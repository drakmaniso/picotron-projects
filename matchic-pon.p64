picotron cartridge // www.picotron.net
version 2

:: design/
:: design/spells.txt
--[[pod_format="raw",created="2025-02-22 10:06:12",modified="2025-02-22 11:40:56",revision=10]]
# Spells
## Direct spells

### Destroy most common colour

:: design/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAyLTIyIDEwOjA2OjAyIixtb2RpZmllZD0iMjAyNS0w
Mi0yNSAyMDo1ODoyNiJdXQ==
:: docs/
:: docs/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTI2IDE0OjAzOjI1Iixtb2RpZmllZD0iMjAyNS0w
Mi0yNSAyMDo1ODoyNiJdXQ==
:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNS0w
Mi0yNSAyMDo1ODoyNiIscmV2aXNpb249ODk1OF1dbHo0APl2AAAX7gEA8xR7WzBdPXtibXA9cHh1
AEMgEBAE8PAsZmxhZ3M9MCxwYW5feAgAz3k9MCx6b29tPTZ9LDEA-1DxHh0dBPBPPxJAPuAODxYX
DxUOIA4XHxYO0A4HPxUuBz0O0A4PFh8UHS8WHR8UDQ4AoQ0PFA8TTQwPFB0PAP8QHQ8UDC0MCy0O
oDIPFhscLRwbDR4RYAIzLVMyHRIBUAkAEP8BYEIsQiEcIXACMy1DIh0SAQkANY_AMS5xHhHwTA8B
Cx0zDwH-NDkhEA8P8AYBIBHwBULwBwIzAgHwBgIDMgHwBBJjEvABAqMC4AKzEsACIxWDAgGgAiMl
gxIBkAIjFZMSAYAC8wAiAXAGAAAk4zIFAP8V00IBgAKzQgGQAqNSAaASY2IBwAHCAeABogHwARFi
EfAEYfA1tAAd8BdNAuACoAIDAsACAwKQAhMCoAITApACIwKAAiMCkAIDARMCYAITARwAYQMRE2IT
EQoAMiGDIRIAEaMQACfzAQUA8QmAAiMiYyIjAnACEwIPGgcBAkMCBwEOAhMRAFEOEQ4CIwYAABAA
MyMCLgQA8CVwAjMiQyIzAnAC8wMCgAJjKWMCYFFTCVNRcAIzAhMCEwIzAqAxIxIDEiMxcBEgAqMC
IBGwUwEvBGLyAB-wAIsBYAHwBBFAEfAEAQNBAwwA8SZDEdAhIAFjASAhUBEjEQABAx8PAx4DAQAR
IxEgAWMRDgcPKw4HDQ4RYwEQAXMBDh0OHQ4BcwwAIAMeKQAADAD-M4MBQwGDARAxYwEjAWMxEAEQ
AfMDARABQDHDMXABEAEjAUMBIwEQAaBBQ0HQASABQwEgAfADASMB8AkBAwHwCwHwj8kAHcAaAgEC
8AoBDxYB8AoLAEELAfAMAwDTBeHAAeMBoAED8gABkAYA8CESMUIxEgFwIQIBDR8PDQEiAQ0eDQEC
IUABEwECAQ4fEA4BIgEOHA4BAgETATABAwIWABYcFQBxEgEwARIBAjYAAzwAAxQAAlkA0hIBQCHy
ASFwAfIBAZAFALEygTIBkAEiAYMBIggAVAMBQgECDABwcgEiAaABEgkAbxIBwOHwTv0AJR8S-QAD
RrABA9ICARUC-QBVMgEiATL4AAMOAAXzADZRIlHrAGAPHB8dDxwCAT8fHQ7vAG3xEy8RoCGwARMR
cAEjEZABEhMRQAEyExFgAUITERABEg0PDw0UAPEiYhMRIg4PEA4yEwEgAZITEQINDg1SASABIhFi
ExFyARABEhEAASIRMhMRUgEQISABAg8AcwITETIBcBEPAFETIQIBwA0A4AIBIxHwAhEQATIDAfAG
-QARAQ8AEUIgACADEd8AEYAKAGIAAUIhMCEKAIICExEiEWABEwsAMFIRkAcA0IIRsAGyEeABghHw
AQGrBDABMhFTAG8R8AkR8EAOAR3wAhYRYBHwABEDAWABAxGwERMCCQDyIRIRcBETEgGAATIRQAET
MgGAAVIBMAFCAaABQgFAATIxQDEyAVABQhMBQAETQgFgAQQAE3AIABCAzAACrwEwMSAxrgEQIkQB
YBMiAbABMkAAAE4CQQEiAUDKARADDwIwYAESXQJxIgECMQAxAmgCAIkBcAESEwEAARMcABASjAEA
KwAwIAESAAI0DQ4NDgDyDbABUgESIRIBwAFSAQIBIwECAdABUgEDMgHgAVJqAVAAAUIBQgcAn1IB
IgHwApHwGicBHbAyIaARoBEjAXAREwQAMDIBQCEBMlAREzECoAEQERNCATABEzKnAIAiERNiATAB
UqQA8RERE5IBIAFyERNiESIBIAFSERMyESIBABESARABMhETAg0AkwIBICEQAQIhEw0AQRFwESM1
AjAgEcDJAEIQEfACygAwBgFCDgAAPwGxAhEDASAR4CFCAQAKADDAESK-AQENAEIhgBFSDQBQEwGg
EYILAPAH0BGyAfAAEYIB8AMRYgHwBREyAfAIEfQDPxHwLw8BHTAakfBqARBTVAEiAzJcAQCgAJFS
AeABQgFSAdDhAZACAVIBwAEDAiEZABCw6gEArwESAjIBFaAQAAAzAQP-ARAABQAxDQ4NDwABCwIR
Mg0CASECATQAMBIBQAUAEAIMAABDAhADVgJhAzIBIAEDWAIREnMCEJAkAAKIAiADMtICNTIBcAoA
QGABA1I6AGFSAVABAyLNAhJAPgAAwwEQA8ECUANCAUAR_AJiAyIRcBEiFAMhsBEdAwAvA09gEfAW
HwhwIvMD5wcAEAgSwwgIMEIjQgQIL-MDAQhBDxgLHg8xAP--SABRA-8jFbUD0NUjoNVDgFVUAwIF
U2BFdAIFJENARYQDREMwNfQBMyA19AMzEDX0AxMSECX0BSIFAAjwASQD9AEiECUTAvQCIhAlEgUH
AP8fFRMF9AIyEDP0AzIgM-QBMjBDdANUQkBDZBM0QmBTNAMCJFKAQ9KgI9LQA7LwFb8ACx8xvwAC
jpUEJSOgtQMFwwDwCgIFNEMwNZQCBUQzIDW0AlQzEDWkAwI0AgTLALAEA4QSBQIkAwIEIg0AkHQD
AgUUAiMCA8EA8Q9kEwIFJCIFMhAlFAI0ExIFJAIlFCIQJRQSBBMSFZTqADAiFbQSAPEBAwIVIrQi
EAUDAhMCBUQCpPgAMVQCpPkA-xtkAkQDNDIQM3QSJANEMiAzdAIkAzQyMENkEgMCNEJAQ1QDEhMU
QmBTBDMGATQxZQM1CAExFAMkCgFxFQQVNAMUAw8BMCUTVKQA8Ac0AxITMDUEAiQjIgU0AjMgNRQC
EzIlFQF2MxA1FCI1FCEBNhIlRCIBRgMCBWQjATUVAxIkATIFAwUmAScUEiYBECRrAAMqAUQ0AlQD
LQFmJAMEAjQTMgFQNAIEI0I1AXFEAwI0AzIUOQHxADQjAjQDAhUCBDIQMxQTUsIAYUIgMyJFAgsA
YTIwQxVEEhUAAEUBHzJEATLwHiUTcBUToEUjQCUjgFUjMCVDYGUjIDUEM1BFAwIFBCMQFTQzMDUU
AgUkAwIAFVEC8HUkAzQSABVEExIgJYQSAAUTNDIgJXQiECMUMjAVEyQDFCIwE0JABTMCAyQiQEJg
MyQy8AMjUkA1gBUAE0IwVRNQFQQDECJAVUMwAxQCkDUUUyADEhAlEyA1RDNgJRQTECVkExJAJSQj
ABVUAxQiQCU0EwAVRAMkIjAlFAMUIwAFAyQDDzAPACEEA5QAQCM0AwR6AP8PBTQSADMkQlAzJCIA
I4JgE1IgA4KAYjBysCKAIvATFwEMD4IEHg8xAP------KvEQIxMEIA8W-xUMQA8W-xQOIA8WLxTz
CS4PExAPFi4DZQIAgy4PEwAPFj8VDwCBPQ8TDxY_A2YCABA_DQATPQ0AHT0NADE_A2cCAEU_DxMN
DAAXDBgAJQwLSgAmDA0LAAoWAAJ4AEU_DAANkwD-AQwQDS7zCS4MIP4ODED8DSD0AAsZMvQAkwUH
BAAnAAcgFwIATwcAJwBAAAscOEAAkRAHIBcQBwAHMAIALxBHPwAcAX8AQgcwByACAA8-ACU-EBdA
vgAkETBAAK8ABwAHEAcARyAHQgAdb1cwN0AHMH0AIyAXEH0AETeBAQ9AACASRzcBAsIAHyA6ASEC
dwAOfwAPQgAbEDeCAD8QFxBAABn-AQcLBAA3EFcAFx86Fw4XDgAFAAN-Vw4ANx4QPpoADCwxNFsA
gBAXMCcPOhA3cxonDjADAH8QVwBXDgBeUAAdBqsAwQAeABcOICcOECceAAMAD1IANJ8XHiAnQBcO
FxD1AClgQBcPOiAnTQBwECcOFwAXHk0AQVcOAC78AC9AHlIAHbJXAFcPOhdORxBXEEMABZ8ALwBO
nwAf0CcgNw86ACcuABceIEf_AB8e5gEsAZ8AAN0ABfQABQYAECDvAB8glQEnAZgAPwA3HqYAMAtV
AHFXDgBHDhAetQAASQFfJx4gLhBUABrwAAoQBBBHMGcQhwAnLzonDowCDwUAEa_HDgBnHhBHHjBO
bwAMHDluAP8CICdQNw86MEcOIFcOMB4nDlADAAFAIIcAh2QAH45dABwNywDHAC4QJw5ANw4wNx4g
AwAfMGAAMAFbACBQJ1sAcTA3DkBHUA4PAC8nIB4BKXEQJ2AnDzpQtABBQCceQAkAIQAnHgQEegEB
ugARTm0AX1AnDmAuYwAc9QOHAIcPOocOJ24nDlBnIHcQhxBMAA_8ACvxBCBHMFcPOhBnDgBHPgA3
HjAnHkBgADMAJy68AAPBAA9hACUDugAnAD4cAQ8JAAU-YC4wPAItAQUAfwBnHgBnDgDFADcPZwAD
oYcOAHcOEGcOIC7EAFAwRw4QV2AAbyA3HkA_IGMAGQ_rCgHALTIzLjA2OTA0NzYxBgADQACTLTEu
NzE0Mjg1BgACTwAKIATyA2YiBPBY-zM38A4O-zI3DzHwDQgATw868AwKAP8FzA3-MTcfOvAO-Tfw
DIkBVzAuNTgzAQAEigEaMhgAD0wYAV5mHATwv4oBDwgAnw8ZAT3REQ4EEL8zMA6-Mg8xIAYAwBAO
3zIPMQAOPzJRPZMBIQ7dBgAfPQ4AB2IADr0PMR8HAK8POiC-MR86MLwQ8g0ZXxEOBPADhwAJUAAO
3QwAdgAaDAoAvxAOvQwgDr0MMLwgcAAcDfYAQE8yMU1pAPQNPREdET0MDzoOfRE9DAsObRFNDAsO
XRFdDAsO3QoAUAAOvQwbBQBvCyC8GzC77AAvCn0AEQB8ABEAfAARAHIAAvYAAAoADvIAD4UPJjUt
ODEqAh455RQPNQD-zPIHKOABAAAOAQAABP87Jw89-ztJDzwPOwQANv87EQ0ABBEAQD3-O3cFABYp
FwAPBAANMP87ZjIAHzNaAAoW0w0ADwQAETb-O6gNAAIRABYPDQAPUwBGEInJABY5EgAPBAARD1gA
ERAhWAAWoRIADwQAEQ9YAA8CFQAQEwUAEHthABAPBQAWAxwADwQAETb-O6YNAA9mAAYgzztbABAG
HgAWrhYAD2AAExBWOwAfBVQCAA9qAAJg-zsHDz2-DQAfPW4AHDD-O1RlABZBEgAPZQAIIBMfYQDQ
Pg89Hzz-OwkPPv87IhcAFmAkAA8EAAkPNQETMP87AQUAFATMABA_BQAWXyAADwQACQ9iABoBmAE-
Pw89wAASMP87bCoAPRUPPiwCD2QACRMHwgACywAWXiAADwQABQ-CABojVg_PAQANAEdYDzwvIwAP
BAAFgP87Ng8--zsjzgAWKxcAD2sADUBUHzwfawBBPw8_H-4BR1QPPE8nAA8EAAEw-ztyZgAWIxIA
AAQAEa8aAB8DagAGGFjVAB9WZgAPAPYCMP87Y2oAFiUWAA9qABEyWg88ZgASVBcAD2oADQAEACSf
OzUAMTkPPXYDALYFET5QBC8PO3wAEAAEABHvHQBBUw89fyEED38AGALtABaXEQAPbAASEw8hAASs
ABAlDwASURgAD3oAFQA4AkY9-ztdEgAPewAYAScBAYAAFTDTAxIBHQAAIQATbwgADwQABTb-O6QN
AA93AA4DegUDOgAQH3YAMRkPPfEAD3YAVCJPOxEHdz--O1cPPi8LAQ98ABcQTkMAHxFAAwYHyAAP
AAELAb8IAeMGEwHoBQ_MAB0Rj0gAEDI_ABZVFgAPjwAkARoBH1_FACUfXmQJBDH-Ow0JABQ_EQAv
DzuqAAMCLQAWq5IADGQAHw_AAAoQStMBFj0WABsPgAAPBAABHj6AAEEtDz0PCQEREFEEED2HBg_S
ACQfen0ABA6SAA8SAQgHmwEUAt8EEkCUAQ_WACNQSA89jzssARAYDgAWDB8ACO8BAN8IBREAHw9U
AAwEDABh-ztQDzxfqwASE5EHD6cAKBImpwMWPtUFFQojAB49qwAPYAIMDHQANP87degBFhlDAA8v
AAYPHAABMP87QkYBGCd3CR8HowALDwQADgh0ADL-O0s4BwEkBA7dBA8pAgEOpAAQCT8AFGNDAR8I
oAAADjkFD6QAGR_hmgAmEDSaABALBQAWHpsAFz0EAA_bAC0BOgESa0cACBoAD6cAFTH-O3A5ABA9
EAUE3AEfPaEAOBB5oQARFw4AKz5PHgAPpQAVEc9KABRi4QE0DQ898QUcPaoADuwGD60AGRA9nQgQ
AfICEkFPAA_uACcSZPwHFzyhAAmlABPPLgAPqQAjQ5cPP49NABNPUQAfD48ACBsPBAAEOABX-zuU
DzyeAB89ogApG2_fBDD-O1upAR89owBAH69BAS4fqZYAQARiAA_aACsTRyYJE89PAQSjAA_rACc4
Wg8-tQgFsAAAHgAXDwQAD7gAKxKZeQMOrwAPWgEjCaoADk0AD64ALRdV_xIMSgAPuwAJH__3ABkO
BAAPcQAfG48oADD-Ox27ABJXsgUMkwAPuwAjAZ4LEEQFAB0fxQAUPS8AD8UAKQRvAArJABIzTQsF
IAYPygAqNv87mhEAD7wAHAGZBh8PuAAWECkmBhpbowEvLzt_ACYHwwARQtYBBCsNAegGDlUJD1wA
Gg-aABsSHQsMFT6SAQ-fADsWmBEAD8wAT0JPDz8vQwVOPf87LyoAD9MAAQ-rBx0P1wBaAJ4JAVkA
AtYVH3EmAAMfD9cANhaWEQAPUQAVDlUAD7YBGxYvKBIQC4YCQQUPPS-tABpHKAAeDwQAD6QAFheP
DAAP_QADQQEPPU89DhZ_GgAPXgAABAQAHzwCAT8URQgEGiseAB8PBAALD5IABg-4ABER7-MAFoYV
AA9dAAQABAAXPhgAD-MANBBeBQAaIhoAHw8EAAcXPQQABBQAD4IAFgiKABZvcwIWfBoABwQAFz0E
AB88_AApDCAAFi8EAAHqARE_JQ4C4wwaICcAHw8EAAcXPQQAHjwEAA5AAA8NAQ8WkBUABwQAFz0E
AB88CAFBMP87GwkBHzQAARcfPQQAAB88BAApBgQBEQkEBEA_-zsqlAAWNSMABwQAFz0EAB88cwMC
DxYBLBEPiwAbTYIADxEBBB89BAAEHzwRAQIPFQJEBAgADwMBPBKRCQAPAgFhH_-_ADkPvQAIDwIB
CgcVChMfrhUvDztTAA4fPQQABB88BAApEy-uAwOKABM2XhQtDzsEABc9BAAXPAgADh4BD-4ABA8a
AREDHwMWMxoACB4ACwQAHz0EAAQfPAQAKQYRARBSigAWLRoACwQACG4ABAgADwwBCg-KAAgOHAAJ
FAETMKgWLw87LgAHB4oADwQAAR88BAApBhQBDjkDCAQAFz0EAB88fAQBBAwAD8kAEA8cAAITLzsa
A1cHFUoiAB8_MgAFAwQAHz0EAAQfPAQAKQQXARHPawkQSi8CFiceAA8EAAAXPQQAHzwgARUO1gAP
GAAHMP87OAUAEhSFDy49zyMADTMAAwQAHz0EAAQfPAQAKQBsAAP7CxA_kwAWMRsABwQAFz0IAAgE
AB88HgEAFD8QAA7TAA8EABM0-ztDcg0eMToAD0oAAB89BAAIHzwEACkUL7QlIq87IQ0BrwEeDwQA
Fz0IAAgEAB48PgIPBAAzPv87kwsBFy8MAAOJAR89BAAIHzwEACkCGwEWnBEABwQAHz0EAAQfPA4B
CA0gAA8EABkWr9gaFAfADh0PEAEPBAAFHz0EAAgfPCQBLxAtjgA-TA89Mh8FHz0EAAQfPC4BGR8v
KgEaH4cxABYfPQQACB88BAApEi8EABA-CQ5GP-87hBoABwQAHz0EAAgPSQJIAh8BD0kAER89BAAI
HzwEACk--ztqrAYDHz0EAAgPEwFCE08EAAN_ChArBQARGyEBLzwPBAALHz0EAAwfPCEBKxaiDQAD
BAAfPQQACBw81AAEDAAPIAABLw874QASJTxPHAESayAGDzYACR89BAAUHzwXASsQD08DFoISAAcE
AB89BAAEHDzUAAQMAAcgAB89HAElJa87NwIfPzoABh89BAAYHzw3Aj0XPF0ADwQAAQnTAAQMAAcc
AAkkAA8EABUTTwQAMf87gfgQD1QBBR89BAAYHzwaASsBsiIQPAUACyUqBwQAHz0EAAQJ2AAEDAAH
IAAXPRQAD0MCEhNPBAAPrQYJHz0EABgfPAQAKQJwDwHQDBQ6CQASHxAgHw8EAAMfPQQABAngAAQM
AAcgABc9FAAPKAESBCQAJU87qCEfaTYABh89BAAYHzwEACkBIwYDTQIOvCcEBAAfPQQABA8lAUYD
bxsfXzIABh89BAAYHzwEACkPiAQFFzxhAA8EAAEMFwEbPQQAGDwEAA7lAA8XAQUfjS0ABh89BAAY
HzwSASsbegYdCwQAHz0EAAgP8wABGz0EABg8BAAP7gABDxsBAxAVMgIWZxYADwQAAB89BAAYHzw2
AmEfPfcAABs9BAAEGAAMKAAPjQAIAVEwETddEQJ6DQxHABYP_hEfPQQAGB88JAGBHzwkAR0RT40A
EFcbARIA8hEFGwAPBAAAHz0EABgfPAQAKQBVDCE973oNEDpxAwuANgMEAB89BAAMDyoBGgewBA8m
AQQUaFYHFhIaAA8EAAAfPQQAGB88BAApAN8HITxvjhoWbBYABwQAGz0MAA8EAAEPIAE2Ey_DCAER
EzY_bzsbLBPvLxkfDwQABxs9BAAPFhIJHzw0ASsSE5A2Nv87cxYADwQACB89BAAAGzwEAA8YAAUP
OAEYFGZcAhUALAEPUgAFHz0EABgfPAQAKQP-HgFvJBBYBQAWCRwADwQACB89BAAEDyAAAR88MgEn
BrQEBjMBDwQABR89BAAYHzwEACUCETMTPTwtLw87BAAOHz0EAAQPIAABHzwpAR0Rj5IAFmkbAQ8V
FgQXPGUADwQAFR88BAAlMv87Ia83Aqs3H1JVAhcXPH8ACAQAHzwUAAQPLAEgFnleEx4PBAAfPQQA
GB88BAAVFy8MAAj7BgNHAhZuFgAPBAAMHz0EABQfPBsBPR89BAAcHzwbASsBFiofbjYAEh89BAAU
HzwTASMXE3c2CxgBHz0EABwP7AACDBgADxABAxAqBQAebSIAA1wVHz0EABQfPAQBIwEGOBpXFgAE
DAAHXgAPBAAVD_QAAgwYAAgMABMPLg8yPu87yQ8BGCsVP1QEEy8EAAMOARc8bAAPBAAFHzwOAQwf
PQ4BBxsIcj4PDgFjAZo-FpQeAA8AATwNBAACMwwBrwQQLnsAHx8BAW0WqhkAC-wAFzxdAA8EAAEf
PPwAHxAWBQAUHgkeHyH8ADsWL0AAAQQAHy8MAAQBsj0BGh8AAh4fL-kAUgFlPh4l3jcOdwAPBAAb
FDy-ABcPBAAfLwwAADL-O7ANABovbgEfPQQAAAQcAA-oACAB6kMTI3EvLy878QBtH29bAg8fPAQA
DQuxACY8D8wFFA3KAhIFLBEiPC85Ci8_b0QACx89BAAZF0-VAAQEABsvDAAAggARProfD-IAEBc9
HAAP8gAWAoAfEh1pOwF0AB4P0TgP6QAmBVYCBFkABAQAHS-pAAGEFhNMQD4P7gAAFzxXAAQEAB48
BAAPswAGEzxcQRZLfQAP5gAxHzzmABUBEwYAajFAPf87KJ0HEg1wAA81CQwePAQAD7AABhE8pSQD
HgoH4BwP6AApBCQAD_gAHRKGZgAPEwoQHjwEAA_mAAIE3gAfSdUABASdAAQMAAdjAA8EAAEfPNkA
GQHUBgPWERM2LEMAOgMTzzgAD1UOABs9BAAfPOcAFxETHQQG1zEP6wBSAXANAEY8Abo-IjxPJwAc
PZ4AB1cAAQQAFi8YAAkEABWPVwABOBESCfwpKT2PVQEP1wAvBagoA0oBAsw0Mv87iGcAH8__ACwC
hwETJUMrD7kAOQXrAQJHGQAGIAUSBg_2AA0LawALcAEBTz8VDQwtA7AHD7gAMgEkBidPO2EBD3ES
ABc9BAAFewAPqwADEzXvBR8voQA3EgWpCAOmABBwXwEfB6sAMRUJUQEWJSsAD1EBMwOxBRJMbQMP
qwAvH3OdADQA8QgDogIVB8kDF1CvJw_nACsQI1kAAd8IFhvzAh7PpAAFBAAaL-MDHz0EAAUAoAAC
VgAEcQABZCMPsgAEHzyyABcTDZQFD60AGAxiAA_tAABBAQ8-b_IZEA22ABgDtgABzkwTNkdFD9AB
Ag_9ABcfZbgAPVstDz7PO2QBDRYMBzMABBAAD6QACwsxCC88r6wAMg1qAA69OQQuAB88pwAJAhMD
Ewm4QS8PO7AAPwFYAR-vsAAYFz0UAA2wAAPMJR8prABCAZ5PJjyPJQAJ5j8EBAAXPQQAHzyoAAcf
ZaMAPgZnBAK7Kh8HrAA2FmF8AAywAAA9AB_PtAAuEx1lBS8PO7QAGxc9GAALtAAQQ1MAGg2BAAx6
Cg9xAS0CFjw4LQ8_uAAbL1EAA0cFFngSAAdDAAQEABw8BAABxUcPvAANDrUtD7kAFANqHQNFABYt
OAEEuQAVTx0AHnQHVhs9BAAcPAQAAB0WAtsFC4kABVgAD8YANQ1JAAAsCgb9UA-TAAMQdQUAEhAO
AAMEABs9BAAcPAQAA5wGH0XTACMfPtMAFBc9HAADSQAfK8oADACDFQK2UQqKBhs9BAAePFsAEwmF
UAzSAA8EAAkM2gAfPNoAJREPqAEWI2xDCOIAFy83ATj-O3RuTBILIgADBAAbPQQAHjywABBZ5gAd
AaEADwQACg-mADkB7woN4gAOJQAyHw8-AQ8ePaNOGz0EAB88KAIBAgsOD_cAGRRfQFQP6gA2EAfV
AR8R7wARH3mJTwMXPQQAHjw2ABIDXQQP5gAaE2_MAB8P0AFbMRkPP3Q5AYYGBxsAGz0EABo8NwAz
BA88ZT4HUhkPBAANAAEEF38QAA-jADYPQAwEARUlDaMAGz0EABo8MgARBdolEz6xDwN1Bg-eABQB
FgMTXxAAD_IAMQSvAgQnLRU-bgwirzsiVR4PMgAP3EUKBAQABBgAAxwMAc4DAaANFjcbAA_ZAw8G
LyEXHxgAD-YAMxQRnAADGw0fD_4AMxYDtAAChQcTGiobDjQKD89YDx9f8gA4AHYCE89AAA-5ABQP
PEoDBAQABBgAAyFRFD2rRBM9Fx0P8QAZA-UAHj3dAg8EAAIfPQQAAB88BAABEa-UAgP4BgX2AA_a
AA0AyBYcPXkPGz0EAAxDCBILMwAkPT8PHx6vagAPBAAOHq9NBQ8EAAUfPQQAAB88BAABAXsFEi8N
AAZrEA_aAA0P-gEYEgqyBRM_wFsWFV0ADnEGD0hbDxc-EAAPBAAIHz0EAAAfPAQAAQX-AA--AUQE
AwIC_gAC-gIfEwMBJwx4AA8EAAEfPQQAAB88TQADEgW_HA8AARwSRftOBRIAB2gABAQAHDxGGAEB
Dw-7AHkP9wEfEF-3ADwWDz2JABs9BAAaPDcAExV1Cg-4AIMOAzUP7gMpBChSCeUAD-EACA09AA-x
AE8OjwAP8QAQFzxnABc9FAAIWAwaGVsAD2cACA1CAAJGAA5PDQ89AAUMBAAfPPoACgReAB4_JxEP
BAALHy9mFB0P_wEuDksLD0AACgwEAB88BAABAQgBD2UABg9SBwsfPRMBAxJuixMN_iEDMgAEBAAd
PBwBDH4BDiABDwQADw6VCQ8EAAIfPQQABB88BAABDSQBD5kACQMwAQxNAB89MAEHAf4nERrbDBA9
sVMbPCsAFz0EABw8BAAAwiUFTAATLxUADz0BJQ7mBQ8EAAYfPQQABB88QQEuDwQADA9pAAIUL0kB
A-kLBHolFkAjAAs-ABc9FAAPTQEmDkUAD00BHx89BAAIHzxNAWgVCiJjFjgbAAs3ABc9FAAPRQEP
D10FCA5JAA9JAZgXPQQAGDwEABYvTkwWOhYABy4AFz0UAAhBBAEYEQFkJgVIABMvHgAPSQEpBEwA
A6MEDwQADR89BAAIHzxRARIOpQAPBAAWFz0EAB48VQEKVxAXPQQAHjyWABEvHxwGmgoTLwQAHw9Q
ARMOVgAHBAAPUAFLHwmpAAQPBAAjFz0EABw8xQAPVAEFHzzkAzkPUQAGD0sBTwKIYg2tAA5xAA8E
ABoPdQAGHy9TAR0HNzcHEgAOBAAPaAGNOAUPPmkAHw9sAYcTDXsOLw87cAFLBAQAD9wCYQWMAQ8E
ABgXPQgAFz0QAA9wAS0WTQ0ADwQAMA9xAA4PdwFPFgFdAAx7AQwQAAcEAA5RAA8oAAcEBAAcPFwA
GW8tCBKIDQADBAAONQANugATC31QLw87BAA2D3YADhYPswAvPA9MABMPBAABHzyQAQoIfAEXL6Mg
DwQAOBc9BAAYPAQACJgBApEAFowNAA81AAUM8hsDBg4Le3EPBAAsD3oADg_cAWEvPA8EADcfPQQA
ABg8BAAOnAERePQ0CRUACz0ABAgADxMxAR0jOgAPBAAtHj1yAA_kASIfPQQACB88BAAJBaQBCAQA
D6gBJB89FAAEDwQAAR88qAEBES_RAB2EZgEINQAECAANgBcMNQAPBAAtHj1tAA_bAeQXTwwAA48s
EVAOAAzwHghCAAQIAA7sBBJftxoCMTYPtQG9H0_7EAQLKgEPBAAVHz0UAAQPBAABCCAAJzwv5AAC
uAESfG0BC3EBFD0xAAcIAA3TOAKlGgs6AA8EAC0ePXIAD1MBBx8PQAADBAgADwQABR88WAANBAQA
Gw8EABcvDAAPBAAQHz0IAAgPBAAFHzxwAAEICAAPswEmEy8cKwNbHR4R4wAPBAAwHj1_AA8EAAAP
XwEEBzwAHz0EAAgfPFgADQQEAB8PAgEAHw8EAAMvPQ8cAA8ICAAPBAABABwAHz9wAAEZL4IBQSAP
PN-oBB88yAEKBAQAHDwEAAJGABYcxigTn5EiBB0ADvsADwQALg6NAA8EAAgXLwwAC0QABAgADwQA
BR88BAAJF08EAB8PBAAbHz0cAAwEBAAMEAAIGAAP9AASBeMBAmUDH0njAQIEBAAPXgAGAkYAFB9G
AAeIQg78AA8EAC4OhgAPBAAIFy8MAAtEAAQIAA8EAAEfPAQADRdPBAAfDwQAGw5kAA4cAB89EAAA
BBQAD-QAFiMvO5olD9gBLB8h1AEUFy8MAA8EABAbPQQAFzwIAC88D2QAGwhAAA8EAAEfPAQADRdP
BAAfDwQAGw9kAAUbPQQADxQABR889AAVFE9ifA-LAQwfPEUABQMNAhIKDgAfTz4ABBYvEAAPBAAR
Gz0EABc8CAAfPI4ACR4PBAAfPQQADB88BAANF08EAB8PBAAbFz0EAA8UAAEEBAAfPBQAAQ8EAB0U
T8sBH0_7GwQPWQAJES89ABI9CQAXLxkADAQADhwAD2UAChs9BAAXPAgAD2QAHR89BAAMHzwiAREE
BAAfDwQAFxs9BAAPGAAFHz0YAAQfPAQAHQQAAQ-OAXofPQQAAAggAA9kABUfPQQAFB88BAANE08E
AA7EAA8EAA4bPQQADxgABRs9GAAfPAQAJQ3SAQ9rBQQfPGkACQXWAQgRAB4PBAAPHAAOC2kAHz0E
AAAIIAAPBAAVHz0EABgfPAQADRNPBAAOyAAPBAAKHj0EAA4cAA8oAAUPBAAlFi_0ABE94gEO3gEP
RQATA3xAAdwwGgcbAB4PBAAOHAAPBAALHz0EAAAXPAgADwQAFR89BAAYHzwEAA0E6AEfDwQAHx49
BAAOHAAPKAAFDwQAJQRwATL-O4AJAA_9ACEAC0QvPc-GAQoPXQAeHz0EAAAXPAgADwQAFR89BAAY
HzwEAA0eT9wADwQAGR49BAAOHAAPKAAFDwQAKg-mATMfQeIBTgQEAB88BAAYHz0EABQfPAQAEQ-i
ASAbPQwADAQADhwADygABA8EACkUL4wmAE0AAq4QDo4BD_cBHw8EAAMPXQAeHz0EAAQfPAQAHB89
BAAUHzzAADwIBAAbPQwADAQADhgADyQAAA8EADEBX0QP5gEnEjmWMh8PJgEzHz0EAAgfPAQAHB89
BAAUHzwEAA4OzQMPBAAZCGgAHj0EAA4YAA8kAAEP7gE3EF3ZAx8S8wEpAaFAA3UqD-QBdB89BAAc
HzwEAFAIbAAfPQQAJB885gM6D_8BIxZDDQAP6gEkFz0IAA8EAAUfPAQAFB89BAAcHzwEAEAfPRAA
ABs9DAAPBAAVHzwEADUXLwgAA8t2H2DzASUBD1ID50sP_AFUD4MoDR89BAAMFz4MABc9OAAOXAAP
BAAnHz0QAAAbPQwADwQACRc8CAAPBABCEi8WExM9o5ofWAACIxZPwSQPBAIMD9IPDAj0AA8EAAUf
PAQAFB497AEPBAAOHzwEADwePRAADwQAGhc8CAAPBABOAZsJAZJ9DwQCJwdWEw--AWAbPQwADwQA
HR88BAA4Hz0UAAEPBAAUHjwIAA8EAE8CBwQWdhEAD-oBGQDSCwn7gw-6ATwfPAQADBs9DAAP-QMd
HzwEADgfPRQAAQ8EABQePAgADwQATwWeEQcEABw_JgYbD-IBE582lgUVAA-yAXgPBAARFzwEAAwQ
AA8EAB0fPRQAAQ8EABQXPAQADBAAD8cHGh8PFAALEj7qAQHlAw_2AQgP7wEFAo94AdiFB1RiD-QB
nAxAAB88BAAoFz0EAA4UAA8EAAcbPAQADhQADwQAFBsvqgEIDAAEBAAD8DkBSmEWLhcADgQADj8A
AhwsEj2QKwllFw-1ARwI6QAPBAABHzwEAAwbPQwADwQAIQhAAB88BAAoFz0EAAwQAA8EAAUePAQA
DhgADwQAFRsvqgEIDAAPzwUJDdADDOcBA0WkHy-nAbIPBAAlFz0IAA8EAB0fPAQAORcvpgEeb_8B
AWgNED75ogEWAA-oAREs7zuWph8r6wFODyY1BRs9DAAPBAAhHzwEACwXPQgADwQADRc8BAAMEAAP
6wE6CLEBBBwAAk51EjusZAUaAA8EAAEdT85HBdcDHy3sAU4PBAARHz0EACQXPAQADBAADwQAERc9
CAAEBAAXPgwAFz0kAA-EASYfDyQAEB9PqgEABBwAAyYXAVmSFiobAA8EAAEIPwACYUkP5QEwHz0E
AAgfPAQAGB89BAAcBIkBFzwEAAwQAA8EABEfPQQAFB88BAAlFy8MAA8kAAkfT6YBAAQcAAPlARZW
FgAPrgEJAw2qAdhxA_QrD90BnAQEAAxAABs8BAAOFAAOIAAPBAARHzydAQ0bDwQADKUBDxkRBA-R
AQgOi5cPzAEEFAiUNgqbVg-LAWEfPQQAOBs8BAAOFAAOIAAPBAANHzzDAQkEBAAPMAEULzxv7wEI
AydUFmYSAA-EAQsvCQ85CS4fPQQACB88BAAICE0JHz0EADgXPAQADxQAAQgcAAQIAA8EAA0fPAQA
BQS8AR-PJAAMH29UAQQP2wwOGG_vOy8POyUACw8EAAgfPQQABB88BAAYEz22AR89BAAwFzwEAA8U
AAEMHAAPBAARHzyCAQkPpgErAcI7FkwSAA8EAAEGqwESIQUIDM1hLjwPYAAPBAAJHz0EAAQfPAQA
GB89BAA4D1QAAR88BAAAHz0EABQfPIgBBQuwAQ8sAAITLzY8HG8eEi7vO9FOD1cDjg8EADUPVAAB
HzwEAAAbPQQADxQAAQQYAA97AQIPUwMNF0_fARIvLlMlPW9BoxZaKQAPngHdHz0UAAAIBAAePQQA
DxgACg0EAB8vngEUF49EARYvvJASBBIAD5sBDwLwhy88DykACQ8EAA8fPQQAAB88BAAYD5QGMRc8
BAAfPQQAABc8BAAePQQADxgACg0EAB8vnwEIG4_XAQ8UpAkkPI_GAR9PbgECD54BCwMEAB89BAAA
Fz8gAA8EAA0fPQQAMA5MAA8kAAQPGAAgDQQABHoBAiYWC04BHI_rDgDOYBGPrxIDp7kPTAMFFC9z
chMPDQAfD5QBBADyYggQAA8EAAQfPQQAAB88BAAYGz0EAA8iAyEPTAAFGzwMAAgQAA8YABUNBAAf
L5gBARevlAEDLXIfZoQBBwWGwB4vgAEPFAMhBDQBHzwEABwfPQQASB88IAAQBAQAFz0EAB88BAAB
Ey8EAAJyEwP0AgFeRjL-O4oSAA9oARIEGQAfD4AELx88BAAcHz0EAEgfPBwADAwEAA8cAAYVT2gB
AkyMARUABCUMDz0TAxNP2x4nPE8RAB8PYAHTHzwEAAEPIAAFGG9cAR_PuwIFGE_OMQ9LATAfPAQA
IB89BABIHzwYAAUPBAAZBEsBFM_6DhyPm08Sbz4BAb4ZBRUAFy8MAA9PAVgePN4GDwQATh88TwEh
BJoCHT5LAQNlLAvplA9QAQEEDQcfDwQACxc9BAAfPAQAJA9UAVkfPAQADB89VAEHFMifAhY-NgET
LyYADzoBbA8EAEUbPAwADwQACQ86AQgBaLsShJEPBR8hDjsBD0MB-wpDaw8935KcJz3vIgAPBAAR
F48MAA96AAgEBAAfPAQAJB89BABMGzwMAA8EAAkPSgEIAVpaEEGSAh4LJGYPTAEdHz58AAQEBAAf
PAQAJB49BAAPIwU6CGgAHzwEAB0YbzkNAy2kFpUfAA8EAAAfPt0DKB88BAAkHz0EAEwfPAQAKRpv
diAQRY8CFBIOAAZeqQ5fAg9IASMOSAAPBAAbHz0EAEQfPEgBMxsHRAEDsSMSkUgBA0wBDgQADzoK
Ew_sAAMPWAAQC0AADwQAPR88PAEzFS8KBRwi3SYC1AMfPTgBiBc_DAAPBAARHzw4ATcUS64DGCRz
AhNTW4cvDzsEAAcPvwcFDzQBGBc-DAAORAAPBAA3Hzw0ATsBQy0VK8IjFABDAQtgzg-tBCAPbQIt
CEQADwQAMQhUAB88BAApAAV_AMEaADTKED0EAABgOAJTzy8POy8Bkg_kAw0XPAQADBAAD5wAGgA0
PQIoEAwAYw8fAWEISAAPBAApFzwEAAwQAA8fARwVbIjWPiAPPLEjDz4MHx89KAEGD5AAEAtEAA8E
ACUbPAQADhQABwQAHy8MSREBHn0DGMoUMaMEE0A8AS8PO1oCJh89ngAFHy_aABALRAAPBAAlHzyt
BRUfDwQACAAfXhI_okATPatAAFgtAipeJA896A8L7hoPZAIgDzIBDhcvFAAOPAAPBAAuFzwEAAwQ
AA8uARYApAAB-zM4-zs06oIxGg89fKQBPycXbzEADy0BcA4UAA_TDg8XPAQADBAADy0BGgImNxRf
XgIWth4ADxoBHBc_jgAfPW4ABQQEAB8PBAADGz0EAA4UAA8EAA8XPAQADBAALzwvQwIWEm2okAC7
dSE9r90VDtAsDzUCOg6XAA04AB49FAAPBAAWHzwIAAAPgAAVBxcBEmerYjb-O7UaAA8SASwePGoA
D0IBDh49FAAPBAAWHzwIAAAPCgEgFBNLcRAhHQIQL8AGFo4kAA8UAWAePBQADwQAFh88CAAAD2IH
DQmcAAdCrRKLSJ0TPqFFA2pyDxUBoAQEABc8CAAPFQEeIg87UgwDijwW-4XdDVMADw8BGA8jEBkf
PRQAAQ8EACQXPAgADyACIBEXSU0QPlOnED3G0yU9D4AjDycCHB8PqAMEDz8RJAgEAB89BAAkFzwI
AA8cASARjVGYAUUcBEsHDgQADyoCGw2OAA8KATwEjQgMBAAXPAgADwoBFiVvO7LhEH0FABZSGwAP
AwGIDwQABQRAAA8DASABNB4a-5uND-sA1BWjJq0WFRsAD-8AZAREAA8EAB0fPP8AJwEiBgHXmjJJ
Dz-IxBZyJAAPCAHRBL8jBXbpHD-Tcw8DASEfPAMBdB8_AwENAgoGE-9-Jw-yALAP9QEKE0_8lwQl
nwo-Cw9PAAYPUwAEHz3vAJMBBqISDeQDEz5qqxBQCgAOpEYP-gAmD7MgHB89BAAgHzz6AB8BxecQ
mgUADnZRD_sArhMv5wARj_sAEH3WARUfeOEeSgKGD-QAHAxsAB4_JAAPBAAKHz0EACAfPJwACR0v
9AARnZUAAb9gJj6-yQgeDzsRD-0AHg-xAXEF-48G8gASbeAAAUUwAAQAAgiZEj0g2QU5AA-xAKoV
j_0AAW1TGLNTFRE89gAvPA-oALEBgA4w-zufuAMBwkAUCMoBATvWEhH7AR8P4wCrECXLAAGbQQGb
BBVcnBoeHKWVD0AIAg-bAIAEfAADaxsRk90XIj9PsI4CJBkHS3AQDBMAFgE6AA-qAFAXPMIADwQA
FR88fAAJEk-wcgS4uRGMpp0TPwHtEhSvAx8P4ACkFW8LDQUQsxKC41MjPc8coR8P2wAPHz7bADgX
PLcADwQABQgoAB882wANAt8AGAtJBRP6IwcPugEtHi_DBA8EABUfPQQADAgoAB88BAAFE29jATb-
Ow6vIwGsmQFjgRE9CTMDQwcPSQAKD_kASATFAA8EAAUePAQAD_kACRUQaewTieyUBCMIHw-gAGcX
PMwAGz0EAB884AAVAZEMA5Q3Af_jAbySEgdsqg-iAK4TD6YBAIQAA6AsEi_IDgN4ERJSnQ0P6QC2
FS-XAQGOAxCXBQAfTt8ARxcvDAAPBAAIFz0IAAgEAB882wAjAQqtHv_2AR891wBcCHgACAQAHzwE
ABkIbAATb9z7AllBC94AHzzeAGQXPNoAFz0UAA8EACIC4gAv-z-eAHoEBAAP3gAuAwwPMY8PPVIF
AugZExHYWA-xABwfPvEAkSUvOyUuEn-iGwIsHz9IDz3cAS0TbwgAGw8EAA4UAA-vADofPWwABQLr
ABQfJiIBwRoSKWgMEj6aCxZqLQAP9QApHw8EAAIOQAIP9QA4KzwvCAAG8QABSA4u-yNtCw-fALEC
4wAQAdABEpmqHgYHqw-oAEkOIAAP3ABFEwVrGhIvgR8QP48WAFcAGT2Z6RMvCAAP5AA5H4-gAEQV
T9wAM9EPPg28A-dACCcAD8sAmxNfQv4BkRIJSUAELAAPJgYFD9AAIQ5GBg-MACMTLxwBAAgAAyBW
EjVVCwMXDhQGCQAHdkUALQAfD6EBPAjRAB8vzQAgE2-JAAPFADEzDzyBCQOOAQN0tw9hAAQPwQAu
ARQQLw87BAAbE28AbwIhGBY9VKMG0cQPrABBFA9tEy8PO7AAHxNvrgEBRgcRb0oAExETJALpEh-I
uQALF_8MAA_1ABkvjzveOyMGsAAByBsTN80JAroAH7SsACcTD1gAHw8EAAQOEQIPrQAaFtuFCSc8
L3MAD58AYhOvVQATL_cERj7-O9oSAB8PlwBxAnwCFAsGswHsAQEOGAHHnBJmJQAfD6oAFAgEAA_u
ADITz6YAA5kAL-81kABsAgvEAQUAEqgCGyM9r6MAHw_UAF0TL-wCM-8777IFHS9DAB8BhABIFU_A
AAHkDRIZhaEhPm9IAhFoO9MBAYsBfgQOmwAfA5cATjNlDz_QHwWKBw8IsgAPigBLAyf6EHUFABIM
DTsCCTsaU4oACcYJD4YAHRKvfisrPA8EABUvhQAU-AEBH1V3ADgCD4AeAzEAE0--AlP-O3sPPjDD
DXkAD0cHCBdPDAAMBAAJcgEZb20AEFvwARSD0wQSNk4ZH091ACEMIwEUPREAGY9xABVFLQUTXl0C
Ew8oAA9qACQaCWYAAUzhO-871h8AGw9AAA9QABID5A0S4BIAD0MAFxQLPwAQZz8AG-8fDhdPPAAV
TzQAEA0FABv-v0EXTyMABisAATYEIP9vBgAWCXsAF08kABFPKAAv-7kaAAY1Eg89c0MbT8QAAiMA
AQgW8QTPLGZsYWdzPTAscGFuX3g9LTgxCgD-D3k9LTI5LHpvb209MX0se2JtcD1weHUAQyAQEATw
8DUA-1wxKCgE-7MBlwQDJtAYHXIDEhTOBQKGCwNpAgHUIBIC4QQCAwwUDPkBEzDAiyRfO5CRAUAf
ExfWAwAgBwODshIRQAAAEEcTj1ixKD87sAUFSkMB864VF0cAFQwhGxMq-yUkvzt-AAUpIxIHWgAB
ZwABjgYB5gAEUAACxAATP9dIAbIEAEoHAfMAE1-sszv-OyRNARMwSwESMEkBHDZJARSv1qcTDwEM
BXQAIW87bgACcwMBIwACfAADDgACdAEFLgAFSAAD7AASEl8ZBiEAIn879AADqx80Bg89sAEABAAG
yEATFTkBFJ_aCAD3ACE9X4kAE1AFAQC4AwMhARMI5r8V364AFEdoABYN4bcBhgASL3IBEj0_ABUe
GgIUMdoAMwAPPQUiEi4uABF-UQAUDUQAEQ7YDATiAB8BagEcAhMNEjF_AhSP1wQlfzvIAgGA2hII
zQEB_gADkAIDJwYUPbMGEQgJAAPYABIEJwAZf0QBEBCTAhMvkwIWEBoABb4ABBQBAZcKFb9nADQE
DzyXAgLDCgGWCBMLhCABRQEGRwASBXYAKW87owIVILYBFQsqAQJpAwSTAxBbBQASIVIDJT87KgAS
BTYCBCcoEgtsASWfOxcAHyBwARwjjzt8ACUvO_sBEgIuAQGdHhN-hwEUzw0EBeAABWMBACK5AZcY
ARsBAZUAAwoAFQmBAhUcHgAVDPgCEy0uAgBxAAFjAQOlBBICPhEB9wATz3oBJb87SwASAPQAE89S
ASTfO48AEAUnAAhnBAO7BAR5AwAMAACFAAI6AyJ-O38AIjzfrzkBowEDrgMVA2EBFQVrLBUGv5AU
BKkBEwr4Ai_vO3UBHAPNARRvhgARIjtCBOEABWABASsCEAJlABUeTgEVMH4DExJEAgAZBAMYPxKD
cQUBCwEHv0MDBLoBvx0DHAARDBMAAkXuAVMBE39lAQd6ABM0SAQDfwATLDABAzgkEB8YAg-4AB4Z
bEsEQwEPPJ9XCgF0AAJ9ABgT6iIB4TASARsAJb87BwEUC9MAEEIgABUOVgUTAcQBAt0AFJEQAQXN
AxUAAgEVM9QGAZICEDowABcAiAAHbQATNgkBE79X_ATBAwHBAh8uBAEeExk8AiVPOxUDAVgCFQZs
AgGhADMPDz1-ARIdnQIlrztPBgUSAxIRSwEnDz0nBwM1ARQ6JAAEUAMibztvATT-Oy5NABUCPgEV
LVMCFQyWABUckwIVCToDFQseABI0_gMjzzsLBACEAAE_AQBDAAFDDSSPO7oFFERSBBUCZQQfGjgB
HgGHIAOMPxSf7QAC4wAB_wQTBi0GBjMFEgO1KARUBRUF3wAVBUAIFAFDABkWwgADtwUKFwAl3zsC
ARJGNwAA4gADDwETMlUCC3ECA3oGFJ8mAQpSAAO90hUmigMUIDIBEgJ3BQOPRx8eLQEZ8BMdHQTw
MsnQGcsZoAkMC8obCYAJDPoBCwhgCQz6AwkIUAkLBwDxAEAJC-oFCQgwCQtaGUoZWgoAkUoJHAkq
CRwJSg4AkzoJPAkKCTwJOg4ANUwJTAwAE6wKADNKCYwuAFtaCWwJWhQAVUoJPAk8IABTHAkKCRwk
AFFqGSoZagoAAIUAAIwABpoA-wZgCAn6AQkIgAgZyhkIoBjJGNDI8DIBAQseNQEB8Q7O0B7PEB6g
Dg8RDxDPDx8QDoAODxH-DwEPEA8NYAsAggMODw1QDg8QCgDzBkAODxB-Dy6dDg8NMA4PEH0OHxEO
jQ0AEI0NABV9DQBFLxEObScAHz8NAAQ4bQ5PDQAWP0EACw0AFi9oAA91AAcznS59pAAU-bcAAQkA
EGAJAP8BAQ4PDYAMHs0eDKAczhzQzC4BIGDPE9AezxUvAXAWDxXPFB8VLwGRFv8UAQ8VDxJgCwCC
Aw4PElAODxUKABFACgDDBQ4PEjAODxV-FE59CwBjbQ5PFg5tDQBjXQ5vFg5dDQBvTQ6PFg5NDQAo
CU4ACWgAFX1-ACP9BZ0AFP2wAAEJABBgCQBPAQ4PEigBLVAY0B7PGigBcBsPGs8ZHxooAZEb-xkB
DxoPF2ALAIIDDg8XUA4PGgoA8wZADg8ajxkujQ4PFzAODxp9Di8bDn0NAG9tDk8bDm0NAAFjXR5P
Gx5dDQBjTQ6PGw5NDQBvPQ6vGw49DQAOEE1oADUMDiw4AERdPgw_UQBUjQ4MDo0MACMujaYAFP25
AAEJABBgCQD-AQEODxeACx7NHgugG84b0MsxASFQHdAezx8xAXAgDx-PHh8fMQGRIP8eAQ8fDxxg
CwCgAw4PHFAODx_PHpYAyRxADg8fnQ6dDg8cMAoAb40ODyAOjQ0ADm99Di8gDn0NAAFvbQ5PIA5t
DQAbCUEAJI0uoAAU-bQAAQkAEGAJAE8BDg8cXQItUCLQHs8kLAFwJQ8kzyMfJCwBkSX-IwEPJA8h
YAsAggMODyFQDg8kCgARQAoAwwUODyEwDg8kfyM_jQsAVG0OLyUODQAQXQ0AE50NABBNDQAYrQ0A
OD0eTQ8ARi0ODA4RADc8LhwOABWMDABVXQ5sDl1tADNMDm0MAAGJAwEKACP9BaEAFP20AAEJABBg
CQBPAQ4PIVgCLVAn0B7PKSwBcCoPKc8oHyksAZEq-ygBDykPJmALAPALAw4PJlAODymPKA8mjygO
DyZADg8pnygPJp8NABwwDQAAJwAjDyorAA8RAAKUfygPJi8qDyZ-EQCUXygfJk8qHyZfEQCfLygv
Jo8qLyYvIgAGDUQAD3cADw_zAAMTQCsAI48o5wAC8QARYAoA-wIBDg8mgA0ezygeDaAdzh3QzWIB
IVAs0B7PLmIBcC8PLs8tHy5iAZEv-y0BDy4PK2ALAIIDDg8rUA4PLgoA9AtADg8ufy1PK38tDg8r
MA4PLl8tHytPLx8rXxEAlE8tDyuPLw8rTxEAmD8tDyuvLw8rPxEAnx8vHysvLx8rHxkALxBPbQAI
FQAgTy0mABEvMgAFhgATbyoAH28RAAomDy8EAAUZAAXwAAD9AAwRARFgCgBAAQ4PK4wBHy2MASeU
LPkJMAkM_wUKMQkPBwATIrosbQlCugwKDAoAE9oIADhajFopACo6rB8ABjEAKbosKQAPBwAPrwr5
BggwCfgI8CzlAB4w-gkwmAlCEAUPD-UIT-8PBQ4KABtvnw8PEZ8PDQAfVA8PDxF-EQATfxEADxUA
DzVPDx8VAAIEADYfEU8dADcPER8dAAAMAAcdABM-GQAWPxUADtIADwoAFjAP-gYIAB-9eAEhIP8T
eQFiFv8VBQ8URQkG2QkPCgAVb58UDxafFA0AAVZvFG8Wbw0AWg8WTxQPEQBYDxQvFg8VABNPEQBa
LxQvFk8qABpPOwAWzw0AHj_AAA6NAA67AA8KAAxfFP4GDxJYASUQGFgBYhv-GgUPGW0JT-8ZBQ4K
ACWlXxk-Gw8ZPxtfGREAcw8bHxkPGw8IAAkZADMPGR8EAAsZABpvEQALVAATj1AAH48RABcNRAAO
vQAPCgAWXxn_Bg8XbgElEB1uAWIg-x8FDx6vCU--HgUOCgAlpV8ePyAPHj8gXx4RAHMPIB8eDyAP
CAAJGQBTDx4fIA8IAAkZAFQ-Hg8gjxEAb08eryBPHmsAAD6PIF8XAF5-Hk8gfxcADwoAHl8e-gYP
HFQBJRAiVAFiJf8kBQ8j1gkGbgoPCgAfZV8jPyWvIw0AWg8lHyMPEQA6DyMfEQAW3w0AOE8lnxoA
ES8vADovJV9AAAoEABxfMgAaLxUAFo8NAA6xAA8KABZfI-4GDyFiASUQJ2IBYir-KQUPKOEJT-8o
BQ4KABtWnygPKp9xCrYvKg8oDyoPKC8qXxUAABEACgQACR0AEy8EAAcVABaPDQALYQAfjzwADgZm
AAQEAB9foAAKCWEADuMADwoADF8o-gYPJoABJRAsgAFiL-8uBQ8t0glP-y0FDgoAOVZ-LU8vfy8K
Wg8vLy0PEQATDwQACxUAGi8RAC6-LVEADnIADwoAIl4t-gYPK0EBD5oKJV8K_wMKCRAAhw_iCkNf
Lw8PEB8EAAIDIQAvHw8EAAMfLyEAFg9jAAcPhAD-5A-9C05fLxQPFR8EAAIDIQAvHxQEAAMULyEA
Fw8VAAwEAC8PFGcA--8aD5ENTi8PGQQAFQ8xAP---2kPJxBYWS8eHx8fBAA0Dx8PjQ8VDxUACAQA
D0QA-1MP1hBOLx8jBAADFC8oEBcvFQAKBAADIQAVDxEADgQAFA8lAC8fI2cA--8RD2ASTi8PKAQA
FQMxABUfEQAPBAAHFB8tAC8PKF4A----Dw-AFE4vDy0EABUfDjsA--8RDyQWKZ8M_wcKMAv6BwkF
AAPxDposmgkwC3ocKht6CTALWgsMahtaCTALOgsMqhs6CQAoygkIAF9KC6oJSggAAFdaC4oJWggA
OWqIamgADwUAAD8K_QfRACEABBZABw8PMIQTPwcPDggAGGGvDw8Rrw8LAAN4IC8Onw8AAp_PDw8R
Lw8PDo8PAAIhfw9gICUOfw8AFxEPACFvDwQALw5vDwACIV8PTwAvDl8PAAJBbw_NbgkAL-4HBwAM
Tw78Bw08ASFwFv8VBw8UMNQRPwcPEwgAGGGfFC8WnxQLAJJ-FB8WLxQfFX8PAJJfFB8WbxQfFV8P
ABA-KyBiFa8UHxU-EQAAXxJf7xQPEy8PABGVPxQfE68UHxI-XABlE28UHxJfegB0Ey8UHxJ-FJQA
PhKfFK8ADwgAD28U-xMHDxJBASFwG-8aBw8ZMBEPPwcPGAgAEGBvGV8bDxqyKiFvGREAEV-BHwEI
AAAPAJ9PGQ8arxkPGE8PAGMlF0_WAABfIBMXlgCObxl-GA8XbxnTAA8IAAdvGf8YBw8XVQEhcCD-
HwcPHjBjDj8HDx0IACBgbx5fIA8f5iohbx4RABFf-B8BCAAADwBhTx4PH68eCAAADwAgPx4PKzUP
HD8eAGUdrx4PHE88AFMdjx4PHDwAAFIAQ28eDxxaAJJ-Hg8dTx4PHH8PAJKPHg8dLx4PHI8PAECf
Hg8d3BASnw8AAFYALq8eswAPCAAHbx7-HQcPHEUBIXAl-yQHDyMwvAw-Bw8iCAAIEa-6HwELABOf
rB8Snw8AEo_mHyIkjw8AYX8jDyVPIwgAAA8AYW8jDyVvIwgAAA8AE18pAB9fDwAnJSFfWgBlIm8j
DyFveABTIk8jDyF4AAA4AFUvIw8hj7QAECI8ECSfI84APiGvI_kADggAbyP-IgcPIVsBIP8B-ykJ
MP4HDygPJzAe-ygFHwcABZBvKD8qDg0ObygNAOBfKA1sDydcGzAeXA5sCwgAV0wOjAtMCABfPA6s
CzwIAAAMKAAEQAAESACdbG8mbBswHvwFBQB-Dgz7BzAO_1YHISH-LuQAny0PLDAe-y0FHwcABUBv
LT8v5AAQLQ0AaF8tDWwPLJwADLwADNwABAgADCgABEAABuQAHyvkADrwBh8cBGD5AcAJDOsKCLAJ
C_oJCKAJC_kyEpAHABKA-jITcAUzAq8eFVCfMxJAQzMVKkMzE0qfM0BKCQggHAAAnzNAWgkIEAwA
EKwKAPECAAkLegmMCXoJCAkLiglsCYoTAFFqCYwJaicAEWqeMxFqPwATap4zApQzUnoZKhl6lzMC
hAAABwAZYKAAGYC8ABGg0ACvsAkK_QAIwPgBYBgBHYD_AcAODxHvEFgfULAODxDv5BwRoOQcAN0y
FZAKABWAsDMVcAoAFmC6MxhQRTMALjMUnQ0AETANABIvUjMRIA0AEj8aABgQDQARAA0AIE8RMC8U
DRkAE60ZABCNDQATnTMAAQc0E61NAAGsMxWdZwAIgQAkLn2wMxQFsDMEvwABCQAUgMIzFJAJAAD4
ACDtDgkBbw3_AAzA-E8BHyD-E1ABIBbvfRswErAO3whBDg8SoEgbAAUzFZAKABWA0TMVcAoAFWBw
GwA-MxJ-2zMAUzMQfXMzBugzEm_AMxEgDQASjw0AGBANABEANAASjzQACAwAHAAzABB9TQATfU0A
CWcANI1OjdEzBJIAJP0F0TMEuAABCQAUgOMzFJAJAADxAE-tDg8SSQEoEBhJASAb74kYYBewDg8a
740YEaCNGAAdMxWQCgAVgPIzFXAKABZg-DMYUPwzEUANABZPCTQFDQAQIA0AAPwzAA0AERAWNBKP
FjQRAA0AEq8NAAgMAAAZABBdDQAVXTMAA-szE21RAFNtPgw_bWoAU50ODA6dgwAVjZoAI-0FrgAU
-cEAAQkAFIAENBSQCQAA_gBB7Q4PF1IBPwvA_1IBIBAdUgEwIO8fowhQsA4PH_-mFxGg3BcAQzMV
kAoAEYAKAAAdNBZwHTQVYBM0FVAKAAIxNCEPIA0AGDANAFAgDg8frQ0AUa0ODxwQGgASLxoAEQAa
ABIvGgABGQAWTxkAEI0NABONMwAFDQARIA80Q08gDn1nABCNQAAEEjQCHDQBEzQUBRM0BLwAAQkA
FIAlNBSQCQAA9QBP7Q4PHJ8CKBAiTQEgJe9yFmAhsA4PJO89FhGgPRYAZDMVkAoAFYA0NBVwCgAV
YGUWAJ4zAz40ALIzGH0xNBRtMTQUIA0AVM0ODyEQDQAgPR77MxQANgAAPjQAAjQBEAAAPTQTfR4A
U20OjA5tOQBTfQ5sDn1SAFN9DkwOfWsAJI1OggAU-ZYAJP0FNDQEvAABCQAUgEY0FJAJAAD1AE-t
Dg8hmgIoECdNASAq76YTYCawDg8p76oTFaBQMxWQCgAVgG4zGHCFMxhgnzMcUKwzE5-XMwERABww
EQATIBEAFC8RABEQLDQCPTQBLDQSAD0pAV80EF8RAAF7AAIhABSPIQANQwATr2UAGK9lAAmHAAAi
ABivpQAOvwAZYPAAAgoAH4AYAQAUoDUBELDVFF8ADybA-YcBIBAshwEgL__IEmArsA4PLu_MEhWg
SzMVkAoAFYBpMxlwczMFlDMcUIQ0EUARABEPhDQnXy2VNBSvlTQTICIACFI0ASoAHxAZAAUTAB80
CBkAAR80B0g0BUw0Ai0ABoM0FG9bABOPKgAUj4UAE38RAAXqKSZ-LX80AAQABXY0Ce8AArATH2Aa
AQAfgEIBABSgXwEQsOETPgAPK7EBD9QKQyH6BV4KIsoscApCygwKDIgKQfoADHqdCjF6jHqvCiD6
C78KImqsvQoFHwAw2gwKCgAWIEQAL-oHsQqaAr0nGFCNNCRADiAUA0kKBQ0AAGMKY78PDxG-D30K
Er8tFAI4ABMAKwACUDQDMwAPFAABACkAH2_zNAAUb1cAH2_zNAAUb4EAF1_zNBRfowAz-w8HugAG
0QACCgAfYPkAAB_AIQEAFKA_ARCwyShfAA8NwP3xCmsFMTQAdQpjrxQPFq8UjApjfxRvFn8UpgoT
j8s0I48UxAoXj8s0I48U5goXf8s0ATsAA2EAAMo0FJ8lAAA6ABbvRwA0Pxa-ZQAJfwAFDQAZQLAA
AgoAH2DYAAAfgAABABSgHQEQsEwnXwAPEsD9FwthAswjFVAKAACQChNvSjQjbxmtChNv2jQTDwgA
I28Z0gobf_I0I38Z-AoTf_I0I38ZGgsTj1QAIo8ZNwsTv08AFL8hABOvEQAUr0MACREAHyCXAAEz
-xkHsgAMxgAfYO4AAAICAQoWARSgMwEQsM0kXwAPF8D9SgtXAgoAFWBOIxVQCgAAyAoTb-k0I28e
5gobb-k0I28eDAsTf-E0BPk0I38eMgsTf-k0I68eUAsyfx6vHgABagAVCxYAFo80ADP-HglXADaP
Hk8zNTP-HgeYAAysAB9g1AAAH4D8AAAUoBkBELA1JF8ADxzA-WgLawIKAADlCmNvIz8lvyP8ChNv
EDUjvyMZCxF-GBVDHyXPIzYLABEAM-8jAFALMo8jTxsAFQ40FQEQNSOPIyEAAkAACgQAGH9MABMv
BAAUf3IAVG8jjyVvkAAz-yMHpwAMuwAfYOMAAB_ACwEAFKAoARCwwyJfAA8hwP2VC1cCCgAVYGcf
GFBmNADqChdviDQUbwwLEW8RAAoEABRvOgsXf_w0Fn_jCyWPKp8LVc8oDyrPmwsljyqXCw87AAQG
ZQAEBAAUf20AD58AAkWvKA8qqwsG2AACCgAPpQucAqkKBrMKEUAKABMH7QoCCgAACAtUny1PL58m
CxOfPzUUn0wLE687NQAEABOvdQsTrz41FK8lAAA2ABbfQwADUAAfIHEAAB5AmQAPTAtsOArrCk0L
SAr7AQpPCwLbNAZRC0UK_wUKDgsQIBAAIQcKMAsh_glAC2IK_wkKCQhWCxsAHwAbID8AG0BfABtg
fwAagJ4AD1ILRg9KMwEjDw9ECi8fD2MzBB_AOgAEIy8PkgoXDxUADT4AJGAODQAPQgAEH1BCAAoD
oQAeQEYADmsAAEYLDqkAC0oAAIALDm8AD04AAB8QTgAMFC8IDA9OAA8DewAPxAAODlUAD6MAMCYg
DhEADzsBKy9ADssBMR5gawANTwIYERkAD40CEg-HAg8PHg1MD50zASMvFDEMDx0ABh_AHQAEBbIz
H3AhAA0fYCEACgMZNB9QJQARH0AlAAwULz4NDyUADh8gJQAMBb0AHxApABUfACkAEgPJAA8sABkm
AA4RAA8pAAomEA4RAA8pAAoA-QAXLxUADyUAAh4wJQAPkQEfD9sBFyZgDhEADyEAAiZwDhEADyEA
Ah6AsQAGHQAfkB0ABg8nD08vDxn0MhAkkA4NAA8pAAxVgA4PGh8RAA8EAAMjHxmWDg8pABImYA4R
AA_DABIkUA4NAA8xABQfQIsAEAmTAB8wMQAdJiAOEQAPmwAaJBAODQAPOQAcHwCjABgJqwAPOAAl
JgAOEQAP4wBTHiCrAA_3ATwmQA4RAA97AkMeYJMADy8DLCaADhEAD9MDMA8iElkfL5I1AQBJEQYV
AAIEAC0vHkASD7U1Bh9Q7zUJFUDYER8wZwAABWsAHyBhAAYDZQAGNxIRACsAD0wAAwAEABMPfBIO
IAAHcAAVAE8AHxC_AAIHwgAfIHAACB4PuxIPJwEjCuESD28AAAarAQ5hAA8DE1kfL_Y0BR_QHQAJ
JoAOEQAPIQACJnAOEQAPIQACAIgSD2o1Dh9QJQARH0CpAAQJJQAfMCUAESYgDhEADykACiYQDhEA
DykACgDLEw7BAA8tAAQOLAAPWQAtA6sADykAEh8gKQAMBdo2DyUADh9AJQAMDtsBDyUCIwNnAg8h
AAoegCEABqkAH5AdAAYPARVPHx_WNA0mkA4RAA_ONAokgA4NAA8tABAfcHsADAV-AB9gKQAQBS0A
JlAOEQAPhwASJEAODQAPNQAYHzCTABQFlwAfIDEAGAU1ACYQDhEAD58AGiQADg0ADz0AIA_qABwF
rgAeADkAD_MASCQgDg0AD7cBSR5AMQAPewI4JGAODQAPLwM5HoApAA-TAyUP5hdPLw8tQDYQCgUY
FR8bAA8EAAMQHzMACiQYLw8trjYYCksYDm4AD3YACApyGC8PLQQAHQNbGDP-LQlyGA5_AA_GABAB
QgATC0IALw8thQAqHiCFAA8DARUmQA4bAA95ARweYHYAD_cBDSaADhsAD2YABw9pGT8w_wHAzBig
sBvqGaAb_gEZkAUAYIAb_gMZcAUA8gFgG4osihlQG2ocKhtqGUAblTgyGTAblTijGSAbSgvKCUoZ
EAgAgwAbaguqCWoZBwDxAwAbWguqCVoZEBtqC4oJahkgG5Q4IxkwCADFQBtaiFoZUBv6BRlgdAAV
gIgAv6Ab6hmwCwr5AcD5tQMgUBABwP4BSjjisB7vDx8OoB7-DwEfDpAHAIKAHv8PAx8OcAcAkmAe
-w8FHw5QHoQkVR8OQB6fhzg5Hw4wDgAzIB6fhTgADgAZEA4A8wwAHp8PDk0PDp0cHp0PEU0MnRwA
Hn0ObQx9HBAIAJMgHl0OjQxdHDAIAPADQB5djw1dHFAe-QUcYB79AxxwBQBggB79ARyQBQAwoB7t
GSsv-AEYKyIRFQQB8gIUDxOwHu8UHxOgHv8UAR8TkAcAgoAe-xQDHxNwBwDyBGAe-xQFHxNQHo8U
LxaPFB8TQB5eOPMaHn0fEzAeXR8WbR5dHxMgHk0PFg6tHk0fExAePQ7tDD0cAB5NDu0MTRwHABMA
FwCAEB5NHK0fEk3zADAcbRvzAL99HC0bfRxAHo0rjfIARREa8gDyAhkPGLAe7xkfGKAe-xkBHxiQ
BwCCgB7-GQMfGHAHAPMNYB5fGV8bDg0OXxkfGFAeTxkNjA5MHxhAHkwOrBIzAAgAkyAeXA6sC1wb
EAgAgwAebA6sC2wbBwAbAB8AGCA-AEAPF0wbUADwAowKTBtQHlx7ClwbYB78AxtwBQBggB78ARuQ
BQCfoB7sG7AODPsBsCsiER-zAPICHg8dsB7vHh8doB7-HgEfHZAHAIKAHv8eAx8dcAcAgmAe-x4F
Hx1QBwAgQB6tNwBDNNEeHx0wHl8eDYwOXB8d8QAQDtIAYEwOzA8cTPIA8CQLrApsGx58C4wKfBsA
HnwLbAp8GxAejAtMCowbIB6MCywKjBswHpwLDAqcG0AenAqcG1AjNA-tAD8RJO0A8gIjDyKwHu8j
HyKgHv8jAR8ikAcAkIAe-yMDHyJwHgoic48jHyJgHo-zIQAOACJQHvAhoA59HyJAHn0PJU0KAPME
MB5tDyVtDm0fIiAebQ6NDG0cEAgAALwDQ40MfRwHABgAHwCwDyFtHCAebQxtC23ZAjAMTQvZAv8E
fQwtC30cUB6NDA0LjRxgHo0Ljd8COxEp-wDyAigPJ7Ae7ygfJ6Ae-ygBHyeQBwCCgB7-KAMfJ3AH
ABhgBTcVUAU3cUAebA5sC2zhNRGMsAJfbA6MC2zfAg8CJwATIDcAEzBHABNAKDYSUAw3D-EBPxEu
8gDyAi0PLLAe7y0fLKAe-y0BHyyQBwCCgB7-LQMfLHAHABhgEzcVUBM3D-IASB8r8gA8AAA48Rg1
a-AEG2ob8AAbugnAC9oJCKALKhyqCQiACyosqhkIcAsqHMoJCGAQN0U6GQhQrmpFKhkIQA43YRop
CDALSg03AwsAEqwJAFBaCYwJKgkAY2oJbAkqORIAEhoJAAAJN0UKSQhApmpBGjkIUKVqsBpJCGDq
SQhwGappkmr-Bmp5CKAI6QjAGKkY8AAYaRjwBGjwNeoACx446gDwA28Q8AQebw8e8AAevQ8OwA7d
DOodUC0fEa0MLR5QLS8RrRxXHnAtHxEdLH0Mfx5wfQwfEQxtHK8eEI0LACBdHNsecJ0MLxEMTSwL
Hz_NDD8LAAA2fQxPCwAAFgAdPAsAAEIAEExNAAFjAAAWAANjAPANLUwPDWCdLB1MC3AcrWwLgAsc
bXwLoAvsC8AbrKcBX2wb8ARr-gAhEBX_ABIU-gARE-4AEBL_ADAWrQyzG1AtLxatHN0bUC0fFs0M
Bxz-EH1MXRwLUA5tDE8WDE0cC0AObQxqDD0sCzAOXQyKDC0JAAcoHTwJAAA2ACEdTD8A70oMLTwL
UA59TC1MC2Dt4QA_EBrhABIZ4QARGOEAEBfhADAbrQwsGFAtLxutHF4YcC0fGy0sbQySGEB9DC8b
1AERF_cAQBsMTRwKGRF9CwAQLEYZYW0cTxscPQsAYV0MjxsMLQsAZk0MrxsMHQsAKw08CwAQXVgA
YAsMKwwNTFEAcF08CzwdPArhAbALDD1MCmCNLC1MCv4A-wgKgAocbXwKoArsCsAarBrwABpsGvAE
av4AIRAf-gASHv4AER3_ABAc-gAwIK0MrxZALS8gLckCEBwAAVAgPQx9DOwWMJ0MfeMBYI0MDyAM
beMBUJ0MCgxtyAEFCQBZjQwqDF0JAGx9DEoMPTwJABot4wEgDCoSAAHpAA-nAT0QJOkAEiPpABEi
6QAQIekAMCWtDDcUUC0vJa0cYRRQLR8lzQyLFDJ9PG3IAiIvJeUAUG0MKgx9ygBUXQwqDI0JADQ9
HC0LADQtDArOAj86LBrQAmYQKekAEijpABEn6QAQJukAMCqtDLgQkC0vKi0PJm0cC_sAoio9C30M
C2AOnQvRATILCgvQAQAJAADKAEGNCyoLvgFBbRtKG8UDVD0riisNEgAjLTwkABBNCQAANgBBXTwL
QEgAEE3jAJCdC01MC2CdCz3lAD99Cx3nADkQLucAEi3nABEs5wAQK_cAMC_tDKkOUC0vL60cvA5w
LR8vHU8rXeYAUF0bThs96ABQTQuOCy3oAFBNC64LHc0Af00LHhsuGx4NAA9QTgtOCw3tAGFdGx4r
HhvbAVB9C04LPfgAQW0LTgvbATFtCw4CAG8dTAtgfUuUBT4PfAcVMhxKHHwHQAwZDCoEAAF8B3IM
OQwKDDkMcQdEDEkMSQsAEqkJAEJaDIkMfAdTDGkMKjkSAAJ8ByAMOT4AAXwHcgwZDAoMGQx8Bz8c
Khx8B24TK3wHUAscC20cNgVgCxwLXRwKzgJQLAtNLAqqAhs8CQA0fQtMCQBKPAtNPAkAYSwLTUwK
QFEAI008UQB-LUwKYJ0rHYcFCg9mB1JATxZdHJsjkG0PFkwLTRwPEn8CMGwLPc0AX10LjAstCQAH
KB08CQAANgAQHegAUG0LTAst6AAgfUvmAB-t5AAKD2kHTBMraQcgCyzDARFQnAAQTcwBBbEBSm0b
TBvtAFRNC6wLHQkAKA08CQCQXQssCwwLLAsN6ABCXTsMO1cHMQsMC1cHHytXB2ETC1cHEBuEBRIK
hAUDlQASbbYCMAwLbc8ABQkAEI0OAQkJAAAOASw9PAkAGi3OAU8LLAst5gAQD1QHUkA-JW0cDRxA
bQ8lLAEBECGpAEMsC30spQEUjQkAND0bLQsANC0LDLwCPzwrHL4CZg9XBw8A0QAfJtIBEQXAAQXF
AlQ9K4wrDRIAIy08JAAjTTz-AUFdPApASAABiAQAVgcRClYHEgpWBw-mAAQPVgdMMEtdDEYWEF3E
AADoABBNiQMA6AAHiQNfHBssGxwNAA8zTAtMqQNnGxwrHBsd0wIH2gExbQsMAgAxHUwKVgcPhAU8
8AZp8AQZPAsMCxnwABkcahsYwAkcqgsrL0EM6gkIlnkATi8BBwCgDzVQCQxKGUoZSnEvIww63A55
OgkIDjAJDIt5FQyLeSAOIA0AFKwLAAN5eREOD0YBjnkLFgAUSpB5Ew7teRIK7XkQHhNwIBkqZ0aS
DlAIC-oCCB5QhXn-Fw5wCAnqCQgegAgZqhkIHqAYGWoZGB7ADhhpGC7wAA5oLvAEbvAXGQEegG7w
BB4-EQ8QnXkAGgIAhDpwHxAfDcAOHx9PEhD6LBER_iwDuHkCaC0xEV8PUUWBDzVQDg8RbQ5hQPEC
DVAODH0OHA5tDgsPNTAODI39QiALMBYAEDwKACkKIAsAArF0AAsAdA8QbQ48Dn0XAAQLAMIJbQ4s
Do0OCwowDglkAFMLGjAOCWQA8CMKUAsJfS5dDgsaUAsO-QEOCwpwCw7tDgsagAserR4LGqAbHm0e
GxrAChtuGyrwAAprKj4CDyUBHyBvEyYBMBYPFc5OASYBAeVOoh8SwA4fFq8UDxWoKgI7OgOveQIW
KwMKAAElAVIWbxRObXMrYRZdDkwOXRkAMzAODMN1QhIwDgzadUULDzUgDAAZCgsALw8VFwACEglE
AAEoAQJcAAEoASNtTiYBL-0BJQFPEBglAQPfTgElAfIAG28ZHxofF8AOHxuvGQ8aTScRG00nA6x5
AtsnQBtvGS4XRQEmASMbbTFFM1AODMoAASUBAysCAC8BTB5MHl0BAWEMPQ6sDj0LACYPGgwABxcA
QwlNDiyJeQEnAVRNPgw_TU8CACxDASkBP20ubSoBTxAdKgEDpE4BKgEgIG8tJpIcwA4fIK8eDx8r
JhEgKyYApXlCfx4OfX8mISB9CgABKgFCII0OjbwmEiDBAAAYAAF1AwFVehUcCwACTwIxfQ4s5QAJ
CwAAZXkeTI4DFAkLAAtPAgLPAw8oAVYQIigBMCUPJIZ5ASgBkCVvIx8kHyHADp5uIg8k2yMRJdsj
A6F5AkkkAwoAAScBUiVvIz59piQhJV35ACMPIXcDEyxcRRAMGwITrSgBAAwAIz0eVgIADQACiHkA
DwAGiHkPfwOAECctATAqDymHeQEtAfIAKm8oHykfJsAOHyqvKA8pjCARKowgIIAO4jgSD9BEGHAN
AAEzARUqSkUTUBwAJQ8qIAATMCAAIw8qJAATMCQAFi8kAEkgDg8qcXkCEwAJlXkBEwAeKSYAD0wA
ABkpcAABgwAAtTkkJg8mADMfNTAmAAMiADJQDyYjAAMfAEVQDyYODwByDzVwDyYO7xoAcIAPJh6v
KB4LADCgHyYGCv8EHyYfNcANHyZuHC3wAA1sLfAEbZABIRAskAEwLw8utXkBkAHyAC9vLR8uHyvA
Dh8vry0PLkEfES9BHwPQeQKRH0IvXy1P0kQBjQEQLyp5I08uJnkAEQAAUHkjjy5MeQEOAQETABSv
EwAEEQAAbgBWLy4fKx8sAB8gGwAlAsV5Ei4EAAcyAACdADEfLi82ABZPLgATby4AFW_jACMuXxMA
AdoAFR8TACYPLgQABPUAAA4ABQUBAL0BIisOHgEAugEyKw7vFwBwgA8rHq8tHgsAMKAfK9oKIR8r
ugEeK7oBDywKSSH6AykKIqoszwkVDLR5MwzaDPoJI1qMCQAh_gUIADMLOqwRAAQjAATqeQAQCiOq
LAoKL-oDBwqPAgoAAgYKABxZEI8jAAkNAAH-ARURXUUJDQABLgIoEZ-PeQITAA3meQEXAB8QFwAD
PxFPD-95BAI2AA8BegYBmwAnED9QRRA-FwABngIDKkUAjwIyDQ8Q5wAAjAIkDQ7zAFJwDw0O7zAA
cIAPDR6vDx4LADCgHw3WEiEfDYwCHg1GBA96CmAUjwpFCQ0AAf4AGBYXehkWF3oBPQEnFm9ORQcX
AA0begEXACgVbx16BkEAGM8iAAMhegF-ABUVjgAaHw8AAHgBFBIsRQB4ASQSDtIAUnAPEg7vMwBw
gA8SHq8UHgsAMKAfEmYTIR8SeAEeEngBD80KVAIKAALMChH-eUQACgATT7xEIU8ZHQAA-mwA-FkI
VUUEuHkBGQAIVUUSXzQAEyAbABxvEwACWgAGEwAKG3oCJgAOEwAMJgAAIDQJpgABkQEDPEUAjgEU
FzVFAI4BIhcODAAAjgEyFw7vMABwgA8XHq8ZHgsAMKAfFxAUIR8XjgEeF44BDzELSgJvMRVwCgAB
jgEG4YQjIE9cRSNPHjULOw8gX15FBAl6IyBfVkUJV3oBQgEZIFl6AhMABVt6AQ8AAyNFBC4AA196
ChsAAttFEk-PRQF0AQNuMgB0ATIcDx-CAAB0ASQcDs4AUnAPHA7vMABwgA8cHq8eHgsAMKAfHJgU
IR8cdAEeHHQBD30LYABreiOPI38LE19bRSOPI4QLAURaAV1FBFN6AREAEs8gABEgDwA4TyWPDwAC
K0VVDyMvJU8XAAG0RRsPBAAeTzYAAAQACTYANY8lT4sAEiRBRRcfDAAAggEyIQ8k0AAAggEkIQ7c
AEFwDyEO_wAAggFQIR6vIx4LADCgHyE0FSEfIYIBHyGCASwfJtILAhQe0QsyDycO0Qs0DycOc4U1
Jw5wCgAFywsQJwQAEA4NAEBPKC8nvCNhDygvJ08oJAARMKsLABMACgQAABQAFA4dABMvBAASXzQA
ESAXABiPDwBVnygPJ58PABspHgAPRAADJylfcAAEBAAVX5cAHSmuAAXnCwLSAAHhABIp7QAQHwwA
FCf5AFJwDg8n7zIAcIAOHyevKB8LAECgHh8niyQQHp4BQB5vJx6eAR9u4AtfBMwKAMwLAn0rBgoA
AfoAEi-GKwDIC0F-LU59FwAAbQtIfQ4tDg4ANg0ODRAAWC59Dg0uHgAWvRoAJE59WwAxLv0DPQsF
CwADbwsh-QEXAABrC-AX-QEODA81cAwO7Q4MG4AMHq0eDBugHB5tHhwbwAscbhwr8AALbCveHA82
AR7iTEuAS4BrYGtgGxwqG0AFAPFKDGoLIBsMWgsJMBuKCwAbehkPNSAbmhuKGQ4gG5oLmhkOIAsJ
_gUZDjAJ_gQZHjAZ_gMZDlAZ_gEZHmAZ6hkegCmqKR6gOWo5HqArqiugGwzaG4AbDPoAGXAGAGAO
YBt6CXoHAP8TahlqKQ5wCwk6KQ4JSikegGkeAGkeoDkuIA45HsA_YD7wMM4AHdAxfxDwBZ7wBB4f
ES8PXRfwAl0fDvADHm0c8AMeXRwPNfACDAAABQAxC-ABBgBCAB4PEQgAFgoHAEHgHgp9BgBhbRwb
4B59GAACBgAxbRwbBgBAC-ABDqggIvACBgASHAYAcF0cC-ADLE0GAM_cC-ADC3wL8AV78BPHAB0Q
UqEc8AOu8AA_LxY-FD7ALh8WjxQuoC61CQCqKwC3KzIPNXCyKwMHADIPNVC0KwMHAD8PNUAJABkS
UEYAFB8JAFAPNXAfE2gAFB8JAPADDzWQLxOvFC8THzWgPxNvFD8TtAMmrxNQBR805wAd8QM2Txrw
Bo7wAy4fGy8ZLvACHg9JTlE18AAej7kcpo0ODxgPNeAejR8HAPASwD6NHxgekG5tHE5gHh8bLQ5t
DB0bDR5QDgv9BA5AHv0FKwMQIEksHgoGAPARMBxdHB0sXRwaQIwdnBpgCkwKDB0cCkwqkEoMHRxq
8AEOACLwBwYAEkwEAE8ISvAY2QAdgDgPH-AMDvAMzADwCwoeDx3wCh4NDzXwCR4NDPAIHg8gHfAI
HgsPDgDwBgceCwoNDPAGLhod8AYeOg0M8AQuOlwJ8AFaDfADHgtaHfABHgt6HfAABgBg4B4Lmh3Q
BQBIDMAeqgUA-wfQHYodHNAtai0M8ACtHPABDG0s8ARsDgQf8gBSXyTwBU4fIh818AIuLyUJAFMe
HyUfIwsAALIHAQsAdAMePyMfIg8JAAoSABpPCQBgsA8iUB5fmisgDg10AvALXyMdDzWAHg0MQB5v
Ix1wHh0MQB57LTAuDyUKAPMfi24aCx0MUB6bLhobHRxQHvsBHQxwHusdHHAd6x0MkC2rLRygPWs9
HMAMrSzwAOoAD3wCHjJVDymgATALDg2kATAn8AovjSAnDaEBUCofJ-AIDwBgKB8nDfAGEQCQKB8n
8AUeDyo-CQDgAi5vKC8n0D6PKD8ngD7ZTP8xTydgHTyPKDw9gA0saywt0A0cSxwt8AIcKxwd8AUc
Cxwd8AYcCxwN8AgsHfAILA3wCgwd8AoMDfALDA3wDA3wN78AGQ7yng-1lBCRTEiASIAISwhgBABm
Cww6CwhABwBAWgsIIAcA0QkIMAgLegsIAAgLDGoNAGGKCwgLDHoLAEGaCwyKCQAl_gUHACNACJeU
AoZLEQibS5EIC8oJCMAIC6oGACEMuhMAIQzaIABiDPoACQhwLwBhcAgLegl6CAAwagkIYGEggAhz
GxEABgDvoAhJCCAISQjASEBI8E7wAB3AMX3wBQ1vEA3wBQ0ODQYRDgoAFkwHALAEDQ5cDg3wAw0O
bB0AXAINDmwLBwBQAQ0ODxEJAFIADQ4KfAgAGYwHABJ8JgAHNAAKBwBRAw0OXAttACJMC3sACAcA
f2sN8AV98DHcAB3wBVGPEvADDo8VDvABDg0PFn8UDQ7gCQBQnxQNDsAJAEC-FA0ObANgFt8UDQ6A
CQBi-xQADQ5gCgCvAg8TDlAODf8UAwkALxBgCQAwAQ8TZgAAKGoAdwAQzwgAQMAODa8IAEDgDg2P
CACv8AEOjA7wA47wUe4AHdA1bxfwBQ5vGg7wAw4NXQ8SDfgAvxt-GQ8YDvAADg2PCQAMIcA_CABx
PoAOTZ8ZPQcBchv-GQINDkAKAK8EDxgOMA4N-xkFCQAOkG8ZHxgNDxkvGHxpAEAAYE8ZDxgeDV0y
8QgeDE8ZDA5gDkwOAA4NCwwOAA5MDoBOEAwAQRBO8AEJAC-wCAcAAj9O8DYXAR0wVQ8cZAbxAgsO
Dx8O8AoODQ7wCQ4NDx4NVQDwAgwNDvAHDg0PIBwNDvAGDg0LCACTBQ4NCzwNDvAECACTAw4NC1wN
DvACCAAAogAhfA03AQAIAJDgDg0LnA8dDtAIABAKBwAfrAYAAVHgDg2MCj0AIGwKVAB-ag7wBW7w
Nc8AHaBRbyHwBQ4-JA8iqQAA5A4vHyMMABsRLwwAEQQMABU-DAAaTwoANMAOUAsAQrAeUA7raEAO
kA4N0wKQbyMNDnAODQ8iDQAhfyMUABIMDgBgjA1eDRwLCgBAnF0sC0MCMPwBC-UCIOwL8wIgzAvx
AiGsCw4BEAsOAR_L7QIjM1UPJtYBFynWATEqDyfXAQIJAADZASAqH0wNJvAGCwAwBB4NngYgDyc5
CRAd4Q2QHycesB4dHyqPCgAQcAoAEs8KAKAcrygcHrAeHGscLACgDEsMHvAEDgwrDFAAAQcAMgcO
DJ4CAQcAMAkODIwAAZcAAJ0AH1XVAAwPrQYv8CtUKfAIGQsMChjwBBkrDCoY8AAZSwxKGLAZawxq
GHAZiwyKGEAIHIsMihsIMAgaHFscC1obGQgwCDocwQz2AxobOQhACEocahtJCFAISguKCwgAm2AI
SgtqC0kIcAgAwIAISgtKC0kIkAhKawYA-xE6C2kLOQigCBoLiQsZCLAICgupCwkIsAgLyQsIwOjw
a9IAHRFV1AFSEQ8N8AoHACEJDtsXVg8PDfAICwBBBw4fEA0XNg3wBgsAUAUOLxAPUDg2DfAECwBw
Aw4-EA8RPwsAMgIOL0IAERAaADMBDj8PAAEeABQANAABHgAz4A4-DgAAHQAR0BwAE08cADPADj8O
ABE-alIAHAATbxwAEaAcABF-GgCAkA4fEB8Rjh_MTwB9GFAQHxHOH_dPAYAYIP4BSJxfgP0D8Gkn
AR0wcS8TgAkAXBeAFB8S8AQeLxXQFnAfEvAAHk8V4xZgHxKwHm8VwxZgHxJwHo8VnBaAHxJADZ8V
HxY-XHINMA0PFm8VA3FAbxQPFREAUhQPFj8VqBeQPxQPFQ4NMA0fFhcQFbIXER9uTVEeDTANL2xc
Mg8VLiAAQRUPFB8qcTEODB5GAHAMOxxrHD4MPwD-JAxrHCscbgwNMA2bLJ4NQB2LDI4dcB1rDG4d
sB1LDE4d8AAdKwwuHfAEHQsMDh3wCC3wcQwBHcBq-xgBoA7-GgEPF4BhBgAsTVAbDg1wDZoWkM8a
DxseDXANL45bwRoPGy4NcA0-Ga8bPggAAsJwDwwAVTKfGj6KAEEargwuoAAwDM4MnQD-AQsM7gwO
DYAN-gENoP0B8GoCAR2Aiq8d8AEOHx-EFQDjR1MPHOAOLw4AANVvEcAOABNvDgAzoA4-DgAgPx50
FgAOABOPDgAzYA5PDgAAHHDQQA5vIP8fAA8cMA1fHlZbcw8fXg1ADU8MADFODWAMABFvDAAzgA0-
DABSPg2gDT9DAGMfPg3ADS8MAFIuDeANL4UAIB8uDwoTHw0AEB4ACgK1SAENADMFDQ8NAEMODfAH
DQDPDfAJDQ8fDfALDfBVIQEdUTcvIvAJ8QYAekgAPgQCFAcASwcSLxMHECEoBAISB2Ah8AEOTyRw
FWEPIeAOXyT_FUIhwA5fQAAACwdiIaANHyU-OgDSJD8jHyQNkA0fIx8lDzcAoyQPIx8kHg2QDT9s
cBI_DAAfJAwAGRAfvZtgDE8jDA4cSwDwDBw_DCsMPhwNoA1eDAsMXg3ADV4MXg3gDU4MTkwBMD4M
PkYBMC4MLkABMB4MHjoBnw4MDg3wCS3wNzEBHZFPDye-JvAADyeGFYMpDybgDycPKQ0AgCcPJtAP
Jx8p2FqjDykfJw8mwA8nLw8AkC8nDyawDyc-KbMVow8pPycPJqAPJ08PAFJPJw8mkA8AEV8NAEOA
DydfHABSXycPJnAcABNvKwASYB4AE28eAFBQDydfKthaIG8p4CFCXygPKRsAQw5gDk8NABBPSBYA
GgACUwBgDoAOTyhvFgAykA5PVgAADQAzoA4-DQBgPycOsA4vPQAQJ70AQw7ADh8NAFAfJw7QDg1D
IY8nshYi4A4LAG8O8ADO8E-cB07wG1IcO-AETFvwAHxrsJyLgKyLCXA7bHsZcGs8azlgixwrOjlg
q2pJUKt6OQQAcWCbeilwi4oEAP8YgDkrmhmQaYopkHl6KaB5ahmweVopwHlIGeBJeAnwACmI8AIJ
aPBSkQAd8A9TPxHwCG7wBY7wAy8QTi8P8AIvEH8P8AE-EI8P8AAGACHgTwZ4EtAHAPIHwF8Qjw8f
DrBfEJ8PDw6gXxCvDx8OkAcA-yKAbxCvDy8OcF8Qzw8fDmA9HxDfDy1QXdwtUH28PUB9nF1Afa8N
TVBdyy2ALevQq-BQrQAd8iCPTxbwBm4fFPACbk3gjl2wPxVefYBsLq1gnM1QnL0PE1CcrSswrJ07
MKyNSzCcnQQA-w_MG31LUDxrbTtwmz0vEiuga4rgO3rwAwtq8Acq8HKDAB3xJm_PG-ACrg8a8ACu
LdCeXbCeLxk9DxiQnk8ZLQ8YkI5vGR0fGHANbo8ZDS8YcC0uvxkvGHBdBgBETb8ZPwYAJj3PBgD-
FS0Mzxk8cB0cu0xwTJtcgExbPxc8kGyKLKBMqgzALLrwAarwT6YAHf9JiY8g8ALOPx_QPY59YF1u
Hx59UG0_jB0PHUB93CswbewrMF3sOzA9O7xLQHusO2B7jDuAa4w7kGtsO7BbXDvQWyxL4GsfHDvw
AUs6G-ADK0oL8AULWvAIKsgHHzE2PyVgAv9UnvACHyR_HfAATU490G0_TcBtHyMeTbBtTF2gXWxN
oC8iLXw9oEuMPaBLnB0LoEucK6BLjDugS3xLoFtcW6BbTGugW0xbwFssa8BrHGvQWx8hW-AASyo7
8AIrShvwBBta8Ac6Rg4f-01tfyrwBM7gvi8pwM49oC2eXYBNjm1gbW59YH1eXR8nYH1fKE0-J1AM
Tb8oTFAcLctMUDzLXFBMu1xQXKtcUGyLXHB8W2xwjE8mXJBsWkywTHos0Dx6HPAAHIrwbksEOlBt
PTZ9fQ==
:: gfx/1.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA5LTEzIDEzOjUxOjM5Iixtb2RpZmllZD0iMjAyNC0w
OS0xMyAxMzo1MzoxOCIscmV2aXNpb249OV1dbHo0AG0AAAAFMQAA8xR7WzBdPXtibXA9cHh1AEMg
EBAE8PAsZmxhZ3M9MCxwYW5feAgAz3k9MCx6b29tPTh9LDEA----------------------------
------------------------------------51BtPTh9fQ==
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNS0w
Mi0yNSAyMDo1ODoyNiIsc3RvcmVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Il1d
:: map/
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNC0w
OS0wMSAwNzozNDozNSIscmV2aXNpb249MzA3NV1dbHo0AMEAAABZEAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD-------_x0zIwMDAzMDAwNDAwMDYMAC81MIAAWxMxCAATNYAALzYw
AQBbFzb8ABMxDAAPAQBVBHwBAAABEzAMAA_AAVkTMXQAEzB4ABcxjAAPAAFVEzaEAAQMAC81MAEA
--------nvEJIiksaGlkZGVuPWZhbHNlLHBhbl94PTQ3CQDSeT0wLHRpbGVfaD0yOQoAEHcKAIB6
b29tPTF9fQ==
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNS0w
Mi0yNSAyMDo1ODoyNiIsc3RvcmVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Il1d
:: pal/
:: pal/0.pal
b64$LS1bW3BvZCxiZ19jb2xvcj0wLGJsYWNrZXN0X2NvbG9yPTAsY3JlYXRlZD0iMjAyNC0wOC0y
MyAxODo1OTowOSIsaGlkZGVuPXtbMF09dHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1
ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUs
dHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRy
dWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVl
LHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0
cnVlLHRydWUsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2V9LGhpZGRlbl90b2dnbGVzPXtbMF09dHJ1ZSx0cnVlLHRydWUsdHJ1ZX0saWNv
bj11c2VyZGF0YSgidTgiLDE2LDE2LCIwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAwMDAwMDAw
MDEwNzA3MDcwNzA3MDcwNzA3MDYwMTAwMDAwMDAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNjA2MDEw
MDAwMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA2MDYwNjAxMDAwMDAwMDEwNzA3MDcwNzA3MDcwNzA3
MDYwNjA2MDYwMTAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzAxMDAwMDAxMDcwNzA3MDcw
NzA3MDcwNzA3MDcwNzA3MDEwMDAwMDEwNzA3MDYwNjAxMDEwZDBkMDEwMTA3MDcwMTAwMDAwMTA3
MDcwNjA2MDEwMTBkMGQwMTAxMDcwNzAxMDAwMDAxMDcwNzAxMDEwNzA3MDYwNjBkMGQwNzA3MDEw
MDAwMDEwNzA3MDEwMTA3MDcwNjA2MGQwZDA3MDcwMTAwMDAwMTA3MDcwZDBkMDEwMTBkMGQwNjA2
MDcwNzAxMDAwMDAxMDcwNzBkMGQwMTAxMGQwZDA2MDYwNzA3MDEwMDAwMDEwNzA3MDcwNzA3MDcw
NzA3MDcwNzA3MDcwMTAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzAxMDAwMDAxMDEwMTAx
MDEwMTAxMDEwMTAxMDEwMTAxMDEwMCIpLGxvY2tlZD17WzBdPWZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlfSxtb2RpZmllZD0iMjAyNS0wMi0yNSAyMDo1ODoyNiIsb2tw
YWxfdmVyc2lvbj0iMS4wLjQiLHJldmlzaW9uPTgyOTQsdGVzdF9jdWJlX2NvbG9ycz17WzBdPXsx
MiwxMSwxMH0sezExLDEwLDl9LHsxMCw5LDh9LHsxNywxNiwxNX0sezE2LDE1LDE0fSx7MTUsMTQs
MTN9LHsyMiwyMSwyMH0sezIxLDIwLDE5fSx7MjAsMTksMTh9LHsyNywyNiwyNX0sezI2LDI1LDI0
fSx7MjUsMjQsMjN9LHszMiwzMSwzMH0sezMxLDMwLDI5fSx7MzAsMjksMjh9LHszNywzNiwzNX0s
ezM2LDM1LDM0fSx7MzUsMzQsMzN9LHsxLDEsMX0sezEsMSwxfSx7MSwxLDF9LHsxLDEsMX0sezEs
MSwxfSx7MSwxLDF9fSx3aGl0ZXN0X2NvbG9yPTddXWx6NAD2AQAAFQIAAPUFdXNlcmRhdGEoImkz
MiIsNjQsIjABACAxZAIAQDAwMmICAEAwMDNkAgBAMDA1MwIAQDAwYjUCAEAwMGRiAgAxMDBmAQDw
bzAwNzQxZjY1MDBhODI1OTIwMGUyNDliYTAwZWY4M2M1MDBmOGJiZDkwMDc3MmMxNjAwYTIzMjE5
MDBkNTRmMjEwMGYzODI1NzAwZmNiYzljMDA2NzQ5MTMwMDljNzExYTAwZDZhMjI1MDBlZGM0NTQw
MGZiZTE5OTAwMmQ1MxgA8BYzMTZlMzIwMDUwYTMyYzAwODdkNDU2MDBiZmYyOTUwMDE2NTg1CABA
Nzc5N_AA8BQwYjRiMzAwNWNkOGQyMDBhY2Y2ZjAwMDQ3MjI4NjAwNWUyNiAA0DhkM2JlZDAwYWU4
MWawAPAEOGM0ZmMwMDA2MTUzYTAwMDcyNLgAQTBiMzdYADFmNjgfAFBjOTRjZZgAsDEzMTUwMDUy
MjAyLwAwNjMyWAHwFmE1NWU0ZTAwYjc5MTg0MDA0ZjRiM2UwMDU3YTY3YzAwN2RjNznAAPAGM2U4
YmMwMGJlYjVhNDAwNTg1OTVkiAAwNmM4EAFANjljYTgBMDNjZXAAwDg2ODM4MDAwMjMzNSgAUTM1
NGQ4GAExNjg5gAEwOGRigAAwOWI4kAGAZGVlNGYxIik=
:: pal/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTIzIDE4OjU0OjE5Iixtb2RpZmllZD0iMjAyNS0w
Mi0yNSAyMDo1ODoyNiJdXQ==
:: sfx/
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM1Iixtb2RpZmllZD0iMjAyNS0w
Mi0yNSAyMDo1ODoyNiIscmV2aXNpb249ODA1Nl1dbHo0AC8BAADmBwAA8CdweHUAAygAAAQABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDBAUGBwAP-5AICQoLDwwPDQ8ODw8QAPAADQ8RDxIPEw8UDxUP
Fg8XEwDxAQ8YDxkPGg8bDxwPHQ8eDx8UAPEAIA8hDyIPIw8kDyUPJg8nFADxACgPKQ8qDysPLA8t
Dy4PLxQA8QAwDzEPMg8zDzQPNQ82DzcUAP8FOA85DzoPOw88Dz0PPg8-AA--8P8BAOv-J1oBEAYP
IBABIAEgAfAAAhACDBABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDDAAAh9EMAAc
H0AwAPIf-wEA3PIE_A9AAA1ADy3--y8A-i8M-i-wcBIAKiH_EQBf-rDwcAMIAP-UH-8BAP_ZUP--
--8g
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNS0w
Mi0yNSAyMDo1ODoyNiIsc3RvcmVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Il1d
:: src/
:: src/logic/
:: src/logic/creation.lua
--[[pod_format="raw",created="2024-08-30 06:25:09",modified="2025-02-17 10:05:57",revision=4750]]
--- Board Creation Logic


function logic_cells(config)
	local grid
	local size
	if config.tiling == "square" then
		grid = sgrid_new()
		local height = grid:max_height() - 1
		for x = 0, config.columns - 1 do
			for y = 0, height do
				grid:set(pos(x, y), true)
			end
		end
	elseif config.tiling == "hex" then
		grid = hgrid_new()
		local height = (grid:max_height() - 1) * 2
		for x = 0, config.columns - 1 do
			for y = 0, height, 2 do
				grid:set(pos(x, y - (x % 2)), true)
			end
		end
	end
	return grid
end


-------------------------------------------------------------------------


function logic_new_cell_column(status, cells)
	status.columns += 1
	if cells:tiling() == "square" then
		local height = cells:max_height() - 1
		for y = 0, height do
			cells:set(pos(status.columns - 1, y), true)
		end
	elseif cells:tiling() == "hex" then
		local height = (cells:max_height() - 1) * 2
		for y = 0, height do
			local x = status.columns - 1
			cells:set(pos(x, y - (x % 2)), true)
		end
	end
end

------------------------------------------------------------------------


local function random_gem(config)
	return math.random(gem_air, gem_air - 1 + config.number_of_colours)
end


function logic_fill_gem_at(config, cells, gems, marks, p)
	local cell = cells:get(p)
	if not cell then
		return
	end
	local test = (gems:tiling() == "square") and logic_test_sqr_match_at or logic_test_hex_match_at
	local gem = gems:get(p)
	if not gem then
		local attempts = 0
		local found = false
		while attempts < 16 and not found do
			gem = random_gem(config)
			gems:set(p, gem)
			found = not test(gems, p)
			attempts += 1
		end
		if attempts == 16 then
			gem = gem_gift
			gems:set(p, gem)
		end
	end
end


function logic_fill_gems(config, cells, gems, marks)
	-- TODO: transform into a coroutine
	local height = gems:max_height() - 1
	if gems:tiling() == "square" then
		for x = 0, 13 do
			for y = height - 6, height do
				logic_fill_gem_at(config, cells, gems, marks, pos(x, y))
			end
		end
	elseif gems:tiling() == "hex" then
		cells:foreachpos(
			function(p, _)
				if p.y < 2 * (height - 6) then
					return
				end
				logic_fill_gem_at(config, cells, gems, marks, p)
			end
		)
	end
end

:: src/logic/matching.lua
--[[pod_format="raw",created="2024-08-24 08:12:55",modified="2025-02-17 10:38:21",revision=5916]]
--- Matching Logic

-- The matching algorithm has two phases:
--
-- 1. First, a linear sweep through all the gems, and for each gem involved in a match
--    creates a mark registering which direction(s) matched.
-- 2. Then a flood-fill algorithm is used to group matches together.


function logic_is_matching(gem1, gem2)
	if (not gem1) or (not gem2) then
		return false
	end
	
	-- Only colored gems can match.
	if (gem1 < gem_color_first) or (gem1 > gem_color_last) then
		return false
	end
	if (gem2 < gem_color_first) or (gem2 > gem_color_last) then
		return false
	end

	return (gem1 == gem2)
end


--------------------------------------------------------------------------


local function test_3(gems, p0, p1, p2)
	local gem0 = gems:get(p0)
	local gem1 = gems:get(p1)
	local gem2 = gems:get(p2)
	return logic_is_matching(gem0, gem1)
		and logic_is_matching(gem0, gem2)
		and logic_is_matching(gem1, gem2)
end


local function test_4(gems, p0, p1, p2, p3)
	local gem0 = gems:get(p0)
	local gem1 = gems:get(p1)
	local gem2 = gems:get(p2)
	local gem3 = gems:get(p3)
	return logic_is_matching(gem0, gem1)
		and logic_is_matching(gem0, gem2)
		and logic_is_matching(gem0, gem3)
		and logic_is_matching(gem1, gem2)
		and logic_is_matching(gem1, gem3)
		and logic_is_matching(gem2, gem3)
end


function logic_test_sqr_match_at(gems, p)
	local S = p + pos(0, 1)
	local SS = p + pos(0, 2)
	local N = p + pos(0, -1)
	local NN = p + pos(0, -2)
	local E = p + pos(1, 0)
	local EE = p + pos(2, 0)
	local W = p + pos(-1, 0)
	local WW = p + pos(-2, 0)
	local SE = p + pos(1, 1)
	local SW = p + pos(-1, 1)
	local NE = p + pos(1, -1)
	local NW = p + pos(-1, -1)
	return test_3(gems, SS, S, p) or test_3(gems, S, p, N) or test_3(gems, p, N, NN)
		or test_3(gems, EE, E, p) or test_3(gems, E, p, W) or test_3(gems, p, W, WW)
		or test_4(gems, p, S, SE, E) or test_4(gems, p, S, SW, W) 
		or test_4(gems, p, N, NE, E) or test_4(gems, p, N, NW, W)
end


function logic_test_hex_match_at(gems, p)
	local S = p + pos(0, 2)
	local S_S = p + pos(0, 4)
	local N = p + pos(0, -2)
	local N_N = p + pos(0, -4)
	local SE = p + pos(1, 1)
	local SE_SE = p + pos(2, 2)
	local SW = p + pos(-1, 1)
	local SW_SW = p + pos(-2, 2)
	local NE = p + pos(1, -1)
	local NE_NE = p + pos(2, -2)
	local NW = p + pos(-1, -1)
	local NW_NW = p + pos(-2, -2)
	local E = p + pos(2, 0)
	local W = p + pos(-2, 0)
	return test_3(gems, S_S, S, p) or test_3(gems, S, p, N) or test_3(gems, p, N, N_N)
		or test_3(gems, SE_SE, SE, p) or test_3(gems, SE, p, NW) or test_3(gems, p, NW, NW_NW)
		or test_3(gems, NE_NE, NE, p) or test_3(gems, NE, p, SW) or test_3(gems, p, SW, SW_SW)
		or test_4(gems, p, SE, S, SW) or test_4(gems, p, NE, N, NW)
		or test_4(gems, p, NE, E, SE) or test_4(gems, p, NW, W, SW)
end


local function check_3_and_mark(gems, p0, p1, p2, mark, marks)
	if test_3(gems, p0, p1, p2) then
		marks:merge(p0, mark)
		marks:merge(p1, mark)
		marks:merge(p2, mark)
	end
end


local function check_4_and_mark(gems, p0, p1, p2, p3, mark, marks)
	if test_4(gems, p0, p1, p2, p3) then
		marks:merge(p0, mark)
		marks:merge(p1, mark)
		marks:merge(p2, mark)
		marks:merge(p3, mark)
	end
end


local function mark_sgrid_matches_at(gems, p0, marks)
	check_3_and_mark( gems,
		p0,
		p0 + pos(0, 1),
		p0 + pos(0, 2),
		{ name = "matching", vertical = true }, marks )
	check_3_and_mark( gems,
		p0,
		p0 + pos(1, 0),
		p0 + pos(2, 0),
		{ name = "matching", horizontal= true }, marks )
	check_4_and_mark( gems,
		p0,
		p0 + pos(1, 0),
		p0 + pos(0, 1),
		p0 + pos(1, 1),
		{ name = "matching", vertical = true, horizontal = true }, marks )
end


local function mark_hgrid_matches_at(gems, p0, marks)
	check_3_and_mark( gems,
		p0,
		p0 + pos(0, 2),
		p0 + pos(0, 4),
		{ name = "matching", vertical = true }, marks )
	check_3_and_mark( gems,
		p0,
		p0 + pos(1, 1),
		p0 + pos(2, 2),
		{ name = "matching", horizontal_SE = true }, marks )
	check_3_and_mark( gems,
		p0,
		p0 + pos(1, -1),
		p0 + pos(2, -2),
		{ name = "matching", horizontal_NE = true }, marks )
	local p1 = p0 + pos(1, 1)
	local p2 = p0 + pos(1, -1)
	local p3 = p0 + pos(2, 0)
	if test_4(gems, p0, p1, p2, p3) then
		marks:merge(p0, { name = "matching", vertical = true, horizontal_NE = true, horizontal_SE = true})
		marks:merge(p1, { name = "matching", vertical = true, horizontal_SE = true })
		marks:merge(p2, { name = "matching", vertical = true, horizontal_NE = true })
		marks:merge(p3, { name = "matching", vertical = true, horizontal_NE = true, horizontal_SE = true})
	end
end


local function mark_all_matches(gems)
	local marks = gems:new_grid()
	if gems:tiling() == "square" then
		gems:foreachpos(
			function(p, _gem)
				mark_sgrid_matches_at(gems, p, marks)
			end
		)
	elseif gems:tiling() == "hex" then
		gems:foreachpos(
			function(p, _gem)
				mark_hgrid_matches_at(gems, p, marks)
			end
		)
	end
	return marks
end


---------------------------------------------------------------------------


local function group_this_match(cells, gems, marks, p)
	-- A simple flood-fill algorithm to group all
	-- intersecting linear matches together.
	local colour = false
	local positions = {}
	local remaining = { p }
	while #remaining > 0 do
		local current = deli(remaining)
		local gem = gems:get(current)
		if not colour then
			colour = gem
		end
		local mark = marks:get(current)
		if mark and mark.name == "matching"
			and (not mark.counted)
			and logic_is_matching(colour, gem)
		then
			colour = gem
			add(positions, current)
			marks:merge(current, { counted = true })
			local cell = cells:get(current)
			local neighbours = gems:neighbours(current)
			foreach(
				neighbours,
				function(n)
					local s = marks:get(n.position)
					if not s then
						return
					end
					if s and s.name == "matching"
						and (not s.counted)
						and s[n.direction]
					then
						add(remaining, n.position)
					end
				end
			)
		end
	end
	return { colour = colour, positions = positions }
end


function logic_find_matches(cells, gems)
	local marks = mark_all_matches(gems)
	local matches = {}
	marks:foreachpos(
		function(p, mark)
			if mark and mark.name == "matching"
				and (not mark.counted)
			then
				local match = group_this_match(cells, gems, marks, p)
				add(matches, match)
			end
		end
	)
	return matches, marks
end


-------------------------------------------------------------------------------


function logic_count_opportunities(cells, gems)
	local cleared_count = 0
	gems:foreachpos(
		function(position, _)
			local gem = gems:get(position)
			local right = position + pos(1, 0)
			local down = position + pos(0, 1)
			if gems:get(right) then
				local gem_right = gems:get(right)
				gems:set(position, gem_right)
				gems:set(right, gem)
				local matches, _ = logic_find_matches(cells, gems)
				gems:set(position, gem)
				gems:set(right, gem_right)
				foreach(matches,
					function(match)
						cleared_count += #match.positions
					end
				)
			end
			if gems:get(down) then
				local gem_down = gems:get(down)
				gems:set(position, gem_down)
				gems:set(down, gem)
				local matches, _ = logic_find_matches(cells, gems)
				gems:set(position, gem)
				gems:set(down, gem_down)
				foreach(matches,
					function(match)
						cleared_count += #match.positions
					end
				)
			end
		end
	)
	return cleared_count
end
:: src/logic/mechanics.lua
--[[pod_format="raw",created="2024-08-30 06:41:59",modified="2025-02-17 10:33:25",revision=4745]]
--- Core Mechanics Logic


function logic_mark_gravity(cells, gems, marks, gravity)
	local some_gems_are_falling = false
	gems:foreachpos(
		function(p, gem)
			local below = p + gravity
			local distance = 0
			local cell_below = cells:get(below)
			while cell_below do
				if (not gems:get(below)) then
					some_gems_are_falling = true
					distance += 1
				end
				below += gravity
				cell_below = cells:get(below)
			end
			if distance > 0 then
				marks:set(p, { name = "falling", target = p + distance * gravity })
			end
		end
	)
	return some_gems_are_falling
end


function logic_enact_gravity(gems, marks)
	local fell_gems = {}
	marks:foreachpos(
		function(p, mark)
			if mark.name == "falling" then
				local new_p = mark.target
				add(fell_gems, { gem = gems:get(p), pos = new_p })
				gems:del(p)
				marks:del(p)
			end
		end
	)
	foreach(fell_gems,
		function(fell_gem)
			gems:set(fell_gem.pos, fell_gem.gem)
			marks:del(fell_gem.pos)
		end
	)
end


------------------------------------------------------------------------


function logic_mark_swap(gems, marks, source, target)
	local gem0 = gems:get(source)
	local gem1 = gems:get(target)
	local test = (gems:tiling() == "square") and logic_test_sqr_match_at or logic_test_hex_match_at
	gems:set(source, gem1)
	gems:set(target, gem0)
	local matched = test(gems, target) or test(gems, source)
	gems:set(source, gem0)
	gems:set(target, gem1)
	marks:set(source, {
		name = "swapping",
		selected = true,
		target = target,
	})
	marks:set(target, {
		name = "swapping",
		target = source,
	})
	return true
end


function logic_enact_swap(gems, marks)
	local reinsert = {}
	marks:foreachpos(
		function(p, mark)
			if mark.name == "swapping" then
				add(reinsert, { gem = gems:get(p), position = mark.target })
				gems:del(p)
				marks:del(p)
			end
		end
	)
	foreach(
		reinsert,
		function(r) gems:set(r.position, r.gem) end
	)
end


-------------------------------------------------------------------------


function logic_enact_clear(gems, marks)
	marks:foreachpos(
		function(p, mark)
			if mark.name == "matching" then
				gems:del(p)
				marks:del(p)
			end
		end
	)
end


-------------------------------------------------------------------------


function logic_push_up(config, cells, gems, marks)
	if gems:tiling() == "square" then
		local width = cells:max_width() - 1
		local height = cells:max_height() - 1
		for x = 0, width do
			for y = 0, height do
				local position = pos(x, y)
				local below = pos(x, y + 1)
				gems:set(position, gems:get(below))
				marks:set(position, marks:get(below))
			end
		end
		for x = 0, width do
			logic_fill_gem_at(config, cells, gems, marks, pos(x, height))
		end
	elseif gems:tiling() == "hex" then
		local width = cells:max_width() - 1
		local height = (cells:max_height() - 1) * 2
		cells:foreachpos(
			function(position, _)
				local below = pos(position.x, position.y + 2)
				gems:set(position, gems:get(below))
				marks:set(position, marks:get(below))
			end
		)
		cells:foreachpos(
			function(position, _)
				if position.y >= height - 1
				then
					logic_fill_gem_at(config, cells, gems, marks, position)
				end
			end
		)
	end
end


-----------------------------------------------------------------------


function logic_check_filled(config, status, cells, gems)
	if not config.fail_top then
		return
	end
	status.filled = false
	status.filled_columns = {}
	gems:foreachpos(
		function(position, _)
			local _, top = cells:coords_cell(position)
			if top <= 0 then
				status.filled = true
				status.filled_columns[position.x] = true
			end
		end
	)
end


function logic_check_cleared(config, status, cells, gems)
	if not config.clear_zone then
		return
	end
	status.cleared = true
	gems:foreachpos(
		function(position, _)
			local _, top = cells:coords_cell(position)
			if top < config.clear_zone then
				status.cleared = false
			end
		end
	)
end

:: src/logic/spells.lua
--[[pod_format="raw",created="2024-08-30 06:37:36",modified="2025-02-25 20:58:26",revision=3274]]
--- Spell Logic

-- simple match: 5 point
-- 4 gems combo: 15 points
-- 5 gems combo: 25 points
-- 6 gems combo: 35 points
-- 7 gems combo: 45 points

-- one simple cascade after a simple match: 10 points
-- two simple cascades after a simple match: 15 points
-- three simple cascades after a simple match: 20 points

-- one simple cascade after a 4 gems combo: 20 points
-- one 4 gems combo after a simple match: 20 points

function logic_gain_mana(status, matches)
	local gained = false
	local points = 0
	foreach(
		matches,
		function(match)
			local count = #(match.positions)
			points += 5 + 10 * (count - 3)
			gained = true
		end
	)
	status.mana += points
	status.mana = clamp(status.mana, 0, status.max_mana)
	status.score += points
	return gained
end


spells = {
	[0] = {
		name = "Clear gem",
	},
	{
		name = "Clear random",
	},
	{
		name = "Distant swap",
	},
	{
		name = "Shuffle",
	},
	{
		name = "Equalize",
	},
	{
		name = "Destroy column",
	},
	{
		name = "Destroy row",
	},
	{
		name = "Swap columns",
	},
	{
		name = "Replace color",
	},
	{
		name = "Destroy top",
	},
	{
		name = "Undo",
	},
	{
		name = "Vertical flip",
	},
	{
		name = "Multiswap",
	},
	{
		name = "Push row",
	},
	{
		name = "Link gems",
	},
	{
		name = "Combos freeze",
		passive = true,
	},
	{
		name = "Combos explode",
		passive = true,
	},
}
:: src/logic/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTMwIDA2OjI0OjM5Iixtb2RpZmllZD0iMjAyNS0w
Mi0yNSAyMDo1ODoyNiJdXQ==
:: src/constants.lua
--[[pod_format="raw",created="2024-08-24 15:17:10",modified="2024-09-19 09:45:49",revision=4839]]
--- Match3 Global Constants


-- Gems and cells ------------------------------------------------------

-- Color gems
gem_air = 0x01
gem_fire = 0x02
gem_day = 0x03
gem_earth = 0x04
gem_water = 0x05
gem_night = 0x06
gem_white = 0x07
gem_black = 0x08

gem_color_first = gem_air
gem_color_last = gem_black

-- Black gems
gem_gift = 0x08
gem_bomb = 0x09
gem_cat = 0x0a
gem_bat = 0x0b
gem_robot = 0x0c
gem_robot_asleep = 0x0d
gem_robot_asleep2 = 0x0e

gem_names = {
	[gem_air] = "Air",
	[gem_fire] = "Fire",
	[gem_day] = "Day",
	[gem_earth] = "Earth",
	[gem_water] = "Water",
	[gem_night] = "Night",
	[gem_white] = "White",
	[gem_black] = "Black",
}

:: src/gfx.lua
--[[pod_format="raw",created="2024-08-24 12:06:13",modified="2025-02-25 20:58:26",revision=8880]]
--- Graphics


local star_seed = 0


function gfx_seed_the_stars()
	star_seed = math.random(37, 6584587)
end


function gfx_draw_starry_background(left, top, right, bottom)
	local hash = star_seed
	for x = left, right, 40 do
		for y = top, right, 40 do
			hash = hash~(hash << 13); hash = hash~(hash >> 17); hash = hash~(hash << 5)
			local flipped = (x+y)%2 == 0
			spr(120 + (hash%8), x, y, flipped, flipped)
		end
	end
end


----------------------------------------------------------------------------------


local cell_width = 29
local cell_height = 29


function gfx_draw_cells(cells, stats)
	local function draw_cell(p, _)
		local has_cell = cells:get(p)
		if p.y == -1 then
			if cells:tiling() == "square" then
				has_cell = cells:get(pos(p.x, p.y + 1))
			elseif cells:tiling() == "hex" then
				has_cell = cells:get(pos(p.x, p.y + 2))
			end
		end
		if not has_cell then
			return
		end
		local x, y = cells:coords_cell(p)
		local sprite
		if cells:tiling() == "square" then
			sprite = 32
			local offset = (stats.push_ups) % 2
			sprite += (p.x + p.y + offset) % 2
		elseif cells:tiling() == "hex" then
			sprite = 40
			local offset = (stats.push_ups) % 3
			sprite += (p.y + (p.x * 3) - offset) % 3
		end
		spr(sprite, x, y)
	end
	cells:foreachpos(draw_cell)
end


-----------------------------------------------------------------------


local sprites_color_gem = {
	[gem_air] = 1,
	[gem_fire] = 2,
	[gem_day] = 3,
	[gem_earth] = 4,
	[gem_water] = 5,
	[gem_night] = 6,
	[gem_white] = 7,
	[gem_black] = 8,
}


local sprites_other_gem = {
	[gem_gift] = 8,
	[gem_bomb] = 9,
	[gem_cat] = 10,
	[gem_bat] = 11,
	[gem_robot] = 12,
	[gem_robot_asleep] = 13,
	[gem_robot_asleep2] = 13,
}

--color_gem_skin = math.random(0, 14)
color_gem_skin = 0
local function gem_sprite(gem)
	local base = 128 + color_gem_skin * 8
	if gem >= gem_color_first and gem <= gem_color_last then
		return sprites_color_gem[gem] - 1 + base
	else
		return sprites_other_gem[gem]
	end
end


local function scaled_gem(sprite, x, y, size)
	local w, h = flr(29 * size + 0.5) // 2 * 2 + 1, flr(29 * size + 0.5) // 2 * 2 + 1
	local x, y = x + ((29 - w) / 2), y + ((29 - h) / 2)
	sspr(sprite, 0, 0, 29, 29, x, y, w, h)
end


local function draw_exploded_gem(gem, x, y, clock, new_clock)
	local size = 32 * new_clock
	local colour = 10 + (gem - 1) * 5
	oval(x - size, y - size, x + 29 + size, y + 29 + size, colour + 1)
	if clock < 0.25 then
		ovalfill(x + 2, y + 2, x + 25, y + 25, 7)
	elseif clock < 0.50 then
		ovalfill(x + 2, y + 2, x + 25, y + 25, colour + 2)
	elseif clock < 0.75 then
		ovalfill(x + 1, y + 1, x + 27, y + 27, colour + 1)
	elseif clock < 1.0 then
		ovalfill(x, y, x + 29, y + 29, colour)
	end
end


function gfx_draw_gems(stats, cells, gems, marks, clock)
	local function draw_gem(p, gem)
		local x, y = gems:coords_gem(p)
		local sprite = gem_sprite(gem)
		local cell = cells:get(p)
		local mark = marks:get(p)
		palt(53, true)
		if not mark then
			if stats.filled_columns[p.x] then
				spr(sprite, x + math.random(-1, 1), y)
			else
				spr(sprite, x, y)
			end
		elseif mark.name == "new" then
			scaled_gem(sprite, x, y, clock)
		elseif mark.name == "matching" then
		elseif mark.name == "falling" or mark.name == "swapping"
		then
			local dest_x, dest_y = gems:coords_gem(mark.target)
			local ix, iy = x + clock * (dest_x - x), y + clock * (dest_y - y)
			spr(sprite, ix, iy)
		end
		palt(53, false)
	end
	gems:foreachpos(draw_gem)
	local new_clock = clock * clock * clock * clock
	gems:foreachpos(
		function(p, gem)
			local x, y = gems:coords_gem(p)
			local mark = marks:get(p)
			if mark and mark.name == "matching" then
				draw_exploded_gem(gem, x, y, clock, new_clock)
			end
		end
	)
end


------------------------------------------------------------------------


local pattern_tick = 0
local patterns = {
	[0] =
	0b00011111,
	0b10001111,
	0b11000111,
	0b11100011,
	0b11110001,
	0b11111000,
	0b01111100,
	0b00111110,
}


function gfx_draw_clear_zone()
	if config.clear_zone then
		local pattern = patterns[flr(pattern_tick) % 8]
		pattern_tick += 0.166666666
		fillp(pattern, pattern, pattern, pattern, pattern, pattern, pattern, pattern)
		poke(0x550b,0x3f)
		line(80, config.clear_zone, 400, config.clear_zone, 7)
		poke(0x550b,0x00)
		fillp()
	end
end


-----------------------------------------------------------------------


function gfx_draw_turns(ox, oy, turn, timer)
	spr(64, ox, oy)
	local hundreds = (turn // 100) % 10
	local tens = (turn // 10) % 10
	local ones = turn % 10
	local anim = flr((timer) * 10.0)
	pal(7, 1)
	clip(ox + 7, oy + 3, ox + 7 + 3 * 8, oy + 3 + 8)
	-- hundreds
	if anim == 0 or (turn % 100) > 0 then
		spr(65 + hundreds, ox + 7, oy + 6)
	else
		spr(65 + hundreds, ox + 7, oy + 6 + anim)
		spr(65 + ((hundreds - 1) % 10), ox + 7, oy + 6 + anim - 10)
	end
	-- tens
	if anim == 0 or ones > 0 then
		spr(65 + tens, ox + 7 + 8, oy + 6)
	else
		spr(65 + tens, ox + 7 + 8, oy + 6 + anim)
		spr(65 + ((tens - 1) % 10), ox + 7 + 8, oy + 6 + anim - 10)
	end
	-- ones
	spr(65 + ones, ox + 7 + 2 * 8, oy + 6 + anim)
	spr(65 + ((ones - 1) % 10), ox + 7 + 2 * 8, oy + 6 + anim - 10)
	clip()
	pal(7, 7)
end


local function gfx_draw_mana(ox, oy, mana, zoomed)
	local base_char
	local char_width
	if zoomed then
		base_char = 85
		char_width = 11
		oy -= 3
	else
		base_char = 75
		char_width = 8
	end
	local thousands = (mana // 1000) % 10
	local hundreds = (mana // 100) % 10
	local tens = (mana // 10) % 10
	local ones = mana % 10
	local digits = max(1, math.floor(math.log(mana, 10)) + 1)
	ox -= (digits * char_width) // 2
	if mana >= 1000 then
		spr(base_char + thousands, ox, oy)
		ox += char_width
	end
	if mana >= 100 then
		spr(base_char + hundreds, ox, oy)
		ox += char_width
	end
	if mana >= 10 then
		spr(base_char + tens, ox, oy)
		ox += char_width
	end
	spr(base_char + ones, ox, oy)
end



function gfx_draw_mana_bar(ox, oy, mana, max_mana, zoomed)
	local width = 66
	local height = 26
	local size = min(width, flr(0.5 + width * (mana / max_mana)))
	poke(0x5508, 0xff)
	poke(0x550b, 0x3f)
	rectfill(ox-3, oy-3, ox+width+3, oy+height+3, 7 | (3 << 6))
	poke(0x550b, 0x00)
	poke(0x5508, 0x3f)
	rectfill(ox-1, oy+height-3-1, ox+width+1, oy+height+1, 58)
	if size > 0 then
		rectfill(ox, oy+height-3, ox+size, oy+height, 54)
	end
--	rect(ox-1, oy-1, ox+width+1, oy+height+1, 63)
	gfx_draw_mana(ox + (width//2) + 1, oy + height - 20, mana, zoomed)
end
:: src/hgrid.lua
--[[pod_format="raw",created="2024-08-25 08:16:09",modified="2025-02-25 20:58:26",revision=5341]]
--- Hex Grids

--- Hex grids use the "double height" coordinate system:
---
---     (0,0)         (2,0)         (4,0)
---            (1,1)         (3,1)
---     (0,2)         (2,2)         (4,2)
---            (1,3)         (3,3)
---     (0,4)         (2,4)         (4,4)
---
--- The origin of the grid, `pos(0, 0)`, is at the top left.


-- Local Constants --------------------------------------------------------


local max_width <const> = 15
local max_height <const> = 12

local dx <const> = 24
local dy <const> = 14

local gem_offset_x = 1
local gem_offset_y = -1


------------------- -----------------------------------------------------------


local metatable = {}


function hgrid_new()
	local grid = {}
	metatable.default_origin(grid)
	setmetatable(grid, { __index = metatable })
	for i = 0, max_width * max_height do
		grid[i] = nil -- TODO false
	end
	return grid
end


function metatable:new_grid()
	return hgrid_new()
end


function metatable:clone()
	local grid = self:new_grid()
	grid.origin = self.origin
	self:foreachpos(function(p, item) grid:set(p, item) end)
	return grid
end


-----------------------------------------------------------------------------


function metatable:tiling()
	return "hex"
end


function metatable:max_width()
	return max_width
end


function metatable:max_height()
	return max_height
end


-----------------------------------------------------------------------------


function metatable:get(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width then -- or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	return self[p.x + ((p.y // 2) * max_width)]
end


function metatable:set(p, value)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	self[p.x + ((p.y // 2) * max_width)] = value
end


function metatable:merge(p, state)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	local index = p.x + ((p.y // 2) * max_width)
	if not self[index] then
		self[index] = {}
	end
	for k, v in pairs(state) do
		self[index][k] = v
	end
end


function metatable:del(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	self[p.x + ((p.y // 2) * max_width)] = false
end


-- Screen Coordinates ---------------------------------------------------------


function metatable:default_origin()
	self.origin = { x = 116, y = 7 }
end


local function compute_screen_size(self)
	local min_p = pos(max_width, max_height)
	local max_p = pos(0, 0)
	self:foreachpos(
		function(position, cell)
			if not cell or cell == 0 then
				return
			end
			if position.x < min_p.x then min_p.x = position.x end
			if position.y < min_p.y then min_p.y = position.y end
			if position.x > max_p.x then max_p.x = position.x end
			if position.y > max_p.y then max_p.y = position.y end
		end
	)
	local width = 1 + max_p.x - min_p.x
	local height = 1 + max_p.y - min_p.y
	return min_p, max_p, width, height
--	self.origin.y += 6 -- for Matchic Pon only
--	self.origin.y -= flr(delta * dy * 2)
end


function metatable:set_center_coords(x, y)
	local min_p, max_p, width, height = compute_screen_size(self)
	self.origin = {
		x = x - ((width * dx) // 2) - (min_p.x * dx) - 4,
		y = y - ((height * dy) // 2) - (min_p.y * dy) - 8 + 3,
	}
	self.screen_width = width * dx + 8
	self.screen_height = height * dy
end


function metatable:set_bottom_center_coords(x, y)
	local min_p, max_p, width, height = compute_screen_size(self)
	self.origin = {
		x = x - ((width * dx) // 2) - (min_p.x * dx) - 4,
		y = y - (max_p.y * dy) - dy + 3,
	}
	self.screen_width = width * dx + 8
	self.screen_height = height * dy
end


function metatable:offset_coords(x, y)
	self.origin.x += flr(x * dx)
	self.origin.y += flr(y * dy * 2)
end


function metatable:coords_cell(p)
	return self.origin.x + p.x * dx, self.origin.y + p.y * dy
end


function metatable:coords_gem(p)
	return self.origin.x + (p.x * dx) + gem_offset_x,
		self.origin.y + (p.y * dy) + gem_offset_y
end


function metatable:pos(x, y)
	local ox, oy = self.origin.x, self.origin.y
	x -= ox
	y -= oy + 1
	local px, py = x // dx, y // dy
	local xx, yy = x - (px * dx), y - (py * dy)
	if xx < 8 then
		if (px + py) % 2 == 0 and yy < dy + (-2 * xx) then
			px -= 1
			py -= 1
		elseif (px + py) % 2 != 0 and yy > -1 + (2 * xx) then
			px -= 1
		end
	end
	py = (2 * ((py - (px % 2)) // 2)) + (px % 2)
	return pos(px, py)
end


function metatable:distance(p0, p1)
	-- TODO: is this correct?
	return (abs(p0.x - p1.x) + abs(p0.y - p1.y)) // 2
end


-- Iterating ----------------------------------------------------------


function metatable:foreachpos(func)
	for x = 0, max_width do
		for y = x % 2, max_height * 2 - 1, 2 do
			local p = pos(x, y)
			local item = self:get(p)
			if item then
				func(p, item)
			end
		end
	end
end	


function metatable:neighbours(p)
	return {
		{ position = p + pos(1, 1), direction = "horizontal_SE" },
		{ position = p + pos(0, 2), direction = "vertical" },
		{ position = p + pos(-1, 1), direction = "horizontal_NE" },
		{ position = p + pos(-1, -1), direction = "horizontal_SE" },
		{ position = p + pos(0, -2), direction = "vertical" },
		{ position = p + pos(1, -1), direction = "horizontal_NE" },
	}
end


function metatable:blast_radius(p)
	return {
		p + pos(0, 0),
		p + pos(0, -2),
		p + pos(1, -1),
		p + pos(1, 1),
		p + pos(0, 2),
		p + pos(-1, 1),
		p + pos(-1, -1),
	}
end

:: src/in_game.lua
--[[pod_format="raw",created="2024-08-27 17:11:11",modified="2025-02-25 20:58:26",revision=8807]]
in_game = {}


-- The Board
config = {}
local cells = false
local gems = false
local starting_status = {
	number_of_colours = config.number_of_colours,
	columns = config.columns,
	gravity = config.gravity,
	speed = config.speed,
	turn = 0,
	combo_pause = 0,
	distance = 0.0, -- total distance risen
	push_ups = 0, -- total number of push_ups
	mana = 0,
	max_mana = 200,
	score = 0,
	in_cascade = false,
	cleared = false,
	filled = false,
	filled_columns = {},
}
local status = deep_copy(starting_status)
local undo = {} -- TODO use `create_delta` and `apply_delta` instead

local marks = false
local matches = {}

-- State Machine
local menu_requested = false
local substate = false
local clock = 0.0
local interaction = false
local displayed_mana = 0
local on_screen_distance = 0


-------------------------------------------------------------------------


local function update_board_coords()
	cells:set_bottom_center_coords(00 + ((480 - 000) // 2), 269)
	cells:offset_coords(0.0, status.push_ups - on_screen_distance)
	gems.origin = cells.origin
end


local function rise_board()
	if on_screen_distance < status.distance then
		on_screen_distance += 1.0 / 27.0
		if on_screen_distance > status.distance then
			on_screen_distance = status.distance
		end
	end
	while on_screen_distance - status.push_ups > 0.0 do
		logic_push_up(config, cells, gems, marks)
		status.push_ups += 1
	end
	update_board_coords()
end


-----------------------------------------------------------------------


-- Functions for substate need to be global, because of Lua
-- forward-declaration rule for locals.

function creating_the_board()
	undo = {}
	cells = logic_cells(config)
	local gems_candidates = {}
	for i = 1, 4 do
		gems_candidates[i] = cells:new_grid()
		local marks = cells:new_grid() -- TODO: remove `marks` from `logic_fill_gems`
		logic_fill_gems(config, cells, gems_candidates[i], marks)
	end
	local best_candidate = false
	local best_count = 0
	for i = 1, 3 do
		local count = logic_count_opportunities(cells, gems_candidates[i])
		if (not best_candidate) or (count < best_count) then
			best_candidate = i
			best_count = count
		end
	end
	gems = gems_candidates[best_candidate]
	marks = cells:new_grid()
	cells:set_bottom_center_coords(00 + ((480 - 000) // 2), 269)
	gems.origin = cells.origin
	status = deep_copy(starting_status)
	status.number_of_colours = config.number_of_colours
	status.columns = config.columns
	status.gravity = config.gravity
	status.speed = config.speed
	matches = {}
	displayed_mana = 0
	on_screen_distance = 0.0
	gfx_seed_the_stars()
	return starting_new_turn
end


function starting_new_turn()
	if clock == 0.0 then
		status.turn += 1
		status.in_cascade = false
	end

	return waiting_for_input
end


function waiting_for_input()
	local mx, my, mb, _, _ = mouse()
	if mb == 0x1 then
		local mp = cells:pos(mx, my)
		if gems:get(mp) then
			interaction = { name = "swap", position = mp, start = t() }
			return waiting_for_swap
		end
	end
	if keyp("r") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:del(p)
		matches = {}
		return applying_gravity
	end
	if keyp("e") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:del(p)
		matches = {}
		logic_check_cleared(config, status, cells, gems)
		return waiting_for_input
	end
	if keyp("o") then
		status.distance += 1.0 / 25.0
		update_board_coords()
		logic_check_cleared(config, status, cells, gems)
		logic_check_filled(config, status, cells, gems)
	end
	if keyp("a") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:set(p, gem_air)
		marks:set(p, { name = "new" })
		matches = {}
		return checking_matches
	end
	if keyp("s") then
		config.tiling = "square"
		config.gravity = pos(0, 1)
		config.columns = 2 * (config.columns // 2)
		return creating_the_board
	end
	if keyp("h") then
		config.tiling = "hex"
		config.gravity = pos(0, 2)
		config.columns = 2 * (config.columns // 2) + 1
		return creating_the_board
	end
	if keyp("z") then
		local previous = deli(undo)
		if previous then
			cells = previous.cells
			gems = previous.gems
			marks = cells:new_grid()
			status = previous.status
			on_screen_distance = status.distance
		end
	end
	if keyp("1") then color_gem_skin = 5 end
	if keyp("2") then color_gem_skin = 8 end
	if keyp("3") then color_gem_skin = 10 end
	if keyp("4") then
		color_gem_skin = (color_gem_skin - 1) % 16
		if config.tiling == "square" and color_gem_skin == 7 then
			color_gem_skin = 3	
		elseif config.tiling == "hex" and color_gem_skin == 3 then
			color_gem_skin = 15
		end
	end
	if keyp("5") then color_gem_skin = config.tiling == "square" and 0 or 4 end
	if keyp("6") then
		color_gem_skin = (color_gem_skin + 1) % 16
		if config.tiling == "square" and color_gem_skin == 4 then
				color_gem_skin = 8
		elseif config.tiling == "hex" and color_gem_skin == 0 then
			color_gem_skin = 4
		end
	end
	if keyp("7") then color_gem_skin = 2 end
	if keyp("8") then
		local prev = color_gem_skin
		while prev == color_gem_skin do
			color_gem_skin = math.random(0, 14)
		end
	end
	if keyp("9") then color_gem_skin = 15 end
	return waiting_for_input
end


function waiting_for_swap()
	local mx, my, mb, _, _ = mouse()
	if mb != 0x1 then
		interaction = false
		return waiting_for_input
	end
	local mp = cells:pos(mx, my)
	if cells:distance(mp, interaction.position) != 1
		or (not cells:get(mp))
		or (eq_pos(mp, interaction.position - config.gravity) and not gems:get(mp))
	then
		return waiting_for_swap
	end
	local success = logic_mark_swap(gems, marks, interaction.position, mp)
	interaction = false
	if not success then
		return waiting_for_input
	end
	add(undo, {
		cells = cells:clone(),
		gems = gems:clone(),
		status = deep_copy(status),
	})
	return swapping_two_gems
end


function swapping_two_gems()
	clock += 1.0 / 8.0
	if clock < 1.0 then
		return swapping_two_gems
	end
	logic_enact_swap(gems, marks)
	return applying_initial_gravity
end


function applying_initial_gravity()
	if clock == 0.0 then
		local some_gems_are_falling = logic_mark_gravity(cells, gems, marks, status.gravity)
		if not some_gems_are_falling then
			return checking_matches
		end
	end
	clock += 1.0 / 8.0
	if clock < 1.0 then
		return applying_initial_gravity
	end
	logic_enact_gravity(gems, marks)
	return checking_matches
end


function checking_matches()
	matches, marks = logic_find_matches(cells, gems)
	if #matches > 0 then
		local _ = logic_gain_mana(status, matches)
		foreach (
			matches,
			function(match)
				if #match.positions > 3 then
					status.combo_pause += #match.positions - 3
				end
				status.in_cascade = true
			end
		)
		return clearing_gems
	end
	return ending_turn
end


function clearing_gems()
	clock += 1.0 / 16.0
	if clock < 1.0 then
		return clearing_gems
	end
	logic_enact_clear(gems, marks)
	return applying_gravity
end


function applying_gravity()
	if clock == 0.0 then
		local some_gems_are_falling = logic_mark_gravity(cells, gems, marks, status.gravity)
		logic_check_filled(config, status, cells, gems)
		if not some_gems_are_falling then
			return ending_turn
		end
	end
	clock += 1.0 / 8.0
	if clock < 1.0 then
		return applying_gravity
	end
	logic_enact_gravity(gems, marks)
	return checking_matches
end


function ending_turn()
	logic_check_cleared(config, status, cells, gems)
	if status.cleared then
		return starting_new_turn
	end
	
	if config.combo_pause and status.combo_pause > 0 then
		status.combo_pause -= 1
		return starting_new_turn
	end
	
	status.distance += status.speed
	status.speed += config.speed_increase
--	while status.distance - status.push_ups > 0.0 do
--		logic_push_up(config, cells, gems, marks)
--		status.push_ups += 1
--	end
--	update_board_coords()

	if config.column_increase and status.turn % config.column_increase == 0 then
		logic_new_cell_column(status, cells)
	end

	return starting_new_turn
end


-----------------------------------------------------------------------


function in_game:enter()
	menu_requested = false
	substate = creating_the_board
	local gui = ui_create_root()
	gui:attach(
		ui_button {
			x = 14, y = 5,
			sprite = 98,
			sprite_clicked = 99,
			tap =
				function(self)
					menu_requested = true
				end,
		}
	)
	gui:attach {
		x = 80, y = 0, width = 480 - 160, height = 270,
		hover =
			function(self, msg)
				local cursor_pos = cells:pos(80 + msg.mx, msg.my)
				local cell = cells:get(cursor_pos)
				if cell and cell != 0 then
					window { cursor = "grab" }
				else
					window { cursor = "" }
				end
			end
	}
end


function in_game:exit()
end


function in_game:update()
	local next = substate()
	if next != substate then
		clock = 0.0
		substate = next
	end
	
	rise_board()
	logic_check_filled(config, status, cells, gems)

	if displayed_mana < status.mana then
		displayed_mana += 0.25
	elseif displayed_mana >= status.mana then
		displayed_mana = status.mana
	end
	
	ui_update_all()
	
	if menu_requested then
		return in_prelaunch_waves -- in_mode_selection
	end

	return false
end


function in_game:draw()
	if not cells then
		return
	end
	-- Starry background
--	gfx_draw_starry_background(0, 0, 480, 270)
	spr(112, 0, 0)
	-- Draw the board
	if status.turn > 0 then
---		gfx_draw_cells(cells, status)
		local x1 = cells.origin.x - 2
		local x2 = cells.origin.x + cells.screen_width + 2
		poke(0x5508, 0xff)
		poke(0x550b, 0x3f)
		rectfill(x1, 0, x2, 270, 7 | (2 << 6))
		poke(0x550b, 0x00)
		poke(0x5508, 0x3f)
		line(x1 - 1, 0, x1 - 1, 270, 63)
		line(x2 + 1, 0, x2 + 1, 270, 63)
		gfx_draw_gems(status, cells, gems, marks, clock)
		gfx_draw_clear_zone()
	end
	-- Experience
--	gfx_draw_mana(455, 20, flr(displayed_mana), displayed_mana < status.mana)
	gfx_draw_mana_bar(408, 5, flr(displayed_mana), status.max_mana, displayed_mana < status.mana)
--	print(string.format("/%d", status.max_mana), 455 + 1 + 1, 20 + 3 + 1, 58)
--	print(string.format("/%d", status.max_mana), 455 + 1, 20 + 3, 7)
	---
	for i = 0, 5 do
		spr(96, 480 - 80 + 4, 40 + i * 38)
	end
	cursor(480 - 80 + 10, 44 + 0 * 38, 1)
	print("Destroy gem")
	cursor(480 - 80 + 10, 44 + 1 * 38, 1)
	print("Rotate column")
	cursor(480 - 80 + 10, 44 + 2 * 38, 1)
	print("Destroy line")
	cursor(480 - 80 + 10, 44 + 3 * 38, 1)
	print("Repaint")
	cursor(480 - 80 + 10, 44 + 4 * 38, 1)
	print("Equalize")
	cursor(480 - 80 + 10, 44 + 5 * 38, 1)
	print("1234567890123")
	-- Update the cursor
	if false then
		local mx, my = mouse()
		local cursor_pos = cells:pos(mx, my)
		rectfill(mx + 4 - 10, my + 10, mx + 36, my + 20, 7)
		print(tostr(cursor_pos.x)..","..tostr(cursor_pos.y), mx + 6 - 10, my + 12, 0)
	end
	--
	ui_draw_all()

	cursor(480 // 2 - 4*4, 120, status.cleared and 7 or 0)
	print(status.cleared and "cleared!" or "")
	cursor(4, 32, 7)
	print(string.format("turn: %d", status.turn))
	print(string.format("score: %d", status.score))
	print("")
	print(string.format("\14colours: %d", config.number_of_colours))
	print(string.format("\14columns: %d", config.columns))
	print(string.format("\14speed: %1.3f", status.speed))
	print("")
--	print(string.format("\14dist: %3.3f", status.distance))
--	print(string.format("\14up: %d", status.push_ups))
end
:: src/in_mode_selection.lua
--[[pod_format="raw",created="2024-09-21 11:01:40",modified="2024-09-21 11:45:03",revision=73]]
in_mode_selection = {}


local start_requested = false


function in_mode_selection:enter()
	gfx_seed_the_stars()
	start_requested = false
	local gui = ui_create_root()
	gui:attach(ui_button {
		x = (480 // 2) - (80 // 2), y = 80, width = 80, height = 13,
		label = "Tutorial",
		tap =
			function(self)
				-- start_requested = true
			end
	})
	gui:attach(ui_button {
		x = (480 // 2) - (80 // 2), y = 120, width = 80, height = 13,
		label = "Endurance",
		tap =
			function(self)
				start_requested = in_prelaunch_endurance
			end
	})
	gui:attach(ui_button {
		x = (480 // 2) - (80 // 2), y = 160, width = 80, height = 13,
		label = "Waves",
		tap =
			function(self)
				start_requested = in_prelaunch_waves
			end
	})
end


function in_mode_selection:exit()
end


function in_mode_selection:update()
	ui_update_all()
	if start_requested then
		return start_requested
	end
end


function in_mode_selection:draw()
	gfx_draw_starry_background(0, 0, 480, 270)
	ui_draw_all()
end
:: src/in_prelaunch_endurance.lua
--[[pod_format="raw",created="2024-09-20 07:05:05",modified="2025-02-15 10:09:50",revision=955]]
in_prelaunch_endurance = {}


local start_requested = false


function in_prelaunch_endurance:enter()
	config = {
		tiling = "square",
		number_of_colours = 6,
		columns = 6,
		gravity = pos(0, 1),
		speed = 0.400,
		speed_increase = 0.001,
		column_increase = false,
		fail_top = true,
		clear_zone = false,
		combo_pause = false,
	}

	gfx_seed_the_stars()
	start_requested = false
	local gui = ui_create_root()
	gui:attach(ui_label {
		x = (480 // 2) - (120 // 2), y = 10, width = 120, height = 13,
		label = "Game Mode: Endurance",
		centered = true,
	})
	gui:attach(ui_hchoice {
		x = (480 // 2) - (120 // 2), y = 50, width = 120, height = 13,
		labels = { "Square", "Hexagonal" },
		selection = 1,
		change =
			function(self)
				if self.selection == 1 then config.tiling = "square"
				elseif self.selection == 2 then config.tiling = "hex"
				end
			end,
	}) 
	gui:attach(ui_label {
		x = (480 // 2) - (120 // 2), y = 75, width = 120, height = 13,
		label = "Colours",
		centered = true,
	})
	gui:attach(ui_hchoice {
		x = (480 // 2) - (100 // 2), y = 90, width = 100, height = 13,
		labels = { "5", "6", "7", "8" },
		selection = 2,
		change =
			function(self)
				config.number_of_colours = clamp(self.selection + 4, 5, 8)
			end,
	}) 
	gui:attach(ui_label {
		x = (480 // 2) - (120 // 2), y = 125, width = 120, height = 13,
		label = "Columns",
		centered = true,
	})
	gui:attach(ui_hchoice {
		x = (480 // 2) - (220 // 2), y = 140, width = 220, height = 13,
		labels = { "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", },
		selection = 1,
		change =
			function(self)
				config.columns = clamp(self.selection + 5, 6, 15)
			end,
	}) 
	gui:attach(ui_button {
		x = (480 // 2) - (60 // 2), y = 230, width = 60, height = 13,
		label = "Start",
		tap =
			function(self)
				start_requested = true
			end
	})
end


function in_prelaunch_endurance:exit()
end


function in_prelaunch_endurance:update()
	ui_update_all()
	if start_requested then
		return in_game
	end
end


function in_prelaunch_endurance:draw()
	gfx_draw_starry_background(0, 0, 480, 270)
	ui_draw_all()
end
:: src/in_prelaunch_waves.lua
--[[pod_format="raw",created="2024-09-21 11:32:35",modified="2025-02-25 20:58:26",revision=1636]]
in_prelaunch_waves = {}


local start_requested = false

local gui_tiling
local gui_colours
local gui_columns
local gui_speed


function in_prelaunch_waves:enter()
	config = {
		tiling = "square",
		number_of_colours = 6,
		columns = 6,
		gravity = pos(0, 1),
		speed = 0.3,
		speed_increase = 0.000,
		column_increase = false,
		fail_top = true,
		clear_zone = 268 - 4 * 25,
		combo_pause = false,
	}
	color_gem_skin = 5


	gfx_seed_the_stars()
	start_requested = false
	local gui = ui_create_root()
	gui:attach(ui_label {
		x = (480 // 2) - (120 // 2), y = 10, width = 120, height = 13,
		label = "Game Mode: Waves",
		centered = true,
	})
	
	gui:attach(ui_label {
		x = (480 // 2) - 120, y = 50, width = 120, height = 13,
		label = "Shape of the gems:",
	})
	gui_tiling = ui_hchoice {
		x = (480 // 2), y = 50, width = 120, height = 13,
		labels = { "Squares", "Hexagons" },
		selection = 1,
	}
	gui:attach(gui_tiling)
	
	gui:attach(ui_label {
		x = (480 // 2) - 120, y = 80, width = 120, height = 13,
		label = "Number of colours:",
	})
	gui_colours = ui_hchoice {
		x = (480 // 2), y = 80, width = 120, height = 13,
		labels = { "5", "6", "7", "8" },
		selection = 2,
	}
	gui:attach(gui_colours)
	
	gui:attach(ui_label {
		x = (480 // 2) - 120, y = 110, width = 120, height = 13,
		label = "Width of the waves:",
	})
	gui_columns = ui_hchoice {
		x = (480 // 2), y = 110, width = 120, height = 13,
		labels = { "S", "M", "L", "XL", },
		selection = 1,
	}
	gui:attach(gui_columns)
	
	gui:attach(ui_label {
		x = (480 // 2) - 120, y = 140, width = 120, height = 13,
		label = "Speed:",
	})
	gui_speed = ui_hchoice {
		x = (480 // 2) - 70, y = 140, width = 300, height = 13,
		labels = { "300", "325", "350", "375", "400", "425", "450", "475", "500",
			"525", "550", "575", "600", },
		selection = 1,
	}
	gui:attach(gui_speed)

	gui:attach(ui_button {
		x = (480 // 2) - (60 // 2), y = 230, width = 60, height = 13,
		label = "Start",
		tap =
			function(self)
				start_requested = true
			end
	})
end


function in_prelaunch_waves:exit()
end


function in_prelaunch_waves:update()
	ui_update_all()
	if start_requested then
		if gui_tiling.selection == 1 then
			config.tiling = "square"
			color_gem_skin = 0
		elseif gui_tiling.selection == 2 then
			config.tiling = "hex"
			color_gem_skin = 4
		end

		config.number_of_colours = clamp(gui_colours.selection + 4, 5, 8)

		config.columns = clamp(4 + 2 * gui_columns.selection, 6, 15)
		if config.tiling == "hex" then
			config.columns += 1
		end
		
		local speed_min = 0.300
		local speed_increment = 0.025
		config.speed = speed_min + speed_increment * (gui_speed.selection - 1)
		
		return in_game
	end
end


function in_prelaunch_waves:draw()
	spr(112, 0, 0)
--	gfx_draw_starry_background(0, 0, 480, 270)
	ui_draw_all()
end
:: src/sgrid.lua
--[[pod_format="raw",created="2024-08-24 07:17:45",modified="2025-02-25 20:58:26",revision=6272]]
--- Square Grids

--- The origin of the grid, `pos(0, 0)`, is at the top left.


---------------------------------------------------------------------------


local max_width <const> = 14
local max_height <const> = 12

local dx <const> = 25
local dy <const> = 25

local gem_offset_x = -1
local gem_offset_y = -1


----------------------------------------------------------------------------


local metatable = {}


function metatable:new_grid()
	return sgrid_new()
end


function sgrid_new()
	local grid = {}
	setmetatable(grid, { __index = metatable })
	for i = 0, max_width * max_height do
		grid[i] = false
	end
	return grid
end


function metatable:clone()
	local grid = self:new_grid()
	grid.origin = self.origin
	self:foreachpos(function(p, item) grid:set(p, item) end)
	return grid
end


-------------------------------------------------------------------------------


function metatable:tiling()
	return "square"
end


function metatable:max_width()
	return max_width
end


function metatable:max_height()
	return max_height
end


--------------------------------------------------------------------------------


function metatable:get(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	return self[p.x + (p.y * max_width)]
end


function metatable:set(p, value)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	self[p.x + (p.y * max_width)] = value
end


function metatable:merge(p, state)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	local index = p.x + (p.y * max_width)
	if not self[index] then
		self[index] = {}
	end
	for k, v in pairs(state) do
		self[index][k] = v
	end
end


function metatable:del(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	self[p.x + (p.y * max_width)] = false
end


function metatable:distance(p0, p1)
	return abs(p0.x - p1.x) + abs(p0.y - p1.y)
end


-------------------------------------------------------------------------------


local function compute_screen_size(self)
	local min_p = pos(max_width, max_height)
	local max_p = pos(0, 0)
	self:foreachpos(
		function(position, cell)
			if not cell or cell == 0 then
				return
			end
			if position.x < min_p.x then min_p.x = position.x end
			if position.y < min_p.y then min_p.y = position.y end
			if position.x > max_p.x then max_p.x = position.x end
			if position.y > max_p.y then max_p.y = position.y end
		end
	)
	local width = 1 + max_p.x - min_p.x
	local height = 1 + max_p.y - min_p.y
	return min_p, max_p, width, height
end


function metatable:set_center_coords(x, y)
	local min_p, max_p, width, height = compute_screen_size(self)
	self.origin = {
		x = x - ((width * dx) // 2) - (min_p.x * dx),
		y = y - ((height * dy) // 2) - (min_p.y * dy),
	}
	self.screen_width = width * dx + 1
	self.screen_height = height * dy
end


function metatable:set_bottom_center_coords(x, y)
	local min_p, max_p, width, height = compute_screen_size(self)
	self.origin = {
		x = x - ((width * dx) // 2) - (min_p.x * dx),
		y = y - (max_p.y * dy) - dy,
	}
	self.screen_width = width * dx + 1
	self.screen_height = height * dy
end


function metatable:offset_coords(x, y)
	self.origin.x += flr(x * dx)
	self.origin.y += flr(y * dy)
end


function metatable:coords_cell(p)
	return self.origin.x + p.x * dx, self.origin.y + p.y * dy
end


function metatable:coords_gem(p)
	return self.origin.x + p.x * dx + gem_offset_x,
		self.origin.y + p.y * dy + gem_offset_y
end


function metatable:pos(x, y)
	return pos((x - self.origin.x) // dx, (y - self.origin.y) // dy)
end


----------------------------------------------------------------------------


function metatable:foreachpos(func)
	local p = pos(0, 0)
	for x = 0, max_width do
		for y = 0, max_height do
			local p = pos(x, y)
			local item = self:get(p)
			if item then
				local stop_requested = func(p, item)
				if stop_requested then
					return
				end
			end
		end
	end
end	


function metatable:neighbours(p)
	return {
		{ position = p + pos(1, 0), direction = "horizontal" },
		{ position = p + pos(0, 1), direction = "vertical" },
		{ position = p + pos(-1, 0), direction = "horizontal" },
		{ position = p + pos(0, -1), direction = "vertical" },
	}
end


function metatable:blast_radius(p)
	return {
		p + pos(0, 0),
		p + pos(1, 0),
		p + pos(1, 1),
		p + pos(0, 1),
		p + pos(-1, 1),
		p + pos(-1, 0),
		p + pos(-1, -1),
		p + pos(0, -1),
		p + pos(1, -1),
	}
end

:: src/ui.lua
--[[pod_format="raw",created="2024-09-20 07:57:16",modified="2025-02-25 20:58:26",revision=1897]]
local gui = false


function ui_create_root()
	gui = create_gui()
	return gui
end


function ui_delete_root()
	gui = false
end


function ui_update_all()
	gui:update_all()
end


function ui_draw_all()
	gui:draw_all()
end


------------------------------------------------------------------------


local function panel_draw(self)
	rectfill(0, 0, self.width, self.height, 60)
end


function ui_panel(el)
	el = el or {}
	el.draw = el.draw or panel_draw
	gui:new(el)
	return el
end


------------------------------------------------------------------------


local function label_draw(self)
	local x = 2
	if self.centered then
		x = (self.width - (5 * #self.label)) // 2
	end
	local y = (self.height - 6) // 2
	cursor(x, y, 7)
	print(self.label)
end


function ui_label(el)
	el = el or {}
	el.label = el.label or ""
	el.draw = el.draw or label_draw
	gui:new(el)
	return el
end


------------------------------------------------------------------------


local function button_draw(self)
	if self.clicked then
		if self.sprite_clicked then
			spr(self.sprite_clicked, 0, 0)
		else
			rectfill(0, 0, self.width, self.height, 49)
		end
	else
		if self.sprite then
			spr(self.sprite, 0, 0)
		else
			rectfill(0, 0, self.width, self.height, 50)
		end
	end
	local x = (self.width - (5 * #self.label)) // 2
	local y = (self.height - 6) // 2
	cursor(x, y, 1)
	print(self.label)
end


local function button_click(self)
	self.clicked = true
end

local function button_release(self)
	self.clicked = false
end


function ui_button(el)
	el = el or {}
	el.label = el.label or ""
	if el.sprite then
		local s = get_spr(el.sprite)
		el.width = el.width or s:width()
		el.height = el.height or s:height()
	end
	el.cursor = el.cursor or "pointer"
	el.draw = el.draw or button_draw
	el.click = el.click or button_click
	el.release = el.release or button_release
	gui:new(el)
	return el
end


------------------------------------------------------------------------


local function hchoice_draw(self)
	local part_width = self.width // (#self.labels)
	for i, label in ipairs(self.labels) do
		local x = (i - 1) * part_width
		local bg = 50
		if self.selection == i then
			bg = 55
		elseif self.clicked_choice == i then
			bg = 49
		end
		rectfill(x, 0, x + part_width - 2, self.height, bg)
		local label_x = x + ((part_width - (5 * #label)) // 2)
		local label_y = (self.height - 6) // 2
		cursor(label_x, label_y, 1)
		print(label)
	end
end


local function hchoice_click(self, msg)
	local part_width = self.width // (#self.labels)
	self.clicked_choice = 1 + (msg.mx // part_width)
end


local function hchoice_tap(self, msg)
	local part_width = self.width // (#self.labels)
	self.selection = 1 + (msg.mx // part_width)
	self:change()
end


local function hchoice_release(self)
	self.clicked_choice = false
end


function ui_hchoice(el)
	el = el or {}
	el.labels = el.labels or {}
	el.cursor = el.cursor or "pointer"
	el.draw = el.draw or hchoice_draw
	el.click = el.click or hchoice_click
	el.tap = el.tap or hchoice_tap
	el.release = el.release or hchoice_release
	el.change = el.change or function(self) end
	gui:new(el)
	return el
end

:: src/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTI0IDA3OjE3OjA5Iixtb2RpZmllZD0iMjAyNS0w
Mi0yNSAyMDo1ODoyNiJdXQ==
:: debug.lua
--[[pod_format="raw",created="2024-08-24 12:45:09",modified="2024-09-24 07:41:11",revision=77]]
-- Detect uninitialized globals and typos
-- from @snowkittykira from the BBS


-- if you're using include(), include this after including everything else,
-- since most included modules will need to assign global variables on load

-- these globals are needed by picotron
_init = _init or false
_draw = _draw or false
_update = _update or false
-- these are used by the picotron terminal
cproj_draw = cproj_draw or false
cproj_update = cproj_update or false
_ = _ or false
_is_terminal_command = _is_terminal_command or false
k = k or false
res = res or false
-- gui needs these
drag_t = drag_t or false

local function unknown_variable (t, k)
  error (debug.traceback ('unknown variable ' .. tostring (k), 2))
end

setmetatable (_G, {
  __index = unknown_variable,
  __newindex = unknown_variable,
})
:: drakma.lua
b64$LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNC0wNC0wNyAwNzo0Mjo0NSIsbW9k
aWZpZWQ9IjIwMjUtMDItMTcgMDk6NTY6MDAiLHJldmlzaW9uPTIxMDZdXQpfbW9kdWxlcyA9IHt9
CgotLSBBICdyZXF1aXJlJyBmdW5jdGlvbiBzaW1pbGFyIHRvIHN0YW5kYXJkIEx1YS4KLS0gSWRl
YSBmcm9tIGVsZ29waGVyIG9uIHRoZSBCQlMKZnVuY3Rpb24gcmVxdWlyZShuYW1lKQoJbG9jYWwg
Y2FjaGVkID0gX21vZHVsZXNbbmFtZV0KCWlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQKCglsb2Nh
bCBmaWxlbmFtZSA9IGZ1bGxwYXRoKG5hbWUgLi4gJy5sdWEnKQoJbG9jYWwgc3JjID0gZmV0Y2go
ZmlsZW5hbWUpIAoKCWlmICh0eXBlKHNyYykgIT0gInN0cmluZyIpIHBhbmljKCJjb3VsZCBub3Qg
aW5jbHVkZSAiIC4uIGZpbGVuYW1lKQoKCS0tIGh0dHBzOi8vd3d3Lmx1YS5vcmcvbWFudWFsLzUu
NC9tYW51YWwuaHRtbCNwZGYtbG9hZAoJLS0gY2h1bmsgbmFtZSAoZm9yIGVycm9yIHJlcG9ydGlu
ZykKCS0tIG1vZGUgKCJ0IiBmb3IgdGV4dCBvbmx5IC0tIG5vIGJpbmFyeSBjaHVuayBsb2FkaW5n
KQoJLS0gX0VOViB1cHZhbHVlCgktLSBAIGlzIGEgc3BlY2lhbCBjaGFyYWN0ZXIgdGhhdCB0ZWxs
cyBkZWJ1Z2dlciB0aGUgc3RyaW5nIGlzIGEgZmlsZW5hbWUKCWxvY2FsIGZ1bmMsIGVyciA9IGxv
YWQoc3JjLCAiQCIgLi4gZmlsZW5hbWUsICJ0IiwgX0VOVikKCWlmIChub3QgZnVuYykgcGFuaWMo
IlN5bnRheCBlcnJvcjoiLCB0b3N0cihlcnIpKQoKCWxvY2FsIG1vZHVsZSA9IGZ1bmMoKQoJX21v
ZHVsZXNbbmFtZV0gPSBtb2R1bGUKCglyZXR1cm4gbW9kdWxlCmVuZAoKCmZ1bmN0aW9uIHBhbmlj
KC4uLikKCWxvY2FsIGFyZ3MgPSB7IC4uLiB9Cglmb3JlYWNoKAoJCWFyZ3MsCgkJZnVuY3Rpb24o
c3RyKQoJCQlzZW5kX21lc3NhZ2UoMywgeyBldmVudCA9ICJyZXBvcnRfZXJyb3IiLCBjb250ZW50
ID0gc3RyIH0pCgkJZW5kCgkpCglzdG9wKCkKZW5kCgoKLS0gVGFibGUgdXRpbGl0eSBmdW5jdGlv
bnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0KCgpmdW5jdGlvbiBpc19lbXB0eSh0KQoJcmF3ZXF1YWwobmV4dCh0KSwgbmlsKQplbmQKCmZ1
bmN0aW9uIGRlZXBfY29weSh0LCBhbHJlYWR5KQoJaWYgKG5vdCBhbHJlYWR5KSBhbHJlYWR5ID0g
e30KCWlmIHR5cGUodCkgPT0gInRhYmxlIiB0aGVuCgkJaWYgYWxyZWFkeSBhbmQgYWxyZWFkeVt0
XSB0aGVuCgkJCXJldHVybiBhbHJlYWR5W3RdCgkJZW5kCgkJbG9jYWwgbmV3ID0ge30KCQlhbHJl
YWR5W3RdID0gbmV3CgkJZm9yIGssIHYgaW4gcGFpcnModCkgZG8KCQkJbmV3W2tdID0gZGVlcF9j
b3B5KHYsIGFscmVhZHkpCgkJZW5kCgkJcmV0dXJuIG5ldwoJZWxzZQoJCXJldHVybiB0CgllbmQK
ZW5kCgoKZnVuY3Rpb24gdG9zdHJyZWModCkKCWlmIHR5cGUodCkgIT0gInRhYmxlIiB0aGVuCgkJ
cmV0dXJuIHRvc3RyKHQpCgllbmQKCQoJbG9jYWwgcyA9IG5pbAoJZm9yIGssIHYgaW4gcGFpcnMo
dCkgZG8KCQlpZiBub3QocykgdGhlbgoJCQlzID0gInsgIgoJCWVsc2UKCQkJcyAuLj0gIiwgIgoJ
CWVuZAoJCXMgLi49IHRvc3RyKGspIC4uICIgPSAiIC4uIHRvc3RycmVjKHYpCgllbmQKCWlmIG5v
dCBzIHRoZW4KCQlyZXR1cm4gInt9IgoJZW5kCglzIC4uPSAiIH0iCgoJcmV0dXJuIHMKZW5kCgoK
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCgpsb2NhbCBiaXRfbm9pc2VfMSA8Y29uc3Q_ID0gMHg2
OGUzMWRhNGI1Mjk3YTRkCmxvY2FsIGJpdF9ub2lzZV8yIDxjb25zdD4gPSAweGI1Mjk3YTRkMWI1
NmM0ZTkKbG9jYWwgYml0X25vaXNlXzMgPGNvbnN0PiA9IDB4MWI1NmM0ZTk2OGUzMWRhNApmdW5j
dGlvbiBub2lzZTFkKHBvc2l0aW9uLCBzZWVkKQoJbG9jYWwgbWFuZ2xlZF9iaXRzID0gZmxyKHBv
c2l0aW9uKQoJbWFuZ2xlZF9iaXRzICo9IGJpdF9ub2lzZV8xCgltYW5nbGVkX2JpdHMgKz0gc2Vl
ZAoJbWFuZ2xlZF9iaXRzIF5ePSAobWFuZ2xlZF9iaXRzID4_IDgpCgltYW5nbGVkX2JpdHMgKz0g
Yml0X25vaXNlXzIKCW1hbmdsZWRfYml0cyBeXj0gKG1hbmdsZWRfYml0cyA8PCA4KQoJbWFuZ2xl
ZF9iaXRzICo9IGJpdF9ub2lzZV8zCgltYW5nbGVkX2JpdHMgXl49IChtYW5nbGVkX2JpdHMgPj4g
OCkKCXJldHVybiBtYW5nbGVkX2JpdHMKZW5kCgoKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCgpm
dW5jdGlvbiBjbGFtcCh2LCBtaW4sIG1heCkKCWlmIHYgPCBtaW4gdGhlbgoJCXJldHVybiBtaW4K
CWVuZAoJaWYgdiA_IG1heCB0aGVuCgkJcmV0dXJuIG1heAoJZW5kCglyZXR1cm4gdgplbmQKCgpm
dW5jdGlvbiBleHBfZGVjYXkoYSwgYiwgZGVjYXksIGR0KQoJLS0tIExlcnAgc21vb3RoaW5nLCBi
dXQgZnJhbWVyYXRlLWluZGVwZW5kYW50LCBmcm9tIEZyZXlhIEhvbG3DqXIKCS0tLSBodHRwczov
L3d3dy55b3V0dWJlLmNvbS93YXRjaD92PUxTTlF1RkVET3lRCgktLS0gVXNlIGFzIGBhID0gZXhw
X2RlY2F5KGEsIGIsIGRlY2F5LCBkdClgCglyZXR1cm4gYiArIChhIC0gYikgKiBtYXRoLmV4cCgt
IGRlY2F5ICogZHQpCmVuZAoKCi0tIFBvcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKCi0tIFdBUk5JTkc6
IGRvIG5vdCBmb3JnZXQgdGhhdCBgcG9zYCBpcyBhIHJlZmVyZW5jZSB0eXBlLCBub3QgYSB2YWx1
ZToKLS0gYXZvaWQgbW9kaWZ5aW5nIGluIHBsYWNlLgpmdW5jdGlvbiBwb3MoeCwgeSkKCWxvY2Fs
IHAgPSB1c2VyZGF0YSgiaTE2IiwgMikKCXAueCA9IHgKCXAueSA9IHkKCXJldHVybiBwCmVuZAoK
ZnVuY3Rpb24gZXFfcG9zKHAxLCBwMikKCXJldHVybiBwMS54ID09IHAyLnggYW5kIHAxLnkgPT0g
cDIueQplbmQKCgotLSBEcmF3aW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCgotLSBGcm9tIFNvcGhpZSBv
biB0aGUgZGlzY29yZApmdW5jdGlvbiBnZXRfZHJhd3NwYWNlKCkKICAgIHJldHVybiB7CiAgICAg
ICAgY2FtX3g9cGVlazQoMHg1NTEwKSwKICAgICAgICBjYW1feT1wZWVrNCgweDU1MTQpLAogICAg
ICAgIGNsaXBfbD1wZWVrMigweDU1MjgpLAogICAgICAgIGNsaXBfdD1wZWVrMigweDU1MmEpLAog
ICAgICAgIGNsaXBfcj1wZWVrMigweDU1MmMpLAogICAgICAgIGNsaXBfYj1wZWVrMigweDU1MmUp
LAogICAgfQplbmQKCgpmdW5jdGlvbiBzZXRfZHJhd3NwYWNlKGRyYXdzcGFjZSkKICAgIHBva2U0
KDB4NTUxMCxkcmF3c3BhY2UuY2FtX3gpCiAgICBwb2tlNCgweDU1MTQsZHJhd3NwYWNlLmNhbV95
KQogICAgcG9rZTIoMHg1NTI4LGRyYXdzcGFjZS5jbGlwX2wpCiAgICBwb2tlMigweDU1MmEsZHJh
d3NwYWNlLmNsaXBfdCkKICAgIHBva2UyKDB4NTUyYyxkcmF3c3BhY2UuY2xpcF9yKQogICAgcG9r
ZTIoMHg1NTJlLGRyYXdzcGFjZS5jbGlwX2IpCmVuZA==
:: main.lua
--[[pod_format="raw",created="2024-03-30 05:39:34",modified="2025-02-25 20:58:26",revision=8306]]
include "drakma.lua"
include "src/constants.lua"
include "src/sgrid.lua"
include "src/hgrid.lua"
include "src/ui.lua"
include "src/logic/creation.lua"
include "src/logic/matching.lua"
include "src/logic/spells.lua"
include "src/logic/mechanics.lua"
include "src/gfx.lua"
include "src/in_game.lua"
include "src/in_mode_selection.lua"
include "src/in_prelaunch_endurance.lua"
include "src/in_prelaunch_waves.lua"
--include "debug.lua"


local state = in_prelaunch_waves --- in_mode_selection
local next_state = false


function _init()
	window { cursor = "" }
	fetch("pal/0.pal"):poke(0x5000)
	for c = 0, 63 do
		for i = 0, 63 do
			poke(0xa000 + (c * 64) + i, i - 1)
			poke(0xb000 + (c * 64) + i, i + 1)
		end
	end
	state:enter()
end


function _update()
	if next_state then
		state:exit()
		state = next_state
		state:enter()
	end
	next_state = state:update()
end


function _draw()
	state:draw()
	print(string.format("\014% 3.0f%%", stat(1) * 100.0), 4, 256, 7)
	print(string.format("\014% 3.1fMB", stat(0) / (1024 * 1024)), 4, 262, 7)
end
:: .info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTIzIDE4OjQ1OjEzIixtb2RpZmllZD0iMjAyNS0w
Mi0yNSAyMDo1ODoyNiIscnVudGltZT0xMyxzdG9yZWQ9IjIwMjQtMDMtMzAgMDY6NTQ6MjQiLHdv
cmtzcGFjZXM9e3tsb2NhdGlvbj0ic3JjL3VpLmx1YSMxIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xv
Y2F0aW9uPSJzcmMvbG9naWMvc3BlbGxzLmx1YSMxIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0
aW9uPSJzcmMvaW5fZ2FtZS5sdWEjMSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ic3Jj
L2dmeC5sdWEjMSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ic3JjL2luX3ByZWxhdW5j
aF93YXZlcy5sdWEjMSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ic3JjL3NncmlkLmx1
YSMxIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJzcmMvaGdyaWQubHVhIzEiLHdvcmtz
cGFjZV9pbmRleD0xfSx7bG9jYXRpb249Im1haW4ubHVhIzEiLHdvcmtzcGFjZV9pbmRleD0xfSx7
bG9jYXRpb249ImdmeC8wLmdmeCIsd29ya3NwYWNlX2luZGV4PTJ9LHtsb2NhdGlvbj0ic2Z4LzAu
c2Z4Iix3b3Jrc3BhY2VfaW5kZXg9NH0se2xvY2F0aW9uPSJwYWwvMC5wYWwiLHdvcmtzcGFjZV9p
bmRleD03fX1dXQ==
:: [eoc]
