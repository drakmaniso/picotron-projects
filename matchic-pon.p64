picotron cartridge // www.picotron.net
version 2

:: docs/
:: docs/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTI2IDE0OjAzOjI1Iixtb2RpZmllZD0iMjAyNC0w
OS0xNiAxMTowMDo1MSJdXQ==
:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNC0w
OS0xNiAxMTowMDo1MSIscmV2aXNpb249NTg0NF1dbHo0AAlYAAAi2AAA8xR7WzBdPXtibXA9cHh1
AEMgEBAE8PAsZmxhZ3M9MCxwYW5feAgAz3k9MCx6b29tPTZ9LDEA-1DwER0dBPBPPxJAPuAODxYf
Kg8VDiAOHyofFg7QDg8qPxUuBQBADg81wB4ApBQfFS8WHxUfFA8TANUPFQ8UDxNPFQ8TDxQfKAAB
FQARLxUAEC8VADGQPyw_AFATLxUfEz4A-AYeHytgDyw-LS8VXy0-LB8VHywPK1ARAD8PNUATACXz
AFBPLC8TTywvKx8TLysfNVsANU8tLyIAH2ATAITvcD8rLn0eHR81gPwD8C7JAR3yPDkvKxAPD-AG
DysgHvAFTyzwBw0-LQ0O8AYNDD0ODzXwAx1sHfABDawN4A28HcANLB8qjA0OoA0sK4wdDpANLBuc
HQ4PNXAN-AAtDgYAKwpgBwAm7D0GAP8g3E0OCnANvE0OGnANrF0OCpAdbG0OGqAOzQ4awA6tDhrg
Hm0eGvABCm4q8ARq8BfNAB3wBU0PLOAOoA4PLQ7ADg0OkA4dDqAOoABAgA4tDgQA0QyADg0PKx0O
YA4dCw0OAFIbHW4dGwsAMyuNKxQAEq0SACr9AQYAkHAOLS5tLi0OcFQA8QkaDyoLDk0OCgsPGg4d
DgxgDh0OCRsJDi0GAAERADMtDikEAIAMYA49Lk0uPQkAIP0DSQD-Jm0vCW0OHEBbXQhdW3AOPQ4d
Dh0OPQ4cgDstHg0eLTtwGyAOrQ4cABuwHm0eHPABDG4s8ARsEAEf8AKLDytgDvAEHkAe8AQODyxO
DQ0A8DFNHtAuIA5tDiAuDzVAHi0eAA4NHw8NHA0OAB4tHiAObR4MDyoODAsODB5tDhAOfQ4MHgwe
DA59Dg81AA59Dg0cKwDwCX0OCgAOjQ5NDo0OCgA_bQ4tDm0_CgAOGt8A8AYaDgoQCgA_zT4KEAow
DhoOLQ5NDi0WAPAGcAoATk1OChAKkA4qDk0OKg4K0AogGwD-AiAK8AMODQ4a8AkOGvALCvBx6AAd
IBoPCgNwLPAKDysPFhQDIvAJEgAgDzUUABEfBgBBDzXwCwYA8AQE7yvADu8tDqAODf8sAA6QDg38
BgDwDhw_TD4cDg81YC4MDg8NHw8PDQ4sDgsfDwsODC5A0wHwBQ4KHxAKDiwOChkKDgwOHQ4wDg0M
FgAWGRUAAEAAsSAOHA4MDgsaCw4sBgAAFgAQCBUAAmEA8AIcDggwLvwBLhhACA78AQ4oYAYAYAiA
DjyOPAcAUiwOjQ4sCQBVDQ5MDgwNABB8CgAwkA4cCgCvHA4YoO4YwOjwMCoBKR8SKgEWULAODd8s
lgUFMgEXDC0BVTwOLA48JQEDDgAFIAEwXixeAgESCxcBYA8cHx0PHDABIh8dMQEYCxsBEQsbATAb
QAsVARErGwESCxsBFAsbARgLGwEVCxsBFQsbAW8boO4bwOsbAR-wGS8fK6AusA4fLR5wDi0ekA4f
LB0eQA48HR5gDkwdHhAOHA8NDw8PDRwWAPIEbB0eLA8PDxAPDzwdDiAOnB0eDB4AoVwOIA4sHmwd
HnwwA-ECHB4LDiwePB0eXA4LAC4rDgwQAKMMHR48DgsQKxAeEgByHS4MDgtwGxAA8QUMDi0eC8Ab
EB4bDjwNDgvwAhsADhwB4PABHhAOTA4LsB4gDg0e-wAhG2ALAHIADkwuGxAuCwCSDB0eLB47IA4d
DABAXB4rYAgA-xiMHiuADrweK7AOjB4r0A5sHivwAQ48HivwAw4cHivwBh4r8Akb8CI1AR3xCBYf
K2Ae8AAeDy0ODzVQDg8tHrAeHQ8sDQDwEA0fLB5wHh0cDh81YA48HkAOHTwOC3AOXA4wDkwOG4DL
ANAwDjw_QD48DhswDkwdDwBQHUwOC1AfABBABQAjUA4PACELcO4AAAUAYXAOLD4gPvEB8AMsHQ4L
EA4dLA4bkA48DhsgDjwWAAG3AxAwKwAQgIECEBxMABAcKgKADSwODD4APgxEABMNsAFxDhwdDgsO
HSAAEhzSAQEzAABzASQbgPQBABMAIAsQBQBgoA5cDhwuZQJADlwODNwFoA4LwA5cDg08DhsIAAGp
ATDgDky0ADDgDlyGAI-wAJ4b8AKbsFsBHdAyLyugHqAeLy0OcB4dBABAPywOQE8BALcFFB2OAqIO
EB4dTA4wDh08vgBBLB4dbIUEE1y7ALAeHZwOIA58Hh1sHpcB8QQQDlweHTweLA4LHhwOEA48Hh0M
DQDFDA4LAAsuCwAODC4dEACVHgsgKwAeLQ4MDwAhG2DrAAAKABGw7QDxCiAb8AEOTA4QHvADDiwO
DB4NDiAe4C5MDgAKAHKgGx4sHh0MDgBSLnALHlwOAHAdDguACx6MDQCwG6ALHrwOC9ALHowsAeAL
HmwOC-ADCx48DhvwBaUAvwvwCAseG-AKG-ARQwEd8gYanyvwAg4vLQ5dDvAADg0-LA5MDvBOAyBc
DqYBMVwO0DACMAwOXDMIIAwuGQAQsDcCIC81sAQEZQEQoBMAAD0BABQAAWgBEBwGBTAsDgAFAAQm
AHCQDg0_DzU_BAUAIwVBDjsAG2wAYKAODRwOQAUAEAwMAAGfAiANLGgAUjwOIA4NtgJgHD4LED4s
OQBQHA47IBvFAhBwHAABcQEBCgAkC1AGABBcTgCxXA5QDg0sPgswPjxRAGA8DjtAGw4MAkANTA6A
BQBBCzAePEYAcCweG0ALHixMAEEcHitw3gH-A1AODR4rsAseC1AeK-AAG2AbcG4JfTH9Aw4FAAFd
CRDNXQZ0YA4tTi1OLUgJBU4JEilNCR8JTQlGDyQNEB8yMQD--0gAbANvDv83CxD_AwA5L-AOhAAL
HzWEAAATODwAD4QAZm--Ow3-PA0GAD4PhgAdBzsADwYAOA_GAAwPRQIdDbEFTw87DzwEACEXHwwA
DzgA--------By8PO4kGHQc7AA8EABkXHwwADzgA--------By8PPIkGHHGPPA89DzuvBgARTwYA
Mv88AAcAEAEHABHPFAAXfyAAER8GABePDAAX7wYAAjAAJF88NAARLwYAFQ80ABMvZAAWBFcAFx8p
AASDABAHBwAX3xMAEZ8GABE-BgAYvyUAF28lACZfPFYANv88Eg0ALD88KwAdHxgANv88CA0AE58T
ABYCLAAXfz4AA3wABV0AJztPIwATHyMAFhYTABd-uAAIEgAXzzoBAiQBGd9DABYTkgAIqwAP5AEZ
8SgjIATwG-82A-AA-gPg-gXQ-gXA-gew-geg-gmQ-gmA-gtw-gtg-g1Q-g1A-g8w-g8g-hEQ-hEg
DAARQBgAEWAkABGAMAARoDwAEcBIACHg-lUAL-Abtg8ZAo8AHzePAHsfOI8AePM1cP87A_D-PAXQ
-zsFwP88B7D-Oweg-zwJkP87CYD-PAtw-zsLYP88DVD-Ow1A-zwPMP87DyD-PBEQ-zsRAP88E-87
EwAPABMgHwATQC8AE2A-ABOATwAToF8AE8BvAF-g-zwDcIMRHg8xAHsAQgEEQAMTn0wDIOBuCAAw
vtAuBwAQjgUA8ABOwP4GDz2wDQ87-gANDC7uAaBODQw_DQyODQwO9gHxBS4NDP4GYJ4NDF4NDC4N
DD5QDP4LAwLBPg0M7g0MfiAODQzOLwDyAD4Qng0M-gINDA4ADP4EDQQAEAM2ABAARQBCDBD_AFoA
USAMbg0MbwADPAJBvg0Mfl4AEWBuABBwHAAQjkkCAUAAkR4NoF4NDO6wDiYAIZ7AOgC-0F4NDM7g
rg0MTg2pAQwcMekF8BPwFb80DzHQ3zQvMaDfNE8xgF80XzIPMQ8wDzRfMWBPNH8yCwDwCS8yTzFA
TzSPMg8xTzJPMTA-NP8yAT8xIAgAQQM-MRAIAL8fMR8wEC80-zIFLwgAGXEvMg8x-zIBDAByHzEP
MP8yAgwAMjAPNAwAEB8YAAAMAFA-MBA-MXIAIDAgCADxDgE-MDBPMX8yDzFfMk8wQE8xbzIfMT8y
TzBgXzE-xQD-Bi8yXzCATzHfMKAvMd8w0A8xvzDwFQsHHAMiAVCfNA8yLyYBAA4AHw8qARBCMA80
PywBEZ8NACFPMjEBYb8yDzBfMjQBEa8-ABA-HgATMj0BYA8yDzGPMvsAAL0AAV4AJDIvGQASfxEA
YDQfMg8wLwoAEjEpAQH4AAJ9ABAvdgABFQAQMloAAFYAABcAIA8wEgACLgAjMh9vAEUfNJ8yggFU
LzAfNL8iAABnAEEfNC8wEQAhDzQPABIxxABFDzCvMp8BFF8PAAKiAaFvMg8wTzIPMT8yqQExfzIf
xAAhTzKwAQAgARMvHgARMKwBEjD-AAG7AQBLAVIfMB8xH78BPw8yP78BNgAiARBwogBgoE80LzFA
xQHggF80LzEwLzRPMWBvNC_XAQBxACFQT_sAEA-qAXAxEB80PzI-vwEASwEBRQFUMQ8wAB-IAQLL
ABIfEgAATwEwIC80ugFBAA80H_QAQSAvNH8rASAxH-IAAIEAADQAAIcBkjAfMU8wQA80P8UB8FIy
LzBATmA-MS8yPvADLzFeQD80gB0AHzFOMF0cUB0PMgwQLkBdTDAMGw6QPRtcIAweEC0cID1LPGAt
GxwQLWscHkAtKywAHVsMGy5ALTscAB1LDCsuMC0bDBssAA0MKwwODgD-HgsMDSsMDgAsOwwLPjAd
HA07HgA8K05QPCsuACyOYBxeIAyOgG4wfrAugC7wE2QBHfEFNk808AMuAA5PMw8yAC7ADi8zDzIN
AHAOLzMOsA49BQLwBw8xTaAMPQ8yDEMMCz0McB4NDA0bgxvSBPAGQB4tHDMFFAUEExwOHRswDj0L
IxQFAgCiAws9CzAOLQsjBRAAtQQDLQsMMAwrDBMEEgBUKxxALCMPAGMUAyxQLhMMAHcFFAMuQA4t
DwBjDi0wDh0LEQAQHxIAQy0LMC0RAMIKDyoaFAMdGzALHQwSAII6AwQDKwxALA4ARwUaEwRfAC8E
E18AAggQABo9DwAnLQt_AAt9AAACAAB8ABMrewAAAgABfACP-zABLHD-NQTjHx-wEYQvNPUBLkAO
DyoODzL1AS4NMC4N9AEuDSAuDfUDLg0QGQCADfQDDgwODRAFADFkTmQMAHAuDVReDVQuCQDwAH4r
Dg2ODRCuCwwPDA8KCQwA8A_dDgsPDB8KCa0gLVMOCyoJDVMtMB4NVB4pDg1UHg0LABNeCQAxZE1k
CAAm9AMHACL_CAQAcQ79CED-MAfZAB9L2QBhJS8Q2gBUEQ8PDw7bAFIRHw8PDtwAEC8XAAPeAB8q
3gCcFRXeABAWPywE3gBTFh8UDxPeAAAXAA-eAKQjGh3dAFQbDxkPGN0AUxsfGQ8Y3QAAFwAE3QAT
HdwALx5N3ACRFB-cAFQgDx4PHdwAUyAfHg8d3AAAFwAP3ACjFCTcAFQlDyMPItwAUyUfIw8i3AAA
FwAP3ABeC_AJVm80DzE-5AkADgkC-AcB6AlAHzQPMhoIAMkHAhUAAfIJAGQIJF8yJwkTP80IEDBY
CADHCDIvMS8XABEwPAgRHyoARD8wLzT-CQEQCgAbCAEdAB0xFgoQH60IDxgKAgFxAB9vGgoBIB80
hgANHAoB0AkBKgAEIAoRH18AHh8gCgA5CgLOAAkoChE-wwoDFQAGLgoBmAADVwAPOAoAAtIANC8x
Tz4KEU86AABeADY-MB9GCjM-Mi8XAABXAAA0AAFOCmIfMh8xXzBuAAF1AQBUClcvME80DxUAAVoK
AZEJFjAoAANeCi8-MFwKOw6EDg8xANDwCCMTBCAPFv8VDEAPFv8UDiAPFi8U-zAJTgYQEAwARg8w
bycEAAAXAFYADxY-FRMAAAQAcD8VDxMPFj8tABYoBAAhPxQWABsVFgAfFRYACABCABYpBAABQgAf
FRYAAh8WFgAICFgABkIADBYADywACQjcAAHzAB8VCgEBNRAPFS0BryD-FA4PE0D_DSB_ARmTBQcE
ACcAByAXAgBPBwAnAEAACxw4QACREAcgFxAHAAcwAgAvEEc-ABwBfwBCBzAHIAIADz8AJT8QF0C_
ACQRMEAArwAHAAcQBwBHIAdCAB1vVzA3QAcwfQAjIBcQfQARN4EBD0AAIBJHNwECwgAfIDoBIQJ3
AA5-AA9CABsQN4IAPxAXEEAAGf8CBwsEAD8qEF4AHh86Hg0eDQAFAAN-Xg0APh0QPZsADCwxNFwA
wRAfKjAuDzoQPg0gDd4HBQMAfxBeAF4NAF1RAB0HrQBAAB0AHqgIQRAuHQADAA9TADWfHh0gLkAe
DR4Q_AAqYEAeDzogLk4AcBAuDR4AHh1OAEFeDQAt-wAvQB1TAB3CXyoAXg86Hk1OEF4QRAAFoQAv
AE2hAB-gLyogPg86AC4tAB4dIE4BAR8d7AEsAqEAAOAABfcABQYAECDyAB8gmgEoAZoAPwA_HagA
MAxWAHFeDQBODRAdtwAATQFfLh0gLRBVABrxAQoQBBBPKjBuEI4ALi86Lg0XCw8FABCvjg0Abh0Q
Th0wTXAADBw5bwD-AyAvKlA_DzowTg0gXg0wHS4NUAMAAUAgjgCOZQAfjV4AHA7NAMcALRAuDUA_
DTA_HSADAB8wYQAxAVwAIFAuXABxMD4NQE5QDQ8ALy4gIQEpgRAvKmAuDzpQtgBBQC4dQAkAIQAu
KgQEfgEBvAARTW4AX1AuDWAtZAAc9QSPKgCODzqODS5tLg1QbiB_EI4QTQAPvgAr8QUgTyowXg86
EG4NAE49AD4dMC4dQGEAMwAuLb4AA8MAD2IAJQS8ACcAPR8BDwkABT9gLTBCAi4BBQB-AG4dAG4N
AMcANw9oAAShjg0Afg0Qbg0gLcYAUDBODRBeYQBvID4dQD0gZAAZ-gZeCAQQ-zpKIA7-O0oPPQAO
-ztMDz4GADAADz0hAEw_IP1KwwCxLTIzLjMxOTA0NzYGAANuAJItMC43MTQyODUGACI2OH4AClkE
0GYcBPBY9VIgBfRSAxAFADAPOgAHAB8OBgBrfBDzUh4g-lJ6BVMyNi43Nd8AHzOXGgEAzwDvv-RS
IATzUg87EATzUg4FAFsPtAAhwBEOBBAPFq8VMA8Wv_ALAgcAUhAPFt8VBA0xFF8OMgwSOhMAgw86
TxVfDj8VEgACGgAXFSYAEhUUADAADxVJABQfCQCvDzogvxMfOjC_EDkMGV8RDgTwA58AERMAEgAE
nQASAJwAFgCbABIAmgASEI8AEiAHAD8wviCPABwPLQEDQE8VPw4BQQGSAFEfDh8UH3QAACMBM38V
Hy8BAAoAIk8VFgBZXxQfDl8xASYPFRQADz0BTQ_vAAQWAK4AFACtABYArAADQgEWAKoAD00BKsEE
BAQAHzsADh86Dz0FAD8AHQBAAAsfMQUQLKEXCwTwAR87gE5QcAD-KVAeTzouIA4dDz1ADp0OIBxA
Dr0eMD4dXG0_HTxQDK0MUB4gHH0MUA4dDDAcPRxgDh0MUDyQHPAAcwAcUjAfO-AEcQAhTnAIAPAO
IC5POh5gHz0gDp86DhAuMB69DgAPPR0_bVwdDgB5APACLBAMfRwgHnAcPRwwDh0MgDyFAE-wBBxA
JBEeDzEA--_Y8F8oKAT-PxYC-gUC-i4G-h0CTgLuAv4UBv4GBv4HAv4NAv4DAv4CAgYCjgb_DAJO
Av4wAv4iAl4C3gb_OwL_BQb_AQI_Av4RAgYC3gKOAj4CThIGDzIGEv4TAgYC-hYC-hcC-jQC-hAC
-ioC-mMGvkIAEBAbADAHAt43ABH_JgACKwAQA0oA-wA9Bk4C-iMC7gJeAp4G-iSzIxnCKCgErz8C
-goCDgbuVgBgbgI_Bv4JEwAhPgIIAADhAAEaABCuFQCA-gwC-hIC-jeGAKDuAgYCfga_Av4ACwF6
BgI_Au4C3swA0J4C-gECngJ_Bl4G-lCvABEuvwBgCAL_HQbeagAQR0AAMg0Cfi8AgS4CTgYuAv4e
RQEQMYIA4AAG-iAC-i4CLgJ_Bv4NJgAxDgZuhgAfAegAHOFvPwb_MQKOBo4C-hkGfr0BIFcGigAy
CAJe4QAQzgwAEN4aADBeAo5rABcTzQARfpQAoBcCrgK_Av4TAr7dAXRVBv4LAv4UOQFg-gUCfgJu
OQAgFgK2AEEBAv4LqwAxDAJOHQKBWwb_IQY_Aj4YAOEFAv4SBv4PAv4LBm4Cng0AHyDTABwgjz9c
ABEumgAQAsYAcEQCfgaOAs53AgGUAGH_CALOAh5PAhAEaQAh-gTUAUEGAv4cEgACzQEQLVUBQf4C
Bq7PAkACAv4bTwAQvukAFQbdARDeTwBSBQKOAi4VARIelQIxrgJOSgAQFyEBMB0GrgcBQR0C-gPa
AFAFBv4lBkQAECIkACBOBk0CPw0CruYAHGD-PwsC-m9gADEiBp6TABMWZAFBAgb_HtEAETAmAhAS
cwGQ7gL_Mwb_gwKOrgAi-gAqAEGuAv5OEABgDAKuBv4nVwIzfgK_RgAQNJgCAEkAzywC-g4C-lEC
-h8GjqQAHhNssQIwAQKejwMYFkACEAHzAzEGAr6sABALjgBBQgb_Dk8DEAEvAUCuBv6RsQAkDAJw
ASH_MzYEUAwC-joGEgAVFj8AEDauAEG_Av5SYwJPLQL_LqsAHhAZiQECtwFBIgL_BqUBUAUC-g8G
CAFRHQJuAq70AxA7ZwBSEQI_AgaCBADHABA6FAABIgIQbmwEEC4rABECzAARLYABEQxWABEcpgFB
CQL_BCEDEARkARIeXwMCcwFQDAbOAo6FAzFEAl5QAE8NAv4ayAAeQjcG-gk8AzEQAr5BAxAG3AMB
YQNBAwb_XHQDAfUBIf4FOQUQAScAExaEAACtAwQNABHeqAASRtYDQAQC-jKBAQSRARAEWAUAvAAF
OwBBHwL_JkcCECDEABACUwRPKwL_HsEAGQAUHfApNWvwBBtqG-AAG7oJwAvaCQigCyocqgkIgAsq
LKoZCHALKhzKCQgPNVALWhlKGToZCFALSgkcCSoEAPABGQgOMAtKCTwJCgk8CRopCA0AMEwJTAsA
Yw4gC0oJrAoAUVoJjAkqCgBkaglsCSo5FAATGgoAEDxDABBJTQBwWgkcCQoJHBoA-yYeMAtqGSoZ
GkkIDlDqSQgeUBmqaQgOcAgZankIHoAI6QgeoBipGB7ADhhpGC7wAA5oLvAEbiBKH4A1bxDwBB5v
D8JF8A29Dw7ADt0MDw2gDi0fEa0MDw2ADi0vEa0cDw1wEgAwHSx9D0PwADVQDn0MHxEMbRwPDVAO
jQsAEF2MRPICNTAOnQwvEQxNLA8NMA6NDD8LAACKRAkNADh9DE8NAAAaAB88DQACAEwAEkxZAAFx
AAAaADIfNTBzABEtGgBQUJ0sHUwWAEBQHK1sEQD-D3APDRxtfAsfNYAL7AsaoBusGxrAChtsGyrw
AAprKlNMIjA1bxUjARIUIwEREyMBEBIjAVAWrQwPEiMBUBatHA8SIwFRFs0MDxIhAeBMXRwPElAO
bQxPFgxNHBUA8AUwDm0MbxYMPSwPEjAOXQyPFgwtLBgAHyANAA0vHTwNAAABTAAkHUxZAHBPFgwt
PA8SHgExfUwtFwBTUO1MDxIZARASGQEfEhkBPxAaGQESGRkBERgZARAXGQFQG60MDxcZAVAbrRwP
FxkBchstLG0MDxc8AiAvGzECERceARAbHgESF_MBAA0A4ywPFzAObRxPGxw9LA8X9wAzGwwtDQBo
TQyvGwwdDQAvDTwNAAAQXWQAYgsMKwwNTF0Agl08CzwdPA8XPwIxCww9GABzUI0sLUwPFyUBEBcl
Af8QFxxtfAofNYAK7AoZoBqsGhnACRpsGinwAAlqKfAEaSUBIRAfJQESHiUBER0lARAcJQFQIK0M
DxwlASAgLUsDEBwnAXAgPQx9DA8cJwFgnQx9HA8cYAMhDyAgAAJgAwANADcsDxwLAAJgA08vIAxd
DQABf30MTyAMPTwNAAVDLUwPHEICECBCAhEcQgIkDC8aAAIiARMcIgEQHCIBHxxHAj8QJCIBEiMi
AREiIgEQISIBUCWtDA8hIgFQJa0cDyEgAVElzQwPIUUCUDxtHA8hQgIgLyUeARIhxQBwLyUMfSwP
IWADUC8lDI0sGAASIA0AOD0cLQ8ARi0MCwwRADA7LBtaAwMOABWLDAAwbQxrZQMDXgAQSyIBFSFk
AxIhZAMTIR0BECEdAR8hPwI-ECkdARIoHQERJx0BECYdAVAqrQwPJh0BUCqtHA8mHQFQKs0MDyYd
AVH9AxwPJgcAEAu5AEL9BCwLBgAsCiAHACgDPAcA8AgCTAsKMA79ATwLGjAO-QBMCwpQ7UwLGt8A
QAsKcAv5AR8a_AE5EC7bABIt2wARLNsAECvbAFAvrQwPK9sAUC_tHA8r2wBUL80MDyvbAB8r2wCP
UBhs8AQcVgjwEBy6CcAM6gmgDBofKsoJgAwaLsoZYAwqHuoJCFAM_gRaCPAVMAxqHEocShkIMAxa
DBkMKgwZDDoZCA0QDFoMOQwKDDkMKikIDQAwSQxJCwBjDQAMWgypCgBgagyJDCo5CgBqegxpDDo5
FADwAmoMOQw5DBpJCA0QC2oMGQwKXwDwGzkIHRALehwqHCpJCA0w_gFJCB0wCepZCA1QCbppCB1g
GWqJCB2A_QAIHWAI-wEdwA0YaRgt8AANaC3wBG2QSx8ZAQkBIG8R5AGADx8Q8AAevw9hCKDvDw8O
oA4fDx8qEAAAZAhRHw8vKs8MAKBgDi8PHyrfDx8OWwhAfw8ujRYAAOoBcI0OHw4OfRxaCFCdDhwO
bQAC4BAOrQ4sDl0sCxAOnQ48CQAnCgAKAGKNDkwOTTwKAD08Dl0KAMAsDl1MCwoQDxCNDhwVADAa
EAlbABA9KgLBrS4tTAsaMAztXAsKJAJvGmALHF2MJAIHDxoBIBAWGgEwFB8VGgEQFFgIUO8UDxOg
XRUQKhAAAFsIUR8ULyrPDACgYA4vFB8q3xQfE1cIMP8UBBUAABkBQI8UTm0VAHAwDn0OTxMOdwgA
GgHwAn0ObA5NLA8SEA5tDowOPSwLjFADCwASCgoALy08CgAFAD0AES0cAWEVfQ5MDj0cASGNThoB
L-0BGQFOEBsZATAZHxoZARAZWAgg7xlYCEAfGR8qEAAAWwhRHxkvKs8MAKBgDi8ZHyrfGR8YUghA
jxkufRYAAjMCUC8YDm0cUQgAxgASXTMCABYCATMCVX0eTB5NDQECFwFvXQ6sDh08CgAFMW0OLHNS
ER0bAWMabT4MPi03AjAMDk0dATadLj0eAS8LDB8BQxAgHwEwHh8fHwFwHg8cwA7vHlIIgB8eHyq-
Hg8dVQhRHx4vKs8MAKBgDi8eHypPHg59dlNQUA6dDo0XAAAgAVGtDo0fHUsIUQ4PHQ59YwgAUwNk
DA59LA8cCgABOQJTnQ4sDm1fAxUsQQMGXwMICgARPR4BFx85AkcOLA49HgEfCx4BShAlHgEwIx8k
HgFwIw8hwA7vI04IgB8jHyq-Iw8iUQhRHyMvKs8MAKBgDi8jHyrfIx8iTQgw-yMEFQAAHAFAjyM_
fRUAADsCQS8iDn1iCABWAyAsDlYIERAMAhSdVgNELA49HlgDESwSUgRSAz88LhxeAwgfJF4DAA8i
AU8QKiIBMCgfKSIBcCgPJsAO7yhTCCAfKGEIAFQIYB0uLS8PbQwAoGAOLR4tTw9dHydRCCJ9TxYA
ACEBkE0qDU8PDS8ULRsAwTAOPUoNLw8NTxQdHyAANBAOTREA0i8nDyYQDk1aDQ8PDV8PAAA1AWRd
Si1PFC0OADT9BT8YAGRPIy1PGR0PAKVNXyMNDx4NXxkNEgCRTyMNLx4NTxlPEQBEEA8pPRIAACMA
EB8SAINNLyMNTx4NLyQAYTCNTx4tTx0AgTAPJn1PHh1fGAChUA8mDydtLx4NbxwAcGAPJh8nXYwL
AHCADybsCx81cAFgGcAJG2wbwgkQa8IJD3ABDQ-VFisBoQEJkhDwA_oJoAsaHMoJgAsaLMoZYAsq
HDsIEws7CPALC-oFGQgwC8ooShkIDhAL2ggKCEopCBAL_gAIAFIOAAt6iAgAMPoFOQcAMVqoOggA
MvoACAkAADIAICpJPACgyigqOQgeEAv6AooQABgIER4YCBEOGAgRHhgIEB4YCA94EAEPFgEMHjfl
AAx3EIHtDKAOHR8RvXUQUB0vEc0MDghBLR8R3WYQMf0EDPEJU60LjRwLBwCDChAOvQuNLAsHAHMK
AA69Cw0LpwR8Cw0LDQtdPAwAQW0bDQsCABMblgMhCx0QACEdC9UFgA5dOw0LDTsdkwMDNAoP8AY8
DwsBAQtfEAILASEWvV0QIR0vVBAACwEhFt1TEA8LAQQhjWvWBkONC00L-whDCw0rDQwAg20rDQst
Ky08GAATS64FIgutCAAhO239ADGtC235AD_tC136AFQLQBAQ7ecHQh0fG73lB0IdLxvN4wdCLR8b
3eEHJP0E3wdB-QUfGC0QcTwNPE0fGAygBbAMHQwNDB0MTS8YDA4AAatcQAxNKww6BDB9DG0LAACC
BVA8DTw9OwoAX60MDQxtCgAAUV1LDAoQWwAxLTsMDAIgSwwSASBLDJ4F8BFbDApQDAutawwaYAwb
XYsMGoAM6wwaoByrHBrAChxrHBMBH2wTASQILhAUHA0CUCC9Dx0MEQFAIM0PHQRVYB8g3R8dDA8B
IgsMDQEjGwwLATcbDAoJARQrCAEzDA0c-QBBDD0MfQoAMW2sLfEAIf0FBwAifYwUASH9BP0APY1M
TfsAHwz7AEoIBxAUIfsAQSW9DyL7AEElzQ8i_wBHJd0fIvsAMH08jfwAAPIAEY38AFCNDA0cjfgA
MY0MvegAIo1M8ABijQwtDA0s9AAzjQwNAgAEEAA0LQwtDAAhjB0CAS-9AwEBXAjrDxQmAQFBKr0P
JwEBQSrNDycBAUcq3R8nAQExrQ8PAgEwbS8KZQdCLxRNGw0DMQ8KDRIAQg8UDQkJAmQKLQ8PLQkQ
A0M6Dw85DADyAb0LfTsMCAAOfT8jDx4-GT0NAHYPIy0PHi0PDwAgDQeOB8APGQ0GLUsMCBAObScQ
ANEmLTsMGBAOrQVdSwwIKQERGCkBEggpARIYKQEQGCkBEBgpAf8AGMAIHGscKPAACGwo8ARoKQEN
D1MHYiH6BVIHQvoGKQgGAAA2BxgGTAcLBwARBEYHL-oDRQdGHzZFBzZC-QUcCwYAAOUCMgYsCwYA
JQoABwAvBTwHAAARBCUGL-0DHQdHHzYdBywP4wCkDwYHMQIIAAD3A2T9Bi8YDxcIAADdAwcKAC8F
PwoACSQET0QAEAMUABAfCgASAhQAQTD9AU8TAFAwDxjtXBIAMFAPF6EMLx81EQE-DwQHKSH9BQUG
Qv0GKwwGACUKAAcALwU7BwAAAu4GD_wFSh827QYrD_QApg-QBhgP5ACgD4sGI-IdafAEGTwLDAsZ
8AAZHGobGMAJHKoLCQigCQzqCQiACQz6AQkIYAkM_gMJCFAHAFAPNTAJDH4eZFoJCDAJDH8edEoJ
CA4QCQyAHjFKCQgOAACBHgAbABAADQAUrAsAAG8eEVoLABALhB4dahYAAoYeEVpUAAWHHmFaCQge
EAmIHgAyADAwCAuQAEAeMAgJCABADlAICa4AYB5gCAnqCZUeMBmqGdoGPxlqGdwGL8Bu8AQePxEP
EA8RDxBCAiAfEUYWsB8NwA4fEa8PDxAOpx4wDxHvIRZxgA4PEf8PAUEWAAoAEQM-FmMPEW8PLo1A
FmAPEX0OHA4OADAwDgzxFSF9Dg8UEAzREhB922MQDBwWIH0OCAYICwAAoxECCwB0DxB9DjwOjRcA
BAsAEAkVEiCdDjkGEglkAAA9BhMJZACACjALCY0ubQ7WEQCsYADYEQDdYABIBjAO7Q43BTAerR45
BTEebR47BR9uOwUqEBM3AQBibTEWDxU3ARAWYxZxHxLADh8Wr4NtgBKgDg8W7xQOQQcA3DogAQ5C
BwAKACADDkMHBAoAATYBYBZ-FE59Dl4WcQ8WbQ5MDm0ZAGEQDgxtDmwNAIAQDgxdDowOXU4BFQAM
ABkKCwAvDxUXAAISCUQAATkBAlwAATkBI31ONwEv-QM2AVYQGDYBcRsPGg8bDxo2ARAbgBawHxfA
Dh8brxkPGg6TB1APG_8ZDpIHYA8b-xkBDpIHAAoAIAMOkgdxDxt-GS59DisHQQ4PG31WAgCZBxMM
2wABNgEDTQIAQAFMHkwebRIBYQxNDqwOTQsAJg8aDAAHFwAjCV2EFhJdOAFUXT4MPl1xAjIMDo06
AT99Ln07AVYQHTsBcSAPHw8gDx87ARAgnBaAHxzADh8grx7KGYAcoA4PIO8eDpkWYA8g-x4BDpcW
QA8gjx6QA2EcUA4PII0KAAE7ASAgnZAWEBwKAALSACMPHKgDEQwZAAULAAJxAgBdFgKIAwcLAAJ_
Fg3BAxQJCwALcQICAgQPOQFdECI5AXElDyQPJQ8kOQEQJbcWsB8hwA4fJa8jDyQOtxZQDyXvIw60
FmAPJf8jAQ6yFgAKACADDrAWBAoAATgBYCV-Iz6NDrIWMQ8lbQoBIw8hqgNhLA6tDg8hqgMzLA69
OQERXbYWA3gCE123FgIPADEPJF25Fg_yA4kQJz4BcSoPKQ8qDyk_ARAq0xawHybADh8qrygPKQ7T
FlAPKu8oDtIWcA8qbygvD28NABFgDQASTw0AGFANAAFHATMqPyjaFkA9Dg8mEQATLcoWES0jAAAB
RATtFgAiAAEQAAPdFhE9IgBQAA4PKk3eFhVNDwAk-QcLACEpTeAWBhsAFD3hFgU9AAbQFhQ9cgAk
KS0TAACFABEfEwAUPeQWAiYAozAPJg8pbU8ebQ7nFhMODQAB5xYzDm0vGgDwA2APJg7tDgwfNYAM
Hq0eDBugHBNn-wAbwAscbhwr8AALbCvwBGsHCYch_gUECSK6LKoIYQzKDAoMavoII_oM1QgjaowJ
ACH6BwgAMwtKrBEABCMAEws2AADrCCO6LOUIL-oF4gihAgoAAuEIIJ8PBAAB4ggHDQABQQIAUAAg
Ea8PAAkNAAFwAgEPAFYPDw8RjxMAE48TAAoXAB8QFwADRRFfDx8XAAIEADYfEV82ACFfD25KBR8A
AAwAFV_bAEMQTw8-GwAwPxFPFwAB4AJBEP8PBSMAUjAPDQ8Q5wAA2AIkDQ7zABFQDAARARgAQWAP
DQ4oAQC7GVANHq8PHgsAMKAfDR4RoB8NHzXADR8NbhzIIB5syCAPWQliIJ8UBAADWwkFDQABEwFg
Fn8UbxZ-DwACDQBSDxZPFA8RAAFSAQETAFoPFC8WDxcAE18TAFUvFC8WXxcAEhUuABxPQQAY3yIA
NT8Wr38AFRWOABofDwAAjQEyEg8VxgAAjQEkEg7SABFQDAARARgAQWAPEg4HAQCNAVASHq8UHgsA
MKAfEsgRIR8SjQEeEo0BD7AJXQIKAAKvCTH-GQWtCcEPG18ZPxsPGT8bXxkdAGEQDg8bbxlzSyMb
DwgAEG8bAAQZADMPGR8EAAMZAAFSAQEbABxvEwACWgAGEwAjGp9WABafJgAOEwAMJgBJEA4PGqYA
AaYBEhrDAACjATIXDxrcAACjASQXDugAEVAMABEBGABBYA8XDh0BAKMBUBcerxkeCwAwoB8XiBIh
HxejAR4XowEPGApTM-8eAxcKAgoAAhcKM-8eBRcKEF9YAFMePyBfHhwKQQ8gbx46TCMgDwgAEG8b
AAQZAFMPHh8gDwgAEm80ABMAGwBWPx4PIJ8TAFVfHq8gXw8ARx--HgcuAD6PIG8bAJAQDg8ffx5P
IH8bAAGJARIfqQAAiQEyHA8fwgAAiQEkHA7OABFQDAARARgAQWAPHA4DAQCJAVAcHq8eHgsAMKAf
HAATIR8ciQEeHIkBD2gKaWNvIz8lnyNqCiFvI9dMAhEAAQ8BMCV-I-dMAFwAAXUKAhEAEt8gABEA
DwA4TyWfDwAxDyUvMwA1LyVfFwASJEYACgQAHl82AAAEAAk2ADWPJV_LAFAk-yMFDqApBgwAAJcB
MiEPJNAAAJcBJCEO3AARUAwAEQEYAEFgDyEOEQEAlwFQIR6vIx4LADCgHyGzEyEfIZcBHiGXAQ-B
Ckkz-ygBvgoz-ygDuwoCCgABlwFzKp8oDxCfKLQKoV8oKw0PEA0vFV0gAAClChBt6B6DDxANDxUN
DG25CmFtCy0PEC0PAAFAAWYqbTsPEDwPADStDq0MAIcpbT8kDx8-GiwAdg8kLQ8fLQ8TAEApbQ8k
chp0Hw0PGg0JbXsAMCldKhQAISldgQoAEQBBnQ8fnR4AAbYKIf0DGQAwMA8mOQwAbDEQCDoM-xYI
F2AIDu0OCBeACB6tHggXoBgebR4YF8AHGG4YJ-AAB2gn8ARnqgpPkDApoCmQGSsZYAQAYwkbKhsJ
QAYA9hELagsJIAkLeggwCQt6CwkACQuKCA81EAkLmgsJC5oJCAoAAHQKO6oLqgkAAaAKQRAJ_gaB
CgAHABMOeArxAR5ACBnqGQgeYBgZqhkYHpBwCqEukAkbqhkIoAkLIgsQC5kKp3AJC3oJegkIDmAJ
ADFqCQjhEyBwCBYiMQgZOroK-wQ5GB4AGDkIHqA4LiAOOB7APmA_-1YfcBOO8AQOfxDqdWANXw8d
Dw0JAJN-Dw8N8AIODY8IABB-iQkj8AEJACAPNXh1AS4KBQkANQ814AoAT9AODZ8KAAdFwA4NrwoA
Ep-iCR-AMgADEo8eAAQKAAhkAD7wAA4KAEIBDw0OqwD-EQIMDm8PDgwPNfACDB5fDw4M8AMcfgzw
Aw81jAvwBItA2SwfAC0KEW8nCpAdbxQdHsAOHcwfCiEN7IV4ANN6EnAHAADULFMN-AMOCwcAgwow
Dg38BQ4LBwAvCiAIABQSMD8AExoIAIIKUA78Ag4LGgcAUgpwCw7sgw8SrIMPHWyDDw-kLB_AGU8Y
8AYeTxoNAlAdbxkPF-MBEI9VCCPwAAkAAZgBEK8KAAQIAALSAQIKACCwHgoA8AIfF5AeLa8ZLR8X
YA4dLxkNjLMxGUAGAQBGBFMN-AcOCwcALwoACAAE8RoQDowODQwefA4LGiALHkwOCw0MDgsOTB4L
GkAbThsNDA4bThsaYApLChkAUgpLKpBKCgBCAErwAQoALPAHCABvSwrwCEqgHgEdQBsPHfAweLPw
Cw4N8AoODx8PHAcAMw3wCQgAEAgIAAD9BwYKAHEN8AYODx8vFQAFCgAQDbt-IR9PFQBBAw4PH4gI
YfABDg8fjwoAFAAKAGAN0A4PH68KAAUJAGANsA4PH88KAAUJAC8NoAoAFDCwDr8IABMdCAAwDdAM
lghgDB3gHG4cEoIP_wYjgDVfIvAFHk8kdAdi8AIeHyQvaQdl8AEOHyQ-DAA3DyRPDAAD1Qcv8AIY
AAgEDAAAGAAXbwwAIX8j4wgiDTAMABANn3ghDyRkNrMPJI8jDg1wDg8kDhAApJ8jDh0wHg8kDyMS
AHWvIx49HyQfEAAASQgCcg8BRwgmDR8LAADOAwALADMCDR8KABABFQBAcA7-I2OBMDWADUsIAJoO
EB1JCN8dHzXADB1uHSzwAAxt34EjsBlO8AcOTxAO8AUOthIQDysCIg1P4gQ10CkQDACFAC8TgAkr
CQARABEPa4WkYAkLKgkIAA4NLxYAAdJRYBUPE0AJCzsaAxkAQRMPFU_HLhEwFwBGDzUOHzEAAhoA
MA81IDkaNggAHhgAER8YAKAwGUoJCAwADw0cFgARPxYA8BEcQGkIDBAMAF8THxIccFgMMFcskFxA
XKBfIkBfGJAfIh8CsAwwDxhPGh8XYA8iGQIAmyuhDAAPHRAPGA8aP-AtEEAaABJPGgBwDx0PHw8d
AB0AEU8dAEkwDyIPHQAXHiEAAD8fJgwgIgAAIQAhLx4aLQYgAAFCABYvQgACIQBhAA8XDxgvIgBU
HEAPIS8eABRPHgAAbR9WHGAvIRwWAIcMAC8XHIAsABIAcBAs0C8dLx6CLf8BDPAEXx0PHBzwBUYc
8AdMoNQITpEvSYBJgAlLCWAEAGELDDoLCUAHABAIBwARWtcIQAxaCwgHAALaCCUMetAIIAyKAQIB
yQgnDJrKCAwIAANUEzIeIAlUExJAswghHmDBCFIegAkLygcAIQza0AgwDPoA8xNACwz6AvQTATUA
Jg5ACAAwigmKkhMF4AgxHmAIowIQCOQccB6ACEkIHgAFAK_gSB4gSB7ATkBO4AgmEA7XCFEfEU8P
DQoAG2wHAALnCDB8DQvyBlGMDgvwAAcAAXIIQ4wOCwoHAFDQDg0PEQkAUsAODQmcCAAZrAcAUZwO
CxrALQApGtA7AANCAABZABB8CABAAQ4NbAgAEQIIACPwAwcAEwsHAK9_CwrwA4sK8ASKrAgekDSP
E-ADDo8VDmQAABkSMA0O4AkAUJ8UDQ7ACQAwvxQNsn4AMBIQDVR_AMYSIAAN2hIBCwBSAg0PEkAL
ABEEzRJBDf8UBRMSHyALADkBWAACdxI1QA4NahIkDg1pEjIODc8KAEKgDg2vCgBSwA8SDY8LAFDg
DxKODDMGf4wb8AOL8BZyEiFBBQ5vGgECACUSEg3vCAD2GzANDxcyAS8bn_gIBQYKACCgLgoAEC8b
OzDPGS2REhANfBIhAg3yCAALAFIEDQ8XIAsAEQZmEkEN-xkHPAAfAAsAGFIQDg1-GQoJANgRUyAP
Fw1cDQmBXA4LHzVAC14OCVNeCxpgWw0JQlsagFoKAE8AWvAADQlEAAIJUA7wCg4NDQAgCA76GBAO
CAARDBEAYAYODQ8gHHqKQQ4NCxwTAHQEDg0LPA0OCAABAgNEC1wNDggAASMDRAt8DQ4IAAB2A1IL
nA0PHAgAkwkKsA4NC7wOCQcAXwqgDg3MBwAFELCZAxIJkgP-Bgka4AkNbA4JGvABCW4JGvADaRrw
BakaH6A0fyLwBA5vJA8hugkxJA8l4QgPDAAkAfkIAesIA-UQJPAC6wgSsN8IVm8jDg2g3QgADwAX
kN0IE3-tCDcPJQ7-CBFQEgAnDyMDCRBdEgAXHwMJIF8kbBEEEAAOAwkUQO4IAJUDQA8k7yMKAABn
CRHPCgARoEUAAAoAIsANdQD-AR814A2ODRzwAY0c8AOM8Bb5CClfDxEvDx37CCA8Dwwa-QgBOmIC
-wg5Dww6AQkA_0wPAwl5NA8bLwUJAh0CDwcJNAFCFQ8JCdQC3REwLBlgBABgCRwqHAlABgCACEAJ
DGsMCSAGAABvHEB6DAkABgAB3xEwDJsMBAAAdBwgmgwEAADzCEIMqwyrCQAyqgyqCQAw_wcMBQlA
DPoFDOARQAz7BQzhEUAM_gMM4REwHOsc4REwHKoc4REwHGsc4REwHKocAx0i6wwDHZAMCHAJDHsM
ewzYEUIMegx6CQAwawwIBADADnAJDDocCA4IHDoMAQkQPOIRHzziETIREeIRAOeGER-rhgPqEQIP
AAATAAMECQQPACMfDxEAFQ8RAAIkABsBJAABghEHEwACJgAaADkAEg8qAB-gFgACGNCHAANBAA8W
AAgeH0IAHMAsAAcYAAdwAAGwAB8fFgACD3AACAYSAANAAAAUAA-cABUKHAEPEwAGPAEPDXoBFwxP
ABINyhImHQ9dAADSEi99DNISLiAWHtISACIFASYFAtoSAg0ABxUAAC8KUgwPFRwLAgAgDA0RHUUN
DAscAgAwDQpw4gcWCyMAEQoJEwcTAAAlAFlQDg0cCyYAKgkwEwAAJgAaMFwAAigAGyBNABIcFAAM
PAAvCSA9ACkbMCgAOw0KGaAAAE4ACtgASgwNChnYADkNCgkOAWQNChmACh0vAFIdChmgGg4AER1O
Qh9tTkIpA7QTERu0E0IPGg8ZBAATHc4KBREABAQAEg3NEw8ZAAIC7wIHFAAGBAA-DQ8XHAAJAmsD
Dx4ABzawHg0SAAkeAAEtFAYQAAgEAAJBFAOeAFEMDxkMCwIAUQ0MCwwdXwsvDAsCAAADPwIPGgAC
AUgLLwsMAgACLw0KHAAJLwkAHQBDFhCsADYdCx2qAEMZIAodCwBCDQsNCiUA8QMdChlAGk0aDQsN
Gk0aGWAJSgkdAFIJSimQSQoAQgBJ8AEKACXwBwgAEC0GAF9KCfAISfQULjMgDxwHAAH0FBMg9BQC
jR0XHAsAEA3sFDMgHx8ZAAANABMvGQAQBCUAQB8fHh9JHgH-FBAgDQAyHx4PEQARAUkoIg8gBxUA
5B0THyAAEiAQFRQgEQAEXwAAFAASrx8AFbBdAAUjABEgKRUHSAAFTAAArh4WzwsADjgALw2gOQAO
AFsABx4AAcMALx2wpQAAMQ3QDjEfACAAT_AcbyBwFS8UJXAVAEsdICQPUx0CRRUCEQAWHxEAFA8R
ABgkEwAlJB8mAABIAA8mAB8EFQAJKAAYJBUAGiMXAAKzFSYlHxcAEiW8FRIlhwwHRgABHAAxcA4c
GQAYDEkAYB8jDB0wHhsDARsA0xsPJBsKGwobHD0cCwoUACMKGwIAhzwLChsMDQkwEwAAAgCWDA0Z
MA4MCwobAgBKDA0JUBMAiAwNGVAODBsKIwA5cA4MIQA0gA0cMwBiHA0ZoB0cCwBwHRnACR1sHdcF
H23XBSQADQ0E7QcAEw0CDAABEAABQwMHDwACHQ0GLggJIw0KFwAAi5sRD5ebbGAJSggADhoABCsN
JmsIGwAFGQAgHxQrDRJqKQ0jDxA2AAQbABIVLg0hewh0AAwcABEUNA2oCWoIDQAPDR0PExkAlx1A
GUsIDRANAGsAxRIdcFgNMFwtkF1AXUANBXcCUiENMA8YGQYABABDHxhgDx0AASEAJSENUg0XGQQA
EBhdFhUjKABjIQ0PHQ8eOQ0pDxkEAAJkDQdRAADeDBMfLQAGJwABKwAQDW4NFSMuADMhDx31Ax8d
LAAAAFgACFYAHU_BAGQXHUAPIQ-oACQPHX8EAp4NAiYAYhcdYC8hHZQAAB4A0A8cDQAvFx2ALQAP
HW8OADgQLdA6ADUN8ASWAJ8cHfAFRx3wB02MDU-wODcp8AgZHyoMGPAEGR4MDgocGPAAGR4sDioc
GLAZHkwOShwYcBkebA5qHBhACR6MDoocCCAIHpwOmhsIEAgMCh5sHgxqGwkLnBbxJAgMKh4sHgoL
ChwqGykLCA0QCAw6LhoLGhscCzkLCB0QCAxKDBoLGisKDEkLCA0gCAxaDA4AUVkLCA0wHQAgKxob
ABEdDQAxCisqKAAQQCgAIRsqJgAQUBkAIQs6JQAADAAQbCEAYGAIDDoLaWMA-xsNcAgMGguJCxkL
CB1wCAwKC6kLCQsIDYAIDAvJGwgNkAjrCB2g6B3A7fCkmB6AOA7wCw4PKg9TByAfKlkDI-AICQAB
QxOBDyoPEQ8qDw8aAAoPAAFQE2YPKh8RDyobBAcPAAKyBWIqLxEPKi8gAAoPAAGODHIPKj8RDyo-
IAATACAAAMApBCQAE9AjAAAUAAInABbQJgAYECoAFLAqACUQHywAFLAsAFYQHw8fECwAE5AsAEQf
Dy8QLAATkCwAABQAFx9YABNwLAATfygAEXDmAGMfKo4fEB8jABFQGQFhHyrOHxAPEwCDUA4fKv4B
HxBaKjD-EAO9DZ9g-w0DHzWA-QNWnx-hVC8T8AgeHyoPFh8S8AQJAFAPKg8UHw8AAO4jUS8WDyov
DwAQsKFHQRYPKk8OAJFwHh8qbxYPKm8OAPAEQA4fKo8WDyqPFB8WDxIgDQ8qn3ChATEqkQ0QDQwP
KmwbDxoFUBxqDA8VEwBQCgs8GxoiNkA6DA4J3QXyDw0MGgsMGyoJKikKHAoMHgkNCAANDCoLOgkq
KToMLg8AtBoMChwKCSopKhwOIgCxCgw6HBopGhw_DA4RAIIcahwZChxuDB4A8CaaLJ4MDQgQDRmK
DI4ZDRggHRlqDG4ZHRhACB0ZSgxOGR0ocAgdGSoMLhkdKLAIHRkKDA4ZHfM97x0pHSjwBAgtKPAI
KPA2VgEdkU3-GAGgDv8qAdgpoSr-GwEPKg8XYA0iKTAq7xu3c8AbDVANDB8ZDyrMCx7jB5NADQwv
GQusCy4NAEU-Gas_CwB0C0oPGhoJDBEAYDoLOgkaGQ8AEQgOAEYqCRopDgBWGgkaKQoPAFYKCRop
Gg8ARgkaKSoOADYaKToNADYKKUoNACYpWgwAE5wKAFIqCa4JLgsAUhoJzgkeCwD-EAoJ7gkODA0I
UA0M-gEJDRhgDfkBDRiA-QEYoPgB8C89AR3wCW0-HW8c8AEPHS8qfyAPHOAPHQ8qHyAPKooKEh86
KUAfDxzAFwBALyAPKioUAqUKES8ZABqgGQAVLxkAEIAZABA-GQACFwACWSlKHw8cYBkAFS8ZABBA
GQART3sAIC8fhSkRTxcAkSAPHX8qnyBvH70pMh9fHtwLQV8dDx97mQE0FAETABBPEwAzHzUgEwAW
bxMAU0AODx8-EwASPxMAE2ATABZPEwARgFwhAhMAEi8TABOgEwAWLxMAIsAOGQEAEwASHxMAE_AT
ABYPEwAh8AG_IQIUABMPFAAWAxQAARAAIQUO7gsBDAAiBw4IAI8JDh3wCw3wGsgBHTIaLyL9BTAl
DyFNAAAJABIqYAsAaABiKh8lDyofDwAQAyMFQiUPKi8PABABGgVBJQ8qPw8AkeAODypPJQ8qTw4A
EMA4KFIlDypfI30LAg4AAFcAAhIAc4ANDyUfKj9NAGA-Iy8kDXATABEjiQAAFQAAhQgA_ykRJHcD
IGANJgAAGQBkDBsMDyU_FABzOwobDBscChAAgAo7CgsMGxwLEAARCQ8ARgwbHBsOADQbHCsNAKIb
HA4KHCsKDhweEADxAhw_CisKPiwNCXANDF4KCwpeYwshDF4JANCgDQxODE4MDRnADQw_cAPRGeAN
DC4MLgwNGfABDdGiQQ0Z8AO-oQAKAN8FDSwNGfAHLRnwCSmwkQEdMDLPJkwBIb8pAKcCvikB3gYA
3ymdjygPKQ8nDykOEQARD9YGIC8phDQwDykvEwANEQACzgZwTykPKl8pTxEAAA8AID8pqDRyDykf
KA8pPyYAE1AmABEvFwASHywAE1AsAAIVABQ-LAATMCwAER8XAFIvKQ8oDzAAMDAOX6IAAxcAMC8o
Xy4AcyAODylPKB8TAAMqAAFFACMpPyoAFD_IAAEMIyApT2sABioAEVAqADYvKU8mABFQJgA1bylP
4wABWwAjbyf2AB4fEwABLQEBnAAjjydAAR4fEwABdwEiKa8eADCwDs8SAH-Qzh3gzfAUwQpTMAsM
CsEKMCsMKr8K8QxLDEoYsBlrDGoYcBmLDIoYQAmrDKoIIAgcmwy3CoEaHGscC2obGbUK9A86HCsc
KhsqGzkIDhAISixqK0kIHhAIWguKC1kIDiAJAJQwCFoLagtZCB4JACQOQAkAUFAIWgtKGwDxHVAI
WmtZCA5gCEoLaQtJCA5wCCoLiQspCB5wCBoLqQsZCA6ACAoLyQsJCA6QSlxP6B7A7osKJRERiwoB
xzQRD40KBAsAAY8KIR8Q8TMXDQsAAYcKEi-cCRcNCwABfwoSP94JFw0LAAF3CmFPEA8RTw9zChI-
YAASEBwAM9AOTxAAAB8AEdAeABUvHgAzsA5PEAAAHgARsB4AFU8eABSQVwABHgARkB4AFW8eABFw
HgARfxwAknAOLxAfEY4fEKkAcVAOHxAfEc5QCgA7ChQROwpQQA8N-gUhAI-9BRxg-AXwLTcKIwBu
HCEPFDkKIC8V0TMBNQogTxUKNAAxCjBvFQ9-NJAScB6PFQ8WjxQpCjCvFQ_JNAAlCmAWnxUfFg_5
MwASCnAPFA8WbxUfRgAgFW_qNFANEA0fFGx4AsQ0ED9cqwEpChAvKjQQFdA0AY6rIRUuFgAgPxTX
NDQPFT4kABAVt6sAJAAiDgwiAJIfFAw7HGscPgxHAPAACwxrHCscbgwODQoADQybKgrwFwoQDasM
rg0aIB2LDI4dGkAKHWsMbh0qcAodSwxOHSqwCh0rDC4djirvHQsMDh0q8AQKLSrwCCoiCibQGgEO
gA8XDxv-GgEPGyIKALoz8QLvGg8bHg1QDS8ZDxvPGg8bLvUJkT8ZDxuvGg8bPg4AU08ZrxtOCgBv
DxuPGQ8aDgBnNZ8aTqIAMq4PGqEAUS8ZDxrOeQFhQA0fGQzudQEBIgr-AAwNG2AN-gENG4D9ARug
_yIKITEvHX8iCgDSFBJPAAoAKAoTLw8AEC9wVAIPABNvDwBDoA8dPw8AIT8eDAoTTw8AIU8eAgoA
DwATjw8AQ0APHV8PACJfHvAJQCD-HwHvCQAyAAAYACFvHesJE18PACFfHecJAA8AFG8PADNADk8P
ACFPHd8JEk9fAAIPADOADj8PACE-HdcJEj_qAAIPADPADi8PACEvHc8JAAsAFA8PAAAPFQMQACIf
HccJFR8MACIFDjwfD8MJNwHoFBEjxQkRH3EhAcEJES9sIQG9CRE-AiIBuQkST_QfUSHgDl8kkwkg
IcBYIiElb99UEm9KADEkbyOpCUIjHyU-RgDTJD8jHyQODXANLyMfJSggECSkCREufwkhTyNCACQk
Tg4AHyQOACEQL2QAYgxPIwwOHFcAkA8jHD4MKww_HCciwHANbgwLDG4NGoANbgcA8BmgDV4MXg0a
wA1ODE4NGuANPgw_DRrwAQ0uDC4NGvADDR4MHg0a8AUNWIGPGvAHLRrwCSqTCSUBjAkJlQkTH4IJ
OR8nDg0AAA4GEz96CTk-Jw4NAAAMBhFfgwljXycOcA5PGgAhTyfeCBNfDwBBXycOUBwAFI8cADMw
Dl8PACNfJ10JFJ9VCRBftwgCGgAAKQATTw8AIU8nRQkAHgAUbx4AEVAeABRvHgBSUA5fKG8aADNw
Dj8kCRA-GgAJDwAA0QATHxwJEB8eAAkPAAspCQMLAA8tCVfwFDUaOfAEKhw7GfAAGkxbGbAafGsZ
gAqciwlgCqybCFAJO2x7FgnAQAlrPGs5CEAJixwrslSgMAmrakkIMAmrejxlAgcAwDAJm3opCB4w
CYuKKSoqAQcAYFAIOSuaGQsJEGkPABJgBwBQcAhpehkHCTR5Win8CMAI2QgOwAi5CB7QCHmsSF94
PvACfoQXH9A2Pw-wCA4-ER7wBQ5tKCjxGo0O8AEPDi8QTS4PDvAADC8QfgwPNdAMPxB_HNAMO44M
DzWwDEuODA8NBwCSCg81kAxbngwKBgByCXAMW64cCgYA8BIJUAxrriwKUAxbzhwKCTAKPBveLAow
ClzeLAoJIAp8rjwHADCMjkwHACT8BwYA-wUwGvwDGhlACSrMKilwGco5wMnwFNUAHTByTxQwHlAW
HxPwAv8f8BwPE_AebxZODxOwHR8VbxZeDYAdPxVfFn4NYA1vFS8Wrg1ADZ8Vzg0wDZzOXBmwDZyu
LQ8SEA2snj11QqgNrI5NCwoADZyeBwDAjB1_TQsaEA08bV5NPkL-GK0uXQsaUBv9ABsacAobvRsq
oAobfRsq4AobLSsq8AMKKzrwByrwN8sAHYBSjxnwAh5-GwEYYOAOjxs-GmxN8AaPG18aDxigDp8b
bxoPGIAOnxsuTxqzZFCfG04-Go0ecGAOjxtuHxpLJRBQexdQbxuODxraJADtCXQYLxovG64-DgAm
XxoMAD9PGr4MAAI-PxrODAACYS8aDxjOPQ0AYg0fGh2_TQsAUA8aPZ5dCwD-F1APF01efQwfNVAM
-QMMC3AM-QEMG4AM7QwboCytDBvAG6wb8AC74wEf8Bdsjx7wAh6PIB4-HZAdzyA-Hx1gDTyfIGwN
QB1Max58DTANbDt_PKw-wA183i0PHBANbO4tCs4B8ANc7j0KCQANPD2_TQoJEAp9rj2JHv81fY49
ChlACm2OPQoJYAptbj0KGXAKXV49ChmQCl0uTQoZoArNChnACq0KGeAKjQoZ8AEKbQoZ8AMaLRoZ
8AUJKinwCCn2CR8wGT8jfgMRJX4DYB7wAg8inXUD8iUfJH0bDNAMS007DMAMWz1LDKAMax4dSwwP
NYAMa05bDIAMW25LDApwDyEsK347DApwCUyOBwApnisHADAMGwkIACCOPAcAMVxuTAcAIV5cBwD-
Jk5cCRqACVw_XAkKkAlsHmwJCqAJ3AkasAm8CRrQCZwJGvAACXwJGvACGTwZGvAECjkq8Ac6XR8e
MFB-JpolECpxQvEQrQ8pHsAOvSwOoA7NPA6ADiydXA5gDkyNbA5QDlxtfFEGUnxdXB8nCgBAXyhM
P4AGMVy-KJcGZCAOHycszwwAUj8nzyhfCwA0Tye-CwA0XyevCwAwbyePCwAAlwZQfydfKG8WAFFA
Dv8nBIwGMf8nAnoGMf8nAGQGId8nUQbfryceHzXQrivwAKvwM3sPT7Ao8AgYLBjwBBgcKTga8hgY
HBkqGRwYsBgcGWsZHBhwGBwZqhkcGDAYHBnrGRwYEAgMGfoDGQwsGkAJ_wUJsydBCAwJ_goAEBAU
ACADCbcnABQAAAoAJA4gFAAAwycAFUQQDIIPMAwJ_woAJA5AFABgDlAIDAnrHQAACQAQ6hIAE2AS
AGAOcAgMCcobAAAJABDLEgBQgAgM6QyIBp-sCB6Q_AEOsP60CyCwOA3wCw0PEQ3wCg1uCaHwCA0O
Dw4ODfAIQQkAhQ8QDbKuMQwODQoAEgsVACAEDQ0fEBAWAAELABIKFwAiAg3XHgAYAAcMADMJ8AAN
ABAbGgAIDQA0CdANMB85DA4NDQAlCbAOABAKdwALDwAhCZB5AAYRAAwQACcJcBEAAYgADREAkAlQ
DQ78Aw4NUHcPfwlQ-QUZYPl2DyLwBRLwCB4vFh7wBB4dLxMdHvAAHh0cXB4gHB3PsiMcL2seIRwd
0LIFeh4GFwATMDEAHh8bABAQ8CVFHxQLGgIAMRwNDswjGBoCAAEFLyAADq8ZCAIAMAwNDhYkRwwK
CxoCABQKFwANRAAfCUMAMxkcLQAQHBUAJx4dFQBnChwdHgkgEwBkHB0eKTAJEQAADgAScA4AACoA
gCmwCR4dLB0e5SCPHi0eKfAECS7qBSOQTP8XA4AO-xsDy7BA-xgDDQSxEwwPHw8EAAgBXgEfQCsA
--_hMPwDDR4_r-0DDhtg-gMbgPuMHiCAba8c8AEOryDbNSGvHdk1IwwfDiJRHx8PHgzjNRAM7xEG
FwARDO81IAzvHgAdYB4AAyIAAMwABA8ABgQAEA8bAABbKzP-HgUKAAZvAAl3AADcESQNDHwiBgQA
ARsAFEB-AADkEQwmAAEiAAChAAt3AADyETINDI8gAAHpAAgcABXgyQAiDA3wETINDC8sACHwAxwA
AgwAEQWUNEAb8AcOBgBvCQ4b8AsLdAwfkBovIfAJDi8lDkgAMS8iDa4yEAzPIxIMTDgFqyYhDA2B
N0IMCx8jsAUV4MUFEgywASUKCw8AGKC0BQOnARgaEQAZcNUFAUoCGWD-BQH7BRxgNwAsCWA4AB8J
NwA3GHATAFcMDQ4ZgBEAABAAFaAQAAAwABUZ9AAADQAT4A0AAAwAASgBEgolAABEARAsCACPBQ4t
DhnwBy6-GycgzyoJuDGvJw0bETANDydYGg8EAAAhJw0euAUQAAkEAAFrAR_QHwAGAyMAASEABxMA
CgQAAUQAH3AjAAoDJwAfcGkACgWQAB9QJwAOAysAH1B1AA4FoAAfMCsAEgMvAB8wgQASBbAAHiBc
AA_LAC8B1wMfMAoBFQ81AREBUgAOMwEPzwEgAUoADs0BD1kCGAFCAA5XAgmEAADeON8NDhuwDs0O
C9DOG_DLEx1VgCsZ8AQZGyob61HwCBtqGxmwGRuqGxlwGRvqGxkwGRv6AxsZLD4iBwtXPmNqGUoZ
aguVWgLrWiFaC08_EzrrWkE6CwgeDwAA7FogOgsJFEELOgmsCwAQMAsAEIwLABEeqTdBbAlKCz8_
AxYAAEE_ESrsWlAqCwgeUBgAAuxaABwAcGAJC0oZKhkyAHJwCQvqCwgeBwAiDoAHAD_QCeupDSkB
Lx0hEA8cLwEuHAItHQJLJwYLAAE4HTIPEC8YAAYLAAE4HQGrHAO7JygQLrgnhRAPDw4fEQ4fuich
EB8RABcPvCdUEC8PDi8TACLwACQAFj8kABLQIwAUP0cAEtAiABRPEAAARgIEIgAFsCcJEAAApgIA
QR0AZwAUX6YnIRBPigATXyIAV3AODxBvEgAAEABCfw8uXR4AcFAODxD9AwxYHSD8BSFHX-sFGmD6
Sx0mIi8V1Q0SFNUNEWzQDRGsxw0R7LYNMWxObKMNcHwOTxYOfA11UaENbA5vFg5sDQ8SkQ1vXA6P
Fg5cDgAtClQABW4AUQ81AB8ShQDwEhsPNSAbHewdGyowChsdrB0bKnAKGx1sHRsqsAobHSwdGx8d
MBstGx0dHysdHSMwTP8YPQ0SGj0NMBkDDQtRAwkAAW4KBwsARH8ZLnwMAGRsDi8bDmwOAG9cDk8b
DlwOAAMQTF40FEwOADA8Do-DwgMOAG8sDq8bDiwOABEQPHAANgsOKzwARUw_Cz5XAFV8DgsOfA0A
BqcAL-wDCgAGAEILAAw-MGD-F9IpH-pGCyIQHUYLER9GCxEelgkxXA5cjwkxbA5shwkxfA58LQth
fA4PIA58HwtRjA4LDowEC5CMDisOjA0PHCAgAFErDnwNCv4KgFwOSw5cDQoZ5QBxDksOTA0KGfG-
MEsOPAs2ABsBUEsOLA0KIQkxLA4rCwBQwA4NLC4JABDgkEIRChQJADkAAhAJIgoZwAogChl4Cr8K
GfAJChnwCwnwN6YcIyIvJMAKEiPAChZMDkMA-0IBqwoRrA4BEcwMAUJMPlwNfcAgLyU0AhEhusAg
LyWyAREhiQoQLA4AGYwOADk8HiwQAEcsDgsOEgA4Oy4bDwAWiw0AVDwOaw48DQACQAEhDyFxByBM
TgsAASQMEcwJABCgqAAhDyEWDBGMCQABPgEiDyEIDAIuAAJCAQEKADEFDi0IACAHLwYALwkqWAoq
EyiDByHPKEAKQ0wvD0zTB4FMDw8vEQ8PTBgKUUwLLxELGgBwcA4NHC8KDBAAQwwvFBzuCYIKLwwP
CgwrDP5VAdgHAE44AhgAEkwWAD8cDQ4UAAEBKglxPC8KbC8UPJQJI-wFbglzPC8jbC8ZPCMA8wAc
DyMvJQ8jTA8ZLxsPGRw4CQ0WAAF5ABIMFgAAQw0CGQAEFQnjHC8jDA8eLyAPHgwvGRzQABJMEgAT
TO8IBg8AAggBMy8eTMcIQswNDgqvCBAarwhvCtDOGuDKrwhQcJN48AUIWghpB0UIWggOBgCAGggq
CA5g_AEGADoI_gMGACAw_BQWK-oGBgBy_AQqCA5A7jwABUoABwYAf3gO8AV_8GakAB1AU03wCH9c
Tw818AcIABhATfAEDQ2SANDNAQkAMgzgTQcAAQ4ADwkACyGQXQkAQV1QDT4RAGouDT4NDEANACEu
HQ0AIB0uDQBffg0uDX4JAAKP-QcMUPwH8Cy6Oh9gEvAIDi8UXzgbBwgAkQB_LxRuoA79AEkCRP0A
DgwGADEtni0HADgOfQ4JACFQTgkAEE4EzXAtHi0ObQ4M0nU8LQ49CwCQTi0OLV4tTgwgIF9BvQ5M
UAcAJQyQBwBw3gyQDp0ObAUAMgzwAAYAcH4tDgzwAVxqACLwBwYAb04M8AhMoOwUIcGQDn8ZDn0O
kA59Dn1axQAIACEMgLgAIS0eY8UArQAtPQ4LABGuBwADLwAJBwAQXtYAoQyQPA4tDi0OXNAHAD8M
8AMIAAsR0DYAH5BRAAJP-gMMkHvQITCG-xzhABoe2wAP4gADAAQACAsA2GAuLV4tflAO-QUODEAG
ADH_BwwwEyccUCPGsGD_BQxwDA7tDiyAAF8RoAUAj-4BDLD8AfBMtwAdIEufnSMAWE4AegsMCABC
LyMeLQoAAagACAgAd67QDs0ODMAFADEtbi0HAAAizyN_YCrPMF0ODGkCAMbGBQ0AGk0LABEdyAIA
PwARPgkAK-0EBgCP-gYMYPwG8Eniqh9xJuCeLyieUCsDAJgBE0AKABcMCQABnAECngEVQJMBDw0A
AEteLV4tnwECBgA6ni2eEQADBgAFMgAKSAAJDQAIfAAFkgANCQAAYgCPUHxOnOBM8Bg6Bh4PMQD-
klBtPTZ9fQ==
:: gfx/1.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA5LTEzIDEzOjUxOjM5Iixtb2RpZmllZD0iMjAyNC0w
OS0xMyAxMzo1MzoxOCIscmV2aXNpb249OV1dbHo0AG0AAAAFMQAA8xR7WzBdPXtibXA9cHh1AEMg
EBAE8PAsZmxhZ3M9MCxwYW5feAgAz3k9MCx6b29tPTh9LDEA----------------------------
------------------------------------51BtPTh9fQ==
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNC0w
OS0xNiAxMTowMDo1MSIsc3RvcmVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Il1d
:: map/
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNC0w
OS0wMSAwNzozNDozNSIscmV2aXNpb249MzA3NV1dbHo0AMEAAABZEAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD-------_x0zIwMDAzMDAwNDAwMDYMAC81MIAAWxMxCAATNYAALzYw
AQBbFzb8ABMxDAAPAQBVBHwBAAABEzAMAA_AAVkTMXQAEzB4ABcxjAAPAAFVEzaEAAQMAC81MAEA
--------nvEJIiksaGlkZGVuPWZhbHNlLHBhbl94PTQ3CQDSeT0wLHRpbGVfaD0yOQoAEHcKAIB6
b29tPTF9fQ==
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNC0w
OS0xNiAxMTowMDo1MSIsc3RvcmVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Il1d
:: pal/
:: pal/0.pal
b64$LS1bW3BvZCxiZ19jb2xvcj0wLGJsYWNrZXN0X2NvbG9yPTAsY3JlYXRlZD0iMjAyNC0wOC0y
MyAxODo1OTowOSIsaGlkZGVuPXtbMF09dHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1
ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUs
dHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRy
dWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVl
LHRydWUsdHJ1ZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRy
dWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVl
LHRydWV9LGhpZGRlbl90b2dnbGVzPXtbMF09dHJ1ZSx0cnVlLHRydWUsdHJ1ZX0saWNvbj11c2Vy
ZGF0YSgidTgiLDE2LDE2LCIwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAwMDAwMDAwMDEwNzA3
MDcwNzA3MDcwNzA3MDYwMTAwMDAwMDAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNjA2MDEwMDAwMDAw
MDAxMDcwNzA3MDcwNzA3MDcwNzA2MDYwNjAxMDAwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDYwNjA2
MDYwMTAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzAxMDAwMDAxMDcwNzA3MDcwNzA3MDcw
NzA3MDcwNzA3MDEwMDAwMDEwNzA3MDYwNjAxMDEwZDBkMDEwMTA3MDcwMTAwMDAwMTA3MDcwNjA2
MDEwMTBkMGQwMTAxMDcwNzAxMDAwMDAxMDcwNzAxMDEwNzA3MDYwNjBkMGQwNzA3MDEwMDAwMDEw
NzA3MDEwMTA3MDcwNjA2MGQwZDA3MDcwMTAwMDAwMTA3MDcwZDBkMDEwMTBkMGQwNjA2MDcwNzAx
MDAwMDAxMDcwNzBkMGQwMTAxMGQwZDA2MDYwNzA3MDEwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDcw
NzA3MDcwMTAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzAxMDAwMDAxMDEwMTAxMDEwMTAx
MDEwMTAxMDEwMTAxMDEwMCIpLGxvY2tlZD17WzBdPWZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlfSxtb2RpZmllZD0iMjAyNC0wOS0xNiAxMTowMDo1MSIsb2twYWxfdmVy
c2lvbj0iMS4wLjMiLHJldmlzaW9uPTUzNTQsdGVzdF9jdWJlX2NvbG9ycz17WzBdPXsxNSwzMSw0
fSx7MzEsNCwyMH0sezQsMjAsMjF9LHsxMCw5LDI1fSx7OSwyNSwyNH0sezgsMjQsMn0sezI2LDEx
LDI3fSx7MTEsMjcsM30sezI3LDMsMTl9LHsyOCwxNywxOX0sezI4LDEyLDE2fSx7MTIsMTYsMX0s
ezYsMjksMTN9LHsyOSwxMywxOH0sezEzLDE4LDF9LHs3LDIzLDE0fSx7MjMsMTQsMTN9LHsxNCwz
MCwxOH0sezcsNiwyMn0sezYsMjIsNX0sezIyLDUsMjF9LHsxLDEsMX0sezEsMSwxfSx7MSwxLDF9
fSx3aGl0ZXN0X2NvbG9yPTddXWx6NADrAQAAFQIAAP0FdXNlcmRhdGEoImkzMiIsNjQsIjABAPAN
NGMzNjVhMDA4MjNmMzgwMDk4NDczZjAwOWY1MQgAkTY0NDg3NzAwZgEA8DgwMDc0MWY2NTAwYTgy
NTkyMDBlMjQ5YmEwMGVmODNjNTAwZjhiYmQ5MDA3NzJjMTYwMGEyMzIxOTAwZDU0ZjIxMDBmMzgy
NVAA8CRjYmM5YzAwNjc0OTEzMDA5YzcxMWEwMGQ2YTIyNTAwZWRjNDU0MDBmYmUxOTkwMDJkNTMY
APAWMzE2ZTMyMDA1MGEzMmMwMDg3ZDQ1NjAwYmZmMjk1MDAxNjU4NQgA8A03Nzk3ZDAwMjBiNGIz
MDA1Y2Q4ZDIwMGFjZjZm_ACwNzIyODYwMDVlMjYgANA4ZDNiZWQwMGFlODFmsACQOGM0ZmMwMDUz
AgBAMDBhNgIAQDAwY2UCAEAwMGU3AgAAqAAAAgBAMDAxZAIAQDAwMmICAEAwMDNkAgAGQAAgYjUC
AOAwMDRmNGIzZTAwNzM2YeAA8BM5ZThmNzQwMGFhOWQ4NTAwYmViNWE0MDA1ODU5NWQwMDY4AgBR
MDA2Zja5ABE3AQBQMDA4NjivAfEGMDNmMjcyYTAwNWIzNzM0MDA2NjQwYABQMDQ5NDQoACA1YxAB
gDQwMmM0ZCIp
:: pal/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTIzIDE4OjU0OjE5Iixtb2RpZmllZD0iMjAyNC0w
OS0xNiAxMTowMDo1MSJdXQ==
:: sfx/
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM1Iixtb2RpZmllZD0iMjAyNC0w
OS0xNiAxMTowMDo1MSIscmV2aXNpb249NTI1NV1dbHo0ABoBAABSCAAA8CdweHUAAygAAAQABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDBAUGBwAP-5AICQoLDwwPDQ8ODw8QAPAADQ8RDxIPEw8UDxUP
Fg8XEwDxAQ8YDxkPGg8bDxwPHQ8eDx8UAPEAIA8hDyIPIw8kDyUPJg8nFADxACgPKQ8qDysPLA8t
Dy4PLxQA8QAwDzEPMg8zDzQPNQ82DzcUAP8FOA85DzoPOw88Dz0PPg8-AA--8P8BAOv-J1oBEAYP
IBABIAEgAfAAAhACDBABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDDAAAh9EMAAc
H0AwAPIf-wEA3L-4D0AADUD--7DwcAoA--9kH-8BAP_ZUP----8g
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNC0w
OS0xNiAxMTowMDo1MSIsc3RvcmVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Il1d
:: src/
:: src/logic/
:: src/logic/creation.lua
--[[pod_format="raw",created="2024-08-30 06:25:09",modified="2024-09-16 11:00:51",revision=2607]]
--- Board Creation Logic


function logic_cells(tiling)
	local grid
	local size
	if tiling == "square" then
		grid = sgrid_new()
		local height = grid:max_height() - 1
		for x = 0, 5 do
			for y = 0, height do
				grid:set(pos(x, y), cell_good)
			end
		end
	elseif tiling == "hex" then
		grid = hgrid_new()
		local height = (grid:max_height() - 1) * 2
		for x = 0, 6 do
			for y = 0, height, 2 do
				grid:set(pos(x, y - (x % 2)), cell_good)
			end
		end
	end
	return grid
end


-------------------------------------------------------------------------


function logic_new_cell_column(stats, cells)
	stats.columns += 1
	if cells:tiling() == "square" then
		local height = cells:max_height() - 1
		for y = 0, height do
			cells:set(pos(stats.columns - 1, y), cell_good)
		end
	elseif cells:tiling() == "hex" then
		local height = (cells:max_height() - 1) * 2
--			for y = 0, height, 2 do
--				grid:set(pos(x, y - (x % 2)), cell_good)
--			end
		for y = 0, height do
			local x = stats.columns - 1
			cells:set(pos(x, y - (x % 2)), cell_good)
		end
	end
end

------------------------------------------------------------------------


local function random_gem()
	return math.random(gem_air, gem_night)
end

local bag_of_gems = {}
local rejected_gems = {}


--local function random_gem()
--	while #bag_of_gems == 0 do
--		bag_of_gems = rejected_gems
--		rejected_gems = {}
--		for i = gem_air, gem_night do
--			add(rejected_gems, i)
--		end
--	end
--	local idx = math.random(1, #bag_of_gems)
--	local gem = bag_of_gems[idx]
--	deli(bag_of_gems, idx)
--	return gem
--end


function logic_fill_gem_at(cells, gems, states, p)
	local cell = cells:get(p) or 0
	if (cell & cell_mask == 0) or (cell & rock_mask != 0) then
		return
	end
	local test = (gems:tiling() == "square") and logic_test_sqr_match_at or logic_test_hex_match_at
	local gem = gems:get(p)
	if not gem then
		local attempts = 0
		local found = false
		while attempts < 16 and not found do
			if gem then
				add(rejected_gems, gem)
			end
			gem = random_gem()
			gems:set(p, gem)
			found = not test(gems, p)
			attempts += 1
		end
		if attempts == 16 then
			gem = gem_gift
			gems:set(p, gem)
		end
	end
end


function logic_fill_gems(cells, gems, states)
	-- TODO: transform into a coroutine
	-- TODO: fill in reverse gravity order
	if gems:tiling() == "square" then
		local height = gems:max_height() - 1
		for x = 0, 12 do
			for y = 6, height do
				logic_fill_gem_at(cells, gems, states, pos(x, y))
			end
		end
	elseif gems:tiling() == "hex" then
		-- TODO
--		local height = (2 * gems:max_height()) - 2
--		for x = 0, 12 do
--			for y = 6 * 2, height, 2 do
--				logic_fill_gem_at(cells, gems, states, pos(x, y + ((x + 1) % 2)))
--			end
--		end
		cells:foreachpos(
			function(p, _)
				if p.y < 2 * 7 then
					return
				end
				logic_fill_gem_at(cells, gems, states, p)
			end
		)
	end
end

:: src/logic/matching.lua
--[[pod_format="raw",created="2024-08-24 08:12:55",modified="2024-09-16 11:00:51",revision=3686]]
--- Matching Logic

-- The matching algorithm has two phases:
--
-- 1. First, a linear sweep through all the gems, and for each gem involved in a match
--    creates a mark registering which direction(s) matched.
-- 2. Then a flood-fill algorithm is used to group matches together.


local function logic_is_matching(gem1, gem2)
	if (not gem1) or (not gem2) then
		return false
	end
	
	-- Only colored gems can match.
	if (gem1 < gem_color_first) or (gem1 > gem_color_last) then
		return false
	end
	if (gem2 < gem_color_first) or (gem2 > gem_color_last) then
		return false
	end

	return (gem1 == gem2)
end


--------------------------------------------------------------------------


local function test_3(gems, p0, p1, p2)
	local gem0 = gems:get(p0)
	local gem1 = gems:get(p1)
	local gem2 = gems:get(p2)
	return logic_is_matching(gem0, gem1)
		and logic_is_matching(gem0, gem2)
		and logic_is_matching(gem1, gem2)
end


local function test_4(gems, p0, p1, p2, p3)
	local gem0 = gems:get(p0)
	local gem1 = gems:get(p1)
	local gem2 = gems:get(p2)
	local gem3 = gems:get(p3)
	return logic_is_matching(gem0, gem1)
		and logic_is_matching(gem0, gem2)
		and logic_is_matching(gem0, gem3)
		and logic_is_matching(gem1, gem2)
		and logic_is_matching(gem1, gem3)
		and logic_is_matching(gem2, gem3)
end


function logic_test_sqr_match_at(gems, p)
	local S = p + pos(0, 1)
	local SS = p + pos(0, 2)
	local N = p + pos(0, -1)
	local NN = p + pos(0, -2)
	local E = p + pos(1, 0)
	local EE = p + pos(2, 0)
	local W = p + pos(-1, 0)
	local WW = p + pos(-2, 0)
	local SE = p + pos(1, 1)
	local SW = p + pos(-1, 1)
	local NE = p + pos(1, -1)
	local NW = p + pos(-1, -1)
	return test_3(gems, SS, S, p) or test_3(gems, S, p, N) or test_3(gems, p, N, NN)
		or test_3(gems, EE, E, p) or test_3(gems, E, p, W) or test_3(gems, p, W, WW)
		or test_4(gems, p, S, SE, E) or test_4(gems, p, S, SW, W) 
		or test_4(gems, p, N, NE, E) or test_4(gems, p, N, NW, W)
end


function logic_test_hex_match_at(gems, p)
	local S = p + pos(0, 2)
	local S_S = p + pos(0, 4)
	local N = p + pos(0, -2)
	local N_N = p + pos(0, -4)
	local SE = p + pos(1, 1)
	local SE_SE = p + pos(2, 2)
	local SW = p + pos(-1, 1)
	local SW_SW = p + pos(-2, 2)
	local NE = p + pos(1, -1)
	local NE_NE = p + pos(2, -2)
	local NW = p + pos(-1, -1)
	local NW_NW = p + pos(-2, -2)
	local E = p + pos(2, 0)
	local W = p + pos(-2, 0)
	return test_3(gems, S_S, S, p) or test_3(gems, S, p, N) or test_3(gems, p, N, N_N)
		or test_3(gems, SE_SE, SE, p) or test_3(gems, SE, p, NW) or test_3(gems, p, NW, NW_NW)
		or test_3(gems, NE_NE, NE, p) or test_3(gems, NE, p, SW) or test_3(gems, p, SW, SW_SW)
		or test_4(gems, p, SE, S, SW) or test_4(gems, p, NE, N, NW)
		or test_4(gems, p, NE, E, SE) or test_4(gems, p, NW, W, SW)
end


local function check_3_and_mark(gems, p0, p1, p2, mark, marks)
	if test_3(gems, p0, p1, p2) then
		marks:merge(p0, mark)
		marks:merge(p1, mark)
		marks:merge(p2, mark)
	end
end


local function check_4_and_mark(gems, p0, p1, p2, p3, mark, marks)
	if test_4(gems, p0, p1, p2, p3) then
		marks:merge(p0, mark)
		marks:merge(p1, mark)
		marks:merge(p2, mark)
		marks:merge(p3, mark)
	end
end


local function mark_sgrid_matches_at(gems, p0, marks)
	check_3_and_mark( gems,
		p0,
		p0 + pos(0, 1),
		p0 + pos(0, 2),
		{ name = "matching", vertical = true }, marks )
	check_3_and_mark( gems,
		p0,
		p0 + pos(1, 0),
		p0 + pos(2, 0),
		{ name = "matching", horizontal= true }, marks )
	check_4_and_mark( gems,
		p0,
		p0 + pos(1, 0),
		p0 + pos(0, 1),
		p0 + pos(1, 1),
		{ name = "matching", vertical = true, horizontal = true }, marks )
end


local function mark_hgrid_matches_at(gems, p0, marks)
	check_3_and_mark( gems,
		p0,
		p0 + pos(0, 2),
		p0 + pos(0, 4),
		{ name = "matching", vertical = true }, marks )
	check_3_and_mark( gems,
		p0,
		p0 + pos(1, 1),
		p0 + pos(2, 2),
		{ name = "matching", horizontal_SE = true }, marks )
	check_3_and_mark( gems,
		p0,
		p0 + pos(1, -1),
		p0 + pos(2, -2),
		{ name = "matching", horizontal_NE = true }, marks )
	local p1 = p0 + pos(1, 1)
	local p2 = p0 + pos(1, -1)
	local p3 = p0 + pos(2, 0)
	if test_4(gems, p0, p1, p2, p3) then
		marks:merge(p0, { name = "matching", vertical = true, horizontal_NE = true, horizontal_SE = true})
		marks:merge(p1, { name = "matching", vertical = true, horizontal_SE = true })
		marks:merge(p2, { name = "matching", vertical = true, horizontal_NE = true })
		marks:merge(p3, { name = "matching", vertical = true, horizontal_NE = true, horizontal_SE = true})
	end
end


local function mark_all_matches(gems)
	local marks = gems:new_grid()
	if gems:tiling() == "square" then
		gems:foreachpos(
			function(p, _gem)
				mark_sgrid_matches_at(gems, p, marks)
			end
		)
	elseif gems:tiling() == "hex" then
		gems:foreachpos(
			function(p, _gem)
				mark_hgrid_matches_at(gems, p, marks)
			end
		)
	end
	return marks
end


---------------------------------------------------------------------------


local function group_this_match(cells, gems, marks, p)
	-- A simple flood-fill algorithm to group all
	-- intersecting linear matches together.
	local colour = false
	local positions = {}
	local one_good_cell = false
	local remaining = { p }
	while #remaining > 0 do
		local current = deli(remaining)
		local gem = gems:get(current)
		if not colour then
			colour = gem
		end
		local mark = marks:get(current)
		if mark and mark.name == "matching"
			and (not mark.counted)
			and logic_is_matching(colour, gem)
		then
			colour = gem
			add(positions, current)
			marks:merge(current, { counted = true })
			local cell = cells:get(current)
			if cell and cell & cell_mask == cell_good then
				one_good_cell = true
			end
			local neighbours = gems:neighbours(current)
			foreach(
				neighbours,
				function(n)
					local s = marks:get(n.position)
					if not s then
						return
					end
					if s and s.name == "matching"
						and (not s.counted)
						and s[n.direction]
					then
						add(remaining, n.position)
					end
				end
			)
		end
	end
	return { colour = colour, positions = positions, one_good_cell = one_good_cell }
end


function logic_find_matches(cells, gems)
	local marks = mark_all_matches(gems)
	local matches = {}
	marks:foreachpos(
		function(p, mark)
			if mark and mark.name == "matching"
				and (not mark.counted)
			then
				local match = group_this_match(cells, gems, marks, p)
				add(matches, match)
			end
		end
	)
	return matches, marks
end
:: src/logic/mechanics.lua
--[[pod_format="raw",created="2024-08-30 06:41:59",modified="2024-09-16 11:00:51",revision=2424]]
--- Core Mechanics Logic


function logic_mark_gravity(cells, gems, marks, gravity)
	local some_gems_are_falling = false
	gems:foreachpos(
		function(p, gem)
			local below = p + gravity
			local distance = 0
			local cell_below = cells:get(below)
			while cell_below
				and (cell_below & cell_mask != cell_none)
				and (cell_below & rock_mask == 0)
			do
				if (not gems:get(below)) then
					some_gems_are_falling = true
					distance += 1
				end
				below += gravity
				cell_below = cells:get(below)
			end
			if distance > 0 then
				marks:set(p, { name = "falling", target = p + distance * gravity })
			end
		end
	)
	return some_gems_are_falling
end


function logic_enact_gravity(gems, marks)
	local fell_gems = {}
	marks:foreachpos(
		function(p, mark)
			if mark.name == "falling" then
				local new_p = mark.target
				add(fell_gems, { gem = gems:get(p), pos = new_p })
				gems:del(p)
				marks:del(p)
			end
		end
	)
	foreach(fell_gems,
		function(fell_gem)
			gems:set(fell_gem.pos, fell_gem.gem)
			marks:del(fell_gem.pos)
		end
	)
end


------------------------------------------------------------------------


function logic_mark_swap(gems, marks, source, target)
	local gem0 = gems:get(source)
	local gem1 = gems:get(target)
	local test = (gems:tiling() == "square") and logic_test_sqr_match_at or logic_test_hex_match_at
	gems:set(source, gem1)
	gems:set(target, gem0)
	local matched = test(gems, target) or test(gems, source)
	gems:set(source, gem0)
	gems:set(target, gem1)
--	if not matched then
--		return false
--	end
	marks:set(source, {
		name = "swapping",
		selected = true,
		target = target,
	})
	marks:set(target, {
		name = "swapping",
		target = source,
	})
	return true
end


function logic_enact_swap(gems, marks)
	local reinsert = {}
	marks:foreachpos(
		function(p, mark)
			if mark.name == "swapping" then
				add(reinsert, { gem = gems:get(p), position = mark.target })
				gems:del(p)
				marks:del(p)
			end
		end
	)
	foreach(
		reinsert,
		function(r) gems:set(r.position, r.gem) end
	)
end


-------------------------------------------------------------------------


function logic_enact_clear(gems, marks)
	marks:foreachpos(
		function(p, mark)
			if mark.name == "matching" then
				gems:del(p)
				marks:del(p)
			end
		end
	)
end


-------------------------------------------------------------------------


function logic_push_up(cells, gems, marks)
	if gems:tiling() == "square" then
		local width = cells:max_width() - 1
		local height = cells:max_height() - 1
		for x = 0, width do
			for y = 0, height do
				local position = pos(x, y)
				local below = pos(x, y + 1)
				gems:set(position, gems:get(below))
				marks:set(position, marks:get(below))
			end
		end
		for x = 0, 12 do
			logic_fill_gem_at(cells, gems, marks, pos(x, height))
		end
	elseif gems:tiling() == "hex" then
		local width = cells:max_width() - 1
		local height = (cells:max_height() - 1) * 2
		cells:foreachpos(
			function(position, _)
				local below = pos(position.x, position.y + 2)
				gems:set(position, gems:get(below))
				marks:set(position, marks:get(below))
			end
		)
		cells:foreachpos(
			function(position, _)
				if position.y >= height - 1
				then
					logic_fill_gem_at(cells, gems, marks, position)
				end
			end
		)
	end
end

:: src/logic/shuffle.lua
--[[pod_format="raw",created="2024-09-13 09:11:02",modified="2024-09-16 11:00:51",revision=1273]]

:: src/logic/spells.lua
--[[pod_format="raw",created="2024-08-30 06:37:36",modified="2024-09-16 11:00:51",revision=1226]]
--- Spell Logic


function logic_gain_mana(stats, matches)
	local gained = false
	foreach(
		matches,
		function(match)
			local count = #(match.positions)
			stats.in_cascade = true
			stats.experience += 1 + 3 * (count - 3)
			stats.colours[match.colour] += count
			gained = true
		end
	)
	return gained
end

:: src/logic/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTMwIDA2OjI0OjM5Iixtb2RpZmllZD0iMjAyNC0w
OS0xNiAxMTowMDo1MSJdXQ==
:: src/constants.lua
--[[pod_format="raw",created="2024-08-24 15:17:10",modified="2024-09-16 11:00:51",revision=3917]]
--- Match3 Global Constants


-- Gems and cells ------------------------------------------------------

-- Color gems
gem_air = 0x01
gem_fire = 0x02
gem_day = 0x03
gem_earth = 0x04
gem_water = 0x05
gem_night = 0x06
gem_white = 0x07
gem_black = 0x08

gem_color_first = gem_air
gem_color_last = gem_black

-- Black gems
gem_gift = 0x08
gem_bomb = 0x09
gem_cat = 0x0a
gem_bat = 0x0b
gem_robot = 0x0c
gem_robot_asleep = 0x0d
gem_robot_asleep2 = 0x0e

gem_names = {
	[gem_air] = "Air",
	[gem_fire] = "Fire",
	[gem_day] = "Day",
	[gem_earth] = "Earth",
	[gem_water] = "Water",
	[gem_night] = "Night",
	[gem_white] = "White",
	[gem_black] = "Black",
}


-- Cells
cell_mask = 0x03
cell_none = 0x00
cell_good = 0x01
cell_bad = 0x02

-- Rocks
rock_full = 0x10
rock_cracked = 0x20
rock_broken = 0x30
cell_door = 0x40
cell_chest_air = 0x50
cell_chest_fire = 0x60
cell_chest_day = 0x70
cell_chest_earth = 0x80
cell_chest_water = 0x90
cell_chest_night = 0xa0

rock_mask = 0xf0

:: src/gfx.lua
--[[pod_format="raw",created="2024-08-24 12:06:13",modified="2024-09-16 11:00:51",revision=5817]]
--- Graphics


local cell_width = 29
local cell_height = 29


function gfx_draw_cells(cells, stats)
	local function draw_cell(p, _)
		local has_cell = cells:get(p)
		if p.y == -1 then
			if cells:tiling() == "square" then
				has_cell = cells:get(pos(p.x, p.y + 1))
			elseif cells:tiling() == "hex" then
				has_cell = cells:get(pos(p.x, p.y + 2))
			end
		end
		if not has_cell then
			return
		end
		local x, y = cells:coords_cell(p)
		local sprite
		if cells:tiling() == "square" then
			sprite = 32
			local offset = ((stats.turn - 1) // stats.speed) % 2
			sprite += (p.x + p.y + offset) % 2
		elseif cells:tiling() == "hex" then
			sprite = 40
			local offset = ((stats.turn - 1) // stats.speed) % 3
			sprite += (p.y + (p.x * 3) - offset) % 3
		end
		spr(sprite, x, y)
	end
	if cells:tiling() == "square" then
		local width = cells:max_width() - 1
		local height = cells:max_height() - 1
		for x = 0, width do
			for y = -1, height do
				draw_cell(pos(x, y))
			end
		end
	elseif cells:tiling() == "hex" then
		cells:foreachpos(draw_cell)
	end
end


-----------------------------------------------------------------------


local sprites_color_gem = {
	[gem_air] = 1,
	[gem_fire] = 2,
	[gem_day] = 3,
	[gem_earth] = 4,
	[gem_water] = 5,
	[gem_night] = 6,
	[gem_white] = 7,
	[gem_black] = 8,
}


local sprites_other_gem = {
	[gem_gift] = 8,
	[gem_bomb] = 9,
	[gem_cat] = 10,
	[gem_bat] = 11,
	[gem_robot] = 12,
	[gem_robot_asleep] = 13,
	[gem_robot_asleep2] = 13,
}

--color_gem_skin = math.random(0, 14)
color_gem_skin = 0
local function gem_sprite(gem)
	local base = 128 + color_gem_skin * 8
	if gem >= gem_color_first and gem <= gem_color_last then
		return sprites_color_gem[gem] - 1 + base
	else
		return sprites_other_gem[gem]
	end
end


local function scaled_gem(sprite, x, y, size)
	local w, h = flr(29 * size + 0.5) // 2 * 2 + 1, flr(29 * size + 0.5) // 2 * 2 + 1
	local x, y = x + ((29 - w) / 2), y + ((29 - h) / 2)
	sspr(sprite, 0, 0, 29, 29, x, y, w, h)
end


local function draw_exploded_gem(gem, x, y, clock, new_clock)
	local size = 32 * new_clock
	local colour = 10 + (gem - 1) * 5
	oval(x - size, y - size, x + 29 + size, y + 29 + size, colour + 1)
	if clock < 0.25 then
		ovalfill(x + 2, y + 2, x + 25, y + 25, 7)
	elseif clock < 0.50 then
		ovalfill(x + 2, y + 2, x + 25, y + 25, colour + 2)
	elseif clock < 0.75 then
		ovalfill(x + 1, y + 1, x + 27, y + 27, colour + 1)
	elseif clock < 1.0 then
		ovalfill(x, y, x + 29, y + 29, colour)
	end
end


function gfx_draw_gems(cells, gems, states, clock)
	local function draw_gem(p, gem)
		local x, y = gems:coords_gem(p)
		local sprite = gem_sprite(gem)
		local cell = cells:get(p)
		if cell and cell & cell_mask == cell_bad then
			pal(53, 58)
		end
		local state = states:get(p)
		if not state or state.name == "broken" then
			spr(sprite, x, y)
		elseif state.name == "new" then
			scaled_gem(sprite, x, y, clock)
		elseif state.name == "matching" then
		elseif state.name == "falling" or state.name == "swapping"
		then
			local dest_x, dest_y = gems:coords_gem(state.target)
			local ix, iy = x + clock * (dest_x - x), y + clock * (dest_y - y)
			spr(sprite, ix, iy)
		elseif state.name == "moving" then
			x, y = gems:coords_gem(state.source, gem)
			local dest_x, dest_y = gems:coords_gem(state.target)
			scaled_gem(gem_sprite(state.target_gem), dest_x, dest_y, 1.0)
		end
		pal(53, 53)	
	end
	gems:foreachpos(draw_gem)
	local new_clock = clock * clock * clock * clock
	gems:foreachpos(
		function(p, gem)
			local x, y = gems:coords_gem(p)
			local sprite = gem_sprite(gem)
			local cell = cells:get(p)
			if cell and cell & cell_mask == cell_bad then
				pal(53, 58)
			end
			local state = states:get(p)
			if state and state.name == "matching" then
				draw_exploded_gem(gem, x, y, clock, new_clock)
			elseif state and state.name == "moving" then
				x, y = gems:coords_gem(state.source, gem)
				local dest_x, dest_y = gems:coords_gem(state.target)
				local ix, iy = x + clock * (dest_x - x), y + clock * (dest_y - y)
				spr(gem_sprite(state.moving_gem), ix, iy)
			end
		end
	)
end


-----------------------------------------------------------------------


function gfx_draw_turns(ox, oy, turn, anim_turn)
	spr(64, ox, oy)
	local hundreds = (turn // 100) % 10
	local tens = (turn // 10) % 10
	local ones = turn % 10
	local anim = anim_turn // 2
	pal(7, 1)
	clip(ox + 7, oy + 3, ox + 7 + 3 * 8, oy + 3 + 8)
	-- hundreds
	if anim == 0 or (turn % 100) > 0 then
		spr(65 + hundreds, ox + 7, oy + 6)
	else
		spr(65 + hundreds, ox + 7, oy + 6 + anim)
		spr(65 + ((hundreds - 1) % 10), ox + 7, oy + 6 + anim - 10)
	end
	-- tens
	if anim == 0 or ones > 0 then
		spr(65 + tens, ox + 7 + 8, oy + 6)
	else
		spr(65 + tens, ox + 7 + 8, oy + 6 + anim)
		spr(65 + ((tens - 1) % 10), ox + 7 + 8, oy + 6 + anim - 10)
	end
	-- ones
	spr(65 + ones, ox + 7 + 2 * 8, oy + 6 + anim)
	spr(65 + ((ones - 1) % 10), ox + 7 + 2 * 8, oy + 6 + anim - 10)
	clip()
	pal(7, 7)
end


function gfx_draw_level(ox, oy, exp, zoomed)
	local base_char
	local char_width
	if zoomed then
		base_char = 85
		char_width = 11
		oy -= 3
	else
		base_char = 75
		char_width = 8
	end
	local thousands = (exp // 1000) % 10
	local hundreds = (exp // 100) % 10
	local tens = (exp // 10) % 10
	local ones = exp % 10
	local digits = 4
	if exp < 10 then
		digits = 1
	elseif exp < 100 then
		digits = 2
	elseif exp < 1000 then
		digits = 3
	else
		digits = 4
	end
	ox -= (digits * char_width) // 2
	if exp >= 1000 then
		spr(base_char + thousands, ox, oy)
		ox += char_width
	end
	if exp >= 100 then
		spr(base_char + hundreds, ox, oy)
		ox += char_width
	end
	if exp >= 10 then
		spr(base_char + tens, ox, oy)
		ox += char_width
	end
	spr(base_char + ones, ox, oy)
end


function gfx_draw_xp_bar(ox, oy, mana)
	spr(95, ox, oy)
	if mana == 0 then
		return
	end
	local size = min(91, flr(0.5 + 91*(mana / 50)))
	rectfill(ox+1, oy+2, ox+1+size, oy+5, 40)
	line(ox+1+size, oy+2, ox+1+size, oy+5, 39)
	line(ox+1, oy+2, ox+1, oy+5, 41)
	if size > 1 then
		line(ox+2, oy+1, ox+1+size-1, oy+1, 41)
		line(ox+2, oy+6, ox+1+size-1, oy+6, 39)
	end
end
:: src/hgrid.lua
--[[pod_format="raw",created="2024-08-25 08:16:09",modified="2024-09-16 11:00:51",revision=3544]]
--- Hex Grids

--- Hex grids use the "double height" coordinate system:
---
---     (0,0)         (2,0)         (4,0)
---            (1,1)         (3,1)
---     (0,2)         (2,2)         (4,2)
---            (1,3)         (3,3)
---     (0,4)         (2,4)         (4,4)
---
--- The origin of the grid, `pos(0, 0)`, is at the top left.


-- Local Constants --------------------------------------------------------


local max_width <const> = 13
local max_height <const> = 12

local dx <const> = 25
local dy <const> = 14


------------------- -----------------------------------------------------------


local metatable = {}


function hgrid_new()
	local grid = {}
	metatable.default_origin(grid)
	setmetatable(grid, { __index = metatable })
	for i = 0, max_width * max_height do
		grid[i] = nil -- TODO false
	end
	return grid
end


function metatable:new_grid()
	return hgrid_new()
end


function metatable:clone()
	local grid = self:new_grid()
	grid.origin = self.origin
	self:foreachpos(function(p, item) grid:set(p, item) end)
	return grid
end


-----------------------------------------------------------------------------


function metatable:tiling()
	return "hex"
end


function metatable:max_width()
	return max_width
end


function metatable:max_height()
	return max_height
end


-----------------------------------------------------------------------------


function metatable:get(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width then -- or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	return self[p.x + ((p.y // 2) * max_width)]
end


function metatable:set(p, value)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	self[p.x + ((p.y // 2) * max_width)] = value
end


function metatable:merge(p, state)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	local index = p.x + ((p.y // 2) * max_width)
	if not self[index] then
		self[index] = {}
	end
	for k, v in pairs(state) do
		self[index][k] = v
	end
end


function metatable:del(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	self[p.x + ((p.y // 2) * max_width)] = false
end


-- Screen Coordinates ---------------------------------------------------------


function metatable:default_origin()
	self.origin = { x = 116, y = 7 }
end


function metatable:compute_origin(delta)
	local min_p = pos(max_width, max_height)
	local max_p = pos(0, 0)
	self:foreachpos(
		function(position, cell)
			if not cell or cell == 0 then
				return
			end
			if position.x < min_p.x then min_p.x = position.x end
			if position.y < min_p.y then min_p.y = position.y end
			if position.x > max_p.x then max_p.x = position.x end
			if position.y > max_p.y then max_p.y = position.y end
		end
	)
	local width = 1 + max_p.x - min_p.x
	local height = 1 + max_p.y - min_p.y
	self.origin = {
		x = 110 + ((480 - 110) // 2) - ((width * dx) // 2) - (min_p.x * dx) - 4,
		y = (270 // 2) - ((height * dy) // 2) - (min_p.y * dy) - 8,
	}
	self.origin.y += 6 -- for Matchic Pon only
	self.origin.y -= flr(delta * dy * 2)
end


function metatable:coords_origin()
	return self.origin.x, self.origin.y
end


function metatable:coords_cell(p)
	local ox, oy = self:coords_origin()
	return ox + p.x * dx, oy + p.y * dy
end


function metatable:coords_gem(p)
	local ox, oy = self:coords_origin()
	return ox + (p.x * dx) + 3, oy + (p.y * dy) + 1
end


function metatable:pos(x, y)
	local ox, oy = self:coords_origin()
	x -= ox
	y -= oy + 1
	local px, py = x // dx, y // dy
	local xx, yy = x - (px * dx), y - (py * dy)
	if xx < 8 then
		if (px + py) % 2 == 0 and yy < dy + (-2 * xx) then
			px -= 1
			py -= 1
		elseif (px + py) % 2 != 0 and yy > -1 + (2 * xx) then
			px -= 1
		end
	end
	py = (2 * ((py - (px % 2)) // 2)) + (px % 2)
	return pos(px, py)
end


function metatable:distance(p0, p1)
	-- TODO: is this correct?
	return (abs(p0.x - p1.x) + abs(p0.y - p1.y)) // 2
end


-- Iterating ----------------------------------------------------------


function metatable:foreachpos(func)
	for x = 0, max_width do
		for y = x % 2, max_height * 2 - 1, 2 do
			local p = pos(x, y)
			local item = self:get(p)
			if item then
				func(p, item)
			end
		end
	end
end	


function metatable:neighbours(p)
	return {
		{ position = p + pos(1, 1), direction = "horizontal_SE" },
		{ position = p + pos(0, 2), direction = "vertical" },
		{ position = p + pos(-1, 1), direction = "horizontal_NE" },
		{ position = p + pos(-1, -1), direction = "horizontal_SE" },
		{ position = p + pos(0, -2), direction = "vertical" },
		{ position = p + pos(1, -1), direction = "horizontal_NE" },
	}
end


function metatable:blast_radius(p)
	return {
		p + pos(0, 0),
		p + pos(0, -2),
		p + pos(1, -1),
		p + pos(1, 1),
		p + pos(0, 2),
		p + pos(-1, 1),
		p + pos(-1, -1),
	}
end

:: src/in_editor.lua
--[[pod_format="raw",created="2024-08-30 08:13:35",modified="2024-09-13 09:08:06",revision=929]]
in_editor = {}

local tiling = "square"

local cells = false
local gems = false
local marks = false

local active_tool = 0
local ox, oy = 8, 8
local sx, sy = 32, 32

local tools = {
	[0] = cell_none,
	cell_good,
	cell_bad,
	rock_full,
	rock_cracked,
	rock_broken,
	cell_chest_air,
	cell_chest_fire,
	cell_chest_day,
	cell_chest_earth,
	cell_chest_water,
	cell_chest_night,
	cell_door,
	false,
	false,
	gem_gift,
	gem_bomb,
	false,
	gem_cat,
	gem_bat,
	gem_robot,
	false,
	false,
}



function in_editor:enter()
	if not cells then
		cells = logic_new_test_cells(tiling, true)
		gems = cells:new_grid()
	end
	cells:default_origin()
	gems:default_origin()
	marks = cells:new_grid()
end


function in_editor:exit()
end


function in_editor:update()
	if keyp("s") then
		tiling = "square"
		cells = false
		in_editor:enter()
	end
	if keyp("h") then
		tiling = "hex"
		cells = false
		in_editor:enter()
	end
	local mx, my, mb, _, _ = mouse()
	if mb == 0x1 and mx < 110 then
		mx -= ox
		my -= oy
		local x, y = clamp(mx // sx, 0, 2), clamp(my // sy, 0, 7)
		active_tool = clamp(x + 3 * y, 0, 22)
	elseif mb == 0x1 then
		local mp = cells:pos(mx, my)
		local tool = tools[active_tool]
		if tool == cell_none then
			local cell = cells:get(mp) or cell_none
			cell = (cell & ~cell_mask) | tool
			cells:set(mp, cell)
			gems:del(mp)
		elseif tool == cell_good or tool == cell_bad then
			local cell = cells:get(mp) or cell_none
			cell = (cell & ~cell_mask) | tool
			cells:set(mp, cell)
		elseif active_tool <= 12 then 
			local cell = cells:get(mp) or cell_none
			cell = (cell & cell_mask) | tool
			cells:set(mp, cell)
			gems:del(mp)
		elseif cells:get(mp) and cells:get(mp) & cell_mask != 0 then
			gems:set(mp, tool)
			local cell = cells:get(mp) or cell_none
			cell = (cell & cell_mask)
			cells:set(mp, cell)
		end
	end
	if mb == 0x2 then
		local mp = cells:pos(mx, my)
		local cell = cells:get(mp) or cell_none
		cell = (cell & cell_mask)
		cells:set(mp, cell)
		gems:del(mp)
	end
	if keyp("g") then
		in_game:load_from_editor(tiling, cells, gems)
		return in_game
	end
	return false
end


function in_editor:draw()
	cls(63)
	if not cells then
		return
	end
	local mx, _, _, _, _ = mouse()
	if mx <= 110 then
		window { cursor = "pointer" }
	else
		window { cursor = "crosshair" }
	end
	gfx_draw_cells(cells)
	gfx_draw_gems(cells, gems, marks, 0.0)
	-- Draw the panel
	rectfill(0, 0, 110, 269, 55)
	rectfill(ox, oy, ox + 28, oy + 28, 63)
	spr(33, ox + 1 * sx, oy + 0 * sy)
	spr(34, ox + 2 * sx, oy + 0 * sy)
	spr(48, ox + 0 * sx, oy + 1 * sy)
	spr(49, ox + 1 * sx, oy + 1 * sy)
	spr(50, ox + 2 * sx, oy + 1 * sy)
	spr(52, ox + 0 * sx, oy + 2 * sy)
	spr(53, ox + 1 * sx, oy + 2 * sy)
	spr(54, ox + 2 * sx, oy + 2 * sy)
	spr(55, ox + 0 * sx, oy + 3 * sy)
	spr(56, ox + 1 * sx, oy + 3 * sy)
	spr(57, ox + 2 * sx, oy + 3 * sy)
	spr(51, ox + 0 * sx, oy + 4 * sy)

	spr(8, ox + 0 * sx, oy + 5 * sy)
	spr(9, ox + 1 * sx, oy + 5 * sy)
--	spr(11, ox + 2 * sx, oy + 5 * sy)
	spr(10, ox + 0 * sx, oy + 6 * sy)
	spr(11, ox + 1 * sx, oy + 6 * sy)
	spr(12, ox + 2 * sx, oy + 6 * sy)
--	spr(14, ox + 0 * sx, oy + 7 * sy)
--	spr(15, ox + 1 * sx, oy + 7 * sy)

	local x, y = active_tool % 3, active_tool // 3
	rect(ox + x * sx - 1, oy + y * sy - 1, ox + x * sx + 29, oy + y * sy + 29, 7)
end
:: src/in_game.lua
--[[pod_format="raw",created="2024-08-27 17:11:11",modified="2024-09-16 11:00:51",revision=5159]]
in_game = {}


-- The Board
local tiling = "square"
local gravity = pos(0, 1)

local cells = false
local gems = false
local marks = false

local matches = {}

local prev_cells = false
local prev_gems = false
local prev_stats = false

-- State Machine
local editor_requested = false
local substate = false
local clock = 0.0
local interaction = false

local starting_stats = {
	columns = 6,
	speed = 3,
	turn = 0,
	experience = 0,
	in_cascade = false,
	colours = {
		[gem_air] = 0,
		[gem_fire] = 0,
		[gem_day] = 0,
		[gem_earth] = 0,
		[gem_water] = 0,
		[gem_night] = 0,
		[gem_white] = 0,
		[gem_black] = 0,
	},
}
local stats = deep_copy(starting_stats)
local anim_turn = 0
local displayed_xp = 0
local star_seed = 37


-----------------------------------------------------------------------


-- Functions for substate need to be global, because of Lua
-- forward-declaration rule for locals.


function creating_the_board()
	cells = logic_cells(tiling)
	gems = cells:new_grid()
	cells:compute_origin(0.0)
	gems.origin = cells.origin
	marks = cells:new_grid()
	matches = {}
	stats = deep_copy(starting_stats)
	anim_turn = 0
	displayed_xp = 0
	star_seed = math.random(37, 6584587)
	logic_fill_gems(cells, gems, marks)
	return starting_new_turn
end


function starting_new_turn()
	if clock == 0.0 then
		stats.turn += 1
		anim_turn = 20
		stats.in_cascade = false
	end
	local step = (stats.turn - 1) % stats.speed
	local delta = 1.0 / stats.speed
	cells:compute_origin((step - 1) * delta + clock * delta)
	gems.origin = cells.origin
	if clock == 0.0 and step == 0 then
		logic_push_up(cells, gems, marks)
	end
	if clock == 0.0 and stats.turn % 10 == 0 then
		logic_new_cell_column(stats, cells)
	end
	--
	clock += 1.0 / 8.0
	if clock < 1.0 then 
		return starting_new_turn
	end
	return waiting_for_input
end


function waiting_for_input()
	local mx, my, mb, _, _ = mouse()
	if mb == 0x1 then
		local mp = cells:pos(mx, my)
		if gems:get(mp) then
			interaction = { name = "swap", position = mp, start = t() }
			return waiting_for_swap
		end
	end
	if keyp("del") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:set(p, gem_gift)
		marks = cells:new_grid()
		matches = {}
	end
	if keyp("w") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:set(p, gem_rainbow)
		marks:set(p, { name = "new" })
		matches = {}
		return checking_matches
	end
	if keyp("r") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		cells:set(p, (cells:get(p) or 0) | rock_full)
		gems:del(p)
		matches = {}
		return checking_matches
	end
	if keyp("a") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:set(p, gem_air)
		marks:set(p, { name = "new" })
		matches = {}
		return checking_matches
	end
	if keyp("m") then
		return checking_matches
	end
	if keyp("e") then
		tiling = (tiling == "square") and "hex" or "square"
		return creating_the_board
	end
	if keyp("z") then
		cells = prev_cells:clone()
		gems = prev_gems:clone()
		marks = cells:new_grid()
		stats = deep_copy(prev_stats)
	end
	if keyp("1") then color_gem_skin = 5 end
	if keyp("2") then color_gem_skin = 8 end
	if keyp("3") then color_gem_skin = 10 end
	if keyp("4") then
		color_gem_skin = (color_gem_skin - 1) % 15
	end
	if keyp("5") then color_gem_skin = 0 end
	if keyp("6") then
		color_gem_skin = (color_gem_skin + 1) % 15
	end
	if keyp("7") then color_gem_skin = 2 end
	if keyp("8") then
		local prev = color_gem_skin
		while prev == color_gem_skin do
			color_gem_skin = math.random(0, 14)
		end
	end
	if keyp("9") then color_gem_skin = 15 end
	return waiting_for_input
end


function waiting_for_swap()
	local mx, my, mb, _, _ = mouse()
	if mb != 0x1 then
		interaction = false
		return waiting_for_input
	end
	local mp = cells:pos(mx, my)
	if cells:distance(mp, interaction.position) != 1
		or (not cells:get(mp))
	then
		-- TODO: also prevent upward swap when no gem
		return waiting_for_swap
	end
	if cells:tiling() == "square"
		and mp.y == interaction.position.y - 1
		and not gems:get(mp)
	then
		return waiting_for_swap
	elseif cells:tiling() == "hex"
		and mp.y == interaction.position.y - 2
		and not gems:get(mp)
	then
		return waiting_for_swap
	end
	local success = logic_mark_swap(gems, marks, interaction.position, mp)
	interaction = false
	if not success then
		return waiting_for_input
	end
	prev_cells = cells:clone()
	prev_gems = gems:clone()
	prev_stats = deep_copy(stats)
	return swapping_two_gems
end


function swapping_two_gems()
	clock += 1.0 / 16.0
	if clock < 1.0 then
		return swapping_two_gems
	end
	logic_enact_swap(gems, marks)
	return applying_initial_gravity
end


function applying_initial_gravity()
	if clock == 0.0 then
		local some_gems_are_falling = logic_mark_gravity(cells, gems, marks, gravity)
		if not some_gems_are_falling then
			return checking_matches
		end
	end
	clock += 1.0 / 16.0
	if clock < 1.0 then
		return applying_initial_gravity
	end
	logic_enact_gravity(gems, marks)
	return checking_matches
end


function checking_matches()
	matches, marks = logic_find_matches(cells, gems)
	if #matches > 0 then
		local _ = logic_gain_mana(stats, matches)
		return clearing_gems
	end
	return starting_new_turn
end


function clearing_gems()
	clock += 1.0 / 16.0
	if clock < 1.0 then
		return clearing_gems
	end
	logic_enact_clear(gems, marks)
	return applying_gravity
end


function applying_gravity()
	if clock == 0.0 then
		local some_gems_are_falling = logic_mark_gravity(cells, gems, marks, gravity)
		if not some_gems_are_falling then
			return starting_new_turn
		end
	end
	clock += 1.0 / 16.0
	if clock < 1.0 then
		return applying_gravity
	end
	logic_enact_gravity(gems, marks)
	return checking_matches
end


-----------------------------------------------------------------------


function in_game:load_from_editor(ed_tiling, ed_cells, ed_gems)
	tiling = ed_tiling
	if tiling == "square" then
		gravity = pos(0, 1)
	else
		gravity = pos(0, 2)
	end
	cells = ed_cells:clone()
	gems = ed_gems:clone()
	marks = cells:new_grid()
	matches = {}
	stats = deep_copy(starting_stats)
	substate = creating_the_board
end


-----------------------------------------------------------------------


function in_game:enter()
	editor_requested = false
	if not substate then
		substate = creating_the_board
	end
end


function in_game:exit()
end


function in_game:update()
	local next = substate()
	if next != substate then
		clock = 0.0
		substate = next
	end
	if anim_turn > 0 then
		anim_turn -= 1
	end
	if displayed_xp < stats.experience then
		displayed_xp += 0.125
	elseif displayed_xp >= stats.experience then
		displayed_xp = stats.experience
	end
	if editor_requested then
		return in_editor
	end
	return false
end


function in_game:draw()
	if not cells then
		return
	end
	-- Starry background
	local hash = star_seed
	for x = 0, 9 do
		for y = 0, 6 do
			hash = hash~(hash << 13); hash = hash~(hash >> 17); hash = hash~(hash << 5)
			local flipped = (x+y)%2 == 0
			spr(120 + (hash%8), 110 + x * 40, 0 + y * 40, flipped, flipped)
		end
	end
	-- Draw the board
	if stats.turn > 0 then
		gfx_draw_cells(cells, stats)
		gfx_draw_gems(cells, gems, marks, clock)
	end
	-- Draw the panel
	rectfill(0, 0, 110, 269, 60)
	line(0, 0, 110, 0, 62)
	line(0, 0, 0, 269, 62)
	line(110, 0, 110, 269, 58)
	line(0, 269, 110, 269, 58)
	-- Top bar
	spr(102, 6, 10)
	spr(98, 14, 5)
	gfx_draw_turns(37, 2, stats.turn, anim_turn)
	spr(100, 79, 5)
	spr(102, 101, 10)
	-- Experience
	spr(104, 16, 30)
	gfx_draw_level(56, 30, flr(displayed_xp) // 50, false) ---, displayed_xp < stats.experience)
	spr(105, 71, 30)
	gfx_draw_xp_bar(8, 46, flr(displayed_xp) % 50)
--	cursor(11, 57, 58)
--	print("\14XP: " .. tostr(flr(displayed_xp)))
	cursor(12, 56, 58)
	print("\14experience: " .. tostr(flr(displayed_xp))
		.. " / " .. tostr(50 * flr(displayed_xp // 50) + 50))
	--
	line(0, 75, 110, 75, 62)
	line(0, 75 - 1, 110, 75 - 1, 58)
	---
	for i = 0, 5 do
		spr(96, 4, 84 + i * 30)
	end
	cursor(11, 95 + 0 * 30, 58)
	print("Air: " .. tostr(stats.colours[gem_air]))
	cursor(10, 94 + 0 * 30, 12)
	print("Air: " .. tostr(stats.colours[gem_air]))
	cursor(11, 95 + 1 * 30, 58)
	print("Fire: " .. tostr(stats.colours[gem_fire]))
	cursor(10, 94 + 1 * 30, 17)
	print("Fire: " .. tostr(stats.colours[gem_fire]))
	cursor(11, 95 + 2 * 30, 58)
	print("Day: " .. tostr(stats.colours[gem_day]))
	cursor(10, 94 + 2 * 30, 22)
	print("Day: " .. tostr(stats.colours[gem_day]))
	cursor(11, 95 + 3 * 30, 58)
	print("Earth: " .. tostr(stats.colours[gem_earth]))
	cursor(10, 94 + 3 * 30, 27)
	print("Earth: " .. tostr(stats.colours[gem_earth]))
	cursor(11, 95 + 4 * 30, 58)
	print("Water: " .. tostr(stats.colours[gem_water]))
	cursor(10, 94 + 4 * 30, 32)
	print("Water: " .. tostr(stats.colours[gem_water]))
	cursor(11, 95 + 5 * 30, 58)
	print("Night: " .. tostr(stats.colours[gem_night]))
	cursor(10, 94 + 5 * 30, 37)
	print("Night: " .. tostr(stats.colours[gem_night]))
	-- Update the cursor
	local mx, my = mouse()
	local cursor_pos = cells:pos(mx, my)
	local cell = cells:get(cursor_pos)
	if cell and cell != 0 then
		window { cursor = "grab" }
	else
		window { cursor = "" }
	end
	if false then
		rectfill(mx + 4 - 10, my + 10, mx + 36, my + 20, 7)
		print(tostr(cursor_pos.x)..","..tostr(cursor_pos.y), mx + 6 - 10, my + 12, 0)
	end
end
:: src/sgrid.lua
--[[pod_format="raw",created="2024-08-24 07:17:45",modified="2024-09-16 11:00:51",revision=4114]]
--- Square Grids

--- The origin of the grid, `pos(0, 0)`, is at the top left.


---------------------------------------------------------------------------


local max_width <const> = 13
local max_height <const> = 11

local dx <const> = 27
local dy <const> = 27


----------------------------------------------------------------------------


local metatable = {}


function metatable:new_grid()
	return sgrid_new()
end


function sgrid_new()
	local grid = {}
	metatable.default_origin(grid)
	setmetatable(grid, { __index = metatable })
	for i = 0, max_width * max_height do
		grid[i] = false
	end
	return grid
end


function metatable:clone()
	local grid = self:new_grid()
	grid.origin = self.origin
	self:foreachpos(function(p, item) grid:set(p, item) end)
	return grid
end


-------------------------------------------------------------------------------


function metatable:tiling()
	return "square"
end


function metatable:max_width()
	return max_width
end


function metatable:max_height()
	return max_height
end


--------------------------------------------------------------------------------


function metatable:get(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	return self[p.x + (p.y * max_width)]
end


function metatable:set(p, value)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	self[p.x + (p.y * max_width)] = value
end


function metatable:merge(p, state)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	local index = p.x + (p.y * max_width)
	if not self[index] then
		self[index] = {}
	end
	for k, v in pairs(state) do
		self[index][k] = v
	end
end


function metatable:del(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	self[p.x + (p.y * max_width)] = false
end


function metatable:distance(p0, p1)
	return abs(p0.x - p1.x) + abs(p0.y - p1.y)
end


-------------------------------------------------------------------------------


function metatable:default_origin()
	self.origin = { x = 121, y = 4 }
end


function metatable:compute_origin(delta)
	local min_p = pos(max_width, max_height)
	local max_p = pos(0, 0)
	self:foreachpos(
		function(position, cell)
			if not cell or cell == 0 then
				return
			end
			if position.x < min_p.x then min_p.x = position.x end
			if position.y < min_p.y then min_p.y = position.y end
			if position.x > max_p.x then max_p.x = position.x end
			if position.y > max_p.y then max_p.y = position.y end
		end
	)
	local width = 1 + max_p.x - min_p.x
	local height = 1 + max_p.y - min_p.y
	self.origin = {
		x = 110 + ((480 - 110) // 2) - ((width * dx) // 2) - (min_p.x * dx),
		y = (270 // 2) - ((height * dy) // 2) - (min_p.y * dy),
	}
	self.origin.y += (dy // 2) - 3 -- for Matchic Pon only
	self.origin.y -= flr(delta * dy)
end


function metatable:coords_origin()
	return self.origin.x, self.origin.y
end


function metatable:coords_cell(p)
	local ox, oy = self:coords_origin()
	return ox + p.x * dx, oy + p.y * dy
end


function metatable:coords_gem(p)
	local ox, oy = self:coords_origin()
	return ox + p.x * dx, oy + p.y * dy
end


function metatable:pos(x, y)
	local ox, oy = self:coords_origin()
	return pos((x - ox) // dx, (y - oy) // dy)
end


----------------------------------------------------------------------------


function metatable:foreachpos(func)
	local p = pos(0, 0)
	for x = 0, max_width do
		for y = 0, max_height do
			local p = pos(x, y)
			local item = self:get(p)
			if item then
				func(p, item)
			end
		end
	end
end	


function metatable:neighbours(p)
	return {
		{ position = p + pos(1, 0), direction = "horizontal" },
		{ position = p + pos(0, 1), direction = "vertical" },
		{ position = p + pos(-1, 0), direction = "horizontal" },
		{ position = p + pos(0, -1), direction = "vertical" },
	}
end


function metatable:blast_radius(p)
	return {
		p + pos(0, 0),
		p + pos(1, 0),
		p + pos(1, 1),
		p + pos(0, 1),
		p + pos(-1, 1),
		p + pos(-1, 0),
		p + pos(-1, -1),
		p + pos(0, -1),
		p + pos(1, -1),
	}
end

:: src/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTI0IDA3OjE3OjA5Iixtb2RpZmllZD0iMjAyNC0w
OS0xNiAxMTowMDo1MSJdXQ==
:: debug.lua
--[[pod_format="raw",created="2024-08-24 12:45:09",modified="2024-09-01 05:15:15",revision=75]]
-- Detect uninitialized globals and typos
-- from @snowkittykira from the BBS


-- if you're using include(), include this after including everything else,
-- since most included modules will need to assign global variables on load

-- these globals are needed by picotron
_init = _init or false
_draw = _draw or false
_update = _update or false
-- these are used by the picotron terminal
cproj_draw = cproj_draw or false
cproj_update = cproj_update or false
_ = _ or false
_is_terminal_command = _is_terminal_command or false
k = k or false
res = res or false
-- gui needs these
drag_t = drag_t or false

local function unknown_variable (t, k)
  error (debug.traceback ('unknown variable ' .. tostring (k), 2))
end

setmetatable (_G, {
  __index = unknown_variable,
  __newindex = unknown_variable,
})
:: drakma.lua
b64$LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNC0wNC0wNyAwNzo0Mjo0NSIsbW9k
aWZpZWQ9IjIwMjQtMDktMTMgMDk6MzQ6MjQiLHJldmlzaW9uPTE1MDddXQpfbW9kdWxlcyA9IHt9
CgotLSBBICdyZXF1aXJlJyBmdW5jdGlvbiBzaW1pbGFyIHRvIHN0YW5kYXJkIEx1YS4KLS0gSWRl
YSBmcm9tIGVsZ29waGVyIG9uIHRoZSBCQlMKZnVuY3Rpb24gcmVxdWlyZShuYW1lKQoJbG9jYWwg
Y2FjaGVkID0gX21vZHVsZXNbbmFtZV0KCWlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQKCglsb2Nh
bCBmaWxlbmFtZSA9IGZ1bGxwYXRoKG5hbWUgLi4gJy5sdWEnKQoJbG9jYWwgc3JjID0gZmV0Y2go
ZmlsZW5hbWUpIAoKCWlmICh0eXBlKHNyYykgIT0gInN0cmluZyIpIHBhbmljKCJjb3VsZCBub3Qg
aW5jbHVkZSAiIC4uIGZpbGVuYW1lKQoKCS0tIGh0dHBzOi8vd3d3Lmx1YS5vcmcvbWFudWFsLzUu
NC9tYW51YWwuaHRtbCNwZGYtbG9hZAoJLS0gY2h1bmsgbmFtZSAoZm9yIGVycm9yIHJlcG9ydGlu
ZykKCS0tIG1vZGUgKCJ0IiBmb3IgdGV4dCBvbmx5IC0tIG5vIGJpbmFyeSBjaHVuayBsb2FkaW5n
KQoJLS0gX0VOViB1cHZhbHVlCgktLSBAIGlzIGEgc3BlY2lhbCBjaGFyYWN0ZXIgdGhhdCB0ZWxs
cyBkZWJ1Z2dlciB0aGUgc3RyaW5nIGlzIGEgZmlsZW5hbWUKCWxvY2FsIGZ1bmMsIGVyciA9IGxv
YWQoc3JjLCAiQCIgLi4gZmlsZW5hbWUsICJ0IiwgX0VOVikKCWlmIChub3QgZnVuYykgcGFuaWMo
IlN5bnRheCBlcnJvcjoiLCB0b3N0cihlcnIpKQoKCWxvY2FsIG1vZHVsZSA9IGZ1bmMoKQoJX21v
ZHVsZXNbbmFtZV0gPSBtb2R1bGUKCglyZXR1cm4gbW9kdWxlCmVuZAoKCmZ1bmN0aW9uIHBhbmlj
KC4uLikKCWxvY2FsIGFyZ3MgPSB7IC4uLiB9Cglmb3JlYWNoKAoJCWFyZ3MsCgkJZnVuY3Rpb24o
c3RyKQoJCQlzZW5kX21lc3NhZ2UoMywgeyBldmVudCA9ICJyZXBvcnRfZXJyb3IiLCBjb250ZW50
ID0gc3RyIH0pCgkJZW5kCgkpCglzdG9wKCkKZW5kCgoKLS0gVGFibGUgdXRpbGl0eSBmdW5jdGlv
bnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0KCgpmdW5jdGlvbiBpc19lbXB0eSh0KQoJcmF3ZXF1YWwobmV4dCh0KSwgbmlsKQplbmQKCmZ1
bmN0aW9uIGRlZXBfY29weSh0LCBhbHJlYWR5KQoJaWYgKG5vdCBhbHJlYWR5KSBhbHJlYWR5ID0g
e30KCWlmIHR5cGUodCkgPT0gInRhYmxlIiB0aGVuCgkJaWYgYWxyZWFkeSBhbmQgYWxyZWFkeVt0
XSB0aGVuCgkJCXJldHVybiBhbHJlYWR5W3RdCgkJZW5kCgkJbG9jYWwgbmV3ID0ge30KCQlhbHJl
YWR5W3RdID0gbmV3CgkJZm9yIGssIHYgaW4gcGFpcnModCkgZG8KCQkJbmV3W2tdID0gZGVlcF9j
b3B5KHYsIGFscmVhZHkpCgkJZW5kCgkJcmV0dXJuIG5ldwoJZWxzZQoJCXJldHVybiB0CgllbmQK
ZW5kCgoKZnVuY3Rpb24gdG9zdHJyZWModCkKCWlmIHR5cGUodCkgIT0gInRhYmxlIiB0aGVuCgkJ
cmV0dXJuIHRvc3RyKHQpCgllbmQKCQoJbG9jYWwgcyA9IG5pbAoJZm9yIGssIHYgaW4gcGFpcnMo
dCkgZG8KCQlpZiBub3QocykgdGhlbgoJCQlzID0gInsgIgoJCWVsc2UKCQkJcyAuLj0gIiwgIgoJ
CWVuZAoJCXMgLi49IHRvc3RyKGspIC4uICIgPSAiIC4uIHRvc3RycmVjKHYpCgllbmQKCWlmIG5v
dCBzIHRoZW4KCQlyZXR1cm4gInt9IgoJZW5kCglzIC4uPSAiIH0iCgoJcmV0dXJuIHMKZW5kCgoK
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCgpmdW5jdGlvbiBjbGFtcCh2LCBtaW4sIG1heCkKCWlm
IHYgPCBtaW4gdGhlbgoJCXJldHVybiBtaW4KCWVuZAoJaWYgdiA_IG1heCB0aGVuCgkJcmV0dXJu
IG1heAoJZW5kCglyZXR1cm4gdgplbmQKCgpmdW5jdGlvbiBleHBfZGVjYXkoYSwgYiwgZGVjYXks
IGR0KQoJLS0tIExlcnAgc21vb3RoaW5nLCBidXQgZnJhbWVyYXRlLWluZGVwZW5kYW50LCBmcm9t
IEZyZXlhIEhvbG3DqXIKCS0tLSBodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PUxTTlF1
RkVET3lRCgktLS0gVXNlIGFzIGBhID0gZXhwX2RlY2F5KGEsIGIsIGRlY2F5LCBkdClgCglyZXR1
cm4gYiArIChhIC0gYikgKiBtYXRoLmV4cCgtIGRlY2F5ICogZHQpCmVuZAoKCi0tIFBvcyAtLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLQoKCi0tIFdBUk5JTkc6IGRvIG5vdCBmb3JnZXQgdGhhdCBgcG9zYCBpcyBh
IHJlZmVyZW5jZSB0eXBlLCBub3QgYSB2YWx1ZToKLS0gYXZvaWQgbW9kaWZ5aW5nIGluIHBsYWNl
LgpmdW5jdGlvbiBwb3MoeCwgeSkKCWxvY2FsIHAgPSB1c2VyZGF0YSgiaTE2IiwgMikKCXAueCA9
IHgKCXAueSA9IHkKCXJldHVybiBwCmVuZAoKCi0tIERyYXdpbmcgLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoK
Ci0tIEZyb20gU29waGllIG9uIHRoZSBkaXNjb3JkCmZ1bmN0aW9uIGdldF9kcmF3c3BhY2UoKQog
ICAgcmV0dXJuIHsKICAgICAgICBjYW1feD1wZWVrNCgweDU1MTApLAogICAgICAgIGNhbV95PXBl
ZWs0KDB4NTUxNCksCiAgICAgICAgY2xpcF9sPXBlZWsyKDB4NTUyOCksCiAgICAgICAgY2xpcF90
PXBlZWsyKDB4NTUyYSksCiAgICAgICAgY2xpcF9yPXBlZWsyKDB4NTUyYyksCiAgICAgICAgY2xp
cF9iPXBlZWsyKDB4NTUyZSksCiAgICB9CmVuZAoKCmZ1bmN0aW9uIHNldF9kcmF3c3BhY2UoZHJh
d3NwYWNlKQogICAgcG9rZTQoMHg1NTEwLGRyYXdzcGFjZS5jYW1feCkKICAgIHBva2U0KDB4NTUx
NCxkcmF3c3BhY2UuY2FtX3kpCiAgICBwb2tlMigweDU1MjgsZHJhd3NwYWNlLmNsaXBfbCkKICAg
IHBva2UyKDB4NTUyYSxkcmF3c3BhY2UuY2xpcF90KQogICAgcG9rZTIoMHg1NTJjLGRyYXdzcGFj
ZS5jbGlwX3IpCiAgICBwb2tlMigweDU1MmUsZHJhd3NwYWNlLmNsaXBfYikKZW5k
:: main.lua
--[[pod_format="raw",created="2024-03-30 05:39:34",modified="2024-09-16 11:00:51",revision=5650]]
include "drakma.lua"
include "src/constants.lua"
include "src/sgrid.lua"
include "src/hgrid.lua"
include "src/logic/creation.lua"
include "src/logic/matching.lua"
include "src/logic/spells.lua"
include "src/logic/mechanics.lua"
include "src/gfx.lua"
include "src/in_game.lua"
include "src/in_editor.lua"
include "debug.lua"


local state = in_game
local next_state = false


function _init()
	window { cursor = "" }
	fetch("pal/0.pal"):poke(0x5000)
	state:enter()
end


function _update()
	if next_state then
		state:exit()
		state = next_state
		state:enter()
	end
	next_state = state:update()
end


function _draw()
	state:draw()
	print(string.format("\014% 3.0f", (stat(1) * 100.0)) .. "%", 460, 264, 1)
end
:: .info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTIzIDE4OjQ1OjEzIixtb2RpZmllZD0iMjAyNC0w
OS0xNiAxMTowMDo1MSIscnVudGltZT0xMCxzdG9yZWQ9IjIwMjQtMDMtMzAgMDY6NTQ6MjQiLHdv
cmtzcGFjZXM9e3tsb2NhdGlvbj0ibWFpbi5sdWEjMTUiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9j
YXRpb249InNyYy9pbl9nYW1lLmx1YSM4MyIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0i
c3JjL2xvZ2ljL2NyZWF0aW9uLmx1YSMzOSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0i
c3JjL2xvZ2ljL3NodWZmbGUubHVhIzEiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InNy
Yy9jb25zdGFudHMubHVhIzE2Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJzcmMvZ2Z4
Lmx1YSMyMzgiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InNyYy9zZ3JpZC5sdWEjMTMy
Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJzcmMvaGdyaWQubHVhIzE0MSIsd29ya3Nw
YWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ic3JjL2xvZ2ljL21lY2hhbmljcy5sdWEjMTUxIix3b3Jr
c3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJzcmMvbG9naWMvbWF0Y2hpbmcubHVhIzgiLHdvcmtz
cGFjZV9pbmRleD0xfSx7bG9jYXRpb249InNyYy9sb2dpYy9zcGVsbHMubHVhIzEyIix3b3Jrc3Bh
Y2VfaW5kZXg9MX0se2xvY2F0aW9uPSJnZngvMC5nZngiLHdvcmtzcGFjZV9pbmRleD0yfSx7bG9j
YXRpb249InNmeC8wLnNmeCIsd29ya3NwYWNlX2luZGV4PTR9LHtsb2NhdGlvbj0icGFsLzAucGFs
Iix3b3Jrc3BhY2VfaW5kZXg9N319XV0=
:: [eoc]
