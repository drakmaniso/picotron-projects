picotron cartridge // www.picotron.net
version 2

:: design/
:: design/spells.txt
--[[pod_format="raw",created="2025-02-22 10:06:12",modified="2025-05-12 08:03:48",revision=92]]
# Spells
## Direct spells

### Destroy most common colour

:: design/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAyLTIyIDEwOjA2OjAyIixtb2RpZmllZD0iMjAyNS0w
NS0xMiAwODowMzo0OSJdXQ==
:: docs/
:: docs/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTI2IDE0OjAzOjI1Iixtb2RpZmllZD0iMjAyNS0w
NS0xMiAwODowMzo0OSJdXQ==
:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNS0w
NS0xMiAwODowMzo0OCIscmV2aXNpb249OTAzMF1dbHo0AFJ9AABV-AEA8xR7WzBdPXtibXA9cHh1
AEMgEBAE8PAsZmxhZ3M9MCxwYW5feAgAz3k9MCx6b29tPTZ9LDEA-1DxHh0dBPBPPxJAPuAODxYX
DxUOIA4XHxYO0A4HPxUuBz0O0A4PFh8UHS8WHR8UDQ4AoQ0PFA8TTQwPFB0PAP8QHQ8UDC0MCy0O
oDIPFhscLRwbDR4RYAIzLVMyHRIBUAkAEP8BYEIsQiEcIXACMy1DIh0SAQkANY_AMS5xHhHwTA8B
Cx0zDwH-NDkhEA8P8AYBIBHwBULwBwIzAgHwBgIDMgHwBBJjEvABAqMC4AKzEsACIxWDAgGgAiMl
gxIBkAIjFZMSAYAC8wAiAXAGAAAk4zIFAP8V00IBgAKzQgGQAqNSAaASY2IBwAHCAeABogHwARFi
EfAEYfA1tAAd8BdNAuACoAIDAsACAwKQAhMCoAITApACIwKAAiMCkAIDARMCYAITARwAYQMRE2IT
EQoAMiGDIRIAEaMQACfzAQUA8QmAAiMiYyIjAnACEwIPGgcBAkMCBwEOAhMRAFEOEQ4CIwYAABAA
MyMCLgQA8CVwAjMiQyIzAnAC8wMCgAJjKWMCYFFTCVNRcAIzAhMCEwIzAqAxIxIDEiMxcBEgAqMC
IBGwUwEvBGLyAB-wAIsBYAHwBBFAEfAEAQNBAwwA8SZDEdAhIAFjASAhUBEjEQABAx8PAx4DAQAR
IxEgAWMRDgcPKw4HDQ4RYwEQAXMBDh0OHQ4BcwwAIAMeKQAADAD-M4MBQwGDARAxYwEjAWMxEAEQ
AfMDARABQDHDMXABEAEjAUMBIwEQAaBBQ0HQASABQwEgAfADASMB8AkBAwHwCwHwj8kAHcAaAgEC
8AoBDxYB8AoLAEELAfAMAwDTBeHAAeMBoAED8gABkAYA8CESMUIxEgFwIQIBDR8PDQEiAQ0eDQEC
IUABEwECAQ4fEA4BIgEOHA4BAgETATABAwIWABYcFQBxEgEwARIBAjYAAzwAAxQAAlkA0hIBQCHy
ASFwAfIBAZAFALEygTIBkAEiAYMBIggAVAMBQgECDABwcgEiAaABEgkAbxIBwOHwTv0AJR8S-QAD
RrABA9ICARUC-QBVMgEiATL4AAMOAAXzADZRIlHrAGAPHB8dDxwCAT8fHQ7vAG3xEy8RoCGwARMR
cAEjEZABEhMRQAEyExFgAUITERABEg0PDw0UAPEiYhMRIg4PEA4yEwEgAZITEQINDg1SASABIhFi
ExFyARABEhEAASIRMhMRUgEQISABAg8AcwITETIBcBEPAFETIQIBwA0A4AIBIxHwAhEQATIDAfAG
-QARAQ8AEUIgACADEd8AEYAKAGIAAUIhMCEKAIICExEiEWABEwsAMFIRkAcA0IIRsAGyEeABghHw
AQGrBDABMhFTAG8R8AkR8EAOAR3wAhYRYBHwABEDAWABAxGwERMCCQDyIRIRcBETEgGAATIRQAET
MgGAAVIBMAFCAaABQgFAATIxQDEyAVABQhMBQAETQgFgAQQAE3AIABCAzAACrwEwMSAxrgEQIkQB
YBMiAbABMkAAAE4CQQEiAUDKARADDwIwYAESXQJxIgECMQAxAmgCAIkBcAESEwEAARMcABASjAEA
KwAwIAESAAI0DQ4NDgDyDbABUgESIRIBwAFSAQIBIwECAdABUgEDMgHgAVJqAVAAAUIBQgcAn1IB
IgHwApHwGicBHbAyIaARoBEjAXAREwQAMDIBQCEBMlAREzECoAEQERNCATABEzKnAIAiERNiATAB
UqQA8RERE5IBIAFyERNiESIBIAFSERMyESIBABESARABMhETAg0AkwIBICEQAQIhEw0AQRFwESM1
AjAgEcDJAEIQEfACygAwBgFCDgAAPwGxAhEDASAR4CFCAQAKADDAESK-AQENAEIhgBFSDQBQEwGg
EYILAPAH0BGyAfAAEYIB8AMRYgHwBREyAfAIEfQDPxHwLw8BHTAakfBqARBTVAEiAzJcAQCgAJFS
AeABQgFSAdDhAZACAVIBwAEDAiEZABCw6gEArwESAjIBFaAQAAAzAQP-ARAABQAxDQ4NDwABCwIR
Mg0CASECATQAMBIBQAUAEAIMAABDAhADVgJhAzIBIAEDWAIREnMCEJAkAAKIAiADMtICNTIBcAoA
QGABA1I6AGFSAVABAyLNAhJAPgAAwwEQA8ECUANCAUAR_AJiAyIRcBEiFAMhsBEdAwAvA09gEfAW
HwhwIvMD5wcAEAgSwwgIMEIjQgQIL-MDAQhBDxgLHg8xAP--SABRA-8jFbUD0NUjoNVDgFVUAwIF
U2BFdAIFJENARYQDREMwNfQBMyA19AMzEDX0AxMSECX0BSIFAAjwASQD9AEiECUTAvQCIhAlEgUH
AP8fFRMF9AIyEDP0AzIgM-QBMjBDdANUQkBDZBM0QmBTNAMCJFKAQ9KgI9LQA7LwFb8ACx8xvwAC
jpUEJSOgtQMFwwDwCgIFNEMwNZQCBUQzIDW0AlQzEDWkAwI0AgTLALAEA4QSBQIkAwIEIg0AkHQD
AgUUAiMCA8EA8Q9kEwIFJCIFMhAlFAI0ExIFJAIlFCIQJRQSBBMSFZTqADAiFbQSAPEBAwIVIrQi
EAUDAhMCBUQCpPgAMVQCpPkA-xtkAkQDNDIQM3QSJANEMiAzdAIkAzQyMENkEgMCNEJAQ1QDEhMU
QmBTBDMGATQxZQM1CAExFAMkCgFxFQQVNAMUAw8BMCUTVKQA8Ac0AxITMDUEAiQjIgU0AjMgNRQC
EzIlFQF2MxA1FCI1FCEBNhIlRCIBRgMCBWQjATUVAxIkATIFAwUmAScUEiYBECRrAAMqAUQ0AlQD
LQFmJAMEAjQTMgFQNAIEI0I1AXFEAwI0AzIUOQHxADQjAjQDAhUCBDIQMxQTUsIAYUIgMyJFAgsA
YTIwQxVEEhUAAEUBHzJEATLwHiUTcBUToEUjQCUjgFUjMCVDYGUjIDUEM1BFAwIFBCMQFTQzMDUU
AgUkAwIAFVEC8HUkAzQSABVEExIgJYQSAAUTNDIgJXQiECMUMjAVEyQDFCIwE0JABTMCAyQiQEJg
MyQy8AMjUkA1gBUAE0IwVRNQFQQDECJAVUMwAxQCkDUUUyADEhAlEyA1RDNgJRQTECVkExJAJSQj
ABVUAxQiQCU0EwAVRAMkIjAlFAMUIwAFAyQDDzAPACEEA5QAQCM0AwR6AP8PBTQSADMkQlAzJCIA
I4JgE1IgA4KAYjBysCKAIvATFwEMD4IEHg8xAP------KvEQIxMEIA8W-xUMQA8W-xQOIA8WLxTz
CS4PExAPFi4DZQIAgy4PEwAPFj8VDwCBPQ8TDxY_A2YCABA_DQATPQ0AHT0NADE_A2cCAEU_DxMN
DAAXDBgAJQwLSgAmDA0LAAoWAAJ4AEU_DAANkwD-AQwQDS7zCS4MIP4ODED8DSD0AAsZMvQAkwUH
BAAnAAcgFwIATwcAJwBAAAscOEAAkRAHIBcQBwAHMAIALxBHPwAcAX8AQgcwByACAA8-ACU-EBdA
vgAkETBAAK8ABwAHEAcARyAHQgAdb1cwN0AHMH0AIyAXEH0AETeBAQ9AACASRzcBAsIAHyA6ASEC
dwAOfwAPQgAbEDeCAD8QFxBAABn-AQcLBAA3EFcAFx86Fw4XDgAFAAN-Vw4ANx4QPpoADCwxNFsA
gBAXMCcPOhA3cxonDjADAH8QVwBXDgBeUAAdBqsAwQAeABcOICcOECceAAMAD1IANJ8XHiAnQBcO
FxD1AClgQBcPOiAnTQBwECcOFwAXHk0AQVcOAC78AC9AHlIAHbJXAFcPOhdORxBXEEMABZ8ALwBO
nwAf0CcgNw86ACcuABceIEf_AB8e5gEsAZ8AAN0ABfQABQYAECDvAB8glQEnAZgAPwA3HqYAMAtV
AHFXDgBHDhAetQAASQFfJx4gLhBUABrwAAoQBBBHMGcQhwAnLzonDowCDwUAEa_HDgBnHhBHHjBO
bwAMHDluAP8CICdQNw86MEcOIFcOMB4nDlADAAFAIIcAh2QAH45dABwNywDHAC4QJw5ANw4wNx4g
AwAfMGAAMAFbACBQJ1sAcTA3DkBHUA4PAC8nIB4BKXEQJ2AnDzpQtABBQCceQAkAIQAnHgQEegEB
ugARTm0AX1AnDmAuYwAc9QOHAIcPOocOJ24nDlBnIHcQhxBMAA_8ACvxBCBHMFcPOhBnDgBHPgA3
HjAnHkBgADMAJy68AAPBAA9hACUDugAnAD4cAQ8JAAU-YC4wPAItAQUAfwBnHgBnDgDFADcPZwAD
oYcOAHcOEGcOIC7EAFAwRw4QV2AAbyA3HkA_IGMAGQ_rCgHALTIzLjA2OTA0NzYxBgADQACTLTEu
NzE0Mjg1BgACTwAKIATyA2YiBPBY-zM38A4O-zI3DzHwDQgATw868AwKAP8FzA3-MTcfOvAO-Tfw
DIkBVzAuNTgzAQAEigEaMhgAD0wYAV5mHATwv4oBDwgAnw8ZAT3REQ4EEL8zMA6-Mg8xIAYAwBAO
3zIPMQAOPzJRPZMBIQ7dBgAfPQ4AB2IADr0PMR8HAK8POiC-MR86MLwQ8g0ZXxEOBPADhwAJUAAO
3QwAdgAaDAoAvxAOvQwgDr0MMLwgcAAcDfYAQE8yMU1pAPQNPREdET0MDzoOfRE9DAsObRFNDAsO
XRFdDAsO3QoAUAAOvQwbBQBvCyC8GzC77AAvCn0AEQB8ABEAfAARAHIAAvYAAAoADvIAD4UPJjUt
ODEqAh455RQPNQD-zPIHKOABAAAOAQAABP87Jw89-ztJDzwPOwQANv87EQ0ABBEAQD3-O3cFABYp
FwAPBAANMP87ZjIAHzNaAAoW0w0ADwQAETb-O6gNAAIRABYPDQAPUwBGEInJABY5EgAPBAARD1gA
ERAhWAAWoRIADwQAEQ9YAA8CFQAQEwUAEHthABAPBQAWAxwADwQAETb-O6YNAA9mAAYgzztbABAG
HgAWrhYAD2AAExBWOwAfBVQCAA9qAAJg-zsHDz2-DQAfPW4AHDD-O1RlABZBEgAPZQAIIBMfYQDQ
Pg89Hzz-OwkPPv87IhcAFmAkAA8EAAkPNQETMP87AQUAFATMABA_BQAWXyAADwQACQ9iABoBmAE-
Pw89wAASMP87bCoAPRUPPiwCD2QACRMHwgACywAWXiAADwQABQ-CABojVg_PAQANAEdYDzwvIwAP
BAAFgP87Ng8--zsjzgAWKxcAD2sADUBUHzwfawBBPw8_H-4BR1QPPE8nAA8EAAEw-ztyZgAWIxIA
AAQAEa8aAB8DagAGGFjVAB9WZgAPAPYCMP87Y2oAFiUWAA9qABEyWg88ZgASVBcAD2oADQAEACSf
OzUAMTkPPXYDALYFET5QBC8PO3wAEAAEABHvHQBBUw89fyEED38AGALtABaXEQAPbAASEw8hAASs
ABAlDwASURgAD3oAFQA4AkY9-ztdEgAPewAYAScBAYAAFTDTAxIBHQAAIQATbwgADwQABTb-O6QN
AA93AA4DegUDOgAQH3YAMRkPPfEAD3YAVCJPOxEHdz--O1cPPi8LAQ98ABcQTkMAHxFAAwYHyAAP
AAELAb8IAeMGEwHoBQ_MAB0Rj0gAEDI_ABZVFgAPjwAkARoBH1_FACUfXmQJBDH-Ow0JABQ_EQAv
DzuqAAMCLQAWq5IADGQAHw_AAAoQStMBFj0WABsPgAAPBAABHj6AAEEtDz0PCQEREFEEED2HBg_S
ACQfen0ABA6SAA8SAQgHmwEUAt8EEkCUAQ_WACNQSA89jzssARAYDgAWDB8ACO8BAN8IBREAHw9U
AAwEDABh-ztQDzxfqwASE5EHD6cAKBImpwMWPtUFFQojAB49qwAPYAIMDHQANP87degBFhlDAA8v
AAYPHAABMP87QkYBGCd3CR8HowALDwQADgh0ADL-O0s4BwEkBA7dBA8pAgEOpAAQCT8AFGNDAR8I
oAAADjkFD6QAGR_hmgAmEDSaABALBQAWHpsAFz0EAA_bAC0BOgESa0cACBoAD6cAFTH-O3A5ABA9
EAUE3AEfPaEAOBB5oQARFw4AKz5PHgAPpQAVEc9KABRi4QE0DQ898QUcPaoADuwGD60AGRA9nQgQ
AfICEkFPAA_uACcSZPwHFzyhAAmlABPPLgAPqQAjQ5cPP49NABNPUQAfD48ACBsPBAAEOABX-zuU
DzyeAB89ogApG2_fBDD-O1upAR89owBAH69BAS4fqZYAQARiAA_aACsTRyYJE89PAQSjAA_rACc4
Wg8-tQgFsAAAHgAXDwQAD7gAKxKZeQMOrwAPWgEjCaoADk0AD64ALRdV_xIMSgAPuwAJH__3ABkO
BAAPcQAfG48oADD-Ox27ABJXsgUMkwAPuwAjAZ4LEEQFAB0fxQAUPS8AD8UAKQRvAArJABIzTQsF
IAYPygAqNv87mhEAD7wAHAGZBh8PuAAWECkmBhpbowEvLzt_ACYHwwARQtYBBCsNAegGDlUJD1wA
Gg-aABsSHQsMFT6SAQ-fADsWmBEAD8wAT0JPDz8vQwVOPf87LyoAD9MAAQ-rBx0P1wBaAJ4JAVkA
AtYVH3EmAAMfD9cANhaWEQAPUQAVDlUAD7YBGxYvKBIQC4YCQQUPPS-tABpHKAAeDwQAD6QAFheP
DAAP_QADQQEPPU89DhZ_GgAPXgAABAQAHzwCAT8URQgEGiseAB8PBAALD5IABg-4ABER7-MAFoYV
AA9dAAQABAAXPhgAD-MANBBeBQAaIhoAHw8EAAcXPQQABBQAD4IAFgiKABZvcwIWfBoABwQAFz0E
AB88_AApDCAAFi8EAAHqARE_JQ4C4wwaICcAHw8EAAcXPQQAHjwEAA5AAA8NAQ8WkBUABwQAFz0E
AB88CAFBMP87GwkBHzQAARcfPQQAAB88BAApBgQBEQkEBEA_-zsqlAAWNSMABwQAFz0EAB88cwMC
DxYBLBEPiwAbTYIADxEBBB89BAAEHzwRAQIPFQJEBAgADwMBPBKRCQAPAgFhH_-_ADkPvQAIDwIB
CgcVChMfrhUvDztTAA4fPQQABB88BAApEy-uAwOKABM2XhQtDzsEABc9BAAXPAgADh4BD-4ABA8a
AREDHwMWMxoACB4ACwQAHz0EAAQfPAQAKQYRARBSigAWLRoACwQACG4ABAgADwwBCg-KAAgOHAAJ
FAETMKgWLw87LgAHB4oADwQAAR88BAApBhQBDjkDCAQAFz0EAB88fAQBBAwAD8kAEA8cAAITLzsa
A1cHFUoiAB8_MgAFAwQAHz0EAAQfPAQAKQQXARHPawkQSi8CFiceAA8EAAAXPQQAHzwgARUO1gAP
GAAHMP87OAUAEhSFDy49zyMADTMAAwQAHz0EAAQfPAQAKQBsAAP7CxA_kwAWMRsABwQAFz0IAAgE
AB88HgEAFD8QAA7TAA8EABM0-ztDcg0eMToAD0oAAB89BAAIHzwEACkUL7QlIq87IQ0BrwEeDwQA
Fz0IAAgEAB48PgIPBAAzPv87kwsBFy8MAAOJAR89BAAIHzwEACkCGwEWnBEABwQAHz0EAAQfPA4B
CA0gAA8EABkWr9gaFAfADh0PEAEPBAAFHz0EAAgfPCQBLxAtjgA-TA89Mh8FHz0EAAQfPC4BGR8v
KgEaH4cxABYfPQQACB88BAApEi8EABA-CQ5GP-87hBoABwQAHz0EAAgPSQJIAh8BD0kAER89BAAI
HzwEACk--ztqrAYDHz0EAAgPEwFCE08EAAN_ChArBQARGyEBLzwPBAALHz0EAAwfPCEBKxaiDQAD
BAAfPQQACBw81AAEDAAPIAABLw874QASJTxPHAESayAGDzYACR89BAAUHzwXASsQD08DFoISAAcE
AB89BAAEHDzUAAQMAAcgAB89HAElJa87NwIfPzoABh89BAAYHzw3Aj0XPF0ADwQAAQnTAAQMAAcc
AAkkAA8EABUTTwQAMf87gfgQD1QBBR89BAAYHzwaASsBsiIQPAUACyUqBwQAHz0EAAQJ2AAEDAAH
IAAXPRQAD0MCEhNPBAAPrQYJHz0EABgfPAQAKQJwDwHQDBQ6CQASHxAgHw8EAAMfPQQABAngAAQM
AAcgABc9FAAPKAESBCQAJU87qCEfaTYABh89BAAYHzwEACkBIwYDTQIOvCcEBAAfPQQABA8lAUYD
bxsfXzIABh89BAAYHzwEACkPiAQFFzxhAA8EAAEMFwEbPQQAGDwEAA7lAA8XAQUfjS0ABh89BAAY
HzwSASsbegYdCwQAHz0EAAgP8wABGz0EABg8BAAP7gABDxsBAxAVMgIWZxYADwQAAB89BAAYHzw2
AmEfPfcAABs9BAAEGAAMKAAPjQAIAVEwETddEQJ6DQxHABYP_hEfPQQAGB88JAGBHzwkAR0RT40A
EFcbARIA8hEFGwAPBAAAHz0EABgfPAQAKQBVDCE973oNEDpxAwuANgMEAB89BAAMDyoBGgewBA8m
AQQUaFYHFhIaAA8EAAAfPQQAGB88BAApAN8HITxvjhoWbBYABwQAGz0MAA8EAAEPIAE2Ey_DCAER
EzY_bzsbLBPvLxkfDwQABxs9BAAPFhIJHzw0ASsSE5A2Nv87cxYADwQACB89BAAAGzwEAA8YAAUP
OAEYFGZcAhUALAEPUgAFHz0EABgfPAQAKQP-HgFvJBBYBQAWCRwADwQACB89BAAEDyAAAR88MgEn
BrQEBjMBDwQABR89BAAYHzwEACUCETMTPTwtLw87BAAOHz0EAAQPIAABHzwpAR0Rj5IAFmkbAQ8V
FgQXPGUADwQAFR88BAAlMv87Ia83Aqs3H1JVAhcXPH8ACAQAHzwUAAQPLAEgFnleEx4PBAAfPQQA
GB88BAAVFy8MAAj7BgNHAhZuFgAPBAAMHz0EABQfPBsBPR89BAAcHzwbASsBFiofbjYAEh89BAAU
HzwTASMXE3c2CxgBHz0EABwP7AACDBgADxABAxAqBQAebSIAA1wVHz0EABQfPAQBIwEGOBpXFgAE
DAAHXgAPBAAVD_QAAgwYAAgMABMPLg8yPu87yQ8BGCsVP1QEEy8EAAMOARc8bAAPBAAFHzwOAQwf
PQ4BBxsIcj4PDgFjAZo-FpQeAA8AATwNBAACMwwBrwQQLnsAHx8BAW0WqhkAC-wAFzxdAA8EAAEf
PPwAHxAWBQAUHgkeHyH8ADsWL0AAAQQAHy8MAAQBsj0BGh8AAh4fL-kAUgFlPh4l3jcOdwAPBAAb
FDy-ABcPBAAfLwwAADL-O7ANABovbgEfPQQAAAQcAA-oACAB6kMTI3EvLy878QBtH29bAg8fPAQA
DQuxACY8D8wFFA3KAhIFLBEiPC85Ci8_b0QACx89BAAZF0-VAAQEABsvDAAAggARProfD-IAEBc9
HAAP8gAWAoAfEh1pOwF0AB4P0TgP6QAmBVYCBFkABAQAHS-pAAGEFhNMQD4P7gAAFzxXAAQEAB48
BAAPswAGEzxcQRZLfQAP5gAxHzzmABUBEwYAajFAPf87KJ0HEg1wAA81CQwePAQAD7AABhE8pSQD
HgoH4BwP6AApBCQAD_gAHRKGZgAPEwoQHjwEAA_mAAIE3gAfSdUABASdAAQMAAdjAA8EAAEfPNkA
GQHUBgPWERM2LEMAOgMTzzgAD1UOABs9BAAfPOcAFxETHQQG1zEP6wBSAXANAEY8Abo-IjxPJwAc
PZ4AB1cAAQQAFi8YAAkEABWPVwABOBESCfwpKT2PVQEP1wAvBagoA0oBAsw0Mv87iGcAH8__ACwC
hwETJUMrD7kAOQXrAQJHGQAGIAUSBg_2AA0LawALcAEBTz8VDQwtA7AHD7gAMgEkBidPO2EBD3ES
ABc9BAAFewAPqwADEzXvBR8voQA3EgWpCAOmABBwXwEfB6sAMRUJUQEWJSsAD1EBMwOxBRJMbQMP
qwAvH3OdADQA8QgDogIVB8kDF1CvJw_nACsQI1kAAd8IFhvzAh7PpAAFBAAaL-MDHz0EAAUAoAAC
VgAEcQABZCMPsgAEHzyyABcTDZQFD60AGAxiAA_tAABBAQ8-b_IZEA22ABgDtgABzkwTNkdFD9AB
Ag_9ABcfZbgAPVstDz7PO2QBDRYMBzMABBAAD6QACwsxCC88r6wAMg1qAA69OQQuAB88pwAJAhMD
Ewm4QS8PO7AAPwFYAR-vsAAYFz0UAA2wAAPMJR8prABCAZ5PJjyPJQAJ5j8EBAAXPQQAHzyoAAcf
ZaMAPgZnBAK7Kh8HrAA2FmF8AAywAAA9AB_PtAAuEx1lBS8PO7QAGxc9GAALtAAQQ1MAGg2BAAx6
Cg9xAS0CFjw4LQ8_uAAbL1EAA0cFFngSAAdDAAQEABw8BAABxUcPvAANDrUtD7kAFANqHQNFABYt
OAEEuQAVTx0AHnQHVhs9BAAcPAQAAB0WAtsFC4kABVgAD8YANQ1JAAAsCgb9UA-TAAMQdQUAEhAO
AAMEABs9BAAcPAQAA5wGH0XTACMfPtMAFBc9HAADSQAfK8oADACDFQK2UQqKBhs9BAAePFsAEwmF
UAzSAA8EAAkM2gAfPNoAJREPqAEWI2xDCOIAFy83ATj-O3RuTBILIgADBAAbPQQAHjywABBZ5gAd
AaEADwQACg-mADkB7woN4gAOJQAyHw8-AQ8ePaNOGz0EAB88KAIBAgsOD_cAGRRfQFQP6gA2EAfV
AR8R7wARH3mJTwMXPQQAHjw2ABIDXQQP5gAaE2_MAB8P0AFbMRkPP3Q5AYYGBxsAGz0EABo8NwAz
BA88ZT4HUhkPBAANAAEEF38QAA-jADYPQAwEARUlDaMAGz0EABo8MgARBdolEz6xDwN1Bg-eABQB
FgMTXxAAD_IAMQSvAgQnLRU-bgwirzsiVR4PMgAP3EUKBAQABBgAAxwMAc4DAaANFjcbAA_ZAw8G
LyEXHxgAD-YAMxQRnAADGw0fD_4AMxYDtAAChQcTGiobDjQKD89YDx9f8gA4AHYCE89AAA-5ABQP
PEoDBAQABBgAAyFRFD2rRBM9Fx0P8QAZA-UAHj3dAg8EAAIfPQQAAB88BAABEa-UAgP4BgX2AA_a
AA0AyBYcPXkPGz0EAAxDCBILMwAkPT8PHx6vagAPBAAOHq9NBQ8EAAUfPQQAAB88BAABAXsFEi8N
AAZrEA_aAA0P-gEYEgqyBRM_wFsWFV0ADnEGD0hbDxc-EAAPBAAIHz0EAAAfPAQAAQX-AA--AUQE
AwIC_gAC-gIfEwMBJwx4AA8EAAEfPQQAAB88TQADEgW_HA8AARwSRftOBRIAB2gABAQAHDxGGAEB
Dw-7AHkP9wEfEF-3ADwWDz2JABs9BAAaPDcAExV1Cg-4AIMOAzUP7gMpBChSCeUAD-EACA09AA-x
AE8OjwAP8QAQFzxnABc9FAAIWAwaGVsAD2cACA1CAAJGAA5PDQ89AAUMBAAfPPoACgReAB4_JxEP
BAALHy9mFB0P_wEuDksLD0AACgwEAB88BAABAQgBD2UABg9SBwsfPRMBAxJuixMN_iEDMgAEBAAd
PBwBDH4BDiABDwQADw6VCQ8EAAIfPQQABB88BAABDSQBD5kACQMwAQxNAB89MAEHAf4nERrbDBA9
sVMbPCsAFz0EABw8BAAAwiUFTAATLxUADz0BJQ7mBQ8EAAYfPQQABB88QQEuDwQADA9pAAIUL0kB
A-kLBHolFkAjAAs-ABc9FAAPTQEmDkUAD00BHx89BAAIHzxNAWgVCiJjFjgbAAs3ABc9FAAPRQEP
D10FCA5JAA9JAZgXPQQAGDwEABYvTkwWOhYABy4AFz0UAAhBBAEYEQFkJgVIABMvHgAPSQEpBEwA
A6MEDwQADR89BAAIHzxRARIOpQAPBAAWFz0EAB48VQEKVxAXPQQAHjyWABEvHxwGmgoTLwQAHw9Q
ARMOVgAHBAAPUAFLHwmpAAQPBAAjFz0EABw8xQAPVAEFHzzkAzkPUQAGD0sBTwKIYg2tAA5xAA8E
ABoPdQAGHy9TAR0HNzcHEgAOBAAPaAGNOAUPPmkAHw9sAYcTDXsOLw87cAFLBAQAD9wCYQWMAQ8E
ABgXPQgAFz0QAA9wAS0WTQ0ADwQAMA9xAA4PdwFPFgFdAAx7AQwQAAcEAA5RAA8oAAcEBAAcPFwA
GW8tCBKIDQADBAAONQANugATC31QLw87BAA2D3YADhYPswAvPA9MABMPBAABHzyQAQoIfAEXL6Mg
DwQAOBc9BAAYPAQACJgBApEAFowNAA81AAUM8hsDBg4Le3EPBAAsD3oADg_cAWEvPA8EADcfPQQA
ABg8BAAOnAERePQ0CRUACz0ABAgADxMxAR0jOgAPBAAtHj1yAA_kASIfPQQACB88BAAJBaQBCAQA
D6gBJB89FAAEDwQAAR88qAEBES_RAB2EZgEINQAECAANgBcMNQAPBAAtHj1tAA_bAeQXTwwAA48s
EVAOAAzwHghCAAQIAA7sBBJftxoCMTYPtQG9H0_7EAQLKgEPBAAVHz0UAAQPBAABCCAAJzwv5AAC
uAESfG0BC3EBFD0xAAcIAA3TOAKlGgs6AA8EAC0ePXIAD1MBBx8PQAADBAgADwQABR88WAANBAQA
Gw8EABcvDAAPBAAQHz0IAAgPBAAFHzxwAAEICAAPswEmEy8cKwNbHR4R4wAPBAAwHj1_AA8EAAAP
XwEEBzwAHz0EAAgfPFgADQQEAB8PAgEAHw8EAAMvPQ8cAA8ICAAPBAABABwAHz9wAAEZL4IBQSAP
PN-oBB88yAEKBAQAHDwEAAJGABYcxigTn5EiBB0ADvsADwQALg6NAA8EAAgXLwwAC0QABAgADwQA
BR88BAAJF08EAB8PBAAbHz0cAAwEBAAMEAAIGAAP9AASBeMBAmUDH0njAQIEBAAPXgAGAkYAFB9G
AAeIQg78AA8EAC4OhgAPBAAIFy8MAAtEAAQIAA8EAAEfPAQADRdPBAAfDwQAGw5kAA4cAB89EAAA
BBQAD-QAFiMvO5olD9gBLB8h1AEUFy8MAA8EABAbPQQAFzwIAC88D2QAGwhAAA8EAAEfPAQADRdP
BAAfDwQAGw9kAAUbPQQADxQABR889AAVFE9ifA-LAQwfPEUABQMNAhIKDgAfTz4ABBYvEAAPBAAR
Gz0EABc8CAAfPI4ACR4PBAAfPQQADB88BAANF08EAB8PBAAbFz0EAA8UAAEEBAAfPBQAAQ8EAB0U
T8sBH0_7GwQPWQAJES89ABI9CQAXLxkADAQADhwAD2UAChs9BAAXPAgAD2QAHR89BAAMHzwiAREE
BAAfDwQAFxs9BAAPGAAFHz0YAAQfPAQAHQQAAQ-OAXofPQQAAAggAA9kABUfPQQAFB88BAANE08E
AA7EAA8EAA4bPQQADxgABRs9GAAfPAQAJQ3SAQ9rBQQfPGkACQXWAQgRAB4PBAAPHAAOC2kAHz0E
AAAIIAAPBAAVHz0EABgfPAQADRNPBAAOyAAPBAAKHj0EAA4cAA8oAAUPBAAlFi_0ABE94gEO3gEP
RQATA3xAAdwwGgcbAB4PBAAOHAAPBAALHz0EAAAXPAgADwQAFR89BAAYHzwEAA0E6AEfDwQAHx49
BAAOHAAPKAAFDwQAJQRwATL-O4AJAA_9ACEAC0QvPc-GAQoPXQAeHz0EAAAXPAgADwQAFR89BAAY
HzwEAA0eT9wADwQAGR49BAAOHAAPKAAFDwQAKg-mATMfQeIBTgQEAB88BAAYHz0EABQfPAQAEQ-i
ASAbPQwADAQADhwADygABA8EACkUL4wmAE0AAq4QDo4BD_cBHw8EAAMPXQAeHz0EAAQfPAQAHB89
BAAUHzzAADwIBAAbPQwADAQADhgADyQAAA8EADEBX0QP5gEnEjmWMh8PJgEzHz0EAAgfPAQAHB89
BAAUHzwEAA4OzQMPBAAZCGgAHj0EAA4YAA8kAAEP7gE3EF3ZAx8S8wEpAaFAA3UqD-QBdB89BAAc
HzwEAFAIbAAfPQQAJB885gM6D_8BIxZDDQAP6gEkFz0IAA8EAAUfPAQAFB89BAAcHzwEAEAfPRAA
ABs9DAAPBAAVHzwEADUXLwgAA8t2H2DzASUBD1ID50sP_AFUD4MoDR89BAAMFz4MABc9OAAOXAAP
BAAnHz0QAAAbPQwADwQACRc8CAAPBABCEi8WExM9o5ofWAACIxZPwSQPBAIMD9IPDAj0AA8EAAUf
PAQAFB497AEPBAAOHzwEADwePRAADwQAGhc8CAAPBABOAZsJAZJ9DwQCJwdWEw--AWAbPQwADwQA
HR88BAA4Hz0UAAEPBAAUHjwIAA8EAE8CBwQWdhEAD-oBGQDSCwn7gw-6ATwfPAQADBs9DAAP-QMd
HzwEADgfPRQAAQ8EABQePAgADwQATwWeEQcEABw_JgYbD-IBE582lgUVAA-yAXgPBAARFzwEAAwQ
AA8EAB0fPRQAAQ8EABQXPAQADBAAD8cHGh8PFAALEj7qAQHlAw_2AQgP7wEFAo94AdiFB1RiD-QB
nAxAAB88BAAoFz0EAA4UAA8EAAcbPAQADhQADwQAFBsvqgEIDAAEBAAD8DkBSmEWLhcADgQADj8A
AhwsEj2QKwllFw-1ARwI6QAPBAABHzwEAAwbPQwADwQAIQhAAB88BAAoFz0EAAwQAA8EAAUePAQA
DhgADwQAFRsvqgEIDAAPzwUJDdADDOcBA0WkHy-nAbIPBAAlFz0IAA8EAB0fPAQAORcvpgEeb_8B
AWgNED75ogEWAA-oAREs7zuWph8r6wFODyY1BRs9DAAPBAAhHzwEACwXPQgADwQADRc8BAAMEAAP
6wE6CLEBBBwAAk51EjusZAUaAA8EAAEdT85HBdcDHy3sAU4PBAARHz0EACQXPAQADBAADwQAERc9
CAAEBAAXPgwAFz0kAA-EASYfDyQAEB9PqgEABBwAAyYXAVmSFiobAA8EAAEIPwACYUkP5QEwHz0E
AAgfPAQAGB89BAAcBIkBFzwEAAwQAA8EABEfPQQAFB88BAAlFy8MAA8kAAkfT6YBAAQcAAPlARZW
FgAPrgEJAw2qAdhxA_QrD90BnAQEAAxAABs8BAAOFAAOIAAPBAARHzydAQ0bDwQADKUBDxkRBA-R
AQgOi5cPzAEEFAiUNgqbVg-LAWEfPQQAOBs8BAAOFAAOIAAPBAANHzzDAQkEBAAPMAEULzxv7wEI
AydUFmYSAA-EAQsvCQ85CS4fPQQACB88BAAICE0JHz0EADgXPAQADxQAAQgcAAQIAA8EAA0fPAQA
BQS8AR-PJAAMH29UAQQP2wwOGG_vOy8POyUACw8EAAgfPQQABB88BAAYEz22AR89BAAwFzwEAA8U
AAEMHAAPBAARHzyCAQkPpgErAcI7FkwSAA8EAAEGqwESIQUIDM1hLjwPYAAPBAAJHz0EAAQfPAQA
GB89BAA4D1QAAR88BAAAHz0EABQfPIgBBQuwAQ8sAAITLzY8HG8eEi7vO9FOD1cDjg8EADUPVAAB
HzwEAAAbPQQADxQAAQQYAA97AQIPUwMNF0_fARIvLlMlPW9BoxZaKQAPngHdHz0UAAAIBAAePQQA
DxgACg0EAB8vngEUF49EARYvvJASBBIAD5sBDwLwhy88DykACQ8EAA8fPQQAAB88BAAYD5QGMRc8
BAAfPQQAABc8BAAePQQADxgACg0EAB8vnwEIG4_XAQ8UpAkkPI_GAR9PbgECD54BCwMEAB89BAAA
Fz8gAA8EAA0fPQQAMA5MAA8kAAQPGAAgDQQABHoBAiYWC04BHI_rDgDOYBGPrxIDp7kPTAMFFC9z
chMPDQAfD5QBBADyYggQAA8EAAQfPQQAAB88BAAYGz0EAA8iAyEPTAAFGzwMAAgQAA8YABUNBAAf
L5gBARevlAEDLXIfZoQBBwWGwB4vgAEPFAMhBDQBHzwEABwfPQQASB88IAAQBAQAFz0EAB88BAAB
Ey8EAAJyEwP0AgFeRjL-O4oSAA9oARIEGQAfD4AELx88BAAcHz0EAEgfPBwADAwEAA8cAAYVT2gB
AkyMARUABCUMDz0TAxNP2x4nPE8RAB8PYAHTHzwEAAEPIAAFGG9cAR_PuwIFGE_OMQ9LATAfPAQA
IB89BABIHzwYAAUPBAAZBEsBFM_6DhyPm08Sbz4BAb4ZBRUAFy8MAA9PAVgePN4GDwQATh88TwEh
BJoCHT5LAQNlLAvplA9QAQEEDQcfDwQACxc9BAAfPAQAJA9UAVkfPAQADB89VAEHFMifAhY-NgET
LyYADzoBbA8EAEUbPAwADwQACQ86AQgBaLsShJEPBR8hDjsBD0MB-wpDaw8935KcJz3vIgAPBAAR
F48MAA96AAgEBAAfPAQAJB89BABMGzwMAA8EAAkPSgEIAVpaEEGSAh4LJGYPTAEdHz58AAQEBAAf
PAQAJB49BAAPIwU6CGgAHzwEAB0YbzkNAy2kFpUfAA8EAAAfPt0DKB88BAAkHz0EAEwfPAQAKRpv
diAQRY8CFBIOAAZeqQ5fAg9IASMOSAAPBAAbHz0EAEQfPEgBMxsHRAEDsSMSkUgBA0wBDgQADzoK
Ew_sAAMPWAAQC0AADwQAPR88PAEzFS8KBRwi3SYC1AMfPTgBiBc_DAAPBAARHzw4ATcUS64DGCRz
AhNTW4cvDzsEAAcPvwcFDzQBGBc-DAAORAAPBAA3Hzw0ATsBQy0VK8IjFABDAQtgzg-tBCAPbQIt
CEQADwQAMQhUAB88BAApAAV_AMEaADTKED0EAABgOAJTzy8POy8Bkg_kAw0XPAQADBAAD5wAGgA0
PQIoEAwAYw8fAWEISAAPBAApFzwEAAwQAA8fARwVbIjWPiAPPLEjDz4MHx89KAEGD5AAEAtEAA8E
ACUbPAQADhQABwQAHy8MSREBHn0DGMoUMaMEE0A8AS8PO1oCJh89ngAFHy_aABALRAAPBAAlHzyt
BRUfDwQACAAfXhI_okATPatAAFgtAipeJA896A8L7hoPZAIgDzIBDhcvFAAOPAAPBAAuFzwEAAwQ
AA8uARYApAAB-zM4-zs06oIxGg89fKQBPycXbzEADy0BcA4UAA_TDg8XPAQADBAADy0BGgImNxRf
XgIWth4ADxoBHBc_jgAfPW4ABQQEAB8PBAADGz0EAA4UAA8EAA8XPAQADBAALzwvQwIWEm2okAC7
dSE9r90VDtAsDzUCOg6XAA04AB49FAAPBAAWHzwIAAAPgAAVBxcBEmerYjb-O7UaAA8SASwePGoA
D0IBDh49FAAPBAAWHzwIAAAPCgEgFBNLcRAhHQIQL8AGFo4kAA8UAWAePBQADwQAFh88CAAAD2IH
DQmcAAdCrRKLSJ0TPqFFA2pyDxUBoAQEABc8CAAPFQEeIg87UgwDijwW-4XdDVMADw8BGA8jEBkf
PRQAAQ8EACQXPAgADyACIBEXSU0QPlOnED3G0yU9D4AjDycCHB8PqAMEDz8RJAgEAB89BAAkFzwI
AA8cASARjVGYAUUcBEsHDgQADyoCGw2OAA8KATwEjQgMBAAXPAgADwoBFiVvO7LhEH0FABZSGwAP
AwGIDwQABQRAAA8DASABNB4a-5uND-sA1BWjJq0WFRsAD-8AZAREAA8EAB0fPP8AJwEiBgHXmjJJ
Dz-IxBZyJAAPCAHRBL8jBXbpHD-Tcw8DASEfPAMBdB8_AwENAgoGE-9-Jw-yALAP9QEKE0_8lwQl
nwo-Cw9PAAYPUwAEHz3vAJMBBqISDeQDEz5qqxBQCgAOpEYP-gAmD7MgHB89BAAgHzz6AB8BxecQ
mgUADnZRD_sArhMv5wARj_sAEH3WARUfeOEeSgKGD-QAHAxsAB4_JAAPBAAKHz0EACAfPJwACR0v
9AARnZUAAb9gJj6-yQgeDzsRD-0AHg-xAXEF-48G8gASbeAAAUUwAAQAAgiZEj0g2QU5AA-xAKoV
j_0AAW1TGLNTFRE89gAvPA-oALEBgA4w-zufuAMBwkAUCMoBATvWEhH7AR8P4wCrECXLAAGbQQGb
BBVcnBoeHKWVD0AIAg-bAIAEfAADaxsRk90XIj9PsI4CJBkHS3AQDBMAFgE6AA-qAFAXPMIADwQA
FR88fAAJEk-wcgS4uRGMpp0TPwHtEhSvAx8P4ACkFW8LDQUQsxKC41MjPc8coR8P2wAPHz7bADgX
PLcADwQABQgoAB882wANAt8AGAtJBRP6IwcPugEtHi_DBA8EABUfPQQADAgoAB88BAAFE29jATb-
Ow6vIwGsmQFjgRE9CTMDQwcPSQAKD_kASATFAA8EAAUePAQAD_kACRUQaewTieyUBCMIHw-gAGcX
PMwAGz0EAB884AAVAZEMA5Q3Af_jAbySEgdsqg-iAK4TD6YBAIQAA6AsEi_IDgN4ERJSnQ0P6QC2
FS-XAQGOAxCXBQAfTt8ARxcvDAAPBAAIFz0IAAgEAB882wAjAQqtHv_2AR891wBcCHgACAQAHzwE
ABkIbAATb9z7AllBC94AHzzeAGQXPNoAFz0UAA8EACIC4gAv-z-eAHoEBAAP3gAuAwwPMY8PPVIF
AugZExHYWA-xABwfPvEAkSUvOyUuEn-iGwIsHz9IDz3cAS0TbwgAGw8EAA4UAA-vADofPWwABQLr
ABQfJiIBwRoSKWgMEj6aCxZqLQAP9QApHw8EAAIOQAIP9QA4KzwvCAAG8QABSA4u-yNtCw-fALEC
4wAQAdABEpmqHgYHqw-oAEkOIAAP3ABFEwVrGhIvgR8QP48WAFcAGT2Z6RMvCAAP5AA5H4-gAEQV
T9wAM9EPPg28A-dACCcAD8sAmxNfQv4BkRIJSUAELAAPJgYFD9AAIQ5GBg-MACMTLxwBAAgAAyBW
EjVVCwMXDhQGCQAHdkUALQAfD6EBPAjRAB8vzQAgE2-JAAPFADEzDzyBCQOOAQN0tw9hAAQPwQAu
ARQQLw87BAAbE28AbwIhGBY9VKMG0cQPrABBFA9tEy8PO7AAHxNvrgEBRgcRb0oAExETJALpEh-I
uQALF_8MAA_1ABkvjzveOyMGsAAByBsTN80JAroAH7SsACcTD1gAHw8EAAQOEQIPrQAaFtuFCSc8
L3MAD58AYhOvVQATL_cERj7-O9oSAB8PlwBxAnwCFAsGswHsAQEOGAHHnBJmJQAfD6oAFAgEAA_u
ADITz6YAA5kAL-81kABsAgvEAQUAEqgCGyM9r6MAHw_UAF0TL-wCM-8777IFHS9DAB8BhABIFU_A
AAHkDRIZhaEhPm9IAhFoO9MBAYsBfgQOmwAfA5cATjNlDz_QHwWKBw8IsgAPigBLAyf6EHUFABIM
DTsCCTsaU4oACcYJD4YAHRKvfisrPA8EABUvhQAU-AEBH1V3ADgCD4AeAzEAE0--AlP-O3sPPjDD
DXkAD0cHCBdPDAAMBAAJcgEZb20AEFvwARSD0wQSNk4ZH091ACEMIwEUPREAGY9xABVFLQUTXl0C
Ew8oAA9qACQaCWYAAUzhO-871h8AGw9AAA9QABID5A0S4BIAD0MAFxQLPwAQZz8AG-8fDhdPPAAV
TzQAEA0FABv-v0EXTyMABisAATYEIP9vBgAWCXsAF08kABFPKAAv-7kaAAY1Eg89c0MbT8QAAiMA
AQgW8QTPLGZsYWdzPTAscGFuX3g9LTgxCgD-D3k9LTI5LHpvb209MX0se2JtcD1weHUAQyAQEATw
8DUA-1wxKCgE-7MBlwQDJtAYHXIDEhTOBQKGCwNpAgHUIBIC4QQCAwwUDPkBEzDAiyRfO5CRAUAf
ExfWAwAgBwODshIRQAAAEEcTj1ixKD87sAUFSkMB864VF0cAFQwhGxMq-yUkvzt-AAUpIxIHWgAB
ZwABjgYB5gAEUAACxAATP9dIAbIEAEoHAfMAE1-sszv-OyRNARMwSwESMEkBHDZJARSv1qcTDwEM
BXQAIW87bgACcwMBIwACfAADDgACdAEFLgAFSAAD7AASEl8ZBiEAIn879AADqx80Bg89sAEABAAG
yEATFTkBFJ_aCAD3ACE9X4kAE1AFAQC4AwMhARMI5r8V364AFEdoABYN4bcBhgASL3IBEj0_ABUe
GgIUMdoAMwAPPQUiEi4uABF-UQAUDUQAEQ7YDATiAB8BagEcAhMNEjF_AhSP1wQlfzvIAgGA2hII
zQEB_gADkAIDJwYUPbMGEQgJAAPYABIEJwAZf0QBEBCTAhMvkwIWEBoABb4ABBQBAZcKFb9nADQE
DzyXAgLDCgGWCBMLhCABRQEGRwASBXYAKW87owIVILYBFQsqAQJpAwSTAxBbBQASIVIDJT87KgAS
BTYCBCcoEgtsASWfOxcAHyBwARwjjzt8ACUvO_sBEgIuAQGdHhN-hwEUzw0EBeAABWMBACK5AZcY
ARsBAZUAAwoAFQmBAhUcHgAVDPgCEy0uAgBxAAFjAQOlBBICPhEB9wATz3oBJb87SwASAPQAE89S
ASTfO48AEAUnAAhnBAO7BAR5AwAMAACFAAI6AyJ-O38AIjzfrzkBowEDrgMVA2EBFQVrLBUGv5AU
BKkBEwr4Ai_vO3UBHAPNARRvhgARIjtCBOEABWABASsCEAJlABUeTgEVMH4DExJEAgAZBAMYPxKD
cQUBCwEHv0MDBLoBvx0DHAARDBMAAkXuAVMBE39lAQd6ABM0SAQDfwATLDABAzgkEB8YAg-4AB4Z
bEsEQwEPPJ9XCgF0AAJ9ABgT6iIB4TASARsAJb87BwEUC9MAEEIgABUOVgUTAcQBAt0AFJEQAQXN
AxUAAgEVM9QGAZICEDowABcAiAAHbQATNgkBE79X_ATBAwHBAh8uBAEeExk8AiVPOxUDAVgCFQZs
AgGhADMPDz1-ARIdnQIlrztPBgUSAxIRSwEnDz0nBwM1ARQ6JAAEUAMibztvATT-Oy5NABUCPgEV
LVMCFQyWABUckwIVCToDFQseABI0_gMjzzsLBACEAAE_AQBDAAFDDSSPO7oFFERSBBUCZQQfGjgB
HgGHIAOMPxSf7QAC4wAB_wQTBi0GBjMFEgO1KARUBRUF3wAVBUAIFAFDABkWwgADtwUKFwAl3zsC
ARJGNwAA4gADDwETMlUCC3ECA3oGFJ8mAQpSAAO90hUmigMUIDIBEgJ3BQOPRx8eLQEZ8AgdHQTw
LPkJMAkH-AELDBsKCDAJDPoFCQcAXwr7AwoJEAAJUksZSxlLEwCSSgkcCSoJHAlKGgCSKwk8CQsJ
PAkrHgB0OglMCUwJOhwAFKwYADRKCYwyAF1LCWwJSxYAcjsJPAk8CTsYAJJaCRwJCgkcCVocAFhb
GSsZW5EAGwuhAAUQABILEACvCvkGCDAJ_AjwLCEBCx41IQHyC-4JMA4H-xEBDxAPER8QDw8PDTAO
DxH-DwUOCgBfLw8PEB8EAAIDIQAGEQAKBAAfLyEAFgRjALMPDy4NDxAdDB0MHRoAli0MHQwNDhsO
DBUAEQsLALYMDhsODQwdDC0OChMAJSsOEgACOQAROyQAHx0SAAQRHRIAKUsORwAEIwAGRwBJDjsO
HUYAAmgACEYAWR0OGw4dRwALoQARLRMAFS42ABIMEQArHQxIAAMCAAFIAC0MHRIAIP0FBwB-Df4G
CjAO_u0BISH-E_4B8gUWAQ8VDxYfFQ8UDxIwDg8W-xQFDgoAXy8UDxUfBAACAyEABhEACgQAFC8h
ABcPFQAMBAAvDxRnAB9ATg0PFQABAhgAEQ0wASJLDqsBIg8SXAE4DmsOSAFCDosODTIBEAswADEO
iw4uAAKJAU8NDosOLAAVDFkACi8CADAAWB0MTgwdMgAGAgAPxAEDAzYABAIAATgADg4CD_oBMBEY
6gHyBRsBDxoPGx8aDxkPFzAODxv-GQUOCgBPDxkPGgQAEw8xAGhhLg0PGg0MAgADJAADDgABhQMI
GgAUCw0AJEsOCgACbgEPFgAHPB5LHhQAAQ4CCBIAPw6rDhAAGnsNDisOCw4rRgBsDQw_Cz4MFAAA
DgASCyoADhoAEy4IAAIYAC4MDQIADDIACAIADzQACw9eAjARHV4C-AUgAQ8fDyAfHw8eDxwwDg8g
-x4FDgoAWS8eHx8fBABDDx8PHh0AFw8VACUOHw0AAx4AQ58eDp0LAKAtHx8dHA0OHB0cNAMCFAAQ
DQ4AAEIBAQgAABQAYguNDgsOjYsDchwdHA4LDgwxAAEpARAcQgARK0QAAREAVH0OKw59LQAAIgIJ
KwAB6gMDKgBebQ5LDm0qAA9VAAEyjS6N0wMiHB0CAAcpAAMCAAeDAQ_KATARIooB8gUlAQ8kDyUf
JA8jDyEwDg8l-yMFDgoATx8jDyQEAAEjLyMhABcvFQAKBAADIQAVDxEADgQALw8jZwAdMg8jPgkA
D2QABF8OLyUOD2IACQEhAB8kYAACEQ8_AAQbAA9hAAIGPgBjHg0fIw0MHwAyHA0cUgQANAIhDSwW
AJALLA0MDjsuGw4dAADEATEMDRwiBDEcDQwQABAcEABRaw4cDSwPABAsDwBISw4MDTAAWRwNTg0c
MgAEAgABNQAQDTUABQIABzYABAIAATgALQ0cOAAS-EACDzkCKBEnOQL8BSoBDykPKh8pDygPJjAO
Dyr-KAUOCgBfHygPKQ8EAAwjHygtAG_fKA8mnyg6AAcXJgwADzoAGVcmDyoPJhAACDoAIo8oHwAf
jz4ABCAmLzwADzoAAZhfKB8mTyofJl86AG8vJo8qLyYmAA0eD2AAD5oAHw7YAA9MATIfKToADR8p
OgAGBfcBBgoAMCj_BggAH-1nAiIRLGcC8gUvAQ8uDy8fLg8tDyswDg8v-y0FDgoATw8tDy4EABMD
MQAVHxEADwQABy8fLV4AMyZPKwwAD1YABGYfK08vHysQAA5KAF8rjy8PK0IABSUrrx0ADDoAoCsf
Lx8rLy8fKx8jAA8_AAMJIwAPRgAmIk8vBAAPQgADEC48ADUvKx-nAA5CAAIEAAJEAAYQAA5KAAZv
AAYQAA9OAAYnDy8EAA9WAA4PrAEEBREADwQAAQ9WABAOBAAPXgAqFS75Al8t-gYPK1UDJADVEEYM
_wUKARAPBwARMrosWggAMgwKDAoAE9oIADhajFopACo6rB8ABjEAKbosKQAPBwAED5kQN1MPEf8Q
BZQQFRCUEA8KABZvnw8PEZ8PDQAfVA8PDxF-EQATfxEADxUADzVPDx8VAAIEADYfEU8dAAEKEQUd
AAAMAAcdABM-GQAWPxUADtIADwoAFjAP-gYIAB-9JBAmUw8W-xUFHxAVFR8QDwoAFm_fFA8WnxQN
AAFWbxRvFm8NAFoPFk8UDxEAWA8ULxYPFQATTxEAWi8ULxZPKgAaTzsAFs8NAB4-gAAOjQAOuwAP
CgAMMBT_BggAH-2SDyZTDxv-GgWNDxUajQ8PCgAgpV8ZPxsPGT8bXxkRAEEPGx8ZRQ8BCAAJGQAz
DxkfBAALGQAabxEAC1QAE49QAB_PEQAXDUQADr0ADwoAFjAZ-gYIAB-9og4mUw8g-x8FnQ4VH5MO
DwoAIKVfHj8gDx4-IF8eEQBADyAfHsEOAggACRkAUw8eHyAPCAAJGQBUPx4PII8RAG9PHq8gTx5r
AAA_jyBfFwBefx5PIH8XAA8KAB4wHv4GCAAf-WwOJlMPJf8kBWcOFSRnDg8KACBlXyM-Ja8jDQAB
4Q0KEQA6DyMfEQAW3w0AOE8lnxoAES8vADovJV9AAAoEABxfMgAaLxUAFo8NAA6xAA8KABYwI-4G
CAAf-ZUNJn4PKv8pBQ8ojwsPCgATRJ8oDyr7C_YpXygvKg8oDyoPKC8qXxUAABEACgQACR0AEy8E
AAcVABaPDQALYQAfjzwADgZmAAQEAB9foAAKCWEADuMADgoAD64MO3sPL-8uBQ8tsAkPCgA0ZX8t
Ty9-LQ0AWg8vLy0PEQATDwQACxUAGi8RAC6-LVEADnIADwoAEg_aCkwLqxoPEAB9D6IKQw82Gw0H
EQAOFRsPIQAMD2MADg_EAP-kD-0LTg_1Gw0HEQAPHBwDJxUPFQAOHBwPZwD--xoPkQ1OLw8ZvBwV
DzEA----aQ8nEFgPxB4JFh-EHggEAA9EAP9TD9YQTi8fI9YeCxQk1h4OBAADIQAIyx4MBAAE2x4F
EQAPZwD--wsPYBJOLw8oBAAVHw47AP--EQ_FE0UvDy1wHRwPzh0TD14A----GA8kFjHzJ1Qo8AgY
KxjwBBgbKhsY8AAYG2obGLAYG6obGHAYG_obGDAYG-oDGxgQCAtqGUoZagsIEAgLWoUxEVoOAHBK
CTwJCgk8SzEBDgAAgzGRSgkIIAgLOgmsjTEkCAtrMQA8ABBsWTEQQB4AEIweABBQCgAAfjECDAAT
Sn0x9QNKCQhgCAtKGSoZSgkIcAgL_gEHAP8BgAgL6gkIkAj5AQig_AHwTfQAHXI1bvAEHi8RZDHw
DR7wAB4fEW8PHxAfDcAOHxGvDw8QDg8NoA4PEe-NExCAVRbwCQ8BDg8NcA4PEV8PLn0ODw1gDg8R
bQ4cDgwA8AFQDgx9DhwObQ4LQA4MjQ4sCgAQMBQAHDwKAFMPEG0OTBUAUG0OPA59CgAYCgoAMCwO
jUcAEgpcAEMLUA4KWwD-HGALCn0uXQ4LcAsO-QEOC4ALDu0OC6ALHq0eC8AbHm0eG-AAG24b8ARr
8DUOAR2CNI8T8AMOTxaFMPABDvABDg8WjxQPFQ7gDg8WrwkAIMAOzR_ADxUOoA4PFu8JABCAlhRw
FAEPFQ5gDhwgkU5tDxUOQA4PFuEAIA8VBhJgDF0ObA5d2QBvDE0OjA5NCgAFLw8VFQAAFQo9ABMK
NAFRQAsObU4KAQkCAbAOzQ4LwAsOrQ4L4G0svwvwAQuOC-ADi-A0CAEdUBovGPAJ_w6wGw8aDvAH
Dg8bLxkKAFEFDg8bTwoAIQMOox8RGiQBIBuPCgBQ4A4PG68JABHAJgBALk0PGiYBUBtNDiwODAAQ
gNQAYEwOTQsOYBEB8AxMDl0LDkAODF0eTB5dCw4gDgtdDowOXQ4PFxApAIOsDk0OChAOCwoAsCAK
Dj0OrA49DgpACgBQLA4MDiwOAPAVYAoOPT4MPj0OCoAKDl0ODA5dDgqgCg5NLk0OCsAKDq0OCuAK
eS0w8AEKKS0w8AMKTgD-AvAFCg4tDgrwBwouCvAJKvAaIQEdgk3-HQGgDs8gZi4ABAIwIP8edC4h
HGALAGEDDg8cUA5UHxONCwAfjQoAAFF9DgwOfQwAEgwLABkLCgASbUIDCQoAATkBDwoADyYPHzMA
IX0uTwA1Cv0DBwAyYA4KOgJf-gELoPs4BCBgNy8i8Age2y3BDyQe8AQeHyUvIx8kQQQgJW8KACCw
HiMfgB8kHnAeHyXvCQCTQA4fJf8jAw8kzg5SJX8jPo06DBIl7wMhDyErAzMsDp0CAzUsDq0KADU9
Hk0MADUtDgwmAzI8LhwMACYPJD0DDTMDUTAOCn1OWwT0BA0O-QMeC0AbHu0eG3AbHq0eG7A2BO8e
LR4b8AQbLhvwCCvwN8QMOg8KAAtAbyg-Ku4sAAoAB50eQ28oDl0PADNdDG0MAEMMTQyN5gAGCgBf
PQytDj0KAAYPMgABAlEACgoAIm1rkQUv-QUHAAZ-Df4GCzAO_z4LPQ8KAAtAby0-L6YrAAoAAxMA
g18tDy9vLQ5dDwACxAAADAAO7QAOFQELCgAPHwFuoR8cBGD5AcAJB6wOOvECsAkM6gkIoAkMGssa
CQiQCQzpB-APCQwa6xoJCHAJDPoDCQhgCQwa_wEaCQhQCQxaGUoZRwjRCQwaOwkcCSsJHAk7Gkke
B48IESAeAACQCAAcAGAQCQtaCax9CPEEAAkLGlsJjAlbGgkICQuKCWwJihUAEQoVABEKKwARapQI
EGpFAAAYAFEcCQsJHBwAgDAJC3oZKhl6fQADvx4SUL8eEGAQACABCrAAEAuwAGCACQsK6wrOAAG3
CCCgCbcIr7AJCvkACMD4AWAuAR12-gHADgevERs6FLCkCB_gGjoAED8ZAB_Q8TkGA9oIDDYABcQc
AO0IFw8VAA0_ABlgWwAULgkAAz8AG1A-AEgOHxEOEAAQDyUAG0CeACEPDycACmgAGzCwHUsOLxEO
SABkIA4PET8PFQAtDj9EABwQRAA0PxEODAABrwBHAA4PEEIAOU8RDkcBCVAAAXUAGj-PAAVFAB8P
JwAKD40AAC8OL0oAABsgcQAMPgEOGQELJQATP18BC7cAAtE7Ei21CjM9DB0CABA9HAcH9zhILQ4L
cCAASB0OC4AgAEkNDguQTTn-AQ4LoA4M7Q4LsA4N-gALwPvcAh8h-xPdAhYWCjsRsGwKQw4PEqCi
OggEAAGcHB_QGQAFH4AZAAAB8xwfcBkABR9gGQACA08AF1AdAChOHxoAF0AaADMOTxYsHQFSABYw
DQA1bxYOFwAVIDIAUQ6PFg4PCgADTQAWEDIADBsAFQAbACEPFR0ABmgADxoABwA1AAdGABePhgAX
EBsAER_hACgPFaMAAw0AD9UACABAAAAMPBEtDDwQQKw1FC0CAABxCQoQACRgDgwAA1wCBw4AF4As
AAFYAgcOAA9WAi4RGFYCFht2O1CwDg8b77QaE6DgCx8PBAAAEC8hAB_QNDsSUQ4PF4AO4ysvGg8E
AAgQHykAH3ApABUdYJwABHo7Xy0ODxdQeDsGEEAXPQpiOwT4PA0WABAgID0IeDsQLXoMAQoAB3o7
AC85FABAAANeOwA_AA8TAAASAAoABhQAEQ1RABsthzsQLXsAKQwdhzsJpQAJhzsxHQ4KXAIPhzsA
E1BcAAcCAEctDgpgSAAGRAAfcBYAAgF6AgsCADoOCpBYADEtDgqGAhEKhgI-CsD6hgIgER2GAhYg
njtQsA4PIO9BGxKgRA1NDg8ckJ07A4EbAGcNBhUAAgQAEC8ZABZwaw0AgA0wHQ8f4DojDh2AOwBr
DSktHKc7c0AODyCdDgvHOxIMKgACsjsBlwEAVT8GqTshHB3BAVGdDisOnd8BFz1eOwMFAiQcHYI7
IRwtJABSjQ5LDo35AQW2OxE98wEmDQwsAAGFO2IMjQ4rDo3hAQBIACIuDXQAFlCvOxE90QEh-QPC
AQB-AAN6ABOAMwACMQBfkA4M-QGnATARIqcBFiW7O1CwDg8l7-IZE6CzOhkvBABPDg8hkBkABROA
BDsNGQAfcBkABR9gSwACAx0AF1AdAGAfIz4NDyQgBWAPIUAODyUsBVIOKw4dDBMAAcFAQi0OKw5E
BQDXAQBSBQC5AQNaBQGfAQYUAEIdHi0MvQEFSgAiDgtFABMKFAAAdzsXDCYAAR8EAEAAAekBACIA
MmsOHREAEyARABNLMQACjwBCDA1ODRAAEkAQAAICAATHAwcQAAkrBikKcA4AKIAOKgAjkA4MAAEO
AA-_AS4RJ-4BFiqAO1CwDg8q75oOHqC1OQ6tORCQBQ9xKAEODyaADnMtLykPBAAEEC8vABNwjjoB
ijofYFA6GRhQijoeQGwAD8Q6AiYvKM0tAR8AAT4AHiB4AA9AOwIFfABTEA4PKX9_OxB-EQBEAA4P
KYAABKg7BXAAQw4PKY8tABSPLQAPbwAeE6_xABOvsQAOBhsP8wAECQobI68oQgAfQIQABAcMAAlr
ARUpawEvYA5_GxgRcOoQEgMOAg5xAA89AgASKT0CQaAODyl1AhCwthtfAA8mwP3MAiARLMwCFi-l
O1CwDg8v70cQHqBTOQ6NGB6Q-zkPhRgDH4ApABIDLQAecM45DwwZAx9gTToRH1D5OxEcQFYZB-07
BSUAGDBvAAcBPAFnABogxRkNvzsFKQAcEAsBDw08AgNzAB4A7hkPWgACBTEADEsaDSQ8A4YAGwAp
AAwsPAivAAyCAAGGAB1PfgADggAeIDEADTw8CFMBCrAAD0A8CBQfqQEP8wERBREADwQADwJJAh8u
nwIZDLQADQQAEx-1Ai8uH0MDDw93ABRBoA4PLpoDELDHGz8ADyvxAyEASBMgDOtFEwBiEhKgbxID
dhISgIwSA5MSEmCqEgOxEmFACQvKLGrTEkLKDAoM7RJB_gAMegITMXqMehYTIPoLJhMiaqwkEwUf
ADDaDAoKABYgRAAh_gdTAAdhABlgfQAZgJkADw8TMTQPEe8KExQQChMSEK4bFZAKABGACgASA9US
AwoAFWCjLxhQczyUQA4PEK8PDxGvYREFDQAAkxFUvw8PEb-DEQANABQPOAATACsAAjY8AzMADxQA
AQApAB9vmTwAFG9XAB9vmTwAFG_BABdfmTwUX6MAM-8PB7oABtEAAgoAH2D5AAAfgCEBABSgPgEQ
sK8wXwAPDcD9whEkNA8W770RFBW9EUIV-xQBrhEDCgARgAoAEgOQEQMKABVgRy4YUBc8YEAODxWv
FIccA34QVH8UbxZ-phATj7E8FI-UEBePsTwUjwQRF3_xPBN-MxETn7A8FJ8lAAA6ABbvRwA0Pxa-
ZQAJfwAFDQAZQLAAAgoAH2DYAAAfgAABABSgHQEQsDIvXwAPEsD92xAkNA8b79YQFBrWEEIa-xkB
vxADCgARgAoAEgOBEAMKABVgsisVUAoAU0AODxpvMDwibxnNKxAakjwXH8g8ARkAWyAODxp-yDwh
fxnFHAIZABRvEQARAJU8AlQAAZU8Qw4PGr9PABS-IQATrxEAFK9DAAkRAB8glwABM-8ZB7IADMYA
H2DuAAACAgEKFgEUoDMBELCzLF8ADxfA-doPJDQPIO-VDxQf1Q8VH9UPAwoAEYAKABIDtw8DCgAV
YDQrFVAKAFNADg8fb988I28eWSsbb988ARkAESCHPArfPAGTPBMQGQAA3zwQrxEAEQARABKvHgAB
agAVCxYAFo80ADP-HglXADCPHk9aEAJ9ADP-HgeYAAysAB9g1AAAH4D8AAAUoBkBELAbLF8ADxzA
-Z4PJEMPJe8kmQ8UJJkPQiT-IwGKDwMKABGACgASA2wPAwoAFWCzKRVQCgCjQA4PJG8jPyW-I9Qp
E2-2PAERAFEgDg8kf6o8MB8lzxEAExARANL-IwAODyEADg8kjyNPGwABDAAB1w8B9jwjjyMhAAJA
AAoEABh-TAATLwQAFH9yAFRvI48lb5AAM-8jB6cADLsAH2DjAAAfgAsBABSgKAEQsKkqXwAPIcD9
Gg8kNA8q7xUPFCkVDwOzDAa9DBWA9gwGAA0VYPQdGFBMPBFAAR4VL248BQMeEW8RAAoEABRv-A0X
f9I8Fn_RDiWPKo0OVc8oDyrPfQ4ljyp5Dg87AAQGZQAEBAAUf20AD58AAkWvKA8qSQ4G2AACCgAf
YAABAB6AKAEP5Q04NA8v7_ANJC7vTwoz-y0BggoCCgARgAoAIgMO5AoCCgAVYGweFVAKABFACgAT
B8ALAgoAAPcLVJ8tTy_fNQwTnyU9FJ9vDBOvIT0ABAATr6wME68kPRSvJQAANgAW30MAA1AAHyBx
AAAfQJkAAB9gwQAAHoDpAA9MC0QDkR4ETQsDkR4ETgsEkR4EUAtFGvsDGg0LECAQABIFex4h_gk-
CzEa_wd1HgBVCxAAMB4lBwofAABqHjj7BQpMCw9gHl0PUQsCCGYcBV4cJpAOEQAcH5wcH4A2AAAA
BAAjLw_NCgrOHAs_ACRgDg0AD0IABB9QQgAKBl4eDkYADGsAAEELDqkAC0oAAHsLBh4eD0oABB8Q
SgAMFC--Cw9KAAkObh4PTQAMDgYBD5sAJSYgDhEADy8BIh8-dQEND7sBDhQ--QEfLzsCJg95AgUf
D7MCDg8FDUwqLxQEACMPFBQMLy8UGQAAJoAOEQAnLxSCHSRwDg0ACxkAJGAODQAPTwAAJlAOEQAN
HQAmQA4RAA1XACQwDg0ADx0AACQgDg0AD1sABCYQDhEADyEAAiYADhEADmMACt8eDyAAAgBBAATK
Hg8hAAIeECEAD8UAFQ--AA0fQFsABgNzAS8PFK0BGg-fAQkfgE8AAgNDAg4ZAA9mDk8PPB8NHxo8
HxUfGjwfFQ8pABMfYJwACAmkACZQDhEAD6wAEh9AgwAQCYsAHzAxAB0fILwAEAnEACYQDhEAD8wA
Gh8AmwAYCaMADzgAJSYADhEAD6oAGh8QFAEdHiCjAA_nATwmQA4RAA-EABIeUMQAD7wAAx5giwAP
DwMsJoAOEQAPpAAKH5CkAAgvLxkxEVkPBiEFBxUACgYhB08RLh8eJwABqjwdUFkAB10AFUDnEC8w
DkAAAQNrAB8gYQAGA2UABkYRAF0RFT8bAApzABMfhxEPRwADA2wAFQBLAB8QugACNB8fP5MAHw_T
AAQeD8IRDsk9Dx8BCC0-HuQRHz-LAAEfgFkAAg8CElkfDzMhAR_QGQAFJIAODQALGQAkcA4NAAsZ
AB9gSwACAx0AH1AdAAkkQA4NAA8dAAAkMA4NAA8dAAAfIFcABgMhAB8QIQANJAAODQAPIQAEDiAA
D0EAFxQPgwAvLyMhAAgmIA4RAA--AAMPOQEdFA9zAS8vIx0ABCZgDhEADt8BDxECFRQPQwIuLyMZ
AA9YE00PMCASLw8oiCAQJIAODQAPtSAUD3sACQV-AB9gKQAQBS0AJlAOEQAPhwASJEAODQAPNQAY
HzCTABQFlwAfIDEAGAU1ACYQDhEAD58AGiQADg0ADz0AIA_qABwFrgAeADkAD_MASCQgDg0AD7cB
SR5AMQAPewI4JGAODQAPLwM5HoApAA-TAyUPPRZPLw8ttSAQClwWDw0hCQURIQp7Fi8PLQQAFQ2i
Fg5uAA92AAgKyRYvDy0EAB0DshYz-y0JyRYOfgAPhgAQAUIAEwtCAC8PLYUAKh4ghQAPAwEVJkAO
GwAPeQEcHmB2AA-nAQ0mgA4bAA9mAAcPwBc-MPsBwCQXoLAb6hmgG-oBGZAFAGCAG-oDGXAFAPMa
YBuKLIoZUBtqHCobahlAG1oLDGobWhkwGzoLDKobOhkgG0oLyglKGRAIAIMAG2oLqglqGQcA8AcA
G1oLqglaGRAbaguKCWoZIBtaC4oJQAACCADFQBtaiFoZUBv6BRlgdAAVgIgAv6Ab6hmwCwr5AcD5
tQMg8ggQAcD_AQ8PDw6wHu8PHw6gHv8PAR8OkAcAgoAe-w8DHw5wBwCSYB7-DwUfDlAe2yJSHw5A
Hp9SIhAODgAZMA4AESAOABMvDgAZEA4A8wwAHp8PDk0PDp0cHp0PEU0MnRwAHn0ObQx9HBAIAJMg
Hl0OjQxdHDAIAPADQB5djw1dHFAe-QUcYB79AxxwBQBggB79ARyQBQC-oB7tHLAODfwBwPwEASAR
FQQB8gIUDxOwHu8UHxOgHv8UAR8TkAcAgoAe-xQDHxNwBwDzM2Ae-xQFHxNQHo8ULxaPFB8TQB5-
FB8WLxQefR8TMB5dHxZtHl0fEyAeTQ8WDq0eTR8TEB49Du0MPRwAHk0O7QxNHAcAEwAXAIAQHk0c
rR8STfMAMBxtG-MAv30cLRt9HEAejSuN8gBFERryAPICGQ8YsB7vGR8YoB7-GQEfGJAHAIKAHv8Z
Ax8YcAcA8xFgHl8ZXxsODQ5fGR8YUB5PGQ2MDkwfGEAeTA6sC0wbMAgAkyAeXA6sC1wbEAgAgwAe
bA6sC2wbBwAbAB8AGCA-AEAPF0wbUADwAowKTBtQHlx7ClwbYB78AxtwBQBggB78ARuQBQCfoB7s
G7AODPsBtzMiER-zAPICHg8dsB7vHh8doB7-HgEfHZAHAIKAHv8eAx8dcAcAgmAe-x4FHx1QBwDx
CEAebx5fIA4NDm8eHx0wHl8eDYwOXB8d8QAQDtIAYEwOzA8cTPIA-ycLrApsGx58C4wKfBsAHnwL
bAp8GxAejAtMCowbIB6MCywKjBswHpwLDAqcG0AenAqcG1Ae-AXtAEARJO0A8gIjDyKwHu8jHyKg
Hv8jAR8ikAcAkIAe-yMDHyJwHmEgc48jHyJgHo9KIAAOACJQHkcgoA59HyJAHn0PJU0KADAwHm1e
PsNtHyIgHm0OjQxtHBAIAAC8A0ONDH0cBwAYAB8AsA8hbRwgHm0MbQtt2QIwDE0L2QL-BH0MLQt9
HFAejQwNC40cYB6NC43fAjsRKf8A8gIoDyewHu8oHyegHv8oAR8nkAcAgoAe-ygDHydwBwAgYB40
PgDeAfELKB8nUB5fKA1sDydcG0AebA5sC2wbMB5cDoywAl9sDowLbN8CDwInABMgNwATMEcA70Ae
XA5sC1wbUB5sbyZs8QFAES7yAPICLQ8ssB7vLR8soB7-LQEfLJAHAIKAHv8tAx8scAcAIGAeBz4A
8gC-LR8sUB5fLQ1sDyzyAEofK-IAPAAGP-EbNTwLDAvwBBxqG-AAHLoJwAzaCQigDCoXqgkIgAwq
J6oZCHAMKhfKCQhg1z1FOhkIUOh3VCoZCEAM0z1SGikIMAxhRgMLABKsCQDzAFoJjAkqKQgwC2oJ
bAkqORIAYRo5CDALWsg9VApJCEAL2HfwExo5CFALahkqGRpJCGDqSQhwGappCIAIGWp5CKAI6QjA
GKkJR19pGPAEaE9FDR447QARP6I9Qg8Q8ARXRvAC8AAfEb8PDw7ADxHfDw8ODaBdB-srF64PDg2A
DxEuJ64fDg1wDxEuFx4vDn4MDWAPEX4MGwxuHA1QC44MGwxeHA1AC54MKwxOLA0wC44MOwkAMX4M
SwkAMA8QfhMAETwTAAIJACAKfjcAQEwNQApSAFBOPA1QClIA-xUuTA1gniweTA1wHK5sDYANHG58
DaAN7A3AHawd8AAdbB3wBG33ACEBvDvwEw8V8AQfFm8UHxXwAB8WvxQPE8APFt8UDxMPEqAPFi8U
F64LADCADxb5AJATDxJwDxYuF84UAP8WYA8Wfk8TXh0PElAPFm4NTA1OHQ8SQAxuDWwNPi0LMAxe
DYwNLgkAAiAPFQoAIx49EwAACQAQCjcAUB5NC0AKSgDwES49C1AKfk0uTQtg7k0LcB2ubQuACx1u
fQugC_0LwButB0MebT1HD-cAExIbMkbwC-AEHxtvGR8a8AAfG78ZDxjADxvfGQ8YDxegzDkgF64L
ADCADxv3APINGA8XcA8bLhcuLxhuDQ8XYA8bfg0sDV4dDxdQDPkAQAtADH4JAADmAEpuHUwdAQFQ
Tg2sDR74ABAaCgAQDvgABAkA8AQKXg0sDQwNLA0OTQtACl49DD0e-AC-jg0MDT5NC2COLS4AAT4B
1zjwEw8f8AQfIG8eHx-wAB8gvx4PHcAPIN8eDx0PHKAPIC8eF64LAPAUgA8gLicuDx1uHQ8ccA8g
Lhc_DX4NDxxgDyCeDX4dDxxQDyCqAAAfADBADJ4KAADvAAUJABCOJgEICQAgDx8mARA_AQEECQAQ
CgkAKS5N_QFPDSwNLv0ARBIlDUYi8AQBRpDwAB8lvyMPIsAdZVAPIg8hoJ0HIBeuCwAwgA8l-QFg
Ig8hcA8l9ALwBCIPIWAPJX4-Im4dDyFQDyVuDSz7ABAh9AIyLA1_8wE0LA2OCQA0Ph0uCwAACDsA
DQB-DyReDTwtHPwCZgPARfAL8AQfKm8oHynwAB8qvygPJ8APKt8oDycPJqBwJyAXrgsAMIAPKvwB
8AAmbh8nDyZwDyouFz4PJn4aAHBgDyqeDyZ_GABCUA8qjsw1AScAEUAaAAEPAFEvJw8mMB4AAC42
E14PABJuXjYTPg8AEj6DNhIODwATKR4AKS4-PAASTg8AEylaACFeP2kAEyl4AAEeABFQHgAgTk_d
AL_eDT5PJw1wHH4NHi0FOQPbRfAC8AQfL28tHy7wAB8vvy0PLMAnJ1APLA8roGYnIBeuCwAwgA8v
OQLALA8rcA8vLhceTyteFwBCYA8vXvU0ED4cAFFQDy9OD980EC4PABFADwAAzTRhHi8sDyswDwAI
YzQPFwAiIi5O8zMABAAiDj8qABZeZDQSHhMAIi5_IgAhPj_JACIubg8AIS4-pwAnLm4INABbABBP
zQBffk0eTyySBjxAa-AEG3MIUBu6CcALcwgwCyoccwgwCyoscwgwCyoccwhQC1ocShxzCGALSgwZ
DCoEAMAZCEALSgw5DAoMOQxfCGQLSgxJDEkLABKpCQBCWgyJDHMIUwxpDCo5EgACcwggDDk_AAFz
CHIMGQwKDBkMcwg-HCoccwhCcG8Q8AQebw_KSnC9Dw7ADt0M0CTgLR8RrQwPDYAOLS8RrRw9JXAt
HxEdK30MZSX7D30LHAttHApQDo0LHAtdHApADp0LLAtNLAowDo0LPAkANH0LTAkASjwLTTwJAGEs
C01MCkBRACNNPFEA-xUtTApgnSsdTApwHK1sCoAKHG18CqAK7ArAGqwa8AAabBrwBGroACEQFegA
EhToABET6AAQEugAMBatDCMjUC0vFq0cRSNQLR8WzQxnI1B9TxZdHI0j8AFtDxZMC00cDxJADm0L
bAs9zQBfXQuMCy0JAAcoHTwJAAA2ABAd6ABQbQtMCy3oACB9S_YAH_3kAD4QGuQAEhnkABEY5AAQ
F_QAMButDM8fUC0vG60cASBwLR8bLSttDDUgAIQBEF3MAQCcABBNzAEFsQFKbRtMG_0AVE0LrAsd
CQAoDTwJAJBdCywLDAssCw3oAFJdOww7HdABnwwLPUwKYI0rLewAPhAf7AASHuwAER3sABAc7AAw
IK0MWB5wLS8gLQttHHwe0y0bPQt9DApgDp0LfRyVABJttgIwDAttzwAFCQAQjQ4BCQkAAA4BLD08
CQAaLc4BTwssCy3mAEQQJOYAEiPmABEi5gAQIeYAMCWtDH0cUC0vJa0cnxxQLR8lzQzBHFB9PyVt
HOccQG0PJSwBARAhqQBDLAt9LKUBFI0JADQ9Gy0LADQtCwy8Aj88Kxy_AmYQKewAEijsABEn7AAQ
JuwAMCqtDAkZMS0vKtIBHybSAREFwAEFxQJUPSuMKw0SACMtPCQAI008-wFBXTwKQEgAAYgEEJ2Y
BCBgnbwCX3AcfQsd5gA5EC7mABIt5gARLOYAECvmADAvrQz5FlAtLy_tHAwXcC0fLx1LXQxAFxBd
xAAA6AAQTYkDAOgAB4kDXxwbLBscDQAPM0wLTKkDZxscKxwbHdMCB9oBMW0LDAIAbx1MCmB9S4QF
PkBp8AQZ0A-QGfAAGRxqGxjACRyqC30uAMBNIYAJuE0ScAcAgA81UAkMShlKwlUQUJ2HAtMPQToJ
CA6shwLVDxE6SocFuocgDiANABSsCwADOVYgDiC9TQE6VgsWAAAcEAHtTREO-E0FPVYQHkp3IBkq
JU6wDlAIC-oCCB5QCAmXAP8XDnAICeoJCB6ACBmqGQgeoBgZahkYHsAOGGkYLvAADmgu8ARu8BcZ
AR4AVVYE-A8AGgIC-g8PVVYYPw81UFdWAj8PNTBZVgApCiALAAPzURAKxy0DUlYCFwAECwASCW9S
UwsKMA4JX1ZDGjAOCWQAQQpQCwlhVjEaUAtgVSEKcGFVIRqAZFYhGqAvUsAawAobbhsq8AAKayo_
Ag8lAR8gbxMmAQMrEAEmAQEtEGEfEsAOHxZtVgG6KiMW7-UqAGZWAhgrAwoAASUBAXJWAmUrEhb_
UwAZAAUDUwC4KwRLVjUPNSAMABkKCwAvDxUXAAITCUdTACgBAlwAASgBI21OJgEv-QElAU8QGCUB
A1kQASUBAVsQUh8XwA4fblYCwEoT7_InEhvTOABgSnFvGS5tDg8XJgESGw5VJg8XJFUBJQEDKwIT
MIdWDAEBEgx0VgALACYPGgwABxcAIwlNjFYSTScBVE0_DD5NTwIByFUAKQE-bS5tKgFPEB0qAQOD
EAEqAQGFEKIfHMAOHyCvHg8ffSYCbUkASklCfx4Ofc0mISB9CgAvDzWeVgMDdQMRDBkABQsAAk8C
MX0OLOUACQsAAH1WHkyOAxQJCwALTwICzwMPKAFWECIoARQlu1YTALFWQB8hwA6yViIPJNUkIyXv
ECUSJUA4FXAKAAEnAVIlbyM_fYAlISVd_QAAGQAFv1YmDyHAVgN3AwPCVikKIMNWAC4BFSTFVg9-
A38QJy0BA9wQAS0BAd4Qoh8mwA4fKq8oDymGISMq790hQip-KA8PRxhwDQABMwEG5UcTUBwAJQ8q
IAATMCAAIw8qJAATMCQAFi8kAACkRwnxggITACIvKOwQFS8TAB4pJgAPTAAAGSlwAAGDAAAGOSQm
DyYAMx81MCYAAyIAMlAPJiMAAx8ARVAPJg4PAHIPNXAPJg7vGgBwgA8mHq8oHgsAMKAfJgYK8AEf
Jh81wA0fJm4cLfAADWwtyA8PkAEgECyQAQMyEQGQAQE0EaIfK8AOHy_vLQ8uOyAC4UYAk0YCTiAA
cEZQXy1PK18XAAGNAWAvTy0fK08rRgPeIKIvPy0PK48uDys-JAATMBMAFK8TAAQRAABuABAvTkUG
LAAfIBsAJRAuGwAQTz1FCjIAAJ0AMR8uLzYAFk8uABNvLgAVb6MAIy5fEwAB2gAVHxMAJg8uBAAE
9QAADgAFBQEAvQEiKw4eAQC6ATIrDu8XAHCADysery0eCwAwoB8r2gohHyu6AR4rugEPLApJIfoD
KQoiqizPCRUM64AzDNoM_gkjWowJACH6BQgAAh_BABEABCMABCGBABAKI6osCgov_gMHCo8CCgAC
Bgogjw8EAAIwNwYNAAH-ARURrkQJDQABLgIoEZ8GgQITAA0dgQEXAB8QFwADPxFPDzaBBAI2AA84
gQYBmwAnED_hRAHONwGeAgN7RACPAjINDxDnAACMAiQNDvMAUnAPDQ7vMABwgA8NHq8PHgsAMKAf
DdYSIR8NjAIeDUYED3oKYBSPW0QJDQAB-gAYFk6BGRZOgQE9AScWb59EBxcADVKBARcAKBVvVIEG
QQAYzyIAA1iBAX8AFRWOABofDwAAeAEUEn1EAHgBJBIO0gBScA8SDu8zAHCADxIerxQeCwAwoB8S
ZhMhHxJ4AR4SeAEPzQpUAgoAAswKMv8ZA0ozIxtPDUQhTxkdAAA1dAA8gQimRATvgAEZAAimRBJf
NAATIBsAHG8TAAJaAAYTAApSgQImAA4TAAwmAABSNAmmAAGRAQONRACOARQXhkQAjgEiFw4MAACO
ATIXDu8wAHCADxcerxkeCwAwoB8XEBQhHxeOAR4XjgEPMQtKAsExFXAKAAGOAQftYRBPTgBTHj8g
Tx41CzsPIF_vRARAgSMgX6dECY6BAUIBGSCQgQITAAWSgQEPAAN0RAQuAAOWgQobAAIsRRJPIEUB
dAEDvDIAdAEyHA8fwgAAdAEkHA7OAFJwDxwO7zAAcIAPHB6vHh4LADCgHxyYFCEfHHQBHhx0AQ99
C2AAooEjjyN-CxNfrEQjjyOECwCdCwKuRASKgQERABLPIAARIA8AOE8ljw8AAnxEVQ8jLyVPFwAB
BUUbDwQAHk82AAAEAAk2ADWPJU_LABIkkkQXHwwAAIIBMiEPJNAAAIIBJCEO3ABBcA8hDvsAAIIB
UCEeryMeCwAwoB8hNBUhHyGCAR8hggEsHybSCwIUHtELMg8nDtELQg8nDoDJU0UPJw5wCgAFywsQ
JwQAEA4NAEBPKC8ntiRhDygvJ08oJAARMKsLABMACgQAABQAFA4dABMvBAASXzQAESAXABiPDwBV
nygPJ58PABspHgAPRAADJylfcAAEBAAVX5cAHSmuAAXnCwLSAAHhABIp7QAQHwwAFCf5AFJwDg8n
7zIAcIAOHyevKB8LAECgHh8nhSUQHp4BQB5vJx6eAR9u4AtfBMwKAMwLAncsBgoAAfoAB9uOQX8t
Tn0XAABtC0h9Di0ODgA2DQ4NEABYLn0ODS4eABa9GgAkTn1bADEu-QM9CwULAANvCyH9ARcAAGsL
8Bf9AQ4MDzVwDA7tDgwbgAwerR4MG6AcHm0eHBvACxxuHCvwAAtsK30fDzYBHuJMS4BLgGtga2Ab
HCobQAUA8UoMagsgGwxaCwkwG4oLABt6GQ81IBuaG4oZDiAbmguaGQ4gCwn6BRkOMAn6BBkeMBn6
AxkOUBn6ARkeYBnqGR6AKaopHqA5ajkeoCuqK6AbDNobgBsM_gAZcAYAYA5gG3oJegcA-xNqGWop
DnALCTopDglKKR6AaR4AaR6gOS4gDjkewD5gPvAwzgAdYDF-EPAFnlNnEREWH-ADHl0fDvADHm0c
8AMeXRwPNfACDAAABQAxC-ABBgBCAB4PEQgAFgoHAEHgHgp9BgBhbRwb4B59GAACBgAxbRwbBgBQ
C-ABDgwHABICBgASHAYAcF0cC-ADLE0GAM_cC-ADC3wL8AV78BPHAB0QUqEc8AOu8AA_LxY-FD7A
Lh8WjxQuoC61CQCkLACxLDIPNXCsLAMHADIPNVCuLAMHAD8PNUAJABkSUEYAFB8JAFAPNXAfE2gA
FB8JAPADDzWQLxOvFC8THzWgPxNvFD8TtAMmrxNQBR805wAd8QM2TxrwBo7wAy4fGy8ZLvACHg_a
TVE18AAej7kcpo0ODxgPNeAejR8HAPASwD6NHxgekG5tHE5gHh8bLQ5tDB0bDR5QDgv9BA5AHv0F
KwMQIEMtHgoGAPARMBxdHB0sXRwaQIwdnBpgCkwKDB0cCkwqkEoMHRxq8AEOACLwBwYAEkwEAE8I
SvAY2QAdgDgPH-AMDvAMzADwAAoeDx3wCh4NDzXwCR4NDPlpcCAd8AgeCw8OAPAGBx4LCg0M8AYu
Gh3wBh46DQzwBC46XAnwAVoN8AMeC1od8AEeC3od8AAGAGDgHguaHdAFAEgMwB6qBQD-B9Adih0c
0C1qLQzwAK0c8AEMbSzwBGwOBB-yAFJfJPAFTh8iHzXwAi4vJQkAUx4fJR8jCwAAsgcBCwB0Ax4-
Ix8iDwkAChIAGk8JAGCwDyJQHl_ULCAODXQC8AtfIx0PNYAeDQxAHm8jHXAeHQxAHnstMC4PJQoA
8x_LbhoLHQxQHpsuGhsdHFAe_wEdDHAe6x0ccB3rHQyQLastHKA9az0cwAytLPAA6gAPfAIeMlUP
KaABMAsODaQBkCfwCg4PKg8nDaEBUCofJ-AIDwBgKB8nDfAGEQCQKB8n8AUeDyo-CQDgAi5vKC8n
0D6PKD8ngD4qTP8xTydgHTyPKDw9gA0saywt0A0cSxwt8AIcKxwd8AUcCxwd8AYcCxwN8AgsHfAI
LA3wCgwd8AoMDfALDA3wDA3wN78AGQ4wrQ8zoxCRTEiASIAISwhgBABmCww6CwhABwAgWgtncSEM
WlpxgXoLCAAICwxqDQBhigsICwx6CwBBmgsMigkAJfoFBwAhQAgTERhgUXGhoAgLygkIwAgLqgYA
IQy6EwAhDNogADUM_gCAcWFwCAt6CXoIADBqCQgkaSCACHMbEQAGAO_gCEkIIAhJCMBIQEjwTvAA
HcAxffAFDW8QDfAFDQ4NBhEOCgAWTAcAsAQNDlwODfADDQ5sHQBcAg0ObAsHAFABDQ4PEQkAUgAN
Dgp8CAAZjAcAEnwmAAc0AAoHAFEDDQ5cC20AIkwLewAIBwB-aw3wBX3wMdwAHXFRjxLwAw6PZHGA
DQ8WfxQNDuAJAFCfFA0OwAkAQL8UDQ5sA2AW3xQNDoAJAGL-FAANDmAKAK8CDxMOUA4N-xQDCQAv
EGAJADABDxNmAEDvFA8TdwAQzwgAQMAODa8IAEDgDg2PCACv8AEOjA7wA47wUe4AHXE1bxfwBQ5v
OHEQDV0PEg34AL8bfxkPGA7wAA4NjwkADCHAPggAcT6ADk2fGT0HAXIb-xkCDQ5ACgCvBA8YDjAO
Df8ZBQkADqBvGR8YDQ8ZLxhvWQCQQA4NTxkPGB4NVzPxCB4MTxkMDmAOTA4ADg0LDA4ADkwOgE4Q
DABBEE7wAQkAL-AIBwACP07wNhcBHTBVDxxkBvECCw4PHw7wCg4NDvAJDg0PHg1VAPACDA0O8AcO
DQ8gHA0O8AYODQsIAJMFDg0LPA0O8AQIAJMDDg0LXA0O8AIIAACiACF8DTcBAAgAkOAODQucDx0O
0AgAEAoHAB_sBgABUeAODYwKPQAgbApUAH9qDvAFbvA1zwAdoVFvIfAFDj8kDyIqcxEklw4PDAAa
ES8MABEEDAAVPwwAGk8KADTADlALADKwHlA1kFAkDpAODdMCkG8jDQ5wDg0PIg0AIX8jFAASDA4A
YIwNXg0cCwoAMJxdLIVzQA38AQv1AiDsC-MCIMwL8QIhrAsOARALDgEfi_0CIzNVDybWARcp1gEx
Kg8n1wECCQAA2QEgKh9MDSbwBgsAMAQeDZ4GIA8nOQkQHeENkB8nHrAeHR8qjwoAEHAKABLPCgCg
HK8oHB6wHhxrHCwAoAxLDB7wBA4MKwxQAAEHADIHDgyeAgEHADAJDgyMAAGXAACdAB9V1QAMD60G
L-ArVCnwCBkLDAoY8AQZKwwqGPAAGUsMShiwGWsMahhwGYsMihhACByLDIobCDAIGhxbHAtaGxkI
MAg6HMEM9gMaGzkIQAhKHGobSQhQCEoLigsIAJtgCEoLagtJCHAIAMCACEoLSgtJCJAISmsGAP8R
OgtpCzkIoAgaC4kLGQiwCAoLqQsJCLAIC8kLCMDo8GvSAB0RVdQBUhEPDfAKBwAhCQ7bF1YPDw3w
CAsAQQcOHxANFzYN8AYLAEAFDi8Q7TFGDw3wBAsAQQMOPxCwblIN8AIOL0IAERAaADMBDj8PAAEe
ABQANAABHgAz4A4-DgAAHQAR0BwAE08cADPADj8OABE-vFEAHAATbxwAEaAcABF-GgCAkA4fEB8R
jh-2TgB9GFAQHxHOH1FPAYAYv-4BDxAPDYD9A-BpJwEdMHEvE4AJAFwXMBQfEl55EBXQFnAfEvAA
Hk8V4xZgHxKwHm8VwxZgHxJwHo8VnBaAHxJADZ8VHxaQW3ANMA0PFm8VnzkQH-sWEBURAFIUDxY-
FagXkD8UDxUODTANHxYXEBWyFwEnbnIVHg0wDS8Ul3gSLiAAUBUPFB8VIAAxDgweRgBwDDscaxw_
DD8A8BAMaxwrHG4MDTANmyyeDUAdiwyOHXAdawxuHbAdSwxObyz-ASsMLh3wBB0LDA4d8Agt8HEM
AR3Aav8YAaAO-xoBDxeAYQYAPk1QGw4NcA2aFpDPGg8bHg1wDS-fWsEaDxsuDXANPxmvGz4IAAJV
eA8MAFUynxo_igBBGq4MLqAAMAzODJ0A-wELDO4MDg2ADf4BDaD9AfBqAgEdgIqvHfABDh8fxBUA
JUhTDxzgDi8OAFEvHg8cwA4AE28OADOgDj8OACA-HnQWAA4AE48OADNgDk8OACBPHsNIsG8g-x8A
DxwwDV8ep1pzDx9eDUANTwwAMU4NYAwAEW8MADOADT8MAFI_DaANP0MAYx8_DcANLwwAUi4N4A0v
hQAgHy4PChMfDQAQHgAKAA0AEg8NADMFDQ8NAEMODfAHDQDPDfAJDQ8fDfALDfBVIQEdAEl4EQnx
BgDMSAA_BAIUBwBLBxIvEwcQISgEAhIHYCHwAQ5PJHAVYQ8h4A5fJP4VQiHADl9AAAALB2IhoA0f
JT86ANIkPyMfJA2QDR8jHyUPNwAgJA_MeFENkA0-I8MVIiQ_DAAfJAwAGbAfIx8kDgxPIwwOHEsA
8AwcPgwrDD4cDaANXgwLDF4NwA1eDF4N4A1ODE5MATA_DD5GATAuDC5AATAeDB46AZ8ODA4N8Akt
8DcxAR2RTw8nvybwAA8nhhWDKQ8m4A8nDykNAIAnDybQDycfKSlaIA8pOTJDwA8nLw8AAAwyULAP
Jz8psxUxDyk-ljIjJ08PAADjMRKQDwARXw0AQ4APJ18cABFfqTIjJ09JAAAeABJgHgATbx4AQVAP
J1_-eCBvKeAhQl8oDykbAEMOYA5PDQAQT0gWABoAAlMAYA6ADk8obxYAMpAOT1YAAA0AM6AOPw0A
UD8nDrAOU2kgbye9AEMOwA4fDQBQHycO0A4HRCGPJ7IWIuAOCwBvDvAAzvBP3AdO8BtSHDvwBExb
8AB8a7Cci4CsiwlwO2x7GXBrPGs5YIscKzo5YKtqSVCrejkEAHFgm3opcIuKBAD-GIA5K5oZkGmK
KZB5eimgeWoZsHlaKcB5SBngSXgJ8AApiPACCWjwUpEAHfAPUz8R8Ahu8AWO8AMvEE4vD-ACLxB-
D-ABPxCPD-AABgCC4E8Qjw8PDtAHAPIHwF8Qjw8fDrBfEJ8PDw6gXxCvDx8OkAcA-yKAbxCvDy8O
cF8Qzw8fDmA9HxDfDy1QXdwtUH28PUB9nF1Afa8NTVBdyy2ALevQq-BQrQAd8iCPTxbwBm4fFPAC
bk3gjl2wPxVefYBsLq1gnM1QnL0PE1CcrSswrJ07MKyNSzCcnQQA-w_MG31LUDxrbTtwmz0vEiug
a4rgO3rwAwtq8Acq8HKDAB3xJm_PG-ACrg8a8ACuLdCeXbCeLxk9DxiQnk8ZLQ8YkI5vGR0fGHAN
bo8ZDS8YcC0uvxkvGHBdBgBETb8ZPwYAJj3PBgD-FS0Mzxk8cB0cu0xwTJtcgExbPxc8kGyKLKBM
qgzALLrwAarwT6YAHf9JiY8g8ALOPx_QPY59YF1uHx59UG0_jB0PHUB93CswbewrMF3sOzA9O7xL
QHusO2B7jDuAa4w7kGtsO7BbXDvQWyxL4GsfHDvwAUs6G-ADK0oL8AULWvAIKsgHHzE2PyVgAvBM
nvACHyR_HfAATU490G0_TcBtHyMeTbBtTF2gXWxNoC8iLXw9oEuMPaBLnB0LoEucK6BLjDugS3xL
oFtcW6BbTGugW0xbwFssa8BrHGvQWx8hW-AASyo78AIrSnl9T1rwBzpGDh--TW1-KvAEzuC_LynA
zj2gLZ5dgE2ObWBtbn1gfV5dHydgfV8oTT8nUAxNvyhMUBwty0xQPMtcUEy7XFBcq1xQbItccHxb
bHCMTyZckGxaTLBMeizQPHoc8AAcivBuSwQ6UG09Nn19
:: gfx/1.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA5LTEzIDEzOjUxOjM5Iixtb2RpZmllZD0iMjAyNC0w
OS0xMyAxMzo1MzoxOCIscmV2aXNpb249OV1dbHo0AG0AAAAFMQAA8xR7WzBdPXtibXA9cHh1AEMg
EBAE8PAsZmxhZ3M9MCxwYW5feAgAz3k9MCx6b29tPTh9LDEA----------------------------
------------------------------------51BtPTh9fQ==
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNS0w
NS0xMiAwODowMzo0OSIsc3RvcmVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Il1d
:: map/
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNC0w
OS0wMSAwNzozNDozNSIscmV2aXNpb249MzA3NV1dbHo0AMEAAABZEAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD-------_x0zIwMDAzMDAwNDAwMDYMAC81MIAAWxMxCAATNYAALzYw
AQBbFzb8ABMxDAAPAQBVBHwBAAABEzAMAA_AAVkTMXQAEzB4ABcxjAAPAAFVEzaEAAQMAC81MAEA
--------nvEJIiksaGlkZGVuPWZhbHNlLHBhbl94PTQ3CQDSeT0wLHRpbGVfaD0yOQoAEHcKAIB6
b29tPTF9fQ==
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNS0w
NS0xMiAwODowMzo0OSIsc3RvcmVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Il1d
:: pal/
:: pal/0.pal
b64$LS1bW3BvZCxiZ19jb2xvcj0wLGJsYWNrZXN0X2NvbG9yPTAsY3JlYXRlZD0iMjAyNC0wOC0y
MyAxODo1OTowOSIsaGlkZGVuPXtbMF09ZmFsc2UsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRy
dWUsdHJ1ZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxm
YWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxz
ZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxm
YWxzZSxmYWxzZSxmYWxzZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUs
dHJ1ZSx0cnVlLHRydWUsZmFsc2UsZmFsc2UsZmFsc2UsdHJ1ZSx0cnVlLGZhbHNlLGZhbHNlLGZh
bHNlLHRydWUsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2V9LGhpZGRlbl90b2dn
bGVzPXtbMF09ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2V9LGh1ZV9tb2RlPSJodWUrbHVtIixodWVf
b2Zmc2V0PTAsaWNvbj11c2VyZGF0YSgidTgiLDE2LDE2LCIwMDAxMDEwMTAxMDEwMTAxMDEwMTAx
MDAwMDAwMDAwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDYwMTAwMDAwMDAwMDAwMTA3MDcwNzA3MDcw
NzA3MDcwNjA2MDEwMDAwMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA2MDYwNjAxMDAwMDAwMDEwNzA3
MDcwNzA3MDcwNzA3MDYwNjA2MDYwMTAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzAxMDAw
MDAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDEwNzA3MDYwNjAxMDEwZDBkMDEwMTA3
MDcwMTAwMDAwMTA3MDcwNjA2MDEwMTBkMGQwMTAxMDcwNzAxMDAwMDAxMDcwNzAxMDEwNzA3MDYw
NjBkMGQwNzA3MDEwMDAwMDEwNzA3MDEwMTA3MDcwNjA2MGQwZDA3MDcwMTAwMDAwMTA3MDcwZDBk
MDEwMTBkMGQwNjA2MDcwNzAxMDAwMDAxMDcwNzBkMGQwMTAxMGQwZDA2MDYwNzA3MDEwMDAwMDEw
NzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwMTAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzAx
MDAwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMCIpLGxvY2tlZD17WzBdPWZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlfSxsb3djb2xfaWNvbj10cnVlLG1vZGlm
aWVkPSIyMDI1LTA1LTEyIDA4OjAzOjQ4Iixva3BhbF92ZXJzaW9uPSIxLjIuMiIscGlja2Vyc19t
b2RlPSJsaW5lYXJfaHVlIixyZXZpc2lvbj04MzU2LHRlc3RfY3ViZV9jb2xvcnM9e1swXT17MTIs
MTEsMTB9LHsxMSwxMCw5fSx7MTAsOSw4fSx7MTcsMTYsMTV9LHsxNiwxNSwxNH0sezE1LDE0LDEz
fSx7MjIsMjEsMjB9LHsyMSwyMCwxOX0sezIwLDE5LDE4fSx7MjcsMjYsMjV9LHsyNiwyNSwyNH0s
ezI1LDI0LDIzfSx7MzIsMzEsMzB9LHszMSwzMCwyOX0sezMwLDI5LDI4fSx7MzcsMzYsMzV9LHsz
NiwzNSwzNH0sezM1LDM0LDMzfSx7MSwxLDF9LHsxLDEsMX0sezEsMSwxfSx7MSwxLDF9LHsxLDEs
MX0sezEsMSwxfX0sdGVzdF9tb2RlPSJjdWJlcyIsdGVzdF9yYW1wX2NvbG9ycz11c2VyZGF0YSgi
dTgiLDEwLDI3LCIwODA5MGEwYjBjMDAwMDAwMDAwMDBkMGUwZjEwMTEwMDAwMDAwMDAwMTIxMzE0
MTUxNjAwMDAwMDAwMDAxNzE4MTkxYTFiMDAwMDAwMDAwMDFjMWQxZTFmMjAwMDAwMDAwMDAwMjEy
MjIzMjQyNTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjMwYTBhMGEwZjAwMDAwMDAwMDAyMzIzMGEwZjBmMDAw
MDAwMDAwMDFlMWUxOTE0MTQwMDAwMDAwMDAwMWUxOTE5MTkxNDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMzYzNzM4MDAwMDAwMDAwMDAw
MDAzMTMyMzMwMDAwMDAwMDAwM2EzYjNjM2QzZTNmMDAwMDAwMDAiKSx3aGl0ZXN0X2NvbG9yPTdd
XWx6NAD2AQAAFQIAAPUFdXNlcmRhdGEoImkzMiIsNjQsIjABACAxZAIAQDAwMmICAEAwMDNkAgBA
MDA1MwIAQDAwYjUCAEAwMGRiAgAxMDBmAQDwbzAwNzQxZjY1MDBhODI1OTIwMGUyNDliYTAwZWY4
M2M1MDBmOGJiZDkwMDc3MmMxNjAwYTIzMjE5MDBkNTRmMjEwMGYzODI1NzAwZmNiYzljMDA2NzQ5
MTMwMDljNzExYTAwZDZhMjI1MDBlZGM0NTQwMGZiZTE5OTAwMmQ1MxgA8BYzMTZlMzIwMDUwYTMy
YzAwODdkNDU2MDBiZmYyOTUwMDE2NTg1CABANzc5N_AA8BQwYjRiMzAwNWNkOGQyMDBhY2Y2ZjAw
MDQ3MjI4NjAwNWUyNiAA0DhkM2JlZDAwYWU4MWawAPAEOGM0ZmMwMDA2MTUzYTAwMDcyNLgAQTBi
MzdYADFmNjgfAFBjOTRjZZgAsDEzMTUwMDUyMjAyLwAwNjMyWAHwFmE1NWU0ZTAwYjc5MTg0MDA0
ZjRiM2UwMDU3YTY3YzAwN2RjNznAAPAGM2U4YmMwMGJlYjVhNDAwNTg1OTVkiAAwNmM4EAFANjlj
YTgBMDNjZXAAwDg2ODM4MDAwMjMzNSgAUTM1NGQ4GAExNjg5gAEwOGRigAAwOWI4kAGAZGVlNGYx
Iik=
:: pal/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTIzIDE4OjU0OjE5Iixtb2RpZmllZD0iMjAyNS0w
NS0xMiAwODowMzo0OSJdXQ==
:: sfx/
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM1Iixtb2RpZmllZD0iMjAyNS0w
NS0xMiAwODowMzo0OCIscmV2aXNpb249ODExM11dbHo0AC8BAADmBwAA8CdweHUAAygAAAQABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDBAUGBwAP-5AICQoLDwwPDQ8ODw8QAPAADQ8RDxIPEw8UDxUP
Fg8XEwDxAQ8YDxkPGg8bDxwPHQ8eDx8UAPEAIA8hDyIPIw8kDyUPJg8nFADxACgPKQ8qDysPLA8t
Dy4PLxQA8QAwDzEPMg8zDzQPNQ82DzcUAP8FOA85DzoPOw88Dz0PPg8-AA--8P8BAOv-J1oBEAYP
IBABIAEgAfAAAhACDBABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDDAAAh9EMAAc
H0AwAPIf-wEA3PIE_A9AAA1ADy3--y8A-i8M-i-wcBIAKiH_EQBf-rDwcAMIAP-UH-8BAP_ZUP--
--8g
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNS0w
NS0xMiAwODowMzo0OSIsc3RvcmVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Il1d
:: src/
:: src/logic/
:: src/logic/creation.lua
--[[pod_format="raw",created="2024-08-30 06:25:09",modified="2025-05-12 08:03:48",revision=4832]]
--- Board Creation Logic


function logic_cells(config)
	local grid
	local size
	if config.tiling == "square" then
		grid = sgrid_new()
		local height = grid:max_height() - 1
		for x = 0, config.columns - 1 do
			for y = 0, height do
				grid:set(pos(x, y), true)
			end
		end
	elseif config.tiling == "hex" then
		grid = hgrid_new()
		local height = (grid:max_height() - 1) * 2
		for x = 0, config.columns - 1 do
			for y = 0, height, 2 do
				grid:set(pos(x, y - (x % 2)), true)
			end
		end
	end
	return grid
end


-------------------------------------------------------------------------


function logic_new_cell_column(status, cells)
	status.columns += 1
	if cells:tiling() == "square" then
		local height = cells:max_height() - 1
		for y = 0, height do
			cells:set(pos(status.columns - 1, y), true)
		end
	elseif cells:tiling() == "hex" then
		local height = (cells:max_height() - 1) * 2
		for y = 0, height do
			local x = status.columns - 1
			cells:set(pos(x, y - (x % 2)), true)
		end
	end
end

------------------------------------------------------------------------


local function random_gem(config)
	return math.random(gem_air, gem_air - 1 + config.number_of_colours)
end


function logic_fill_gem_at(config, cells, gems, marks, p)
	local cell = cells:get(p)
	if not cell then
		return
	end
	local test = (gems:tiling() == "square") and logic_test_sqr_match_at or logic_test_hex_match_at
	local gem = gems:get(p)
	if not gem then
		local attempts = 0
		local found = false
		while attempts < 16 and not found do
			gem = random_gem(config)
			gems:set(p, gem)
			found = not test(gems, p)
			attempts += 1
		end
		if attempts == 16 then
			gem = gem_gift
			gems:set(p, gem)
		end
	end
end


function logic_fill_gems(config, cells, gems, marks)
	-- TODO: transform into a coroutine
	local height = gems:max_height() - 1
	if gems:tiling() == "square" then
		for x = 0, 13 do
			for y = height - 6, height do
				logic_fill_gem_at(config, cells, gems, marks, pos(x, y))
			end
		end
	elseif gems:tiling() == "hex" then
		cells:foreachpos(
			function(p, _)
				if p.y < 2 * (height - 6) then
					return
				end
				logic_fill_gem_at(config, cells, gems, marks, p)
			end
		)
	end
end

:: src/logic/matching.lua
--[[pod_format="raw",created="2024-08-24 08:12:55",modified="2025-05-12 08:03:48",revision=5998]]
--- Matching Logic

-- The matching algorithm has two phases:
--
-- 1. First, a linear sweep through all the gems, and for each gem involved in a match
--    creates a mark registering which direction(s) matched.
-- 2. Then a flood-fill algorithm is used to group matches together.


function logic_is_matching(gem1, gem2)
	if (not gem1) or (not gem2) then
		return false
	end
	
	-- Only colored gems can match.
	if (gem1 < gem_color_first) or (gem1 > gem_color_last) then
		return false
	end
	if (gem2 < gem_color_first) or (gem2 > gem_color_last) then
		return false
	end

	return (gem1 == gem2)
end


--------------------------------------------------------------------------


local function test_3(gems, p0, p1, p2)
	local gem0 = gems:get(p0)
	local gem1 = gems:get(p1)
	local gem2 = gems:get(p2)
	return logic_is_matching(gem0, gem1)
		and logic_is_matching(gem0, gem2)
		and logic_is_matching(gem1, gem2)
end


local function test_4(gems, p0, p1, p2, p3)
	local gem0 = gems:get(p0)
	local gem1 = gems:get(p1)
	local gem2 = gems:get(p2)
	local gem3 = gems:get(p3)
	return logic_is_matching(gem0, gem1)
		and logic_is_matching(gem0, gem2)
		and logic_is_matching(gem0, gem3)
		and logic_is_matching(gem1, gem2)
		and logic_is_matching(gem1, gem3)
		and logic_is_matching(gem2, gem3)
end


function logic_test_sqr_match_at(gems, p)
	local S = p + pos(0, 1)
	local SS = p + pos(0, 2)
	local N = p + pos(0, -1)
	local NN = p + pos(0, -2)
	local E = p + pos(1, 0)
	local EE = p + pos(2, 0)
	local W = p + pos(-1, 0)
	local WW = p + pos(-2, 0)
	local SE = p + pos(1, 1)
	local SW = p + pos(-1, 1)
	local NE = p + pos(1, -1)
	local NW = p + pos(-1, -1)
	return test_3(gems, SS, S, p) or test_3(gems, S, p, N) or test_3(gems, p, N, NN)
		or test_3(gems, EE, E, p) or test_3(gems, E, p, W) or test_3(gems, p, W, WW)
		or test_4(gems, p, S, SE, E) or test_4(gems, p, S, SW, W) 
		or test_4(gems, p, N, NE, E) or test_4(gems, p, N, NW, W)
end


function logic_test_hex_match_at(gems, p)
	local S = p + pos(0, 2)
	local S_S = p + pos(0, 4)
	local N = p + pos(0, -2)
	local N_N = p + pos(0, -4)
	local SE = p + pos(1, 1)
	local SE_SE = p + pos(2, 2)
	local SW = p + pos(-1, 1)
	local SW_SW = p + pos(-2, 2)
	local NE = p + pos(1, -1)
	local NE_NE = p + pos(2, -2)
	local NW = p + pos(-1, -1)
	local NW_NW = p + pos(-2, -2)
	local E = p + pos(2, 0)
	local W = p + pos(-2, 0)
	return test_3(gems, S_S, S, p) or test_3(gems, S, p, N) or test_3(gems, p, N, N_N)
		or test_3(gems, SE_SE, SE, p) or test_3(gems, SE, p, NW) or test_3(gems, p, NW, NW_NW)
		or test_3(gems, NE_NE, NE, p) or test_3(gems, NE, p, SW) or test_3(gems, p, SW, SW_SW)
		or test_4(gems, p, SE, S, SW) or test_4(gems, p, NE, N, NW)
		or test_4(gems, p, NE, E, SE) or test_4(gems, p, NW, W, SW)
end


local function check_3_and_mark(gems, p0, p1, p2, mark, marks)
	if test_3(gems, p0, p1, p2) then
		marks:merge(p0, mark)
		marks:merge(p1, mark)
		marks:merge(p2, mark)
	end
end


local function check_4_and_mark(gems, p0, p1, p2, p3, mark, marks)
	if test_4(gems, p0, p1, p2, p3) then
		marks:merge(p0, mark)
		marks:merge(p1, mark)
		marks:merge(p2, mark)
		marks:merge(p3, mark)
	end
end


local function mark_sgrid_matches_at(gems, p0, marks)
	check_3_and_mark( gems,
		p0,
		p0 + pos(0, 1),
		p0 + pos(0, 2),
		{ name = "matching", vertical = true }, marks )
	check_3_and_mark( gems,
		p0,
		p0 + pos(1, 0),
		p0 + pos(2, 0),
		{ name = "matching", horizontal= true }, marks )
	check_4_and_mark( gems,
		p0,
		p0 + pos(1, 0),
		p0 + pos(0, 1),
		p0 + pos(1, 1),
		{ name = "matching", vertical = true, horizontal = true }, marks )
end


local function mark_hgrid_matches_at(gems, p0, marks)
	check_3_and_mark( gems,
		p0,
		p0 + pos(0, 2),
		p0 + pos(0, 4),
		{ name = "matching", vertical = true }, marks )
	check_3_and_mark( gems,
		p0,
		p0 + pos(1, 1),
		p0 + pos(2, 2),
		{ name = "matching", horizontal_SE = true }, marks )
	check_3_and_mark( gems,
		p0,
		p0 + pos(1, -1),
		p0 + pos(2, -2),
		{ name = "matching", horizontal_NE = true }, marks )
	local p1 = p0 + pos(1, 1)
	local p2 = p0 + pos(1, -1)
	local p3 = p0 + pos(2, 0)
	if test_4(gems, p0, p1, p2, p3) then
		marks:merge(p0, { name = "matching", vertical = true, horizontal_NE = true, horizontal_SE = true})
		marks:merge(p1, { name = "matching", vertical = true, horizontal_SE = true })
		marks:merge(p2, { name = "matching", vertical = true, horizontal_NE = true })
		marks:merge(p3, { name = "matching", vertical = true, horizontal_NE = true, horizontal_SE = true})
	end
end


local function mark_all_matches(gems)
	local marks = gems:new_grid()
	if gems:tiling() == "square" then
		gems:foreachpos(
			function(p, _gem)
				mark_sgrid_matches_at(gems, p, marks)
			end
		)
	elseif gems:tiling() == "hex" then
		gems:foreachpos(
			function(p, _gem)
				mark_hgrid_matches_at(gems, p, marks)
			end
		)
	end
	return marks
end


---------------------------------------------------------------------------


local function group_this_match(cells, gems, marks, p)
	-- A simple flood-fill algorithm to group all
	-- intersecting linear matches together.
	local colour = false
	local positions = {}
	local remaining = { p }
	while #remaining > 0 do
		local current = deli(remaining)
		local gem = gems:get(current)
		if not colour then
			colour = gem
		end
		local mark = marks:get(current)
		if mark and mark.name == "matching"
			and (not mark.counted)
			and logic_is_matching(colour, gem)
		then
			colour = gem
			add(positions, current)
			marks:merge(current, { counted = true })
			local cell = cells:get(current)
			local neighbours = gems:neighbours(current)
			foreach(
				neighbours,
				function(n)
					local s = marks:get(n.position)
					if not s then
						return
					end
					if s and s.name == "matching"
						and (not s.counted)
						and s[n.direction]
					then
						add(remaining, n.position)
					end
				end
			)
		end
	end
	return { colour = colour, positions = positions }
end


function logic_find_matches(cells, gems)
	local marks = mark_all_matches(gems)
	local matches = {}
	marks:foreachpos(
		function(p, mark)
			if mark and mark.name == "matching"
				and (not mark.counted)
			then
				local match = group_this_match(cells, gems, marks, p)
				add(matches, match)
			end
		end
	)
	return matches, marks
end


-------------------------------------------------------------------------------


function logic_count_opportunities(cells, gems)
	local cleared_count = 0
	gems:foreachpos(
		function(position, _)
			local gem = gems:get(position)
			local right = position + pos(1, 0)
			local down = position + pos(0, 1)
			if gems:get(right) then
				local gem_right = gems:get(right)
				gems:set(position, gem_right)
				gems:set(right, gem)
				local matches, _ = logic_find_matches(cells, gems)
				gems:set(position, gem)
				gems:set(right, gem_right)
				foreach(matches,
					function(match)
						cleared_count += #match.positions
					end
				)
			end
			if gems:get(down) then
				local gem_down = gems:get(down)
				gems:set(position, gem_down)
				gems:set(down, gem)
				local matches, _ = logic_find_matches(cells, gems)
				gems:set(position, gem)
				gems:set(down, gem_down)
				foreach(matches,
					function(match)
						cleared_count += #match.positions
					end
				)
			end
		end
	)
	return cleared_count
end
:: src/logic/mechanics.lua
--[[pod_format="raw",created="2024-08-30 06:41:59",modified="2025-05-12 08:03:48",revision=4827]]
--- Core Mechanics Logic


function logic_mark_gravity(cells, gems, marks, gravity)
	local some_gems_are_falling = false
	gems:foreachpos(
		function(p, gem)
			local below = p + gravity
			local distance = 0
			local cell_below = cells:get(below)
			while cell_below do
				if (not gems:get(below)) then
					some_gems_are_falling = true
					distance += 1
				end
				below += gravity
				cell_below = cells:get(below)
			end
			if distance > 0 then
				marks:set(p, { name = "falling", target = p + distance * gravity })
			end
		end
	)
	return some_gems_are_falling
end


function logic_enact_gravity(gems, marks)
	local fell_gems = {}
	marks:foreachpos(
		function(p, mark)
			if mark.name == "falling" then
				local new_p = mark.target
				add(fell_gems, { gem = gems:get(p), pos = new_p })
				gems:del(p)
				marks:del(p)
			end
		end
	)
	foreach(fell_gems,
		function(fell_gem)
			gems:set(fell_gem.pos, fell_gem.gem)
			marks:del(fell_gem.pos)
		end
	)
end


------------------------------------------------------------------------


function logic_mark_swap(gems, marks, source, target)
	local gem0 = gems:get(source)
	local gem1 = gems:get(target)
	local test = (gems:tiling() == "square") and logic_test_sqr_match_at or logic_test_hex_match_at
	gems:set(source, gem1)
	gems:set(target, gem0)
	local matched = test(gems, target) or test(gems, source)
	gems:set(source, gem0)
	gems:set(target, gem1)
	marks:set(source, {
		name = "swapping",
		selected = true,
		target = target,
	})
	marks:set(target, {
		name = "swapping",
		target = source,
	})
	return true
end


function logic_enact_swap(gems, marks)
	local reinsert = {}
	marks:foreachpos(
		function(p, mark)
			if mark.name == "swapping" then
				add(reinsert, { gem = gems:get(p), position = mark.target })
				gems:del(p)
				marks:del(p)
			end
		end
	)
	foreach(
		reinsert,
		function(r) gems:set(r.position, r.gem) end
	)
end


-------------------------------------------------------------------------


function logic_enact_clear(gems, marks)
	marks:foreachpos(
		function(p, mark)
			if mark.name == "matching" then
				gems:del(p)
				marks:del(p)
			end
		end
	)
end


-------------------------------------------------------------------------


function logic_push_up(config, cells, gems, marks)
	if gems:tiling() == "square" then
		local width = cells:max_width() - 1
		local height = cells:max_height() - 1
		for x = 0, width do
			for y = 0, height do
				local position = pos(x, y)
				local below = pos(x, y + 1)
				gems:set(position, gems:get(below))
				marks:set(position, marks:get(below))
			end
		end
		for x = 0, width do
			logic_fill_gem_at(config, cells, gems, marks, pos(x, height))
		end
	elseif gems:tiling() == "hex" then
		local width = cells:max_width() - 1
		local height = (cells:max_height() - 1) * 2
		cells:foreachpos(
			function(position, _)
				local below = pos(position.x, position.y + 2)
				gems:set(position, gems:get(below))
				marks:set(position, marks:get(below))
			end
		)
		cells:foreachpos(
			function(position, _)
				if position.y >= height - 1
				then
					logic_fill_gem_at(config, cells, gems, marks, position)
				end
			end
		)
	end
end


-----------------------------------------------------------------------


function logic_check_filled(config, status, cells, gems)
	if not config.fail_top then
		return
	end
	status.filled = false
	status.filled_columns = {}
	gems:foreachpos(
		function(position, _)
			local _, top = cells:coords_cell(position)
			if top <= 0 then
				status.filled = true
				status.filled_columns[position.x] = true
			end
		end
	)
end


function logic_check_cleared(config, status, cells, gems)
	if not config.clear_zone then
		return
	end
	status.cleared = true
	gems:foreachpos(
		function(position, _)
			local _, top = cells:coords_cell(position)
			if top < config.clear_zone then
				status.cleared = false
			end
		end
	)
end

:: src/logic/spells.lua
--[[pod_format="raw",created="2024-08-30 06:37:36",modified="2025-05-12 08:03:48",revision=3360]]
--- Spell Logic

-- one simple match: 5 point
-- 4 gems combo: 15 points
-- 5 gems combo: 25 points
-- 6 gems combo: 35 points
-- 7 gems combo: 45 points

-- one cascade of simple matches: 15 points
-- two cascades of simple matches: 25 points
-- three cascades of simple matches: 35 points

-- one simple cascade after a 4 gems combo: 25 points
-- one 4 gems combo after a simple match: 25 points

function logic_gain_mana(status, matches)
	local gained = false
	local points = 0
	foreach(
		matches,
		function(match)
			local count = #(match.positions)
			points += 5 + 10 * (count - 3) + 5 * status.cascade
			gained = true
		end
	)
	status.mana += points
	status.mana = clamp(status.mana, 0, status.max_mana)
	status.score += points
	return gained
end


spells = {
	[0] = {
		name = "Clear gem",
	},
	{
		name = "Clear random",
	},
	{
		name = "Distant swap",
	},
	{
		name = "Shuffle",
	},
	{
		name = "Equalize",
	},
	{
		name = "Destroy column",
	},
	{
		name = "Destroy row",
	},
	{
		name = "Swap columns",
	},
	{
		name = "Replace color",
	},
	{
		name = "Destroy top",
	},
	{
		name = "Undo",
	},
	{
		name = "Vertical flip",
	},
	{
		name = "Multiswap",
	},
	{
		name = "Push row",
	},
	{
		name = "Link gems",
	},
	{
		name = "Combos freeze",
		passive = true,
	},
	{
		name = "Combos explode",
		passive = true,
	},
}
:: src/logic/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTMwIDA2OjI0OjM5Iixtb2RpZmllZD0iMjAyNS0w
NS0xMiAwODowMzo0OSJdXQ==
:: src/constants.lua
--[[pod_format="raw",created="2024-08-24 15:17:10",modified="2025-05-12 08:03:48",revision=4921]]
--- Match3 Global Constants


-- Gems and cells ------------------------------------------------------

-- Color gems
gem_air = 0x01
gem_fire = 0x02
gem_day = 0x03
gem_earth = 0x04
gem_water = 0x05
gem_night = 0x06
gem_white = 0x07
gem_black = 0x08

gem_color_first = gem_air
gem_color_last = gem_black

-- Black gems
gem_gift = 0x08
gem_bomb = 0x09
gem_cat = 0x0a
gem_bat = 0x0b
gem_robot = 0x0c
gem_robot_asleep = 0x0d
gem_robot_asleep2 = 0x0e

gem_names = {
	[gem_air] = "Air",
	[gem_fire] = "Fire",
	[gem_day] = "Day",
	[gem_earth] = "Earth",
	[gem_water] = "Water",
	[gem_night] = "Night",
	[gem_white] = "White",
	[gem_black] = "Black",
}

:: src/gfx.lua
--[[pod_format="raw",created="2024-08-24 12:06:13",modified="2025-05-12 08:03:48",revision=8966]]
--- Graphics


local star_seed = 0


function gfx_seed_the_stars()
	star_seed = math.random(37, 6584587)
end


function gfx_draw_starry_background(left, top, right, bottom)
	local hash = star_seed
	for x = left, right, 40 do
		for y = top, right, 40 do
			hash = hash~(hash << 13); hash = hash~(hash >> 17); hash = hash~(hash << 5)
			local flipped = (x+y)%2 == 0
			spr(120 + (hash%8), x, y, flipped, flipped)
		end
	end
end


----------------------------------------------------------------------------------


local cell_width = 29
local cell_height = 29


function gfx_draw_cells(cells, stats)
	local function draw_cell(p, _)
		local has_cell = cells:get(p)
		if p.y == -1 then
			if cells:tiling() == "square" then
				has_cell = cells:get(pos(p.x, p.y + 1))
			elseif cells:tiling() == "hex" then
				has_cell = cells:get(pos(p.x, p.y + 2))
			end
		end
		if not has_cell then
			return
		end
		local x, y = cells:coords_cell(p)
		local sprite
		if cells:tiling() == "square" then
			sprite = 32
			local offset = (stats.push_ups) % 2
			sprite += (p.x + p.y + offset) % 2
		elseif cells:tiling() == "hex" then
			sprite = 40
			local offset = (stats.push_ups) % 3
			sprite += (p.y + (p.x * 3) - offset) % 3
		end
		spr(sprite, x, y)
	end
	cells:foreachpos(draw_cell)
end


-----------------------------------------------------------------------


local sprites_color_gem = {
	[gem_air] = 1,
	[gem_fire] = 2,
	[gem_day] = 3,
	[gem_earth] = 4,
	[gem_water] = 5,
	[gem_night] = 6,
	[gem_white] = 7,
	[gem_black] = 8,
}


local sprites_other_gem = {
	[gem_gift] = 8,
	[gem_bomb] = 9,
	[gem_cat] = 10,
	[gem_bat] = 11,
	[gem_robot] = 12,
	[gem_robot_asleep] = 13,
	[gem_robot_asleep2] = 13,
}

--color_gem_skin = math.random(0, 14)
color_gem_skin = 0
local function gem_sprite(gem)
	local base = 128 + color_gem_skin * 8
	if gem >= gem_color_first and gem <= gem_color_last then
		return sprites_color_gem[gem] - 1 + base
	else
		return sprites_other_gem[gem]
	end
end


local function scaled_gem(sprite, x, y, size)
	local w, h = flr(29 * size + 0.5) // 2 * 2 + 1, flr(29 * size + 0.5) // 2 * 2 + 1
	local x, y = x + ((29 - w) / 2), y + ((29 - h) / 2)
	sspr(sprite, 0, 0, 29, 29, x, y, w, h)
end


local function draw_exploded_gem(gem, x, y, clock, new_clock)
	local size = 32 * new_clock
	local colour = 10 + (gem - 1) * 5
	oval(x - size, y - size, x + 29 + size, y + 29 + size, colour + 1)
	if clock < 0.25 then
		ovalfill(x + 2, y + 2, x + 25, y + 25, 7)
	elseif clock < 0.50 then
		ovalfill(x + 2, y + 2, x + 25, y + 25, colour + 2)
	elseif clock < 0.75 then
		ovalfill(x + 1, y + 1, x + 27, y + 27, colour + 1)
	elseif clock < 1.0 then
		ovalfill(x, y, x + 29, y + 29, colour)
	end
end


function gfx_draw_gems(stats, cells, gems, marks, clock)
	local function draw_gem(p, gem)
		local x, y = gems:coords_gem(p)
		local sprite = gem_sprite(gem)
		local cell = cells:get(p)
		local mark = marks:get(p)
		palt(53, true)
		if not mark then
			if stats.filled_columns[p.x] then
				spr(sprite, x + math.random(-1, 1), y)
			else
				spr(sprite, x, y)
			end
		elseif mark.name == "new" then
			scaled_gem(sprite, x, y, clock)
		elseif mark.name == "matching" then
		elseif mark.name == "falling" or mark.name == "swapping"
		then
			local dest_x, dest_y = gems:coords_gem(mark.target)
			local ix, iy = x + clock * (dest_x - x), y + clock * (dest_y - y)
			spr(sprite, ix, iy)
		end
		palt(53, false)
	end
	gems:foreachpos(draw_gem)
	local new_clock = clock * clock * clock * clock
	gems:foreachpos(
		function(p, gem)
			local x, y = gems:coords_gem(p)
			local mark = marks:get(p)
			if mark and mark.name == "matching" then
				draw_exploded_gem(gem, x, y, clock, new_clock)
			end
		end
	)
end


------------------------------------------------------------------------


local pattern_tick = 0
local patterns = {
	[0] =
	0b00011111,
	0b10001111,
	0b11000111,
	0b11100011,
	0b11110001,
	0b11111000,
	0b01111100,
	0b00111110,
}


function gfx_draw_clear_zone()
	if config.clear_zone then
		local pattern = patterns[flr(pattern_tick) % 8]
		pattern_tick += 0.166666666
		fillp(pattern, pattern, pattern, pattern, pattern, pattern, pattern, pattern)
		poke(0x550b, 0x3f)
		line(80, config.clear_zone, 400, config.clear_zone, 7)
		poke(0x550b, 0x00)
		fillp()
	end
end


-----------------------------------------------------------------------


function gfx_draw_turns(ox, oy, turn, timer)
	spr(64, ox, oy)
	local hundreds = (turn // 100) % 10
	local tens = (turn // 10) % 10
	local ones = turn % 10
	local anim = flr((timer) * 10.0)
	pal(7, 1)
	clip(ox + 7, oy + 3, ox + 7 + 3 * 8, oy + 3 + 8)
	-- hundreds
	if anim == 0 or (turn % 100) > 0 then
		spr(65 + hundreds, ox + 7, oy + 6)
	else
		spr(65 + hundreds, ox + 7, oy + 6 + anim)
		spr(65 + ((hundreds - 1) % 10), ox + 7, oy + 6 + anim - 10)
	end
	-- tens
	if anim == 0 or ones > 0 then
		spr(65 + tens, ox + 7 + 8, oy + 6)
	else
		spr(65 + tens, ox + 7 + 8, oy + 6 + anim)
		spr(65 + ((tens - 1) % 10), ox + 7 + 8, oy + 6 + anim - 10)
	end
	-- ones
	spr(65 + ones, ox + 7 + 2 * 8, oy + 6 + anim)
	spr(65 + ((ones - 1) % 10), ox + 7 + 2 * 8, oy + 6 + anim - 10)
	clip()
	pal(7, 7)
end


local function gfx_draw_mana(ox, oy, mana, zoomed)
	local base_char
	local char_width
	if zoomed then
		base_char = 85
		char_width = 11
		oy -= 3
	else
		base_char = 75
		char_width = 8
	end
	local thousands = (mana // 1000) % 10
	local hundreds = (mana // 100) % 10
	local tens = (mana // 10) % 10
	local ones = mana % 10
	local digits = max(1, math.floor(math.log(mana, 10)) + 1)
	ox -= (digits * char_width) // 2
	if mana >= 1000 then
		spr(base_char + thousands, ox, oy)
		ox += char_width
	end
	if mana >= 100 then
		spr(base_char + hundreds, ox, oy)
		ox += char_width
	end
	if mana >= 10 then
		spr(base_char + tens, ox, oy)
		ox += char_width
	end
	spr(base_char + ones, ox, oy)
end



function gfx_draw_mana_bar(ox, oy, mana, max_mana, zoomed)
	local width = 66
	local height = 26
	local size = min(width, flr(0.5 + width * (mana / max_mana)))
	poke(0x5508, 0xff)
	poke(0x550b, 0x3f)
	rectfill(ox-3, oy-3, ox+width+3, oy+height+3, 7 | (3 << 6))
	poke(0x550b, 0x00)
	poke(0x5508, 0x3f)
	rectfill(ox-1, oy+height-3-1, ox+width+1, oy+height+1, 58)
	if size > 0 then
		rectfill(ox, oy+height-3, ox+size, oy+height, 54)
	end
--	rect(ox-1, oy-1, ox+width+1, oy+height+1, 63)
	gfx_draw_mana(ox + (width//2) + 1, oy + height - 20, mana, zoomed)
end
:: src/hgrid.lua
--[[pod_format="raw",created="2024-08-25 08:16:09",modified="2025-05-12 08:03:48",revision=5427]]
--- Hex Grids

--- Hex grids use the "double height" coordinate system:
---
---     (0,0)         (2,0)         (4,0)
---            (1,1)         (3,1)
---     (0,2)         (2,2)         (4,2)
---            (1,3)         (3,3)
---     (0,4)         (2,4)         (4,4)
---
--- The origin of the grid, `pos(0, 0)`, is at the top left.


-- Local Constants --------------------------------------------------------


local max_width <const> = 15
local max_height <const> = 12

local dx <const> = 24
local dy <const> = 14

local gem_offset_x = 1
local gem_offset_y = -1


------------------- -----------------------------------------------------------


local metatable = {}


function hgrid_new()
	local grid = {}
	metatable.default_origin(grid)
	setmetatable(grid, { __index = metatable })
	for i = 0, max_width * max_height do
		grid[i] = nil -- TODO false
	end
	return grid
end


function metatable:new_grid()
	return hgrid_new()
end


function metatable:clone()
	local grid = self:new_grid()
	grid.origin = self.origin
	self:foreachpos(function(p, item) grid:set(p, item) end)
	return grid
end


-----------------------------------------------------------------------------


function metatable:tiling()
	return "hex"
end


function metatable:max_width()
	return max_width
end


function metatable:max_height()
	return max_height
end


-----------------------------------------------------------------------------


function metatable:get(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width then -- or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	return self[p.x + ((p.y // 2) * max_width)]
end


function metatable:set(p, value)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	self[p.x + ((p.y // 2) * max_width)] = value
end


function metatable:merge(p, state)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	local index = p.x + ((p.y // 2) * max_width)
	if not self[index] then
		self[index] = {}
	end
	for k, v in pairs(state) do
		self[index][k] = v
	end
end


function metatable:del(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	self[p.x + ((p.y // 2) * max_width)] = false
end


-- Screen Coordinates ---------------------------------------------------------


function metatable:default_origin()
	self.origin = { x = 116, y = 7 }
end


local function compute_screen_size(self)
	local min_p = pos(max_width, max_height)
	local max_p = pos(0, 0)
	self:foreachpos(
		function(position, cell)
			if not cell or cell == 0 then
				return
			end
			if position.x < min_p.x then min_p.x = position.x end
			if position.y < min_p.y then min_p.y = position.y end
			if position.x > max_p.x then max_p.x = position.x end
			if position.y > max_p.y then max_p.y = position.y end
		end
	)
	local width = 1 + max_p.x - min_p.x
	local height = 1 + max_p.y - min_p.y
	return min_p, max_p, width, height
--	self.origin.y += 6 -- for Matchic Pon only
--	self.origin.y -= flr(delta * dy * 2)
end


function metatable:set_center_coords(x, y)
	local min_p, max_p, width, height = compute_screen_size(self)
	self.origin = {
		x = x - ((width * dx) // 2) - (min_p.x * dx) - 4,
		y = y - ((height * dy) // 2) - (min_p.y * dy) - 8 + 3,
	}
	self.screen_width = width * dx + 8
	self.screen_height = height * dy
end


function metatable:set_bottom_center_coords(x, y)
	local min_p, max_p, width, height = compute_screen_size(self)
	self.origin = {
		x = x - ((width * dx) // 2) - (min_p.x * dx) - 4,
		y = y - (max_p.y * dy) - dy + 3,
	}
	self.screen_width = width * dx + 8
	self.screen_height = height * dy
end


function metatable:offset_coords(x, y)
	self.origin.x += flr(x * dx)
	self.origin.y += flr(y * dy * 2)
end


function metatable:coords_cell(p)
	return self.origin.x + p.x * dx, self.origin.y + p.y * dy
end


function metatable:coords_gem(p)
	return self.origin.x + (p.x * dx) + gem_offset_x,
		self.origin.y + (p.y * dy) + gem_offset_y
end


function metatable:pos(x, y)
	local ox, oy = self.origin.x, self.origin.y
	x -= ox
	y -= oy + 1
	local px, py = x // dx, y // dy
	local xx, yy = x - (px * dx), y - (py * dy)
	if xx < 8 then
		if (px + py) % 2 == 0 and yy < dy + (-2 * xx) then
			px -= 1
			py -= 1
		elseif (px + py) % 2 != 0 and yy > -1 + (2 * xx) then
			px -= 1
		end
	end
	py = (2 * ((py - (px % 2)) // 2)) + (px % 2)
	return pos(px, py)
end


function metatable:distance(p0, p1)
	-- TODO: is this correct?
	return (abs(p0.x - p1.x) + abs(p0.y - p1.y)) // 2
end


-- Iterating ----------------------------------------------------------


function metatable:foreachpos(func)
	for x = 0, max_width do
		for y = x % 2, max_height * 2 - 1, 2 do
			local p = pos(x, y)
			local item = self:get(p)
			if item then
				func(p, item)
			end
		end
	end
end	


function metatable:neighbours(p)
	return {
		{ position = p + pos(1, 1), direction = "horizontal_SE" },
		{ position = p + pos(0, 2), direction = "vertical" },
		{ position = p + pos(-1, 1), direction = "horizontal_NE" },
		{ position = p + pos(-1, -1), direction = "horizontal_SE" },
		{ position = p + pos(0, -2), direction = "vertical" },
		{ position = p + pos(1, -1), direction = "horizontal_NE" },
	}
end


function metatable:blast_radius(p)
	return {
		p + pos(0, 0),
		p + pos(0, -2),
		p + pos(1, -1),
		p + pos(1, 1),
		p + pos(0, 2),
		p + pos(-1, 1),
		p + pos(-1, -1),
	}
end

:: src/in_game.lua
--[[pod_format="raw",created="2024-08-27 17:11:11",modified="2025-05-12 08:03:48",revision=8893]]
in_game = {}


-- The Board
config = {}
local cells = false
local gems = false
local starting_status = {
	number_of_colours = config.number_of_colours,
	columns = config.columns,
	gravity = config.gravity,
	speed = config.speed,
	turn = 0,
	combo_pause = 0,
	distance = 0.0, -- total distance risen
	push_ups = 0, -- total number of push_ups
	mana = 0,
	max_mana = 200,
	score = 0,
	cascade = 0,
	cleared = false,
	filled = false,
	filled_columns = {},
}
local status = deep_copy(starting_status)
local undo = {} -- TODO use `create_delta` and `apply_delta` instead

local marks = false
local matches = {}

-- State Machine
local menu_requested = false
local substate = false
local clock = 0.0
local interaction = false
local displayed_mana = 0
local on_screen_distance = 0


-------------------------------------------------------------------------


local function update_board_coords()
	cells:set_bottom_center_coords(00 + ((480 - 000) // 2), 269)
	cells:offset_coords(0.0, status.push_ups - on_screen_distance)
	gems.origin = cells.origin
end


local function rise_board()
	if on_screen_distance < status.distance then
		on_screen_distance += 1.0 / 27.0
		if on_screen_distance > status.distance then
			on_screen_distance = status.distance
		end
	end
	while on_screen_distance - status.push_ups > 0.0 do
		logic_push_up(config, cells, gems, marks)
		status.push_ups += 1
	end
	update_board_coords()
end


-----------------------------------------------------------------------


-- Functions for substate need to be global, because of Lua
-- forward-declaration rule for locals.

function creating_the_board()
	undo = {}
	cells = logic_cells(config)
	local gems_candidates = {}
	for i = 1, 4 do
		gems_candidates[i] = cells:new_grid()
		local marks = cells:new_grid() -- TODO: remove `marks` from `logic_fill_gems`
		logic_fill_gems(config, cells, gems_candidates[i], marks)
	end
	local best_candidate = false
	local best_count = 0
	for i = 1, 3 do
		local count = logic_count_opportunities(cells, gems_candidates[i])
		if (not best_candidate) or (count < best_count) then
			best_candidate = i
			best_count = count
		end
	end
	gems = gems_candidates[best_candidate]
	marks = cells:new_grid()
	cells:set_bottom_center_coords(00 + ((480 - 000) // 2), 269)
	gems.origin = cells.origin
	status = deep_copy(starting_status)
	status.number_of_colours = config.number_of_colours
	status.columns = config.columns
	status.gravity = config.gravity
	status.speed = config.speed
	matches = {}
	displayed_mana = 0
	on_screen_distance = 0.0
	gfx_seed_the_stars()
	return starting_new_turn
end


function starting_new_turn()
	if clock == 0.0 then
		status.turn += 1
		status.cascade = 0
	end

	return waiting_for_input
end


function waiting_for_input()
	local mx, my, mb, _, _ = mouse()
	if mb == 0x1 then
		local mp = cells:pos(mx, my)
		if gems:get(mp) then
			interaction = { name = "swap", position = mp, start = t() }
			return waiting_for_swap
		end
	end
	if keyp("r") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:del(p)
		matches = {}
		return applying_gravity
	end
	if keyp("e") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:del(p)
		matches = {}
		logic_check_cleared(config, status, cells, gems)
		return waiting_for_input
	end
	if keyp("o") then
		status.distance += 1.0 / 25.0
		update_board_coords()
		logic_check_cleared(config, status, cells, gems)
		logic_check_filled(config, status, cells, gems)
	end
	if keyp("a") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:set(p, gem_air)
		marks:set(p, { name = "new" })
		matches = {}
		return checking_matches
	end
	if keyp("s") then
		config.tiling = "square"
		config.gravity = pos(0, 1)
		config.columns = 2 * (config.columns // 2)
		return creating_the_board
	end
	if keyp("h") then
		config.tiling = "hex"
		config.gravity = pos(0, 2)
		config.columns = 2 * (config.columns // 2) + 1
		return creating_the_board
	end
	if keyp("z") then
		local previous = deli(undo)
		if previous then
			cells = previous.cells
			gems = previous.gems
			marks = cells:new_grid()
			status = previous.status
			on_screen_distance = status.distance
		end
	end
	if keyp("1") then color_gem_skin = 5 end
	if keyp("2") then color_gem_skin = 8 end
	if keyp("3") then color_gem_skin = 10 end
	if keyp("4") then
		color_gem_skin = (color_gem_skin - 1) % 16
		if config.tiling == "square" and color_gem_skin == 7 then
			color_gem_skin = 3	
		elseif config.tiling == "hex" and color_gem_skin == 3 then
			color_gem_skin = 15
		end
	end
	if keyp("5") then color_gem_skin = config.tiling == "square" and 0 or 4 end
	if keyp("6") then
		color_gem_skin = (color_gem_skin + 1) % 16
		if config.tiling == "square" and color_gem_skin == 4 then
				color_gem_skin = 8
		elseif config.tiling == "hex" and color_gem_skin == 0 then
			color_gem_skin = 4
		end
	end
	if keyp("7") then color_gem_skin = 2 end
	if keyp("8") then
		local prev = color_gem_skin
		while prev == color_gem_skin do
			color_gem_skin = math.random(0, 14)
		end
	end
	if keyp("9") then color_gem_skin = 15 end
	return waiting_for_input
end


function waiting_for_swap()
	local mx, my, mb, _, _ = mouse()
	if mb != 0x1 then
		interaction = false
		return waiting_for_input
	end
	local mp = cells:pos(mx, my)
	if cells:distance(mp, interaction.position) != 1
		or (not cells:get(mp))
		or (eq_pos(mp, interaction.position - config.gravity) and not gems:get(mp))
	then
		return waiting_for_swap
	end
	local success = logic_mark_swap(gems, marks, interaction.position, mp)
	interaction = false
	if not success then
		return waiting_for_input
	end
	add(undo, {
		cells = cells:clone(),
		gems = gems:clone(),
		status = deep_copy(status),
	})
	return swapping_two_gems
end


function swapping_two_gems()
	clock += 1.0 / 8.0
	if clock < 1.0 then
		return swapping_two_gems
	end
	logic_enact_swap(gems, marks)
	return applying_initial_gravity
end


function applying_initial_gravity()
	if clock == 0.0 then
		local some_gems_are_falling = logic_mark_gravity(cells, gems, marks, status.gravity)
		if not some_gems_are_falling then
			return checking_matches
		end
	end
	clock += 1.0 / 8.0
	if clock < 1.0 then
		return applying_initial_gravity
	end
	logic_enact_gravity(gems, marks)
	return checking_matches
end


function checking_matches()
	matches, marks = logic_find_matches(cells, gems)
	if #matches > 0 then
		local _ = logic_gain_mana(status, matches)
		foreach (
			matches,
			function(match)
				if #match.positions > 3 then
					status.combo_pause += #match.positions - 3
				end
				status.cascade += 1
			end
		)
		return clearing_gems
	end
	return ending_turn
end


function clearing_gems()
	clock += 1.0 / 16.0
	if clock < 1.0 then
		return clearing_gems
	end
	logic_enact_clear(gems, marks)
	return applying_gravity
end


function applying_gravity()
	if clock == 0.0 then
		local some_gems_are_falling = logic_mark_gravity(cells, gems, marks, status.gravity)
		logic_check_filled(config, status, cells, gems)
		if not some_gems_are_falling then
			return ending_turn
		end
	end
	clock += 1.0 / 8.0
	if clock < 1.0 then
		return applying_gravity
	end
	logic_enact_gravity(gems, marks)
	return checking_matches
end


function ending_turn()
	logic_check_cleared(config, status, cells, gems)
	if status.cleared then
		return starting_new_turn
	end
	
	if config.combo_pause and status.combo_pause > 0 then
		status.combo_pause -= 1
		return starting_new_turn
	end
	
	status.distance += status.speed
	status.speed += config.speed_increase
--	while status.distance - status.push_ups > 0.0 do
--		logic_push_up(config, cells, gems, marks)
--		status.push_ups += 1
--	end
--	update_board_coords()

	if config.column_increase and status.turn % config.column_increase == 0 then
		logic_new_cell_column(status, cells)
	end

	return starting_new_turn
end


-----------------------------------------------------------------------


function in_game:enter()
	menu_requested = false
	substate = creating_the_board
	local gui = ui_create_root()
	gui:attach(
		ui_button {
			x = 14, y = 5,
			sprite = 98,
			sprite_clicked = 99,
			tap =
				function(self)
					menu_requested = true
				end,
		}
	)
	gui:attach {
		x = 80, y = 0, width = 480 - 160, height = 270,
		hover =
			function(self, msg)
				local cursor_pos = cells:pos(80 + msg.mx, msg.my)
				local cell = cells:get(cursor_pos)
				if cell and cell != 0 then
					window { cursor = "grab" }
				else
					window { cursor = "" }
				end
			end
	}
end


function in_game:exit()
end


function in_game:update()
	local next = substate()
	if next != substate then
		clock = 0.0
		substate = next
	end
	
	rise_board()
	logic_check_filled(config, status, cells, gems)

	if displayed_mana < status.mana then
		displayed_mana += 0.25
	elseif displayed_mana >= status.mana then
		displayed_mana = status.mana
	end
	
	ui_update_all()
	
	if menu_requested then
		return in_prelaunch_waves -- in_mode_selection
	end

	return false
end


function in_game:draw()
	if not cells then
		return
	end
	-- Starry background
--	gfx_draw_starry_background(0, 0, 480, 270)
	spr(112, 0, 0)
	-- Draw the board
	if status.turn > 0 then
---		gfx_draw_cells(cells, status)
		local x1 = cells.origin.x - 2
		local x2 = cells.origin.x + cells.screen_width + 2
		poke(0x5508, 0xff)
		poke(0x550b, 0x3f)
		rectfill(x1, 0, x2, 270, 7 | (2 << 6))
		poke(0x550b, 0x00)
		poke(0x5508, 0x3f)
		line(x1 - 1, 0, x1 - 1, 270, 63)
		line(x2 + 1, 0, x2 + 1, 270, 63)
		gfx_draw_gems(status, cells, gems, marks, clock)
		gfx_draw_clear_zone()
	end
	-- Experience
--	gfx_draw_mana(455, 20, flr(displayed_mana), displayed_mana < status.mana)
	gfx_draw_mana_bar(408, 5, flr(displayed_mana), status.max_mana, displayed_mana < status.mana)
--	print(string.format("/%d", status.max_mana), 455 + 1 + 1, 20 + 3 + 1, 58)
--	print(string.format("/%d", status.max_mana), 455 + 1, 20 + 3, 7)
	---
	for i = 0, 5 do
		spr(96, 480 - 80 + 4, 40 + i * 38)
	end
	cursor(480 - 80 + 10, 44 + 0 * 38, 1)
	print("Destroy gem")
	cursor(480 - 80 + 10, 44 + 1 * 38, 1)
	print("Rotate column")
	cursor(480 - 80 + 10, 44 + 2 * 38, 1)
	print("Destroy line")
	cursor(480 - 80 + 10, 44 + 3 * 38, 1)
	print("Repaint")
	cursor(480 - 80 + 10, 44 + 4 * 38, 1)
	print("Equalize")
	cursor(480 - 80 + 10, 44 + 5 * 38, 1)
	print("1234567890123")
	-- Update the cursor
	if false then
		local mx, my = mouse()
		local cursor_pos = cells:pos(mx, my)
		rectfill(mx + 4 - 10, my + 10, mx + 36, my + 20, 7)
		print(tostr(cursor_pos.x)..","..tostr(cursor_pos.y), mx + 6 - 10, my + 12, 0)
	end
	--
	ui_draw_all()

	cursor(480 // 2 - 4*4, 120, status.cleared and 7 or 0)
	print(status.cleared and "cleared!" or "")
	cursor(4, 32, 7)
	print(string.format("turn: %d", status.turn))
	print(string.format("score: %d", status.score))
	print("")
	print(string.format("\14colours: %d", config.number_of_colours))
	print(string.format("\14columns: %d", config.columns))
	print(string.format("\14speed: %1.3f", status.speed))
	print("")
--	print(string.format("\14dist: %3.3f", status.distance))
--	print(string.format("\14up: %d", status.push_ups))
end
:: src/in_mode_selection.lua
--[[pod_format="raw",created="2024-09-21 11:01:40",modified="2025-05-12 08:03:48",revision=155]]
in_mode_selection = {}


local start_requested = false


function in_mode_selection:enter()
	gfx_seed_the_stars()
	start_requested = false
	local gui = ui_create_root()
	gui:attach(ui_button {
		x = (480 // 2) - (80 // 2), y = 80, width = 80, height = 13,
		label = "Tutorial",
		tap =
			function(self)
				-- start_requested = true
			end
	})
	gui:attach(ui_button {
		x = (480 // 2) - (80 // 2), y = 120, width = 80, height = 13,
		label = "Endurance",
		tap =
			function(self)
				start_requested = in_prelaunch_endurance
			end
	})
	gui:attach(ui_button {
		x = (480 // 2) - (80 // 2), y = 160, width = 80, height = 13,
		label = "Waves",
		tap =
			function(self)
				start_requested = in_prelaunch_waves
			end
	})
end


function in_mode_selection:exit()
end


function in_mode_selection:update()
	ui_update_all()
	if start_requested then
		return start_requested
	end
end


function in_mode_selection:draw()
	gfx_draw_starry_background(0, 0, 480, 270)
	ui_draw_all()
end
:: src/in_prelaunch_endurance.lua
--[[pod_format="raw",created="2024-09-20 07:05:05",modified="2025-05-12 08:03:48",revision=1037]]
in_prelaunch_endurance = {}


local start_requested = false


function in_prelaunch_endurance:enter()
	config = {
		tiling = "square",
		number_of_colours = 6,
		columns = 6,
		gravity = pos(0, 1),
		speed = 0.400,
		speed_increase = 0.001,
		column_increase = false,
		fail_top = true,
		clear_zone = false,
		combo_pause = false,
	}

	gfx_seed_the_stars()
	start_requested = false
	local gui = ui_create_root()
	gui:attach(ui_label {
		x = (480 // 2) - (120 // 2), y = 10, width = 120, height = 13,
		label = "Game Mode: Endurance",
		centered = true,
	})
	gui:attach(ui_hchoice {
		x = (480 // 2) - (120 // 2), y = 50, width = 120, height = 13,
		labels = { "Square", "Hexagonal" },
		selection = 1,
		change =
			function(self)
				if self.selection == 1 then config.tiling = "square"
				elseif self.selection == 2 then config.tiling = "hex"
				end
			end,
	}) 
	gui:attach(ui_label {
		x = (480 // 2) - (120 // 2), y = 75, width = 120, height = 13,
		label = "Colours",
		centered = true,
	})
	gui:attach(ui_hchoice {
		x = (480 // 2) - (100 // 2), y = 90, width = 100, height = 13,
		labels = { "5", "6", "7", "8" },
		selection = 2,
		change =
			function(self)
				config.number_of_colours = clamp(self.selection + 4, 5, 8)
			end,
	}) 
	gui:attach(ui_label {
		x = (480 // 2) - (120 // 2), y = 125, width = 120, height = 13,
		label = "Columns",
		centered = true,
	})
	gui:attach(ui_hchoice {
		x = (480 // 2) - (220 // 2), y = 140, width = 220, height = 13,
		labels = { "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", },
		selection = 1,
		change =
			function(self)
				config.columns = clamp(self.selection + 5, 6, 15)
			end,
	}) 
	gui:attach(ui_button {
		x = (480 // 2) - (60 // 2), y = 230, width = 60, height = 13,
		label = "Start",
		tap =
			function(self)
				start_requested = true
			end
	})
end


function in_prelaunch_endurance:exit()
end


function in_prelaunch_endurance:update()
	ui_update_all()
	if start_requested then
		return in_game
	end
end


function in_prelaunch_endurance:draw()
	gfx_draw_starry_background(0, 0, 480, 270)
	ui_draw_all()
end
:: src/in_prelaunch_waves.lua
--[[pod_format="raw",created="2024-09-21 11:32:35",modified="2025-05-12 08:03:48",revision=1722]]
in_prelaunch_waves = {}


local start_requested = false

local gui_tiling
local gui_colours
local gui_columns
local gui_speed


function in_prelaunch_waves:enter()
	config = {
		tiling = "square",
		number_of_colours = 6,
		columns = 6,
		gravity = pos(0, 1),
		speed = 0.3,
		speed_increase = 0.000,
		column_increase = false,
		fail_top = true,
		clear_zone = 268 - 4 * 25,
		combo_pause = false,
	}
	color_gem_skin = 5


	gfx_seed_the_stars()
	start_requested = false
	local gui = ui_create_root()
	gui:attach(ui_label {
		x = (480 // 2) - (120 // 2), y = 10, width = 120, height = 13,
		label = "Game Mode: Waves",
		centered = true,
	})
	
	gui:attach(ui_label {
		x = (480 // 2) - 120, y = 50, width = 120, height = 13,
		label = "Shape of the gems:",
	})
	gui_tiling = ui_hchoice {
		x = (480 // 2), y = 50, width = 120, height = 13,
		labels = { "Squares", "Hexagons" },
		selection = 1,
	}
	gui:attach(gui_tiling)
	
	gui:attach(ui_label {
		x = (480 // 2) - 120, y = 80, width = 120, height = 13,
		label = "Number of colours:",
	})
	gui_colours = ui_hchoice {
		x = (480 // 2), y = 80, width = 120, height = 13,
		labels = { "5", "6", "7", "8" },
		selection = 2,
	}
	gui:attach(gui_colours)
	
	gui:attach(ui_label {
		x = (480 // 2) - 120, y = 110, width = 120, height = 13,
		label = "Width of the waves:",
	})
	gui_columns = ui_hchoice {
		x = (480 // 2), y = 110, width = 120, height = 13,
		labels = { "S", "M", "L", "XL", },
		selection = 1,
	}
	gui:attach(gui_columns)
	
	gui:attach(ui_label {
		x = (480 // 2) - 120, y = 140, width = 120, height = 13,
		label = "Speed:",
	})
	gui_speed = ui_hchoice {
		x = (480 // 2) - 70, y = 140, width = 300, height = 13,
		labels = { "300", "325", "350", "375", "400", "425", "450", "475", "500",
			"525", "550", "575", "600", },
		selection = 1,
	}
	gui:attach(gui_speed)

	gui:attach(ui_button {
		x = (480 // 2) - (60 // 2), y = 230, width = 60, height = 13,
		label = "Start",
		tap =
			function(self)
				start_requested = true
			end
	})
end


function in_prelaunch_waves:exit()
end


function in_prelaunch_waves:update()
	ui_update_all()
	if start_requested then
		if gui_tiling.selection == 1 then
			config.tiling = "square"
			color_gem_skin = 0
		elseif gui_tiling.selection == 2 then
			config.tiling = "hex"
			color_gem_skin = 4
		end

		config.number_of_colours = clamp(gui_colours.selection + 4, 5, 8)

		config.columns = clamp(4 + 2 * gui_columns.selection, 6, 15)
		if config.tiling == "hex" then
			config.columns += 1
		end
		
		local speed_min = 0.300
		local speed_increment = 0.025
		config.speed = speed_min + speed_increment * (gui_speed.selection - 1)
		
		return in_game
	end
end


function in_prelaunch_waves:draw()
	spr(112, 0, 0)
--	gfx_draw_starry_background(0, 0, 480, 270)
	ui_draw_all()
end
:: src/sgrid.lua
--[[pod_format="raw",created="2024-08-24 07:17:45",modified="2025-05-12 08:03:48",revision=6358]]
--- Square Grids

--- The origin of the grid, `pos(0, 0)`, is at the top left.


---------------------------------------------------------------------------


local max_width <const> = 14
local max_height <const> = 12

local dx <const> = 25
local dy <const> = 25

local gem_offset_x = -1
local gem_offset_y = -1


----------------------------------------------------------------------------


local metatable = {}


function metatable:new_grid()
	return sgrid_new()
end


function sgrid_new()
	local grid = {}
	setmetatable(grid, { __index = metatable })
	for i = 0, max_width * max_height do
		grid[i] = false
	end
	return grid
end


function metatable:clone()
	local grid = self:new_grid()
	grid.origin = self.origin
	self:foreachpos(function(p, item) grid:set(p, item) end)
	return grid
end


-------------------------------------------------------------------------------


function metatable:tiling()
	return "square"
end


function metatable:max_width()
	return max_width
end


function metatable:max_height()
	return max_height
end


--------------------------------------------------------------------------------


function metatable:get(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	return self[p.x + (p.y * max_width)]
end


function metatable:set(p, value)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	self[p.x + (p.y * max_width)] = value
end


function metatable:merge(p, state)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	local index = p.x + (p.y * max_width)
	if not self[index] then
		self[index] = {}
	end
	for k, v in pairs(state) do
		self[index][k] = v
	end
end


function metatable:del(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	self[p.x + (p.y * max_width)] = false
end


function metatable:distance(p0, p1)
	return abs(p0.x - p1.x) + abs(p0.y - p1.y)
end


-------------------------------------------------------------------------------


local function compute_screen_size(self)
	local min_p = pos(max_width, max_height)
	local max_p = pos(0, 0)
	self:foreachpos(
		function(position, cell)
			if not cell or cell == 0 then
				return
			end
			if position.x < min_p.x then min_p.x = position.x end
			if position.y < min_p.y then min_p.y = position.y end
			if position.x > max_p.x then max_p.x = position.x end
			if position.y > max_p.y then max_p.y = position.y end
		end
	)
	local width = 1 + max_p.x - min_p.x
	local height = 1 + max_p.y - min_p.y
	return min_p, max_p, width, height
end


function metatable:set_center_coords(x, y)
	local min_p, max_p, width, height = compute_screen_size(self)
	self.origin = {
		x = x - ((width * dx) // 2) - (min_p.x * dx),
		y = y - ((height * dy) // 2) - (min_p.y * dy),
	}
	self.screen_width = width * dx + 1
	self.screen_height = height * dy
end


function metatable:set_bottom_center_coords(x, y)
	local min_p, max_p, width, height = compute_screen_size(self)
	self.origin = {
		x = x - ((width * dx) // 2) - (min_p.x * dx),
		y = y - (max_p.y * dy) - dy,
	}
	self.screen_width = width * dx + 1
	self.screen_height = height * dy
end


function metatable:offset_coords(x, y)
	self.origin.x += flr(x * dx)
	self.origin.y += flr(y * dy)
end


function metatable:coords_cell(p)
	return self.origin.x + p.x * dx, self.origin.y + p.y * dy
end


function metatable:coords_gem(p)
	return self.origin.x + p.x * dx + gem_offset_x,
		self.origin.y + p.y * dy + gem_offset_y
end


function metatable:pos(x, y)
	return pos((x - self.origin.x) // dx, (y - self.origin.y) // dy)
end


----------------------------------------------------------------------------


function metatable:foreachpos(func)
	local p = pos(0, 0)
	for x = 0, max_width do
		for y = 0, max_height do
			local p = pos(x, y)
			local item = self:get(p)
			if item then
				local stop_requested = func(p, item)
				if stop_requested then
					return
				end
			end
		end
	end
end	


function metatable:neighbours(p)
	return {
		{ position = p + pos(1, 0), direction = "horizontal" },
		{ position = p + pos(0, 1), direction = "vertical" },
		{ position = p + pos(-1, 0), direction = "horizontal" },
		{ position = p + pos(0, -1), direction = "vertical" },
	}
end


function metatable:blast_radius(p)
	return {
		p + pos(0, 0),
		p + pos(1, 0),
		p + pos(1, 1),
		p + pos(0, 1),
		p + pos(-1, 1),
		p + pos(-1, 0),
		p + pos(-1, -1),
		p + pos(0, -1),
		p + pos(1, -1),
	}
end

:: src/ui.lua
--[[pod_format="raw",created="2024-09-20 07:57:16",modified="2025-05-12 08:03:48",revision=1983]]
local gui = false


function ui_create_root()
	gui = create_gui()
	return gui
end


function ui_delete_root()
	gui = false
end


function ui_update_all()
	gui:update_all()
end


function ui_draw_all()
	gui:draw_all()
end


------------------------------------------------------------------------


local function panel_draw(self)
	rectfill(0, 0, self.width, self.height, 60)
end


function ui_panel(el)
	el = el or {}
	el.draw = el.draw or panel_draw
	gui:new(el)
	return el
end


------------------------------------------------------------------------


local function label_draw(self)
	local x = 2
	if self.centered then
		x = (self.width - (5 * #self.label)) // 2
	end
	local y = (self.height - 6) // 2
	cursor(x, y, 7)
	print(self.label)
end


function ui_label(el)
	el = el or {}
	el.label = el.label or ""
	el.draw = el.draw or label_draw
	gui:new(el)
	return el
end


------------------------------------------------------------------------


local function button_draw(self)
	if self.clicked then
		if self.sprite_clicked then
			spr(self.sprite_clicked, 0, 0)
		else
			rectfill(0, 0, self.width, self.height, 49)
		end
	else
		if self.sprite then
			spr(self.sprite, 0, 0)
		else
			rectfill(0, 0, self.width, self.height, 50)
		end
	end
	local x = (self.width - (5 * #self.label)) // 2
	local y = (self.height - 6) // 2
	cursor(x, y, 1)
	print(self.label)
end


local function button_click(self)
	self.clicked = true
end

local function button_release(self)
	self.clicked = false
end


function ui_button(el)
	el = el or {}
	el.label = el.label or ""
	if el.sprite then
		local s = get_spr(el.sprite)
		el.width = el.width or s:width()
		el.height = el.height or s:height()
	end
	el.cursor = el.cursor or "pointer"
	el.draw = el.draw or button_draw
	el.click = el.click or button_click
	el.release = el.release or button_release
	gui:new(el)
	return el
end


------------------------------------------------------------------------


local function hchoice_draw(self)
	local part_width = self.width // (#self.labels)
	for i, label in ipairs(self.labels) do
		local x = (i - 1) * part_width
		local bg = 50
		if self.selection == i then
			bg = 55
		elseif self.clicked_choice == i then
			bg = 49
		end
		rectfill(x, 0, x + part_width - 2, self.height, bg)
		local label_x = x + ((part_width - (5 * #label)) // 2)
		local label_y = (self.height - 6) // 2
		cursor(label_x, label_y, 1)
		print(label)
	end
end


local function hchoice_click(self, msg)
	local part_width = self.width // (#self.labels)
	self.clicked_choice = 1 + (msg.mx // part_width)
end


local function hchoice_tap(self, msg)
	local part_width = self.width // (#self.labels)
	self.selection = 1 + (msg.mx // part_width)
	self:change()
end


local function hchoice_release(self)
	self.clicked_choice = false
end


function ui_hchoice(el)
	el = el or {}
	el.labels = el.labels or {}
	el.cursor = el.cursor or "pointer"
	el.draw = el.draw or hchoice_draw
	el.click = el.click or hchoice_click
	el.tap = el.tap or hchoice_tap
	el.release = el.release or hchoice_release
	el.change = el.change or function(self) end
	gui:new(el)
	return el
end

:: src/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTI0IDA3OjE3OjA5Iixtb2RpZmllZD0iMjAyNS0w
NS0xMiAwODowMzo0OSJdXQ==
:: debug.lua
--[[pod_format="raw",created="2024-08-24 12:45:09",modified="2025-05-12 08:03:48",revision=159]]
-- Detect uninitialized globals and typos
-- from @snowkittykira from the BBS


-- if you're using include(), include this after including everything else,
-- since most included modules will need to assign global variables on load

-- these globals are needed by picotron
_init = _init or false
_draw = _draw or false
_update = _update or false
-- these are used by the picotron terminal
cproj_draw = cproj_draw or false
cproj_update = cproj_update or false
_ = _ or false
_is_terminal_command = _is_terminal_command or false
k = k or false
res = res or false
-- gui needs these
drag_t = drag_t or false

local function unknown_variable (t, k)
  error (debug.traceback ('unknown variable ' .. tostring (k), 2))
end

setmetatable (_G, {
  __index = unknown_variable,
  __newindex = unknown_variable,
})
:: drakma.lua
b64$LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNC0wNC0wNyAwNzo0Mjo0NSIsbW9k
aWZpZWQ9IjIwMjUtMDUtMTIgMDg6MDM6NDgiLHJldmlzaW9uPTIxODhdXQpfbW9kdWxlcyA9IHt9
CgotLSBBICdyZXF1aXJlJyBmdW5jdGlvbiBzaW1pbGFyIHRvIHN0YW5kYXJkIEx1YS4KLS0gSWRl
YSBmcm9tIGVsZ29waGVyIG9uIHRoZSBCQlMKZnVuY3Rpb24gcmVxdWlyZShuYW1lKQoJbG9jYWwg
Y2FjaGVkID0gX21vZHVsZXNbbmFtZV0KCWlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQKCglsb2Nh
bCBmaWxlbmFtZSA9IGZ1bGxwYXRoKG5hbWUgLi4gJy5sdWEnKQoJbG9jYWwgc3JjID0gZmV0Y2go
ZmlsZW5hbWUpIAoKCWlmICh0eXBlKHNyYykgIT0gInN0cmluZyIpIHBhbmljKCJjb3VsZCBub3Qg
aW5jbHVkZSAiIC4uIGZpbGVuYW1lKQoKCS0tIGh0dHBzOi8vd3d3Lmx1YS5vcmcvbWFudWFsLzUu
NC9tYW51YWwuaHRtbCNwZGYtbG9hZAoJLS0gY2h1bmsgbmFtZSAoZm9yIGVycm9yIHJlcG9ydGlu
ZykKCS0tIG1vZGUgKCJ0IiBmb3IgdGV4dCBvbmx5IC0tIG5vIGJpbmFyeSBjaHVuayBsb2FkaW5n
KQoJLS0gX0VOViB1cHZhbHVlCgktLSBAIGlzIGEgc3BlY2lhbCBjaGFyYWN0ZXIgdGhhdCB0ZWxs
cyBkZWJ1Z2dlciB0aGUgc3RyaW5nIGlzIGEgZmlsZW5hbWUKCWxvY2FsIGZ1bmMsIGVyciA9IGxv
YWQoc3JjLCAiQCIgLi4gZmlsZW5hbWUsICJ0IiwgX0VOVikKCWlmIChub3QgZnVuYykgcGFuaWMo
IlN5bnRheCBlcnJvcjoiLCB0b3N0cihlcnIpKQoKCWxvY2FsIG1vZHVsZSA9IGZ1bmMoKQoJX21v
ZHVsZXNbbmFtZV0gPSBtb2R1bGUKCglyZXR1cm4gbW9kdWxlCmVuZAoKCmZ1bmN0aW9uIHBhbmlj
KC4uLikKCWxvY2FsIGFyZ3MgPSB7IC4uLiB9Cglmb3JlYWNoKAoJCWFyZ3MsCgkJZnVuY3Rpb24o
c3RyKQoJCQlzZW5kX21lc3NhZ2UoMywgeyBldmVudCA9ICJyZXBvcnRfZXJyb3IiLCBjb250ZW50
ID0gc3RyIH0pCgkJZW5kCgkpCglzdG9wKCkKZW5kCgoKLS0gVGFibGUgdXRpbGl0eSBmdW5jdGlv
bnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0KCgpmdW5jdGlvbiBpc19lbXB0eSh0KQoJcmF3ZXF1YWwobmV4dCh0KSwgbmlsKQplbmQKCmZ1
bmN0aW9uIGRlZXBfY29weSh0LCBhbHJlYWR5KQoJaWYgKG5vdCBhbHJlYWR5KSBhbHJlYWR5ID0g
e30KCWlmIHR5cGUodCkgPT0gInRhYmxlIiB0aGVuCgkJaWYgYWxyZWFkeSBhbmQgYWxyZWFkeVt0
XSB0aGVuCgkJCXJldHVybiBhbHJlYWR5W3RdCgkJZW5kCgkJbG9jYWwgbmV3ID0ge30KCQlhbHJl
YWR5W3RdID0gbmV3CgkJZm9yIGssIHYgaW4gcGFpcnModCkgZG8KCQkJbmV3W2tdID0gZGVlcF9j
b3B5KHYsIGFscmVhZHkpCgkJZW5kCgkJcmV0dXJuIG5ldwoJZWxzZQoJCXJldHVybiB0CgllbmQK
ZW5kCgoKZnVuY3Rpb24gdG9zdHJyZWModCkKCWlmIHR5cGUodCkgIT0gInRhYmxlIiB0aGVuCgkJ
cmV0dXJuIHRvc3RyKHQpCgllbmQKCQoJbG9jYWwgcyA9IG5pbAoJZm9yIGssIHYgaW4gcGFpcnMo
dCkgZG8KCQlpZiBub3QocykgdGhlbgoJCQlzID0gInsgIgoJCWVsc2UKCQkJcyAuLj0gIiwgIgoJ
CWVuZAoJCXMgLi49IHRvc3RyKGspIC4uICIgPSAiIC4uIHRvc3RycmVjKHYpCgllbmQKCWlmIG5v
dCBzIHRoZW4KCQlyZXR1cm4gInt9IgoJZW5kCglzIC4uPSAiIH0iCgoJcmV0dXJuIHMKZW5kCgoK
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCgpsb2NhbCBiaXRfbm9pc2VfMSA8Y29uc3Q_ID0gMHg2
OGUzMWRhNGI1Mjk3YTRkCmxvY2FsIGJpdF9ub2lzZV8yIDxjb25zdD4gPSAweGI1Mjk3YTRkMWI1
NmM0ZTkKbG9jYWwgYml0X25vaXNlXzMgPGNvbnN0PiA9IDB4MWI1NmM0ZTk2OGUzMWRhNApmdW5j
dGlvbiBub2lzZTFkKHBvc2l0aW9uLCBzZWVkKQoJbG9jYWwgbWFuZ2xlZF9iaXRzID0gZmxyKHBv
c2l0aW9uKQoJbWFuZ2xlZF9iaXRzICo9IGJpdF9ub2lzZV8xCgltYW5nbGVkX2JpdHMgKz0gc2Vl
ZAoJbWFuZ2xlZF9iaXRzIF5ePSAobWFuZ2xlZF9iaXRzID4_IDgpCgltYW5nbGVkX2JpdHMgKz0g
Yml0X25vaXNlXzIKCW1hbmdsZWRfYml0cyBeXj0gKG1hbmdsZWRfYml0cyA8PCA4KQoJbWFuZ2xl
ZF9iaXRzICo9IGJpdF9ub2lzZV8zCgltYW5nbGVkX2JpdHMgXl49IChtYW5nbGVkX2JpdHMgPj4g
OCkKCXJldHVybiBtYW5nbGVkX2JpdHMKZW5kCgoKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCgpm
dW5jdGlvbiBjbGFtcCh2LCBtaW4sIG1heCkKCWlmIHYgPCBtaW4gdGhlbgoJCXJldHVybiBtaW4K
CWVuZAoJaWYgdiA_IG1heCB0aGVuCgkJcmV0dXJuIG1heAoJZW5kCglyZXR1cm4gdgplbmQKCgpm
dW5jdGlvbiBleHBfZGVjYXkoYSwgYiwgZGVjYXksIGR0KQoJLS0tIExlcnAgc21vb3RoaW5nLCBi
dXQgZnJhbWVyYXRlLWluZGVwZW5kYW50LCBmcm9tIEZyZXlhIEhvbG3DqXIKCS0tLSBodHRwczov
L3d3dy55b3V0dWJlLmNvbS93YXRjaD92PUxTTlF1RkVET3lRCgktLS0gVXNlIGFzIGBhID0gZXhw
X2RlY2F5KGEsIGIsIGRlY2F5LCBkdClgCglyZXR1cm4gYiArIChhIC0gYikgKiBtYXRoLmV4cCgt
IGRlY2F5ICogZHQpCmVuZAoKCi0tIFBvcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKCi0tIFdBUk5JTkc6
IGRvIG5vdCBmb3JnZXQgdGhhdCBgcG9zYCBpcyBhIHJlZmVyZW5jZSB0eXBlLCBub3QgYSB2YWx1
ZToKLS0gYXZvaWQgbW9kaWZ5aW5nIGluIHBsYWNlLgpmdW5jdGlvbiBwb3MoeCwgeSkKCWxvY2Fs
IHAgPSB1c2VyZGF0YSgiaTE2IiwgMikKCXAueCA9IHgKCXAueSA9IHkKCXJldHVybiBwCmVuZAoK
ZnVuY3Rpb24gZXFfcG9zKHAxLCBwMikKCXJldHVybiBwMS54ID09IHAyLnggYW5kIHAxLnkgPT0g
cDIueQplbmQKCgotLSBEcmF3aW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCgotLSBGcm9tIFNvcGhpZSBv
biB0aGUgZGlzY29yZApmdW5jdGlvbiBnZXRfZHJhd3NwYWNlKCkKICAgIHJldHVybiB7CiAgICAg
ICAgY2FtX3g9cGVlazQoMHg1NTEwKSwKICAgICAgICBjYW1feT1wZWVrNCgweDU1MTQpLAogICAg
ICAgIGNsaXBfbD1wZWVrMigweDU1MjgpLAogICAgICAgIGNsaXBfdD1wZWVrMigweDU1MmEpLAog
ICAgICAgIGNsaXBfcj1wZWVrMigweDU1MmMpLAogICAgICAgIGNsaXBfYj1wZWVrMigweDU1MmUp
LAogICAgfQplbmQKCgpmdW5jdGlvbiBzZXRfZHJhd3NwYWNlKGRyYXdzcGFjZSkKICAgIHBva2U0
KDB4NTUxMCxkcmF3c3BhY2UuY2FtX3gpCiAgICBwb2tlNCgweDU1MTQsZHJhd3NwYWNlLmNhbV95
KQogICAgcG9rZTIoMHg1NTI4LGRyYXdzcGFjZS5jbGlwX2wpCiAgICBwb2tlMigweDU1MmEsZHJh
d3NwYWNlLmNsaXBfdCkKICAgIHBva2UyKDB4NTUyYyxkcmF3c3BhY2UuY2xpcF9yKQogICAgcG9r
ZTIoMHg1NTJlLGRyYXdzcGFjZS5jbGlwX2IpCmVuZA==
:: main.lua
--[[pod_format="raw",created="2024-03-30 05:39:34",modified="2025-05-12 08:03:48",revision=8393]]
include "drakma.lua"
include "src/constants.lua"
include "src/sgrid.lua"
include "src/hgrid.lua"
include "src/ui.lua"
include "src/logic/creation.lua"
include "src/logic/matching.lua"
include "src/logic/spells.lua"
include "src/logic/mechanics.lua"
include "src/gfx.lua"
include "src/in_game.lua"
include "src/in_mode_selection.lua"
include "src/in_prelaunch_endurance.lua"
include "src/in_prelaunch_waves.lua"
--include "debug.lua"


local state = in_prelaunch_waves --- in_mode_selection
local next_state = false


function _init()
	window { cursor = "" }
	fetch("pal/0.pal"):poke(0x5000)
	for c = 0, 63 do
		for i = 0, 63 do
			poke(0xa000 + (c * 64) + i, i - 1)
			poke(0xb000 + (c * 64) + i, i + 1)
		end
	end
	state:enter()
end


function _update()
	if next_state then
		state:exit()
		state = next_state
		state:enter()
	end
	next_state = state:update()
end


function _draw()
	state:draw()
	print(string.format("\014% 3.0f%%", stat(1) * 100.0), 4, 256, 7)
	print(string.format("\014% 3.1fMB", stat(0) / (1024 * 1024)), 4, 262, 7)
end
:: .info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTIzIDE4OjQ1OjEzIixtb2RpZmllZD0iMjAyNS0w
NS0xMiAwODowMzo0OSIscnVudGltZT0xOCxzdG9yZWQ9IjIwMjQtMDMtMzAgMDY6NTQ6MjQiLHdv
cmtzcGFjZXM9e3tsb2NhdGlvbj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn0se2xvY2F0
aW9uPSJzZngvMC5zZngiLHdvcmtzcGFjZV9pbmRleD00fSx7bG9jYXRpb249Im1haW4ubHVhIix3
b3Jrc3BhY2VfaW5kZXg9N30se2xvY2F0aW9uPSJwYWwvMC5wYWwiLHdvcmtzcGFjZV9pbmRleD04
fX1dXQ==
:: [eoc]
