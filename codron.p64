picotron cartridge // www.picotron.net
version 2

:: fonts/
:: fonts/cozi.font
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTIxIDE5OjIyOjIwIixtb2RpZmllZD0iMjAyNS0w
My0yNyAxNTowNToxNCIscmV2aXNpb249MTBdXWx6NACeAwAAOgcAAPIicHh1AAMoAAgAAAQFCgsA
AQOQD4APmD_ID4APj3_ID4kviA-4D4gPmC_ID4kPmG_ICA8A8KsPiAAeD5gIHg_J8DBvPyAtQA0P
Mw1ADA8MDEAMAAxALDAPMA88DQkPMCADDw8NBwMQDz4-BkA-MA8_AA9jDzYPHA8_CAYIMA8YgA8M
DxhQHwwgGkAPBAoEsEIAAgAVcAoPHwoLChAEDw4PAQ8GCA8HBBAPCQQCASACBQIPCwUKABRQBFIE
AlQCEAUCDwcCBTAEDw4EYBQCMAeAAhAUEh8BAA8GAQ8NDwsRDwYABA40Dw4ADgEIBAIPAQcJAPIz
DggBDgAEDhUHFAAHHA8HGAkADhwJEQ4ABxgEIgAOEQ4RDgAOEQ8OGA4wAgACQAQAFAIQBAIMAgQw
BwAHMAIECAQCTwDwGAACAA0PER8dDw0MDQAOEQchAAkRCREJAA4BLAEOAAlBCQAHHAkcBwYAkCwA
DRwDEQ0AISUA8BVCCQANOAEOABEFDwMFEQBcBwAPEQ8bHxUvEQABDwsDMQAOQQ5LAPEBLAAOMQYO
DwwJEQkhAA4BDLgA8GAPH1QAUQ0AQQUPAwAvER8VDxsPEQAhDiEAIQ0YCQAHCAQCHAcACVwJABwS
FAANWA0CBbAHAAIEcA0hDQAcCSEJIA0sDQAYDSENIA4BBwwNAA8MEgciEA0hDQgOHAkxAAIADwMi
CQAIAA8MKAEOHAGjAPAnAQALQg8MIAYfFR8RIAkxIA4hDhAJIQkcAA0hDRgQAwssIA0MDggJABIH
Ig8MIDENICEFCyAfnAD2HgogEQ4REDENCA4QBwgODAcADhIMIg5yDhQIJA4gDg8VDwwgGxogb38A
D1UPKgQA8AgAD0EPYw9-H10Pdw8_AAYfYw93Bg9BBicBFkQEAPAPAAQKD3wGDx8PGA8QAA8cDyYf
Xw9-Bg8cAA8iD3cfCgChCAAPKg8cDzYPd3QC8AEqAB8cBg9dDxwfFAAIDxwGLgCxKg86AAYPZw9j
D2djABEGdwDxBX8PYwYADxgPeCgHCQAGD2MPaw9jHwDzCAgPFA8qD10PKg8UCDAPVTAGD3MPYw9z
HAAxHA9-bwDxBCIQD38PIg8UCAMPIg9-AAYPdx8-APMCEA8KBAAPUA8gEA8RDyoPRAAHAHEGD2sP
dw9rRgBBD38ABQIA9AJvVRAPfg9CD1IPSg9CD34QAQwAQAEQAQ0KAB8NCQD---9oUA9KDQEA
:: fonts/p9.font
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTIzIDIxOjQzOjIxIixtb2RpZmllZD0iMjAyNS0w
My0yNyAxNTowNToxNCIscmV2aXNpb249NDldXWx6NACBBQAApgUAAPCPcHh1AAMoAAgAAAQECAYQ
A-ABD5DwBglgDyAwDvA0RzAnQAcFB0AFAgVABQAFQCUwBAYHBgQgAQMHAwEgByFAJAcgBQcCBwJA
AnABAlATIBVQAgUCwCIAAiAVUAUHBQcFIAcDBgcCIAUEAgEFIBMGBQcgAgFQAiECIAIkAiAFAgcC
BTACBwJgAgFAB4ACIBgUEhAHJQcgAyIHIAcEBwEGAPEJBgQHIBUHFCAHAQcEByARBwUHIAc0IAcF
CQDwDQUHFDACAAJAAgACASAEAgECBDAHAAcwAQIEAgE8APA0AAIgAhUBBjAGBQcFMBMFBzAGEQYw
AxUDMAcDAQYwBwMRMAYBBQcwFQcFMAcSBzAHEgMwBQMVMCEGMBcVMAMlMAYVAzwA8BUBMAIFAwYw
AwUDBTAGAQQDMAciMCUGMBUHAjAVFzAFEgUwBQcWAPEgBAEHIAMhAyASFBgQBiQGIAIFkAcgAgRQ
BwUHFSAHBQMFByAGIQYgAyUHIAcBAwEGAFARIAYRBeMAMBUgB-cA8AgiAyAVAxUgMQcgDw8vFQ8R
IAM1IAYlA_wAYBEgAhUDBkkA8A4VIAYBBwQDIAcyIDUGICUHAiAdHxUPDyAVAhUgFSgB8hQHBAIB
ByAGAgMCBiBCIAMCBgIDMAQHAUACBQIwT38gD1UPKgQA8EkgD0EPfx9dDz4gDB9jD3cMIA0PRA0L
DSAEDzwPHA8eDxAgDxwPLhwPHCAPNhwPHAggCg82D3cPNgogGgwKDxQgCgwPfw8qDzogDA9nD2MP
ZwwgD38PXQ9-VwDwESAPOBgfDiAMD2MPaw9jDCAICgwKCEAPVUAMD3MPYw9zEgDwFQ9-DA8iIAwK
CAoMIAwPdx9jDDAFD1IOQA0PKgswDA9rD3cPa1QA8DkACQAJIE9VIA8OBA8eDy0PJiANHyEPJQIg
DwwPHh4KIAgGCA8kDxogD04EDA9FDyYgDyIPXx8SDwogBggPPA0PBiAPEA8MAgPRAPB4Ig96HyIP
EiAGDgACDzwgCAcPEAIDICIPIgogCAwIAwggDxIPPw8SAgogBw8QD34EDzggAg8HDzICASAPDwIP
Dg8QCiAMH0AODxggDA8QGAUgCA84BAIHIAEPBw8SD3gPGCAPeg9CAg8KD3IgDwkMD0sPbQ9mIA8a
DycPIg9zASAHD0ofSQ9GZwAROgQA8WMaIA8jD2IfIgogAwAIDyoPTTADDxIPIQ9AIA99D3kNDz0P
XSAMBwgGDy4gDwYPJA9_DyYFIA8kD04ED0YHIA8KBw9aD0YPMCAGBAYPRA84IA8UDA8kGCAPOg9W
D1IPMAggBAoEBg8GIAgCDA4KIB8iDya8APICCw8kD3IPMCAEDzYPLA8mD2QTADRCDzCtAPBNIw8S
IA8OD2QKDygPeCAEAg8GDysPGUAPDgUIMA8KDx8PEgQwBA8PDxUPDTAEAw8GDw4gDA4PFAQCIA8w
CA8OGCAIDA8iDgsgDCgMIAUPfgsPFA8SIAQMDyQPIgFsAUAMCCAHDQDxAAUIIAQPfA8SBQggDC4M
IOMA8QIkDgUgDwYODyYFAyAMDgULCTkAAI0BIA8iHQDwBAMgDA8iDy0PMAMgCggMCAQgHyoVACAK
AAwA4BQKDyQEIAgMGAQwChAMlQBAKAUPLI8A8w0wD14IIC4FDw4gBR8kD0QPQiACBhIKIAweBQMg
dgFhMAgMCB8qygCxCAUgBwAMAAYgCAQaAUB_IA9ASwBRaA8GIAacBACVAPATFCAKJQwgBgUGBQYg
DAAMDgsgLQ4FIC8UD1QPMiASDyIPEhkBYS8iDCAMAbkA8BIOBw4LIA8GHgUPDjAPFQUIDwYwBAYP
FARAAwgGMAoLBQpwAKBjBQggCAUJBAgg
:: fonts/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTIzIDIxOjM2OjMxIixtb2RpZmllZD0iMjAyNS0w
My0yOCAxOTo1MjowMSJdXQ==
:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTIyIDE2OjAzOjQ4Iixtb2RpZmllZD0iMjAyNS0w
My0yOCAxOTo1MjowMSIscmV2aXNpb249NTU3NV1dbHo0AEIBAAChMgAA8yF7WzBdPXtibXA9cHh1
AEMgEBAE8FYHEAfAF9AXwAcQB-BWLGZsYWdzPTAscGFuX3gIAMd5PTAsem9vbT04fSw_AJEICARw
JxBHMDcCAE9HECdwPgALSzE2fSx9AB-wcAAMDzEA788LCwTwE2fgZ_Bn8BM4AAstMTA5APECCCcA
B2AXEAdABwAHIAcwB0AEAI9AByAHYCfwCk8AHvEACwdwBwAHAAdgJ1BnUCdgDABPcAfwC0kAHfIB
wDdgBxAXUAcQBwAHQAcQN5kAEJAGAG83ACeAB8BRAA0OUwEPMgCw-wMLCwQgEQARUAEHAQcBYAEH
AXAEAAQRYCIAX1ARABEgYQAMHzKTAB8PMgD-----------------------------------------
--------------------lFA9MTB9fQ==
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTIyIDE3OjM3OjMxIixtb2RpZmllZD0iMjAyNS0w
My0yOCAxOTo1MjowMSJdXQ==
:: map/
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTI3IDE1OjA4OjIyIixtb2RpZmllZD0iMjAyNS0w
My0yOCAxOTo1MjowMSIscmV2aXNpb249MTE1OF1dbHo0AGgAAABYEAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD--------------------78QgiKSxoaWRkZW49ZmFsc2UscGFuX3g9
MAgA0nk9MCx0aWxlX2g9MTYKABB3CgCAem9vbT0xfX0=
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTI3IDE1OjA4OjIyIixtb2RpZmllZD0iMjAyNS0w
My0yOCAxOTo1MjowMSJdXQ==
:: sfx/
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTI3IDE1OjA4OjIyIixtb2RpZmllZD0iMjAyNS0w
My0yOCAxOTo1MjowMSIscmV2aXNpb249MTE1OF1dbHo0AKAAAAALCgAA-zBweHUAAygAAAQABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDQA8PkAQFBgdADJAICQoLQAyQDwwPDQ8ODEAM8P8BAOv-J6oB
EAYPIBABIAEgAfAAAhACDhABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDjAA----
--_9H-8BAKzPyA9AAA8QQP--sPD-AQD-6lD-----KQ==
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTI3IDE1OjA4OjIyIixtb2RpZmllZD0iMjAyNS0w
My0yOCAxOTo1MjowMSJdXQ==
:: src/
:: src/ui/
:: src/ui/editor.lua
--[[pod_format="raw",created="2025-03-23 10:19:52",modified="2025-03-28 19:52:01",revision=5458]]
-------------------------------------------------------------------------------------------


local app = require "src/app.lua"
local buffers = require "src/buffers.lua"
local workspace = require "src/workspace.lua"
local rowbox = require "src/ui/rowbox.lua"
local findbox = require "src/ui/findbox.lua"


-------------------------------------------------------------------------------------------


local margin_width <const> = 19 -- 19 or 26
local scrollbar_width <const> = 7
local min_edge_distance <const> = 26


local cursor_width <const> = 4
local cursor_height <const> = 11


-------------------------------------------------------------------------------------------


local show_line_numbers = false


local show_cursors_in_scrollbar = true
local show_sections_in_scrollbar = false


-------------------------------------------------------------------------------------------


return function(attribs)
	local result = attribs or {}
	result.x = result.x or 0
	result.y = result.y or 0
--	result.width_rel = 1
--	result.width_add = -result.x
	result.width = 480 - 60
	result.height_rel = 1
	result.cursor = get_spr(16)
	head():new(result)

	local rowbox = result:attach(rowbox { x = 0, y = 0 })
	local findbox = result:attach(findbox { editor = result, x = 0, y = 0 })

	-- Private fields
	local blink_timer = 0
	local freewheel_last_dy = 0
	local freewheel_velocity = 0.0
	local freewheel_acceleration = 0.0
	local last_command = nil
	

	local function get_margin_width()
		if show_line_numbers then
			return margin_width
		end
		return 0
	end
	

	function result:show_cursor(keep_edge_distance)
		local edge_distance = keep_edge_distance and min_edge_distance or 0
		local buf = workspace.current_buffer()
		local col, row = buf:active_cursor_pos()
		local y = buf:find_cursor_y(row)
		if y - edge_distance < buf.offset_y then
			buf.offset_y = y - 2 - edge_distance
			buf.offset_y = max(- 4, buf.offset_y)
		elseif y + cursor_height - 2 + edge_distance > buf.offset_y + self.height then
			buf.offset_y = y + cursor_height - 2 + edge_distance - self.height
		end
		local x = buf:find_cursor_x(col, row)
		if x - 4 < buf.offset_x then
			buf.offset_x = x - 4
		elseif x + cursor_width + 2 + scrollbar_width > buf.offset_x + self.width - get_margin_width() then
			buf.offset_x = x + cursor_width + 2 + scrollbar_width - self.width + get_margin_width()
		end
		buf:highlight(row)
		buf.highlighter_row = row
	end
	

	function result:center_cursor()
		if not self.height then return end -- when called from switch_to
		local buf = workspace.current_buffer()
		local col, row = buf:active_cursor_pos()
		local y = buf:find_cursor_y(row)
		buf.offset_y = y - (self.height // 2) - 11
		local x = buf:find_cursor_x(col, row)
		if x - 4 < buf.offset_x then
			buf.offset_x = x - 4
		elseif x + cursor_width + 2 + scrollbar_width > buf.offset_x + self.width - get_margin_width() then
			buf.offset_x = x + cursor_width + 2 + scrollbar_width - self.width + get_margin_width()
		end
		buf:highlight(row)
		buf.highlighter_row = row
	end
	

	function result:clamp_scrollbar_thumb()
		local buffer = workspace.current_buffer()
		buffer.offset_y = mid(-4, buffer.offset_y, max(-4, buffer:total_height() - self.height + min_edge_distance))
		buffer.offset_x = max(-4, buffer.offset_x)
		buffer.display_y = mid(-4, buffer.display_y, max(-4, buffer:total_height() - self.height + min_edge_distance))
		buffer.display_x = max(-4, buffer.display_x)
	end
	

	function result:hover(msg)
		self.cursor = get_spr(16)
		if msg.mx >= self.width - scrollbar_width then
			self.cursor = 1
			local total_height, thumb_y, thumb_height = self:compute_scrollbar_coords()
			if msg.my >= thumb_y and msg.my <= thumb_y + thumb_height then
				self.cursor = "grab"
			end
		end
	end


	function result:click(msg)
		if not msg.has_pointer then return end
		if msg.mx >= self.width - scrollbar_width then
			local total_height, thumb_y, thumb_height = self:compute_scrollbar_coords()
			if msg.my >= thumb_y and msg.my <= thumb_y + thumb_height then
				self.click_on_scrollbar_thumb = true
			else
				self.click_on_scrollbar_bg = true
			end
			return
		end
		if msg.mb == 2 then
			self.right_click_on_text = true
			return
		end
		if msg.mb == 1 then
			self:set_keyboard_focus(true)
			local buffer = workspace.current_buffer()
			local row = buffer:find_cursor_row(msg.my + buffer.offset_y)
			local col = buffer:find_cursor_col(row, msg.mx + buffer.offset_x - get_margin_width())
			if key("alt") then
				buffer:add_cursor(col, row)
				blink_timer = 0
			else
				buffer:set_cursor(col, row)
				blink_timer = 0
			end
			self.click_on_text = true
			self.ignore_first_drag_update = true
			last_command = nil
		end
	end


	function result:drag(msg)
		if self.click_on_scrollbar_thumb then
			local buffer = workspace.current_buffer()
			local total_height, thumb_y, thumb_height = self:compute_scrollbar_coords()
			thumb_y += msg.dy
			buffer.offset_y = math.floor(0.5 + (thumb_y * total_height) / self.height)
			buffer.display_y = math.floor(0.5 + (thumb_y * total_height) / self.height)
			self:clamp_scrollbar_thumb()
			return
		elseif self.click_on_scrollbar_bg and msg.mb == 1 then
			local buffer = workspace.current_buffer()
			local total_height, thumb_y, thumb_height = self:compute_scrollbar_coords()
			buffer.offset_y = math.floor(0.5 + (msg.my * total_height) / self.height)
			buffer.offset_y -= self.height // 2
			self:clamp_scrollbar_thumb()
			return
		end
		if self.right_click_on_text and msg.mb == 2 then
			local buffer = workspace.current_buffer()
			buffer.offset_y -= msg.dy
			self:clamp_scrollbar_thumb()
			freewheel_velocity = math.floor(0.5 + (msg.dy + freewheel_last_dy) / 2.0)
			freewheel_acceleration = 0.850 + 0.145 * mid(1, abs(msg.dy), 24) / 24.0
			freewheel_last_dy = msg.dy
			self.cursor = "grab"
			return
		end
		if not self.click_on_text then return end
		local buffer = workspace.current_buffer()
		local row = buffer:find_cursor_row(msg.my + buffer.offset_y)
		local col = buffer:find_cursor_col(row, msg.mx + buffer.offset_x - get_margin_width())
		local active_col, active_row = buffer:active_cursor_pos()
		if col ~= active_col or row ~= active_row then
			buffer:extend_active_selection(col, row)
		end
		if self.ignore_first_drag_update then
			self.ignore_first_drag_update = false
		elseif msg.my < 1 then
			buffer.offset_y -= 3
		elseif msg.my > self.height - 2 then
			buffer.offset_y += 3
		end
	end
	

	function result:release(msg)
		if self.click_on_text then
			self:show_cursor(false)
		end
		self.click_on_text = false
		self.click_on_scrollbar_thumb = false
		self.click_on_scrollbar_bg = false
	end
	

	function result:mousewheel(msg)
		local buffer = workspace.current_buffer()
		if not buffer then return end
		buffer.offset_y -= 24 * msg.wheel_y
		buffer.offset_x -= 6 * msg.wheel_x
		self:clamp_scrollbar_thumb()
	end

	
	function result:update(msg)
		rowbox.x = self.width - rowbox.width - scrollbar_width
		rowbox.y = self.height - rowbox.height
		findbox.width = 40 + 5 * #findbox:target()
		findbox.x = ((self.width - scrollbar_width) // 2) - (findbox.width // 2)
		findbox.y = self.height - findbox.height
	
		blink_timer += 1
		local buffer = workspace.current_buffer()

		local _col, row = buffer:active_cursor_pos()
		rowbox.content = string.format("%d", row)
				
		for i = 1, 5 do
			buffer:highlight(buffer.highlighter_row)
			buffer.highlighter_row += 1
			if buffer.highlighter_row > buffer:number_of_rows() then
				buffer.highlighter_row = 1
			end
		end
	
		if freewheel_velocity ~= 0 and msg.mb == 0 then
			buffer.offset_y -= freewheel_velocity
			self:clamp_scrollbar_thumb()
			freewheel_velocity *= freewheel_acceleration
			if abs(freewheel_velocity) < 0.5 then
				freewheel_velocity = 0.0
				freewheel_acceleration = 0.0
			end
		end
		
		local function lerp(start, fin, t)
		 return start * (1 - t) + fin * t	
		end
		local speed = findbox.hidden and 0.333333 or 0.2
		if abs(buffer.offset_y - buffer.display_y) < 1.0 then
			buffer.display_y = buffer.offset_y
		else
			buffer.display_y = lerp(buffer.display_y, buffer.offset_y, speed)
			self:clamp_scrollbar_thumb()
		end
		if abs(buffer.offset_x - buffer.display_x) < 1.0 then
			buffer.display_x = buffer.offset_x
		else
			buffer.display_x = lerp(buffer.display_x, buffer.offset_x, speed)
			self:clamp_scrollbar_thumb()
		end
	
		if not self:has_keyboard_focus() then return end

		local moved = false -- has the cursor moved?
		local this_command = nil -- TODO: something better than this...

		while peektext() do
			local k = readtext()
			buffer:insert(k)
			moved = true
		end

		-- Movement (with optional "shift")
		if not key("ctrl") and not key("alt") then
			local extend = key("shift")
			if keyp("enter") then buffer:newline(true, key("shift")); moved = true
			elseif keyp("tab") then buffer:tab(extend); moved = true
			elseif keyp("backspace") then buffer:backspace(); moved = true
			elseif keyp("delete") then buffer:delete(); moved = true
			elseif keyp("up") then buffer:move_up(extend); moved = true
			elseif keyp("down") then buffer:move_down(extend); moved = true
			elseif keyp("right") then buffer:move_right(extend); moved = true
			elseif keyp("left") then buffer:move_left(extend); moved = true
			elseif keyp("home") then buffer:move_home(extend, false); moved = true
			elseif keyp("end") then buffer:move_end(extend); moved = true
			elseif keyp("pageup") then
				for i = 1, 20 do
					buffer:move_up(extend)
				end
				moved = true
			elseif keyp("pagedown") then
				for i = 1, 20 do
					buffer:move_down(extend)
				end
				moved = true
			elseif keyp("escape") then
				-- Does not work as of Picotron 0.2.0b (escape is borked)
				buffer:set_cursor(buffer:active_cursor_pos())
			end
		end
	
		if key("ctrl") and not key("alt") then
			local extend = key("shift")
			if keyp("right") then buffer:next_word(extend); moved = true
			elseif keyp("left") then buffer:previous_word(extend); moved = true
			elseif keyp("w") then
				if last_command ~= "select_word" then
					buffer:next_word(false)
					buffer:previous_word(false)
				end
				buffer:next_word(true)
				this_command = "select_word"
				moved = true
			elseif keyp("l") then
				if last_command ~= "select_line" then
					buffer:move_home(false, false)
				end
				buffer:move_down(true)
				this_command = "select_line"
				moved = true
			elseif keyp("h") and extend then
				buffer:set_cursor(buffer:active_cursor_pos())
			elseif keyp("c") then
				local selections = buffer:get_all_selections()
				app.set_multiclipboard(selections)
			elseif keyp("x") then
				local selections = buffer:get_all_selections()
				app.set_multiclipboard(selections)
				buffer:delete_selection()
				moved = true
			elseif keyp("v") then
				-- TODO: should be in a function, somewhere...
				buffer:delete_selection()
				local multiclip = app.get_multiclipboard()
				if type(multiclip) == "string" then multiclip = { multiclip } end
				if #multiclip == buffer:number_of_cursors() then
					local i = 1
					buffer:foreach_cursor(
						function(col, row, _)
							buffer:insert_text_at(col, row, multiclip[i])
							i += 1
						end
					)
				else
					local str = table.concat(multiclip, "\n")
					buffer:foreach_cursor(
						function(col, row, _)
							buffer:insert_text_at(col, row, str)
						end
					)
				end
				moved = true
			elseif keyp("f") then
				findbox.hidden = false
				findbox:set_keyboard_focus(true)
				self:set_keyboard_focus(false)
				findbox:set_origin()
			end
		end	
		
		if key("ctrl") then
			if keyp("z") then
				buffer:undo()
				moved = true
			elseif keyp("y") or (key("shift") and keyp("z")) then
				buffer:redo()
				moved = true
			end
			if keyp("tab") then notify("!!!") end
			if key("shift") and keyp("n") then show_line_numbers = not show_line_numbers
			end
		end
				
		if moved then
			self:show_cursor(true)
			blink_timer = 0
			last_command = this_command
		end

	end
	

	function result:compute_scrollbar_coords()
		local buffer = workspace.current_buffer()
		local total_height = buffer:total_height()
		local thumb_height = math.floor(0.5 + (self.height * self.height) / total_height)
		thumb_height = max(scrollbar_width, thumb_height)
		local thumb_y = math.floor(0.5 + (buffer.display_y * self.height) / total_height)
		return total_height, thumb_y, thumb_height
	end

	
	function result:draw(msg)
		rectfill(0, 0, self.width - 1 - scrollbar_width, self.height - 1, 1)
		
		-- TODO: this is in /system/lib/gui_ed.lua:
		--     -- draw tabs relative to home
		--     poke(0x4005, (@0x4005) | 0x2)

		local buffer = workspace.current_buffer()
		if not buffer then return end
		
		local dx = math.floor(0.5 + buffer.display_x)
		local dy = math.floor(0.5 + buffer.display_y)
		
		-- Matches
		
		local match_color = 0
		for start_col, start_row, end_col, end_row in buffer:matches() do
			for row = start_row, end_row do
				local y = buffer:find_cursor_y(row) - dy
				local start_x = get_margin_width() - dx
				if row == start_row then
					start_x = buffer:find_cursor_x(start_col, row) - dx + get_margin_width()
				end
				local end_x = self.width
				if row == end_row then
					end_x = buffer:find_cursor_x(end_col, row) - dx + get_margin_width() - 1
				end
				if not (row == end_row and end_col == 1) then
					rectfill(start_x, y - 2, end_x, y + 8, match_color)
				end
			end
		end
		
		-- Selections
		
		local selection_color = (buffer:number_of_selections() > 1) and 9 or 10
		buffer:foreach_selection(
			function(start_col, start_row, end_col, end_row, _active)
				for row = start_row, end_row do
					local y = buffer:find_cursor_y(row) - dy
					local start_x = get_margin_width() - dx
					if row == start_row then
						start_x = buffer:find_cursor_x(start_col, row) - dx + get_margin_width()
					end
					local end_x = self.width
					if row == end_row then
						end_x = buffer:find_cursor_x(end_col, row) - dx + get_margin_width() - 1
					end
					if not (row == end_row and end_col == 1) then
						rectfill(start_x, y - 2, end_x, y + 8, selection_color)
					end
				end
			end
		)
		
		-- Text
	
		local x = get_margin_width() - dx
		local row = buffer:find_cursor_row(dy)
		local y = buffer:find_cursor_y(row) - dy
		buffer:highlight(row) -- TODO: is this useful?
		local text = buffer:highlighted(row)
		while text and y < self.height do
			print(text, x, y, 6)
			row += 1
			y = buffer:find_cursor_y(row) - dy
			text = buffer:highlighted(row)
		end
		
		-- Cursors
		
		local cursor_color = (buffer:number_of_cursors() > 1) and 30 or 14
		if (blink_timer % 32 < 16) or not self:has_keyboard_focus() then
			buffer:foreach_cursor(
				function(col, row, is_selection, _active)
					local y = buffer:find_cursor_y(row) - dy
					local x = buffer:find_cursor_x(col, row) - dx + get_margin_width()
					local w = is_selection and 0 or cursor_width
					if (not is_selection) or false then
						rectfill(x, y - 2, x + w, y + 8, cursor_color)
					end
				end
			)
		end

		-- Margin (i.e. line numbers)
	
		if show_line_numbers then
			rectfill(-4 - dx, 0, -4 + get_margin_width() - 1 - dx, self.height - 1, is_testing and 18 or 16) -- or 18, 16
			--line(get_margin_width() - 1, 0, get_margin_width() - 1, self.height - 1, 18)
			local row = buffer:find_cursor_row(dy)
			local y = buffer:find_cursor_y(row) - dy
			while buffer:text(row) and y < self.height do
--				print(string.format("%4d", row), 3, y, 1)
				print(string.format("\014%4d", row), -2 - dx, y + 2, 1)
				row += 1
				y = buffer:find_cursor_y(row) - dy
			end
		end

		-- Scrollbar
		
		rectfill(self.width - scrollbar_width, 0, self.width - 1, self.height - 1, 13)
		local total_height, thumb_y, thumb_height = self:compute_scrollbar_coords()
		-- The scrollbar thumb
		rectfill(
			self.width - scrollbar_width + 0, thumb_y,
			self.width - 1, thumb_y + thumb_height - 1,
			6
		)
		if show_sections_in_scrollbar then
			buffer:foreach_row(
				function(row, str)
					if str:find("----", 1, 4) then
						local y = buffer:find_cursor_y(row)
						y = (y * self.height) // total_height
						line(self.width - scrollbar_width + 1, y, self.width - 2, y, 18)
					end
				end
			)
		end
		if show_cursors_in_scrollbar then
			buffer:foreach_cursor(
				function(col, row, is_selection, _is_active)
					if not is_selection then
						local y = buffer:find_cursor_y(row)
						y = (y * self.height) // total_height
						line(self.width - scrollbar_width + 1, y, self.width - 2, y, cursor_color)
					end
				end
			)
		end
		if true and not findbox.hidden and #findbox:target() > 1 then
			for _start_col, start_row, _end_col, end_row in buffer:matches() do
				local start_y = buffer:find_cursor_y(start_row)
				start_y = (start_y * self.height) // total_height
				local end_y = buffer:find_cursor_y(end_row)
				end_y = (end_y * self.height) // total_height
				rectfill(
					self.width - scrollbar_width + 1, start_y,
					self.width - 2, end_y,
					match_color
				)
			end
		end
		if true then
			buffer:foreach_selection(
				function(_start_col, start_row, _end_col, end_row, _is_active)
					local start_y = buffer:find_cursor_y(start_row)
					start_y = (start_y * self.height) // total_height
					local end_y = buffer:find_cursor_y(end_row)
					end_y = (end_y * self.height) // total_height
					rectfill(
						self.width - scrollbar_width + 1, start_y,
						self.width - 2, end_y,
						selection_color
					)
				end
			)
		end
	end


	return result
end


-------------------------------------------------------------------------------------------

:: src/ui/findbox.lua
--[[pod_format="raw",created="2025-03-28 14:29:26",modified="2025-03-28 19:52:01",revision=351]]
-------------------------------------------------------------------------------------------


local workspace = require "src/workspace.lua"


-------------------------------------------------------------------------------------------


return function(attribs)
	local self = attribs
	self.width = 40
	self.height = 14
	self.hidden = true
	head():new(self)
	
	
	-- Private fields
	local had_keyboard_focus = false
	local ocol, orow = 1, 1 -- Origin
	local acol, arow = 1, 1 -- Anchor, i.e. starting position for search
	local target = "" -- The text we're looking for
	local previous_target = ""
	local no_match = false

	
	function self:target()
		return target
	end
	
	
	function self:set_origin(col, row)
		local buffer = workspace.current_buffer()
		ocol, orow = buffer:active_cursor_pos()
		acol, arow = ocol, orow
		no_match = false
	end
	
	
	function self:click(msg)
		return false
	end
	
	
	local function update_search(buffer)
		if target == "" then
			acol, arow = ocol, orow
			buffer:clear_matches()
			buffer:set_cursor(acol, arow)
			self.editor:center_cursor()
		else
			buffer:find_all(target, true)
		end
		local found = false
		buffer:set_cursor(ocol, orow)
		for scol, srow, ecol, erow in buffer:matches() do
			if (srow == arow and scol >= acol) or (srow > arow) then
				buffer:set_selection(scol, srow, ecol, erow)
				self.editor:center_cursor(true)
				found = true
				break
			end
		end
		if not found then
			for scol, srow, ecol, erow in buffer:matches() do
				buffer:set_selection(scol, srow, ecol, erow)
				self.editor:center_cursor(true)
				found = true
				break
			end
		end
		no_match = not found
		self.editor:center_cursor(true)
	end
	
	
	function self:update(msg)
		local buffer = workspace.current_buffer()
		if not buffer then return end
		

		if not self:has_keyboard_focus() then
			if had_keyboard_focus then
				acol, arow = 1, 1
				previous_target = target
				target = ""
				self.hidden = true
				buffer:clear_matches()
				had_keyboard_focus = false
			end
			return
		end
		
		had_keyboard_focus = true
		
		while peektext() do
			local k = readtext()
			target ..= k
			update_search(buffer)
		end

		if keyp("enter") then
			self:set_keyboard_focus(false)
			if key("shift") then
				local col, row = buffer:active_cursor_pos()
				buffer:set_cursor(col, row)
			end
		elseif keyp("backspace") then
			if key("ctrl") then
				previous_target = target
				target = ""
				buffer:set_cursor(ocol, orow)
				self:set_keyboard_focus(false)
				self.editor:center_cursor()
			else
				target = target:sub(1, -2)
				update_search(buffer)
			end
		elseif keyp("tab") or keyp("pagedown") then
			if target == "" then
				target = previous_target
			else
				acol, arow = buffer:active_cursor_pos()
			end
			update_search(buffer)
		end
		local moved = false
		if not key("ctrl") and not key("alt") then
			if keyp("up") then buffer:move_up(false); moved = true
			elseif keyp("down") then buffer:move_down(false); moved = true
			elseif keyp("right") then buffer:move_right(false); moved = true
			elseif keyp("left") then buffer:move_left(false); moved = true
			elseif keyp("home") then buffer:move_home(false, false); moved = true
			elseif keyp("end") then buffer:move_end(false); moved = true
			end
		end
		if moved then
			self.editor:center_cursor()
			self:set_keyboard_focus(false)
		end
	end
	
	
	function self:draw(msg)
		rectfill(0, 0, self.width - 1, self.height - 1, is_testing and 13 or 17)
		line(0, 0, self.width - 1, 0, 1)
		line(0, 0, 0, self.height - 1, 1)
		line(self.width - 1, 0, self.width - 1, self.height - 1, 1)
		print("Find: ", 8, 5, 1)
		print(target, 8 + 25, 5, no_match and 9 or 7)
	end
	
	return self
end


-------------------------------------------------------------------------------------------

:: src/ui/head.lua
--[[pod_format="raw",created="2025-03-27 19:11:47",modified="2025-03-28 19:52:01",revision=853]]
----------------------------------------------------------------------------------------


local _head = nil
function head() return _head end


----------------------------------------------------------------------------------------


function init()
	_head = create_gui()
end


----------------------------------------------------------------------------------------


function update()
	_head:update_all()
end


----------------------------------------------------------------------------------------


function draw()
	_head:draw_all()
end


----------------------------------------------------------------------------------------


return {
	head = head,
	init = init,
	draw = draw,
	update = update,
}


----------------------------------------------------------------------------------------

:: src/ui/rowbox.lua
--[[pod_format="raw",created="2025-03-27 19:02:27",modified="2025-03-28 19:52:01",revision=874]]
-------------------------------------------------------------------------------------------


return function(attribs)
	local self = attribs
	self.width = 23
	self.height = 8
	self.content = ""
	head():new(self)

	
	function self:click(msg)
		return false
	end
	
		
	function self:draw(msg)
		line(0, 0, self.width - 1, 0, 1)
		line(0, 0, 0, self.height - 1, 1)
		rectfill(1, 1, self.width - 1, self.height - 1, is_testing and 18 or 16)
		print("\014" .. self.content, 5 + 2 * (4 - #self.content), 2, 1)
	end
	
	return self
end


-------------------------------------------------------------------------------------------

:: src/ui/sidebar.lua
--[[pod_format="raw",created="2025-03-23 12:31:49",modified="2025-03-28 19:52:01",revision=3944]]
-------------------------------------------------------------------------------------------


local workspace = require "src/workspace.lua"


-------------------------------------------------------------------------------------------


local arrow_up <const> = "\^:00040e1f00000000"
local arrow_down <const> = "\^:001f0e0400000000"
local arrow_right <const> = "\^:02060e0602000000"
local arrow_left <const> = "\^:080c0e0c08000000"


local row_height <const> = 9
local header_height <const> = 16
local padding_top <const> = 5
local padding_bottom <const> = 3
local padding_left <const> = 3
local padding_right <const> = 5


local bg_sidebar <const> = 17 -- or 13, 17
local fg_path_inactive <const> = 1 -- or 1, 19
local fg_path_active <const> = 6 -- or 6, 6


-------------------------------------------------------------------------------------------


return function(attribs)
	local result = attribs or {}
	result.x = attribs.x or 0
	result.y = attribs.y or 0
	result.width = 60
	result.height_rel = 1
	head():new(result)


	-- Private fields


	function result:hover(msg)
		self.cursor = 1
		if msg.mx >= self.width - 2 then
			self.cursor = 9 -- TODO: replace with horiz. double arrow
		else
			self.cursor = "pointer"
		end
	end
	
	
	function result:click(msg)
		-- needed so that editor's keyboard focus is not lost.
		local row = 1 + (msg.my - header_height - padding_top) // row_height
		workspace.set_current(row)
	end
	

	function result:tap(msg)
	end
	
	
	function result:update(msg)
		if self:has_keyboard_focus() then
			log("!!!!!")
		end
	end
	

	function result:draw(msg)
		rectfill(0, 0, self.width - 1, self.height - 1, is_testing and 13 or bg_sidebar)
		do
			local x = 2
			pal(7, fg_path_inactive)
			if false then -- only for fullscreen
				spr(8, x, 2); x += 11
			end
			spr(9, x, 2); x += 11
			print("\014all\-h" .. arrow_down, 20 + 6*0, 2 + 3, 7)
			--spr(10, x, 2); x += 11
			--spr(9, x, 2); x += 11
			spr(11, self.width - 11 - 3, 2)
			pal(7, 7)
			line(4, 15, self.width - 5, 15, fg_path_inactive)
		end
		clip(
			self.x + padding_left,
			self.y + header_height + padding_top,
			self.width - padding_left - padding_right,
			self.height - header_height - padding_top - padding_bottom
		)
--		rectfill(0, 0, self.width - 1, self.height - 1, 2)
		local x, y = padding_left, header_height + padding_top
		workspace.foreach(
			function(node, level)
				if level == 0 then return end
				local str = "\014"
				--for i = 2, level do str ..= " " end
				--if node.children then str ..= arrow_down end
				str ..= node.name
				if node.children then str ..= "/" end
				local c = fg_path_inactive
				if node.path == workspace.current_path() then
					c = fg_path_active
				end
				print(str, x + 6 * (level - 1), y, c)
				y += row_height
			end
		)
	end

	
	return result
end


-------------------------------------------------------------------------------------------

:: src/ui/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTIzIDEwOjE5OjAxIixtb2RpZmllZD0iMjAyNS0w
My0yOCAxOTo1MjowMSJdXQ==
:: src/app.lua
--[[pod_format="raw",created="2025-03-27 11:19:40",modified="2025-03-28 19:52:01",revision=1448]]

local multiclipboard = {}


function set_multiclipboard(array)
	multiclipboard = {
		multi = array,
		clipboard = table.concat(array, "\n"),
	}
	set_clipboard(multiclipboard.clipboard)
end


function get_multiclipboard()
	local clipboard = get_clipboard()
	if multiclipboard.array and (clipboard == multiclipboard.clipboard) then
		return multiclipboard.array
	end
	return clipboard
end


return {
	set_multiclipboard = set_multiclipboard,
	get_multiclipboard = get_multiclipboard,
}
:: src/buffers.lua
--[[pod_format="raw",created="2025-03-22 18:20:27",modified="2025-03-28 19:52:01",revision=5321]]
-------------------------------------------------------------------------------------------


-- NOTE: duplicated in buffer.lua!
local row_height <const> = 11


------------------------------------------------------------------------------------------


local function shallow_copy(text)
	local copied = {}
	for i in ipairs(text) do
		copied[i] = text[i]
	end
	return copied
end


------------------------------------------------------------------------------------------


function new(path, text)
	local result = {
		-- Public fields
		offset_x = -4,
		offset_y = -4,
		display_x = -4,
		display_y = -4,
		highlighter_row = 1,
	}
	

	-- Private fields
	local text = split(text, "\n", false) or {}
	local highlighted = {}
	local cursors = { { col = 1, row = 1, wanted_x = 0 } }
	local matches = {}
	local undo_stack = create_undo_stack(
		function()
			return {
				text = shallow_copy(text),
				-- TODO: is there a better solution than saving the highlights
				-- in the undo stack? Picotron's code editor doesn't seem to
				-- do it, but doesn't suffer from slow update after undo/redo
				-- in a large file...
--				highlighted = shallow_copy(highlighted),
				cursors = pod(cursors),
			}
		end,
		function(state)
			text = state.text
--			highlighted = state.highlighted
			cursors = unpod(state.cursors)
			result:highlight(cursors[#cursors].row)
		end
	)
	local undo_group = nil


	function result:text(row)
		if row < 1 then return "" end
		if row > #text then return nil end
		return text[row]	
	end
	
	
	function result:highlighted(row)
		if highlighted[row] and highlighted[row].input == text[row] then
			return highlighted[row].out or ""
		end
		return text[row] or ""
	end
	
	
	function result:number_of_rows()
		return #text
	end
	

	function result:full_text_copy()
		return table.concat(text, "\n")
	end
	

	function result:foreach_row(func)
		for row, str in ipairs(text) do
			func(row, str)
		end
	end
	
	
	local decor_multicat = { [3] = "\fd", [4] = "\fc" }
	local reserved_keywords = { "and", "break", "do", "else", "elseif", "end", "for",	"function", "if", "in", "local", "not", "or", "repeat", "return", "then", "until", "while" }
	local reserved_values = { "true", "false", "nil" }
	local decor_keyword = {}
	for i = 1, #reserved_keywords do decor_keyword[reserved_keywords[i]] = "\fe" end
	for i = 1, #reserved_values do decor_keyword[reserved_values[i]] = "\fc" end
	local decor_cat <const> = { [0] = "\f7", "\f6", "\fc", "\fd", "\fc", "\f7" }
	local decor_funcname = function(cat, char) if cat == 1 and char == "(" then return "\fb" else return nil end end
	
	
	function result:highlight(row)
		row = mid(1, row, #text)
		local str = text[row] or ""
		
		local unchanged = highlighted[row] and highlighted[row].input == str
		local continuity =
			highlighted[row] and highlighted[row - 1]
			and (highlighted[row - 1].after == highlighted[row].before)
		if unchanged and (continuity or (row == 1)) then
			return
		end
		
		if row > 1 then
			self:highlight(row - 1)
			if not highlighted[row - 1] then return end
		end
		
		--[[do
			local cause = "???"
			if not unchanged then cause = "changed" end
			if not continuity then
				cause = "continuity: "
				if not highlighted[row] then cause ..= "(not highlighted row)"
				elseif not highlighted[row - 1] then cause ..= "(not highlighted row - 1)"
				else cause ..= "" .. highlighted[row - 1].after .. " ~= " .. highlighted[row].before
				end
			end
			log("highlighting row " .. row .. " because " .. cause)
		end]]
		
		local out = ""
		local col = 1
		local lexer_state = highlighted[row - 1] and highlighted[row - 1].after or 0
		while col <= #str do
			local token, end_col, cat
			token, end_col, cat, lexer_state = tokenoid(str, col, lexer_state)
			if not token then return out end
			local decor =
				decor_multicat[cat] or decor_keyword[token]
				or decor_funcname(cat, str[end_col]) or decor_cat[cat] or ""
			out = out .. decor .. token
			col = end_col
		end
		highlighted[row] = {
			input = str,
			out = out,
			before = highlighted[row - 1] and highlighted[row - 1].after or 0,
			after = lexer_state or 0,
		}
	end
	

	function result:checkpoint()
		undo_stack:checkpoint()
	end
	

	function result:undo()
		undo_stack:undo()
		undo_group = nil
	end
	

	function result:redo()
		undo_stack:redo()
		undo_group = nil
	end
	
	
	function result:center_on(col, row)
		-- TODO: this method should be in editor.lua, probably
		self.offset_y = self:find_cursor_y(row - 12)
		self.offset_x = self:find_cursor_x(col, row)
	end
	

	-- Cursors --
	

	function result:foreach_cursor(func)
		local nb = #cursors
		for i, cursor in ipairs(cursors) do
			local is_active_cursor = (nb > 1) and (i == nb)
			local is_selection = (cursor.sel_col ~= nil)
			func(cursor.col, cursor.row, is_selection, is_active_cursor)
		end
	end
	
	
	local function selection_range(cursor)
		if cursor.sel_row < cursor.row then
			return cursor.sel_col, cursor.sel_row, cursor.col, cursor.row
		elseif cursor.sel_row > cursor.row then
			return cursor.col, cursor.row, cursor.sel_col, cursor.sel_row
		elseif cursor.sel_col < cursor.col then
			return cursor.sel_col, cursor.sel_row, cursor.col, cursor.row
		else
			return cursor.col, cursor.row, cursor.sel_col, cursor.sel_row
		end
	end
	

	function result:foreach_selection(func)
		local nb = #cursors
		for i, cursor in ipairs(cursors) do
			if cursor.sel_col then
				local start_col, start_row, end_col, end_row = selection_range(cursor)
				local is_active_cursor = (nb > 1) and (i == nb)
				func(start_col, start_row, end_col, end_row, is_active_cursor)
			end
		end
	end
	
	
	function result:get_all_selections()
		local selections = {}
		for cursor in all(cursors) do
			local str = ""
			local start_col, start_row, end_col, end_row = selection_range(cursor)
			if start_row == end_row then
				str = sub(text[start_row], start_col, end_col - 1)
			else
				str = sub(text[start_row], start_col, -1) .. "\n"
				for row = start_row + 1, end_row - 1 do
					str ..= text[row] .. "\n"
				end
				str ..= sub(text[end_row], 1, end_col - 1)
			end
			add(selections, str)
		end
		return selections
	end
	

	function result:has_multiple_cursors()
		return #cursors > 1
	end
	
	
	function result:number_of_cursors()
		return #cursors
	end
	
	
	function result:number_of_selections()
		local nb = 0
		for cursor in all(cursors) do
			if cursor.sel_col then
				nb += 1
			end
		end
		return nb
	end
	
	
	function result:find_all(target, plain)
		matches = {}
		for row = 1, #text do
			local col = 1
			while col <= #text[row] do
				local tcol = text[row]:find(target, col, plain)
				if tcol then
					table.insert(matches, {
						scol = tcol, srow = row,
						ecol = tcol + #target, erow = row,
					})
					col = tcol + #target
				else
					col = #text[row] + 1
				end
			end
			row += 1
		end
		return nil
	end
	
	
	function result:matches()
		local i = 0
		return function()
			i += 1
			if i <= #matches then
				local match = matches[i]
				return match.scol, match.srow, match.ecol, match.erow
			end
		end
	end
	
	
	function result:clear_matches()
		matches = {}
	end


	function result:find_cursor_x(col, row)
		if text then
			return print(sub(text[row], 1, col - 1), 0, -1000) or 0
		end
		return 0
	end


	function result:find_cursor_y(row)
		if text then
			return (row - 1) * row_height
		end
		return 0
	end
	

	function result:find_cursor_row(y)
		return 1 + (y // row_height)
	end


	function result:find_cursor_col(row, x)
		if row > #text then return #text[#text] + 1 end
		local str = text[row]
		if not str then return 0 end
		if #str == 0 then return 1 end
		for col = 1, #str do
			local xx = print(sub(str, 1, col), 0, -1000)
			if xx and xx > x then return col end
		end
		return #str + 1
	end
	

	function result:active_cursor_pos(width, height)
		return cursors[#cursors].col, cursors[#cursors].row
	end
	

	function result:total_height()
		return #text * row_height
	end
	

	function result:set_cursor(col, row)
		local row = mid(1, row, #text)
		local col = mid(1, col, #text[row] + 1)
		local x = result:find_cursor_x(col, row)
		cursors = { { col = col, row = row, x = x } }
		undo_group = nil
	end
	

	function result:add_cursor(col, row)
		local row = mid(1, row, #text)
		local col = mid(1, col, #text[row] + 1)
		local x = result:find_cursor_x(col, row)
		add(cursors, { col = col, row = row, x = x })
		self:merge_cursors()
		undo_group = nil
	end
	

	function result:set_selection(scol, srow, ecol, erow)
		local sel_row = mid(1, srow, #text)
		local sel_col = mid(1, scol, #text[srow] + 1)
		local row = mid(1, erow, #text)
		local col = mid(1, ecol, #text[erow] + 1)
		local x = result:find_cursor_x(col, row)
		cursors = { { col = col, row = row, x = x, sel_col = sel_col, sel_row = sel_row } }
		undo_group = nil
	end
	

	function result:extend_active_selection(col, row)
		local cursor = cursors[#cursors]
		local row = mid(1, row, #text)
		local col = mid(1, col, #text[row] + 1)
		if (col == cursor.col) and (row == cursor.row) then
			return
		end
		if not cursor.sel_col then
			cursor.sel_col, cursor.sel_row = cursor.col, cursor.row
		end
		cursor.col, cursor.row = col, row
		if (cursor.col == cursor.sel_col) and (cursor.row == cursor.sel_row) then
			cursor.sel_col, cursor.sel_row = nil, nil
		end
		cursor.wanted_x = result:find_cursor_x(cursor.col, cursor.row)
		self:merge_cursors()
		undo_group = nil
	end
	

	function result:merge_cursors()
		-- TODO: handle selections...
		local is_duplicate = {}
		for i = #cursors, 1, -1 do
			for j = i - 1, 1, -1 do
				local c1, c2 = cursors[i], cursors[j]
				if c1.row == c2.row and c1.col == c2.col then
					is_duplicate[c1] = true
				end
			end
		end
		for i = #cursors, 1, -1 do
			if is_duplicate[cursors[i]] then
				table.remove(cursors, i)
			end
		end
		if #cursors == 0 then -- should never happen?
			self:set_cursor(1, 1)
		end
	end


	-- Movement --
	

	local function initiate_selection(cursor)
		cursor.sel_col, cursor.sel_row = cursor.col, cursor.row
	end


	local function cancel_selection(cursor)
		cursor.sel_col, cursor.sel_row = nil, nil
		cursor.wanted_x = result:find_cursor_x(cursor.col, cursor.row)
		undo_group = nil
	end


	function result:move_up(extend)
		for cursor in all(cursors) do
			if cursor.sel_col and (not extend) then
				cursor.col, cursor.row, _, _ = selection_range(cursor)
				cancel_selection(cursor)
			elseif extend and (not cursor.sel_col) then
				initiate_selection(cursor)
			end
			cursor.row = max(1, cursor.row - 1)
			if cursor.wanted_x then
				cursor.col = result:find_cursor_col(cursor.row, cursor.wanted_x + 2)
			end
			if cursor.col > #text[cursor.row] + 1 then
				cursor.col = #text[cursor.row] + 1
			end
		end
		self:merge_cursors()
		undo_group = nil
	end


	function result:move_down(extend)
		for cursor in all(cursors) do
			if cursor.sel_col and (not extend) then
				 _, _, cursor.col, cursor.row = selection_range(cursor)
				cancel_selection(cursor)
			elseif extend and (not cursor.sel_col) then
				initiate_selection(cursor)
			end
			cursor.row = min(cursor.row + 1, #text)
			if cursor.wanted_x then
				cursor.col = result:find_cursor_col(cursor.row, cursor.wanted_x + 2)
			end
			if cursor.col > #text[cursor.row] + 1 then
				cursor.col = #text[cursor.row] + 1
			end
		end
		self:merge_cursors()
		undo_group = nil
	end


	function result:move_left(extend)
		for cursor in all(cursors) do
			if cursor.sel_col and (not extend) then
				cursor.col, cursor.row, _, _ = selection_range(cursor)
				cancel_selection(cursor)
				goto continue -- because the cursor must not move
			elseif extend and (not cursor.sel_col) then
				initiate_selection(cursor)
			end
			cursor.col -= 1
			if cursor.col < 1 then
				if cursor.row > 1 then
					cursor.row -= 1
					cursor.col = #text[cursor.row] + 1
				else
					cursor.col = 1
				end
			end
			::continue::
			cursor.wanted_x = result:find_cursor_x(cursor.col, cursor.row)
		end
		self:merge_cursors()
		undo_group = nil
	end


	function result:move_right(extend)
		for cursor in all(cursors) do
			if cursor.sel_col and (not extend) then
				_, _, cursor.col, cursor.row = selection_range(cursor)
				cancel_selection(cursor)
				goto continue -- because the cursor must not move
			elseif extend and (not cursor.sel_col) then
				initiate_selection(cursor)
			end
			cursor.col += 1
			if cursor.col > #text[cursor.row] + 1 then
				if cursor.row < #text then
					cursor.row += 1
					cursor.col = 1
				else
					cursor.col = #text[cursor.row] + 1
				end
			end
			::continue::
			cursor.wanted_x = result:find_cursor_x(cursor.col, cursor.row)
		end
		self:merge_cursors()
		undo_group = nil
	end


	function result:move_home(extend, smart)
		for cursor in all(cursors) do
			if cursor.sel_col and (not extend) then
				 cursor.col, cursor.row, _, _ = selection_range(cursor)
				cancel_selection(cursor)
			elseif extend and (not cursor.sel_col) then
				initiate_selection(cursor)
			end
			if smart then
				-- TODO
			else
				cursor.col = 1
			end
			-- TODO: merge cursors!!!
			cursor.wanted_x = result:find_cursor_x(cursor.col, cursor.row)
		end
		self:merge_cursors()
		undo_group = nil
	end


	function result:move_end(extend, smart)
		for cursor in all(cursors) do
			if cursor.sel_col and (not extend) then
				 _, _, cursor.col, cursor.row = selection_range(cursor)
				cancel_selection(cursor)
			elseif extend and (not cursor.sel_col) then
				initiate_selection(cursor)
			end
			if smart then
				-- TODO
			else
				cursor.col = #text[cursor.row] + 1
			end
			-- TODO: merge cursors!!!
			cursor.wanted_x = result:find_cursor_x(cursor.col, cursor.row)
		end
		self:merge_cursors()
		undo_group = nil
	end

	
	local function char_category(char)
		if char == nil then return "nil"
		elseif char == ord(" ") or char == ord("\t") then return "whitespace"
		elseif char >= ord("a") and char <= ord("z") then return "identifier"
		elseif char >= ord("A") and char <= ord("Z") then return "identifier"
		elseif char >= ord("0") and char <= ord("9") then return "identifier"
		elseif char == ord("_") then return "identifier"
		-- TODO: separators, etc.
		else return "other"
		end
	end


	function result:next_word(extend)
		for cursor in all(cursors) do
			if cursor.sel_col and (not extend) then
				 _, _, cursor.col, cursor.row = selection_range(cursor)
				cancel_selection(cursor)
			elseif extend and (not cursor.sel_col) then
				initiate_selection(cursor)
			end
			local str = text[cursor.row]
			while char_category(str:byte(cursor.col)) == "whitespace" do
				cursor.col += 1
			end
			if cursor.col == #str + 1 and cursor.row < #text then
				cursor.row += 1
				cursor.col = 0
			end
			cursor.col += 1
			while
				cursor.col < #str + 1
				and char_category(str:byte(cursor.col)) == char_category(str:byte(cursor.col - 1))
			do
				cursor.col += 1
			end
			cursor.wanted_x = result:find_cursor_x(cursor.col, cursor.row)
		end
		self:merge_cursors()
		undo_group = nil
	end


	function result:previous_word(extend)
		for cursor in all(cursors) do
			if cursor.sel_col and (not extend) then
				 cursor.col, cursor.row, _, _ = selection_range(cursor)
				cancel_selection(cursor)
			elseif extend and (not cursor.sel_col) then
				initiate_selection(cursor)
			end
			local str = text[cursor.row]
			while cursor.col > 1 and char_category(str:byte(cursor.col - 1)) == "whitespace" do
				cursor.col -= 1
			end
			if cursor.col == 1 and cursor.row > 1 then
				cursor.row -= 1
				cursor.col = #text[cursor.row] + 2
			end
			cursor.col -= 1
			while
				cursor.col > 1
				and char_category(str:byte(cursor.col)) == char_category(str:byte(cursor.col - 1))
			do
				cursor.col -= 1
			end
			cursor.wanted_x = result:find_cursor_x(cursor.col, cursor.row)
		end
		self:merge_cursors()
		undo_group = nil
	end
	

	-- Edition --
	

	local function shift_cursors_after_deletion(start_col, start_row, end_col, end_row)
		-- There's probably a cleverer way to do this,
		-- but at least this is straightforward to follow.
		for cursor in all(cursors) do
			if cursor.row < start_row then
				-- nothing to do
			elseif cursor.row < end_row then
				cursor.col, cursor.row = start_col, start_row
			elseif (cursor.row == end_row) and (cursor.col < start_col) then
				-- nothing to do
			elseif (cursor.row == end_row) and (cursor.col < end_col) then
				cursor.col = start_col
			elseif cursor.row == end_row then
				cursor.col += start_col - end_col
			else
				cursor.row += start_row - end_row
			end
			-- The same with selection anchors
			if not cursor.sel_col then
				-- no selection
			elseif cursor.sel_row < start_row then
				-- nothing to do
			elseif cursor.sel_row < end_row then
				cursor.sel_col, cursor.sel_row = start_col, start_row
			elseif (cursor.sel_row == end_row) and (cursor.sel_col < start_col) then
				-- nothing to do
			elseif (cursor.sel_row == end_row) and (cursor.sel_col < end_col) then
				cursor.sel_col = start_col
			elseif cursor.sel_row == end_row then
				cursor.sel_col += start_col - end_col
			else
				cursor.sel_row += start_row - end_row
			end
		end
	end
	

	function result:delete_selection()
		local has_deleted = self:number_of_selections() > 0
		if has_deleted then
			self:checkpoint()
			undo_group = nil
		end
		for cursor in all(cursors) do
			if cursor.sel_col then
				has_deleted = true
				local start_col, start_row, end_col, end_row = selection_range(cursor)
				text[start_row] =
					sub(text[start_row], 1, start_col - 1)
					.. sub(text[end_row], end_col, -1)
				for _ = start_row + 1, end_row do
					table.remove(text, start_row + 1)
					table.remove(highlighted, start_row + 1)
				end
				shift_cursors_after_deletion(start_col, start_row, end_col, end_row)
				cursor.col, cursor.row = start_col, start_row
				cursor.sel_col, cursor.sel_row = nil, nil
			end
		end
		return has_deleted
	end
	
	
	function result:insert_text_at(col, row, str)
		if undo_group ~= "insert_text" then
			self:checkpoint()
		end
		undo_group = "insert_text"
		local lines = split(str, "\n", false)
		if #lines == 1 then
			text[row] = sub(text[row], 1, col - 1) .. str .. sub(text[row], col)
			for cursor in all(cursors) do
				if cursor.row == row and cursor.col >= col then
					cursor.col += #str
				end
				cursor.wanted_x = self:find_cursor_x(cursor.col, cursor.row)
				if cursor.sel_row == row and cursor.sel_col >= col then
					cursor.sel_col += #str
				end
			end
			return
		end
		local delta_row = #lines - 1
		local delta_col = - col + 1 + #lines[#lines]
		table.insert(text, row + 1, lines[#lines] .. sub(text[row], col, -1))
		table.insert(highlighted, row + 1, nil)
		text[row] = sub(text[row], 1, col - 1) .. lines[1]
		for i = #lines - 1, 2, -1 do
			table.insert(text, row + 1, lines[i])
			table.insert(highlighted, row + 1, nil)
		end
		for cursor in all(cursors) do
			if cursor.row == row and cursor.col >= col then
				cursor.row += delta_row
				cursor.col += delta_col
			elseif cursor.row > row then
				cursor.row += delta_row
			end
			if not cursor.sel_col then
				-- do nothing
			elseif cursor.sel_row == row and cursor.sel_col >= col then
				cursor.sel_row += delta_row
				cursor.sel_col += delta_col
			elseif cursor.sel_row > row then
				cursor.sel_row += delta_row
			end
		end
	end
	

	function result:insert(k)
		-- Undo checkpoint, with grouping of inserts
		local group = "insert"
		if k == " " then group = "whitespace" end
		if	
			(group ~= undo_group)
			and not (group == "insert" and undo_group == "whitespace")
		then
			self:checkpoint()
		end
		undo_group = group
		-- Actual edit
		self:delete_selection()
		for cursor in all(cursors) do
			local row, col = cursor.row, cursor.col
			local str = text[row]
			text[row] = sub(str, 1, col - 1) .. k .. sub(str, col)
			self:highlight(row)
			-- Move all impacted cursors
			for cursor in all(cursors) do
				if cursor.row == row and cursor.col >= col then
					cursor.col += #k
					cursor.wanted_x = result:find_cursor_x(cursor.col, cursor.row)
				end
			end
		end
	end
	
	
	local function is_whitespace(byte)
		return (byte == ord(" ")) or (byte == ord("\t"))
	end
	

	local function is_empty_line(str)
		for col = 1, #str do
			if not is_whitespace(str:byte(col)) then
				return false
			end
		end
		return true
	end
	

	local function should_indent_after(str)
		local last_token
		local col = 1
		while (col <= #str) do
			local s, cat
			s, col, cat = tokenoid(str, col)
			if (cat == 1) and (s == "function") then
				return true
			end
			if cat ~= 0 then
				last_token = s
			end
		end
		local indent_tokens <const> = {
			["("] = true, ["["] = true, ["{"] = true, ["="] = true,
			-- TODO: add the myriad assignment operators
			["do"] = true, ["else"] = true, ["elseif"] = true,
			["for"] = true, ["function"] = true, ["goto"] = true, ["if"] = true,
			["local"] = true, ["repeat"] = true, ["return"] = true,
			["then"] = true, ["until"] = true, ["while"] = true,
		}
		return indent_tokens[last_token]
	end


	local function block_closer(str)
		local first_keyword, last_keyword
		local col = 1
		while (col <= #str) do
			local s, cat
			s, col, cat = tokenoid(str, col)
			if cat == 1 then
				if (not first_keyword) or (first_keyword == "local") then
					first_keyword = s
				end
				last_keyword = s
			end
		end
		if (first_keyword == "function") or (last_keyword == "do")
			or (last_keyword == "then") or (last_keyword == "else")
		then
			return "end"
		end
		if last_keyword == "repeat" then
			return "until"
		end
		return nil
	end


	function result:newline(autoindent, autoclose)
		-- Undo checkpoint, with grouping of inserts
		local group = "newline"
		if group ~= undo_group then
			self:checkpoint()
		end
		undo_group = group
		-- Actual edit
		self:delete_selection()
		for cursor in all(cursors) do
			local row, col = cursor.row, cursor.col
			local indentation = ""
			if autoindent then
				local above = row
				while above > 1 and is_empty_line(text[above]) do
					above -= 1
				end
				local c = 1
				while c < #text[above] and is_whitespace(text[above]:byte(c)) do
					indentation ..= text[above][c]
					c += 1
				end
				if should_indent_after(sub(text[row], 1, col - 1)) then
					indentation ..= "\t"
				end
			end
			table.insert(text, row + 1, indentation .. sub(text[row], col, -1))
			table.insert(highlighted, row + 1, nil)
			local delta_row = 1
			if autoclose and col == #text[row] + 1 then
				local closer = block_closer(text[row])
				if closer then
					table.insert(text, row + 2, sub(indentation, 2, -1) .. closer)
					table.insert(highlighted, row + 2, nil)
					delta_row = 2
				end
			end
			text[row] = sub(text[row], 1, col - 1)
			local delta_col = #indentation - #text[row]
			-- Move all impacted cursors
			for cursor in all(cursors) do
				if cursor.row == row and cursor.col == col then
					-- The insertion cursor always move 1 row, even when autoclose
					cursor.row += 1
					cursor.col += delta_col
					cursor.wanted_x = result:find_cursor_x(cursor.col, cursor.row)
				elseif cursor.row == row and cursor.col >= col then
					cursor.row += delta_row
					cursor.col += delta_col
					cursor.wanted_x = result:find_cursor_x(cursor.col, cursor.row)
				elseif cursor.row > row then
					cursor.row += delta_row
				end
			end
		end
	end
	

	function result:tab(reverse)
		-- Undo checkpoint, with grouping of inserts
		-- TODO: should only indent if there is a multi-line selection!
		local has_selection = self:number_of_selections() >= 1
		local group = has_selection and "indent" or "whitespace"
		if group ~= undo_group then
			self:checkpoint()
		end
		undo_group = group
		if has_selection then
			-- Indent or deindent
			local delta_col = 0
			self:foreach_selection(
				function(scol, srow, ecol, erow)
					if ecol == 1 then
						erow -= 1
					end
					for row = srow, erow do
						if reverse then
							if text[row][1] == "\t" then
								text[row] = sub(text[row], 2, -1)
								delta_col = -1
							end
						else
							text[row] = "\t" .. text[row]
							delta_col = 1
						end
					end
					-- Move all impacted cursors
					for cursor in all(cursors) do
						if srow <= cursor.row and cursor.row <= erow
							and cursor.col ~= 1
						then
							cursor.col = mid(1, cursor.col + delta_col, #text[cursor.row])
						end
						if srow <= cursor.sel_row and cursor.sel_row <= erow
							and cursor.sel_col ~= 1
						then
							cursor.sel_col = mid(1, cursor.sel_col + delta_col, #text[cursor.sel_row])
						end
					end
				end
			)
			return
		end
		-- Actual edit
		self:delete_selection()
		for cursor in all(cursors) do
			local row, col = cursor.row, cursor.col
			local str = text[row]
			text[row] = sub(str, 1, col - 1) .. "\t" .. sub(str, col)
			-- Move all impacted cursors
			for cursor in all(cursors) do
				if cursor.row == row and cursor.col >= col then
					cursor.col += 1
					cursor.wanted_x = result:find_cursor_x(cursor.col, cursor.row)
				end
			end
		end
	end
	

	function result:backspace()
		-- Undo checkpoint, with grouping of inserts
		local group = "backspace"
		if group ~= undo_group then
			self:checkpoint()
		end
		undo_group = group
		-- Actual edit
		if self:delete_selection() then
			return
		end
		for cursor in all(cursors) do
			local row, col = cursor.row, cursor.col
			if col == 1 and row > 1 then
				-- join with previous line
				undo_group = nil
				delta_col = #text[row - 1]
				text[row - 1] = text[row - 1] .. text[row]
				table.remove(text, row)
				table.remove(highlighted, row)
				-- Move all impacted cursors
				for cursor in all(cursors) do
					if cursor.row == row then
						cursor.col += delta_col
						cursor.row -= 1
					elseif cursor.row > row then
						cursor.row -= 1
					end
				end
			elseif col > 1 then
				local str = text[row]
				text[row] = sub(str, 1, col - 2) .. sub(str, col)
				-- Move all impacted cursors
				for cursor in all(cursors) do
					if cursor.row == row and cursor.col >= col then
						cursor.col -= 1
						cursor.wanted_x = result:find_cursor_x(cursor.col, cursor.row)
					end
				end
			end
		end
	end
	

	function result:delete()
		-- Undo checkpoint, with grouping of inserts
		local group = "delete"
		if group ~= undo_group then
			self:checkpoint()
		end
		undo_group = group
		-- Actual edit
		if self:delete_selection() then
			return
		end
		for cursor in all(cursors) do
			local row, col = cursor.row, cursor.col
			if col == #text[row] + 1 and row < #text then
				-- Join with next line
				undo_group = nil
				delta_col = #text[row]
				text[row] = text[row] .. text[row + 1]
				table.remove(text, row + 1)
				table.remove(highlighted, row + 1)
				-- Move all impacted cursors
				for cursor in all(cursors) do
					if cursor.row == row + 1 then
						cursor.col += delta_col
						cursor.row -= 1
					elseif cursor.row > row + 1 then
						cursor.row -= 1
					end
				end
			elseif col <= #text[row] then
				local str = text[row]
				text[row] = sub(str, 1, col - 1) .. sub(str, col + 1)
				-- Move all impacted cursors
				for cursor in all(cursors) do
					if cursor.row == row and cursor.col > col then
						cursor.col -= 1
						cursor.wanted_x = result:find_cursor_x(cursor.col, cursor.row)
					end
				end
			end
		end
	end


	return result
end


-------------------------------------------------------------------------------------------


return {
	new = new,
}
:: src/ui.lua
--[[pod_format="raw",created="2025-03-23 10:43:59",modified="2025-03-28 19:52:01",revision=1968]]
----------------------------------------------------------------------------------------


local head = require "src/ui/head.lua"


----------------------------------------------------------------------------------------


return {
	head = head.head,
	init = head.init,
	draw = head.draw,
	update = head.update,
	editor = require "src/ui/editor.lua",
	sidebar = require "src/ui/sidebar.lua",
	rowbox = require "src/ui/rowbox.lua",
}

:: src/workspace.lua
--[[pod_format="raw",created="2025-03-23 16:21:54",modified="2025-03-28 19:52:01",revision=3036]]
-------------------------------------------------------------------------------------------


local buffers = require "src/buffers.lua"


-------------------------------------------------------------------------------------------


local location
local filetree
local fileset
local current
local fake_buffer = buffers.new("(pseudo buffer)", "(pseudo buffer)")


-------------------------------------------------------------------------------------------


function open(path)
	path = fullpath(path)
	-- TODO: something with hloc?
	local parts = split(path, "#", false)
	path = parts[1]
	local row = tonumber(parts[2])
	location = find_main(path)
	if location then
		local folder = parent_folder(location)
		cd(folder) -- is this useful?
		log([[creating filetree folder="]]..folder..[[" location="]]..location..[[" path="]]..path..[["]])
		filetree = scan_folder(fullpath(folder))
	else
		location = path
		log([[creating filetree single-file path="]] .. path .. [[" location="]] .. location .. [["]])
		filetree = scan_folder(fullpath(path))
	end
	fetch_buffers()
	set_current_path(path)
--	if current.buffer and row then
--		current.buffer:center_on(1, row)
--	end
	window {
		title = filetree.name .. (filetree.children and "/" or ""),
		location = location,
		unique_location = true
	}
end


function parent_folder(path)
	local segments = split(path, "/", false)
	return table.concat(segments, "/", 1, #segments - 1)
end


function find_main(path)
	while path ~= "" do
		local kind = fstat(path)
		if kind == "file" and sub(path, -9, -1) == "/main.lua" then
			log([[found main "]] .. path .. [["]])
			return path
		end
		if kind == "file" then
			path = parent_folder(path)
		end
		--log([[searching for main.lua in "]]..path..[["]])
		local maybe_main = path.."/main.lua"
		if fstat(maybe_main) == "file" then
			log([[found main "]] .. maybe_main .. [["]])
			return maybe_main
		end
		path = parent_folder(path)
	end
	return nil
end


function scan_folder(root_path)
	local segs = split(root_path, "/", false)
	local root_name = segs[#segs]
	local kind = fstat(root_path)
	if kind == "folder" then
		local children = {}
		local names = ls(root_path)
		sort(names)
		for name in all(names) do
			local child = scan_folder(root_path .. "/" .. name)
			if child then
				add(children, child)
			end
		end
		if #children == 0 then
			-- TODO: what about newly created folders?
			return nil
		end
		return {
			name = root_name,
			path = root_path,
			children = children,
		}
	elseif kind == "file" then
		local ext = root_path:ext()
		if ext ~= "lua" and ext ~= "txt" and ext ~= "md" then
			return nil
		end
--		local buffer, metadata = buffers.new(root_path, fetch(root_path))
--		if not buffer then return nil end
		return {
			name = root_name,
			path = root_path,
--			buffer = buffer,
--			metadata = metadata,
		}
	else
		notify("*** error while creating the filetree: unknown fstat result")
	end
	return nil
end


function sort(a)
	-- TODO: something better...
	for i = 1, #a do
		local j = i
		while j > 1 and a[j - 1] > a[j] do
			a[j] , a[j - 1] = a[j - 1] , a[j]
			j = j - 1
		end
	end
end


-------------------------------------------------------------------------------------------


function refresh()
	local new_tree = scan_folder(filetree.path)
	local new_nodes = {}
	for node, _ in nodes(new_tree) do
		new_nodes[node.path] = node
	end
	for node, _ in nodes() do
		if new_nodes[node.path] then
			-- TODO: check if file modified
			new_nodes[node.path] = nil
		else
			-- TODO: file has been deleted
		end
	end
	for _, new_node in pairs(new_nodes) do
		new_node.buffer, new_node.metadata = buffers.new(node.path, fetch(node.path))
		
	end
	--[[
	local old_nodes = {}
	for node, _ in nodes() do
		old_nodes[node.path] = node
	end
	filetree = scan_folder(filetree.path)
	for node, _ in nodes() do
		if old_nodes[node.path] then
			node.buffer = old_nodes[node.path].buffer
			node.metadata = old_nodes[node.path].metadata
		else
			node.buffer, node.metadata = buffers.new(node.path, fetch(node.path))
		end
	end
	]]--
end


--------------------------------------------------------------------------------


function merge_trees(old, new)
	for old_child in all(old.children) do
		
	end
end


--------------------------------------------------------------------------------


function switch_to(path, sender)
	-- TODO: hloc
	path = fullpath(path)
	local parts = split(path, "#", false)
	local path = parts[1]
	local row = tonumber(parts[2])
	if not filetree.children then
		if path == filetree.path then
			log([[switch_to: *found* single-file (path="]]..path..[[" folder="]]..filetree.path..[[")]])
		else
			log([[switch_to: not this single-file (path="]]..path..[[" folder="]]..filetree.path..[[")]])
		end
		return
	end
	if sub(path, 1, #filetree.path) ~= filetree.path then
		log([[switch_to: not in filetree folder (path="]]..path..[[" folder="]]..filetree.path..[[")]])
		return
	end
	log([[switch_to: path belongs to filetree folder (path="]]..path..[[" folder="]]..filetree.path..[[")]])
	local found = set_current_path(path)
	if found then
		log([[switch_to: *found* in filetree folder (path="]]..path..[[" folder="]]..filetree.path..[[")]])
--		if row then
--			log("switch_to: showing row "..row)
--			current.buffer:center_on(1, row) -- TODO: set cursor instead
--		end
		return
	end
	log([[switch_to: *new file* in filetree folder (path="]]..path..[[" folder="]]..filetree.path..[[")]])
	log("sending kill_process message to [" .. string.format("%03d", sender) .. "]")
	send_message(2, { event = "kill_process", proc_id = sender, exit_code = 0 })
end


-------------------------------------------------------------------------------------------


function fetch_buffers()
	local err
	for node, _ in nodes() do
		if not node.children then
			node.buffer, node.metadata = buffers.new(node.path, fetch(node.path))
			if not node.buffer then
				-- TODO: try to find what happened...
				-- maybe the file was deleted?
				err = err or "???"
			end
		end
	end
	return err	
end


-------------------------------------------------------------------------------------------


function save_all()
	foreach_(
		function(node, _level)
			if node and (not node.children) then
				local full_text = node.buffer:full_text_copy()
				--log([[saving "]]..node.path..[["]])
				-- TODO: stale file detection
				local err = store(node.path, full_text, {})
				-- TODO: stuff with hloc???
				node.metadata = fetch_metadata(node.path)
				if err then
					notify(err)
				end
			end
		end
	)

	if (sub(location, 1, 10) ~= "/ram/cart/") then
		local str
		if filetree.children then
			str = "saved all files in " .. filetree.path
		else
			str = "saved " .. filetree.path
		end
		if location:sub(1, 8) == "/system/" then
			notify(str .. " ** warning: changes to /system/ not written to disk **")
		else
			notify(str)
		end
	end
end


---------------------------------------------------------------------------------------


-- TODO: remove, use the iterator instead
function foreach_(func)
	if not filetree.children then
		func(filetree, 1)
		return
	end
	
	local function step(node, func, level)
		func(node, level)
		for child in all(node.children) do
			step(child, func, level + 1)
		end
	end

	step(filetree, func, 0)
end


-- Iterator on all filetree nodes:
-- `for node, level in nodes() do ... end`
function nodes(tree)
	local stack = { tree or filetree }
	local levels = { 0 }
	return function()
		if #stack == 0 then
			return nil
		end
		local node = table.remove(stack)
		local level = table.remove(levels)
		if node.children then
			for i = #node.children, 1, -1 do
				table.insert(stack, node.children[i])
				table.insert(levels, level + 1)
			end
		end
		return node, level
	end
end


-------------------------------------------------------------------------------------------


function current_node()
	return current
end


function current_path()
	if current then
		return current.path
	end
	return nil
end


function current_buffer()
	if current then
		return current.buffer or fake_buffer
	end
	return fake_buffer
end


function set_current(row)
	local node = find_row(row)
	if node and (not node.children) then
		current = node
	end
end


function set_current_path(path)
	-- TODO: check if file modified on disk?
	-- TODO: unsaved status?
	local found = nil
	foreach_(
		function(node, _level)
			if (not found) and (node.path == path) then
				found = node
			end
		end
	)
	if found then
		log([[set_current_path "]] .. path .. [["]])
		current = found
		return true
	end
	return false
end


-------------------------------------------------------------------------------------------


function find_row(target)
	local function step(node, current_row, target)
		if current_row == target then
			return node
		end
		current_row += 1
		for child in all(node.children) do
			local result, new_row = step(child, current_row, target)
			if result then
				return result, nil
			end
			current_row = new_row
		end
		return nil, current_row
	end
	return step(filetree, 0, target)
end


-------------------------------------------------------------------------------------------


function print_filetree()
	local str = "filetree:\n"
	for node, level in nodes() do
		for i = 1, level do str ..= "|   " end
		if node.children then
			str ..= node.name .. "\n"
		else
			str ..= node.name .. "\n"
		end		
	end
	printh(str)
end


-------------------------------------------------------------------------------------------


return {
	open = open,
	save_all = save_all,
	switch_to = switch_to,
	refresh = refresh,
	nodes = nodes,
	foreach = foreach_,
	current_node = current_node,
	current_path = current_path,
	current_buffer = current_buffer,
	set_current = set_current,
	find_row = find_row,
	print = print_filetree,
}


-------------------------------------------------------------------------------------------

:: src/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTIyIDE4OjIwOjExIixtb2RpZmllZD0iMjAyNS0w
My0yOCAxOTo1MjowMSJdXQ==
:: label.qoi
b64$cW9pZgAAAeAAAAEOBAH_--Ho-f39-f39-f3T-rkAPvI-wf6iiHnMP-39-f39-cUSxD-X-rkA
Pss-Esw-EsM-EtE--qKIec4--f39-cwSwD-AEsA-xxLBP8ASwT-LEsE-yBLEP8YSxj-JEj8SP90S
xT-GEsU-x-65AD7LPxLMPxLCP8ASwj8SzD-_ooh5zj-9-f39yxLAP8ISwD-GEsE-wBLBP8YSwj8S
wT-IEj-CEj-GEsY-yhI-yf65AD7BP8ASwT-P-qKIeT8SP9b_uQA_yj-CEsA-wBLBP8ESP8ISwT8S
wj8SzD-_ooh5zj-9-f39yxLAP8ISwD-GEsE-wBLBP8YSwj8SwT-IEj-CEj-GEsY-xhLHP8X_uQA_
wD-CEsA-y-6iiHnBPxLBP8YSxT-H-rkAPss-EsE-EsA-Ej8Swz8Swz8SwT8SzT-_ooh5xj8SxT-9
-f39yxLAP8ISwD-GEsY-xhLCP8wSP8ISP8YSxj-GEsA-wxLAP8X_uQA_wD-CEsA-y-6iiHk-Ej-a
-rkAPss-EsE-whLAP8ASwT8Swz8SwT8SzT-_ooh5xT-BEsQ--f39-csSwD-CEsA-xhI-EsI-Ej-G
EsU-yRI-wBLBP9YSwD-DEsA-xf65AD7AP8ISwD-L-qKIecU-xhLFP8f_uQA_yz8SwT8SxT8SwD8S
wz8SwD8Szj-_ooh5xj8SxT-9-f39yxLAP8ISwD-GEj8Swj8SP8YSxT-HEsE-wBLBP8YSxj-GEsA-
wxLAP8X_uQA_wD-CEsA-zP6iiHnEP9b_uQA_zD-AEsA-wRI-wRLCP8ASwD-BEj8Szj-_ooh5zj-9
-f39zBLAP8ASwD-HEsY-xhLFP8cSwT-LEsA-whLAP8YSxz-F-rkAPsE-wBLBP_oS9D-_ooh5zj-9
-f39-f3j-rkAPvQ--qKIec4--f39-f39-oN2nPr_ZUaI0f4dK1P9-f39-f3U-sLDx8UQ_jrRKP39
-f39-dQ7xRD6OtEo-f39-f391DvFEO4owhDGOtEo-f39-f391DvFEMIowRAoEOUoEMAowBDFOtEo
wzsoyjvAKMk7KMk7KDsowzsoyTso0TvAKMs7KDso-f39-es7xRDDKMAQwCgQyCjBECgQwSgQ0SgQ
wCgQKBDEOtEo0TsoyTsoyTsoOyjDOyjJOyjSOyjLOyg7KP39-f3rO8UQwigQKBDBKBDHKBAoECgQ
wSgQwijDEMgoEMAowhDDOswowDrBKMI7wCjAO8EowTvBKMA7KME7KMA7KMA7wSjAO8AoyzvBKDso
O8AowDvBKDsowDsoO8AoOyjBO8EoxDsowTsowDsowDvBKP39-f3vO8UQwigQwygQxyjBECgQwSgQ
wyjBEMkoEMMoEMM6zSg6wSjDOyjAOyjAOyg7KMM7KME7KMA7KDsowDsoOyjAOyjJOyjAOyg7wCjB
OyjAOyg7KDsowDsoOyg7KDsowDsoxDsowTsowDsoOyjAOyj9-f397zvFEMIoEMMoEMcoECgQKBDB
KBDEKBDKKBDJOs0oOsEowzsowDsowDsoOyjDOyjBOyjAOyg7KMA7KDvCKMk7KMA7KDsowjsowDso
O8AowTsoOyg7KDsowDsoxDsowTsowDsoOyjAOyj9-f397zvFEMMoEMEoEMgoECgQKMEQKMEQzygQ
wygQwzrNKDrBKMM7KMA7KMA7KDsowzsowTsowDsoOyjAOyg7KMw7KMA7KDsowjsowDsoOyg7KMA7
KME7KDsowDsoxDsowTsowDsoOyjAOyj9-f397zvFEMQowRDlKMIQKMEQwjrMKME6wCjCO8EoOyjA
OyjAO8EowTvAKMA7wSjAO8EowDvBKMo7wSg7KMM7wSg7KMA7KDsowTsowDvBKMA7KMI7wCjAO8Eo
wDvBKP39-f3vO8UQ9CgQwzrRKP39-f39-dQ7xRD6OtEo-f39-f391DvFEPo60Sj9-f39-f3UO8UQ
_jrRKP39-f39-dQ7xRDCKPIQwjrRKMM7KMo7wCjJOyjJOyg7KOk7KMw7KMo7wCjLOyg7KP39-f3J
O8UQ_jrRKNE7KMk7KMk7KDso0Tso1TsozDsoyzsoyzsoOyj9-f39yTvFEPo6zCjBOsAowjvAKMA7
wSjBO8EowDsowTsowDsowDvBKMA7wCjLO8EoOyg7wCjAO8EowTsowTvBKMA7wCjAO8EowTvBKDvC
KMA7wSg7wSjAO8IowDvBKMQ7KME7KMA7KMA7wSj9-f39zTvFEPo6zig6wCjDOyjAOyjAOyg7KMM7
KME7KMA7KDsowDsoOyjAOyjJOyjCO8AowTsowzsowTsowjsowDsoOyjAOyg7KMM7KME7KMA7KDso
wDsowDsowTsoxzsowTsowDsoOyjAOyj9-f39zTvFEPo6zCjBOsAowzsowDsowDsoOyjDOyjBOyjA
Oyg7KMA7KDvCKMo7wCjAOyjCOyjDOyjBOyjCOyjAOyg7KMA7KMA7wCjBOyjBOyjAOyg7KMA7KMA7
KMI7wCjFOyjBOyjAOyg7KMA7KP39-f3NO8UQ_jrMKDrCKMM7KMA7KMA7KDsowzsowTsowDsoOyjA
Oyg7KM87KDsowjsowjsowjsowjsowDsoOyjAOyjCOyjAOyjBOyjAOyg7KMA7KMA7KMQ7KMQ7KME7
KMA7KDsowDso-f39-c07xRDBKMAQwCjBECjBECgQKBDAKMAQwygQwSgQKBAowRDUOswowTrAKMI7
wSg7KMA7KMA7wSjBO8AowDvBKMA7wSjAO8EoyTvBKMA7KMM7wSg7KMM7wSjAO8AowDsowDsoO8Eo
wjvAKMA7wSg7KMA7KME7wCg7wSjBOyjCO8AowDvBKMA7wSj9-f39zTvFEMEoECgQKBDBKBAoECgQ
KBAoEMUoEMEoECgQKBAoENQ60Sj9-f39-f3UO8UQwSgQKBAowBDAKMAQwCgQKBAoEMUoEMEoECgQ
KMEQ1DrRKP39-f39-dQ7xRDBKBAoECgQwSgQKBAoECgQKBAoEMMoEMEoECgQKBAoENQ60Sj9-f39
-f3UO8UQwSjBECjBECjBEMAowBAowRDAKBDAKMEQwCjAECgQKBDUOtEo-f39-f391DvFEPo60SjD
OyjKO8AoyTsoyTsoOyjkOyjDOyjDO8AoyzsoOyj9-f393jvFEPo60SjROyjJOyjJOyg7KNE7KNY7
KMQ7KMs7KDso-f39-d47xRD6OswowTrAKMI7wCjAO8EowTvBKMA7KME7KMA7KMA7wSjAO8AoyzvB
KDsoO8AowDvBKME7KME7wSjAO8EoOyg7wCg7wCjBO8EoxDsowTsowDsowDvBKP39-f3iO8UQ3CgQ
2zrOKDrAKMM7KMA7KMA7KDsowzsowTsowDsoOyjAOyg7KMA7KMk7KMI7wCjBOyjDOyjBOyjCOyjA
Oyg7wCjCOyjAOyjAOyjEOyjBOyjAOyg7KMA7KP39-f3iO8UQwSjAEMAowRDAKMAQKMEQwCjAECjA
EMMoENs6zSjAOsAowzsowDsowDsoOyjDOyjBOyjAOyg7KMA7KDvCKMo7wCjAOyjCOyjDOyjCO8Ao
wDsowDsoOyjDOyjAOyjAOyjEOyjBOyjAOyg7KMA7KP39-f3iO8UQwSgQKBAoEMEoEMIoEMAoEMEo
ECgQwSgQ3DrOKDrAKMM7KMA7KMA7KDsowzsowTsowDsoOyjAOyg7KM87KDsowjsowjsoxTsoOyjA
Oyg7KMM7KMA7KMA7KMQ7KME7KMA7KDsowDso-f39-eI7xRDBKBAoECjAEMAowRDAKBDAKBDBKBAo
EMEoENw6zCjBOsAowjvBKDsowDsowDvBKME7wCjAO8EowDvBKMA7wSjJO8EowDsowzvBKDsowjvB
KME7wSg7KMI7wSjAO8EowDsowjvAKMA7wSjAO8Eo-f39-eI7xRDBKBAoECgQwygQwCgQwCgQKBAo
ECgQwCgQ3TrRKP3MOyj9-f39-cU7xRDBKMEQKMEQKMAQwCjBECjBECgQKBDAKBDdOtEo-co7wCj9
-f39-cY7xRD6OtEo-f39-f391DvFEPo60Sj9-f39-f3UO8UQ_jrRKMM7KMo7wCjJOyjJOyg7KNQ7
KM07KMM7KMM7wCjLOyg7KP39-f3eO8UQ_jrRKNE7KMk7KMk7KDso0TsowDso0zsoxDsoyzsoOyj9
-f393jvFEMgowBAowRAowRAoEMEoEMIowBDDKMEQKBAoECjBEMo6zCg6KDrAKMI7wCjAO8EowTvB
KMA7KME7KMA7KMA7wSjAO8AoyzvBKDsoO8AowDvBKME7KMA7wSjBO8EoOyg7wCg7wCjBO8EoxDso
wTsowDsowDvBKP39-f3iO8UQxygQwSgQKBAoEMEoEMEoEMEoEMYoEMAoECgQwCgQyzrMKDooOsAo
wzsowDsowDsoOyjDOyjBOyjAOyg7KMA7KDsowDsoyTsowjvAKME7KMM7KME7KMA7KDsowDsoO8Ao
wjsowDsowDsoxDsowTsowDsoOyjAOyj9-f394jvFEMcowRAowRAowBDAKBDBKBDBKMEQxCgQwSgQ
wSgQyzrMKME6wCjDOyjAOyjAOyg7KMM7KME7KMA7KDsowDsoO8IoyjvAKMA7KMI7KMM7KME7KMA7
KDsowDsoOyjDOyjAOyjAOyjEOyjBOyjAOyg7KMA7KP39-f3iO8UQySgQKBDBKBDBKBDBKBDDKBDE
KBDAKBAoEMAoEMs6zig6wCjDOyjAOyjAOyg7KMM7KME7KMA7KDsowDsoOyjPOyg7KMI7KMI7KMI7
KMA7KDsowDsoOyjDOyjAOyjAOyjEOyjBOyjAOyg7KMA7KP39-f3iO8UQxyjAEMAoEMEowRAowRAo
wRAowBDBKBDBKBDAKBAoEMAoEMs6zig6wCjCO8EoOyjAOyjAO8EowTvAKMA7wSjAO8EowDvBKMk7
wSjAOyjDO8EoOyjCOyjAOyjAO8EoOyjCO8EowDvBKMA7KMI7wCjAO8EowDvBKP39-f3iO8UQ_jrR
KP3MOyj9-f39-cU7xRD6OtEo-co7wCj9-f39-cY7xRD6OtEo-f39-f391DvFEPo60Sj9-f39-f3U
O8UQwSjAEMAowRAowRAoECgQKMIQwCjBEMMoEMEoECgQKMEQzjrRKMM7KMo7wCjJOyjJOyg7KNo7
KMQ7wCjLOyg7KP39-f3tO8UQwSgQKBAoECgQKBAoECgQKBAoECgQKBAoECgQwygQwSgQKBAoECgQ
zjrRKNE7KMk7KMk7KDso0TsozjsoyzsoOyj9-f397TvFEMEoECgQKMAQwCjBECjAEMAoECgQKBAo
wRDDKBDBKBAoECjBEM46zCjBOsAowjvAKMA7wSjBO8EowDsowTsowDsowDvBKMA7wCjLO8EoOyg7
wCjAO8EowTsowDsowDsoO8AoxTsowTsowDsowDvBKP39-f3xO8UQwSgQKBAoECgQKBAoECgQKBAo
ECgQKBAoECgQwygQwSgQKBAoECgQzjrMKDrCKMM7KMA7KMA7KDsowzsowTsowDsoOyjAOyg7KMA7
KMk7KMI7wCjBOyjDOyjBOyjAOyjAOyjFOyjBOyjAOyg7KMA7KP39-f3xO8UQwSjBECgQKBAoECgQ
KBAoECgQwSgQKBAoEMAoEMAowRDAKMAQKBAoEM46zCjBOsAowzsowDsowDsoOyjDOyjBOyjAOyg7
KMA7KDvCKMo7wCjAOyjCOyjDOyjBOyjAOyjAOyjFOyjBOyjAOyg7KMA7KP39-f3xO8UQ_jrOKDrA
KMM7KMA7KMA7KDsowzsowTsowDsoOyjAOyg7KM87KDsowjsowjsowjsowDsowDsoxTsowTsowDso
OyjAOyj9-f398TvFEPo6zCjBOsAowjvBKDsowDsowDvBKME7wCjAO8EowDvBKMA7wSjJO8EowDso
wzvBKDsowzvBKDvBKMA7KMI7wCjAO8EowDvBKP39-f3xO8UQ_jrRKP39-f39-dQ7xRD6OtEo-f39
-f391DvFEME7whDAO8EQO8EQO8AQxDsQwTsQOxA7wRDWOtEo-f39-f391DvFEME7EDsQOxA7EDsQ
wDsQwDsQOxDDOxDBOxA7EDsQOxDWOtEo-f39-f391DvFEME7EDsQOxA7wRDAOxDAOxA7EMM7EME7
EDsQO8EQ1jrRKMM7KMo7wCjJOyjJOyg7KNQ7wCjMOyjfOyjCOyjOO8AoyzsoOyj9-f3wO8UQwTsQ
OxA7EDsQOxDAOxDAOxA7EMM7EME7EDsQOxA7ENY60SjROyjJOyjJOyg7KNE7KME7KNY7KNU7KNQ7
KMs7KDso-f398DvFEME7EME7EDsQOxA7wRA7EDsQwDsQwDvBEMA7wBA7EDsQ1jrMKDrCKMI7wCjA
O8EowTvBKMA7KME7KMA7KMA7wSjAO8AoyzvBKDsoO8AowDvBKME7KME7KMI7wCjBO8EoO8AowTvB
KME7KME7wSg7KDvAKMA7wCjBO8EoO8IoO8AowTvAKMA7wSjFOyjBOyjAOyjAO8Eo-f399DvFEPo6
zCg6wijDOyjAOyjAOyg7KMM7KME7KMA7KDsowDsoOyjAOyjJOyjCO8AowTsowzsowjsowTsowDso
OyjAOyjAOyjAOyjDOyjBOyjCO8AowTsowDsoOyjAOyjAOyjCOyjAOyjAOyg7KMA7KMQ7KME7KMA7
KDsowDso-f399DvFEPo6zCjBOsAowzsowDsowDsoOyjDOyjBOyjAOyg7KMA7KDvCKMo7wCjAOyjC
OyjDOyjCOyjBOyjAOyg7KMA7KMA7KMA7KMM7KME7KMI7KMI7wig7KMA7KMA7KMI7KMA7KMA7KDso
wDsoxDsowTsowDsoOyjAOyj9-f30O8UQ_jrMKDooOsAowzsowDsowDsoOyjDOyjBOyjAOyg7KMA7
KDsozzsoOyjCOyjCOyjDOyjBOyjAOyg7KMA7KMA7KMA7KMI7KMI7KMI7KMI7KMI7KMA7KMA7KMI7
KMA7KMA7KDsowDsoxDsowTsowDsoOyjAOyj9-f30O8UQ0CgQ5zrMKME6wCjCO8EoOyjAOyjAO8Eo
wTvAKMA7wSjAO8EowDvBKMk7wSjAOyjDO8EoOyjEO8AowDvAKME7wSg7wSjAO8EoOyjDO8EoOyjD
O8EowDvBKME7wCg7wSjAO8AowDsowDsowDsowjvAKMA7wSjAO8Eo-f399DvFEMIowBAowRDAKMAQ
wigQ5zrRKP3ROyj9-f39-cA7xRDBKBDBKBAoECgQwygQ6DrRKP3PO8Ao-f39-f3BO8UQwSjBECjA
EMAoEMMoEOg60Sj9-f39-f3UO8UQwygQKBAoECgQwigQ6TrRKP39-f39-dQ7xRDBKMAQwCgQKBDA
KMAQwCgQ6TrRKMM7KMo7wCjJOyjJOyg7KNQ7wCjMOyjWOyjGOyjDOyjOO8AoyzsoOyj9-f3vO8UQ
_jrRKNE7KMk7KMk7KDso0TsowTso1jsozDsoxjso1TsoyzsoOyj9-f3vO8UQ_jrMKME6wCjCO8Ao
wDvBKME7wSjAOyjBOyjAOyjAO8EowDvAKMs7wSg7KDvAKMA7wSjBOyjBOyjCO8AowTvBKDvAKME7
wSjBOyjAO8AoOyjBO8EoO8IowDvBKDvBKMA7wCjAO8EowTvBKMQ7KME7KMA7KMA7wSj9-f3zO8UQ
_jrOKDrAKMM7KMA7KMA7KDsowzsowTsowDsoOyjAOyg7KMA7KMk7KMI7wCjBOyjDOyjCOyjBOyjA
Oyg7KMA7KMA7KMA7KMM7KME7KDsoOyg7KMA7KMA7KME7KMI7KMA7KMA7KMA7KMA7KDsowDsoxDso
wTsowDsoOyjAOyj9-f3zO8UQ_jrOKDrAKMM7KMA7KMA7KDsowzsowTsowDsoOyjAOyg7wijKO8Ao
wDsowjsowzsowjsowTsowDsoOyjAOyjAOyjAOyjDOyjBOyg7KDsoOyjAOyjAOyjBOyjCOyjAOyjA
OyjAOyjAOyg7KMA7KMQ7KME7KMA7KDsowDso-f398zvFEMgowBDAKMAQKMAQwSjAECjBECjBECjA
EMAowRDAKMAQwygQwSgQxDrOKDrAKMM7KMA7KMA7KDsowzsowTsowDsoOyjAOyg7KM87KDsowjso
wjsowzsowTsowDsoOyjAOyjAOyjAOyjCOyjCOyjBOyg7KMA7KMA7KME7KMI7KMA7KMA7KMA7KMA7
KDsowDsoxDsowTsowDsoOyjAOyj9-f3zO8UQxygQwSgQKBAoECgQKBDCKBDAKBAoECgQKBDAKBDA
KBDFKBDBKBDEOs4oOsAowjvBKDsowDsowDvBKME7wCjAO8EowDvBKMA7wSjJO8EowDsowzvBKDso
xDvAKMA7wCjBO8EoO8EowDvBKDsowjsowTsowDvBKME7wCjAO8EoOyjAOyg7wSg7KMA7KMA7wSjA
OyjCO8AowDvBKMA7wSj9-f3zO8UQxygQwSgQKBAoECgQKMEQwCgQwCjBECgQKBDAKBDAKMEQwygQ
wSgQxDrRKP3ROyjzOyj9-f39yDvFEMcoEMEoECgQKBAoEMEoEMAoEMAoECgQKBAoEMAoEMIoEMMo
EMEoEMQ60Sj9zzvAKPI7wCj9-f39yTvFEMgowBAowBDAKBAoECjAEMEoEMAoECgQKBAoEMAoEMAo
wBDBKBDAKMEQwCgQwzrRKP39-f39-dQ7-v93qMM7EPo60Sj9-f39-f3UO8UQ_jrRKMM7KMo7wCjJ
OyjJOyg7KNQ7wCjMOyjZO8AowTvAKMo7wCjLOyg7KP39-fk7xRD6OtEo0TsoyTsoyTsoOyjROyjB
OyjWOyjQOyjCOyjLOyjLOyg7KP39-fk7xRD6OswowTrAKMI7wCjAO8EowTvBKMA7KME7KMA7KMA7
wSjAO8AoyzvBKDsoO8AowDvBKME7KME7KMI7wCjBO8EoO8AowTvBKME7KME7wSg7wSjBO8AowTso
wjsowjvBKMQ7KME7KMA7KMA7wSj9-f39O8UQyCjAECjBECgQKBDDKBDBKBAoECjBENY6zCg6KDrA
KMM7KMA7KMA7KDsowzsowTsowDsoOyjAOyg7KMA7KMk7KMI7wCjBOyjDOyjCOyjBOyjAOyg7KMA7
KMA7KMA7KMM7KME7KMI7KMA7KDsowDsowDsowjsowTsoxzsowTsowDsoOyjAOyj9-f39O8UQxygQ
wSgQwSgQKBDDKBDBKBAoECgQKBDWOswowTrAKMM7KMA7KMA7KDsowzsowTsowDsoOyjAOyg7wijK
O8AowDsowjsowzsowjsowTsowDsoOyjAOyjAOyjAOyjDOyjCO8AowDsowDsoO8IowDsowjsowjvA
KMU7KME7KMA7KDsowDso-f39-TvFEMcoEMEowBDBKBDEKBDBKBAoECjBENY6zCg6KDrAKMM7KMA7
KMA7KDsowzsowTsowDsoOyjAOyg7KM87KDsowjsowjsowzsowTsowDsoOyjAOyjAOyjAOyjCOyjF
Oyg7KMA7KDsowzsowjsoxDsoxDsowTsowDsoOyjAOyj9-f39O8UQxygQKBAoEMEoECgQwygQwSgQ
KBAoECgQ1jrMKME6wCjCO8EoOyjAOyjAO8EowTvAKMA7wSjAO8EowDvBKMk7wSjAOyjDO8EoOyjE
O8AowDvAKME7wSg7wSjAO8EoOyjCO8EowDvBKME7wSjBO8AowTvAKDvBKME7KMI7wCjAO8EowDvB
KP39-f07xRDHKMEQKBDBKBAoEMAoEMAowRDAKMAQKBAoENY60Sj90Tso0jso-f39-ek7xRD6OtEo
-c87wCjTOyj9-f396TvFEPo60Sj9-f39-f3UO8UQ_jrRKP39-f39-dQ7xRD6OtEowzsoyjvAKMk7
KMk7KDso1DvAKMw7KNo7KM07KM47wCjLOyg7KP39-eo7xRDHKBAoEMAowBAowRAowRAowBDEKBDB
KBAoECjBEM460SjROyjJOyjJOyg7KNE7KME7KNY7KNA7KN87KMs7KDso-f396jvFEMcoECgQKBDB
KBAoEMAoEMAoECgQwygQwSgQKBAoECgQzjrMKME6wCjCO8AowDvBKME7wSjAOyjBOyjAOyjAO8Eo
wDvAKMs7wSg7KDvAKMA7wSjBOyjBOyjCO8AowTvBKDvAKME7wSjBOyjAO8AoOyjBO8AowTvBKDvB
KME7wSg7wSjAO8AowTvBKMA7wSjEOyjBOyjAOyjAO8Eo-f397jvFEMcowRAoEMEowBDBKBDAKBAo
EMMoEMEoECgQKMEQzjrMKDooOsAowzsowDsowDsoOyjDOyjBOyjAOyg7KMA7KDsowDsoyTsowjvA
KME7KMM7KMI7KME7KMA7KDsowDsowDsowDsowzsowTsoOyg7KDsowDsoOyjCOyjAOyg7KMA7KDso
wDsowDsowDsowjsoxzsowTsowDsoOyjAOyj9-f3uO8UQxygQKBAoECgQKBAoEMAoEMAoECgQwygQ
wSgQKBAoECgQzjrMKME6wCjDOyjAOyjAOyg7KMM7KME7KMA7KDsowDsoO8IoyjvAKMA7KMI7KMM7
KMI7KME7KMA7KDsowDsowDsowDsowzsowTsoOyg7KDvCKDsowjsowDsoOyjAOyg7KMA7KMA7KMA7
KMM7wCjFOyjBOyjAOyg7KMA7KP39-e47xRDHKBAoECjBECgQKBAowRAowRDAKBDAKMEQwCjAECgQ
KBDOOs4oOsAowzsowDsowDsoOyjDOyjBOyjAOyg7KMA7KDsozzsoOyjCOyjCOyjDOyjBOyjAOyg7
KMA7KMA7KMA7KMI7KMI7KME7KDsowjsowjsowDsoOyjAOyg7KMA7KMA7KMA7KMU7KMQ7KME7KMA7
KDsowDso-f397jvFEPo6zig6wCjCO8EoOyjAOyjAO8EowTvAKMA7wSjAO8EowDvBKMk7wSjAOyjD
O8EoOyjEO8AowDvAKME7wSg7wSjAO8EoOyjCOyjBOyjAO8EowDvBKDsowDsowDvBKDsowDsoO8Eo
wDvBKDvBKME7KMI7wCjAO8EowDvBKP39-e47xRD6OtEo-dE7KP39-f39wDvFEPo60Sj9zzvAKP39
-f39wTvFEPo60Sj9-f39-f3UO8UQxyjBECjAEMUowBAowRAowhDAKMEQwygQwSgQKBAowRDEOtEo
-f39-f391DvFEMgoEMAoECgQwygQwSgQKBAoECgQKBAoEMUoEMEoECgQKBAoEMQ60SjDOyjKO8Ao
yTsoyTsoOyjbO8AoyDvAKMs7KDso-f39-ec7xRDIKBDAKBAoEMMoEMEowRAoECgQKBAowBDEKBDB
KBAoECjBEMQ60SjROyjJOyjJOyg7KNE7KMY7KMs7KMs7KDso-f39-ec7xRDIKBDAKBAoEMMoECgQ
KBAoECgQKBAoECgQxSgQwSgQKBAoECgQxDrIKMA6wCjBOsAowjvAKMA7wSjBO8EowDsowTsowDso
wDvBKMA7wCjLO8EoOyg7wCjAO8EowTsowTvBKMA7KME7KMA7KMQ7KME7KMA7KMA7wSj9-f396zvF
EMcowRAoECgQKMEQKMEQKBAoECgQwSgQKMEQwCgQwCjBEMAowBAoECgQxDrJKDrAKDooOsAowzso
wDsowDsoOyjDOyjBOyjAOyg7KMA7KDsowDsoyTsowjvAKME7KMM7KME7KMA7KDvCKDsowDsoxDso
wTsowDsoOyjAOyj9-f396zvFEPo6ySg6wCg6KDrAKMM7KMA7KMA7KDsowzsowTsowDsoOyjAOyg7
wijKO8AowDsowjsowzsowTsowDsowDsowjvAKMU7KME7KMA7KDsowDso-f39-es7xRD6OskoOsAo
Oig6wCjDOyjAOyjAOyg7KMM7KME7KMA7KDsowDsoOyjPOyg7KMI7KMI7KMI7KMA7KMA7KME7KMA7
KMQ7KME7KMA7KDsowDso-f39-es7xRD6OsgowToowTrAKMI7wSg7KMA7KMA7wSjBO8AowDvBKMA7
wSjAO8EoyTvBKMA7KMM7wSg7KMM7wSjAOyjBOyjAOyjAOyjCO8AowDvBKMA7wSj9-f396zvFEPo6
0Sj9xzso-f39-f3KO8UQxyjBECjAEMQowhDBKMAQKMAQwCjBEMQowBAowRAoEMY60Sj9xTvAKP39
-f39yzvFEMgoEMAoECgQwygQKBAoECgQKBAoECgQKBDFKBDBKBDBKBDGOtEo-f39-f391DvFEMgo
EMAoECgQwygQKBAoECgQKBAoECgQKMAQxCjBECjAEMAoEMY60Sj9-f39-f3UO8UQyCgQwCgQKBDD
KBAoECgQKBAoECgQKBAoEMcoECgQwSgQxjrRKMM7KMo7wCjJOyjJOyg7KNU7KOM7wCjLOyg7KP39
-f3TO8UQxyjBECgQKBAowRAoEMEoECjAEMAowRAowRAowRAowBDAKMEQKMEQxDrRKNE7KMk7KMk7
KDso0Tso6DsoyzsoOyj9-f390zvFEPo6yCjAOsAowDrBKMI7wCjAO8EowTvBKMA7KME7KMA7KMA7
wSjAO8AoyzvBKDsoO8AowDvBKME7KMA7wCjAO8EoxjvBKMA7wSg7wCg7KME7wCjFOyjBOyjAOyjA
O8Eo-f39-dc7xRD6OskoOsEoOsEowzsowDsowDsoOyjDOyjBOyjAOyg7KMA7KDsowDsoyTsowjvA
KME7KMM7KMI7KMA7KMA7KMQ7KMA7KDsowDsoOyg7KDsoOyjAOyjEOyjBOyjAOyg7KMA7KP39-f3X
O8UQ_jrJKDrBKDrBKMM7KMA7KMA7KDsowzsowTsowDsoOyjAOyg7wijKO8AowDsowjsowzsowjso
wDsowDsoxDsowDsoOyjAOyg7KDsoOyg7wijEOyjBOyjAOyg7KMA7KP39-f3XO8UQ_jrJKDrBKDrB
KMM7KMA7KMA7KDsowzsowTsowDsoOyjAOyg7KM87KDsowjsowjsowzsowDsowDsoxDsowDsoOyjA
Oyg7KME7KDsoxzsowTsowDsoOyjAOyj9-f391zvFEMcowRAowBDEKMEQKMEQKMEQKBDBKMEQKBAo
ECjAEMEowBAoEMQ6yCjBOijBOsAowjvBKDsowDsowDvBKME7wCjAO8EowDvBKMA7wSjJO8EowDso
wzvBKDsowjvBKDsowDsoO8IowDvBKMA7wSg7KME7KMA7wSjAOyjCO8AowDvBKMA7wSj9-f391zvF
EMgoEMAoECgQwygQKBAoECgQKBDBKBDBKBAoECgQKBAoECgQKBDBKBDEOtEo-dU7KP39-f36O8UQ
yCgQwCgQKBDDKMEQKMAQwCjAEMAoEMEowRAoECgQKBAoECgQwSjAEMM60Sj90zvAKP39-f37EM8o
EMAoECgQwygQwSgQKBAoEMEoEMEoECgQKBAoECgQKBAoEMEoEMQ60Sj9-f39-f3UEM4owRAoECgQ
KMEQKBDBKBAoECjBECjBECgQKBDAKMAQKBAoEMAowBAoEMQ60Sj9-f39-f3UEP3DOtEowzsoyjvA
KMk7KMk7KDso1Tso2Dso0zvAKMw7KMI7KM47wCjLOyg7KP39-eAQ-cM60SjROyjJOyjJOyg7KNE7
KNw7KNQ7KMw7KNQ7KMs7KDso-f394BD9wzrIKMA6wCjBOsAowjvAKMA7wSjBO8EowDsowTsowDso
wDvBKMA7wCjLO8EoOyg7wCjAO8EowTsowDvAKMA7wSjFO8AoOyjBO8AowTvBKMA7wCjGO8EowDvA
KME7KMI7wCjBO8EoO8IoO8AowTvAKMA7wSjFOyjBOyjAOyjAO8Eo-f395BD9wzrJKDrCKDrAKMM7
KMA7KMA7KDsowzsowTsowDsoOyjAOyg7KMA7KMk7KMI7wCjBOyjDOyjCOyjAOyjAOyjEOyg7KDso
OyjAOyg7KMA7KDsowDsoxDsowjsowDsowDsowTsowDsoOyjDOyjCOyjAOyjAOyg7KMA7KMQ7KME7
KMA7KDsowDso-f395BDOKMEQKMAQxCjBECjBECjBECgQwSjBECgQKBAowBDBKMAQKBDEOskoOsAo
wTrAKMM7KMA7KMA7KDsowzsowTsowDsoOyjAOyg7wijKO8AowDsowjsowzsowjsowDsowDsoxDso
Oyg7KDsowDsoOyjAOyg7wijFO8AowDvCKMA7KME7wig7KMM7KMI7KMA7KMA7KDsowDsoxDsowTso
wDsoOyjAOyj9-f3kEM8oEMAoECgQwygQKBAoECgQKBDBKBDBKBAoECgQKBAoECgQKBDBKBDEOsko
OsAoOsIowzsowDsowDsoOyjDOyjBOyjAOyg7KMA7KDsozzsoOyjCOyjCOyjDOyjAOyjAOyjEOyjB
Oyg7KMA7KDsowDsoOyjKOyg7KMM7KME7KMI7KMM7KMI7KMA7KMA7KDsowDsoxDsowTsowDsoOyjA
Oyj9-f3kEM8oEMAoECgQwyjBECjAEMAowBDAKBDBKMEQKBAoECgQKBAoEMEowBDDOsgowToowTrA
KMI7wSg7KMA7KMA7wSjBO8AowDvBKMA7wSjAO8EoyTvBKMA7KMM7wSg7KMI7wSg7KMA7KDvCKDso
wTsowDvAKME7wSjAO8EoO8IoO8EowTvBKME7wCjAO8EowDvBKME7wCg7wSjAO8AowDsowDsowDso
wjvAKMA7wSjAO8Eo-f395BDPKBDAKBAoEMMoEMEoECgQKBDBKBDBKBAoECgQKBAoECgQKBDBKBDE
OtEo-f39-f391BDOKMEQKBAoECjBECgQwSgQKBAowRAowRAoECgQwCjAECgQKBDAKMAQKBDEOtEo
-f39-f391BD9wzrRKP39-f39-dQQ-cM60Sj9-f39-f3UEP3DOtEowzsoyjvAKMk7KMk7KDso1Tso
2TvAKNU7KNQ7KOE7wCjLOyg7KP39-ccQ5SgQ2TrRKNE7KMk7KMk7KDso0Tso3jso1Tso1Dso4jso
yzsoOyj9-f3HEM4oEMIowBDAKMAQKMEQwCjAEMIoENk6yCjAOsAowTrAKMI7wCjAO8EowTvBKMA7
KME7KMA7KMA7wSjAO8AoyzvBKDsoO8AowDvBKME7KMA7wCjAO8EoxTvBKMA7KDvAKMA7wCjBOyjC
O8EoOyjAOyg7wSjBO8EoO8EoxjvAKMA7wSjBO8EoOyjAOyg7KDvAKMA7wSg7wSjBO8EowDvAKMU7
KME7KMA7KMA7wSj9-f3LEM4oEMEoECgQKBDCKBDAKBDDKBDaOskoOsIoOsAowzsowDsowDsoOyjD
OyjBOyjAOyg7KMA7KDsowDsoyTsowjvAKME7KMM7KMI7KMA7KMA7KMQ7KMA7KDvAKME7KMA7KMA7
KME7KMA7KDsowDsoOyjAOyg7KMI7KMA7KMQ7KMA7KDsowDsoOyjAOyg7KMA7KDvAKME7KMA7KDso
wDsoOyjCOyjAOyjEOyjBOyjAOyg7KMA7KP39-csQzigQwSgQKBAoEMIoEMAoEMMoENo6ySg6wSjA
OsAowzsowDsowDsoOyjDOyjBOyjAOyg7KMA7KDvCKMo7wCjAOyjCOyjDOyjCOyjAOyjAOyjEOyjA
Oyg7KMI7wijAOyjBOyjAOyg7KMA7KDsowDsoOyjCOyjAOyjEO8IoOyjAOyg7KMA7KDsowDsoOyjC
OyjAOyg7KMA7KDsowjvCKMQ7KME7KMA7KDsowDso-f39yxDOKBDBKBAoECgQKBDAKBDAKBDCKBDb
OskoOsIoOsAowzsowDsowDsoOyjDOyjBOyjAOyg7KMA7KDsozzsoOyjCOyjCOyjDOyjAOyjAOyjE
OyjAOyg7KMI7KMM7KME7KMA7KDsowDsoOyjAOyg7KMI7KMA7KMQ7KMI7KMA7KDsowDsoOyjAOyg7
KMI7KMA7KDsowDsoOyjCOyjHOyjBOyjAOyg7KMA7KP39-csQzijBECjAEMAowRAowRDAKMAQwCgQ
2zrIKME6KME6wCjCO8EoOyjAOyjAO8EowTvAKMA7wSjAO8EowDvBKMk7wSjAOyjDO8EoOyjCO8Eo
OyjAOyg7wig7wSjAOyjDO8EowTvAKMA7wSjAO8EoOyjAOyjAO8EoOyjAOyg7wijAO8EoOyjAOyjA
O8EowDvBKDsowzvBKDsowDsowDvBKMA7wSjAOyjCO8AowDvBKMA7wSj9-f3LEP3DOtEo-dI7KP39
-f39EP3DOtEo-dI7KP39-f39EP3DOtEo-f39-f391BD9wzrRKP39-f39-dQQ1SjAECjBECjBECjB
ECjBECjBEMAowBAowBDEKBDGOtEowzsoyjvAKMk7KMk7KDso1Tso2TvAKNU7KOU7wCjLOyg7KP39
-doQ1CgQwSgQKBAoEMEoECgQwCgQwSgQwCgQKBAoECgQwygQxjrRKNE7KMk7KMk7KDso0Tso3jso
1Tso5jsoyzsoOyj9-f3aENQoEMEowBDAKMAQwCjBEMAoEMEoEMAoECgQKBAoEMMoEMY6yCjAOsAo
Oig6wCjCO8AowDvBKME7wSjAOyjBOyjAOyjAO8EowDvAKMs7wSg7KDvAKMA7wSjBOyjAO8AowDvB
KMU7wSjAOyg7wCjAO8AowTsowjvBKDsowDsoO8EowTvBKDvBKMU7KME7KMA7wSg7KMA7KMA7wCjB
O8EoxDsowTsowDsowDvBKP39-d4Q1CgQwSgQKBAoEMEoECgQwCgQwSgQwCgQKBAoECgQwygQxjrJ
KDrAKDooOsAowzsowDsowDsoOyjDOyjBOyjAOyg7KMA7KDsowDsoyTsowjvAKME7KMM7KMI7KMA7
KMA7KMQ7KMA7KDvAKME7KMA7KMA7KME7KMA7KDsowDsoOyjAOyg7KMI7KMA7KMQ7KME7KDsowDso
OyjAOyg7KMA7KDsoxzsowTsowDsoOyjAOyj9-f3eENUowBAoECgQKMEQKBAoEMAoEMAowRAowBDA
KBAoEMAoEMAowRDEOskoOsAowTrAKMM7KMA7KMA7KDsowzsowTsowDsoOyjAOyg7wijKO8AowDso
wjsowzsowjsowDsowDsoxDsowDsoOyjCO8IowDsowTsowDsoOyjAOyg7KMA7KDsowjsowDsoxDso
Oyg7KDsowDsoOyjAOyg7wijAO8AoxTsowTsowDsoOyjAOyj9-f3eEP3DOskoOsIoOsAowzsowDso
wDsoOyjDOyjBOyjAOyg7KMA7KDsozzsoOyjCOyjCOyjDOyjAOyjAOyjEOyjAOyg7KMI7KMM7KME7
KMA7KDsowDsoOyjAOyg7KMI7KMA7KMQ7KDsoOyg7KMA7KDsoOyjAOyjFOyjEOyjBOyjAOyg7KMA7
KP39-d4Q-cM6yCjBOsEoOsAowjvBKDsowDsowDvBKME7wCjAO8EowDvBKMA7wSjJO8EowDsowzvB
KDsowjvBKDsowDsoO8IoO8EowDsowzvBKME7wCjAO8EowDvBKDsowDsowDvBKDsowDsoO8IowDso
OyjBO8EoO8AowjvBKDvBKME7KMI7wCjAO8EowDvBKP39-d4Q-cM60Sj90jso-f39-f0Q-cM60Sj9
0jso-f39-f0Q1CjCEMAowRAowRDAKMAQKBAoECjBECjAEMEowBDDKBDEOtEo-f39-f391BDUKBAo
ECgQKBAoEMAoEMAoEMEoECgQwCgQwCgQKBAoEMUoEMQ60Sj9-f39-f3UENQoECgQKBAowRDAKBDA
KBDBKMEQwCgQwCgQKBAoEMUoEMQ60SjNOyjKO8AoyTsoyTsoOyjDOyjEOyjQO8AoyzsoOyj9-f39
5xDUKBAoECgQKBAoEMAoEMAoEMEoECgQwCgQwCgQKBAoECgQwygQxDrRKNs7KMk7KMk7KDsowzso
xDso0TsoyzsoOyj9-f395xDUKBDBKBAoECgQwCgQwSjAECgQKBAowRAoECgQKMEQwCgQwCjAEMM6
yCjAOsAowTrAKMw7wCjAO8EowTvBKMA7KME7KMA7KMA7wSjAO8AoyzvBKMA7wCjAO8EowDsowDso
wDvBKMQ7KME7KMA7KMA7wSj9-f396xD9wzrJKDrAKDrCKM07KMA7KMA7KDsowzsowTsowDsoOyjA
Oyg7KMA7KMk7KMA7KDsowDsoOyjAOyg7KMA7KDsowDsoxDsowTsowDsoOyjAOyj9-f396xD9wzrJ
KDrAKME6wCjCO8IoO8IowDsowDsowDsoOyjDOyjBOyjAOyg7KMA7KDvCKMk7KMA7KDvCKDsowDso
OyjAOyg7KMA7KMQ7KME7KMA7KDsowDso-f39-esQ-cM6ySg6wig6wCjNOyjAOyjAOyg7KMM7KME7
KMA7KDsowDsoOyjMOyjAOyg7KMI7KMA7KDsowDsoOyjAOyjEOyjBOyjAOyg7KMA7KP39-f3rEP3D
OsgowToowTrAKMw7wSg7KMA7KMA7wSjBO8AowDvBKMA7wSjAO8EoyjvBKMA7wSg7wSjBO8EowDvB
KMA7KMI7wCjAO8EowDvBKP39-f3rENQowhDAKMEQwCjAECgQKBAowRAowBDAKMEQwCjAEMAowBDG
OtEo-dE7KP39-f39wBDUKBAoECgQKBDBKBDBKBAoECgQKBAoECgQwCgQwCgQwSgQyDrRKP3PO8Ao
-f39-f3BENQoECgQKBAowBDAKBDBKMEQKMEQKBAoEMAoEMAoEMEowRDGOtEowh3DKP39-f39-csQ
1CgQKBAoECgQwSgQwSgQKBAoECgQKBAoEMAoEMAoEMMoEMY60SjCHcMo-f39-f39yxDUKBDBKBAo
wRDAKMAQKBAoECgQKBAoECgQKMEQwCjAECjAEMEoEMM60SjCHcMo-f39-f39yxD9wzrRKMIdwyj9
-f39-f3LEP3DOsgowDrAKDrCKMIdwyj9-f39-f3LEP3DOskoOsAoOsIowh3DKP39-f39-csQ-cM6
ySg6wCjBOsAowh3DKP39-f39-csQ1SjAECjBECjBECgQwSgQwijAEMMoEMEoECgQKMEQxDrJKDrA
KDooOsAowh3DKP39-f39-csQ1CgQwSgQKBAoEMEoEMEoEMEoEMUoEMEoECgQKBAoEMQ6yCjBOijB
OsAowh3DKP39-f39-csQ1CjBECjBECjAEMAoEMEoEMEowRDDKBDBKBAoECjBEMQ60SjCHcMo-f39
-f39yxDWKBAoEMEoEMEoEMEoEMMoEMMoEMEoECgQKBAoEMQ60SjCHcMo-f39-f39yxDUKMAQwCgQ
wSjBECjBECjBECjAEMEoEMAowRDAKMAQKBAoEMQ60Sj9-f39-f3UEP3DOtEo-f39-f391BD9wzrR
KP39-f39-dQQ-cM60Sj9-f39-f3UEP3DOsgowDrAKME6wCj9-f39-f3UEM8owBDAKMAQKMEQKMEQ
KMAQxCgQwSgQKBAowRDOOskoOsIoOsAo-f39-f391BDOKBDBKBDBKBAoEMAoEMAoECgQwygQwSgQ
KBAoECgQzjrJKDrCKDrAKP39-f39-dQQzijBECgQwSjAEMEoEMAoECgQwygQwSgQKBAowRDOOsko
OsIoOsAo-f39-f391BDQKBAoECgQKBAoEMAoEMAoECgQwygQwSgQKBAoECgQzjrIKME6wSg6wCj9
-f39-f3UEM4owBDAKMEQKBAoECjBECjBEMAoEMAowRDAKMAQKBAoEM460Sj9-f39-f3UEP3DOtEo
-f39-f391BD9wzrRKP39-f39-dQQ-cM60Sj9-f39-f3UEP3DOtEowjvAKNA7wCjMOyjHOyjWOyjZ
O8Ao1Tso_zso2Dso0zvAKMw7KMI7KP39xxDOKBAoECjBEMMoEMEoECgQKMEQ2jrRKMM7KNE7KMw7
KMc7KPM7KNU7KP3YOyjUOyjMOyj9-cwQzigQKBDAKBDEKBDBKBAoECgQKBDaOsgowDrAKME6wCjD
OyjCO8AowTvBKMA7wSjAOyjHO8EoO8IowDvBKDvCKMA7wCjPO8AowDvBKMU7wSjAOyg7wCjAO8Ao
wTsowjvBKDsowDsoO8EowTvBKDvBKMU7KME7KMA7wSg7KMA7KMA7wCjBO8Eo2DvAKMA7wSjFO8Ao
OyjBO8AowTvBKMA7wCjGO8EowDvAKME7KMI7wCjBO8EoO8IoO8AowTvAKMA7wSj9_xDOKBAoEMAo
EMQoEMEoECgQKMEQ2jrJKDrAKDooOsAowzsowTsowDsoOyjCOyjAOyjAOyjGOyjDOyjBOyjAOyjA
OyjBOyjAOyjEO8IoxTsowDsowDsoxDsowDsoO8AowTsowDsowDsowTsowDsoOyjAOyg7KMA7KDso
wjsowDsoxDsowTsoOyjAOyg7KMA7KDsowDsoOyjcOyjAOyjAOyjEOyg7KDsoOyjAOyg7KMA7KDso
wDsoxDsowjsowDsowDsowTsowDsoOyjDOyjCOyjAOyjAOyg7KMA7KP36EM4oECgQwCgQxCgQwSgQ
KBAoECgQ2jrJKDrAKME6wCjDOyjBOyjAOyg7KMI7KMA7KMA7KMc7wCjBOyjBOyjAOyjAOyjBO8Io
zzsowDsowDsoxDsowDsoOyjCO8IowDsowTsowDsoOyjAOyg7KMA7KDsowjsowDsoxDsoOyg7KDso
wDsoOyjAOyg7wijAO8AoxTvCKDvCKDvCKMU7KMA7KMA7KMQ7KDsoOyg7KMA7KDsowDsoO8IoxTvA
KMA7wijAOyjBO8IoOyjDOyjCOyjAOyjAOyg7KMA7KP36EM8owBAowRDAKBDAKMEQwCjAECgQKBDa
OskoOsAoOig6wCjDOyjBOyjAOyg7KMI7KMA7KMA7KMk7KMA7KME7KMA7KMA7KME7KMc7wijFOyjA
OyjAOyjEOyjAOyg7KMI7KMM7KME7KMA7KDsowDsoOyjAOyg7KMI7KMA7KMQ7KDsoOyg7KMA7KDso
OyjAOyjFOyjZOyjAOyjAOyjEOyjBOyg7KMA7KDsowDsoOyjKOyg7KMM7KME7KMI7KMM7KMI7KMA7
KMA7KDsowDso-foQ-cM6yCjBOijBOsAoxDvAKMA7wCjBO8EowDvBKME7wCjEO8EowjvAKMA7wSjB
O8AowDvBKM47wSg7KMA7KDvCKDvBKMA7KMM7wSjBO8AowDvBKMA7wSg7KMA7KMA7wSg7KMA7KDvC
KMA7KDsowTvBKDvAKMI7wSg7wSjZO8EoOyjAOyg7wig7KME7KMA7wCjBO8EowDvBKDvCKDvBKME7
wSjBO8AowDvBKMA7wSjBO8AoO8EowDvAKMA7KMA7KP36EP3DOtEo-dg7KP39-f33EP3DOtEo-dg7
KP39-f33EP3DOtEo-f39-f391BD9wzrRKP39-f39-dQQ-cM60SjCO8Ao0DvAKNY7KMw7KMc7KNc7
wCjEO8Ao-f39-eEQ-cM60SjDOyjROyjWOyjMOyjHOyjWOyjHOyj9-f394RD9wzrIKMA6wCjBOsAo
wzsowjvAKME7wSjAO8EowDsoxjvBKME7wCjAOyjAOyg7wijFO8EoO8IowDvBKDvCKMA7wCjQOyjC
O8EowDsowjvBKMA7wCj9-f391hD9wzrJKDrAKDooOsAowzsowTsowDsoOyjCOyjAOyjAOyjGOyjA
Oyg7KMA7KDsowDsowDsoxjsowzsowTsowDsowDsowTsowDsoxDvCKMQ7wig7KMA7KMA7KME7KMI7
KMA7KP39-f3VEP3DOskoOsAowTrAKMM7KME7KMA7KDsowjsowDsowDsoxjsowDsoO8IowDvAKME7
KMc7wCjBOyjBOyjAOyjAOyjBO8IozzsowTsowDsowDsowjvAKMA7wij9-f391RD9wzrJKDrCKDrA
KMM7KME7KMA7KDsowjsowDsowDsoxjsowDsoOyjCOyjAOyjAOyjJOyjAOyjBOyjAOyjAOyjBOyjH
O8IoxTsowTsowDsowDsoxDsoOyj9-f392BD9wzrIKME6wSg6wCjEO8AowDvAKME7wSjAO8EowTvA
KMQ7KMA7KMA7wSg7KMA7KME7wCg7wig7wSjCO8AowDvBKME7wCjAO8EozzsowjvBKME7wCg7wSjB
O8Eo-f39-dUQ-cM60Sj9-f39-f3UEP3DOtEo-f39-f391BD9wzrRKP39-f39-dQQ-cM60Sj9-f39
-f3UEP3DOtEo-f39-f391BD9wzrRKP39-f39-dQQ-cM6yCjBOijBOsAo-f39-f391BD9wzrKKDoo
Oig6wCj9-f39-f3UEP3DOsgowTooOig6wCj9-f39-f3UEP3DOsgoOsEoOig6wCj9-f39-f3UEP3D
OsgowToowTrAKP39-f39-dQQ-cM60Sj9-f39-f3UEP3DOtEo-f39-f391BD9wzrRKP39-f39-dQQ
-cM60Sj9-f39-f3UEP3DOtEo-f39-f391BD9wzrRKP39-f39-dQQ-cM6yCjBOijAOsEo-f39-f39
1BD9wzrKKDrAKDrBKP39-f39-dQQ-cM6yCjBOsAoOsEo-f39-f391BD9wzrIKDrCKDrBKP39-f39
-dQQ-cM6yCjBOijBOsAo-f39-f391BD9wzrRKP39-f39-dQQ-cM60Sj9-f39-f3UEP3DOtEo-f39
-f391BD9wzrRKP39-f39-dQQ-cM60SjEO8Aozzsowjso1TsoxjsowTsowzsowTso-f39-f3EEP3D
OtEowzso0Tso5zsowjsowzso-f39-f3DEP3DOsgowToowTrAKMM7KME7KMA7KDvBKME7wSg7wig7
wCjBO8AowDvBKMo7wCjAO8EowDvAKMA7wijAOyjDOyj9-f39-cMQ-cM6yig6wSg6wCjCO8IoOyjA
Oyg7KMA7KDsowzsowjsowDsowDsoOyjAOyjKOyjAOyjAOyjAOyjBOyjCOyjDOyj9-f39-cMQ-cM6
yCjBOijBOsAowzsowTsowDsoOyjAOyg7KMM7KMI7KMA7KMA7KDsowDsoyjsowDsowDsowDsowTso
wjsowzso-f39-f3DEP3DOsgoOsEoOsIowzsowTsowDsoOyjAOyg7KMM7KMI7KMA7KMA7KDsowDso
yjsowDsowDsowDsowTsowjsowzso-f39-f3DEP3DOsgowToowTrAKMM7KMI7wSg7KMA7KMA7wSjB
O8AoO8EowDvAKMA7KMA7KMQ7wig7wSg7KMA7KDvBKME7wCjAOyjDOyj9-f39-cMQ-cM60Sj9yTso
wTso-f39-f3EEP3DOtEo-f39-f391BD9wzrRKP39-f39-dQQ-cM60Sj9-f39-f3UEP3DOtEo2Dso
yDso0DvAKPI7KDsowDsoOyjGO8Ao-f39-dAQ-cM60SjjOyjQOyjzOyg7KMA7KDsoxzso-f39-cP_
AAAAwCjANcEoNSg1KMAQ-cM6yCjBOijBOsAo0TsowTsoO8AowDvBKME7wSjAO8AowDsowTsoxTso
xzvBKDsowDsoOyg7wCjAO8EowDvAKMA7KDvAKN87KP39-f3ENSjCNSjBNSjAEP3DOsooOsEoOsAo
0TsowTsowDsowDsowDsoOyjAOyg7KMA7KDsowTsoxDsoxzsowjsowDsoO8AowTsowjsowDsoO8Ao
xjvCKNY7KP39-f3DNSjANcEowDUowRD9wzrIKME6wCjAOsAo0TsoOyg7KMA7KMA7KMA7KDsowDso
OyjAOyg7KDsoOyjFOyjGOyjCOyjAOyg7KMM7wCjAOyjAOyg7KOI7KP39-f3ENSjANSjBNSjCEP3D
OsgoOsMoOsAo0TsoOyg7KMA7KMA7KMA7KDsowDsoOyjAOyg7KDsoOyjFOyjGOyjCOyjAOyg7KMU7
KDsowDsoOyjHO8Io1Tso-f39-cM1wSg1wSg1KDUowBD9wzrIKME6KME6wCjSOyg7KMA7wSg7KMA7
KMA7wSjAO8AowTsoOyjGOyjHO8EowDvBKDsowjvBKME7wCjAOyjiOyj9-f390BD9wzrRKPY7wCj9
xDvAKP39-f3DNcEoyBD9wzrRKP39-f39-ck1KDXBKDXAKMEQ-cM60Sj9-f39-f3HNcEoNcEoNcAo
wRD9wzrRKP39-f39-cc1KME1KDUoNSg1KMAQ-cM60SjTO8AoxTsoxjsoxDsowDsoOyjKO8AoxzvA
KM47wCjBOyg7KME7KNA7KMk7KME7wCjFO8IowDvAKME7wCjBO8AowTso-f391zXBKDUoNSg1wSjA
EP3DOtEo0jsoxzsoxjsowzsowTsoOyjLOyjDOyjAOyjAOyjOOyjBOyg7KMI7KM87KMg7KME7KMA7
KMQ7KMI7KMA7KDsowDsoOyjAOyjBOyj9-f3jEMUAAAAAAAAAAQ==
:: main.lua
--[[pod_format="raw",created="2025-03-24 12:49:34",modified="2025-03-28 19:52:01",revision=3670]]
----------------------------------------------------------------------------------------


log = function(str) printh(env().argv[0]..": "..(str or ""))  end
--log = function(_str) end
log("new process: argv=" .. pod(env().argv))


include "require.lua"
local buffers = require "src/buffers.lua"
local workspace = require "src/workspace.lua"
local ui = require "src/ui.lua"


----------------------------------------------------------------------------------------


local font <const> = "/system/fonts/lil.font"
local font <const> = "/system/fonts/lil_mono.font"
local font <const> = "fonts/cozi.font"
local font_alt <const> = "fonts/p9.font"


----------------------------------------------------------------------------------------


local current_path
is_testing = false


----------------------------------------------------------------------------------------


local sidebar
local editor


----------------------------------------------------------------------------------------


function _init()
	local prog_name = env().argv[0]
	current_path = env().argv[1] or "/ram/cart/main.lua"
	if prog_name == "/system/apps/terminal.lua" then
		-- Codron is the loaded cart, fix the path.
		prog_name = "/ram/cart/main.lua"
		current_path = "/test/test2/main.lua"
		is_testing = true
	end

	do
		local matching_proc_ids = {}
		for process in all(fetch "/ram/system/processes.pod") do
			local name <const> = process.name
			if name == "codron" or name == "codron_dev" then
				matching_proc_ids[#matching_proc_ids + 1] = process.id
			end
		end
		for proc_id in all(matching_proc_ids) do
			if proc_id ~= pid() then
				log("sending switch_to message to [" .. string.format("%03d", proc_id) .. "]")
				send_message(proc_id, { event = "switch_to", path = current_path })
			end
		end
	end
	
	do
		local font_mem = fetch(font)
		if font_mem then
			font_mem:poke(0x4000)
		end
		local font_alt_mem = fetch(font_alt)
		if font_alt_mem then
			font_alt_mem:poke(0x5600)
		end
	end
	
	local wm_ws = nil
	if sub(prog_name, 1, 6) == "/test/" then
		log("using Code workspace")
		wm_ws = 3
	end
	window {
		pauseable = false,
		immortal = false,
		capture_escapes = true,
		tabbed = true,
		width = 300, height = 200,
		title = "?",
		workspace = wm_ws,
		icon = --[[pod_type="gfx"]]unpod("b64:bHo0ABoAAAAYAAAA8AlweHUAQyAICARwJxBHMDcwNzA3MEcQJ3A="),
	}
	
	install_event_handlers()
	update_menu_items()
	
	workspace.open(current_path)
	--workspace.print()
	
	ui.init()
	sidebar = ui.head():attach(ui.sidebar { x = 0, y = 0 })
	editor = ui.head():attach(ui.editor { x = 60, y = 0 })
	editor:set_keyboard_focus(true)
end


----------------------------------------------------------------------------------------


function _update()
	-- TODO: what?
	-- Focus is lost on any click (in picotron's `update_all`),
	-- how do we prevent that from happening?
	if ui.head():get_keyboard_focus_element() == nil then
		-- A click on any GUI element nulls the keyboard focus...
		editor:set_keyboard_focus(true)
	end
	ui:update()
	if key("ctrl") and key("shift") and keyp("e") then
		workspace.refresh()
	end
end


----------------------------------------------------------------------------------------


function _draw()
	cls(2)
	ui:draw()
	--print(string.format("\014%4.0f", stat(1) * 100.0) .. "%", 452, 240, 0)
	print(string.format("\014%3.0f", stat(0) / (1024 * 1024)) .. "MB", 452, 246, 0)
end


------------------------------------------------------------------------------------------


function install_event_handlers()
	on_event(
		"switch_to",
		function(msg)
			log("EVENT: switch_to " .. pod(msg))
			workspace.switch_to(msg.path or "", msg._from)
			local row = tonumber((msg.path or ""):hloc())
			if row and editor then
				workspace.current_buffer():set_cursor(1, row)
				editor:center_cursor()
			end
		end
	)
	on_event(
		"open_file",
		function(msg)
			log("EVENT: open_file " .. pod(msg))
--			workspace.set_current_path
		end
	)
	on_event(
		"new_file",
		function(msg)
			log("EVENT: new_file " .. pod(msg))
		end
	)
	on_event(
		"save_file",
		function(msg)
			log("EVENT: save_file " .. pod(msg))
			if msg.filename then
				log([[!!! filename="]]..msg.filename..[[" !!!]])
			end
			workspace.save_all()
		end
	)
	on_event(
		"save_file_as",
		function(msg)
			log("EVENT: save_file_as " .. pod(msg))
		end
	)
	on_event(
		"jump_to_hloc",
		function(msg)
			log("EVENT: jump_to_hloc " .. pod(msg))
		end
	)
	on_event(
		"drop_items",
		function(msg)
			log("EVENT: drop_items " .. pod(msg))
		end
	)
	on_event(
		"gained_focus",
		function(msg)
			--log("gained_focus")
			-- TODO: check for file changes.
		end
	)
	on_event(
		"lost_focus",
		function(msg)
			--log("lost_focus")
		end
	)
	on_event(
		"gained_visibility",
		function(msg)
			--log("gained_visibility")
		end
	)
	on_event(
		"lost_visibility",
		function(msg)
			--log("lost_visibility")
		end
	)
	-- non existing events?
	on_event(
		"close_window",
		function(msg)
			log("??? EVENT: close_window ???")
		end
	)
	on_event(
		"pause",
		function(msg)
			log("??? EVENT: pause ???")
		end
	)
	on_event(
		"halt",
		function(msg)
			log("??? EVENT: halt ???")
		end
	)
end


------------------------------------------------------------------------------------------


function update_menu_items()
	-- TODO: no need for "New File" menu entry once the sidebar button is implemented
	menuitem {
		id = "new_file",
		label = "\^:7f4141417f616500 New File",
		action = function()
			log("MENU: New File")
			local node = workspace.current_node() or { path = "/desktop" }
			local segments = split(node.path, "/", false)
			local folder = table.concat(segments, "/", 1, #segments - 1)
			log([[open file folder= "]] .. folder .. [["]])
			local open_with = env().argv[0]
			if open_with == "/system/apps/terminal.lua" then
				open_with = "/ram/cart/main.lua"
			end
			create_process(
				"/system/apps/filenav.p64",
				{
					path = folder,
					use_ext = "lua", -- TODO: current buffer extension?
					intention = "new_file",
					open_with = open_with,
					window_attribs = { workspace = "current", autoclose = true }
				}
			)
		end
	}

	menuitem {
		id = "open_file",
		label = "\^:7f4141417f616500 Open File",
		shortcut = "CTRL-O",
		action = function()
			log("MENU: Open File")
			local node = workspace.current_node() or { path = "/desktop" }
			local segments = split(node.path, "/", false)
			local folder = table.concat(segments, "/", 1, #segments - 1)
			log([[open file folder= "]] .. folder .. [["]])
			local open_with = env().argv[0]
			if open_with == "/system/apps/terminal.lua" then
				open_with = "/ram/cart/main.lua"
			end
			create_process(
				"/system/apps/filenav.p64",
				{
					path = folder, -- TODO: !!!!!!!!
					open_with = open_with,
					window_attribs = { workspace = "current", autoclose = true }
				}
			)
		end
	}
end


------------------------------------------------------------------------------------------


function find_codron_pids()
	local matching_pids = {}
	for process in all(fetch "/ram/system/processes.pod") do
		if process.name == "codron" then
			matching_pids[#matching_pids + 1] = process.id
		end
	end
	return matching_pids
end


----------------------------------------------------------------------------------------

:: manual.txt
--[[pod_format="raw",created="2025-03-25 12:12:29",modified="2025-03-28 19:52:01",revision=1832]]
# Codron

## Keybinds

### Editor

Switch between files:
- Ctrl-E: Edit (popup to choose a file)
- Ctrl-J: Jump to previous file (hold ctrl to keep jumping)
- Ctrl-K: Jump to next file

Find, aka incremental search:
- Ctrl-F: Find
- Ctrl-D: reverse finD
- Ctrl-F Ctrl-F: find aGain
- Ctrl-D Ctrl-D: find aGain

Search and replace:
- Ctrl-H: searcH and replace

Navigate in current file:
- Ctrl-G: go to line number (if a number is entered)
  or to a specific function definition (otherwise).
- Ctrl-U: go to previous cursor/selection, or go to
  previous function definition if only one cursor.
- Ctrl-I: go to next cursor/selection, or go to
  next function definition if only one cursor.

Multi-cursors and multi-selection:
- Ctrl-A: select all occurences of current word.
- Ctrl-L: select current line, or extend selection
  by one line.
- Ctrl-O: deselect current occurence.
- Ctrl-M: if selection, add a cursor at end of each
  line, otherwise add one cursor below.
- see also Ctrl-U and Ctrl-I

### Find (incremental search)

- Enter: exit find, cancel selection.
- Shift-Enter: exit find, keep selection.
- Ctrl-A or Ctrl-Enter: exit find, select all occurences.
- Escape or Ctrl-O: exit find, go back to original position.
- Ctrl-F: select next occurence.
- Ctrl-D: select previous occurence.
- Movement keys: exit find, cancel selection.

:: require.lua
--[[pod_format="raw",created="2025-03-19 09:08:58",modified="2025-03-28 19:52:01",revision=1912]]
---------------------------------------------------------------------------------------------


_modules = {}


-- A 'require' function similar to standard Lua.
-- Idea from elgopher on the BBS
function require(name)
	if (_modules == nil) _modules = {}

	local cached = _modules[name]
	if (cached) return cached

	local filename = fullpath(name)
	local src = fetch(filename) 
	if (type(src) != "string") panic("could not include " .. filename)

	-- https://www.lua.org/manual/5.4/manual.html#pdf-load
	-- chunk name (for error reporting)
	-- mode ("t" for text only -- no binary chunk loading)
	-- _ENV upvalue
	-- @ is a special character that tells debugger the string is a filename
	local func, err = load(src, "@" .. filename, "t", _ENV)
	if (not func) panic("Syntax error:", tostr(err))

	local module = func()
	_modules[name] = module

	return module
end


function panic(...)
	local args = { ... }
	foreach(
		args,
		function(str)
			send_message(3, { event = "report_error", content = str })
		end
	)
	stop()
end


--------------------------------------------------------------------------------------------
:: todo.txt
--[[pod_format="raw",created="2025-03-25 08:49:54",modified="2025-03-28 19:52:01",revision=1867]]
- Fix: bug when opening non-existent file
- Fix: disable syntax highlighting for non-lua files.
- Add: button to add new file in sidebar.
- Add: button to refresh the filetree.
- Add: syntax highlighting for markdown files.
- Add: horizontal scrollbar? based on longest line on screen?
- Add: horizontal drag with right click, but gated with pressure.

:: .info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTIyIDE2OjA0OjA0Iixtb2RpZmllZD0iMjAyNS0w
My0yOCAxOTo1MjowMSIscnVudGltZT0xNix3b3Jrc3BhY2VzPXt7bG9jYXRpb249Im1haW4ubHVh
Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJnZngvMC5nZngiLHdvcmtzcGFjZV9pbmRl
eD0yfSx7bG9jYXRpb249Im1hcC8wLm1hcCIsd29ya3NwYWNlX2luZGV4PTN9LHtsb2NhdGlvbj0i
c2Z4LzAuc2Z4Iix3b3Jrc3BhY2VfaW5kZXg9NH19XV0=
:: [eoc]
