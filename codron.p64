picotron cartridge // www.picotron.net
version 2

:: defaults/
:: defaults/theme.lua
--[[pod_format="raw",created="2025-03-31 13:01:59",modified="2025-04-01 20:24:10",revision=658]]

return {
	-- Sidebar
	sidebar_bg = 17,
	sidebar_fg = 1,
	sidebar_fg_active = 6,
	-- Editor
	editor_bg = 1,
	lua_text = 6,
	lua_comment = 13,
	lua_operator = 7,
	lua_keyword = 14,
	lua_string = 12,
	lua_string = 12,
	lua_number = 12,
	lua_reserved = 12,
	lua_function = 11,
	lua_unknown = 8,
}
:: defaults/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTMxIDEzOjAxOjM3Iixtb2RpZmllZD0iMjAyNS0w
NC0wMSAyMDoyNDoxMSJdXQ==
:: fonts/
:: fonts/cozi.font
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTIxIDE5OjIyOjIwIixtb2RpZmllZD0iMjAyNS0w
My0yOCAyMDo1NDozNSIscmV2aXNpb249MjRdXWx6NACgAwAAPgcAAPEdcHh1AAMoAAgAAAQFCgsA
AQOQD4APmD_ID4APj3_ID4kviA-4D4gPmC_ID4kGAEL4L4gIEwDwqw_IAB4PmAgeD4nwMG8-IC1A
DQ8zDUAMDwwMQAwADEAsMA8wDzwNCQ8wIAMPDw0HAxAPPj8GQD8wDz4AD2MPNg8cDz4IBggwDxiA
DwwPGFAfDCAaQA8ECgSwQgACABVwCg8fCgsKEAQPDg8BDwYIDwcEEA8JBAIBIAIFAg8LBQoAFFAE
UgQCVAIQBQIPBwIFMAQPDgRgFAIwB4ACEBQSHwEADwYBDw0PCxEPBgAEDjQPDgAOAQgEAg8BBwkA
8jMOCAEOAAQOFQcUAAccDwcYCQAOHAkRDgAHGAQiAA4RDhEOAA4RDw4YDjACAAJABAAUAhAEAgwC
BDAHAAcwAgQIBAJPAPAYAAIADQ8RHx0PDQwNAA4RByEACREJEQkADgEsAQ4ACUEJAAccCRwHBgCQ
LAANHAMRDQAhJQDwFUIJAA04AQ4AEQUPAwURAFwHAA8RDxsfFS8RAAEPCwMxAA5BDksA8QEsAA4x
Bg4PDAkRCSEADgEMuADwYA8fVABRDQBBBQ8DAC8RHxUPGw8RACEOIQAhDRgJAAcIBAIcBwAJXAkA
HBIUAA1YDQIFsAkAAgRwDSENABwJIQkgDSwNABgNIQ0gDgEHDA0ADwwSByIQDSENCA4cCTEAAgAP
AyIJAAgADwwoAQ4cAaMA8CcBAAtCDwwgBh8VHxEgCTEgDiEOEAkhCRwADSENGBADCywgDQwOCAkA
EgciDwwgMQ0gIQULIB_cAPYeCiARDhEQMQ0IDhAHCA4MBwAOEgwiDnIOFAgkDiAODxUPDCAbGiBv
fwAPVQ8qBADwCAAPQQ9jD38fXQ93Dz4ABh9jD3cGD0EGJwEWRAQA8A8ABAoPfAYPHw8YDxAADxwP
Jh9fD38GDxwADyIPdx8KAKEIAA8qDxwPNg93dALwASoAHxwGD10PHB8UAAgPHAYuALEqDzoABg9n
D2MPZ2MAEQZ3APEFfw9jBgAPGA94KAcJAAYPYw9rD2MfAPMICA8UDyoPXQ8qDxQIMA9VMAYPcw9j
D3McADEcD39vAPEEIhAPfw8iDxQIAw8iD38ABg93Hz8A8wIQDwoEAA9QDyAQDxEPKg9EAAcAcQYP
aw93D2tGAEEPfwAFAgD0Am9VEA9_D0IPUg9KD0IPfhABDABAARABDQoAHw0JAP---2hQD0oNAQA=
:: fonts/p9.font
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTIzIDIxOjQzOjIxIixtb2RpZmllZD0iMjAyNS0w
My0yNyAxNTowNToxNCIscmV2aXNpb249NDldXWx6NACBBQAApgUAAPCPcHh1AAMoAAgAAAQECAYQ
A-ABD5DwBglgDyAwDvA0RzAnQAcFB0AFAgVABQAFQCUwBAYHBgQgAQMHAwEgByFAJAcgBQcCBwJA
AnABAlATIBVQAgUCwCIAAiAVUAUHBQcFIAcDBgcCIAUEAgEFIBMGBQcgAgFQAiECIAIkAiAFAgcC
BTACBwJgAgFAB4ACIBgUEhAHJQcgAyIHIAcEBwEGAPEJBgQHIBUHFCAHAQcEByARBwUHIAc0IAcF
CQDwDQUHFDACAAJAAgACASAEAgECBDAHAAcwAQIEAgE8APA0AAIgAhUBBjAGBQcFMBMFBzAGEQYw
AxUDMAcDAQYwBwMRMAYBBQcwFQcFMAcSBzAHEgMwBQMVMCEGMBcVMAMlMAYVAzwA8BUBMAIFAwYw
AwUDBTAGAQQDMAciMCUGMBUHAjAVFzAFEgUwBQcWAPEgBAEHIAMhAyASFBgQBiQGIAIFkAcgAgRQ
BwUHFSAHBQMFByAGIQYgAyUHIAcBAwEGAFARIAYRBeMAMBUgB-cA8AgiAyAVAxUgMQcgDw8vFQ8R
IAM1IAYlA_wAYBEgAhUDBkkA8A4VIAYBBwQDIAcyIDUGICUHAiAdHxUPDyAVAhUgFSgB8hQHBAIB
ByAGAgMCBiBCIAMCBgIDMAQHAUACBQIwT38gD1UPKgQA8EkgD0EPfx9dDz4gDB9jD3cMIA0PRA0L
DSAEDzwPHA8eDxAgDxwPLhwPHCAPNhwPHAggCg82D3cPNgogGgwKDxQgCgwPfw8qDzogDA9nD2MP
ZwwgD38PXQ9-VwDwESAPOBgfDiAMD2MPaw9jDCAICgwKCEAPVUAMD3MPYw9zEgDwFQ9-DA8iIAwK
CAoMIAwPdx9jDDAFD1IOQA0PKgswDA9rD3cPa1QA8DkACQAJIE9VIA8OBA8eDy0PJiANHyEPJQIg
DwwPHh4KIAgGCA8kDxogD04EDA9FDyYgDyIPXx8SDwogBggPPA0PBiAPEA8MAgPRAPB4Ig96HyIP
EiAGDgACDzwgCAcPEAIDICIPIgogCAwIAwggDxIPPw8SAgogBw8QD34EDzggAg8HDzICASAPDwIP
Dg8QCiAMH0AODxggDA8QGAUgCA84BAIHIAEPBw8SD3gPGCAPeg9CAg8KD3IgDwkMD0sPbQ9mIA8a
DycPIg9zASAHD0ofSQ9GZwAROgQA8WMaIA8jD2IfIgogAwAIDyoPTTADDxIPIQ9AIA99D3kNDz0P
XSAMBwgGDy4gDwYPJA9_DyYFIA8kD04ED0YHIA8KBw9aD0YPMCAGBAYPRA84IA8UDA8kGCAPOg9W
D1IPMAggBAoEBg8GIAgCDA4KIB8iDya8APICCw8kD3IPMCAEDzYPLA8mD2QTADRCDzCtAPBNIw8S
IA8OD2QKDygPeCAEAg8GDysPGUAPDgUIMA8KDx8PEgQwBA8PDxUPDTAEAw8GDw4gDA4PFAQCIA8w
CA8OGCAIDA8iDgsgDCgMIAUPfgsPFA8SIAQMDyQPIgFsAUAMCCAHDQDxAAUIIAQPfA8SBQggDC4M
IOMA8QIkDgUgDwYODyYFAyAMDgULCTkAAI0BIA8iHQDwBAMgDA8iDy0PMAMgCggMCAQgHyoVACAK
AAwA4BQKDyQEIAgMGAQwChAMlQBAKAUPLI8A8w0wD14IIC4FDw4gBR8kD0QPQiACBhIKIAweBQMg
dgFhMAgMCB8qygCxCAUgBwAMAAYgCAQaAUB_IA9ASwBRaA8GIAacBACVAPATFCAKJQwgBgUGBQYg
DAAMDgsgLQ4FIC8UD1QPMiASDyIPEhkBYS8iDCAMAbkA8BIOBw4LIA8GHgUPDjAPFQUIDwYwBAYP
FARAAwgGMAoLBQpwAKBjBQggCAUJBAgg
:: fonts/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTIzIDIxOjM2OjMxIixtb2RpZmllZD0iMjAyNS0w
NC0wMSAyMDoyNDoxMSJdXQ==
:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTIyIDE2OjAzOjQ4Iixtb2RpZmllZD0iMjAyNS0w
NC0wMSAyMDoyNDoxMCIscmV2aXNpb249NzQyOF1dbHo0AI8BAADiMgAA8yF7WzBdPXtibXA9cHh1
AEMgEBAE8FYHEAfAF9AXwAcQB-BWLGZsYWdzPTAscGFuX3gIAMd5PTAsem9vbT04fSw_AJEICARw
JxBHMDcCAE9HECdwPgALHDE_ALGAFxAXABcwNwAXAAQAfzAXABcQF4BGACEQdzoAFRAKAA9EABoA
BgEf8PkADA8xAI3PCwsE8BNn4GfgZ-ATOAALLTEwOQDxAggnAAdgFxAHQAcAByAHMAdABACPQAcg
B2An8ApPAB7xAAsHcAcABwAHYCdQZ1AnYAwAT3AH8AtJAB3yAcA3YAcQF1AHEAcAB0AHEDeZABCQ
BgBvNwAngAfAUQAa3wkIBPAGB2AXUCdgF3A8AA4dNjwAQgcnIDcfAQEEAC9XkEIADQ-RAR0vMTAy
ACz-AwsLBCARABFQAQcBBwFgAQcBcAQABBFgIgBfUBEAESBhAAwfMpMAHw8yAP--------------
----------------------------------------------_UUD0xMH19
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTIyIDE3OjM3OjMxIixtb2RpZmllZD0iMjAyNS0w
NC0wMSAyMDoyNDoxMSJdXQ==
:: src/
:: src/ui/
:: src/ui/editor.lua
--[[pod_format="raw",created="2025-03-23 10:19:52",modified="2025-04-01 20:24:10",revision=7652]]
-------------------------------------------------------------------------------------------


local app = require "src/app.lua"
local buffers = require "src/buffers.lua"
local config = require "src/config.lua"
local findbox = require "src/ui/findbox.lua"


-------------------------------------------------------------------------------------------


local margin_width <const> = 19 -- 19 or 26
local scrollbar_width <const> = 7
local min_edge_distance <const> = 26


local cursor_width <const> = 4
local cursor_height <const> = 11


-------------------------------------------------------------------------------------------


local show_line_numbers = false


local show_cursors_in_scrollbar = true
local show_sections_in_scrollbar = false


-------------------------------------------------------------------------------------------


return function(attribs)
	local self = attribs or {}
	self.x = self.x or 0
	self.y = self.y or 0
	self.width = 480 - 60
	self.height_rel = 1
	self.cursor = get_spr(16)
	head():new(self)

	local findbox = self:attach(findbox { editor = self, x = 0, y = 0 })

	-- Private fields
	local buffer = buffers.new("(pseudo buffer)")
	local blink_timer = 0
	local freewheel_last_dy = 0
	local freewheel_velocity = 0.0
	local freewheel_acceleration = 0.0
	local last_command = nil
	local last_click_time = time()
	local click_counter = 0
	local drag_select_mode = "char"
	
	
	function self:buffer()
		return buffer
	end
	
	
	function self:set_buffer(b)
		if not findbox.hidden then
			findbox:stop_search()
			buffer:clear_selections()
		end
		buffer = b
	end
	

	local function get_margin_width()
		if show_line_numbers then
			return margin_width
		end
		return 0
	end
	

	function self:show_cursor(keep_edge_distance)
		local edge_distance = keep_edge_distance and min_edge_distance or 0
		-- TODO: use middle of current selection instead?
		local col, row = buffer:active_cursor_pos()
		local y = buffer:find_cursor_y(row)
		if y - edge_distance < buffer.screen_y then
			buffer.screen_y = y - 2 - edge_distance
			buffer.screen_y = max(- 4, buffer.screen_y)
		elseif y + cursor_height - 2 + edge_distance > buffer.screen_y + self.height then
			buffer.screen_y = y + cursor_height - 2 + edge_distance - self.height
		end
		local x = buffer:find_cursor_x(col, row)
		if x - 4 < buffer.screen_x then
			buffer.screen_x = x - 4
		elseif x + cursor_width + 2 + scrollbar_width > buffer.screen_x + self.width - get_margin_width() then
			buffer.screen_x = x + cursor_width + 2 + scrollbar_width - self.width + get_margin_width()
		end
		freewheel_velocity = 0
		freewheel_acceleration = 0
		-- TODO: use *start* of current selection instead
		buffer:highlight(row)
		buffer.highlighter_row = row
	end
	

	function self:center_cursor()
		if not self.height then return end -- when called from switch_to
		local col, row = buffer:active_cursor_pos()
		local y = buffer:find_cursor_y(row)
		buffer.screen_y = y - (self.height // 2) - 11
		local x = buffer:find_cursor_x(col, row)
		if x - 4 < buffer.screen_x then
			buffer.screen_x = x - 4
		elseif x + cursor_width + 2 + scrollbar_width > buffer.screen_x + self.width - get_margin_width() then
			buffer.screen_x = x + cursor_width + 2 + scrollbar_width - self.width + get_margin_width()
		end
		freewheel_velocity = 0
		freewheel_acceleration = 0
		buffer:highlight(row)
		buffer.highlighter_row = row
	end
	

	function self:clamp_scrollbar_thumb()
		buffer.screen_y = mid(-4, buffer.screen_y, max(-4, buffer:total_height() - self.height + min_edge_distance))
		buffer.screen_x = max(-4, buffer.screen_x)
		buffer.y = mid(-4, buffer.anim_y, max(-4, buffer:total_height() - self.height + min_edge_distance))
		buffer.anim_x = max(-4, buffer.anim_x)
	end
	

	function self:hover(msg)
		self.cursor = get_spr(16)
		if msg.mx >= self.width - scrollbar_width then
			self.cursor = 1
			local total_height, thumb_y, thumb_height = self:compute_scrollbar_coords()
			if msg.my >= thumb_y and msg.my <= thumb_y + thumb_height then
				self.cursor = "grab"
			end
		end
	end


	function self:click(msg)
		local t = time()
		if t - last_click_time < 0.25 then
			click_counter += 1
		else
			click_counter = 1
		end
		last_click_time = time()
		if not msg.has_pointer then return end
		if msg.mx >= self.width - scrollbar_width then
			local total_height, thumb_y, thumb_height = self:compute_scrollbar_coords()
			if msg.my >= thumb_y and msg.my <= thumb_y + thumb_height then
				self.click_on_scrollbar_thumb = true
			else
				self.click_on_scrollbar_bg = true
			end
			return
		end
		if msg.mb == 2 then
			self.right_click_on_text = true
			return
		end
		if msg.mb == 1 then
			self:set_keyboard_focus(true)
			self.click_on_text = true
			last_command = nil
			if not findbox.hidden then
				findbox:stop_search()
			end
			local row = buffer:find_cursor_row(msg.my + buffer.screen_y)
			local col = buffer:find_cursor_col(row, msg.mx + buffer.screen_x - get_margin_width())
			if click_counter == 1 then
				drag_select_mode = "char"
				buffer:set_cursor(col, row, key("alt"))
			elseif click_counter == 2 then
				drag_select_mode = "word"
				buffer:select_word(col, row, key("alt"))
			elseif click_counter == 3 then
				drag_select_mode = "line"
				buffer:select_line(row, key("alt"))
			end
			blink_timer = 0
		end
	end


	function self:drag(msg)
		if self.click_on_scrollbar_thumb then
			local total_height, thumb_y, thumb_height = self:compute_scrollbar_coords()
			thumb_y += msg.dy
			buffer.screen_y = math.floor(0.5 + (thumb_y * total_height) / self.height)
			buffer.anim_y = math.floor(0.5 + (thumb_y * total_height) / self.height)
			self:clamp_scrollbar_thumb()
			return
		elseif self.click_on_scrollbar_bg and msg.mb == 1 then
			local total_height, thumb_y, thumb_height = self:compute_scrollbar_coords()
			buffer.screen_y = math.floor(0.5 + (msg.my * total_height) / self.height)
			buffer.screen_y -= self.height // 2
			self:clamp_scrollbar_thumb()
			return
		end
		if self.right_click_on_text and msg.mb == 2 then
			buffer.screen_y -= msg.dy
			self:clamp_scrollbar_thumb()
			freewheel_velocity = math.floor(0.5 + (msg.dy + freewheel_last_dy) / 2.0)
			freewheel_acceleration = 0.850 + 0.145 * mid(1, abs(msg.dy), 24) / 24.0
			freewheel_last_dy = msg.dy
			self.cursor = "grab"
			return
		end
		if not self.click_on_text then return end
		local row = buffer:find_cursor_row(msg.my + buffer.screen_y)
		local col = buffer:find_cursor_col(row, msg.mx + buffer.screen_x - get_margin_width())
		local active_col, active_row = buffer:active_cursor_pos()
		if col ~= active_col or row ~= active_row then
			if drag_select_mode == "char" then
				buffer:extend_active_selection(col, row)
			elseif drag_select_mode == "word" then
				buffer:extend_word_selection(col, row)
			elseif drag_select_mode == "line" then
				buffer:extend_line_selection(row)
			end
		end
		if msg.my < 1 then
			buffer.screen_y -= 3
		elseif msg.my > self.height - 2 then
			buffer.screen_y += 3
		end
	end
	

	function self:release(msg)
		if self.click_on_text then
			self:show_cursor(false)
		end
		self.click_on_text = false
		self.click_on_scrollbar_thumb = false
		self.click_on_scrollbar_bg = false
	end
	

	function self:mousewheel(msg)
		if not buffer then return end
		buffer.screen_y -= 24 * msg.wheel_y
		buffer.screen_x -= 6 * msg.wheel_x
		self:clamp_scrollbar_thumb()
	end

	
	function self:update(msg)
		findbox.width = 40 + 5 * #findbox:target()
		findbox.x = ((self.width - scrollbar_width) // 2) - (findbox.width // 2)
		findbox.y = self.height - findbox.height
	
		blink_timer += 1

		local _col, row = buffer:active_cursor_pos()
				
		for i = 1, 5 do
			buffer:highlight(buffer.highlighter_row)
			buffer.highlighter_row += 1
			if buffer.highlighter_row > buffer:number_of_rows() then
				buffer.highlighter_row = 1
			end
		end
	
		if freewheel_velocity ~= 0 and msg.mb == 0 then
			buffer.screen_y -= freewheel_velocity
			self:clamp_scrollbar_thumb()
			freewheel_velocity *= freewheel_acceleration
			if abs(freewheel_velocity) < 0.5 then
				freewheel_velocity = 0.0
				freewheel_acceleration = 0.0
			end
		end
		
		local function lerp(start, fin, t)
		 return start * (1 - t) + fin * t	
		end
		local speed = findbox.hidden and 0.333333 or 0.2
		if abs(buffer.screen_y - buffer.anim_y) < 1.0 then
			buffer.anim_y = buffer.screen_y
		else
			buffer.anim_y = lerp(buffer.anim_y, buffer.screen_y, speed)
			self:clamp_scrollbar_thumb()
		end
		if abs(buffer.screen_x - buffer.anim_x) < 1.0 then
			buffer.anim_x = buffer.screen_x
		else
			buffer.anim_x = lerp(buffer.anim_x, buffer.screen_x, speed)
			self:clamp_scrollbar_thumb()
		end
		
		-- The findbox *cannot* handle those key bindings,
		-- because its `keyp` state when getting keyboard focus
		-- is unreliable.
		if keyp("f") and key("ctrl") then
			findbox:launch_search(findbox.hidden, "forward")
		elseif keyp("d") and key("ctrl") then
			findbox:launch_search(findbox.hidden, "backward")
		end
		
		if self:has_keyboard_focus() and not findbox.hidden then
			findbox:set_keyboard_focus(true)
		end
	
		if not self:has_keyboard_focus() then return end

		local moved = false -- has the cursor moved?
		local this_command = nil -- TODO: something better than this...

		while peektext() do
			local k = readtext()
			buffer:insert(k)
			moved = true
		end

		-- Movement (with optional "shift")
		if not key("ctrl") and not key("alt") then
			local extend = key("shift")
			if keyp("enter") then buffer:newline(true, key("shift")); moved = true
			elseif keyp("tab") then buffer:tab(extend); moved = true
			elseif keyp("backspace") then buffer:backspace(); moved = true
			elseif keyp("delete") then buffer:delete(); moved = true
			elseif keyp("up") then buffer:move_up(extend); moved = true
			elseif keyp("down") then buffer:move_down(extend); moved = true
			elseif keyp("right") then buffer:move_right(extend); moved = true
			elseif keyp("left") then buffer:move_left(extend); moved = true
			elseif keyp("home") then buffer:move_home(extend, false); moved = true
			elseif keyp("end") then buffer:move_end(extend); moved = true
			elseif keyp("pageup") then
				for i = 1, 20 do
					buffer:move_up(extend)
				end
				moved = true
			elseif keyp("pagedown") then
				for i = 1, 20 do
					buffer:move_down(extend)
				end
				moved = true
			elseif keyp("escape") then
				-- Does not work as of Picotron 0.2.0b (escape is borked)
				buffer:set_cursor(buffer:active_cursor_pos())
			end
		end
	
		if key("ctrl") and not key("alt") then
			local extend = key("shift")
			if keyp("right") then buffer:next_word(extend); moved = true
			elseif keyp("left") then buffer:previous_word(extend); moved = true
			elseif keyp("w") then
				buffer:next_word(false)
				buffer:previous_word(false)
				buffer:next_word(true)
				findbox:launch_search(true, "forward")
				this_command = "select_word"
				moved = true
			elseif keyp("l") then
				if last_command ~= "select_line" then
					buffer:move_home(false, false)
				end
				buffer:move_down(true)
				this_command = "select_line"
				moved = true
			elseif keyp("h") and extend then
				buffer:set_cursor(buffer:active_cursor_pos())
			elseif keyp("c") then
				buffer:copy()
			elseif keyp("x") then
				buffer:cut()
				moved = true
			elseif keyp("v") then
				buffer:paste()
				moved = true
			end
		end	
		
		if key("ctrl") then
			if keyp("z") then
				buffer:undo()
				moved = true
			elseif keyp("y") or (key("shift") and keyp("z")) then
				buffer:redo()
				moved = true
			end
			if keyp("tab") then notify("!!!") end
			if key("shift") and keyp("n") then show_line_numbers = not show_line_numbers
			end
		end
				
		if moved then
			self:show_cursor(true)
			blink_timer = 0
			last_command = this_command
		end

	end
	

	function self:compute_scrollbar_coords()
		local total_height = buffer:total_height()
		local thumb_height = math.floor(0.5 + (self.height * self.height) / total_height)
		thumb_height = max(scrollbar_width, thumb_height)
		local thumb_y = math.floor(0.5 + (buffer.anim_y * self.height) / total_height)
		return total_height, thumb_y, thumb_height
	end

	
	function self:draw(msg)
		local theme = config.theme
		rectfill(
			0, 0,
			self.width - 1 - scrollbar_width, self.height - 1,
			theme.editor_bg
		)
		
		-- TODO: this is in /system/lib/gui_ed.lua:
		--     -- draw tabs relative to home
		--     poke(0x4005, (@0x4005) | 0x2)

		if not buffer then return end
		
		local dx = math.floor(0.5 + buffer.anim_x)
		local dy = math.floor(0.5 + buffer.anim_y)
		
		-- Matches
		
		local match_color = 0
		for start_col, start_row, end_col, end_row in buffer:matches() do
			for row = start_row, end_row do
				local y = buffer:find_cursor_y(row) - dy
				local start_x = get_margin_width() - dx
				if row == start_row then
					start_x = buffer:find_cursor_x(start_col, row) - dx + get_margin_width()
				end
				local end_x = self.width
				if row == end_row then
					end_x = buffer:find_cursor_x(end_col, row) - dx + get_margin_width() - 1
				end
				if not (row == end_row and end_col == 1) then
					rectfill(start_x, y - 2, end_x, y + 8, match_color)
				end
			end
		end
		
		-- Selections
		
		local selection_color = (buffer:number_of_selections() > 1) and 9 or 10
		buffer:foreach_selection(
			function(start_col, start_row, end_col, end_row, _active)
				for row = start_row, end_row do
					local y = buffer:find_cursor_y(row) - dy
					local start_x = get_margin_width() - dx
					if row == start_row then
						start_x = buffer:find_cursor_x(start_col, row) - dx + get_margin_width()
					end
					local end_x = self.width
					if row == end_row then
						end_x = buffer:find_cursor_x(end_col, row) - dx + get_margin_width() - 1
					end
					if not (row == end_row and end_col == 1) then
						rectfill(start_x, y - 2, end_x, y + 8, selection_color)
					end
				end
			end
		)
		
		-- Text
	
		local x = get_margin_width() - dx
		local row = buffer:find_cursor_row(dy)
		local y = buffer:find_cursor_y(row) - dy
		buffer:highlight(row) -- TODO: is this useful?
		local text = buffer:highlighted(row)
		while text and y < self.height do
			print(text, x, y, 6)
			row += 1
			y = buffer:find_cursor_y(row) - dy
			text = buffer:highlighted(row)
		end
		
		-- Cursors
		
		local cursor_color = (buffer:number_of_cursors() > 1) and 30 or 14
		if (blink_timer % 32 < 16) or not self:has_keyboard_focus() then
			buffer:foreach_cursor(
				function(col, row, is_selection, _active)
					local y = buffer:find_cursor_y(row) - dy
					local x = buffer:find_cursor_x(col, row) - dx + get_margin_width()
					local w = is_selection and 0 or cursor_width
					if (not is_selection) or false then
						rectfill(x, y - 2, x + w, y + 8, cursor_color)
					end
				end
			)
		end

		-- Margin (i.e. line numbers)
	
		if show_line_numbers then
			rectfill(-4 - dx, 0, -4 + get_margin_width() - 1 - dx, self.height - 1, 16) -- or 18, 16
			--line(get_margin_width() - 1, 0, get_margin_width() - 1, self.height - 1, 18)
			local row = buffer:find_cursor_row(dy)
			local y = buffer:find_cursor_y(row) - dy
			while buffer:text(row) and y < self.height do
--				print(string.format("%4d", row), 3, y, 1)
				print(string.format("\014%4d", row), -2 - dx, y + 2, 1)
				row += 1
				y = buffer:find_cursor_y(row) - dy
			end
		end

		-- Scrollbar
		
		rectfill(self.width - scrollbar_width, 0, self.width - 1, self.height - 1, 13)
		local total_height, thumb_y, thumb_height = self:compute_scrollbar_coords()
		-- The scrollbar thumb
		rectfill(
			self.width - scrollbar_width + 0, thumb_y,
			self.width - 1, thumb_y + thumb_height - 1,
			6
		)
		if show_sections_in_scrollbar then
			buffer:foreach_row(
				function(row, str)
					if str:find("----", 1, 4) then
						local y = buffer:find_cursor_y(row)
						y = (y * self.height) // total_height
						line(self.width - scrollbar_width + 1, y, self.width - 2, y, 18)
					end
				end
			)
		end
		if show_cursors_in_scrollbar then
			buffer:foreach_cursor(
				function(col, row, is_selection, _is_active)
					if not is_selection then
						local y = buffer:find_cursor_y(row)
						y = (y * self.height) // total_height
						line(self.width - scrollbar_width + 1, y, self.width - 2, y, cursor_color)
					end
				end
			)
		end
		if true and not findbox.hidden and #findbox:target() > 1 then
			for _start_col, start_row, _end_col, end_row in buffer:matches() do
				local start_y = buffer:find_cursor_y(start_row)
				start_y = (start_y * self.height) // total_height
				local end_y = buffer:find_cursor_y(end_row)
				end_y = (end_y * self.height) // total_height
				rectfill(
					self.width - scrollbar_width + 1, start_y,
					self.width - 2, end_y,
					match_color
				)
			end
		end
		if true then
			buffer:foreach_selection(
				function(_start_col, start_row, _end_col, end_row, _is_active)
					local start_y = buffer:find_cursor_y(start_row)
					start_y = (start_y * self.height) // total_height
					local end_y = buffer:find_cursor_y(end_row)
					end_y = (end_y * self.height) // total_height
					rectfill(
						self.width - scrollbar_width + 1, start_y,
						self.width - 2, end_y,
						selection_color
					)
				end
			)
		end
	end


	return self
end


-------------------------------------------------------------------------------------------

:: src/ui/findbox.lua
--[[pod_format="raw",created="2025-03-28 14:29:26",modified="2025-04-01 20:24:10",revision=2545]]
-------------------------------------------------------------------------------------------


local config = require "src/config.lua"


-------------------------------------------------------------------------------------------


return function(attribs)
	local self = attribs
	self.width = 40
	self.height = 14
	self.hidden = true
	head():new(self)
	
	
	-- Private fields
	local ocol, orow = 1, 1 -- Origin
	local acol, arow = 1, 1 -- Anchor, i.e. starting position for search
	local target = "" -- The text we're looking for
	local direction = "forward"
	local previous_target = ""
	local no_match = false

	
	function self:target()
		return target
	end
	
	
	function self:click(msg)
		return false
	end
	
	
	local function update_search(and_show)
		local buffer = self.editor:buffer()
		if target == "" then
			acol, arow = ocol, orow
			buffer:clear_matches()
			buffer:set_cursor(acol, arow)
			if and_show then
				self.editor:center_cursor()
			end
		else
			buffer:search_all(target, true)
		end
		local found = false
		if direction == "forward" then
			buffer:set_cursor(ocol, orow)
			for scol, srow, ecol, erow in buffer:matches() do
				if (srow == arow and scol >= acol) or (srow > arow) then
					buffer:set_selection(scol, srow, ecol, erow)
					found = true
					break
				end
			end
			if not found then
				for scol, srow, ecol, erow in buffer:matches() do
					buffer:set_selection(scol, srow, ecol, erow)
					found = true
					break
				end
			end
		elseif direction == "backward" then
			buffer:set_cursor(ocol, orow)
			for scol, srow, ecol, erow in buffer:matches_reverse() do
				if (srow == arow and ecol <= acol) or (srow < arow) then
					buffer:set_selection(scol, srow, ecol, erow)
					found = true
					break
				end
			end
			if not found then
				for scol, srow, ecol, erow in buffer:matches_reverse() do
					buffer:set_selection(scol, srow, ecol, erow)
					found = true
					break
				end
			end
		end
		no_match = not found
		if found and and_show then
			self.editor:center_cursor(true)
		end
	end
	
	
	local function relaunch_search()
		local buffer = self.editor:buffer()
		if target == "" then
			target = previous_target
		elseif direction == "forward" then
			acol, arow = buffer:active_cursor_pos()
		elseif direction == "backward" then
			acol, arow, _, _ = buffer:current_selection()
			if not acol then
				acol, arow = buffer:active_cursor_pos()
			end
		end
	end

	
	-- Called by the editor
	function self:launch_search(first_launch, dir)
		direction = dir
		local buffer = self.editor:buffer()
		self:set_keyboard_focus(true)
		if first_launch then
			self.hidden = false
			local str = buffer:current_selection_string()
			if str then
				target = str
			end
			ocol, orow, _, _ = buffer:current_selection()
			if not ocol then
				ocol, orow = buffer:active_cursor_pos()
			end
			acol, arow = ocol, orow
			no_match = false
			update_search(false)
		else
			relaunch_search()
			update_search(true)
		end
	end
	
	
	function self:stop_search()
		local buffer = self.editor:buffer()
		self:set_keyboard_focus(false)
		acol, arow = 1, 1
		previous_target = target
		target = ""
		self.hidden = true
		buffer:clear_matches()
	end
	
	
	function self:update(msg)
		local buffer = self.editor:buffer()
		if not buffer then return end

		if not self:has_keyboard_focus() then
			return
		end
		
		while peektext() do
			local k = readtext()
			target ..= k
			update_search(true)
		end

		if keyp("enter") then
			self:stop_search()
			if key("shift") then
				local col, row = buffer:active_cursor_pos()
				buffer:set_cursor(col, row)
			end
		elseif keyp("backspace") then
			if key("ctrl") then
				target = ""
				update_search(false)
			else
				target = target:sub(1, -2)
				update_search(true)
			end
		elseif keyp("delete") then
			buffer:delete_selection()
			self:stop_search()
		elseif keyp("escape") then
			buffer:set_cursor(ocol, orow)
			self:stop_search()
			self.editor:center_cursor()
		elseif keyp("pagedown") or (keyp("tab") and not key("shift")) then
			direction = "forward"
			relaunch_search()
			update_search(true)
		elseif keyp("pageup") or (keyp("tab") and key("shift")) then
			direction = "backward"
			relaunch_search()
			update_search(true)
		elseif key("ctrl") and keyp("w") then
			-- TODO: same problem as double ctrl-f...
			-- need to come from the editor instead.
			--[[buffer:next_word(false)
			buffer:previous_word(false)
			buffer:next_word(true)
			relaunch_search()
			update_search(true)]]
		elseif key("ctrl") and keyp("a") then
			buffer:select_all_matches()
			self:stop_search()
		elseif key("ctrl") and keyp("x") then
			buffer:cut()
			update_search(true)
		elseif key("ctrl") and keyp("c") then
			buffer:copy()
			update_search(true)
		elseif key("ctrl") and keyp("v") then
			buffer:paste()
			update_search(true)
		-- TODO: add undo/redo, Ctrl-L
		end
		local moved = false
		if not key("ctrl") and not key("alt") then
			if keyp("up") then buffer:move_up(false); moved = true
			elseif keyp("down") then buffer:move_down(false); moved = true
			elseif keyp("right") then buffer:move_right(false); moved = true
			elseif keyp("left") then buffer:move_left(false); moved = true
			elseif keyp("home") then buffer:move_home(false, false); moved = true
			elseif keyp("end") then buffer:move_end(false); moved = true
			end
		end
		if moved then
			self.editor:center_cursor()
			self:stop_search()
		end
	end
	
	
	function self:draw(msg)
		local theme = config.theme
		rectfill(0, 0, self.width - 1, self.height - 1, theme.sidebar_bg)
		line(0, 0, self.width - 1, 0, 1)
		line(0, 0, 0, self.height - 1, 1)
		line(self.width - 1, 0, self.width - 1, self.height - 1, 1)
		pset(1, 1, 1)
		pset(self.width - 2, 1, 1)
		line(1, 2, 2, 1, 1)
		line(self.width - 2, 2, self.width - 3, 1, 1)
--		line(3, 2, self.width - 4, 2, 6)
--		line(2, 3, 2, self.height - 1, 6)
--		line(self.width - 3, 3, self.width - 3, self.height - 1, 6)
		print("Find: ", 8, 5, 1)
		print(target, 8 + 25, 5, no_match and 9 or 7)
	end
	
	return self
end


-------------------------------------------------------------------------------------------

:: src/ui/head.lua
--[[pod_format="raw",created="2025-03-27 19:11:47",modified="2025-04-01 20:24:10",revision=3047]]
----------------------------------------------------------------------------------------


local _head = nil
function head() return _head end


----------------------------------------------------------------------------------------


function init()
	_head = create_gui()
end


----------------------------------------------------------------------------------------


function update()
	_head:update_all()
end


----------------------------------------------------------------------------------------


function draw()
	_head:draw_all()
end


----------------------------------------------------------------------------------------


return {
	head = head,
	init = init,
	draw = draw,
	update = update,
}


----------------------------------------------------------------------------------------

:: src/ui/sidebar.lua
--[[pod_format="raw",created="2025-03-23 12:31:49",modified="2025-04-01 20:24:10",revision=6138]]
-------------------------------------------------------------------------------------------


local buffers = require "src/buffers.lua"
local config = require "src/config.lua"
local filetree = require "src/filetree.lua"


-------------------------------------------------------------------------------------------


local arrow_up <const> = "\^:00040e1f00000000"
local arrow_down <const> = "\^:001f0e0400000000"
local arrow_right <const> = "\^:02060e0602000000"
local arrow_left <const> = "\^:080c0e0c08000000"


local row_height <const> = 9
local header_height <const> = 20
local footer_height <const> = 8
local padding_left <const> = 3
local padding_right <const> = 5


-------------------------------------------------------------------------------------------


return function(attribs)
	local self = attribs or {}
	self.x = attribs.x or 0
	self.y = attribs.y or 0
	self.width = 60
	self.height_rel = 1
	head():new(self)


	-- Private fields
	local current = nil
	
	
	function self:set_current(node)
		current = node
		if current then
			self.editor:set_buffer(current:buffer())
		else
			self.editor:set_buffer(buffers.new("(nil node)"))
		end
	end
	
	
	function self:current_node(node)
		return current
	end


	function self:hover(msg)
		self.cursor = 1
		if msg.mx >= self.width - 2 then
			self.cursor = 9 -- TODO: replace with horiz. double arrow
		else
			self.cursor = "pointer"
		end
	end
	
	
	function self:click(msg)
		local y = header_height
		filetree.foreach(
			function(node, level)
				if level == 0 then return end
				if y <= msg.my and msg.my < y + row_height then
					if node:is_file() then
						self:set_current(node)
					end
				end
				y += row_height
			end
		)
	end
	

	function self:tap(msg)
	end
	
	
	function self:update(msg)
		if self:has_keyboard_focus() then
			log("!!!!!")
		end
	end
	

	function self:draw(msg)
		local theme = config.theme
		rectfill(
			0, 0,
			self.width - 1, self.height - 1,
			theme.sidebar_bg
		)
		do
			local x = 2
			pal(7, theme.sidebar_fg)
			if false then -- only for fullscreen
				spr(8, x, 2); x += 11
			end
			spr(9, x, 2); x += 11
			print("\014all\-h" .. arrow_down, 20 + 6*0, 2 + 3, 7)
			--spr(10, x, 2); x += 11
			--spr(9, x, 2); x += 11
			spr(11, self.width - 11 - 3, 2)
			pal(7, 7)
			line(4, 15, self.width - 5, 15, theme.sidebar_fg)
		end
		do
--			line(4, self.height - 9, self.width - 5, self.height - 9, theme.sidebar_fg)
			pal(7, theme.sidebar_fg)
			spr(12, 0, self.height - 8)
			spr(13, self.width - 11, self.height - 8)
			pal(7, 7)
			local row = 0
			if current then
				local _, r = current:buffer():active_cursor_pos()
				row = r
			end
			row = string.format("%d", row)
--			local x = self.width - 4*(#row) - 4
			local x = (self.width // 2) - ((4 * #row) // 2) - 1
			print("\014" .. row, x, self.height - 6, theme.sidebar_fg)
		end
		clip(
			self.x + padding_left,
			self.y + header_height,
			self.width - padding_left - padding_right,
			self.height - header_height - footer_height
		)
--		rectfill(0, 0, self.width - 1, self.height - 12, 2)
		local x, y = padding_left, header_height
		filetree.foreach(
			function(node, level)
				if node:is_folder() and level == 0 then return end
				level = max(1, level)
				local str = "\014"
				str ..= node:path():basename()
				if node:is_folder() then str ..= "/" end
				local c = theme.sidebar_fg
				if node == current then
					c = theme.sidebar_fg_active
				end
				if node:is_file() and not node:is_on_disk() then
					c = (node == current) and 9 or 25
				end
				if node:is_file() and node:is_stale() then
					c = (node == current) and 23 or 8
				end
				print(str, x + 6 * (level - 1), y, c)
				--[[
				for i = 0, level - 2 do
					line(x + i*6 + 1, y - 2, x + i*6 + 1, y + 6, theme.sidebar_fg_active)
				end
				]]--
				y += row_height
			end
		)
	end

	
	return self
end


-------------------------------------------------------------------------------------------

:: src/ui/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTIzIDEwOjE5OjAxIixtb2RpZmllZD0iMjAyNS0w
NC0wMSAyMDoyNDoxMSJdXQ==
:: src/app.lua
--[[pod_format="raw",created="2025-03-27 11:19:40",modified="2025-04-01 20:24:10",revision=3642]]

local multiclipboard = {}


function set_multiclipboard(array)
	multiclipboard = {
		array = array,
		clipboard = table.concat(array, "\n"),
	}
	set_clipboard(multiclipboard.clipboard)
end


function get_multiclipboard()
	local clipboard = get_clipboard()
	if multiclipboard.array and (clipboard == multiclipboard.clipboard) then
		return multiclipboard.array
	end
	return clipboard
end


return {
	set_multiclipboard = set_multiclipboard,
	get_multiclipboard = get_multiclipboard,
}
:: src/buffers.lua
--[[pod_format="raw",created="2025-03-22 18:20:27",modified="2025-04-01 20:24:10",revision=7515]]
-------------------------------------------------------------------------------------------


local app = require "src/app.lua"
local config = require "src/config.lua"


-------------------------------------------------------------------------------------------


-- NOTE: duplicated in buffer.lua!
local row_height <const> = 11


------------------------------------------------------------------------------------------


local function shallow_copy(text)
	local copied = {}
	for i in ipairs(text) do
		copied[i] = text[i]
	end
	return copied
end

	
local function char_category(char)
	if char == nil then return "nil"
	elseif char == ord(" ") or char == ord("\t") then return "whitespace"
	elseif char >= ord("a") and char <= ord("z") then return "identifier"
	elseif char >= ord("A") and char <= ord("Z") then return "identifier"
	elseif char >= ord("0") and char <= ord("9") then return "identifier"
	elseif char == ord("_") then return "identifier"
	-- TODO: separators, etc.
	else return "other"
	end
end


------------------------------------------------------------------------------------------
	
	
local decor_multicat = { [3] = "\fd", [4] = "\fc" }
local reserved_keywords = { "and", "break", "do", "else", "elseif", "end", "for",	"function", "if", "in", "local", "not", "or", "repeat", "return", "then", "until", "while" }
local reserved_values = { "true", "false", "nil" }
local decor_keyword = {}
local decor_cat = { [0] = "\f7", "\f6", "\fc", "\fd", "\fc", "\f7" }
local decor_funcname = function(cat, char) if cat == 1 and char == "(" then return "\fb" else return nil end end

function init()
	local theme = config.theme
	
	local function color_hex(c)
		local c = c and type(c) == "number" and mid(0, c, 63) or 7
		if 0 <= c and c <= 9 then
			return string.format("\f%d", c)
		else
			return "\f" .. chr(ord("a") + c - 10)
		end
	end
	
	decor_multicat = {
		[3] = color_hex(theme.lua_comment),
		[4] = color_hex(theme.lua_string),
	}
	
	decor_cat = {
		[0] = color_hex(theme.lua_unknown),
		color_hex(theme.lua_text),
		color_hex(theme.lua_number),
		color_hex(8), -- ???
		color_hex(9), -- ???
		color_hex(theme.lua_operator),
	}
	
	for i = 1, #reserved_keywords do
		decor_keyword[reserved_keywords[i]] = color_hex(theme.lua_keyword)
	end
	
	for i = 1, #reserved_values do
		decor_keyword[reserved_values[i]] = color_hex(theme.lua_reserved)
	end
	
	decor_funcname =
		function(cat, char)
			if cat == 1 and char == "(" then
				return color_hex(theme.lua_function)
			else
				return nil
			end
		end
end


------------------------------------------------------------------------------------------


function new(text)
	local self = {
		-- Public fields
		screen_x = -4,
		screen_y = -4,
		anim_x = -4,
		anim_y = -4,
		highlighter_row = 1,
	}
	

	-- Private fields
	local text = split(text, "\n", false) or {}
	local highlighted = {}
	local cursors = { { col = 1, row = 1, wanted_x = 0 } }
	local matches = {}
	local undo_stack = create_undo_stack(
		function()
			return {
				text = shallow_copy(text),
				-- TODO: is there a better solution than saving the highlights
				-- in the undo stack? Picotron's code editor doesn't seem to
				-- do it, but doesn't suffer from slow update after undo/redo
				-- in a large file...
--				highlighted = shallow_copy(highlighted),
				cursors = pod(cursors),
			}
		end,
		function(state)
			text = state.text
--			highlighted = state.highlighted
			cursors = unpod(state.cursors)
			self:highlight(cursors[#cursors].row)
		end
	)
	local undo_group = nil


	function self:text(row)
		if row < 1 then return "" end
		if row > #text then return nil end
		return text[row]	
	end
	
	
	function self:highlighted(row)
		if highlighted[row] and highlighted[row].input == text[row] then
			return highlighted[row].out or ""
		end
		return text[row] or ""
	end
	
	
	function self:number_of_rows()
		return #text
	end
	

	function self:full_text_copy()
		return table.concat(text, "\n")
	end
	

	function self:foreach_row(func)
		for row, str in ipairs(text) do
			func(row, str)
		end
	end
	
	function self:highlight(row)
		row = mid(1, row, #text)
		local str = text[row] or ""
		
		local unchanged = highlighted[row] and highlighted[row].input == str
		local continuity =
			highlighted[row] and highlighted[row - 1]
			and (highlighted[row - 1].after == highlighted[row].before)
		if unchanged and (continuity or (row == 1)) then
			return
		end
		
		if row > 1 then
			self:highlight(row - 1)
			if not highlighted[row - 1] then return end
		end
		
		--[[do
			local cause = "???"
			if not unchanged then cause = "changed" end
			if not continuity then
				cause = "continuity: "
				if not highlighted[row] then cause ..= "(not highlighted row)"
				elseif not highlighted[row - 1] then cause ..= "(not highlighted row - 1)"
				else cause ..= "" .. highlighted[row - 1].after .. " ~= " .. highlighted[row].before
				end
			end
			log("highlighting row " .. row .. " because " .. cause)
		end]]
		
		local out = ""
		local col = 1
		local lexer_state = highlighted[row - 1] and highlighted[row - 1].after or 0
		while col <= #str do
			local token, end_col, cat
			token, end_col, cat, lexer_state = tokenoid(str, col, lexer_state)
			if not token then return out end
			local decor =
				decor_multicat[cat] or decor_keyword[token]
				or decor_funcname(cat, str[end_col]) or decor_cat[cat] or ""
			out = out .. decor .. token
			col = end_col
		end
		highlighted[row] = {
			input = str,
			out = out,
			before = highlighted[row - 1] and highlighted[row - 1].after or 0,
			after = lexer_state or 0,
		}
	end
	

	function self:checkpoint()
		undo_stack:checkpoint()
	end
	

	function self:undo()
		undo_stack:undo()
		undo_group = nil
	end
	

	function self:redo()
		undo_stack:redo()
		undo_group = nil
	end
	
	
	function self:center_on(col, row)
		-- TODO: this method should be in editor.lua, probably
		self.screen_y = self:find_cursor_y(row - 12)
		self.screen_x = self:find_cursor_x(col, row)
	end
	

	-- Cursors --
	

	function self:foreach_cursor(func)
		local nb = #cursors
		for i, cursor in ipairs(cursors) do
			local is_active_cursor = (nb > 1) and (i == nb)
			local is_selection = (cursor.acol ~= nil)
			func(cursor.col, cursor.row, is_selection, is_active_cursor)
		end
	end
	
	
	local function selection_range(cursor)
		if not cursor.acol then
			return cursor.col, cursor.row, cursor.col, cursor.row
		elseif cursor.arow < cursor.row then
			return cursor.acol, cursor.arow, cursor.col, cursor.row
		elseif cursor.arow > cursor.row then
			return cursor.col, cursor.row, cursor.acol, cursor.arow
		elseif cursor.acol < cursor.col then
			return cursor.acol, cursor.arow, cursor.col, cursor.row
		else
			return cursor.col, cursor.row, cursor.acol, cursor.arow
		end
	end
	
	
	local function selection_string(cursor)
		local str = ""
		local start_col, start_row, end_col, end_row = selection_range(cursor)
		if start_row == end_row then
			str = sub(text[start_row], start_col, end_col - 1)
		else
			str = sub(text[start_row], start_col, -1) .. "\n"
			for row = start_row + 1, end_row - 1 do
				str ..= text[row] .. "\n"
			end
			str ..= sub(text[end_row], 1, end_col - 1)
		end
		return str
	end
	

	function self:foreach_selection(func)
		local nb = #cursors
		for i, cursor in ipairs(cursors) do
			if cursor.acol then
				local start_col, start_row, end_col, end_row = selection_range(cursor)
				local is_active_cursor = (nb > 1) and (i == nb)
				func(start_col, start_row, end_col, end_row, is_active_cursor)
			end
		end
	end
	
	
	function self:get_all_selections()
		local selections = {}
		for cursor in all(cursors) do
			local str = selection_string(cursor)
			add(selections, str)
		end
		return selections
	end
	

	function self:has_multiple_cursors()
		return #cursors > 1
	end
	
	
	function self:number_of_cursors()
		return #cursors
	end
	
	
	function self:number_of_selections()
		local nb = 0
		for cursor in all(cursors) do
			if cursor.acol then
				nb += 1
			end
		end
		return nb
	end
	
	
	function self:search_all(target, plain)
		matches = {}
		for row = 1, #text do
			local col = 1
			while col <= #text[row] do
				local tcol = text[row]:find(target, col, plain)
				if tcol then
					table.insert(matches, {
						scol = tcol, srow = row,
						ecol = tcol + #target, erow = row,
					})
					col = tcol + #target
				else
					col = #text[row] + 1
				end
			end
			row += 1
		end
		return nil
	end
	
	
	function self:matches()
		local i = 0
		return function()
			i += 1
			if i <= #matches then
				local match = matches[i]
				return match.scol, match.srow, match.ecol, match.erow
			end
		end
	end
	
	
	function self:matches_reverse()
		local i = #matches + 1
		return function()
			i -= 1
			if i >= 1 then
				local match = matches[i]
				return match.scol, match.srow, match.ecol, match.erow
			end
		end
	end
	
	
	function self:select_all_matches()
		if #matches < 1 then return end
		cursors = {}
		for match in all(matches) do
			local wanted_x = self:find_cursor_x(match.ecol, match.erow)
			table.insert(
				cursors,
				{ acol = match.scol, arow = match.srow,
					col = match.ecol, row = match.erow,
					wanted_x = wanted_x }
			)
		end
	end
	
	
	function self:clear_matches()
		matches = {}
	end


	function self:find_cursor_x(col, row)
		if text then
			return print(sub(text[row], 1, col - 1), 0, -1000) or 0
		end
		return 0
	end


	function self:find_cursor_y(row)
		if text then
			return (row - 1) * row_height
		end
		return 0
	end
	

	function self:find_cursor_row(y)
		return 1 + (y // row_height)
	end


	function self:find_cursor_col(row, x)
		if row > #text then return #text[#text] + 1 end
		local str = text[row]
		if not str then return 0 end
		if #str == 0 then return 1 end
		for col = 1, #str do
			local xx = print(sub(str, 1, col), 0, -1000)
			if xx and xx > x then return col end
		end
		return #str + 1
	end
	
	
	function self:find_word_at(col, row)
		if char_category(text[row]:byte(col)) ~= "identifier" then
			return col, row, col + 1, row
		end
		local scol, ecol = col, col
		while char_category(text[row]:byte(scol)) == "identifier" do
			scol -= 1
		end
		scol += 1
		while char_category(text[row]:byte(ecol)) == "identifier" do
			ecol += 1
		end
		return scol, row, ecol, row
	end
	

	function self:active_cursor_pos()
		return cursors[#cursors].col, cursors[#cursors].row
	end
	
	
	function self:current_selection()
		local cursor = cursors[#cursors]
		if cursor.acol then
			return selection_range(cursor)
		end
		return nil
	end
	
	
	function self:current_selection_string()
		local cursor = cursors[#cursors]
		if cursor.acol then
			return selection_string(cursor)
		end
		return nil
	end
	

	function self:total_height()
		return #text * row_height
	end
	

	function self:set_cursor(col, row, is_add)
		local row = mid(1, row, #text)
		local col = mid(1, col, #text[row] + 1)
		local x = self:find_cursor_x(col, row)
		if is_add then
			add(cursors, { col = col, row = row, x = x })
			self:merge_cursors()
		else
			cursors = { { col = col, row = row, x = x } }
		end
		undo_group = nil
	end
	

	function self:set_selection(scol, srow, ecol, erow, is_add)
		local arow = mid(1, srow, #text)
		local acol = mid(1, scol, #text[srow] + 1)
		local row = mid(1, erow, #text)
		local col = mid(1, ecol, #text[erow] + 1)
		local x = self:find_cursor_x(col, row)
		if is_add then
			add(cursors, { col = col, row = row, x = x, acol = acol, arow = arow })
			self:merge_cursors()
		else
			cursors = { { col = col, row = row, x = x, acol = acol, arow = arow } }
		end
		undo_group = nil
	end
	

	function self:extend_active_selection(col, row)
		local cursor = cursors[#cursors]
		local row = mid(1, row, #text)
		local col = mid(1, col, #text[row] + 1)
		if (col == cursor.col) and (row == cursor.row) then
			return
		end
		if not cursor.acol then
			cursor.acol, cursor.arow = cursor.col, cursor.row
		end
		cursor.col, cursor.row = col, row
		if (cursor.col == cursor.acol) and (cursor.row == cursor.arow) then
			cursor.acol, cursor.arow = nil, nil
		end
		cursor.wanted_x = self:find_cursor_x(cursor.col, cursor.row)
		self:merge_cursors()
		undo_group = nil
	end
	

	function self:select_word(col, row, is_add)
		local row = mid(1, row, #text)
		local col = mid(1, col, #text[row] + 1)
		local scol, srow, ecol, erow = self:find_word_at(col, row)
		local x = self:find_cursor_x(col, row)
		local cursor = {
			wcol = col, wrow = row,
			acol = scol, arow = srow,
			col = ecol, row = erow,
			x = x,
		}
		if is_add then
			add(cursors, cursor)
			self:merge_cursors()
		else
			cursors = { cursor }
		end
		undo_group = nil
	end
	

	function self:extend_word_selection(col, row)
		local row = mid(1, row, #text)
		local col = mid(1, col, #text[row] + 1)
		local cursor = cursors[#cursors]
		local scol, srow, ecol, erow = self:find_word_at(col - 1, row)
		-- Find the original word (the first selected)
		local wscol, wsrow, wecol, werow = self:find_word_at(cursor.wcol, cursor.wrow)
		if (srow < wsrow) or (srow == wsrow and scol < wscol) then
			cursors[#cursors] = {
				wcol = cursor.wcol, wrow = cursor.wrow,
				col = scol, row = srow,
				acol = wecol, arow = werow,
				wanted_x = self:find_cursor_x(scol, srow)
			}
		elseif (erow > werow) or (erow == werow and ecol >= wecol) then
			cursors[#cursors] = {
				wcol = cursor.wcol, wrow = cursor.wrow,
				acol = wscol, arow = wsrow,
				col = ecol, row = erow,
				wanted_x = self:find_cursor_x(ecol, erow)
			}
		end
		self:merge_cursors()
		undo_group = nil
	end
	
	
	function self:select_line(row, is_add)
		local row = mid(1, row, #text)
		local x = self:find_cursor_x(1, row)
		local cursor = {
			lrow = row,
			acol = 1, arow = row,
			col = 1, row = mid(1, row + 1, #text),
			x = x,
		}
		if is_add then
			add(cursors, cursor)
			self:merge_cursors()
		else
			cursors = { cursor }
		end
		undo_group = nil
	end
	

	function self:extend_line_selection(row)
		local cursor = cursors[#cursors]
		local row = mid(1, row, #text)
		if not cursor.acol then
			cursor.acol, cursor.arow = cursor.col, cursor.row
		end
		if not cursor.lrow then
			cursor.lrow = cursor.row
		end
		if row >= cursor.lrow then
			cursor.acol, cursor.arow = 1, cursor.lrow
			cursor.col, cursor.row = 1, row + 1
		elseif row < cursor.lrow then
			cursor.acol, cursor.arow = 1, row
			cursor.col, cursor.row = 1, cursor.lrow + 1
		end
		cursor.wanted_x = self:find_cursor_x(cursor.col, cursor.row)
		self:merge_cursors()
		undo_group = nil
	end
	
	
	function self:clear_selections()
		cursors = { cursors[#cursors] }
		cursors[#cursors].acol = nil
		cursors[#cursors].arow = nil
	end
	

	function self:merge_cursors()
		-- TODO: handle selections...
		local is_duplicate = {}
		for i = #cursors, 1, -1 do
			for j = i - 1, 1, -1 do
				local c1, c2 = cursors[i], cursors[j]
				if c1.row == c2.row and c1.col == c2.col then
					is_duplicate[c1] = true
				end
			end
		end
		for i = #cursors, 1, -1 do
			if is_duplicate[cursors[i]] then
				table.remove(cursors, i)
			end
		end
		if #cursors == 0 then -- should never happen?
			self:set_cursor(1, 1)
		end
	end
	
	
	-- Copy & Paste --
	
	
	function self:copy()
		local selections = self:get_all_selections()
		app.set_multiclipboard(selections)
	end
	
	
	function self:cut()
		local selections = self:get_all_selections()
		app.set_multiclipboard(selections)
		self:delete_selection()
	end
	
	
	function self:paste()
		self:delete_selection()
		local multiclip = app.get_multiclipboard()
		if type(multiclip) == "string" then multiclip = { multiclip } end
		if #multiclip == self:number_of_cursors() then
			local i = 1
			self:foreach_cursor(
				function(col, row, _)
					self:insert_text_at(col, row, multiclip[i])
					i += 1
				end
			)
		else
			local str = table.concat(multiclip, "\n")
			self:foreach_cursor(
				function(col, row, _)
					self:insert_text_at(col, row, str)
				end
			)
		end
	end


	-- Movement --
	

	local function initiate_selection(cursor)
		cursor.acol, cursor.arow = cursor.col, cursor.row
	end


	local function cancel_selection(cursor)
		cursor.acol, cursor.arow = nil, nil
		cursor.wanted_x = self:find_cursor_x(cursor.col, cursor.row)
		undo_group = nil
	end


	function self:move_up(extend)
		for cursor in all(cursors) do
			if cursor.acol and (not extend) then
				cursor.col, cursor.row, _, _ = selection_range(cursor)
				cancel_selection(cursor)
			elseif extend and (not cursor.acol) then
				initiate_selection(cursor)
			end
			cursor.row = max(1, cursor.row - 1)
			if cursor.wanted_x then
				cursor.col = self:find_cursor_col(cursor.row, cursor.wanted_x + 2)
			end
			if cursor.col > #text[cursor.row] + 1 then
				cursor.col = #text[cursor.row] + 1
			end
		end
		self:merge_cursors()
		undo_group = nil
	end


	function self:move_down(extend)
		for cursor in all(cursors) do
			if cursor.acol and (not extend) then
				 _, _, cursor.col, cursor.row = selection_range(cursor)
				cancel_selection(cursor)
			elseif extend and (not cursor.acol) then
				initiate_selection(cursor)
			end
			cursor.row = min(cursor.row + 1, #text)
			if cursor.wanted_x then
				cursor.col = self:find_cursor_col(cursor.row, cursor.wanted_x + 2)
			end
			if cursor.col > #text[cursor.row] + 1 then
				cursor.col = #text[cursor.row] + 1
			end
		end
		self:merge_cursors()
		undo_group = nil
	end


	function self:move_left(extend)
		for cursor in all(cursors) do
			if cursor.acol and (not extend) then
				cursor.col, cursor.row, _, _ = selection_range(cursor)
				cancel_selection(cursor)
				goto continue -- because the cursor must not move
			elseif extend and (not cursor.acol) then
				initiate_selection(cursor)
			end
			cursor.col -= 1
			if cursor.col < 1 then
				if cursor.row > 1 then
					cursor.row -= 1
					cursor.col = #text[cursor.row] + 1
				else
					cursor.col = 1
				end
			end
			::continue::
			cursor.wanted_x = self:find_cursor_x(cursor.col, cursor.row)
		end
		self:merge_cursors()
		undo_group = nil
	end


	function self:move_right(extend)
		for cursor in all(cursors) do
			if cursor.acol and (not extend) then
				_, _, cursor.col, cursor.row = selection_range(cursor)
				cancel_selection(cursor)
				goto continue -- because the cursor must not move
			elseif extend and (not cursor.acol) then
				initiate_selection(cursor)
			end
			cursor.col += 1
			if cursor.col > #text[cursor.row] + 1 then
				if cursor.row < #text then
					cursor.row += 1
					cursor.col = 1
				else
					cursor.col = #text[cursor.row] + 1
				end
			end
			::continue::
			cursor.wanted_x = self:find_cursor_x(cursor.col, cursor.row)
		end
		self:merge_cursors()
		undo_group = nil
	end


	function self:move_home(extend, smart)
		for cursor in all(cursors) do
			if cursor.acol and (not extend) then
				 cursor.col, cursor.row, _, _ = selection_range(cursor)
				cancel_selection(cursor)
			elseif extend and (not cursor.acol) then
				initiate_selection(cursor)
			end
			if smart then
				-- TODO
			else
				cursor.col = 1
			end
			-- TODO: merge cursors!!!
			cursor.wanted_x = self:find_cursor_x(cursor.col, cursor.row)
		end
		self:merge_cursors()
		undo_group = nil
	end


	function self:move_end(extend, smart)
		for cursor in all(cursors) do
			if cursor.acol and (not extend) then
				 _, _, cursor.col, cursor.row = selection_range(cursor)
				cancel_selection(cursor)
			elseif extend and (not cursor.acol) then
				initiate_selection(cursor)
			end
			if smart then
				-- TODO
			else
				cursor.col = #text[cursor.row] + 1
			end
			-- TODO: merge cursors!!!
			cursor.wanted_x = self:find_cursor_x(cursor.col, cursor.row)
		end
		self:merge_cursors()
		undo_group = nil
	end


	function self:next_word(extend)
		for cursor in all(cursors) do
			if cursor.acol and (not extend) then
				 _, _, cursor.col, cursor.row = selection_range(cursor)
				cancel_selection(cursor)
			elseif extend and (not cursor.acol) then
				initiate_selection(cursor)
			end
			local str = text[cursor.row]
			while char_category(str:byte(cursor.col)) == "whitespace" do
				cursor.col += 1
			end
			if cursor.col == #str + 1 and cursor.row < #text then
				cursor.row += 1
				cursor.col = 0
			end
			cursor.col += 1
			while
				cursor.col < #str + 1
				and char_category(str:byte(cursor.col)) == char_category(str:byte(cursor.col - 1))
			do
				cursor.col += 1
			end
			cursor.wanted_x = self:find_cursor_x(cursor.col, cursor.row)
		end
		self:merge_cursors()
		undo_group = nil
	end


	function self:previous_word(extend)
		for cursor in all(cursors) do
			if cursor.acol and (not extend) then
				 cursor.col, cursor.row, _, _ = selection_range(cursor)
				cancel_selection(cursor)
			elseif extend and (not cursor.acol) then
				initiate_selection(cursor)
			end
			local str = text[cursor.row]
			while cursor.col > 1 and char_category(str:byte(cursor.col - 1)) == "whitespace" do
				cursor.col -= 1
			end
			if cursor.col == 1 and cursor.row > 1 then
				cursor.row -= 1
				cursor.col = #text[cursor.row] + 2
			end
			cursor.col -= 1
			while
				cursor.col > 1
				and char_category(str:byte(cursor.col)) == char_category(str:byte(cursor.col - 1))
			do
				cursor.col -= 1
			end
			cursor.wanted_x = self:find_cursor_x(cursor.col, cursor.row)
		end
		self:merge_cursors()
		undo_group = nil
	end
	

	-- Edition --
	

	local function shift_cursors_after_deletion(start_col, start_row, end_col, end_row)
		-- There's probably a cleverer way to do this,
		-- but at least this is straightforward to follow.
		for cursor in all(cursors) do
			if cursor.row < start_row then
				-- nothing to do
			elseif cursor.row < end_row then
				cursor.col, cursor.row = start_col, start_row
			elseif (cursor.row == end_row) and (cursor.col < start_col) then
				-- nothing to do
			elseif (cursor.row == end_row) and (cursor.col < end_col) then
				cursor.col = start_col
			elseif cursor.row == end_row then
				cursor.col += start_col - end_col
			else
				cursor.row += start_row - end_row
			end
			-- The same with selection anchors
			if not cursor.acol then
				-- no selection
			elseif cursor.arow < start_row then
				-- nothing to do
			elseif cursor.arow < end_row then
				cursor.acol, cursor.arow = start_col, start_row
			elseif (cursor.arow == end_row) and (cursor.acol < start_col) then
				-- nothing to do
			elseif (cursor.arow == end_row) and (cursor.acol < end_col) then
				cursor.acol = start_col
			elseif cursor.arow == end_row then
				cursor.acol += start_col - end_col
			else
				cursor.arow += start_row - end_row
			end
		end
	end
	

	function self:delete_selection()
		local has_deleted = self:number_of_selections() > 0
		if has_deleted then
			self:checkpoint()
			undo_group = nil
		end
		for cursor in all(cursors) do
			if cursor.acol then
				has_deleted = true
				local start_col, start_row, end_col, end_row = selection_range(cursor)
				text[start_row] =
					sub(text[start_row], 1, start_col - 1)
					.. sub(text[end_row], end_col, -1)
				for _ = start_row + 1, end_row do
					table.remove(text, start_row + 1)
					table.remove(highlighted, start_row + 1)
				end
				shift_cursors_after_deletion(start_col, start_row, end_col, end_row)
				cursor.col, cursor.row = start_col, start_row
				cursor.acol, cursor.arow = nil, nil
			end
		end
		return has_deleted
	end
	
	
	function self:insert_text_at(col, row, str)
		if undo_group ~= "insert_text" then
			self:checkpoint()
		end
		undo_group = "insert_text"
		local lines = split(str, "\n", false)
		if #lines == 1 then
			text[row] = sub(text[row], 1, col - 1) .. str .. sub(text[row], col)
			for cursor in all(cursors) do
				if cursor.row == row and cursor.col >= col then
					cursor.col += #str
				end
				cursor.wanted_x = self:find_cursor_x(cursor.col, cursor.row)
				if cursor.arow == row and cursor.acol >= col then
					cursor.acol += #str
				end
			end
			return
		end
		local delta_row = #lines - 1
		local delta_col = - col + 1 + #lines[#lines]
		table.insert(text, row + 1, lines[#lines] .. sub(text[row], col, -1))
		table.insert(highlighted, row + 1, nil)
		text[row] = sub(text[row], 1, col - 1) .. lines[1]
		for i = #lines - 1, 2, -1 do
			table.insert(text, row + 1, lines[i])
			table.insert(highlighted, row + 1, nil)
		end
		for cursor in all(cursors) do
			if cursor.row == row and cursor.col >= col then
				cursor.row += delta_row
				cursor.col += delta_col
			elseif cursor.row > row then
				cursor.row += delta_row
			end
			if not cursor.acol then
				-- do nothing
			elseif cursor.arow == row and cursor.acol >= col then
				cursor.arow += delta_row
				cursor.acol += delta_col
			elseif cursor.arow > row then
				cursor.arow += delta_row
			end
		end
	end
	

	function self:insert(k)
		-- Undo checkpoint, with grouping of inserts
		local group = "insert"
		if k == " " then group = "whitespace" end
		if	
			(group ~= undo_group)
			and not (group == "insert" and undo_group == "whitespace")
		then
			self:checkpoint()
		end
		undo_group = group
		-- Actual edit
		self:delete_selection()
		for cursor in all(cursors) do
			local row, col = cursor.row, cursor.col
			local str = text[row]
			text[row] = sub(str, 1, col - 1) .. k .. sub(str, col)
			self:highlight(row)
			-- Move all impacted cursors
			for cursor in all(cursors) do
				if cursor.row == row and cursor.col >= col then
					cursor.col += #k
					cursor.wanted_x = self:find_cursor_x(cursor.col, cursor.row)
				end
			end
		end
	end
	
	
	local function is_whitespace(byte)
		return (byte == ord(" ")) or (byte == ord("\t"))
	end
	

	local function is_empty_line(str)
		for col = 1, #str do
			if not is_whitespace(str:byte(col)) then
				return false
			end
		end
		return true
	end
	

	local function should_indent_after(str)
		local last_token
		local col = 1
		while (col <= #str) do
			local s, cat
			s, col, cat = tokenoid(str, col)
			if (cat == 1) and (s == "function") then
				return true
			end
			if cat ~= 0 then
				last_token = s
			end
		end
		local indent_tokens <const> = {
			["("] = true, ["["] = true, ["{"] = true, ["="] = true,
			-- TODO: add the myriad assignment operators
			["do"] = true, ["else"] = true, ["elseif"] = true,
			["for"] = true, ["function"] = true, ["goto"] = true, ["if"] = true,
			["local"] = true, ["repeat"] = true, ["return"] = false,
			["then"] = true, ["until"] = true, ["while"] = true,
		}
		return indent_tokens[last_token]
	end


	local function block_closer(str)
		local first_keyword, last_keyword
		local col = 1
		while (col <= #str) do
			local s, cat
			s, col, cat = tokenoid(str, col)
			if cat == 1 then
				if (not first_keyword) or (first_keyword == "local") then
					first_keyword = s
				end
				last_keyword = s
			end
		end
		if (first_keyword == "function") or (last_keyword == "do")
			or (last_keyword == "then") or (last_keyword == "else")
		then
			return "end"
		end
		if last_keyword == "repeat" then
			return "until"
		end
		return nil
	end


	function self:newline(autoindent, autoclose)
		-- Undo checkpoint, with grouping of inserts
		local group = "newline"
		if group ~= undo_group then
			self:checkpoint()
		end
		undo_group = group
		-- Actual edit
		self:delete_selection()
		for cursor in all(cursors) do
			local row, col = cursor.row, cursor.col
			local indentation = ""
			if autoindent then
				local above = row
				while above > 1 and is_empty_line(text[above]) do
					above -= 1
				end
				local c = 1
				while c < #text[above] and is_whitespace(text[above]:byte(c)) do
					indentation ..= text[above][c]
					c += 1
				end
				if should_indent_after(sub(text[row], 1, col - 1)) then
					indentation ..= "\t"
				end
			end
			table.insert(text, row + 1, indentation .. sub(text[row], col, -1))
			table.insert(highlighted, row + 1, nil)
			local delta_row = 1
			if autoclose and col == #text[row] + 1 then
				local closer = block_closer(text[row])
				if closer then
					table.insert(text, row + 2, sub(indentation, 2, -1) .. closer)
					table.insert(highlighted, row + 2, nil)
					delta_row = 2
				end
			end
			text[row] = sub(text[row], 1, col - 1)
			local delta_col = #indentation - #text[row]
			-- Move all impacted cursors
			for cursor in all(cursors) do
				if cursor.row == row and cursor.col == col then
					-- The insertion cursor always move 1 row, even when autoclose
					cursor.row += 1
					cursor.col += delta_col
					cursor.wanted_x = self:find_cursor_x(cursor.col, cursor.row)
				elseif cursor.row == row and cursor.col >= col then
					cursor.row += delta_row
					cursor.col += delta_col
					cursor.wanted_x = self:find_cursor_x(cursor.col, cursor.row)
				elseif cursor.row > row then
					cursor.row += delta_row
				end
			end
		end
	end
	

	function self:tab(reverse)
		-- Undo checkpoint, with grouping of inserts
		-- TODO: should only indent if there is a multi-line selection!
		local has_selection = self:number_of_selections() >= 1
		local group = has_selection and "indent" or "whitespace"
		if group ~= undo_group then
			self:checkpoint()
		end
		undo_group = group
		if has_selection then
			-- Indent or deindent
			local delta_col = 0
			self:foreach_selection(
				function(scol, srow, ecol, erow)
					if ecol == 1 then
						erow -= 1
					end
					for row = srow, erow do
						if reverse then
							if text[row][1] == "\t" then
								text[row] = sub(text[row], 2, -1)
								delta_col = -1
							end
						else
							text[row] = "\t" .. text[row]
							delta_col = 1
						end
					end
					-- Move all impacted cursors
					for cursor in all(cursors) do
						if srow <= cursor.row and cursor.row <= erow
							and cursor.col ~= 1
						then
							cursor.col = mid(1, cursor.col + delta_col, #text[cursor.row])
						end
						if srow <= cursor.arow and cursor.arow <= erow
							and cursor.acol ~= 1
						then
							cursor.acol = mid(1, cursor.acol + delta_col, #text[cursor.arow])
						end
					end
				end
			)
			return
		end
		-- Actual edit
		self:delete_selection()
		for cursor in all(cursors) do
			local row, col = cursor.row, cursor.col
			local str = text[row]
			text[row] = sub(str, 1, col - 1) .. "\t" .. sub(str, col)
			-- Move all impacted cursors
			for cursor in all(cursors) do
				if cursor.row == row and cursor.col >= col then
					cursor.col += 1
					cursor.wanted_x = self:find_cursor_x(cursor.col, cursor.row)
				end
			end
		end
	end
	

	function self:backspace()
		-- Undo checkpoint, with grouping of inserts
		local group = "backspace"
		if group ~= undo_group then
			self:checkpoint()
		end
		undo_group = group
		-- Actual edit
		if self:delete_selection() then
			return
		end
		for cursor in all(cursors) do
			local row, col = cursor.row, cursor.col
			if col == 1 and row > 1 then
				-- join with previous line
				undo_group = nil
				delta_col = #text[row - 1]
				text[row - 1] = text[row - 1] .. text[row]
				table.remove(text, row)
				table.remove(highlighted, row)
				-- Move all impacted cursors
				for cursor in all(cursors) do
					if cursor.row == row then
						cursor.col += delta_col
						cursor.row -= 1
					elseif cursor.row > row then
						cursor.row -= 1
					end
				end
			elseif col > 1 then
				local str = text[row]
				text[row] = sub(str, 1, col - 2) .. sub(str, col)
				-- Move all impacted cursors
				for cursor in all(cursors) do
					if cursor.row == row and cursor.col >= col then
						cursor.col -= 1
						cursor.wanted_x = self:find_cursor_x(cursor.col, cursor.row)
					end
				end
			end
		end
	end
	

	function self:delete()
		-- Undo checkpoint, with grouping of inserts
		local group = "delete"
		if group ~= undo_group then
			self:checkpoint()
		end
		undo_group = group
		-- Actual edit
		if self:delete_selection() then
			return
		end
		for cursor in all(cursors) do
			local row, col = cursor.row, cursor.col
			if col == #text[row] + 1 and row < #text then
				-- Join with next line
				undo_group = nil
				delta_col = #text[row]
				text[row] = text[row] .. text[row + 1]
				table.remove(text, row + 1)
				table.remove(highlighted, row + 1)
				-- Move all impacted cursors
				for cursor in all(cursors) do
					if cursor.row == row + 1 then
						cursor.col += delta_col
						cursor.row -= 1
					elseif cursor.row > row + 1 then
						cursor.row -= 1
					end
				end
			elseif col <= #text[row] then
				local str = text[row]
				text[row] = sub(str, 1, col - 1) .. sub(str, col + 1)
				-- Move all impacted cursors
				for cursor in all(cursors) do
					if cursor.row == row and cursor.col > col then
						cursor.col -= 1
						cursor.wanted_x = self:find_cursor_x(cursor.col, cursor.row)
					end
				end
			end
		end
	end


	return self
end


-------------------------------------------------------------------------------------------


return {
	init = init,
	new = new,
}
:: src/config.lua
--[[pod_format="raw",created="2025-03-31 13:04:42",modified="2025-04-01 20:24:10",revision=656]]
----------------------------------------------------------------------------------------


local M = {}


----------------------------------------------------------------------------------------


M.theme = {}
M.shortcuts = {}
M.settings = {}


----------------------------------------------------------------------------------------


local safe_env = {
	-- Standard Lua functions
	assert = assert,
	collectgarbage = collectgarbage,
	error = error,
	getmetatable = getmetatable,
	ipairs = ipairs,
	load = load,
	loadfile = loadfile,
	next = next,
	pairs = pairs,
	pcall = pcall,
	rawequal = rawequal,
	rawget = rawget,
	rawlen = rawlen,
	rawset = rawset,
	select = select,
	setmetatable = setmetatable,
	tonumber = tonumber,
	tostring = tostring,
	type = type,
	-- Standard Lua modules
	coroutine = coroutine,
	math = math,
	string = string,
	table = table,
	utf8 = utf8,
	-- Picotron's Lua functions
	env = env,
	printh = printh,
	-- Picotron's input functions
	btn = btn,
	btnp = btnp,
	key = key,
	keyp = keyp,
	peektext = peektext,
	readtext = readtext,
	mouse = mouse,
	mouselock = mouselock,
	-- Picotron's string functions
	chr = chr,
	ord = ord,
	sub = sub,
	split = split,
	create_delta = create_delta,
	apply_delta = apply_delta,
	-- Picotron's table functions
	add = add,
	del = del,
	deli = deli,
	count = count,
	all = all,
	foreach = foreach,
	-- Picotron's pod functions
	pod = pod,
	unpod = unpod,
	-- Picotron's files functions
	store = store,
	fetch = fetch,
	store_metadata = store_metadata,
	fetch_metadata = fetch_metadata,
	mkdir = mkdir,
	ls = ls,
	cp = cp,
	mv = mv,
	rm = rm,
	pwd = pwd,
	fullpath = fullpath,
	fstat = fstat,
	include = include,
	-- Picotron's system functions
	printh = printh,
	env = env,
	stop = stop,
	time = time,
	date = date,
	get_clipboard = get_clipboard,
	set_clipboard = set_clipboard,
	stat = stat,
	-- Picotron's memory functions
	peek = peek,
	poke = poke,
	peek2 = peek2,
	poke2 = poke2,
	peek4 = peek4,
	poke4 = poke4,
	peek8 = peek8,
	poke8 = poke8,
	memcpy = memcpy,
	memset = memset,
	-- Picotron's userdata functions
	userdata = userdata,
	vec = vec,
	memmap = memmap,
	unmap = unmap,
}


----------------------------------------------------------------------------------------


local function load_config_file(path, t)
	log("loading " .. pod(path))
	local is_default = (t == nil)
	local t = t or {}
	if (not is_default) and (not fstat(path)) then
		-- User configuration files may not exist.
		return t
	end
	local fun, err = load_file(path, safe_env)
	if not fun then
		send_message(3, { event = "report_error", content = "*loading error in configuration file " .. pod(path) .. ":" })
		send_message(3, { event = "report_error", content = tostring(err) })
		return t
	end
	local cofun = cocreate(fun)
	local success, tt = coresume(cofun)
	if not success then
		send_message(3, { event = "report_error", content = "*runtime error in configuration file " .. pod(path) .. ":" })
		send_message(3, { event = "report_error", content = tostring(tt) })
		return
	end
	log("type="..type(tt))
	if type(tt) ~= "table" then
		send_message(3, { event = "report_error", content = "*runtime error in configuration file " .. pod(path) .. ":" })
		send_message(3, { event = "report_error", content = "config file did not return a table" })
		return
	end
	for k, v in pairs(tt) do
		t[k] = v
	end
	return t
end


function M.init()
	setmetatable(safe_env, {
		__index =
			function(k)
				send_error("unknown global: " .. tostring(k))
			end,
	})
	M.theme = load_config_file("defaults/theme.lua")
	load_config_file("/appdata/codron/theme.lua", M.theme)
	log("theme.sidebar_bg="..pod(M.theme.sidebar_bg))
end


----------------------------------------------------------------------------------------


return M


----------------------------------------------------------------------------------------

:: src/filetree.lua
--[[pod_format="raw",created="2025-03-29 16:06:07",modified="2025-04-01 20:24:10",revision=1694]]
-------------------------------------------------------------------------------------------


local buffers = require "src/buffers.lua"


-------------------------------------------------------------------------------------------


local root


-------------------------------------------------------------------------------------------


local function find_main(path)
	while path ~= "" do
		local kind = fstat(path)
		if kind == "file" and sub(path, -9, -1) == "/main.lua" then
			log([[found main "]] .. path .. [["]])
			return path
		end
		if kind == "file" then
			path = parent_folder(path)
		end
		--log([[searching for main.lua in "]]..path..[["]])
		local maybe_main = path.."/main.lua"
		if fstat(maybe_main) == "file" then
			log([[found main "]] .. maybe_main .. [["]])
			return maybe_main
		end
		path = parent_folder(path)
	end
	return nil
end


-------------------------------------------------------------------------------------------


local function sort(a, func)
	-- TODO: something better...
	for i = 1, #a do
		local j = i
		while j > 1 and func(a[j - 1], a[j]) do
			a[j] , a[j - 1] = a[j - 1] , a[j]
			j = j - 1
		end
	end
end


local function compare(a, b)
	return a:path() > b:path()
end


-------------------------------------------------------------------------------------------


local function new_file(path, buffer, metadata)
	local self = {}
	
	-- Private fields
	local path = path or ""
	local buffer = buffer or buffers.new("(empty)")
	local metadata = metadata or {}
	local is_on_disk = true
	local stale = false
	
	function self:is_folder() return false end
	function self:is_file() return true end
	function self:path() return path end
	function self:buffer() return buffer end
	function self:metadata() return metadata end
		
	function self:folder_path()
		return parent_folder(path)
	end
	
	function self:is_stale()
		return stale
	end
	
	function self:mark_stale()
		stale = true
	end
	
	function self:is_on_disk()
		return is_on_disk
	end
	
	function self:mark_is_on_disk()
		is_on_disk = true
	end
	
	function self:unmark_is_on_disk()
		is_on_disk = false
	end
	
	function self:save_all()
		local full_text = self:buffer():full_text_copy()
		--log("filetree.file.save_all: saving " .. pod(self:path()))
		-- TODO: stale file detection
		local new_metadata = fetch_metadata(self:path())
		if new_metadata and metadata.revision and new_metadata.revision
			and metadata.revision < new_metadata.revision
		then
			stale = true
			log("not saved because newer revision on disk: " .. pod(path))
			notify(pod(path) .. ": skipped saving over external changes") -- TODO
			return
		end
		local err = store(self:path(), full_text, metadata)
		metadata = fetch_metadata(self:path())
		if err then
			notify(err)
		else
			stale = false
		end
	end
	
	function self:save_as(new_path)
		local full_text = self:buffer():full_text_copy()
		local err = store(new_path, full_text, metadata)
		metadata = fetch_metadata(new_path)
		if err then
			notify(err)
			return err
		end
		path = new_path
		stale = false
		return nil
	end
	
	function self:foreach(fun, level)
		local found = fun(self, level or 0)
		if found then
			return found
		end
	end
	
	return self
end


-------------------------------------------------------------------------------------------


local function new_folder(path)
	local self = {}
	
	-- Private fields
	local path = path
	local children = {}
	local is_on_disk = false
	
	function self:is_folder() return true end
	function self:is_file() return false end
	function self:path() return path end
		
	function self:folder_path()
		return path
	end
	
	function self:add(node)
		if not node then return end
		if node:is_folder() and node:is_empty() then
			return
		end
		table.insert(children, node)
	end
	
	function self:child(path)
		for child in all(children) do
			if path == child:path() then
				return child
			end
		end
	end
	
	function self:sort()
		sort(children,
			function(a, b)
				if a:is_folder() and b:is_file() then
					return false
				elseif a:is_file() and b:is_folder() then
					return true
				end
				return a:path() > b:path()
			end)
	end
	
	function self:is_empty()
		return #children == 0
	end
	
	function self:is_on_disk()
		return is_on_disk
	end
	
	function self:mark_is_on_disk()
		is_on_disk = true
	end
	
	function self:unmark_is_on_disk()
		is_on_disk = false
		for child in all(children) do
			child:unmark_is_on_disk()
		end
	end
	
	function self:save_all()
		if self == root then
			log("filetree.root: saving all " .. pod(path))
		end
		for child in all(children) do
			child:save_all()
		end
	end

	function self:foreach(fun, level)
		local level = level or 0
		local found = fun(self, level)
		if found then
			return found
		end
		level += 1
		for node in all(children) do
			found = node:foreach(fun, level)
			if found then
				return found
			end
		end
	end
	
	return self
end


-------------------------------------------------------------------------------------------


local function scan(path)
	local kind = fstat(path)
	if kind == "file" then
		local ext = path:ext()
		if ext == "lua" or ext == "txt" or ext == "md" then
			local text, metadata = fetch(path)
			local buffer = buffers.new(text)
			return new_file(path, buffer, metadata)
		end
		return nil
	elseif kind == "folder" then
		local folder = new_folder(path)
		local folder_content = ls(path)
		for name in all(folder_content) do
			folder:add(scan(path .. "/" .. name))
			folder:sort()
		end
		return folder
	else
		send_error("fileset.scan: unexpected fstat result: path=" .. pod(path) .. " fstat=" .. pod(kind))
	end
end


local function create(path)
	if root then send_error("fileset.create: root already created") end
	root = scan(path)
end


-------------------------------------------------------------------------------------------


local function refresh()
	if not root then send_error("fileset.create: no root created") end
	
	local function check(node)
		--log("checking node " .. pod(node:path()))
		if node:is_file() then
			-- TODO: compare metadata
			-- and mark for existence
			local new_metadata = fetch_metadata(node:path())
			--log("metadata="..pod(node:metadata()).." new_metadata="..pod(new_metadata))
			if node:metadata().revision and new_metadata.revision 
				and node:metadata().revision < new_metadata.revision
			then
				log("refresh: " .. pod(node:path()) .. " is stale")
				node:mark_stale()
			end
			node:mark_is_on_disk()
			return
		elseif node:is_folder() then
			local folder_content = ls(node:path())
			for name in all(folder_content) do
				local path = node:path() .. "/" .. name
				local child = node:child(path)
				if child then
					check(child)
				else
					node:add(scan(path))
					node:sort()
				end
			end
			node:mark_is_on_disk() -- TODO: only if it contains child file on disk?
			return
		else
			send_error("fileset.refresh: unexpected fstat result: " .. pod(kind))
		end
	end

	root:unmark_is_on_disk()
	check(root)
end


-------------------------------------------------------------------------------------------


local function root_node()
	return root
end


-------------------------------------------------------------------------------------------


local function foreach_node(fun)
	root:foreach(fun, 0)
end


-------------------------------------------------------------------------------------------


local function find(path)
	local found = root:foreach(
		function(node)
			if node:path() == path then
				return node
			end
		end
	)
	if found then
		return found
	end
end


-------------------------------------------------------------------------------------------


local function save_all()
	root:save_all()
	
	if root:is_file() then
		notify("saved " .. root:path())
	elseif root:folder_path():sub(1, 7) == "/system" then
		notify("saved all files in " .. root:path() .. " ** warning: changes to /system/ not written to disk **")
	elseif root:is_folder() and root:path():sub(1, 9) ~= "/ram/cart" then
		notify("saved all files in " .. root:path())
	end
end


-------------------------------------------------------------------------------------------


local function printh_nodes()
	local str = "filetree:\n"
	root:foreach(
		function(node, level)
			for i = 1, level do str ..= "|   " end
			if node:is_folder() then
				str ..= node:path():basename() .. "/\n"
			elseif node:is_file() then
				str ..= node:path():basename() .. "\n"
			else
				str ..= "(unknown node))\n"
			end
		end
	)
	printh(str)
end


-------------------------------------------------------------------------------------------


return {
	find_main = find_main,
	create = create,
	refresh = refresh,
	root = root_node,
	foreach = foreach_node,
	find = find,
	save_all = save_all,
	printh = printh_nodes,
}


-------------------------------------------------------------------------------------------

:: src/ui.lua
--[[pod_format="raw",created="2025-03-23 10:43:59",modified="2025-04-01 20:24:10",revision=4162]]
----------------------------------------------------------------------------------------


local head = require "src/ui/head.lua"


----------------------------------------------------------------------------------------


return {
	head = head.head,
	init = head.init,
	draw = head.draw,
	update = head.update,
	editor = require "src/ui/editor.lua",
	sidebar = require "src/ui/sidebar.lua",
}

:: src/utils.lua
--[[pod_format="raw",created="2025-03-19 09:08:58",modified="2025-04-01 20:24:10",revision=4104]]
--------------------------------------------------------------------------------------------


function log(str)
	local path = debug.getinfo(2).source
	if path[1] == "@" then path = path:sub(2, -1) end
	local line = debug.getinfo(2).currentline
	printh(path .. ":" .. line .. ": " .. (str or ""))
end
--function log(_str) end


---------------------------------------------------------------------------------------------


_modules = {}


-- A 'require' function similar to standard Lua.
-- Idea from elgopher on the BBS
function require(name)
	if (_modules == nil) _modules = {}

	local cached = _modules[name]
	if (cached) return cached

	local filename = fullpath(name)
	local src = fetch(filename) 
	if (type(src) != "string") panic("could not include " .. filename)

	-- https://www.lua.org/manual/5.4/manual.html#pdf-load
	-- chunk name (for error reporting)
	-- mode ("t" for text only -- no binary chunk loading)
	-- _ENV upvalue
	-- @ is a special character that tells debugger the string is a filename
	local func, err = load(src, "@" .. filename, "t", _ENV)
	if (not func) panic("Syntax error:", tostr(err))

	local module = func()
	_modules[name] = module

	return module
end


--------------------------------------------------------------------------------------------


function load_file(path, env)
	local path = fullpath(path)
	local src = fetch(path)
	if type(src) != "string" then
		return nil, "could not load file " .. pod(path)
	end

	-- https://www.lua.org/manual/5.4/manual.html#pdf-load
	-- chunk name (for error reporting)
	-- mode ("t" for text only -- no binary chunk loading)
	-- _ENV upvalue
	-- @ is a special character that tells debugger the string is a filename
	local func, err = load(src, "@" .. path, "t", env)

	return func, err
end


--------------------------------------------------------------------------------------------


function send_error(...)
	send_message(3, { event = "report_error", content = "*Error:" })
	
	local path = debug.getinfo(3).source
	local line = debug.getinfo(3).currentline
	local str = sub(path, 2) .. ":" .. string.format("%d", line) .. ":\n"

	local args = { ... }
	str ..= table.concat(args, "\n")
	send_message(3, { event = "report_error", content = str })
end


function panic(...)
	send_message(3, { event = "report_error", content = "*Fatal error:" })
	
	local path = debug.getinfo(3).source
	local line = debug.getinfo(3).currentline
	local str = sub(path, 2) .. ":" .. string.format("%d", line) .. ":\n"

	local args = { ... }
	str ..= table.concat(args, "\n")
	send_message(3, { event = "report_error", content = str })

	stop()
end


--------------------------------------------------------------------------------------------


-- TODO: should probably be in a module
function parent_folder(path)
	local segments = split(path, "/", false)
	return table.concat(segments, "/", 1, #segments - 1)
end


--------------------------------------------------------------------------------------------

:: src/workspace.lua
--[[pod_format="raw",created="2025-03-23 16:21:54",modified="2025-04-01 20:24:10",revision=5230]]
-------------------------------------------------------------------------------------------


local buffers = require "src/buffers.lua"


-------------------------------------------------------------------------------------------


local location
local filetree
local fileset
local current
local fake_buffer = buffers.new("(pseudo buffer)")


-------------------------------------------------------------------------------------------


function open(path)
	path = fullpath(path)
	-- TODO: something with hloc?
	local parts = split(path, "#", false)
	path = parts[1]
	local row = tonumber(parts[2])
	location = find_main(path)
	if location then
		local folder = parent_folder(location)
		cd(folder) -- is this useful?
		log([[creating filetree folder="]]..folder..[[" location="]]..location..[[" path="]]..path..[["]])
		filetree = scan_folder(fullpath(folder))
	else
		location = path
		log([[creating filetree single-file path="]] .. path .. [[" location="]] .. location .. [["]])
		filetree = scan_folder(fullpath(path))
	end
	fetch_buffers()
	set_current_path(path)
--	if current.buffer and row then
--		current.buffer:center_on(1, row)
--	end
--[[	window {
		title = filetree.name .. (filetree.children and "/" or ""),
		location = location,
		unique_location = true
	}]]
end


function parent_folder(path)
	local segments = split(path, "/", false)
	return table.concat(segments, "/", 1, #segments - 1)
end


function find_main(path)
	while path ~= "" do
		local kind = fstat(path)
		if kind == "file" and sub(path, -9, -1) == "/main.lua" then
			log([[found main "]] .. path .. [["]])
			return path
		end
		if kind == "file" then
			path = parent_folder(path)
		end
		--log([[searching for main.lua in "]]..path..[["]])
		local maybe_main = path.."/main.lua"
		if fstat(maybe_main) == "file" then
			log([[found main "]] .. maybe_main .. [["]])
			return maybe_main
		end
		path = parent_folder(path)
	end
	return nil
end


function scan_folder(root_path)
	local segs = split(root_path, "/", false)
	local root_name = segs[#segs]
	local kind = fstat(root_path)
	if kind == "folder" then
		local children = {}
		local names = ls(root_path)
		sort(names)
		for name in all(names) do
			local child = scan_folder(root_path .. "/" .. name)
			if child then
				add(children, child)
			end
		end
		if #children == 0 then
			-- TODO: what about newly created folders?
			return nil
		end
		return {
			name = root_name,
			path = root_path,
			children = children,
		}
	elseif kind == "file" then
		local ext = root_path:ext()
		if ext ~= "lua" and ext ~= "txt" and ext ~= "md" then
			return nil
		end
--		local buffer, metadata = buffers.new(fetch(root_path))
--		if not buffer then return nil end
		return {
			name = root_name,
			path = root_path,
--			buffer = buffer,
--			metadata = metadata,
		}
	else
		notify("*** error while creating the filetree: unknown fstat result")
	end
	return nil
end


function sort(a)
	-- TODO: something better...
	for i = 1, #a do
		local j = i
		while j > 1 and a[j - 1] > a[j] do
			a[j] , a[j - 1] = a[j - 1] , a[j]
			j = j - 1
		end
	end
end


-------------------------------------------------------------------------------------------


function refresh()
	local new_tree = scan_folder(filetree.path)
	local new_nodes = {}
	for node, _ in nodes(new_tree) do
		new_nodes[node.path] = node
	end
	for node, _ in nodes() do
		if new_nodes[node.path] then
			-- TODO: check if file modified
			new_nodes[node.path] = nil
		else
			-- TODO: file has been deleted
		end
	end
	for _, new_node in pairs(new_nodes) do
		new_node.buffer, new_node.metadata = buffers.new(fetch(node.path))
		
	end
	--[[
	local old_nodes = {}
	for node, _ in nodes() do
		old_nodes[node.path] = node
	end
	filetree = scan_folder(filetree.path)
	for node, _ in nodes() do
		if old_nodes[node.path] then
			node.buffer = old_nodes[node.path].buffer
			node.metadata = old_nodes[node.path].metadata
		else
			node.buffer, node.metadata = buffers.new(node.path, fetch(node.path))
		end
	end
	]]--
end


--------------------------------------------------------------------------------


function merge_trees(old, new)
	for old_child in all(old.children) do
		
	end
end


--------------------------------------------------------------------------------


function switch_to(path, sender)
	-- TODO: hloc
	path = fullpath(path)
	local parts = split(path, "#", false)
	local path = parts[1]
	local row = tonumber(parts[2])
	if not filetree.children then
		if path == filetree.path then
			log([[switch_to: *found* single-file (path="]]..path..[[" folder="]]..filetree.path..[[")]])
		else
			log([[switch_to: not this single-file (path="]]..path..[[" folder="]]..filetree.path..[[")]])
		end
		return
	end
	if sub(path, 1, #filetree.path) ~= filetree.path then
		log([[switch_to: not in filetree folder (path="]]..path..[[" folder="]]..filetree.path..[[")]])
		return
	end
	log([[switch_to: path belongs to filetree folder (path="]]..path..[[" folder="]]..filetree.path..[[")]])
	local found = set_current_path(path)
	if found then
		log([[switch_to: *found* in filetree folder (path="]]..path..[[" folder="]]..filetree.path..[[")]])
--		if row then
--			log("switch_to: showing row "..row)
--			current.buffer:center_on(1, row) -- TODO: set cursor instead
--		end
		return
	end
	log([[switch_to: *new file* in filetree folder (path="]]..path..[[" folder="]]..filetree.path..[[")]])
	log("sending kill_process message to [" .. string.format("%03d", sender) .. "]")
	send_message(2, { event = "kill_process", proc_id = sender, exit_code = 0 })
end


-------------------------------------------------------------------------------------------


function fetch_buffers()
	local err
	for node, _ in nodes() do
		if not node.children then
			local text, metadata = fetch(node.path)
			node.buffer = buffers.new(text)
			node.metadata = metadata
			if not node.buffer then
				-- TODO: try to find what happened...
				-- maybe the file was deleted?
				err = err or "???"
			end
		end
	end
	return err	
end


-------------------------------------------------------------------------------------------


function save_all()
	foreach_(
		function(node, _level)
			if node and (not node.children) then
				local full_text = node.buffer:full_text_copy()
				--log([[saving "]]..node.path..[["]])
				-- TODO: stale file detection
				local err = store(node.path, full_text, {})
				-- TODO: stuff with hloc???
				node.metadata = fetch_metadata(node.path)
				if err then
					notify(err)
				end
			end
		end
	)

	if (sub(location, 1, 10) ~= "/ram/cart/") then
		local str
		if filetree.children then
			str = "saved all files in " .. filetree.path
		else
			str = "saved " .. filetree.path
		end
		if location:sub(1, 8) == "/system/" then
			notify(str .. " ** warning: changes to /system/ not written to disk **")
		else
			notify(str)
		end
	end
end


---------------------------------------------------------------------------------------


-- TODO: remove, use the iterator instead
function foreach_(func)
	if not filetree.children then
		func(filetree, 1)
		return
	end
	
	local function step(node, func, level)
		func(node, level)
		for child in all(node.children) do
			step(child, func, level + 1)
		end
	end

	step(filetree, func, 0)
end


-- Iterator on all filetree nodes:
-- `for node, level in nodes() do ... end`
function nodes(tree)
	local stack = { tree or filetree }
	local levels = { 0 }
	return function()
		if #stack == 0 then
			return nil
		end
		local node = table.remove(stack)
		local level = table.remove(levels)
		if node.children then
			for i = #node.children, 1, -1 do
				table.insert(stack, node.children[i])
				table.insert(levels, level + 1)
			end
		end
		return node, level
	end
end


-------------------------------------------------------------------------------------------


function current_node()
	return current
end


function current_path()
	if current then
		return current.path
	end
	return nil
end


function current_buffer()
	if current then
		return current.buffer or fake_buffer
	end
	return fake_buffer
end


function set_current(row)
	local node = find_row(row)
	if node and (not node.children) then
		current = node
	end
end


function set_current_path(path)
	-- TODO: check if file modified on disk?
	-- TODO: unsaved status?
	local found = nil
	foreach_(
		function(node, _level)
			if (not found) and (node.path == path) then
				found = node
			end
		end
	)
	if found then
		log([[set_current_path "]] .. path .. [["]])
		current = found
		return true
	end
	return false
end


-------------------------------------------------------------------------------------------


function find_row(target)
	local function step(node, current_row, target)
		if current_row == target then
			return node
		end
		current_row += 1
		for child in all(node.children) do
			local result, new_row = step(child, current_row, target)
			if result then
				return result, nil
			end
			current_row = new_row
		end
		return nil, current_row
	end
	return step(filetree, 0, target)
end


-------------------------------------------------------------------------------------------


function print_filetree()
	local str = "filetree:\n"
	for node, level in nodes() do
		for i = 1, level do str ..= "|   " end
		if node.children then
			str ..= node.name .. "\n"
		else
			str ..= node.name .. "\n"
		end		
	end
	printh(str)
end


-------------------------------------------------------------------------------------------


return {
	open = open,
	save_all = save_all,
	switch_to = switch_to,
	refresh = refresh,
	nodes = nodes,
	foreach = foreach_,
	current_node = current_node,
	current_path = current_path,
	current_buffer = current_buffer,
	set_current = set_current,
	find_row = find_row,
	print = print_filetree,
}


-------------------------------------------------------------------------------------------

:: src/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTIyIDE4OjIwOjExIixtb2RpZmllZD0iMjAyNS0w
NC0wMSAyMDoyNDoxMSJdXQ==
:: label.qoi
b64$cW9pZgAAAeAAAAEOBAH_--Ho-f39-f39-f3T-rkAPvI-wf6iiHnMP-39-f39-cUSxD-X-rkA
Pss-Esw-EsM-EtE--qKIec4--f39-cwSwD-AEsA-xxLBP8ASwT-LEsE-yBLEP8YSxj-JEj8SP90S
xT-GEsU-x-65AD7LPxLMPxLCP8ASwj8SzD-_ooh5zj-9-f39yxLAP8ISwD-GEsE-wBLBP8YSwj8S
wT-IEj-CEj-GEsY-yhI-yf65AD7BP8ASwT-P-qKIeT8SP9b_uQA_yj-CEsA-wBLBP8ESP8ISwT8S
wj8SzD-_ooh5zj-9-f39yxLAP8ISwD-GEsE-wBLBP8YSwj8SwT-IEj-CEj-GEsY-xhLHP8X_uQA_
wD-CEsA-y-6iiHnBPxLBP8YSxT-H-rkAPss-EsE-EsA-Ej8Swz8Swz8SwT8SzT-_ooh5xj8SxT-9
-f39yxLAP8ISwD-GEsY-xhLCP8wSP8ISP8YSxj-GEsA-wxLAP8X_uQA_wD-CEsA-y-6iiHk-Ej-a
-rkAPss-EsE-whLAP8ASwT8Swz8SwT8SzT-_ooh5xT-BEsQ--f39-csSwD-CEsA-xhI-EsI-Ej-G
EsU-yRI-wBLBP9YSwD-DEsA-xf65AD7AP8ISwD-L-qKIecU-xhLFP8f_uQA_yz8SwT8SxT8SwD8S
wz8SwD8Szj-_ooh5xj8SxT-9-f39yxLAP8ISwD-GEj8Swj8SP8YSxT-HEsE-wBLBP8YSxj-GEsA-
wxLAP8X_uQA_wD-CEsA-zP6iiHnEP9b_uQA_zD-AEsA-wRI-wRLCP8ASwD-BEj8Szj-_ooh5zj-9
-f39zBLAP8ASwD-HEsY-xhLFP8cSwT-LEsA-whLAP8YSxz-F-rkAPsE-wBLBP_oS9D-_ooh5zj-9
-f39-f3j-rkAPvQ--qKIec4--f39-f39-oN2nPr_ZUaI0f4dK1P9-f39-f3U-sLDx8UQ_jrRKP39
-f39-dQ7xRD6OtEo-f39-f391DvFEO4owhDGOtEo-f39-f391DvFEMIowRAoEOUoEMAowBDFOtEo
wzsoyjvAKMk7KMk7KDsowzsoyTso0TvAKMs7KDso-f39-es7xRDDKMAQwCgQyCjBECgQwSgQ0SgQ
wCgQKBDEOtEo0TsoyTsoyTsoOyjDOyjJOyjSOyjLOyg7KP39-f3rO8UQwigQKBDBKBDHKBAoECgQ
wSgQwijDEMgoEMAowhDDOswowDrBKMI7wCjAO8EowTvBKMA7KME7KMA7KMA7wSjAO8AoyzvBKDso
O8AowDvBKDsowDsoO8AoOyjBO8EoxDsowTsowDsowDvBKP39-f3vO8UQwigQwygQxyjBECgQwSgQ
wyjBEMkoEMMoEMM6zSg6wSjDOyjAOyjAOyg7KMM7KME7KMA7KDsowDsoOyjAOyjJOyjAOyg7wCjB
OyjAOyg7KDsowDsoOyg7KDsowDsoxDsowTsowDsoOyjAOyj9-f397zvFEMIoEMMoEMcoECgQKBDB
KBDEKBDKKBDJOs0oOsEowzsowDsowDsoOyjDOyjBOyjAOyg7KMA7KDvCKMk7KMA7KDsowjsowDso
O8AowTsoOyg7KDsowDsoxDsowTsowDsoOyjAOyj9-f397zvFEMMoEMEoEMgoECgQKMEQKMEQzygQ
wygQwzrNKDrBKMM7KMA7KMA7KDsowzsowTsowDsoOyjAOyg7KMw7KMA7KDsowjsowDsoOyg7KMA7
KME7KDsowDsoxDsowTsowDsoOyjAOyj9-f397zvFEMQowRDlKMIQKMEQwjrMKME6wCjCO8EoOyjA
OyjAO8EowTvAKMA7wSjAO8EowDvBKMo7wSg7KMM7wSg7KMA7KDsowTsowDvBKMA7KMI7wCjAO8Eo
wDvBKP39-f3vO8UQ9CgQwzrRKP39-f39-dQ7xRD6OtEo-f39-f391DvFEPo60Sj9-f39-f3UO8UQ
_jrRKP39-f39-dQ7xRDCKPIQwjrRKMM7KMo7wCjJOyjJOyg7KOk7KMw7KMo7wCjLOyg7KP39-f3J
O8UQ_jrRKNE7KMk7KMk7KDso0Tso1TsozDsoyzsoyzsoOyj9-f39yTvFEPo6zCjBOsAowjvAKMA7
wSjBO8EowDsowTsowDsowDvBKMA7wCjLO8EoOyg7wCjAO8EowTsowTvBKMA7wCjAO8EowTvBKDvC
KMA7wSg7wSjAO8IowDvBKMQ7KME7KMA7KMA7wSj9-f39zTvFEPo6zig6wCjDOyjAOyjAOyg7KMM7
KME7KMA7KDsowDsoOyjAOyjJOyjCO8AowTsowzsowTsowjsowDsoOyjAOyg7KMM7KME7KMA7KDso
wDsowDsowTsoxzsowTsowDsoOyjAOyj9-f39zTvFEPo6zCjBOsAowzsowDsowDsoOyjDOyjBOyjA
Oyg7KMA7KDvCKMo7wCjAOyjCOyjDOyjBOyjCOyjAOyg7KMA7KMA7wCjBOyjBOyjAOyg7KMA7KMA7
KMI7wCjFOyjBOyjAOyg7KMA7KP39-f3NO8UQ_jrMKDrCKMM7KMA7KMA7KDsowzsowTsowDsoOyjA
Oyg7KM87KDsowjsowjsowjsowjsowDsoOyjAOyjCOyjAOyjBOyjAOyg7KMA7KMA7KMQ7KMQ7KME7
KMA7KDsowDso-f39-c07xRDBKMAQwCjBECjBECgQKBDAKMAQwygQwSgQKBAowRDUOswowTrAKMI7
wSg7KMA7KMA7wSjBO8AowDvBKMA7wSjAO8EoyTvBKMA7KMM7wSg7KMM7wSjAO8AowDsowDsoO8Eo
wjvAKMA7wSg7KMA7KME7wCg7wSjBOyjCO8AowDvBKMA7wSj9-f39zTvFEMEoECgQKBDBKBAoECgQ
KBAoEMUoEMEoECgQKBAoENQ60Sj9-f39-f3UO8UQwSgQKBAowBDAKMAQwCgQKBAoEMUoEMEoECgQ
KMEQ1DrRKP39-f39-dQ7xRDBKBAoECgQwSgQKBAoECgQKBAoEMMoEMEoECgQKBAoENQ60Sj9-f39
-f3UO8UQwSjBECjBECjBEMAowBAowRDAKBDAKMEQwCjAECgQKBDUOtEo-f39-f391DvFEPo60SjD
OyjKO8AoyTsoyTsoOyjkOyjDOyjDO8AoyzsoOyj9-f393jvFEPo60SjROyjJOyjJOyg7KNE7KNY7
KMQ7KMs7KDso-f39-d47xRD6OswowTrAKMI7wCjAO8EowTvBKMA7KME7KMA7KMA7wSjAO8AoyzvB
KDsoO8AowDvBKME7KME7wSjAO8EoOyg7wCg7wCjBO8EoxDsowTsowDsowDvBKP39-f3iO8UQ3CgQ
2zrOKDrAKMM7KMA7KMA7KDsowzsowTsowDsoOyjAOyg7KMA7KMk7KMI7wCjBOyjDOyjBOyjCOyjA
Oyg7wCjCOyjAOyjAOyjEOyjBOyjAOyg7KMA7KP39-f3iO8UQwSjAEMAowRDAKMAQKMEQwCjAECjA
EMMoENs6zSjAOsAowzsowDsowDsoOyjDOyjBOyjAOyg7KMA7KDvCKMo7wCjAOyjCOyjDOyjCO8Ao
wDsowDsoOyjDOyjAOyjAOyjEOyjBOyjAOyg7KMA7KP39-f3iO8UQwSgQKBAoEMEoEMIoEMAoEMEo
ECgQwSgQ3DrOKDrAKMM7KMA7KMA7KDsowzsowTsowDsoOyjAOyg7KM87KDsowjsowjsoxTsoOyjA
Oyg7KMM7KMA7KMA7KMQ7KME7KMA7KDsowDso-f39-eI7xRDBKBAoECjAEMAowRDAKBDAKBDBKBAo
EMEoENw6zCjBOsAowjvBKDsowDsowDvBKME7wCjAO8EowDvBKMA7wSjJO8EowDsowzvBKDsowjvB
KME7wSg7KMI7wSjAO8EowDsowjvAKMA7wSjAO8Eo-f39-eI7xRDBKBAoECgQwygQwCgQwCgQKBAo
ECgQwCgQ3TrRKP3MOyj9-f39-cU7xRDBKMEQKMEQKMAQwCjBECjBECgQKBDAKBDdOtEo-co7wCj9
-f39-cY7xRD6OtEo-f39-f391DvFEPo60Sj9-f39-f3UO8UQ_jrRKMM7KMo7wCjJOyjJOyg7KNQ7
KM07KMM7KMM7wCjLOyg7KP39-f3eO8UQ_jrRKNE7KMk7KMk7KDso0TsowDso0zsoxDsoyzsoOyj9
-f393jvFEMgowBAowRAowRAoEMEoEMIowBDDKMEQKBAoECjBEMo6zCg6KDrAKMI7wCjAO8EowTvB
KMA7KME7KMA7KMA7wSjAO8AoyzvBKDsoO8AowDvBKME7KMA7wSjBO8EoOyg7wCg7wCjBO8EoxDso
wTsowDsowDvBKP39-f3iO8UQxygQwSgQKBAoEMEoEMEoEMEoEMYoEMAoECgQwCgQyzrMKDooOsAo
wzsowDsowDsoOyjDOyjBOyjAOyg7KMA7KDsowDsoyTsowjvAKME7KMM7KME7KMA7KDsowDsoO8Ao
wjsowDsowDsoxDsowTsowDsoOyjAOyj9-f394jvFEMcowRAowRAowBDAKBDBKBDBKMEQxCgQwSgQ
wSgQyzrMKME6wCjDOyjAOyjAOyg7KMM7KME7KMA7KDsowDsoO8IoyjvAKMA7KMI7KMM7KME7KMA7
KDsowDsoOyjDOyjAOyjAOyjEOyjBOyjAOyg7KMA7KP39-f3iO8UQySgQKBDBKBDBKBDBKBDDKBDE
KBDAKBAoEMAoEMs6zig6wCjDOyjAOyjAOyg7KMM7KME7KMA7KDsowDsoOyjPOyg7KMI7KMI7KMI7
KMA7KDsowDsoOyjDOyjAOyjAOyjEOyjBOyjAOyg7KMA7KP39-f3iO8UQxyjAEMAoEMEowRAowRAo
wRAowBDBKBDBKBDAKBAoEMAoEMs6zig6wCjCO8EoOyjAOyjAO8EowTvAKMA7wSjAO8EowDvBKMk7
wSjAOyjDO8EoOyjCOyjAOyjAO8EoOyjCO8EowDvBKMA7KMI7wCjAO8EowDvBKP39-f3iO8UQ_jrR
KP3MOyj9-f39-cU7xRD6OtEo-co7wCj9-f39-cY7xRD6OtEo-f39-f391DvFEPo60Sj9-f39-f3U
O8UQwSjAEMAowRAowRAoECgQKMIQwCjBEMMoEMEoECgQKMEQzjrRKMM7KMo7wCjJOyjJOyg7KNo7
KMQ7wCjLOyg7KP39-f3tO8UQwSgQKBAoECgQKBAoECgQKBAoECgQKBAoECgQwygQwSgQKBAoECgQ
zjrRKNE7KMk7KMk7KDso0TsozjsoyzsoOyj9-f397TvFEMEoECgQKMAQwCjBECjAEMAoECgQKBAo
wRDDKBDBKBAoECjBEM46zCjBOsAowjvAKMA7wSjBO8EowDsowTsowDsowDvBKMA7wCjLO8EoOyg7
wCjAO8EowTsowDsowDsoO8AoxTsowTsowDsowDvBKP39-f3xO8UQwSgQKBAoECgQKBAoECgQKBAo
ECgQKBAoECgQwygQwSgQKBAoECgQzjrMKDrCKMM7KMA7KMA7KDsowzsowTsowDsoOyjAOyg7KMA7
KMk7KMI7wCjBOyjDOyjBOyjAOyjAOyjFOyjBOyjAOyg7KMA7KP39-f3xO8UQwSjBECgQKBAoECgQ
KBAoECgQwSgQKBAoEMAoEMAowRDAKMAQKBAoEM46zCjBOsAowzsowDsowDsoOyjDOyjBOyjAOyg7
KMA7KDvCKMo7wCjAOyjCOyjDOyjBOyjAOyjAOyjFOyjBOyjAOyg7KMA7KP39-f3xO8UQ_jrOKDrA
KMM7KMA7KMA7KDsowzsowTsowDsoOyjAOyg7KM87KDsowjsowjsowjsowDsowDsoxTsowTsowDso
OyjAOyj9-f398TvFEPo6zCjBOsAowjvBKDsowDsowDvBKME7wCjAO8EowDvBKMA7wSjJO8EowDso
wzvBKDsowzvBKDvBKMA7KMI7wCjAO8EowDvBKP39-f3xO8UQ_jrRKP39-f39-dQ7xRD6OtEo-f39
-f391DvFEME7whDAO8EQO8EQO8AQxDsQwTsQOxA7wRDWOtEo-f39-f391DvFEME7EDsQOxA7EDsQ
wDsQwDsQOxDDOxDBOxA7EDsQOxDWOtEo-f39-f391DvFEME7EDsQOxA7wRDAOxDAOxA7EMM7EME7
EDsQO8EQ1jrRKMM7KMo7wCjJOyjJOyg7KNQ7wCjMOyjfOyjCOyjOO8AoyzsoOyj9-f3wO8UQwTsQ
OxA7EDsQOxDAOxDAOxA7EMM7EME7EDsQOxA7ENY60SjROyjJOyjJOyg7KNE7KME7KNY7KNU7KNQ7
KMs7KDso-f398DvFEME7EME7EDsQOxA7wRA7EDsQwDsQwDvBEMA7wBA7EDsQ1jrMKDrCKMI7wCjA
O8EowTvBKMA7KME7KMA7KMA7wSjAO8AoyzvBKDsoO8AowDvBKME7KME7KMI7wCjBO8EoO8AowTvB
KME7KME7wSg7KDvAKMA7wCjBO8EoO8IoO8AowTvAKMA7wSjFOyjBOyjAOyjAO8Eo-f399DvFEPo6
zCg6wijDOyjAOyjAOyg7KMM7KME7KMA7KDsowDsoOyjAOyjJOyjCO8AowTsowzsowjsowTsowDso
OyjAOyjAOyjAOyjDOyjBOyjCO8AowTsowDsoOyjAOyjAOyjCOyjAOyjAOyg7KMA7KMQ7KME7KMA7
KDsowDso-f399DvFEPo6zCjBOsAowzsowDsowDsoOyjDOyjBOyjAOyg7KMA7KDvCKMo7wCjAOyjC
OyjDOyjCOyjBOyjAOyg7KMA7KMA7KMA7KMM7KME7KMI7KMI7wig7KMA7KMA7KMI7KMA7KMA7KDso
wDsoxDsowTsowDsoOyjAOyj9-f30O8UQ_jrMKDooOsAowzsowDsowDsoOyjDOyjBOyjAOyg7KMA7
KDsozzsoOyjCOyjCOyjDOyjBOyjAOyg7KMA7KMA7KMA7KMI7KMI7KMI7KMI7KMI7KMA7KMA7KMI7
KMA7KMA7KDsowDsoxDsowTsowDsoOyjAOyj9-f30O8UQ0CgQ5zrMKME6wCjCO8EoOyjAOyjAO8Eo
wTvAKMA7wSjAO8EowDvBKMk7wSjAOyjDO8EoOyjEO8AowDvAKME7wSg7wSjAO8EoOyjDO8EoOyjD
O8EowDvBKME7wCg7wSjAO8AowDsowDsowDsowjvAKMA7wSjAO8Eo-f399DvFEMIowBAowRDAKMAQ
wigQ5zrRKP3ROyj9-f39-cA7xRDBKBDBKBAoECgQwygQ6DrRKP3PO8Ao-f39-f3BO8UQwSjBECjA
EMAoEMMoEOg60Sj9-f39-f3UO8UQwygQKBAoECgQwigQ6TrRKP39-f39-dQ7xRDBKMAQwCgQKBDA
KMAQwCgQ6TrRKMM7KMo7wCjJOyjJOyg7KNQ7wCjMOyjWOyjGOyjDOyjOO8AoyzsoOyj9-f3vO8UQ
_jrRKNE7KMk7KMk7KDso0TsowTso1jsozDsoxjso1TsoyzsoOyj9-f3vO8UQ_jrMKME6wCjCO8Ao
wDvBKME7wSjAOyjBOyjAOyjAO8EowDvAKMs7wSg7KDvAKMA7wSjBOyjBOyjCO8AowTvBKDvAKME7
wSjBOyjAO8AoOyjBO8EoO8IowDvBKDvBKMA7wCjAO8EowTvBKMQ7KME7KMA7KMA7wSj9-f3zO8UQ
_jrOKDrAKMM7KMA7KMA7KDsowzsowTsowDsoOyjAOyg7KMA7KMk7KMI7wCjBOyjDOyjCOyjBOyjA
Oyg7KMA7KMA7KMA7KMM7KME7KDsoOyg7KMA7KMA7KME7KMI7KMA7KMA7KMA7KMA7KDsowDsoxDso
wTsowDsoOyjAOyj9-f3zO8UQ_jrOKDrAKMM7KMA7KMA7KDsowzsowTsowDsoOyjAOyg7wijKO8Ao
wDsowjsowzsowjsowTsowDsoOyjAOyjAOyjAOyjDOyjBOyg7KDsoOyjAOyjAOyjBOyjCOyjAOyjA
OyjAOyjAOyg7KMA7KMQ7KME7KMA7KDsowDso-f398zvFEMgowBDAKMAQKMAQwSjAECjBECjBECjA
EMAowRDAKMAQwygQwSgQxDrOKDrAKMM7KMA7KMA7KDsowzsowTsowDsoOyjAOyg7KM87KDsowjso
wjsowzsowTsowDsoOyjAOyjAOyjAOyjCOyjCOyjBOyg7KMA7KMA7KME7KMI7KMA7KMA7KMA7KMA7
KDsowDsoxDsowTsowDsoOyjAOyj9-f3zO8UQxygQwSgQKBAoECgQKBDCKBDAKBAoECgQKBDAKBDA
KBDFKBDBKBDEOs4oOsAowjvBKDsowDsowDvBKME7wCjAO8EowDvBKMA7wSjJO8EowDsowzvBKDso
xDvAKMA7wCjBO8EoO8EowDvBKDsowjsowTsowDvBKME7wCjAO8EoOyjAOyg7wSg7KMA7KMA7wSjA
OyjCO8AowDvBKMA7wSj9-f3zO8UQxygQwSgQKBAoECgQKMEQwCgQwCjBECgQKBDAKBDAKMEQwygQ
wSgQxDrRKP3ROyjzOyj9-f39yDvFEMcoEMEoECgQKBAoEMEoEMAoEMAoECgQKBAoEMAoEMIoEMMo
EMEoEMQ60Sj9zzvAKPI7wCj9-f39yTvFEMgowBAowBDAKBAoECjAEMEoEMAoECgQKBAoEMAoEMAo
wBDBKBDAKMEQwCgQwzrRKP39-f39-dQ7-v93qMM7EPo60Sj9-f39-f3UO8UQ_jrRKMM7KMo7wCjJ
OyjJOyg7KNQ7wCjMOyjZO8AowTvAKMo7wCjLOyg7KP39-fk7xRD6OtEo0TsoyTsoyTsoOyjROyjB
OyjWOyjQOyjCOyjLOyjLOyg7KP39-fk7xRD6OswowTrAKMI7wCjAO8EowTvBKMA7KME7KMA7KMA7
wSjAO8AoyzvBKDsoO8AowDvBKME7KME7KMI7wCjBO8EoO8AowTvBKME7KME7wSg7wSjBO8AowTso
wjsowjvBKMQ7KME7KMA7KMA7wSj9-f39O8UQyCjAECjBECgQKBDDKBDBKBAoECjBENY6zCg6KDrA
KMM7KMA7KMA7KDsowzsowTsowDsoOyjAOyg7KMA7KMk7KMI7wCjBOyjDOyjCOyjBOyjAOyg7KMA7
KMA7KMA7KMM7KME7KMI7KMA7KDsowDsowDsowjsowTsoxzsowTsowDsoOyjAOyj9-f39O8UQxygQ
wSgQwSgQKBDDKBDBKBAoECgQKBDWOswowTrAKMM7KMA7KMA7KDsowzsowTsowDsoOyjAOyg7wijK
O8AowDsowjsowzsowjsowTsowDsoOyjAOyjAOyjAOyjDOyjCO8AowDsowDsoO8IowDsowjsowjvA
KMU7KME7KMA7KDsowDso-f39-TvFEMcoEMEowBDBKBDEKBDBKBAoECjBENY6zCg6KDrAKMM7KMA7
KMA7KDsowzsowTsowDsoOyjAOyg7KM87KDsowjsowjsowzsowTsowDsoOyjAOyjAOyjAOyjCOyjF
Oyg7KMA7KDsowzsowjsoxDsoxDsowTsowDsoOyjAOyj9-f39O8UQxygQKBAoEMEoECgQwygQwSgQ
KBAoECgQ1jrMKME6wCjCO8EoOyjAOyjAO8EowTvAKMA7wSjAO8EowDvBKMk7wSjAOyjDO8EoOyjE
O8AowDvAKME7wSg7wSjAO8EoOyjCO8EowDvBKME7wSjBO8AowTvAKDvBKME7KMI7wCjAO8EowDvB
KP39-f07xRDHKMEQKBDBKBAoEMAoEMAowRDAKMAQKBAoENY60Sj90Tso0jso-f39-ek7xRD6OtEo
-c87wCjTOyj9-f396TvFEPo60Sj9-f39-f3UO8UQ_jrRKP39-f39-dQ7xRD6OtEowzsoyjvAKMk7
KMk7KDso1DvAKMw7KNo7KM07KM47wCjLOyg7KP39-eo7xRDHKBAoEMAowBAowRAowRAowBDEKBDB
KBAoECjBEM460SjROyjJOyjJOyg7KNE7KME7KNY7KNA7KN87KMs7KDso-f396jvFEMcoECgQKBDB
KBAoEMAoEMAoECgQwygQwSgQKBAoECgQzjrMKME6wCjCO8AowDvBKME7wSjAOyjBOyjAOyjAO8Eo
wDvAKMs7wSg7KDvAKMA7wSjBOyjBOyjCO8AowTvBKDvAKME7wSjBOyjAO8AoOyjBO8AowTvBKDvB
KME7wSg7wSjAO8AowTvBKMA7wSjEOyjBOyjAOyjAO8Eo-f397jvFEMcowRAoEMEowBDBKBDAKBAo
EMMoEMEoECgQKMEQzjrMKDooOsAowzsowDsowDsoOyjDOyjBOyjAOyg7KMA7KDsowDsoyTsowjvA
KME7KMM7KMI7KME7KMA7KDsowDsowDsowDsowzsowTsoOyg7KDsowDsoOyjCOyjAOyg7KMA7KDso
wDsowDsowDsowjsoxzsowTsowDsoOyjAOyj9-f3uO8UQxygQKBAoECgQKBAoEMAoEMAoECgQwygQ
wSgQKBAoECgQzjrMKME6wCjDOyjAOyjAOyg7KMM7KME7KMA7KDsowDsoO8IoyjvAKMA7KMI7KMM7
KMI7KME7KMA7KDsowDsowDsowDsowzsowTsoOyg7KDvCKDsowjsowDsoOyjAOyg7KMA7KMA7KMA7
KMM7wCjFOyjBOyjAOyg7KMA7KP39-e47xRDHKBAoECjBECgQKBAowRAowRDAKBDAKMEQwCjAECgQ
KBDOOs4oOsAowzsowDsowDsoOyjDOyjBOyjAOyg7KMA7KDsozzsoOyjCOyjCOyjDOyjBOyjAOyg7
KMA7KMA7KMA7KMI7KMI7KME7KDsowjsowjsowDsoOyjAOyg7KMA7KMA7KMA7KMU7KMQ7KME7KMA7
KDsowDso-f397jvFEPo6zig6wCjCO8EoOyjAOyjAO8EowTvAKMA7wSjAO8EowDvBKMk7wSjAOyjD
O8EoOyjEO8AowDvAKME7wSg7wSjAO8EoOyjCOyjBOyjAO8EowDvBKDsowDsowDvBKDsowDsoO8Eo
wDvBKDvBKME7KMI7wCjAO8EowDvBKP39-e47xRD6OtEo-dE7KP39-f39wDvFEPo60Sj9zzvAKP39
-f39wTvFEPo60Sj9-f39-f3UO8UQxyjBECjAEMUowBAowRAowhDAKMEQwygQwSgQKBAowRDEOtEo
-f39-f391DvFEMgoEMAoECgQwygQwSgQKBAoECgQKBAoEMUoEMEoECgQKBAoEMQ60SjDOyjKO8Ao
yTsoyTsoOyjbO8AoyDvAKMs7KDso-f39-ec7xRDIKBDAKBAoEMMoEMEowRAoECgQKBAowBDEKBDB
KBAoECjBEMQ60SjROyjJOyjJOyg7KNE7KMY7KMs7KMs7KDso-f39-ec7xRDIKBDAKBAoEMMoECgQ
KBAoECgQKBAoECgQxSgQwSgQKBAoECgQxDrIKMA6wCjBOsAowjvAKMA7wSjBO8EowDsowTsowDso
wDvBKMA7wCjLO8EoOyg7wCjAO8EowTsowTvBKMA7KME7KMA7KMQ7KME7KMA7KMA7wSj9-f396zvF
EMcowRAoECgQKMEQKMEQKBAoECgQwSgQKMEQwCgQwCjBEMAowBAoECgQxDrJKDrAKDooOsAowzso
wDsowDsoOyjDOyjBOyjAOyg7KMA7KDsowDsoyTsowjvAKME7KMM7KME7KMA7KDvCKDsowDsoxDso
wTsowDsoOyjAOyj9-f396zvFEPo6ySg6wCg6KDrAKMM7KMA7KMA7KDsowzsowTsowDsoOyjAOyg7
wijKO8AowDsowjsowzsowTsowDsowDsowjvAKMU7KME7KMA7KDsowDso-f39-es7xRD6OskoOsAo
Oig6wCjDOyjAOyjAOyg7KMM7KME7KMA7KDsowDsoOyjPOyg7KMI7KMI7KMI7KMA7KMA7KME7KMA7
KMQ7KME7KMA7KDsowDso-f39-es7xRD6OsgowToowTrAKMI7wSg7KMA7KMA7wSjBO8AowDvBKMA7
wSjAO8EoyTvBKMA7KMM7wSg7KMM7wSjAOyjBOyjAOyjAOyjCO8AowDvBKMA7wSj9-f396zvFEPo6
0Sj9xzso-f39-f3KO8UQxyjBECjAEMQowhDBKMAQKMAQwCjBEMQowBAowRAoEMY60Sj9xTvAKP39
-f39yzvFEMgoEMAoECgQwygQKBAoECgQKBAoECgQKBDFKBDBKBDBKBDGOtEo-f39-f391DvFEMgo
EMAoECgQwygQKBAoECgQKBAoECgQKMAQxCjBECjAEMAoEMY60Sj9-f39-f3UO8UQyCgQwCgQKBDD
KBAoECgQKBAoECgQKBAoEMcoECgQwSgQxjrRKMM7KMo7wCjJOyjJOyg7KNU7KOM7wCjLOyg7KP39
-f3TO8UQxyjBECgQKBAowRAoEMEoECjAEMAowRAowRAowRAowBDAKMEQKMEQxDrRKNE7KMk7KMk7
KDso0Tso6DsoyzsoOyj9-f390zvFEPo6yCjAOsAowDrBKMI7wCjAO8EowTvBKMA7KME7KMA7KMA7
wSjAO8AoyzvBKDsoO8AowDvBKME7KMA7wCjAO8EoxjvBKMA7wSg7wCg7KME7wCjFOyjBOyjAOyjA
O8Eo-f39-dc7xRD6OskoOsEoOsEowzsowDsowDsoOyjDOyjBOyjAOyg7KMA7KDsowDsoyTsowjvA
KME7KMM7KMI7KMA7KMA7KMQ7KMA7KDsowDsoOyg7KDsoOyjAOyjEOyjBOyjAOyg7KMA7KP39-f3X
O8UQ_jrJKDrBKDrBKMM7KMA7KMA7KDsowzsowTsowDsoOyjAOyg7wijKO8AowDsowjsowzsowjso
wDsowDsoxDsowDsoOyjAOyg7KDsoOyg7wijEOyjBOyjAOyg7KMA7KP39-f3XO8UQ_jrJKDrBKDrB
KMM7KMA7KMA7KDsowzsowTsowDsoOyjAOyg7KM87KDsowjsowjsowzsowDsowDsoxDsowDsoOyjA
Oyg7KME7KDsoxzsowTsowDsoOyjAOyj9-f391zvFEMcowRAowBDEKMEQKMEQKMEQKBDBKMEQKBAo
ECjAEMEowBAoEMQ6yCjBOijBOsAowjvBKDsowDsowDvBKME7wCjAO8EowDvBKMA7wSjJO8EowDso
wzvBKDsowjvBKDsowDsoO8IowDvBKMA7wSg7KME7KMA7wSjAOyjCO8AowDvBKMA7wSj9-f391zvF
EMgoEMAoECgQwygQKBAoECgQKBDBKBDBKBAoECgQKBAoECgQKBDBKBDEOtEo-dU7KP39-f36O8UQ
yCgQwCgQKBDDKMEQKMAQwCjAEMAoEMEowRAoECgQKBAoECgQwSjAEMM60Sj90zvAKP39-f37EM8o
EMAoECgQwygQwSgQKBAoEMEoEMEoECgQKBAoECgQKBAoEMEoEMQ60Sj9-f39-f3UEM4owRAoECgQ
KMEQKBDBKBAoECjBECjBECgQKBDAKMAQKBAoEMAowBAoEMQ60Sj9-f39-f3UEP3DOtEowzsoyjvA
KMk7KMk7KDso1Tso2Dso0zvAKMw7KMI7KM47wCjLOyg7KP39-eAQ-cM60SjROyjJOyjJOyg7KNE7
KNw7KNQ7KMw7KNQ7KMs7KDso-f394BD9wzrIKMA6wCjBOsAowjvAKMA7wSjBO8EowDsowTsowDso
wDvBKMA7wCjLO8EoOyg7wCjAO8EowTsowDvAKMA7wSjFO8AoOyjBO8AowTvBKMA7wCjGO8EowDvA
KME7KMI7wCjBO8EoO8IoO8AowTvAKMA7wSjFOyjBOyjAOyjAO8Eo-f395BD9wzrJKDrCKDrAKMM7
KMA7KMA7KDsowzsowTsowDsoOyjAOyg7KMA7KMk7KMI7wCjBOyjDOyjCOyjAOyjAOyjEOyg7KDso
OyjAOyg7KMA7KDsowDsoxDsowjsowDsowDsowTsowDsoOyjDOyjCOyjAOyjAOyg7KMA7KMQ7KME7
KMA7KDsowDso-f395BDOKMEQKMAQxCjBECjBECjBECgQwSjBECgQKBAowBDBKMAQKBDEOskoOsAo
wTrAKMM7KMA7KMA7KDsowzsowTsowDsoOyjAOyg7wijKO8AowDsowjsowzsowjsowDsowDsoxDso
Oyg7KDsowDsoOyjAOyg7wijFO8AowDvCKMA7KME7wig7KMM7KMI7KMA7KMA7KDsowDsoxDsowTso
wDsoOyjAOyj9-f3kEM8oEMAoECgQwygQKBAoECgQKBDBKBDBKBAoECgQKBAoECgQKBDBKBDEOsko
OsAoOsIowzsowDsowDsoOyjDOyjBOyjAOyg7KMA7KDsozzsoOyjCOyjCOyjDOyjAOyjAOyjEOyjB
Oyg7KMA7KDsowDsoOyjKOyg7KMM7KME7KMI7KMM7KMI7KMA7KMA7KDsowDsoxDsowTsowDsoOyjA
Oyj9-f3kEM8oEMAoECgQwyjBECjAEMAowBDAKBDBKMEQKBAoECgQKBAoEMEowBDDOsgowToowTrA
KMI7wSg7KMA7KMA7wSjBO8AowDvBKMA7wSjAO8EoyTvBKMA7KMM7wSg7KMI7wSg7KMA7KDvCKDso
wTsowDvAKME7wSjAO8EoO8IoO8EowTvBKME7wCjAO8EowDvBKME7wCg7wSjAO8AowDsowDsowDso
wjvAKMA7wSjAO8Eo-f395BDPKBDAKBAoEMMoEMEoECgQKBDBKBDBKBAoECgQKBAoECgQKBDBKBDE
OtEo-f39-f391BDOKMEQKBAoECjBECgQwSgQKBAowRAowRAoECgQwCjAECgQKBDAKMAQKBDEOtEo
-f39-f391BD9wzrRKP39-f39-dQQ-cM60Sj9-f39-f3UEP3DOtEowzsoyjvAKMk7KMk7KDso1Tso
2TvAKNU7KNQ7KOE7wCjLOyg7KP39-ccQ5SgQ2TrRKNE7KMk7KMk7KDso0Tso3jso1Tso1Dso4jso
yzsoOyj9-f3HEM4oEMIowBDAKMAQKMEQwCjAEMIoENk6yCjAOsAowTrAKMI7wCjAO8EowTvBKMA7
KME7KMA7KMA7wSjAO8AoyzvBKDsoO8AowDvBKME7KMA7wCjAO8EoxTvBKMA7KDvAKMA7wCjBOyjC
O8EoOyjAOyg7wSjBO8EoO8EoxjvAKMA7wSjBO8EoOyjAOyg7KDvAKMA7wSg7wSjBO8EowDvAKMU7
KME7KMA7KMA7wSj9-f3LEM4oEMEoECgQKBDCKBDAKBDDKBDaOskoOsIoOsAowzsowDsowDsoOyjD
OyjBOyjAOyg7KMA7KDsowDsoyTsowjvAKME7KMM7KMI7KMA7KMA7KMQ7KMA7KDvAKME7KMA7KMA7
KME7KMA7KDsowDsoOyjAOyg7KMI7KMA7KMQ7KMA7KDsowDsoOyjAOyg7KMA7KDvAKME7KMA7KDso
wDsoOyjCOyjAOyjEOyjBOyjAOyg7KMA7KP39-csQzigQwSgQKBAoEMIoEMAoEMMoENo6ySg6wSjA
OsAowzsowDsowDsoOyjDOyjBOyjAOyg7KMA7KDvCKMo7wCjAOyjCOyjDOyjCOyjAOyjAOyjEOyjA
Oyg7KMI7wijAOyjBOyjAOyg7KMA7KDsowDsoOyjCOyjAOyjEO8IoOyjAOyg7KMA7KDsowDsoOyjC
OyjAOyg7KMA7KDsowjvCKMQ7KME7KMA7KDsowDso-f39yxDOKBDBKBAoECgQKBDAKBDAKBDCKBDb
OskoOsIoOsAowzsowDsowDsoOyjDOyjBOyjAOyg7KMA7KDsozzsoOyjCOyjCOyjDOyjAOyjAOyjE
OyjAOyg7KMI7KMM7KME7KMA7KDsowDsoOyjAOyg7KMI7KMA7KMQ7KMI7KMA7KDsowDsoOyjAOyg7
KMI7KMA7KDsowDsoOyjCOyjHOyjBOyjAOyg7KMA7KP39-csQzijBECjAEMAowRAowRDAKMAQwCgQ
2zrIKME6KME6wCjCO8EoOyjAOyjAO8EowTvAKMA7wSjAO8EowDvBKMk7wSjAOyjDO8EoOyjCO8Eo
OyjAOyg7wig7wSjAOyjDO8EowTvAKMA7wSjAO8EoOyjAOyjAO8EoOyjAOyg7wijAO8EoOyjAOyjA
O8EowDvBKDsowzvBKDsowDsowDvBKMA7wSjAOyjCO8AowDvBKMA7wSj9-f3LEP3DOtEo-dI7KP39
-f39EP3DOtEo-dI7KP39-f39EP3DOtEo-f39-f391BD9wzrRKP39-f39-dQQ1SjAECjBECjBECjB
ECjBECjBEMAowBAowBDEKBDGOtEowzsoyjvAKMk7KMk7KDso1Tso2TvAKNU7KOU7wCjLOyg7KP39
-doQ1CgQwSgQKBAoEMEoECgQwCgQwSgQwCgQKBAoECgQwygQxjrRKNE7KMk7KMk7KDso0Tso3jso
1Tso5jsoyzsoOyj9-f3aENQoEMEowBDAKMAQwCjBEMAoEMEoEMAoECgQKBAoEMMoEMY6yCjAOsAo
Oig6wCjCO8AowDvBKME7wSjAOyjBOyjAOyjAO8EowDvAKMs7wSg7KDvAKMA7wSjBOyjAO8AowDvB
KMU7wSjAOyg7wCjAO8AowTsowjvBKDsowDsoO8EowTvBKDvBKMU7KME7KMA7wSg7KMA7KMA7wCjB
O8EoxDsowTsowDsowDvBKP39-d4Q1CgQwSgQKBAoEMEoECgQwCgQwSgQwCgQKBAoECgQwygQxjrJ
KDrAKDooOsAowzsowDsowDsoOyjDOyjBOyjAOyg7KMA7KDsowDsoyTsowjvAKME7KMM7KMI7KMA7
KMA7KMQ7KMA7KDvAKME7KMA7KMA7KME7KMA7KDsowDsoOyjAOyg7KMI7KMA7KMQ7KME7KDsowDso
OyjAOyg7KMA7KDsoxzsowTsowDsoOyjAOyj9-f3eENUowBAoECgQKMEQKBAoEMAoEMAowRAowBDA
KBAoEMAoEMAowRDEOskoOsAowTrAKMM7KMA7KMA7KDsowzsowTsowDsoOyjAOyg7wijKO8AowDso
wjsowzsowjsowDsowDsoxDsowDsoOyjCO8IowDsowTsowDsoOyjAOyg7KMA7KDsowjsowDsoxDso
Oyg7KDsowDsoOyjAOyg7wijAO8AoxTsowTsowDsoOyjAOyj9-f3eEP3DOskoOsIoOsAowzsowDso
wDsoOyjDOyjBOyjAOyg7KMA7KDsozzsoOyjCOyjCOyjDOyjAOyjAOyjEOyjAOyg7KMI7KMM7KME7
KMA7KDsowDsoOyjAOyg7KMI7KMA7KMQ7KDsoOyg7KMA7KDsoOyjAOyjFOyjEOyjBOyjAOyg7KMA7
KP39-d4Q-cM6yCjBOsEoOsAowjvBKDsowDsowDvBKME7wCjAO8EowDvBKMA7wSjJO8EowDsowzvB
KDsowjvBKDsowDsoO8IoO8EowDsowzvBKME7wCjAO8EowDvBKDsowDsowDvBKDsowDsoO8IowDso
OyjBO8EoO8AowjvBKDvBKME7KMI7wCjAO8EowDvBKP39-d4Q-cM60Sj90jso-f39-f0Q-cM60Sj9
0jso-f39-f0Q1CjCEMAowRAowRDAKMAQKBAoECjBECjAEMEowBDDKBDEOtEo-f39-f391BDUKBAo
ECgQKBAoEMAoEMAoEMEoECgQwCgQwCgQKBAoEMUoEMQ60Sj9-f39-f3UENQoECgQKBAowRDAKBDA
KBDBKMEQwCgQwCgQKBAoEMUoEMQ60SjNOyjKO8AoyTsoyTsoOyjDOyjEOyjQO8AoyzsoOyj9-f39
5xDUKBAoECgQKBAoEMAoEMAoEMEoECgQwCgQwCgQKBAoECgQwygQxDrRKNs7KMk7KMk7KDsowzso
xDso0TsoyzsoOyj9-f395xDUKBDBKBAoECgQwCgQwSjAECgQKBAowRAoECgQKMEQwCgQwCjAEMM6
yCjAOsAowTrAKMw7wCjAO8EowTvBKMA7KME7KMA7KMA7wSjAO8AoyzvBKMA7wCjAO8EowDsowDso
wDvBKMQ7KME7KMA7KMA7wSj9-f396xD9wzrJKDrAKDrCKM07KMA7KMA7KDsowzsowTsowDsoOyjA
Oyg7KMA7KMk7KMA7KDsowDsoOyjAOyg7KMA7KDsowDsoxDsowTsowDsoOyjAOyj9-f396xD9wzrJ
KDrAKME6wCjCO8IoO8IowDsowDsowDsoOyjDOyjBOyjAOyg7KMA7KDvCKMk7KMA7KDvCKDsowDso
OyjAOyg7KMA7KMQ7KME7KMA7KDsowDso-f39-esQ-cM6ySg6wig6wCjNOyjAOyjAOyg7KMM7KME7
KMA7KDsowDsoOyjMOyjAOyg7KMI7KMA7KDsowDsoOyjAOyjEOyjBOyjAOyg7KMA7KP39-f3rEP3D
OsgowToowTrAKMw7wSg7KMA7KMA7wSjBO8AowDvBKMA7wSjAO8EoyjvBKMA7wSg7wSjBO8EowDvB
KMA7KMI7wCjAO8EowDvBKP39-f3rENQowhDAKMEQwCjAECgQKBAowRAowBDAKMEQwCjAEMAowBDG
OtEo-dE7KP39-f39wBDUKBAoECgQKBDBKBDBKBAoECgQKBAoECgQwCgQwCgQwSgQyDrRKP3PO8Ao
-f39-f3BENQoECgQKBAowBDAKBDBKMEQKMEQKBAoEMAoEMAoEMEowRDGOtEowh3DKP39-f39-csQ
1CgQKBAoECgQwSgQwSgQKBAoECgQKBAoEMAoEMAoEMMoEMY60SjCHcMo-f39-f39yxDUKBDBKBAo
wRDAKMAQKBAoECgQKBAoECgQKMEQwCjAECjAEMEoEMM60SjCHcMo-f39-f39yxD9wzrRKMIdwyj9
-f39-f3LEP3DOsgowDrAKDrCKMIdwyj9-f39-f3LEP3DOskoOsAoOsIowh3DKP39-f39-csQ-cM6
ySg6wCjBOsAowh3DKP39-f39-csQ1SjAECjBECjBECgQwSgQwijAEMMoEMEoECgQKMEQxDrJKDrA
KDooOsAowh3DKP39-f39-csQ1CgQwSgQKBAoEMEoEMEoEMEoEMUoEMEoECgQKBAoEMQ6yCjBOijB
OsAowh3DKP39-f39-csQ1CjBECjBECjAEMAoEMEoEMEowRDDKBDBKBAoECjBEMQ60SjCHcMo-f39
-f39yxDWKBAoEMEoEMEoEMEoEMMoEMMoEMEoECgQKBAoEMQ60SjCHcMo-f39-f39yxDUKMAQwCgQ
wSjBECjBECjBECjAEMEoEMAowRDAKMAQKBAoEMQ60Sj9-f39-f3UEP3DOtEo-f39-f391BD9wzrR
KP39-f39-dQQ-cM60Sj9-f39-f3UEP3DOsgowDrAKME6wCj9-f39-f3UEM8owBDAKMAQKMEQKMEQ
KMAQxCgQwSgQKBAowRDOOskoOsIoOsAo-f39-f391BDOKBDBKBDBKBAoEMAoEMAoECgQwygQwSgQ
KBAoECgQzjrJKDrCKDrAKP39-f39-dQQzijBECgQwSjAEMEoEMAoECgQwygQwSgQKBAowRDOOsko
OsIoOsAo-f39-f391BDQKBAoECgQKBAoEMAoEMAoECgQwygQwSgQKBAoECgQzjrIKME6wSg6wCj9
-f39-f3UEM4owBDAKMEQKBAoECjBECjBEMAoEMAowRDAKMAQKBAoEM460Sj9-f39-f3UEP3DOtEo
-f39-f391BD9wzrRKP39-f39-dQQ-cM60Sj9-f39-f3UEP3DOtEowjvAKNA7wCjMOyjHOyjWOyjZ
O8Ao1Tso_zso2Dso0zvAKMw7KMI7KP39xxDOKBAoECjBEMMoEMEoECgQKMEQ2jrRKMM7KNE7KMw7
KMc7KPM7KNU7KP3YOyjUOyjMOyj9-cwQzigQKBDAKBDEKBDBKBAoECgQKBDaOsgowDrAKME6wCjD
OyjCO8AowTvBKMA7wSjAOyjHO8EoO8IowDvBKDvCKMA7wCjPO8AowDvBKMU7wSjAOyg7wCjAO8Ao
wTsowjvBKDsowDsoO8EowTvBKDvBKMU7KME7KMA7wSg7KMA7KMA7wCjBO8Eo2DvAKMA7wSjFO8Ao
OyjBO8AowTvBKMA7wCjGO8EowDvAKME7KMI7wCjBO8EoO8IoO8AowTvAKMA7wSj9_xDOKBAoEMAo
EMQoEMEoECgQKMEQ2jrJKDrAKDooOsAowzsowTsowDsoOyjCOyjAOyjAOyjGOyjDOyjBOyjAOyjA
OyjBOyjAOyjEO8IoxTsowDsowDsoxDsowDsoO8AowTsowDsowDsowTsowDsoOyjAOyg7KMA7KDso
wjsowDsoxDsowTsoOyjAOyg7KMA7KDsowDsoOyjcOyjAOyjAOyjEOyg7KDsoOyjAOyg7KMA7KDso
wDsoxDsowjsowDsowDsowTsowDsoOyjDOyjCOyjAOyjAOyg7KMA7KP36EM4oECgQwCgQxCgQwSgQ
KBAoECgQ2jrJKDrAKME6wCjDOyjBOyjAOyg7KMI7KMA7KMA7KMc7wCjBOyjBOyjAOyjAOyjBO8Io
zzsowDsowDsoxDsowDsoOyjCO8IowDsowTsowDsoOyjAOyg7KMA7KDsowjsowDsoxDsoOyg7KDso
wDsoOyjAOyg7wijAO8AoxTvCKDvCKDvCKMU7KMA7KMA7KMQ7KDsoOyg7KMA7KDsowDsoO8IoxTvA
KMA7wijAOyjBO8IoOyjDOyjCOyjAOyjAOyg7KMA7KP36EM8owBAowRDAKBDAKMEQwCjAECgQKBDa
OskoOsAoOig6wCjDOyjBOyjAOyg7KMI7KMA7KMA7KMk7KMA7KME7KMA7KMA7KME7KMc7wijFOyjA
OyjAOyjEOyjAOyg7KMI7KMM7KME7KMA7KDsowDsoOyjAOyg7KMI7KMA7KMQ7KDsoOyg7KMA7KDso
OyjAOyjFOyjZOyjAOyjAOyjEOyjBOyg7KMA7KDsowDsoOyjKOyg7KMM7KME7KMI7KMM7KMI7KMA7
KMA7KDsowDso-foQ-cM6yCjBOijBOsAoxDvAKMA7wCjBO8EowDvBKME7wCjEO8EowjvAKMA7wSjB
O8AowDvBKM47wSg7KMA7KDvCKDvBKMA7KMM7wSjBO8AowDvBKMA7wSg7KMA7KMA7wSg7KMA7KDvC
KMA7KDsowTvBKDvAKMI7wSg7wSjZO8EoOyjAOyg7wig7KME7KMA7wCjBO8EowDvBKDvCKDvBKME7
wSjBO8AowDvBKMA7wSjBO8AoO8EowDvAKMA7KMA7KP36EP3DOtEo-dg7KP39-f33EP3DOtEo-dg7
KP39-f33EP3DOtEo-f39-f391BD9wzrRKP39-f39-dQQ-cM60SjCO8Ao0DvAKNY7KMw7KMc7KNc7
wCjEO8Ao-f39-eEQ-cM60SjDOyjROyjWOyjMOyjHOyjWOyjHOyj9-f394RD9wzrIKMA6wCjBOsAo
wzsowjvAKME7wSjAO8EowDsoxjvBKME7wCjAOyjAOyg7wijFO8EoO8IowDvBKDvCKMA7wCjQOyjC
O8EowDsowjvBKMA7wCj9-f391hD9wzrJKDrAKDooOsAowzsowTsowDsoOyjCOyjAOyjAOyjGOyjA
Oyg7KMA7KDsowDsowDsoxjsowzsowTsowDsowDsowTsowDsoxDvCKMQ7wig7KMA7KMA7KME7KMI7
KMA7KP39-f3VEP3DOskoOsAowTrAKMM7KME7KMA7KDsowjsowDsowDsoxjsowDsoO8IowDvAKME7
KMc7wCjBOyjBOyjAOyjAOyjBO8IozzsowTsowDsowDsowjvAKMA7wij9-f391RD9wzrJKDrCKDrA
KMM7KME7KMA7KDsowjsowDsowDsoxjsowDsoOyjCOyjAOyjAOyjJOyjAOyjBOyjAOyjAOyjBOyjH
O8IoxTsowTsowDsowDsoxDsoOyj9-f392BD9wzrIKME6wSg6wCjEO8AowDvAKME7wSjAO8EowTvA
KMQ7KMA7KMA7wSg7KMA7KME7wCg7wig7wSjCO8AowDvBKME7wCjAO8EozzsowjvBKME7wCg7wSjB
O8Eo-f39-dUQ-cM60Sj9-f39-f3UEP3DOtEo-f39-f391BD9wzrRKP39-f39-dQQ-cM60Sj9-f39
-f3UEP3DOtEo-f39-f391BD9wzrRKP39-f39-dQQ-cM6yCjBOijBOsAo-f39-f391BD9wzrKKDoo
Oig6wCj9-f39-f3UEP3DOsgowTooOig6wCj9-f39-f3UEP3DOsgoOsEoOig6wCj9-f39-f3UEP3D
OsgowToowTrAKP39-f39-dQQ-cM60Sj9-f39-f3UEP3DOtEo-f39-f391BD9wzrRKP39-f39-dQQ
-cM60Sj9-f39-f3UEP3DOtEo-f39-f391BD9wzrRKP39-f39-dQQ-cM6yCjBOijAOsEo-f39-f39
1BD9wzrKKDrAKDrBKP39-f39-dQQ-cM6yCjBOsAoOsEo-f39-f391BD9wzrIKDrCKDrBKP39-f39
-dQQ-cM6yCjBOijBOsAo-f39-f391BD9wzrRKP39-f39-dQQ-cM60Sj9-f39-f3UEP3DOtEo-f39
-f391BD9wzrRKP39-f39-dQQ-cM60SjEO8Aozzsowjso1TsoxjsowTsowzsowTso-f39-f3EEP3D
OtEowzso0Tso5zsowjsowzso-f39-f3DEP3DOsgowToowTrAKMM7KME7KMA7KDvBKME7wSg7wig7
wCjBO8AowDvBKMo7wCjAO8EowDvAKMA7wijAOyjDOyj9-f39-cMQ-cM6yig6wSg6wCjCO8IoOyjA
Oyg7KMA7KDsowzsowjsowDsowDsoOyjAOyjKOyjAOyjAOyjAOyjBOyjCOyjDOyj9-f39-cMQ-cM6
yCjBOijBOsAowzsowTsowDsoOyjAOyg7KMM7KMI7KMA7KMA7KDsowDsoyjsowDsowDsowDsowTso
wjsowzso-f39-f3DEP3DOsgoOsEoOsIowzsowTsowDsoOyjAOyg7KMM7KMI7KMA7KMA7KDsowDso
yjsowDsowDsowDsowTsowjsowzso-f39-f3DEP3DOsgowToowTrAKMM7KMI7wSg7KMA7KMA7wSjB
O8AoO8EowDvAKMA7KMA7KMQ7wig7wSg7KMA7KDvBKME7wCjAOyjDOyj9-f39-cMQ-cM60Sj9yTso
wTso-f39-f3EEP3DOtEo-f39-f391BD9wzrRKP39-f39-dQQ-cM60Sj9-f39-f3UEP3DOtEo2Dso
yDso0DvAKPI7KDsowDsoOyjGO8Ao-f39-dAQ-cM60SjjOyjQOyjzOyg7KMA7KDsoxzso-f39-cP_
AAAAwCjANcEoNSg1KMAQ-cM6yCjBOijBOsAo0TsowTsoO8AowDvBKME7wSjAO8AowDsowTsoxTso
xzvBKDsowDsoOyg7wCjAO8EowDvAKMA7KDvAKN87KP39-f3ENSjCNSjBNSjAEP3DOsooOsEoOsAo
0TsowTsowDsowDsowDsoOyjAOyg7KMA7KDsowTsoxDsoxzsowjsowDsoO8AowTsowjsowDsoO8Ao
xjvCKNY7KP39-f3DNSjANcEowDUowRD9wzrIKME6wCjAOsAo0TsoOyg7KMA7KMA7KMA7KDsowDso
OyjAOyg7KDsoOyjFOyjGOyjCOyjAOyg7KMM7wCjAOyjAOyg7KOI7KP39-f3ENSjANSjBNSjCEP3D
OsgoOsMoOsAo0TsoOyg7KMA7KMA7KMA7KDsowDsoOyjAOyg7KDsoOyjFOyjGOyjCOyjAOyg7KMU7
KDsowDsoOyjHO8Io1Tso-f39-cM1wSg1wSg1KDUowBD9wzrIKME6KME6wCjSOyg7KMA7wSg7KMA7
KMA7wSjAO8AowTsoOyjGOyjHO8EowDvBKDsowjvBKME7wCjAOyjiOyj9-f390BD9wzrRKPY7wCj9
xDvAKP39-f3DNcEoyBD9wzrRKP39-f39-ck1KDXBKDXAKMEQ-cM60Sj9-f39-f3HNcEoNcEoNcAo
wRD9wzrRKP39-f39-cc1KME1KDUoNSg1KMAQ-cM60SjTO8AoxTsoxjsoxDsowDsoOyjKO8AoxzvA
KM47wCjBOyg7KME7KNA7KMk7KME7wCjFO8IowDvAKME7wCjBO8AowTso-f391zXBKDUoNSg1wSjA
EP3DOtEo0jsoxzsoxjsowzsowTsoOyjLOyjDOyjAOyjAOyjOOyjBOyg7KMI7KM87KMg7KME7KMA7
KMQ7KMI7KMA7KDsowDsoOyjAOyjBOyj9-f3jEMUAAAAAAAAAAQ==
:: main.lua
--[[pod_format="raw",created="2025-03-24 12:49:34",modified="2025-04-01 20:24:10",revision=5869]]
----------------------------------------------------------------------------------------


include "src/utils.lua"
local buffers = require "src/buffers.lua"
local config = require "src/config.lua"
local filetree = require "src/filetree.lua"
local ui = require "src/ui.lua"


----------------------------------------------------------------------------------------


local font <const> = "/system/fonts/lil.font"
local font <const> = "/system/fonts/lil_mono.font"
local font <const> = "fonts/cozi.font"
local font_alt <const> = "fonts/p9.font"


----------------------------------------------------------------------------------------


local sidebar
local editor


----------------------------------------------------------------------------------------


function _init()
	log("---- new process -----------------------------------------------")
	log("env=" .. pod(env()))

	-- Requested path is the first argument passed to
	-- the program, and may contain a hloc.
	local requested_path = get_requested_path()

	broadcast_requested_path(requested_path)

	local path, row = split_fullpath_and_hloc(requested_path)
	
	if not fstat(path) then
		-- New files must be created early, by the freshly launched
		-- process. If the file belongs to an already existing
		-- window, both process will have the same window.location,
		-- and the WM will kill the new, unneeded one.
		store(path, "", {})
	end
	
	local main_path, root_path = find_main_and_root_path(path)

	open_window(main_path, path)
	
	config.init()
	buffers.init()
	log("config.theme.sidebar_bg=" .. pod(config.theme.sidebar_bg))
	load_fonts()
	
	filetree.create(root_path)
	--filetree.printh()

	update_menu_items()
	install_event_handlers()
	
	generate_ui()
	
	sidebar:set_current(filetree.find(path))
	if row then
		sidebar:current_node():buffer():set_cursor(1, row)
		editor:center_cursor()
	end
end


----------------------------------------------------------------------------------------


function _update()
	local display = get_display()
	local width, height = display:width(), display:height()
	if true then
		sidebar.x, sidebar.y = 0, 0
		editor.x, editor.y = sidebar.width, 0
		editor.width, editor.height = width - sidebar.width, height
	else
		sidebar.x, sidebar.y = width - sidebar.width, 0
		editor.x, editor.y = 0, 0
		editor.width, editor.height = width - sidebar.width, height
	end
	-- TODO: what?
	-- Focus is lost on any click (in picotron's `update_all`),
	-- how do we prevent that from happening?
	if ui.head():get_keyboard_focus_element() == nil then
		-- A click on any GUI element nulls the keyboard focus...
		editor:set_keyboard_focus(true)
	end
	ui:update()
	if key("ctrl") and keyp("e") then
		filetree.refresh()
	end
end


----------------------------------------------------------------------------------------


function _draw()
	cls(8) -- TODO: remove
	ui:draw()
	print(string.format("\014%4.0f", stat(1) * 100.0) .. "%", 452, 246, 0)
	print(string.format("\014%3.0f", stat(0) / (1024 * 1024)) .. "MB", 452, 253, 0)
end


------------------------------------------------------------------------------------------


function generate_ui()
	ui.init()
	editor = ui.head():attach(ui.editor { x = 60, y = 0 })
	editor:set_keyboard_focus(true)
	sidebar = ui.head():attach(ui.sidebar { x = 0, y = 0, editor = editor })
end


------------------------------------------------------------------------------------------


function get_requested_path()
	local requested_path = env().argv[1] or "/ram/cart/main.lua"
	local this_prog = env().argv[0]
	if this_prog == "/system/apps/terminal.lua" then
		-- Codron is the loaded cart, use a fake path.
		requested_path = "/test/test2/main.lua"
	end
	return requested_path
end


------------------------------------------------------------------------------------------


function split_fullpath_and_hloc(path)
	local path = fullpath(path)
	local parts = split(path, "#", false)
	local path = parts[1]
	local row = tonumber(parts[2])
	return path, row
end


------------------------------------------------------------------------------------------


function find_main_and_root_path(path)
	local main_path = filetree.find_main(path)
	local root_path = path
	if main_path then
		root_path = parent_folder(main_path)
	end
	log([[root_path="]]..root_path..[["]])
	return main_path, root_path
end


------------------------------------------------------------------------------------------


function broadcast_requested_path(requested_path)
	local this_prog = env().argv[0]
	if this_prog == "/system/apps/terminal.lua" then
		-- Codron is the loaded cart, fix the program path.
		this_prog = "/ram/cart/main.lua"
	end

	local matching_proc_ids = {}
	for process in all(fetch "/ram/system/processes.pod") do
		local prog <const> = process.prog
		if prog == this_prog then
			matching_proc_ids[#matching_proc_ids + 1] = process.id
		end
	end
	
	for proc_id in all(matching_proc_ids) do
		if proc_id ~= pid() then
			log("sending switch_to message to [" .. string.format("%03d", proc_id) .. "]")
			send_message(proc_id, { event = "switch_to", path = requested_path })
		end
	end
end


------------------------------------------------------------------------------------------


function open_window(main_path, requested_path)
	local location = main_path or requested_path
	local title = main_path and (parent_folder(main_path):basename().."/")
		or requested_path:basename()

	local icon = get_spr(1)
	local this_prog = env().argv[0]
	if this_prog == "/system/apps/terminal.lua" then
		icon = get_spr(3)
	end
	
	window {
		location = location,
		unique_location = true,
		pauseable = false,
		immortal = false,
		capture_escapes = true,
		tabbed = true,
		width = 300, height = 200,
		title = title,
		icon = icon,
	}
end


------------------------------------------------------------------------------------------


function load_fonts()
	local font_mem = fetch(font)
	if font_mem then
		font_mem:poke(0x4000)
	end
	local font_alt_mem = fetch(font_alt)
	if font_alt_mem then
		font_alt_mem:poke(0x5600)
	end
end


------------------------------------------------------------------------------------------


local function switch_to(path, sender)
	path = fullpath(path)
	local parts = split(path, "#", false)
	local path = parts[1]
	local row = tonumber(parts[2])

	local root = filetree.root()
	
	if root:is_file() and path == root:path() then
		log("main.switch_to: *found* single-file: requested=" .. pod(path) .. " this=" .. pod(root:path()))
		sidebar:set_current(root)
		if row then
			sidebar:current_node():buffer():set_cursor(1, row)
			editor:center_cursor()
		end
		return
		
	elseif root:is_file() then
		log("main.switch_to: not this single-file: requested=" .. pod(path) .. " this=" .. pod(root:path()))
		-- TODO: should we `stop()` right there?
		-- or is it better to let the WM do the killing?
		return
	
	elseif root:is_folder() and sub(path, 1, #root:path()) == root:path() then
		local node = filetree.find(path)
		
		if node then
			log("main.switch_to: *found* requested file: requested=" .. pod(path))
			sidebar:set_current(node)
			if row then
				sidebar:current_node():buffer():set_cursor(1, row)
				editor:center_cursor()
			end
			return
			
		else
			log("main.switch: *new file* belongs in filetree folder: requested=" .. pod(path) .. " folder=" .. pod(root:path()))
			filetree.refresh()
			sidebar:set_current(filetree.find(path))
		end

	elseif root:is_folder() then
		log("main.switch_to: not in filetree folder: requested=" .. pod(path) .. " folder=" .. pod(root:path()))
		return
	end
end


------------------------------------------------------------------------------------------


function install_event_handlers()
	on_event(
		"switch_to",
		function(msg)
			log("EVENT: switch_to " .. pod(msg))
			switch_to(msg.path, msg._from)
		end
	)
	on_event(
		"open_file",
		function(msg)
			log("EVENT: open_file " .. pod(msg))
		end
	)
	on_event(
		"new_file",
		function(msg)
			log("EVENT: new_file " .. pod(msg))
		end
	)
	on_event(
		"save_file",
		function(msg)
			log("EVENT: save_file " .. pod(msg))
			if msg.filename then
				log([[!!! filename="]]..msg.filename..[[" !!!]])
			end
			filetree.save_all()
		end
	)
	on_event(
		"save_file_as",
		function(msg)
			log("EVENT: save_file_as " .. pod(msg))
			local new_path = fullpath(msg.filename)
			if not new_path then
				notify("unable to save: invalid file name")
				return
			end
			local node = sidebar:current_node()
			if not node then
				return
			end
			local ext = node:path():ext()
			if not new_path:ext() and ext then
				new_path ..= "." .. ext
			end
			local err = node:save_as(new_path)
			if err then
				notify(err)
			else
				notify("saved as " .. new_path)
			end
			filetree.refresh()
		end
	)
	on_event(
		"jump_to_hloc",
		function(msg)
			log("EVENT: jump_to_hloc " .. pod(msg))
		end
	)
	on_event(
		"drop_items",
		function(msg)
			log("EVENT: drop_items " .. pod(msg))
		end
	)
	on_event(
		"gained_focus",
		function(msg)
			--log("gained_focus")
			-- TODO: check for file changes.
			filetree.refresh()
		end
	)
	on_event(
		"lost_focus",
		function(msg)
			local root = filetree.root()
			if root:is_folder() and sub(root:path(), 1, 9) == "/ram/cart" then
				filetree.root():save_all()
			end
		end
	)
	on_event(
		"gained_visibility",
		function(msg)
			--log("gained_visibility")
		end
	)
	on_event(
		"lost_visibility",
		function(msg)
			--log("lost_visibility")
		end
	)
	on_event(
		"resize",
		function(msg)
			log("EVENT: resize width="..msg.width.." height="..msg.height)
			-- TODO: resize the editor widget
		end
	)
	-- non existing events?
	on_event(
		"modified:/test/test2",
		function(msg)
			log("??? EVENT: modified:")
		end
	)
	on_event(
		"close_window",
		function(msg)
			log("??? EVENT: close_window ???")
		end
	)
	on_event(
		"pause",
		function(msg)
			log("??? EVENT: pause ???")
		end
	)
	on_event(
		"halt",
		function(msg)
			log("??? EVENT: halt ???")
		end
	)
end


------------------------------------------------------------------------------------------


function update_menu_items()
	-- TODO: no need for "New File" menu entry once the sidebar button is implemented
	menuitem {
		id = "new_file",
		label = "\^:7f4141417f616500 New File",
		action = function()
			log("MENU: New File")
			local folder = filetree.root():folder_path()
			if sidebar:current_node() then
				folder = sidebar:current_node():folder_path()
			end
			local open_with = env().argv[0]
			if open_with == "/system/apps/terminal.lua" then
				open_with = "/ram/cart/main.lua"
			end
			create_process(
				"/system/apps/filenav.p64",
				{
					path = folder,
					use_ext = "lua", -- TODO: current buffer extension?
					intention = "new_file",
					open_with = open_with,
					window_attribs = { workspace = "current", autoclose = true }
				}
			)
		end
	}

	menuitem {
		id = "open_file",
		label = "\^:7f4141417f616500 Open File",
		shortcut = "CTRL-O",
		action = function()
			log("MENU: Open File")
			local folder = filetree.root():folder_path()
			if sidebar:current_node() then
				folder = sidebar:current_node():folder_path()
			end
			local open_with = env().argv[0]
			if open_with == "/system/apps/terminal.lua" then
				open_with = "/ram/cart/main.lua"
			end
			create_process(
				"/system/apps/filenav.p64",
				{
					path = folder, -- TODO: !!!!!!!!
					open_with = open_with,
					window_attribs = { workspace = "current", autoclose = true }
				}
			)
		end
	}
	
	if filetree.root():is_folder()
		and filetree.root():path():sub(1, 9) == "/ram/cart"
	then
		menuitem {
			id = "save_file",
			label = "\f6\^:7f4141417f616500 Save All (auto)",
			shortcut = "CTRL-S", -- ctrl-s is handled by window manager
			action =
				function()
					-- still save just in case!
					send_message(pid(), { event = "save_file"} )
					return true
				end
		}
	elseif filetree.root():is_folder() then
		menuitem {
			id = "save_file",
			label = "\^:7f4141417f616500 Save All",
			shortcut = "CTRL-S", -- ctrl-s is handled by window manager
			action =
				function()
					send_message(pid(), { event = "save_file" })
				end
		}
	else
		menuitem {
			id = "save_file",
			label = "\^:7f4141417f616500 Save File",
			shortcut = "CTRL-S", -- ctrl-s is handled by window manager
			action =
				function()
					send_message(pid(), { event = "save_file" })
				end
		}
	end

	menuitem{
		id = "save_file_as",
		label = "\^:7f4141417f616500 Save File As",
		action = function() 
			local folder = filetree.root():folder_path()
			local ext = "lua"
			if sidebar:current_node() then
				folder = sidebar:current_node():folder_path()
				ext = sidebar:current_node():path():ext()
			end
			create_process(
				"/system/apps/filenav.p64", 
				{
					path = folder,
					intention = "save_file_as",
					use_ext = ext,
					window_attribs = { workspace = "current", autoclose = true }
				}
			)
		end
	}

end


------------------------------------------------------------------------------------------

:: manual.txt
--[[pod_format="raw",created="2025-03-25 12:12:29",modified="2025-04-01 20:24:10",revision=4026]]
# Codron

## Keybinds

### Editor

Switch between files:
- Ctrl-E: File Chooser / Command Palette
- Ctrl-J: Jump to previous file (hold ctrl to keep jumping)
- Ctrl-K: Jump to next file

Find, aka incremental search:
- Ctrl-F: Find
- Ctrl-D: reverse finD
- Ctrl-W: find current word
- Ctrl-F Ctrl-F: find aGain
- Ctrl-D Ctrl-D: find aGain

Search and replace:
- Ctrl-H: searcH and replace

Navigate in current file:
- Ctrl-G: go to line number (if a number is entered)
  or to a specific function definition (otherwise).
- Ctrl-PageUp: go to previous cursor/selection, or go to
  previous function definition if only one cursor.
- Ctrl-PageDown: go to next cursor/selection, or go to
  next function definition if only one cursor.

Selection:
- Ctrl-L: select current line, or extend selection
  by one line.
  
Multi-cursors and multi-selection:
- Ctrl-G: deselect current occurence?
- Ctrl-I: if selection, add a cursor at end of each
  line, otherwise add one cursor below.
- see also Ctrl-PageUp and Ctrl-PageDown

### Find (incremental search)

- Enter: exit find, keep selection.
- Shift-Enter: exit find, cancel selection.
- Ctrl-A: exit find, select all occurences.
- Ctrl-F: select next occurence.
- Ctrl-D: select previous occurence.
- Escape: exit find, go back to original position.
- Movement keys: exit find, cancel selection.

:: todo.txt
--[[pod_format="raw",created="2025-03-25 08:49:54",modified="2025-04-01 20:24:10",revision=4061]]
- Fix: alt-double-click to add words to selection: an extra cursor is added.
- Fix: bug when opening non-existent file
- Fix: disable syntax highlighting for non-lua files.
- Add: alt-click on selection to discard it.
- Add: button to add new file in sidebar.
- Add: button to refresh the filetree.
- Add: button to colapse the sidebar.
- Add: button to open the file chooser/command palette.
- Add: auto-close for parenthesis, with smart newline.

## Later
- Fix: Find when a multiline selection... what to do?
- Add: syntax highlighting for markdown files.
- Add: horizontal scrollbar? based on longest line on screen?
- Add: horizontal drag with right click, but gated with pressure.

:: .info.pod
b64$LS1bW3BvZCxhdXRob3I9ImRyYWttYW5pc28iLGNyZWF0ZWQ9IjIwMjUtMDMtMjIgMTY6MDQ6
MDQiLGljb249dXNlcmRhdGEoInU4IiwxNiwxNiwiMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEw
MDAwMDAwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDcwNzAxMDAwMDAwMDEwNzExMTExMTExMTExMTEx
MTExMTExMDcwMTAwMDEwNzExMTExMTExMTExMTExMTExMTExMTExMTA3MDEwMTA3MTExMTExMTEx
MTExMTExMTExMTExMTExMDcwMTAxMDcxMTExMTExMTExMTExMTExMTExMTExMTEwNzAxMDEwNzEx
MTExMTExMTExMTExMTExMTExMTExMTA3MDEwMTA3MTExMTExMTExMTExMTExMTExMTExMTExMDcw
MTAxMDcxMTExMTExMTExMTExMTExMTExMTExMTEwNzAxMDEwNzExMTExMTExMTExMTExMTExMTEx
MTExMTA3MDEwMTA3MTExMTExMTExMTExMTExMTExMTExMTExMDcwMTAxMDYwNzExMTExMTExMTEx
MTExMTExMTExMDcwNjAxMDEwNjA2MDcwNzA3MDcwNzA3MDcwNzA3MDcwNjA2MDEwMDAxMDYwNjA2
MDYwNjA2MDYwNjA2MDYwNjA2MDEwMDAwMDAwMTA2MDYwNjA2MDYwNjA2MDYwNjA2MDEwMDAwMDAw
MDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAiKSxtb2RpZmllZD0iMjAyNS0wNC0wMSAyMDoy
NDoxMSIsbm90ZXM9IkEgY29kZSBlZGl0b3IiLHJ1bnRpbWU9MTcsdGl0bGU9IkNvZHJvbiIsdmVy
c2lvbj0iMC4wLjAiLHdvcmtzcGFjZXM9e3tsb2NhdGlvbj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2Vf
aW5kZXg9Mn0se2xvY2F0aW9uPSJtYWluLmx1YSIsd29ya3NwYWNlX2luZGV4PTd9fV1d
:: [eoc]
