picotron cartridge // www.picotron.net
version 2

:: docs/
:: docs/design.md
b64$LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNS0wNS0wOCAxMzo1MjoyNSIsbW9k
aWZpZWQ9IjIwMjUtMDUtMTMgMjE6Mzg6NDkiLHJldmlzaW9uPTEwNzhdXQojIyBTcGVjaWFsIE1v
dmVzCgotIEV4dHJhIEF0dGFjazogYSBiaWcgYXR0YWNrIChUT0RPOiBob3cgZG9lcyBpdCBzY2Fs
ZT8gdXNlIHRoZSBudW1iZXIgb2YKICBzdXBlci1jaGFyZ2VkIGF0dGFjayBnZW1zPykuIFRyaWdn
ZXJzIGFmdGVyIHRoZSBub3JtYWwgYXR0YWNrLCBzbyBjYW4KICBjaXJjdW12ZW50IGRvZGdlLCBk
ZWZlbnNlIGFuZCBhcm1vci4KCi0gRG91YmxlIFN0cmlrZTogbmV4dCBhdHRhY2sgaXMgZGVhbHQg
dHdpY2UuIE5leHQgYXR0YWNrIGNhbiBiZSBvbiB0aGUgc2FtZQogIHR1cm4uIERvZGdlIG9ubHkg
dHJpZ2dlcnMgZm9yIHRoZSBmaXJzdCBoaXQuCgotIFJhZ2U6IHRyYW5zZm9ybXMgYWxsIGRlZmVu
c2UgZ2VtcyBpbnRvIGF0dGFjayBnZW1zLiBUT0RPOiBjYXAgdGhlIGRhbWFnZT8KCi0gU3BlZWQ6
IHRyYW5zZm9ybXMgYWxsIGRlZmVuc2UgZ2VtcyBpbnRvIGRvZGdlIGdlbXMuIENhbiBpbW1lZGlh
dGVseQogIGZpbGwgdGhlIGRvZGdlIGJhci4KCi0gSGFyZGVuOiB0cmFuc2Zvcm1zIGFsbCBkZWZl
bnNlIGdlbXMgaW50byBhcm1vciBnZW1zLgoKLSBQYXJyeS9Db3VudGVyOiBwYXJyeSB0aGUgbmV4
dCBhdHRhY2sgKG51bGxpZnkgaXQpIGFuZCBtaXJyb3IgdGhlIGRhbWFnZQogIHRvIHRoZSBvcHBv
bmVudC4KCiMjIFNraWxscwoKVXNpbmcgYSBza2lsbCB3aXRob3V0IGNyZWF0aW5nIGEgbWF0Y2gg
ZG9lcyBub3QgZW5kIHRoZSB0dXJuLCBldmVuIGlmIHNvbWUKZ2VtcyBhcmUgY2xlYXJlZC4gVGhv
c2UgY2xlYXJlZCBnZW1zIGFyZSBhZGRlZCB0byB0aGUgbmV4dCBtYXRjaC4KCi0gQ2xlYXIgb25l
IGdlbS4KCi0gQ2xlYXIgb25lIGNvbHVtbi4KCi0gU3VwZXItY2hhcmdlIG9uZSBnZW0uCgotIE1v
dmUgYWxsIHN1cGVyY2hhcmdlcyB0byBhIHNwZWNpZmljIGNvbG9yLgoKLSBGcmVlIHN3YXA6IG1h
a2UgYSBzd2FwLWFuZC1tYXRjaCB3aXRob3V0IGVuZGluZyB0aGUgdHVybi4KCi0gU3dhcCB0d28g
Y29sb3JzLgoKLSBTd2FwIHR3byBkaXN0YW50IChub24tbWF0Y2hpbmc-KSBnZW1zLgoKLSBTd2Fw
IHR3byBhZGphY2VudCBub24tbWF0Y2hpbmcgZ2Vtcy4KCi0gUm90YXRlIGNvbHVtbi4KCi0gU3dh
cCB0d28gKGRpc3RhbnQpIGNvbHVtbnMuCgojIyBQZXJtYW5lbnQgU2tpbGxzCgotIEludmVydCBn
cmF2aXR5LgoKLSBTaHVmZmxlIHRoZSBib2FyZC4KCiMjIFVwZ3JhZGVzCgpDb21tb246Ci0gaW5j
cmVhc2UgcGVyY2VudGFnZSBvZiBzdXBlcmNoYXJnZSA8Y29sb3I_IGdlbXMgKDAlIC0_IDEwJSAt
PiAyMCUgLT4gLi4uKQotIGRlY3JlYXNlIGRvZGdlIG1ldGVyICg2IC0_IDUgLT4gNCAtPiAuLi4p
Ci0gZGVjcmVhc2Ugc3BlY2lhbCBtZXRlciAoMTIgLT4gMTEgLT4gMTAgLT4gLi4uKQoKUmFyZToK
LSBpbmNyZWFzZSBtYXggYXJtb3IKLSBpbmNyZWFzZSBoZWFsdGgKLSBpbmNyZWFzZSBtYXggYXR0
YWNrPwotIGluY3JlYXNlIHBlcmNlbnRhZ2Ugb2YgPGNvbG9yPiBnZW1zICgyMCUgLT4gMzMlKQoK
SWYgaGVhbHRoIGlzIGxvdywgb25lIG9mIHRoZSAzIG9wdGlvbnMgaXMgYWx3YXlzOgotIGhlYWwg
YSBzbWFsbCBhbW91bnQKCiMjIE5ldyBHYW1lIFBsdXMKCi0gRW5uZW1pZXMgYXJlIHRvdWdoZXIK
LSBCYXNpYyBzd2FwIG1lY2hhbmljIGlzIHJlcGxhY2VkIHdpdGggbXVsdGktc3dhcCAoaS5lLiBz
d2FwIGEgY2hhaW4gb2YgNiBnZW1zKQ==
:: docs/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTI2IDE0OjAzOjI1Iixtb2RpZmllZD0iMjAyNS0w
NS0xMyAyMTozODo0OSJdXQ==
:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNS0w
NS0xMyAyMTozODo0OSIscmV2aXNpb249NjQxMF1dbHo0AB49AAAZxgAA8xR7WzBdPXtibXA9cHh1
AEMgEBAE8PAsZmxhZ3M9MCxwYW5feAgAz3k9MCx6b29tPTZ9LDEA-1DwER0dBPBPPxJAPuAODxYf
Kg8VDiAOHyofFg7QDg8qPxUuBQBADg81wB4ApBQfFS8WHxUfFA8TANUPFQ8UDxNPFQ8TDxQfKAAB
FQARLxUAEC8VADGQPyw_AFATLxUfEz4A-AYeHytgDyw-LS8VXy0-LB8VHywPK1ARAD8PNUATACXz
AFBPLC8TTywvKx8TLysfNVsANU8tLyIAH2ATAITvcD8rLn0eHR81gPwD8C7JAR3yPDkvKxAPD-AG
DysgHvAFTyzwBw0-LQ0O8AYNDD0ODzXwAx1sHfABDawN4A28HcANLB8qjA0OoA0sK4wdDpANLBuc
HQ4PNXAN-AAtDgYAKwpgBwAm7D0GAP8g3E0OCnANvE0OGnANrF0OCpAdbG0OGqAOzQ4awA6tDhrg
Hm0eGvABCm4q8ARq8BfNAB3wBU0PLOAOoA4PLQ7ADg0OkA4dDqAOoABAgA4tDgQA0QyADg0PKx0O
YA4dCw0OAFIbHW4dGwsAMyuNKxQAEq0SACr9AQYAkHAOLS5tLi0OcFQA8QkaDyoLDk0OCgsPGg4d
DgxgDh0OCRsJDi0GAAERADMtDikEAIAMYA49Lk0uPQkAIP0DSQD-Jm0vCW0OHEBbXQhdW3AOPQ4d
Dh0OPQ4cgDstHg0eLTtwGyAOrQ4cABuwHm0eHPABDG4s8ARsEAEf8AKLDytgDvAEHkAe8AQODyxO
DQ0A8DFNHtAuIA5tDiAuDzVAHi0eAA4NHw8NHA0OAB4tHiAObR4MDyoODAsODB5tDhAOfQ4MHgwe
DA59Dg81AA59Dg0cKwDwCX0OCgAOjQ5NDo0OCgA_bQ4tDm0_CgAOGt8A8AYaDgoQCgA_zT4KEAow
DhoOLQ5NDi0WAPAGcAoATk1OChAKkA4qDk0OKg4K0AogGwD-AiAK8AMODQ4a8AkOGvALCvBx6AAd
IBoPCgNwLPAKDysPFhQDIvAJEgAgDzUUABEfBgBBDzXwCwYA8AQE7yvADu8tDqAODf8sAA6QDg38
BgDwDhw_TD4cDg81YC4MDg8NHw8PDQ4sDgsfDwsODC5A0wHwBQ4KHxAKDiwOChkKDgwOHQ4wDg0M
FgAWGRUAAEAAsSAOHA4MDgsaCw4sBgAAFgAQCBUAAmEA8AIcDggwLvwBLhhACA78AQ4oYAYAYAiA
DjyOPAcAUiwOjQ4sCQBVDQ5MDgwNABB8CgAwkA4cCgCvHA4YoO4YwOjwMCoBKR8SKgEWULAODd8s
lgUFMgEXDC0BVTwOLA48JQEDDgAFIAEwXixeAgESCxcBYA8cHx0PHDABIh8dMQEYCxsBEQsbATAb
QAsVARErGwESCxsBFAsbARgLGwEVCxsBFQsbAW8boO4bwOsbAR-wGS8fK6AusA4fLR5wDi0ekA4f
LB0eQA48HR5gDkwdHhAOHA8NDw8PDRwWAPIEbB0eLA8PDxAPDzwdDiAOnB0eDB4AoVwOIA4sHmwd
HnwwA-ECHB4LDiwePB0eXA4LAC4rDgwQAKMMHR48DgsQKxAeEgByHS4MDgtwGxAA8QUMDi0eC8Ab
EB4bDjwNDgvwAhsADhwB4PABHhAOTA4LsB4gDg0e-wAhG2ALAHIADkwuGxAuCwCSDB0eLB47IA4d
DABAXB4rYAgA-xiMHiuADrweK7AOjB4r0A5sHivwAQ48HivwAw4cHivwBh4r8Akb8CI1AR3xCBYf
K2Ae8AAeDy0ODzVQDg8tHrAeHQ8sDQDwEA0fLB5wHh0cDh81YA48HkAOHTwOC3AOXA4wDkwOG4DL
ANAwDjw_QD48DhswDkwdDwBQHUwOC1AfABBABQAjUA4PACELcO4AAAUAYXAOLD4gPvEB8AMsHQ4L
EA4dLA4bkA48DhsgDjwWAAG3AxAwKwAQgIECEBxMABAcKgKADSwODD4APgxEABMNsAFxDhwdDgsO
HSAAEhzSAQEzAABzASQbgPQBABMAIAsQBQBgoA5cDhwuZQJADlwODNwFoA4LwA5cDg08DhsIAAGp
ATDgDky0ADDgDlyGAI-wAJ4b8AKbsFsBHdAyLyugHqAeLy0OcB4dBABAPywOQE8BALcFFB2OAqIO
EB4dTA4wDh08vgBBLB4dbIUEE1y7ALAeHZwOIA58Hh1sHpcB8QQQDlweHTweLA4LHhwOEA48Hh0M
DQDFDA4LAAsuCwAODC4dEACVHgsgKwAeLQ4MDwAhG2DrAAAKABGw7QDxCiAb8AEOTA4QHvADDiwO
DB4NDiAe4C5MDgAKAHKgGx4sHh0MDgBSLnALHlwOAHAdDguACx6MDQCwG6ALHrwOC9ALHowsAeAL
HmwOC-ADCx48DhvwBaUAvwvwCAseG-AKG-ARQwEd8gYanyvwAg4vLQ5dDvAADg0-LA5MDvBOAyBc
DqYBMVwO0DACMAwOXDMIIAwuGQAQsDcCIC81sAQEZQEQoBMAAD0BABQAAWgBEBwGBTAsDgAFAAQm
AHCQDg0_DzU_BAUAIwVBDjsAG2wAYKAODRwOQAUAEAwMAAGfAiANLGgAUjwOIA4NtgJgHD4LED4s
OQBQHA47IBvFAhBwHAABcQEBCgAkC1AGABBcTgCxXA5QDg0sPgswPjxRAGA8DjtAGw4MAkANTA6A
BQBBCzAePEYAcCweG0ALHixMAEEcHitw3gH-A1AODR4rsAseC1AeK-AAG2AbcG4JfTH9Aw4FAAFd
CRDNXQZ0YA4tTi1OLUgJBU4JEilNCR8JTQlGDyQNEB8yMQD--0ifHR0E-zf---88NQALHTE1AB84
NQAhXzsN-zwNBgA_D4YAHQc7AA8GADgPhgAMD6cBHQ0TBU8POw88BAAhFx8MAA84AP-------wcv
DzuJBh0HOwAPBAAZFx8MAA84AP-------wcvDzyJBhxxjzwPPQ87rwYAEU8GADL-PAAHABABBwAR
zxQAF38gABEfBgAXjwwAF_8GAAIwACRfPDQAES8GABUPNAATL2QAFgRXABcfKQAEgwAQBwcAF98T
ABGfBgARPwYAGL8lABdvJQAmXzxWADb-PBINACw-PCsAHR8YADb-PAgNABOfEwAWAiwAF38_AAN8
AAVdACc7TyMAEx8jABYWEwAXf7gACBIAF886AQIkARnfQwAWE5IACKsAD_QBGfEmIyAEcP82A_D_
BdD_BcD_B7D_B6D_CZD_CYD_C3D_C2D_DVD_DUD_DzD_DyD_ERD_EQD_NgAJABEgFQARQCEAEWAt
ABGAOQARoEUAEcBRAD-g-gOXFAweNY4AHzeOAHofOI4AevMzOwPg-zwF0P87BcD-PAew-zsHoP88
CZD-OwmA-zwLcP87C2D-PA1Q-zsNQP88DzD-Ow8g-zwREP87EQD-PBP-OxMADwATIB8AE0AvABNg
PwATgE8AE6BfABPAbwA-4P88rwAODoARDzEAewBCAQQ9AxOfSQMg4G4IADC_0C4HABCOBQDwAE7A
-gYPPbANDzv_AA0MLvIBoE4NDD4NDI4NDA76AfEFLg0M-gZgng0MXg0MLg0MPlAM-gsHAsE_DQzu
DQx_IA4NDM4vAPIAPhCeDQz_Ag0MDgAM-gQNBAAQAzYAEABFAEIMEP4AWgBRIAxuDQxvAAM3AkG_
DQx_XgARYG4AEHAcABCORAIBQACRHg2gXg0M7rAOJgAhnsA6AM-QXg0MzuCuDQxODXCvExzwE-AV
vzQPMdDfNC8xoN80TzGAXzRfMg8xDzAPNF8xYE80fzILAPAJLzJPMUBPNI8yDzFPMk8xMD80-zIB
PzEgCABBAz8xEAgAvx8xHzAQLzT-MgUvCAAZcS8yDzH-MgEMAHIfMQ8w-zICDAAyMA80DAAQHxgA
AAwAUD8wED8xcgAgMCAIAPEOAT8wME8xfzIPMV8yTzBATzFvMh8xPzJPMGBfMT-FAP8GLzJfMIBP
Md8woC8x3zDQDzG-MPAVCAccAyIBUJ80DzIvJgEADgAfDyoBEEIwDzQ-LAERnw0AIU8yMQFhvzIP
MF8yNAERrz8AED8eABMyPQFgDzIPMY8y_wAAvQABXgAkMi8ZABJ-EQBgNB8yDzAvCgASMSkBAfgA
An0AEC92AAEVABAyWgAAVgAAFwAgDzASAAIuACMyH28ARR80nzKCAVQvMB80vyIAAGcAQR80LzAR
ACEPNA8AEjHEAEUPMK8ynwEUXw8AAqIBoW8yDzBPMg8xPzKpATF-Mh-EACFPMrABACABEy8eABEw
rAESMP8AAbsBAEsBUh8wHzEfvwE-DzI-vwE2ACIBEHCiAGCgTzQvMUDFAeCAXzQvMTAvNE8xYG80
L5cBAHEAIVBP6wAQD_oBcDEQHzQ-Mj_-AQBLAQFFAVQxDzAAH8gBAssAEh8SAABPATAgLzS6AUEA
DzQf5ABBIC80fysBIDEf8gAAgQAANAAAhwGSMB8xTzBADzQ-xQHwUjIvMEBOYD8xLzI_8AMvMV5A
PzSAHQAfMU4wXRxQHQ8yDBAuQF1MMAwbDpA9G1wgDB4QLRwgPUs8YC0bHBAtaxweQC0rLAAdWwwb
LkAtOxwAHUsMKy4wLRsMGywADQwrDA4OAP8eCwwNKwwOACw7DAs_MB0cDTseADwrTlA8Ky4ALI5g
HF4gDI6AbjB_sC6ALvATZAEd8QU2TzTwAy4ADk8zDzIALsAOLzMPMg0AcA4vMw6wDj0FAvAHDzFN
oAw9DzIMQwwLPQxwHg0MDRuDG9IE8AZAHi0cMwUUBQQTHA4dGzAOPQsjFAUCAKIDCz0LMA4tCyMF
EAC1BAMtCwwwDCsMEwQSAFQrHEAsIw8AYxQDLFAuEwwAdwUUAy5ADi0PAGMOLTAOHQsRABAfEgBD
LQswLREAwgoPKhoUAx0bMAsdDBIAgjoDBAMrDEAsDgBHBRoTBF8ALwQTXwACCBAAGj0PACctC34A
C30AAAIAAHwAEyt7AAACAAF8AI--MAEscP81BEIfH-ARhC809QEuQA4PKg4PMvUBLg0wLg30AS4N
IC4N9QMuDRAZAIAN9AMODA4NEAUAMWROZAwAcC4NVF4NVC4JAPAAfisODY4NEK4LDA8MDwoJDADw
D50OCw8MHwoJrSAtUw4LKgkNUy0wHg1UHikODVQeDQsAE14JADFkTWQIACb0AwcAIv4IBABxDv0I
QP8wB9kAH0vZAGElLxDaAFQRDw8PDtsAUhEfDw8O3AAQLxcAA94AHyreAJwVFd4AEBaeKwTeAFMW
HxQPE94AABcAD94ApCMaHd0AVBsPGQ8Y3QBTGx8ZDxjdAAAXAATdABMd3AAvHk3cAJEUH9wAVCAP
Hg8d3ABTIB8eDx3cAAAXAA-cAKMUJNwAVCUPIw8i3ABTJR8jDyLcAAAXAA-cAF4L4AlWbzQPMT-k
CQAOCQL8BwHoCUAfNA8yGggAyQcCFQAB8gkAZAgkXzInCRM-zQgQMFgIAMcIMi8xLxcAETA8CBEf
KgBEPzAvNP8JARAKABsIAR0AHTEWChAfrQgPGAoCAXEAH28aCgEgHzSGAA0cCgHQCQEqAAQgChEf
XwAeHyAKADkKAs4ACSgKET-DCgMVAAYuCgGYAANXAA84CgAC0gA0LzFPPgoRTzoAAF4ANj8wH0YK
Mz8yLxcAAFcAADQAAU4KYh8yHzFfMG4AAXUBAFQKVy8wTzQPFQABWgoBkQkWMCgAA14KLz8wXAo7
DoQODzEA0PMFIxME8Dv-MAmQDm8nDm0ObQ6QDm0IAKtvKA5sDmwOkA5sCACrbykOaw5rDpAOawgA
DCkABAgAGm1aAD-_CfDYEhqTBQcEACcAByAXAgBPBwAnAEAACxw4QACREAcgFxAHAAcwAgAvEEc-
ABwBfwBCBzAHIAIADz8AJT8QF0C_ACQRMEAArwAHAAcQBwBHIAdCAB1vVzA3QAcwfQAjIBcQfQAR
N4EBD0AAIBJHNwECwgAfIDoBIQJ3AA5-AA9CABsQN4IAPxAXEEAAGf8CBwsEAD8qEF4AHh8_Hg0e
DQAFAAN-Xg0APh0QPZsADCwxNFwAwRAfKjAuDz4QPg0gDQQHBQMAfxBeAF4NAF1RAB0HrQBAAB0A
Hs4HQRAuHQADAA9TADWfHh0gLkAeDR4Q_AAqYEAeDz4gLk4AcBAuDR4AHh1OAEFeDQAt-wAvQB1T
AB3CXyoAXg8_Hk1OEF4QRAAFoQAvAE2hAB-gLyogPg8_AC4tAB4dIE4BAR8d7AEsAqEAAOAABfcA
BQYAECDyAB8gmgEoAZoAPwA_HagAMAxWAHFeDQBODRAdtwAATQFfLh0gLRBVABrxAQoQBBBPKjBu
EI4ALi86Lg09Cg8FABCvjg0Abh0QTh0wTXAADBw5bwD-AyAvKlA_DzowTg0gXg0wHS4NUAMAAUAg
jgCOZQAfjV4AHA7NAMcALRAuDUA_DTA_HSADAB8wYQAxAVwAIFAuXABxMD4NQE5QDQ8ALy4gIQEp
gRAvKmAuDzpQtgBBQC4dQAkAIQAuKgQEfgEBvAARTW4AX1AuDWAtZAAc9QSPKgCODzqODS5tLg1Q
biB_EI4QTQAPvgAr8QUgTyowXg86EG4NAE49AD4dMC4dQGEAMwAuLb4AA8MAD2IAJQS8ACcAPR8B
DwkABT9gLTBCAi4BBQB-AG4dAG4NAMcANw9oAAShjg0Afg0Qbg0gLcYAUDBODRBeYQBvID4dQD0g
ZAAZ-gZeCAQQ-zpKIA7-O0oPPQAO-ztMDz4GADAADz0hAEw_IP1KwwCxLTIzLjMxOTA0NzYGAANu
AJItMC43MTQyODUGACI2OH4AClkE0GYcBPBY9VIgBfRSAxAFADAPOgAHAB8OBgBrfBDzUh4g-lJ6
BVMyNi43Nd8AHzO9GQEAzwDvv-RSIATzUg87EATzUg4FAFsPtAAhoBEOBBC-OTAOvzeSMyDfN2k3
AgYAXz83Xyo-EAAYEd9CAABIAE8wvfAEpQkZ8gIRDgTwAw8WrxUwDxa-FA8TIAcA8QEQDxbfFQ8T
AA8WPxRfDj8UCwABEgBSTxVfDj8bABHfFwAWFSIAIRXfOwASFUkAAQcAPzC_II8AHA0TAVNPNz8q
T-cAUx8qHzcf_wAVfwoAM283HyIAV183HypfGQEKEAAPIwE9QE8VPw4BQAEnAVQfDh8UHysBMn8V
HyYBAAkAAyMAVl8UHw5fKAE0AA8VEgAPMwEqwQQEBAAfOwAOHzoPPQUAPwAdAEAACx8x9w4s0RMR
BPAGOUA5QAk7CSAEAPYEWwkACVsJEAlrCWsJDz4ACesJDgUA-xsQCcsJHiAJqwkeQAmLCR5gCWsJ
HoAJSwkeoAkrCR7ACQsJHuAJHvABDnD3ABkAhQBwMx7gHh8QPis5cR0OLQ5APh0IAJEPPiAOXQ4d
PhwHAFAOLQ4wDu8_QAwgDo0UABB90zUwME49BwCPQDx_HHCc8Bl6AB3wCEUfE_AeHxUOIB5gHh0O
HS4NDg8_MB4dZj6oIA4dDp0ODBAO3QUAfyDeHDDc8CtoAB3RCR8YAB7ADh8aDh0ukBE2Mx0OgAgA
UQ8_YC4NCgBXDFAOHQ4LABdtBwATnQUAMWAOjWM2IA4cBQCPDJBuHKBs8AiQAB3wChsvHSAugA4v
Hy4tDmAOrQ5ADs0OIA7tDgDrNhAAPz8BgAHAEA4NHm0eDQ4cIA4AbgAwDhxQBwAwAAxgBwARgAUA
b44MkIzwB4EAHNGADyLwAg4PPvAADg8kDDlwDg8_0A4tDgQA8AgMoB5NHnAejR4wHs0eMB6NHixA
Hk0eLMM3ICygIAAAJDkQHAUAEAw9OU-wAA4McwINDykDKw8xAB3PKOABAACqAAAABPD-AQAC-wmM
Dy--Of-EsA4PL-7-wg81Dz6gHvD-wR8JAP------B-wD-zX-ww8_oA7-Nf-EDz6w-f-FVgUMBwoj
NTGdBSI3MZ4FPzAuNaAFCX_j-zkF8BH_BAALEAqtBX8DDzcPNfAPCwBEkAke8AMdDz7wDggAHwwH
AB9-Bx7wBR3wDQYAGzIM8AYHAB8MBwAkfwUe8Acd8AsGABsyDPAEBwAfCgcAJH8DHvAJHfAJBgAb
MgzwAgcAHwgHACR-AR7wCx3wBwYAGzIM8AAHAB8GBwAjf_Ae8A0d8AUGABshDNAGAABnAQ8HACF-
wB7wDx3wAwYAGyEMsAYAAGUBDwcAIX_gHvARHfABBgAbIAyQBgAv-gMFABN-DIAe8BP_AwQAC-IC
HQxwHfD-xB0MgB3w-8IdDJAHAIKgHfD-wB0MsAcAgsAd8P__HQzQBwBQ4B3w-7zpAQMIAFABHfD-
utkAAwgAUAMd8P_4XQEDCABQBR3w-7bhAQMIAFIHHfD-tGcCIv_0ygMCIAADCAAjBR5AAAMIACMD
HmAAAwgAIwEegAACCAAi4B6dAAIHACLAHrkAAgcAIqAe1QACBwAhgB7qAA-xAP--xT8T-QMEAAsB
EAE-Ef0FBAALAS8BTxEd-AEGABsAXgEB3QQPBwAjGLANAA8HAB4iwB3NBQ8HACMY0A0ADwcAHiLg
Hb0GDwcAJBkADgAPBwAeIgEdsQcPBwAkGQIOAA8HAB4iAx2lCA8HACQZBA4ADwcAHiIFHZkJDwcA
JBkGDgAPBwAeIgcdjQoPBwAkbwj9BwzwDgUAFG8J-QUM8BAFABRfC-wF8BEEAAxP----v0cMEA9J
Eh4PMQDv8F8oKAT-PxYC-gUC-i4G-h0CTgLuAv4UBv4GBv4HAv4NAv4DAv4CAgYCjgb_DAJOAv4w
Av4iAl4C3gb_OwL_BQb_AQI_Av4RAgYC3gKOAj4CThIGDzIGEv4TAgYC-hYC-hcC-jQC-hAC-ioC
-mMGvkIAEBAbADAHAt43ABH_JgACKwAQA0oA-wA9Bk4C-iMC7gJeAp4G-iRwNRnCKCgErz8C-goC
DgbuVgBgbgI_Bv4JEwAhPgIIAADhAAEaABCuFQCA-gwC-hIC-jeGAKDuAgYCfga_Av4ACwF6BgI_
Au4C3swA0J4C-gECngJ_Bl4G-lCvABEuvwBgCAL_HQbeagAQR0AAMg0Cfi8AgS4CTgYuAv4eRQEQ
MYIA4AAG-iAC-i4CLgJ_Bv4NJgAxDgZuhgAfAegAHOFvPwb_MQKOBo4C-hkGfr0BIFcGigAyCAJe
4QAQzgwAEN4aADBeAo5rABcTzQARfpQAoBcCrgK_Av4TAr7dAXRVBv4LAv4UOQFg-gUCfgJuOQAg
FgK2AEEBAv4LqwAxDAJOHQKBWwb_IQY_Aj4YAOEFAv4SBv4PAv4LBm4Cng0AHyDTABwgjz9cABEu
mgAQAsYAcEQCfgaOAs53AgGUAGH_CALOAh5PAhAEaQAh-gTUAUEGAv4cEgACzQEQLVUBQf4CBq7P
AkACAv4bTwAQvukAFQbdARDeTwBSBQKOAi4VARIelQIxrgJOSgAQFyEBMB0GrgcBQR0C-gPaAFAF
Bv4lBkQAECIkACBOBk0CPw0CruYAHGD-PwsC-m9gADEiBp6TABMWZAFBAgb_HtEAETAmAhAScwGQ
7gL_Mwb_gwKOrgAi-gAqAEGuAv5OEABgDAKuBv4nVwIzfgK_RgAQNJgCAEkAzywC-g4C-lEC-h8G
jqQAHhNssQIwAQKejwMYFkACEAHzAzEGAr6sABALjgBBQgb_Dk8DEAEvAUCuBv6RsQAkDAJwASH_
MzYEUAwC-joGEgAVFj8AEDauAEG_Av5SYwJPLQL_LqsAHhAZiQECtwFBIgL_BqUBUAUC-g8GCAFR
HQJuAq70AxA7ZwBSEQI_AgaCBADHABA6FAABIgIQbmwEEC4rABECzAARLYABEQxWABEcpgFBCQL_
BCEDEARkARIeXwMCcwFQDAbOAo6FAzFEAl5QAE8NAv4ayAAeQjcG-gk8AzEQAr5BAxAG3AMBYQNB
Awb_XHQDAfUBIf4FOQUQAScAExaEAACtAwQNABHeqAASRtYDQAQC-jKBAQSRARAEWAUAvAAFOwBB
HwL_JkcCECDEABACUwRPKwL_HsEAGQDRLtA1bvAEHi8RDxAPER8Q41XwHx8Rbw8fEB8NwA4fEa8P
DxAODw2gDg8R7w8ODw2ADg8R-w8BDg8NcA4PEY8PHl0VU-EBNVAODxF9Hhw_LQ4PDVAODNIawQ4s
Dh0OCw81MA4MPfRXMCwOLcBSIAwtP1VjPj0OCwogDQACGwCUCiAODxAtDmwuDgBDDC0OjCgAMAkt
Dv1XBA0AI048DQDwDDAOCW1_PQ4LGjAOCf0DDgsKUAsJ-QEOCxpQC3Ib-xMLCnALDu0OCxqACx6t
HgsaoBsebR4bGsAKG24bKvAACmsqf1wicDSPE-ADDk-jXqAWHxUO8AEODxaP_l4AKV8QrwkAUMAO
DxbPCQBQoA4PFu8JALGADg8W-xQBDxUOYC4A8A4efQ8VDkAODxZ9HhwOLR4tDxUPEjAODF0eHA4c
LnFWEAvdVWYMPR4cDnwQATQcDpwNADMdDtwLACYPFQwABxcAMwkt3jABIP0FKwEQC0ZTMgsaQBoB
JBpgGgH-Eg7NDgsaoAsOrQ4LGsALDo0OCxrgC44LGvABixrwA4rwFh8BHVAaLxjwCTpdsBsPGg7w
Bw4PGy8ZCgBRBQ4PG08KAFEDDg8bbwoAUAEODxuPCgAg4A6UM2AeDR49Dxo-ASAbHVNVYi4dDxoO
oPoAAAIAcx0LDoAODD0OAJEtCw5gDgw9LgwOAEI9Cw5AHAACEAD0BE0LDiAOC00OHA5sDl0ODxcQ
DgwNABAK8iBAC00OnAwAcAkQCg49DpzlXSAZIAsAcIwOPQ4KGUALABFsCwDwAWAKDi0ObA4tDgoZ
gAoOLW4JAJCgCg6tDgoZwAobXbEZ4AoObQ4KGfABCkcAMfADCi4A3-AFCi4KGfAHKhnwCSkZWB7g
Tf8dAaAOzyAPHw8gHx9CApEg-x4BDx8PHGALAFUDDg8cUAoAxQ81QA4PIE8eLi0uTQ8AQD0OLC4q
AwIQAGQMLQ6sDi0NAFQdDswOHQ0AVA0O7A4NDQBFDvwBHhgAViwObA4sHAB2HQ4MHmweDDoAdi0O
DQ5sDg1YAF9NDmwOTQ0AASoPHxsAFo4ZACz9AwsAEFALABABSFz-AzVgDxz_AQsfNYD7ARqg_gHw
L5ECH-EFIvAIHg8kDyUPJB7wBB4fJS8jHyTsBCAlbwoAULAeHyWvCQARcBIA8Q4ObR8kHkAOHyWN
Do0PJA0PITAODyWNDgwOjQ4PIZcDCQ0AX30OLA59DQACVF0eTB5dDQBUPR6MHj0NAF8dHsweHRoA
Agg0AC8PJFwABigPJIQACg4AYA0OjQ6NHgwA8QYwHyEebQ5tHhsfNUAKGx6tHhsqcAoFBXEqsAob
Hi0eBwXfGy4bKvAECisq8AgqsOUMew8xAB4P0wYiA8kGANQGU20eHD4d1QaCDG0OHB48Dh3WBjAt
PgwhW0MuDA4N2AZCLQ48HhIAAdRcABwDRl4MHjyLBSUMXh8AAd4GVR0ODG4sEAAAIQAUji4AUAkd
Dgx_LAAFDwAkTD4PAFEwDgkdTgYGFBrxBg-pBotDfxQebeoGEW3fBhEd7QYA3gYQHnxbIR0L7QYQ
PQ8AEB6WWxAdkwUC4gYxHgx_EAASCSEBNR4Mng8ARA0ODN4NABgLDQAKGgACAwcBCwAAAwdACgkw
CvsGAdMFIv0B0AUS7cwFH83KBQAQjsgFX4oZ8AOJ_wZPEA-yBhMt-wYQDbcGIS4NAAcA0gABHAFD
DQsOoAkBAAIAIQ4NAgcVLRAAER0EBxEtlF0BVGABBgcBIAADEgARPQgHED0OAEJuDA5NCgcGDwAC
DAcgPQ5oARJNDgcRLQ0AEj0QB0AtDgyOhwIBPwFCLQ4Mbg0AQWAKDh0NABIdSgFSHQ5sDh1OAT8d
bh0aB3QPDgcNIAwujgMHEgc4DK4MFAc3DM4MFgczDO4MFwdGHP4BDBcAdi4MbgwuDB42AFcOHG4c
DjoAAC9jACsBB1wAEC1_ARUeegARPSAAFT0FBwoQABIMlAgFRgcvjk0uB25DTyMOTTAHUV0ODA5d
MQdxHH0ODA59CzEHEAwMAABPZgLZAwUOACEJICAMQi4MDm0NABBdIgUiHl0NAHI9HhxOHB49DQBl
HR4cjhwe4gNfHM4cDg0aAAAINAAZC04AAWgAAnQAGAuBAAkNAADlZpEMDn0eCgkwGh7MAPABHhoZ
QAkaHk0OTR4aKXAJGqxo-wopsAkaHi0eGinwAAkaLhop8AQJKinwCCmw-gZ7DzEAHgDxARQYKwci
8AQpB5DwAB8Rvw8PDsAjBzAPDqDpQCEXvi0HUA8RHifOCgBwYA8RLhfeHxsHcA8Rnh8Ofg00B8Aw
DxGOHRw9Ph0PDTBzSPIADRwNLA0uHQsPNRAMTj0cDwDyAC0LEAw_DVwNHD0_LQsKAAwAAhkAwgoA
DxA_DWwtLA0ePRsAMIw9LgoAQAk_DXwjAAEMAPAaTj08DSwNHk0LChAJfn0uPQsaEAn_Ak0LCjD_
AU0LGjAN7l0LClAdrm3mDDAdXo0XBxDtFQcRrRMHFm0TBx_QLAEfAw0HsfAEHxZvFB8V8AAf7ywR
wP8GIBOgN0GQF74PEw8SgA8WLAFgEw8SYA8WLAGAEw8SUA8W-gQTAAArAfAEFq4fE34dDxIwDxaO
HRwNLh0eHRkAkBAMfh0cDRwtDBoG8QgSEAxeHRwNfA0eLQsPNQAMTg0cDZwNHioBYxU_DdwNDigB
AwoAFgkKADFO3Q4iAS-_AyEBWxAb-wbwCx8a8AQfG28ZHxrwAB8bvxkPGMAPG_8ZDxeg5w2QF74P
GA8XgA8bIQGwGA8XYA8bLhceHxg7BmAPF1APG15-aqEtTg0PFw81MAxujWpoHA0_HQ8XDgABVwIy
bi0MDwAAVwIAOAAFDwAhCgAQABJsDAAiDxoNACIuPRkAE5xNAgYKADNuDYxVAhJuKAASGgoAABQA
RjB_bR46AS8LDTsBQwPRBvAJ8AQfIG8eHx-wAB8gvx4PHMAPIO8eDxyg2kGQF74PHQ8cgA8gOwFg
HQ8cYA8gXAKgHQ8cUA8gXi8dLjYBEBxfAmAgXg0sLSw1AWUcMAxODayIA0INzA0ehAMx7A0OJwFA
Lg38AQMBoA8fPg0sDWwNLE0WAHNODQwdbB0MTwJyXg0ODWwNDpkDIAl_IgEMLAEmjR5jAh8LKQFK
ECWfBkIfJPAEkwbwAfAAHyW-Iw8hwA8l7yMPIaAnQvEXF74PIg8hgA8lHic_DyJ_DQ8hYA8lLhdO
DX4dDyFQDyWODQwNfg0lDUEMng0MFwByMAyODSwNbigBEJ4LAAAoAVF_HUwdTigBQl4djB2mBFQk
Ph3MXRMAAxMBQR1MHT4KAAA6ABFOHQEATwARTh0BAGMAABQAEDAJABE_IgEyng0_JAE-fg0eJgEQ
DzkGew4xAA9qBkpRXh8OXh1sBgBgBhIubQaBDI4NHB08DR5uBrROPQwNDB0MLQwNDugCIzwdEQAC
7gJSDF0MHTw8BQMOAAMdAAJ2BmMMbSwtDE0dACWNPFAFIQx9JwADDgBgTD0MLQxd3AFRPk18DQ7c
AT_OfQ59BpRTnh8Tfg1_BgZ0BpQwDG4dHB0MLRw7ARBeDwAzHSwNOwFjTg0cHQx9KwEAOwEzHQyd
DgBiDxUuDQzdNwEFCgAWCQoAMj4N3C0BL90OhgaJEQ58BhMNigYB-XAQLW4GEVAFBQALASA_DfQP
IQxeDwAwDB0MTgULDwAQCoAGIywNEAACOQEACwAFEQADVAUjDG0OACQPGg8AIx49HQATnQwAGAkM
AGJeDQyNDA3OByNeDTAAFBoMAAF8AgCGBREOVQE-bm0OowaBEA6bBhI_pwYSTpkGAqgGAPYAMC0s
LUIBAKkGcj4NDK0MDR6IAkM_DQzNhAJhLg0M7Qw9ZwJBDP0BDD8Bsx8uDQwtDG0MLQw9mQJzDRxt
HA0MTUEBAR8BBcAGAGkBHx1FAQpAXg2MXZkFL17tuwZsUz4PIm4NvQZALg0MDQ0AQGAMLhfiAEFu
HQtQWwsAFwASCwYFEgwYAAFzC0EtDA1ejAIQft8EALkGAdADIk0cugZyDD4dHI0cHb0DdSQuDRzN
HD0XABJdKQEALQAE1AYARAAC6QcBXAACzQYCcgAQPjQBAgsAEC57AhALDAASLn0CEG54AQ9AARAP
pAZ7DzEAHgHTAQ9uFAmWLw8PEB8PDxA-dhQTPxMAAhcAA4IUCBUAAAQAES-6Bg8ZAAACBAABkhQV
D14AAAQAEB7edQGkbmA1MA4PESzEBMAeGz4MDRwODw0wDgsVC3AcDgsOGw4rl3MA7jkAFAAhPhsS
AAAnAEAKEA4LCAAgWw43ALEsDgoJAA4LLA0OWyIAMRwNDBIAAGILMw5rLjMAIgkANAAVizIAmA0s
DQ57DisODTEAIU47QgAAMQAQECIAQRwNDH4PACAZECAABgIAESyvEyMNLA8AAREARBkwCg4PAKYc
DTwOCglQCg4sDwAAjBIVPA0AMIAKHg0A8QAsHgoZoBoebB4aGcAJGm65D19qKfAEabMDHyBvE_EB
A3sHAeEBAX0HsB8SwA4fFi8UTxUv_BQiDxIDFTAODxIDFVAfFM8VHw0AEWD5G1ADDg8SUBZ7cRT-
FQEPFA6EB4AODxafFB6NDg0V4Q8WDW8VHh8WDi8VHhwNIAARED8VUBsOGy4L-hHVEhAOCw08HhsO
ew4sDbcTURsOmw49aAEAhwER2xsAAJUBPy0O2xgAATEMPd7lE2EODA38Aw2AATEM-QV1AVIMDfwB
DW4BIv0DZQE4HcwdLxVCHi1MLVcBH21XATEQGFcBA6gHAVcBAaoH4R8XwA4fGz8ZDxofGQ8aPxVV
DxegDg8TAAAEAGM-GQ4PF4BfFRwfGQARYEwcAhEAAGpE8AAfGQ08Dg8XUA4PGywNDA5SAQCuAgFd
DgIZAyEOGwIAAhYAEDD2AhMcEwABpgIELQMxDS4LFQAjDRwvAwJPABMLPQAE8gIAEgMAUwAiaw7R
AhIAMQAAEQACOgAiCQA7ABebNQABuA4pDpszAFUNDosODTcDAREAA1QAEhlHAwZSAAI1AxVuMQMC
EQMTHB4AFlARAB8sMQMAAE0DHzwxAzgQHdoBAyoIAdoBASwIsx8cwA4fIC8eDx8PBAAADABpDg8c
oA4PFwAGHwAwDg8c3RUXHxUADAQAEB8lAB9gQgAECUoAABIWBhUAYS4NDx8NLr4GAUMVQDAODyCt
CSEOK9wEEAyrFTAwDgsADyCrDg8AAgYCQC0MDss7FgD_AQA7ABDruQEBsQFzCw0MDvsBDg4AAVgA
WCsOaw4rIQCCDQwOCx5rHgsfAAQoADAMDQ7ZATYNDg0XABEtCwARaxMAEi2yAxcdEwAAmAMOEwAB
xgMAAgATjkoAAAoCAUoABQIAEy3aAycMDQIAA_YDGC0mAAHwAwINAA-0AzgQIhoCAwMJBlMWQB8h
wA5nFjMPJA8EAAAMAFAODyGgDhcJUA4PIYAOGQkGIABiDyMODQ8kvAAxDyFgoB0A-xxiUA4PJQ0M
AgAzDgsOCgARDRkdYTAOC40OCycAAtkBA6QBBQQBAeEBVI0OKw6N3wEAAgAgHkt_WAWaAWULTR6L
Hk28AT8eyx4aAAQPPAAAEwxdAAXOAQqAAADSAQKiAAbKAQvIAAHSAQDrAAjGAQdCAAesBQ_8AQwP
SQl7DzEAHg96CVlzHg0PEB0MHXUJEC27AUMeGz4tbAkRCxEAQA4bHjvqGSIPDVwClD4LDgseCy4L
DlgCACQAIjseFAAlDB1ABFELXgseO1EEArYHIgteIwAFMwJjHQwOC24rNQAjCQA2ABWONABQDC0O
C34yABcdMgAiSz5EABIdbAJHLU57DjQEMB0MHc0LAmYCAL4AAgIAEi1eAiQdDAIAEj1mAhYtDwAA
YAIVPQ0AMIAKHg0AD2QCJR84awlNR38VHm1sCSF-FGAJMxQeLHIJgQxNHhseCy4b9XkBcQkgC0wS
ADAeKw7VfwFyCSAMLQZ7EH5fAQN0CQA2e0MLngsOpwcAjgES3h8AAJ4BERwOAA8cAAJhDSwO2w48
kgFhDQwd3i0MkAEiDfx-CRAN1w4CggET-H8JMhzNHHMBEuxtAS8sTdYKJR84fwlIAcQeQx0PGj16
CaIdDxodDh8bDhwuFAAAOyEjDxrPHiMLLXcJNgwdC9UeARYAAFEhJwsN6R4DOgMBKgAE3x4hHQs7
AyAMLbiCBOIeMwsdC-sCADUAAtkeIg0LHwMBHAACEwABPAAiCQA9ABeeNwARCzcAGZ41ABEd9x4C
MwATEBEABFcAEBkICABXAAVVACEwChEAE2wgAIIwCg49Cw1uCx0AEFAOABEdAgATLUMDAQ8AA0MD
EC0LAA9DAyUPfQl7BFQJEy1uCRcNUAkEZgkBCQUgCy7SBAdlCTIOC67iBAGGA2QtDgvOCw5lCTAO
C_4CBwOrAWQOC-4BCw7wAYcMDgsuC24LLiEAAF8AUA4bbhsOYQAFKAAAKgBDDgtuC00HBWUJUh4L
bgseDQUDlQcBJgAGkQcLEwAEmQcjDotIACEZMDkJEo5EAA9bCVQfOFsJMwDrJgNdCRIdTglYDg8l
DgxXCTF9Dgt0JhFQWgESDF4BJAsODAARCtMBEX0UADJ9DgrfAQOXAQRJAAFBAxBt1gYjHm3TAQAb
CVUbThseDYwBggstHhuOGx4tmQEAVw0-zhsOHAAEDj4AFQxfAATGAQKDAAEiAATKAQWmAATEAQ3N
AADMARN9JAAFygEEfwkDygEAZlgPwgExDzAJXA8xAB4PSScOAhwJBgQAA2UJCJQSBa0SH4AZAAIA
YIEDdycEEQANOgAB3CIPHwAEA0AAAAoTFw8VAA9EAAAfMCMACgNIAB8wpQAEB0gAHyCMAAgVLyMA
HxBrAA4CSgAPbQAPBxMAD20AKS8wDiMADBEfIwAfD5AACzRQDw0QAA8gAAAATI0-DQ4PrAAHRHAP
DQ4TAAkbAGgfNYAPDR4XAABcBv8ODR81oB8NHm8PHh8NHzXADR8Nbhwt8AANbC3wBG3LKDwwDxSP
mY4LzyheDxTPFQ_8LwPDEwO-LzL-FAW7LwIZABMDcAoSIBsABQwADxwACB8VHAAYFBUcAEYwDxIO
TBSRHzVADxIO-xQBDAARYBwAALwAAQ8AUoAPEg7PCwARoBoAFI8aAFLADxIOjwsA7_APEo4NHzXw
AY0c8AOM_Sg7BDYKAv0oEw8OAAISABMBKgAFEgAX4DEABRUAG8A4AAQEACsOoD8ABAQALg6ARwAG
HQAfYE8ABAQEAC8OQFcABAQEAADOhUgfGQ0cAgAQDlgpAGEUFxwCABEM7goD3RMGAgACfBQxEA8X
ABQILwBaCx81IAsWAAK0MRcMPQAAVxkoDgw2ACcagBEAAs8xFQwtABTADQARDNsxIw4MJQAx8AEL
8hRhCxrwAwsOCADfBQsuCxrwBysa8AkqsJYpOwQzCg8EAAsNpxMPLQAMAQYpDy8A--MHEwAPXgBv
BxMADy8ADgC8Kyf-Hr0rABEHX-0BHKD86zJOCBcMBh8MA-0yMf8jAxIALSEwfBUPBAADIR8jZxV1
IA4PJf8jBQwADzsAzB8kOwAzHyQ7ABtFIw79A_IzEi28DQKPDPEAHyEfNUALHyEerR4aK3ALmwxA
K7ALGr4s-wEr8AALGi4aK-AECyor8AgrviwND6QM-2syDw8ueBYjDA2dDAF6FiIOK6IVATQAAO4y
ARUAEEv2DhMtFAAhDA0hACRLDj0AASkAES0ZFicODT0AIQwdDQAAgxgMPgAQDMgRBkAAALETBwIA
Ew00DAMsAAMCAAQmDCYMHQIAYg4KHzVQCnYAAQIAAMYPMnAKDg0AFB0PEQINAB8dTQ8FD-ALhEZ-
FS59nQuGFn8UDi8WDn8RAIcPFF0OTxYOXSQAIG8UEgAUbxEAHg0jAAxHAHQNDxR9Ln0MDgAW-AEM
ATIWMgsfNUeVAhYKE80OChPMBgoijQwCCh_M1ztKD_MLji8uH_ALBWQPGQ4vGw4bAAreCyEOTwEg
Cd0LAUQDD9wLACEOS1kLDNsLJA4rLgBTCh81IAoWABIuVgABVDUCEgAHmx8GEQARDB0DBhEAAmA1
FQwtABTADQASDGo1EwwlAABuNQDaCwJwNR8scDVMBtAID9oL3DIuDQ_EFBUMIwATDBAAAvMWBhoA
EgsPAAGABQ8XAC0PXgAGAbQFDxkAAwcCAAMbAC4NDAIADzYAKi8NDBsABEdQDg383wqfCh81gPoB
GaD53wriRY8jLo0NAAN1F2UNDi8lDg13FwIcAFNtDksObQ4ABFUXKUsOJQAfCyQAAAFxBAlLAEsM
jS6NJAAHAgAFJgAU-dMAAN8HDyUABBkNdgoDHQAAdQowGh81MzcfrTE30w8zRf8hHzXaHwofr9Yf
AALOFBVwCgABMwEBOUUD4B8DWj4CDgkIOkUEXD4lDnxHRQg6RQ8vRQUNOkUDIQEPKQFdD5gfCRav
kB8U74QfEE_AH4FtDg8XcA4PGxtFIS49hQgSUPFEAAIAA4gfBg8AAmYCE007RRFNZgIHO0UBBwEB
EQATbA0AKA8aDgASDDFFAS0BBwsAUk0OjA5NOgEC60MmCxoLAABAASBNbhQAD0EBTA8BHwklrx71
HhTv4R4CfRFQcA4PID8wPgJpPRlQMD4UUDxFAjgBMy0OzJoDUR0O7A4d-QAgDA2FCxENDAAzDx8d
OEUDHAATLTZFFC0zAQEsICIOPQ8AEV2VRg83AQggPY6xAw83AUwPQB4JH680HgIRfRoeEXCtBhMM
iQYSUOw9AjMeYwxtDiwObTUBAr5EJAsw40QlCwr7RAALACIPJBRFCxcAFgktABMJQgAAKAEDWQAA
KAECbwABKAEChwAQCyoBAJwAASsBALAdDy0BDQ9jBnsPMQAeAMABIBounQ1REA8RDxCdDQHLEPMF
DvABTg8RTw8PEE6gDk8Rbw9PEA6QBkUPEA5wCgAzDzVgnAYFDQABCEUDDgAhDF0YBDEsDg0RAAAN
AwOfBgAiABVAoAYDaUICnwYwPQsP3nsRPZ4GED0pIAGwLiWMPmVCAp8GAWVCER2fBgJlQjALXX4J
ADBQDgutQy8JYAgABPEAcApObU4KGYBKDk0OShngV0I-WfAB5wwpMBovE0UBEBW9qgFFAREWbyYA
RQFQFk8UDxVFAUgWbxRPIhAVcAoAATgBCQwAAwdFAg0AEV2vBjINDxVCARNNrwYRHVgQBK8GA0IB
AK0GID0LgCZFDC0O3D4BAwwAAD4BAq0GAjwBE944AS-9ATcBZQ8ZEAMiAU71RAA3AUIbbxlPsw91
-xkBDxoOcLkGIg8aIQEEuwYDEAABfQYAAgAfLREAAxdQ_UsB0g8P_ksFHwv6SyAUC-pLJFAOCwAA
QQEAvgYGSgEPUgFKEB1SAVEfDyAPH1IBAWAlAVIBUCBPHg8fUgFHIG8eT4sPJQ5wCgAALgEEzAYF
DwARLcwGEy0QAIIMHQ6sDh0PH0kBAQpMIA8fRQEB0AYBPwEQHc8GQR0LDxyFAgLOBhMtQAETPc8G
A40CBs8GAUgBArkGD0gBCADPBg9IAVQQIkgBAS8OAUgBARMOAUgBUCVPIw8kSAFQJW8jTyRIAZIl
fyMOfQ8kDnDaBiIPJDoBAtwGAw4AGQwNAFFdDiwOXQ0ABOsGQw8kDkDgBgKEAnAejB5NCw8hRAE0
HsweQAEBFwACPAEC3wYBOAEC1AYBOAEBWgACOAEBcgACJwEHCwAA3wYHCQAPPAEQD7MGew8xAB4P
eA0iQ78PPg15DRKtxU4Beg01DK0O1ktTnQ5MDh2iCAAMABE9oghRTR4dDkx_CREgWQRDHkwOXW8N
Uj0OfA5tGQAxTQ5cZggBwwkyPA6NCwBSPR5MDo2mCDYdDjyoCBEdggAyHA5trAgAWk8gHR4cAG9Q
Cw4dLr3ZCUUPrVIvQ38Ubj3_FlJ9DlwOTQAXQAxtDlwVAQFgDTFdDlzYAAkVARAMCwgTjXQNBxcA
Bi0AEwlEAALdCTJcDk2oUj99bj2pUosUr7IWFs_iFiOOLZQWMS0OjKQGE2C4SQGRSwEaDQGXBjRd
DoyPUgILAAKTBgMMAAATBAJGDQtLBSEOTZECASEWUk0OLA5NGxZSTQ4MDk0XFj9NDk13S3QCCgAC
ERWFPx4eHS4dHj0RAADjTTYsHhx2Sw4RAAimUgKVBwMNAAIPAQ8NABsJQQAIWwAqDx9pACyuPVZL
BwsAD2FLXgXFFABwDQ_PUv-UMq8PTrcGYq8PDj8RHrgGgp8PDg8RLg0eugZgDZ8PDg0_Y04AvQZQ
DYwODU4NAAG-BkENTB4cEAATLCesIB0eDgARPF8FcA0sDg0eHU5QsQLHBnIsDg1_DQ5cHQBAPA4N
XsMJAA0AMAk8HmIAEnwNAEIsDh1ODQBAMA4JDHwAES42ABIaDwAQLhFIAkcAMFALCRAAIR4dHwAQ
UBCzANoDEmzYBjIMLqzaBhKs2gYfbNoGaENvFG4t2wYQbddXAoINEG2uUwF2DREw8Q4RXlkFIQ81
0wYADgARXS9OAKtPEl6HCQLYESFeDIIJAbgNBxoACDQAFQtPACEJIMYJIV4MCwsxMAoOgQAC4QU-
bW4tnFJ6Du4GQx8Zjh3wBlEdDowOHfEGFAwqMwKIUiQMjoRSET0MABM9jA0ADAADfFIEDQAEjA0D
DgACSgwBNAAC-QYEBVEBHgFCPQ4MTg0AEWANABIuDQARgA0AEg4NABKgDQASPTIBPz0OPQkHbQ-9
Bg8ArzQwHC4c2jQPEwALCJlSBJNTBLoGAygBDw8AIQtLAAppAC0PH3kACD8HDzIHAA_IUv_ZDzEA
--------kVBtPTZ9fQ==
:: gfx/1.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA5LTEzIDEzOjUxOjM5Iixtb2RpZmllZD0iMjAyNC0w
OS0xMyAxMzo1MzoxOCIscmV2aXNpb249OV1dbHo0AG0AAAAFMQAA8xR7WzBdPXtibXA9cHh1AEMg
EBAE8PAsZmxhZ3M9MCxwYW5feAgAz3k9MCx6b29tPTh9LDEA----------------------------
------------------------------------51BtPTh9fQ==
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNS0w
NS0xMyAyMTozODo0OSIsc3RvcmVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Il1d
:: map/
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNC0w
OS0wMSAwNzozNDozNSIscmV2aXNpb249MzA3NV1dbHo0AMEAAABZEAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD-------_x0zIwMDAzMDAwNDAwMDYMAC81MIAAWxMxCAATNYAALzYw
AQBbFzb8ABMxDAAPAQBVBHwBAAABEzAMAA_AAVkTMXQAEzB4ABcxjAAPAAFVEzaEAAQMAC81MAEA
--------nvEJIiksaGlkZGVuPWZhbHNlLHBhbl94PTQ3CQDSeT0wLHRpbGVfaD0yOQoAEHcKAIB6
b29tPTF9fQ==
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNS0w
NS0xMyAyMTozODo0OSIsc3RvcmVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Il1d
:: pal/
:: pal/0.pal
b64$LS1bW3BvZCxiZ19jb2xvcj0wLGJsYWNrZXN0X2NvbG9yPTAsY3JlYXRlZD0iMjAyNC0wOC0y
MyAxODo1OTowOSIsaGlkZGVuPXtbMF09ZmFsc2UsZmFsc2UsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0
cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLGZhbHNlLGZhbHNlLGZhbHNlLHRydWUs
dHJ1ZSx0cnVlLHRydWUsZmFsc2UsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0
cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1
ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUs
dHJ1ZSx0cnVlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLHRydWUsdHJ1ZSxmYWxzZSxm
YWxzZSxmYWxzZSxmYWxzZX0saGlkZGVuX3RvZ2dsZXM9e1swXT1mYWxzZSxmYWxzZSx0cnVlLGZh
bHNlfSxodWVfb2Zmc2V0PS0wLjQ3NjQyMzUxNDkyNzY3LGljb249dXNlcmRhdGEoInU4IiwxNiwx
NiwiMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA2
MDEwMDAwMDAwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDYwNjAxMDAwMDAwMDAwMTA3MDcwNzA3MDcw
NzA3MDcwNjA2MDYwMTAwMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA2MDYwNjA2MDEwMDAwMDEwNzA3
MDcwNzA3MDcwNzA3MDcwNzA3MDcwMTAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzAxMDAw
MDAxMDcwNzA2MDYwMTAxMGQwZDAxMDEwNzA3MDEwMDAwMDEwNzA3MDYwNjAxMDEwZDBkMDEwMTA3
MDcwMTAwMDAwMTA3MDcwMTAxMDcwNzA2MDYwZDBkMDcwNzAxMDAwMDAxMDcwNzAxMDEwNzA3MDYw
NjBkMGQwNzA3MDEwMDAwMDEwNzA3MGQwZDAxMDEwZDBkMDYwNjA3MDcwMTAwMDAwMTA3MDcwZDBk
MDEwMTBkMGQwNjA2MDcwNzAxMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDEw
NzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwMTAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAx
MDAiKSxsb2NrZWQ9e1swXT1mYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxz
ZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxm
YWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxz
ZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxm
YWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxz
ZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxm
YWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxz
ZX0sbG93Y29sX2ljb249dHJ1ZSxtb2RpZmllZD0iMjAyNS0wNS0xMyAyMTozODo0OSIsb2twYWxf
dmVyc2lvbj0iMS4yLjIiLHBpY2tlcnNfbW9kZT0ibGluZWFyX2h1ZSIscmV2aXNpb249NTg2Mix0
ZXN0X2N1YmVfY29sb3JzPXtbMF09ezE1LDMxLDR9LHszMSw0LDIwfSx7NCwyMCwyMX0sezEwLDks
MjV9LHs5LDI1LDI0fSx7OCwyNCwyfSx7MjYsMTEsMjd9LHsxMSwyNywzfSx7MjcsMywxOX0sezI4
LDE3LDE5fSx7MjgsMTIsMTZ9LHsxMiwxNiwxfSx7NiwyOSwxM30sezI5LDEzLDE4fSx7MTMsMTgs
MX0sezcsMjMsMTR9LHsyMywxNCwxM30sezE0LDMwLDE4fSx7Nyw2LDIyfSx7NiwyMiw1fSx7MjIs
NSwyMX0sezEsMSwxfSx7MSwxLDF9LHsxLDEsMX19LHRlc3RfbW9kZT0iY3ViZXMiLHRlc3RfcmFt
cF9jb2xvcnM9dXNlcmRhdGEoInU4IiwxMCwyNywiMDAxODA4MTkwOTBhMWEwYjFiMDAwNjAwMDAw
MDAwMDAwMDAwMDMwMDE2MDAwMDAwMDAwMDAwMDAxMzAwMDUwMDAwMDAwMDAwMDAwMDAxMDAwZDAw
MDAwMDAwMDAwMDAwMTAwMDFkMDAwMDAwMDAwMDAwMDAxMTAwMTcwMDAwMDAwMDAwMDAwMDBjMDAw
ZTAwMDAwMDAwMDAwMDAwMWMwMDFlMTIwMjE1MTQwNDFmMGYwNzAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDE0MDQxZjBmMDgxODAyMDAwMDE1MDUxNjA2MDcxNzBlMWUwMDAwMDExMDExMGMxYzFkMGQx
MjAwMDAxMzAzMWIwYjFhMGEwOTE5MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
Iiksd2hpdGVzdF9jb2xvcj03XV1sejQA9gEAABUCAAD9BXVzZXJkYXRhKCJpMzIiLDY0LCIwAQDw
DTRjMzY1YTAwODIzZjM4MDA5ODQ3M2YwMDlmNTEIAJE2NDQ4NzcwMGYBAPA4MDA3NDFmNjUwMGE4
MjU5MjAwZTI0OWJhMDBlZjgzYzUwMGY4YmJkOTAwNzcyYzE2MDBhMjMyMTkwMGQ1NGYyMTAwZjM4
MjVQAPAkY2JjOWMwMDY3NDkxMzAwOWM3MTFhMDBkNmEyMjUwMGVkYzQ1NDAwZmJlMTk5MDAyZDUz
GADwFjMxNmUzMjAwNTBhMzJjMDA4N2Q0NTYwMGJmZjI5NTAwMTY1ODUIAPANNzc5N2QwMDIwYjRi
MzAwNWNkOGQyMDBhY2Y2ZvgAsDcyMjg2MDA1ZTI2IADQOGQzYmVkMDBhZTgxZrAAkDhjNGZjMDA1
MwIAQDAwYjICAEAwMGUzAgBAMDBmNAIAAMgAAAIAQDAwMWQCAEAwMDJlAgBAMDA0NgIAQDAwOWIC
AEAwMGMxAgDgMDA0ZjRiM2UwMDczNmHgAPAXOWU4Zjc0MDBhYTlkODUwMGJlYjVhNDAwNWE1ZTY4
MDA2ODZiNzB4ASA3N9AAoDgxODQ4YTAwYTYCAPEHMDAzZjI3MmEwMDViMzczNDAwNjY0MGAAQDA0
OTRIAPAAMDczYzQwMDY4OTFkNSIp
:: pal/default_00.pal
b64$LS1bW3BvZCxiZ19jb2xvcj0wLGJsYWNrZXN0X2NvbG9yPTAsY3JlYXRlZD0iMjAyNC0wOC0y
MyAxODo1OTowOSIsaGlkZGVuPXtbMF09ZmFsc2UsZmFsc2UsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0
cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVl
LHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0
cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsZmFsc2V9LGhpZGRlbl90b2dnbGVzPXtbMF09ZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2V9LGh1ZV9vZmZzZXQ9LTAuNDg3NTM0NjI2MDM4NzgsaWNvbj11c2Vy
ZGF0YSgidTgiLDE2LDE2LCIwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAwMDAwMDAwMDEwNzA3
MDcwNzA3MDcwNzA3MDYwMTAwMDAwMDAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNjA2MDEwMDAwMDAw
MDAxMDcwNzA3MDcwNzA3MDcwNzA2MDYwNjAxMDAwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDYwNjA2
MDYwMTAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzAxMDAwMDAxMDcwNzA3MDcwNzA3MDcw
NzA3MDcwNzA3MDEwMDAwMDEwNzA3MDYwNjAxMDEwZDBkMDEwMTA3MDcwMTAwMDAwMTA3MDcwNjA2
MDEwMTBkMGQwMTAxMDcwNzAxMDAwMDAxMDcwNzAxMDEwNzA3MDYwNjBkMGQwNzA3MDEwMDAwMDEw
NzA3MDEwMTA3MDcwNjA2MGQwZDA3MDcwMTAwMDAwMTA3MDcwZDBkMDEwMTBkMGQwNjA2MDcwNzAx
MDAwMDAxMDcwNzBkMGQwMTAxMGQwZDA2MDYwNzA3MDEwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDcw
NzA3MDcwMTAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzAxMDAwMDAxMDEwMTAxMDEwMTAx
MDEwMTAxMDEwMTAxMDEwMCIpLGxvY2tlZD17WzBdPWZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlfSxsb3djb2xfaWNvbj10cnVlLG1vZGlmaWVkPSIyMDI1LTA1LTA1IDIw
OjAxOjQ5Iixva3BhbF92ZXJzaW9uPSIxLjIuMiIscGlja2Vyc19tb2RlPSJsaW5lYXJfaHVlIixy
ZXZpc2lvbj00Njc4LHRlc3RfY3ViZV9jb2xvcnM9e1swXT17MTUsMzEsNH0sezMxLDQsMjB9LHs0
LDIwLDIxfSx7MTAsOSwyNX0sezksMjUsMjR9LHs4LDI0LDJ9LHsyNiwxMSwyN30sezExLDI3LDN9
LHsyNywzLDE5fSx7MjgsMTcsMTl9LHsyOCwxMiwxNn0sezEyLDE2LDF9LHs2LDI5LDEzfSx7Mjks
MTMsMTh9LHsxMywxOCwxfSx7NywyMywxNH0sezIzLDE0LDEzfSx7MTQsMzAsMTh9LHs3LDYsMjJ9
LHs2LDIyLDV9LHsyMiw1LDIxfSx7MSwxLDF9LHsxLDEsMX0sezEsMSwxfX0sdGVzdF9tb2RlPSJj
dWJlcyIsdGVzdF9yYW1wX2NvbG9ycz11c2VyZGF0YSgidTgiLDEwLDI3LCIwMDE4MDgxOTA5MGEx
YTBiMWIwMDA2MDAwMDAwMDAwMDAwMDAwMzAwMTYwMDAwMDAwMDAwMDAwMDEzMDAwNTAwMDAwMDAw
MDAwMDAwMDEwMDBkMDAwMDAwMDAwMDAwMDAxMDAwMWQwMDAwMDAwMDAwMDAwMDExMDAxNzAwMDAw
MDAwMDAwMDAwMGMwMDBlMDAwMDAwMDAwMDAwMDAxYzAwMWUxMjAyMTUxNDA0MWYwZjA3MDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMTQwNDFmMGYwODE4MDIwMDAwMTUwNTE2MDYwNzE3MGUxZTAwMDAw
MTEwMTEwYzFjMWQwZDEyMDAwMDEzMDMxYjBiMWEwYTA5MTkwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAiKSx3aGl0ZXN0X2NvbG9yPTddXWx6NADxAQAAFQIAAP0FdXNlcmRhdGEo
ImkzMiIsNjQsIjABAPANNGMzNjVhMDA4MjNmMzgwMDk4NDczZjAwOWY1MQgAkTY0NDg3NzAwZgEA
8DgwMDc0MWY2NTAwYTgyNTkyMDBlMjQ5YmEwMGVmODNjNTAwZjhiYmQ5MDA3NzJjMTYwMGEyMzIx
OTAwZDU0ZjIxMDBmMzgyNVAA8CRjYmM5YzAwNjc0OTEzMDA5YzcxMWEwMGQ2YTIyNTAwZWRjNDU0
MDBmYmUxOTkwMDJkNTMYAPAWMzE2ZTMyMDA1MGEzMmMwMDg3ZDQ1NjAwYmZmMjk1MDAxNjU4NQgA
8A03Nzk3ZDAwMjBiNGIzMDA1Y2Q4ZDIwMGFjZjZm_ACwNzIyODYwMDVlMjYgANA4ZDNiZWQwMGFl
ODFmsACQOGM0ZmMwMDUzAgBAMDBiMgIAQDAwZTMCAEAwMGY0AgAAyAAAAgBAMDAxZAIAQDAwMmUC
AEAwMDQ2AgBAMDA5YgIAQDAwYzECAOAwMDRmNGIzZTAwNzM2YeAA8BM5ZThmNzQwMGFhOWQ4NTAw
YmViNWE0MDA1ODU5NWQwMDY4AgBRMDA2Zja5ABE3AQBQMDA4NjivAfEGMDNmMjcyYTAwNWIzNzM0
MDA2NjQwYABQMDQ5NDQoACA1YxABgDdmYTZjZSIp
:: pal/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTIzIDE4OjU0OjE5Iixtb2RpZmllZD0iMjAyNS0w
NS0xMyAyMTozODo0OSJdXQ==
:: sfx/
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM1Iixtb2RpZmllZD0iMjAyNS0w
NS0xMyAyMTozODo0OSIscmV2aXNpb249NTY5Ml1dbHo0ABoBAABSCAAA8CdweHUAAygAAAQABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDBAUGBwAP-5AICQoLDwwPDQ8ODw8QAPAADQ8RDxIPEw8UDxUP
Fg8XEwDxAQ8YDxkPGg8bDxwPHQ8eDx8UAPEAIA8hDyIPIw8kDyUPJg8nFADxACgPKQ8qDysPLA8t
Dy4PLxQA8QAwDzEPMg8zDzQPNQ82DzcUAP8FOA85DzoPOw88Dz0PPg8-AA--8P8BAOv-J1oBEAYP
IBABIAEgAfAAAhACDBABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDDAAAh9EMAAc
H0AwAPIf-wEA3L-4D0AADUD--7DwcAoA--9kH-8BAP_ZUP----8g
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNS0w
NS0xMyAyMTozODo0OSIsc3RvcmVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Il1d
:: src/
:: src/logic/
:: src/logic/combat.lua
--[[pod_format="raw",created="2024-08-30 06:37:36",modified="2025-05-13 21:38:49",revision=2283]]
--- Combat Logic


function logic_new_fighter(kind)
	local self = {
		health = 20,
		max_health = 30,
		armor = 0,
		max_armor = 3,
		defense = 0,
		max_defense = 20,
		dodge = 0,
		max_dodge = 6,
		special = 0,
		max_special = 12,
		attack = 0,
	}
	
	function self:start_new_turn()
		self.defense = 0
		self.attack = 0
		self.points = {}
		for g in all(gem_colours) do self.points[g] = 0 end
	end
	
	function self:count_points(game, gems, matches)
		for match in all(matches) do
			local count = #(match.positions)
			if match.colour == gem_rainbow then
				-- TODO: keep? delete? what about supercharge?
				foreach(
					gem_colours,
					function(g) self.points[g] += count end
				)
			else
				for p in all(match.positions) do
					local supercharge = (gems:get(p) & gem_supercharge ~= 0) and 1 or 0
					self.points[match.colour] += 1 + supercharge
				end
			end
			game.in_cascade = true -- TODO: keep? delete?
		end
	end
	
	function self:apply_points()
		--self.health = max(0, self.health - [gem_attack])
		local armor_points = 2 * self.points[gem_armor] // 3
		self.armor = min(self.max_armor, self.armor + armor_points)
		self.defense = min(self.max_defense, self.points[gem_defense])
		self.dodge = min(self.max_dodge, self.dodge + self.points[gem_dodge])
		self.special = min(self.max_special, self.special + self.points[gem_special])
		self.attack = self.points[gem_attack]	
	end
	
	return self
end



:: src/logic/creation.lua
--[[pod_format="raw",created="2024-08-30 06:25:09",modified="2025-05-13 21:38:49",revision=3455]]
--- Board Creation Logic


local sc_target <const> = 3


function logic_new_test_cells(tiling, for_editor)
	local grid
	local size
	if tiling == "square" then
		grid = sgrid_new()
		for x = 0, 15 do
			for y = 0, 4 do
				grid:set(pos(x, y), cell_good)
			end
		end
	elseif tiling == "hex" then
		grid = hgrid_new()
--		for i = 0, 3 do
--			for y = i, 12 - i, 2 do
--				grid:set(pos(6 + i, y), cell_good)
--				grid:set(pos(6 - i, y), cell_good)
--			end
--		end
		for x = 0, 16 do
			for y = 0, 8 do
				if y % 2 == x % 2 then
					grid:set(pos(x, y), cell_good)
				end
			end
		end
	end
	return grid
end


------------------------------------------------------------------------


local bag_of_gems = {}
local rejected_gems = {}
local supercharge_counters = {}
for g in all(gem_colours) do supercharge_counters[g] = math.random(2, 10) end


local function random_gem(sc_counts)
	while #bag_of_gems == 0 do
		bag_of_gems = rejected_gems
		rejected_gems = {}
		for g in all(gem_colours) do
			supercharge_counters[g] += 1
			if math.floor((supercharge_counters[g]) % (10.0 / 1.0)) == 0 then
				g |= gem_supercharge
			end
			add(rejected_gems, g)
		end
	end
	local idx = math.random(1, #bag_of_gems)
	local gem = deli(bag_of_gems, idx)
	local colour = gem
--	local colour = gem & gem_colour_mask
--	if sc_counts and (sc_counts[colour] < sc_target) then
--		gem |= gem_supercharge
--		sc_counts[colour] += 1
--	end
	return gem
end


function logic_fill_gem_at(cells, gems, marks, p, sc_counts)
	local cell = cells:get(p) or 0
	if (cell & cell_mask == 0) or (cell & rock_mask != 0) then
		return
	end
	local test = (gems:tiling() == "square") and logic_test_sqr_match_at or logic_test_hex_match_at
	local gem = gems:get(p)
	if not gem then
		local attempts = 0
		local found = false
		while attempts < 16 and not found do
			if gem then
				add(rejected_gems, gem)
			end
			gem = random_gem(sc_counts)
			gems:set(p, gem)
			found = not test(gems, p)
			attempts += 1
		end
		if attempts == 16 then
			gem = gem_gift
			gems:set(p, gem)
		end
		marks:set(p, { name = "new" })
	end
end


local function count_supercharged_gems(gems)
	local counts = {}
	for c in all(gem_colours) do counts[c] = 0 end
	gems:foreachpos(
		function(_, gem)
			local colour = gem & gem_colour_mask
			local supercharge = (gem & gem_supercharge ~= 0)
			if supercharge then
				counts[colour] += 1
			end
		end
	)
	return counts
end


function logic_fill_gems(cells, gems, marks)
	-- TODO: fill in reverse gravity order
	local counts = count_supercharged_gems(gems)
	cells:foreachpos(
		function(p, _)
			logic_fill_gem_at(cells, gems, marks, p, counts)
		end
	)
end


------------------------------------------------------------------------


local function supercharge_gems(gems)
	local counts = count_supercharged_gems(gems)
	for colour in all(gem_colours) do
		while counts[colour] < sc_target do
			local possibilities = {}
			gems:foreachpos(
				function(p, gem)
					local gem_col = gem & gem_colour_mask
					local gem_sc = (gem & gem_supercharge ~= 0)
					if gem_col == colour and not gem_sc then
						add(possibilities, p)
					end
				end
			)
			if #possibilities > 0 then
				local choice = math.random(1, #possibilities)
				local p = possibilities[choice]
				gems:set(p, colour | gem_supercharge)
			end
			counts[colour] += 1
		end
	end
end


function logic_fill_all_gems(cells, gems, marks)
	local counts = {}
	for c in all(gem_colours) do counts[c] = sc_target end
	cells:foreachpos(
		function(p, _)
			logic_fill_gem_at(cells, gems, marks, p, counts)
		end
	)
--	supercharge_gems(gems)
end

:: src/logic/matching.lua
--[[pod_format="raw",created="2024-08-24 08:12:55",modified="2025-05-13 21:38:49",revision=4751]]
--- Matching Logic

-- The matching algorithm has two phases:
--
-- 1. First, a linear sweep through all the gems, and for each gem involved in a match
--    creates a mark registering which direction(s) matched.
-- 2. Then a flood-fill algorithm is used to group matches together.


local function logic_is_matching(gem1, gem2)
	if (not gem1) or (not gem2) then
		return false
	end
	
	gem1 &= gem_colour_mask
	gem2 &= gem_colour_mask
	
	-- Only colored gems can match.
	if (gem1 < gem_attack) or (gem1 > gem_rainbow) then
		return false
	end
	if (gem2 < gem_attack) or (gem2 > gem_rainbow) then
		return false
	end

	return (gem1 == gem2) or (gem1 == gem_rainbow)
		or (gem2 == gem_rainbow)
end


--------------------------------------------------------------------------


local function test_3(gems, p0, p1, p2)
	local gem0 = gems:get(p0)
	local gem1 = gems:get(p1)
	local gem2 = gems:get(p2)
	return logic_is_matching(gem0, gem1)
		and logic_is_matching(gem0, gem2)
		and logic_is_matching(gem1, gem2)
end


local function test_4(gems, p0, p1, p2, p3)
	local gem0 = gems:get(p0)
	local gem1 = gems:get(p1)
	local gem2 = gems:get(p2)
	local gem3 = gems:get(p3)
	return logic_is_matching(gem0, gem1)
		and logic_is_matching(gem0, gem2)
		and logic_is_matching(gem0, gem3)
		and logic_is_matching(gem1, gem2)
		and logic_is_matching(gem1, gem3)
		and logic_is_matching(gem2, gem3)
end


function logic_test_sqr_match_at(gems, p)
	local S = p + pos(0, 1)
	local SS = p + pos(0, 2)
	local N = p + pos(0, -1)
	local NN = p + pos(0, -2)
	local E = p + pos(1, 0)
	local EE = p + pos(2, 0)
	local W = p + pos(-1, 0)
	local WW = p + pos(-2, 0)
	local SE = p + pos(1, 1)
	local SW = p + pos(-1, 1)
	local NE = p + pos(1, -1)
	local NW = p + pos(-1, -1)
	return test_3(gems, SS, S, p) or test_3(gems, S, p, N) or test_3(gems, p, N, NN)
		or test_3(gems, EE, E, p) or test_3(gems, E, p, W) or test_3(gems, p, W, WW)
		or test_4(gems, p, S, SE, E) or test_4(gems, p, S, SW, W) 
		or test_4(gems, p, N, NE, E) or test_4(gems, p, N, NW, W)
end


function logic_test_hex_match_at(gems, p)
	local S = p + pos(0, 2)
	local S_S = p + pos(0, 4)
	local N = p + pos(0, -2)
	local N_N = p + pos(0, -4)
	local SE = p + pos(1, 1)
	local SE_SE = p + pos(2, 2)
	local SW = p + pos(-1, 1)
	local SW_SW = p + pos(-2, 2)
	local NE = p + pos(1, -1)
	local NE_NE = p + pos(2, -2)
	local NW = p + pos(-1, -1)
	local NW_NW = p + pos(-2, -2)
	local E = p + pos(2, 0)
	local W = p + pos(-2, 0)
	return test_3(gems, S_S, S, p) or test_3(gems, S, p, N) or test_3(gems, p, N, N_N)
		or test_3(gems, SE_SE, SE, p) or test_3(gems, SE, p, NW) or test_3(gems, p, NW, NW_NW)
		or test_3(gems, NE_NE, NE, p) or test_3(gems, NE, p, SW) or test_3(gems, p, SW, SW_SW)
		or test_4(gems, p, SE, S, SW) or test_4(gems, p, NE, N, NW)
		or test_4(gems, p, NE, E, SE) or test_4(gems, p, NW, W, SW)
end


local function check_3_and_mark(gems, p0, p1, p2, mark, marks)
	if test_3(gems, p0, p1, p2) then
		marks:merge(p0, mark)
		marks:merge(p1, mark)
		marks:merge(p2, mark)
	end
end


local function check_4_and_mark(gems, p0, p1, p2, p3, mark, marks)
	if test_4(gems, p0, p1, p2, p3) then
		marks:merge(p0, mark)
		marks:merge(p1, mark)
		marks:merge(p2, mark)
		marks:merge(p3, mark)
	end
end


local function mark_sgrid_matches_at(gems, p0, marks)
	check_3_and_mark( gems,
		p0,
		p0 + pos(0, 1),
		p0 + pos(0, 2),
		{ name = "matching", vertical = true }, marks )
	check_3_and_mark( gems,
		p0,
		p0 + pos(1, 0),
		p0 + pos(2, 0),
		{ name = "matching", horizontal= true }, marks )
	check_4_and_mark( gems,
		p0,
		p0 + pos(1, 0),
		p0 + pos(0, 1),
		p0 + pos(1, 1),
		{ name = "matching", vertical = true, horizontal = true }, marks )
end


local function mark_hgrid_matches_at(gems, p0, marks)
	check_3_and_mark( gems,
		p0,
		p0 + pos(0, 2),
		p0 + pos(0, 4),
		{ name = "matching", vertical = true }, marks )
	check_3_and_mark( gems,
		p0,
		p0 + pos(1, 1),
		p0 + pos(2, 2),
		{ name = "matching", horizontal_SE = true }, marks )
	check_3_and_mark( gems,
		p0,
		p0 + pos(1, -1),
		p0 + pos(2, -2),
		{ name = "matching", horizontal_NE = true }, marks )
	local p1 = p0 + pos(1, 1)
	local p2 = p0 + pos(1, -1)
	local p3 = p0 + pos(2, 0)
	if test_4(gems, p0, p1, p2, p3) then
		marks:merge(p0, { name = "matching", vertical = true, horizontal_NE = true, horizontal_SE = true})
		marks:merge(p1, { name = "matching", vertical = true, horizontal_SE = true })
		marks:merge(p2, { name = "matching", vertical = true, horizontal_NE = true })
		marks:merge(p3, { name = "matching", vertical = true, horizontal_NE = true, horizontal_SE = true})
	end
end


local function mark_all_matches(gems)
	local marks = gems:new_grid()
	if gems:tiling() == "square" then
		gems:foreachpos(
			function(p, _gem)
				mark_sgrid_matches_at(gems, p, marks)
			end
		)
	elseif gems:tiling() == "hex" then
		gems:foreachpos(
			function(p, _gem)
				mark_hgrid_matches_at(gems, p, marks)
			end
		)
	end
	return marks
end


---------------------------------------------------------------------------


local function group_this_match(cells, gems, marks, p)
	-- A simple flood-fill algorithm to group all
	-- intersecting linear matches together.
	local colour = gem_rainbow
	local positions = {}
	local one_good_cell = false
	local remaining = { p }
	local rainbows = {}
	while #remaining > 0 do
		local current = deli(remaining)
		local gem = gems:get(current) & gem_colour_mask
		local mark = marks:get(current)
		if mark and mark.name == "matching"
			and (not mark.counted)
			and logic_is_matching(colour, gem)
		then
			if gem == gem_rainbow then
				-- Rainbow gems can be part of multiple matches,
				-- so they need to be unflagged at the end.
				add(rainbows, current)
			else
				colour = gem
			end
			add(positions, current)
			marks:merge(current, { counted = true })
			local cell = cells:get(current)
			if cell and cell & cell_mask == cell_good then
				one_good_cell = true
			end
			local neighbours = gems:neighbours(current)
			foreach(
				neighbours,
				function(n)
					local s = marks:get(n.position)
					if not s then
						return
					end
					if s and s.name == "matching"
						and (not s.counted)
						and s[n.direction]
					then
						add(remaining, n.position)
					end
				end
			)
		end
	end
	foreach(
		rainbows,
		function(p)
			marks:merge(p, { counted = false })
		end
	)
	return { colour = colour, positions = positions, one_good_cell = one_good_cell }
end


function logic_find_matches(cells, gems)
	local marks = mark_all_matches(gems)
	local matches = {}
	marks:foreachpos(
		function(p, mark)
			if mark and mark.name == "matching"
				and (not mark.counted)
			then
				local match = group_this_match(cells, gems, marks, p)
				if match.colour == gem_rainbow then
					-- Ignore, as this is probably a stray rainbow that was unflagged
					-- at the end of `count_this_match`.
					-- TODO: an edge case is when there is a legitime match of
					-- only rainbow gems (e.g. 3 rainbows surrounded by black things).
				else
					add(matches, match)
				end
			end
		end
	)
	return matches, marks
end
:: src/logic/mechanics.lua
--[[pod_format="raw",created="2024-08-30 06:41:59",modified="2025-05-13 21:38:49",revision=3404]]
--- Core Mechanics Logic


------------------------------------------------------------------------


function logic_mark_gravity(cells, gems, marks, gravity)
	local some_gems_are_falling = false
	gems:foreachpos(
		function(p, gem)
			local below = p + gravity
			local distance = 0
			local cell_below = cells:get(below) or cell_none
			while (cell_below & cell_mask != cell_none)
				and (cell_below & rock_mask == 0)
			do
				if (not gems:get(below)) then
					some_gems_are_falling = true
					distance += 1
				end
				below += gravity
				cell_below = cells:get(below) or cell_none
			end
			if distance > 0 then
				marks:set(p, { name = "falling", target = p + distance * gravity })
			end
		end
	)
	return some_gems_are_falling
end


function logic_enact_gravity(gems, marks)
	local fell_gems = {}
	marks:foreachpos(
		function(p, mark)
			if mark.name == "falling" then
				local new_p = mark.target
				add(fell_gems, { gem = gems:get(p), pos = new_p })
				gems:del(p)
				marks:del(p)
			end
		end
	)
	foreach(fell_gems,
		function(fell_gem)
			gems:set(fell_gem.pos, fell_gem.gem)
			marks:del(fell_gem.pos)
		end
	)
end


------------------------------------------------------------------------


function logic_mark_swap(gems, marks, source, target)
	local gem0 = gems:get(source)
	local gem1 = gems:get(target)
	local test = (gems:tiling() == "square") and logic_test_sqr_match_at or logic_test_hex_match_at
	gems:set(source, gem1)
	gems:set(target, gem0)
	local matched = test(gems, target) or test(gems, source)
	gems:set(source, gem0)
	gems:set(target, gem1)
	if not matched then
		return false
	end
	marks:set(source, {
		name = "swapping",
		selected = true,
		target = target,
	})
	marks:set(target, {
		name = "swapping",
		target = source,
	})
	return true
end


function logic_enact_swap(gems, marks)
	local reinsert = {}
	marks:foreachpos(
		function(p, mark)
			if mark.name == "swapping" then
				add(reinsert, { gem = gems:get(p), position = mark.target })
				gems:del(p)
				marks:del(p)
			end
		end
	)
	foreach(
		reinsert,
		function(r) gems:set(r.position, r.gem) end
	)
end


-------------------------------------------------------------------------


function logic_enact_clear(gems, marks)
	marks:foreachpos(
		function(p, mark)
			if mark.name == "matching" then
				gems:del(p)
				marks:del(p)
			end
		end
	)
end

-------------------------------------------------------------------------


function logic_mark_repair(cells, marks, matches)
	local is_something_repaired = false
	foreach(
		matches,
		function(match)
			if match.one_good_cell then
				foreach(
					match.positions,
					function(position)
						local cell = cells:get(position) or 0
						if cell & cell_mask == cell_bad then
							marks:set(position, { name = "repaired" })
							is_something_repaired = true
						end
					end
				)
			end
		end
	)
	return is_something_repaired
end


function logic_enact_repair(cells, marks)
	local to_be_unmarked = {}
	marks:foreachpos(
		function(position, mark)
			if mark.name == "repaired" then
				local cell = cells:get(position)
				cell = (cell & ~cell_mask) | cell_good
				cells:set(position, cell)
				add(to_be_unmarked, position)
			end
		end
	)
	foreach(to_be_unmarked, function(p) marks:del(p) end)
end


----------------------------------------------------------------------


function logic_mark_breakage(cells, gems, marks, matches)
	local something_broke = false
	foreach(
		matches,
		function(match)
			foreach(
				match.positions,
				function(position)
					local neighbours = cells:neighbours(position)
					foreach(
						neighbours,
						function(n)
							local cell = (cells:get(n.position) or 0) & rock_mask
							if cell >= rock_full and cell <= rock_broken then
								marks:set(n.position, { name = "broken" })
								something_broke = true
							end
							local gem = gems:get(n.position) or 0
							if #match.positions > 3 then
								if gem == gem_cat or gem == gem_bat
									or gem == gem_robot_asleep
									or gem == gem_bomb
								then
									marks:set(n.position, { name = "broken" })
									something_broke = true
								elseif gem == gem_robot then
									gems:set(n.position, gem_robot_asleep2)
								end
							elseif gem == gem_bomb then
								marks:set(n.position, { name = "broken", exploded = true })
								something_broke = true
							end
						end
					)
				end
			)
		end
	)
	return something_broke
end


function logic_enact_breakage(cells, gems, marks)
	local to_be_unmarked = {}
	marks:foreachpos(
		function(position, mark)
			if mark.name == "broken" then
				local cell = cells:get(position) or 0
				if cell & rock_mask == rock_full then
					cells:set(position, (cell & cell_mask) | rock_cracked)
				elseif cell & rock_mask == rock_cracked then
					cells:set(position, (cell & cell_mask) | rock_broken)
				elseif cell & rock_mask == rock_broken then
					cells:set(position, (cell & cell_mask))
				end
				local gem = gems:get(position) or 0
				if gem == gem_cat or gem == gem_bat
					or gem == gem_robot_asleep
					or gem == gem_bomb
				then
					gems:del(position)
				end
				if gem == gem_bomb and mark.exploded then
					local neighbours = cells:blast_radius(position)
					foreach(
						neighbours,
						function(p)
							local cell = cells:get(p)
							if cell then
								cells:set(p, cell_bad | (cell & rock_mask))
							end
						end
					)
				end
				add(to_be_unmarked, position)
			end
		end
	)
	foreach(to_be_unmarked, function(p) marks:del(p) end)
end


-----------------------------------------------------------------------


function logic_mark_move(cells, gems, marks)
	local something_moved = false
	local movers = {}
	gems:foreachpos(
		function(position, gem)
			if gem == gem_cat or gem == gem_bat or gem == gem_robot then
				add(movers, position)
			elseif gem == gem_robot_asleep2 then
				gems:set(position, gem_robot_asleep)
			elseif gem == gem_robot_asleep then
				gems:set(position, gem_robot)
			end
		end
	)
	foreach(
		movers,
		function(position)
			local neighbours = cells:neighbours(position)
			local possibilities = {}
			foreach(
				neighbours,
				function(neighbour)
					local cell = cells:get(neighbour.position) or 0
					local gem = gems:get(neighbour.position) or 0
					if (cell & rock_mask == 0)
						and (cell & cell_mask != 0)
						and (gem <= gem_special)
					then
						add(possibilities, neighbour.position)
					end
				end
			)
			if #possibilities > 0 then
				something_moved = true
				local target = possibilities[math.random(1, #possibilities)]
				local moving_gem = gems:get(position)
				gems:del(position)
				local target_gem = gems:get(target)
				gems:set(target, moving_gem)
				local source_gem
				logic_fill_gem_at(cells, gems, marks, position)
				source_gem = gems:get(position)
				marks:set(target, {
					name = "moving",
					source = position,
					target = target,
					moving_gem = moving_gem,
					target_gem = target_gem,
					source_gem = source_gem,
				})
				if moving_gem == gem_bat or moving_gem == gem_robot then
					local cell = cells:get(target)
					cell = cell_bad | (cell & rock_mask)
					cells:set(target, cell)
				end
			end
		end
	)
	return something_moved
end


function logic_enact_move(cells, gems, marks)
	marks:foreachpos(
		function(position, mark)
			if mark.name == "moving" then
				if mark.moving_gem == gem_robot then
				end
			end
		end
	)
	marks:foreachpos(function(p, _) marks:del(p) end)
end
:: src/logic/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTMwIDA2OjI0OjM5Iixtb2RpZmllZD0iMjAyNS0w
NS0xMyAyMTozODo0OSJdXQ==
:: src/constants.lua
--[[pod_format="raw",created="2024-08-24 15:17:10",modified="2025-05-13 21:38:49",revision=4908]]
--- Match3 Global Constants


-- Gems and cells ------------------------------------------------------

-- Color gems
gem_attack = 0x01
gem_dodge = 0x02
gem_defense = 0x03
gem_armor = 0x04
gem_special = 0x05
gem_rainbow = 0x07

gem_colours = { gem_attack, gem_dodge, gem_defense, gem_armor, gem_special }

gem_supercharge = 0x80
gem_colour_mask = 0x7f

-- Black gems
gem_gift = 0x08
gem_bomb = 0x09
gem_cat = 0x0a
gem_bat = 0x0b
gem_robot = 0x0c
gem_robot_asleep = 0x0d
gem_robot_asleep2 = 0x0e

gem_names = {
	[gem_attack] = "Attack",
	[gem_dodge] = "Dodge",
	[gem_defense] = "Defend",
	[gem_armor] = "Armor",
	[gem_special] = "Special",
}


-- Cells
cell_mask = 0x03
cell_none = 0x00
cell_good = 0x01
cell_bad = 0x02

-- Rocks
rock_full = 0x10
rock_cracked = 0x20
rock_broken = 0x30
cell_door = 0x40
cell_chest_air = 0x50
cell_chest_fire = 0x60
cell_chest_day = 0x70
cell_chest_earth = 0x80
cell_chest_water = 0x90
cell_chest_night = 0xa0

rock_mask = 0xf0

:: src/gfx.lua
--[[pod_format="raw",created="2024-08-24 12:06:13",modified="2025-05-13 21:38:49",revision=6751]]
--- Graphics


local cell_width = 29
local cell_height = 29


function gfx_draw_cells(cells)
	local function draw_cell(p, cell)
		local x, y = cells:coords_cell(p)
		local sprite
		if cells:tiling() == "square" then
			if cell & cell_mask == cell_good then
				sprite = 32
				sprite += (p.x + p.y) % 2
			elseif cell & cell_mask == cell_bad then
				sprite = 34
				sprite += p.y % 2
			end
		elseif cells:tiling() == "hex" then
			if cell & cell_mask == cell_good then
				sprite = 40
				sprite += (p.y + (p.x * 3)) % 3
			elseif cell & cell_mask == cell_bad then
				sprite = 43
			end
		end
		spr(sprite, x, y)
		x, y = cells:coords_gem(p)
		if cell and cell & cell_mask == cell_bad then
			pal(53, 58)
		end
		if cell & rock_mask == 0 then
		elseif cell & rock_mask == rock_full then
			spr(48, x, y)
		elseif cell & rock_mask == rock_cracked then
			spr(49, x, y)
		elseif cell & rock_mask == rock_broken then
			spr(50, x, y)
		elseif cell & rock_mask == cell_door then
			spr(51, x, y)
		elseif cell & rock_mask == cell_chest_air then
			spr(52, x, y)
		elseif cell & rock_mask == cell_chest_fire then
			spr(53, x, y)
		elseif cell & rock_mask == cell_chest_day then
			spr(54, x, y)
		elseif cell & rock_mask == cell_chest_earth then
			spr(55, x, y)
		elseif cell & rock_mask == cell_chest_water then
			spr(56, x, y)
		elseif cell & rock_mask == cell_chest_night then
			spr(57, x, y)
		end	
		pal(53, 53)
	end
	cells:foreachpos(draw_cell)
	-- TODO: move border construction out of the hot loop
	local function draw_borders(p, cell)
		local x, y = cells:coords_cell(p)
		if cells:tiling() == "square" then
			local cell_S = cells:get(p + pos(0, 1))
			local cell_W = cells:get(p + pos(-1, 0))
			local cell_E = cells:get(p + pos(1, 0))
			local cell_N = cells:get(p + pos(0, -1))
			if cell & cell_good != 0 then
				if not cell_S or cell_S & cell_good == 0 then
					line(x, y + 28, x + 28, y + 28, 53)
				end
				if not cell_E or cell_E & cell_good == 0 then
					line(x + 28, y, x + 28, y + 28, 53)
				end
				if not cell_N or cell_N & cell_good == 0 then
					line(x, y, x + 28, y, 57)
				end
				if not cell_W or cell_W & cell_good == 0 then
					line(x, y, x, y + 28, 57)
				end
			elseif cell & cell_bad != 0 then
				if cell_N and cell_N & cell_good != 0 then
					line(x, y, x + 28, y, 58)
				end
				if cell_W and cell_W & cell_good != 0 then
					line(x, y, x, y + 28, 58)
				end
			end
		end
	end
--	cells:foreachpos(draw_borders)
end


-----------------------------------------------------------------------


local sprites_color_gem = {
	[gem_attack] = 1,
	[gem_dodge] = 2,
	[gem_defense] = 3,
	[gem_armor] = 4,
	[gem_special] = 5,
}


local sprites_other_gem = {
	[gem_gift] = 8,
	[gem_bomb] = 9,
	[gem_cat] = 10,
	[gem_bat] = 11,
	[gem_robot] = 12,
	[gem_robot_asleep] = 13,
	[gem_robot_asleep2] = 13,
}

--color_gem_skin = math.random(0, 14)
color_gem_skin = 0
local function gem_sprite(gem)
	local base = 128 + color_gem_skin * 16
	local colour = gem & gem_colour_mask
	if colour >= gem_attack and colour <= gem_special then
		local supercharge = ((gem & gem_supercharge) ~= 0) and 8 or 0
		return sprites_color_gem[colour] - 1 + base + supercharge
	else
		return sprites_other_gem[gem]
	end
end


local function scaled_gem(sprite, x, y, size)
	local fullsize <const> = 29
	local w, h = flr(fullsize * size + 0.5) // 2 * 2 + 1, flr(fullsize * size + 0.5) // 2 * 2 + 1
	local x, y = x + ((fullsize - w) / 2), y + ((fullsize - h) / 2)
	sspr(sprite, 0, 0, fullsize, fullsize, x, y, w, h)
end


local function draw_exploded_gem(gem, x, y, clock, new_clock)
	local size = 16 * new_clock
	local size2 = (16 + clock * 16) * new_clock + 8
	
	local colour = 15 + (gem - 1) * 5
	if clock < 0.25 then
		colour = 7
	elseif clock < 0.50 then
		colour += 2
	elseif clock < 0.75 then
		colour += 1
	end

	ovalfill(x + 3 - size, y + 3 - size, x + 26 + size, y + 26 + size, colour)
	oval(x + 3 - size2, y + 3 - size2, x + 26 + size2, y + 26 + size2, colour)
end


function gfx_draw_gems(cells, gems, states, clock)
	local function draw_gem(p, gem)
		local x, y = gems:coords_gem(p)
		local sprite = gem_sprite(gem)
		local cell = cells:get(p)
		if cell and cell & cell_mask == cell_bad then
			pal(53, 58)
		end
		local state = states:get(p)
		if not state or state.name == "broken" then
			spr(sprite, x, y)
		elseif state.name == "new" then
			scaled_gem(sprite, x, y, clock)
		elseif state.name == "matching" then
		elseif state.name == "falling" or state.name == "swapping"
		then
			local dest_x, dest_y = gems:coords_gem(state.target)
			local ix, iy = x + clock * (dest_x - x), y + clock * (dest_y - y)
			spr(sprite, ix, iy)
		elseif state.name == "moving" then
			x, y = gems:coords_gem(state.source, gem)
			local dest_x, dest_y = gems:coords_gem(state.target)
			scaled_gem(gem_sprite(state.target_gem), dest_x, dest_y, 1.0)
		end
		pal(53, 53)	
	end
	gems:foreachpos(draw_gem)
	local new_clock = clock * clock * clock * clock
	gems:foreachpos(
		function(p, gem)
			local x, y = gems:coords_gem(p)
			local sprite = gem_sprite(gem)
			local cell = cells:get(p)
			if cell and cell & cell_mask == cell_bad then
				pal(53, 58)
			end
			local state = states:get(p)
			if state and state.name == "matching" then
				draw_exploded_gem(gem, x, y, clock, new_clock)
			elseif state and state.name == "moving" then
				x, y = gems:coords_gem(state.source, gem)
				local dest_x, dest_y = gems:coords_gem(state.target)
				local ix, iy = x + clock * (dest_x - x), y + clock * (dest_y - y)
				spr(gem_sprite(state.moving_gem), ix, iy)
			end
		end
	)
end


-----------------------------------------------------------------------


function gfx_draw_turns(ox, oy, turn, anim_turn)
	spr(64, ox, oy)
	local hundreds = (turn // 100) % 10
	local tens = (turn // 10) % 10
	local ones = turn % 10
	local anim = anim_turn // 2
	pal(7, 1)
	clip(ox + 7, oy + 3, ox + 7 + 3 * 8, oy + 3 + 8)
	-- hundreds
	if anim == 0 or (turn % 100) > 0 then
		spr(65 + hundreds, ox + 7, oy + 6)
	else
		spr(65 + hundreds, ox + 7, oy + 6 + anim)
		spr(65 + ((hundreds - 1) % 10), ox + 7, oy + 6 + anim - 10)
	end
	-- tens
	if anim == 0 or ones > 0 then
		spr(65 + tens, ox + 7 + 8, oy + 6)
	else
		spr(65 + tens, ox + 7 + 8, oy + 6 + anim)
		spr(65 + ((tens - 1) % 10), ox + 7 + 8, oy + 6 + anim - 10)
	end
	-- ones
	spr(65 + ones, ox + 7 + 2 * 8, oy + 6 + anim)
	spr(65 + ((ones - 1) % 10), ox + 7 + 2 * 8, oy + 6 + anim - 10)
	clip()
	pal(7, 7)
end


-----------------------------------------------------------------------


local function draw_number(mana, zoomed, ox, oy)
	local base_char
	local char_width
	if zoomed then
		base_char = 85
		char_width = 11
		oy -= 3
	else
		base_char = 75
		char_width = 8
	end
	local thousands = (mana // 1000) % 10
	local hundreds = (mana // 100) % 10
	local tens = (mana // 10) % 10
	local ones = mana % 10
	local digits = 4
	if mana < 10 then
		digits = 1
	elseif mana < 100 then
		digits = 2
	elseif mana < 1000 then
		digits = 3
	else
		digits = 4
	end
	ox -= (digits * char_width) -- // 2
	if mana >= 1000 then
		spr(base_char + thousands, ox, oy)
		ox += char_width
	end
	if mana >= 100 then
		spr(base_char + hundreds, ox, oy)
		ox += char_width
	end
	if mana >= 10 then
		spr(base_char + tens, ox, oy)
		ox += char_width
	end
	spr(base_char + ones, ox, oy)
end


function gfx_draw_health_bar(fighter, ox, oy)
	spr(104, ox, oy)
	pal(42, 12)
	pal(58, 8)
	draw_number(fighter.health, false, ox + 40, oy + 3)
	pal()
	rrectfill(ox + 45 + 1, oy + 4 + 1, 120 + 2, 9, 2, 62)
	rrectfill(ox + 45, oy + 4, 120 + 2, 9, 2, 12)
	local h = math.floor(0.5 + 120 * (fighter.health / fighter.max_health))
	rrectfill(ox + 44 + 2, oy + 5, h, 7, 1, 10)
end


function gfx_draw_armor_bar(fighter, ox, oy)
	spr(108, ox, oy)
	pal(42, 32)
	pal(58, 28)
	draw_number(fighter.armor, false, ox + 40, oy + 3)
	pal()
end


function gfx_draw_defense_bar(fighter, ox, oy)
	spr(107, ox, oy)
	pal(42, 27)
	pal(58, 23)
	draw_number(fighter.defense, false, ox + 40, oy + 3)
	pal()
end


function gfx_draw_dodge_bar(fighter, ox, oy)
	spr(106, ox, oy)
	pal(42, 22)
	pal(58, 18)
	draw_number(fighter.dodge, false, ox + 40, oy + 3)
	pal()
end


function gfx_draw_special_bar(fighter, ox, oy)
	spr(109, ox, oy)
	pal(42, 37)
	pal(58, 33)
	draw_number(fighter.special, false, ox + 40, oy + 3)
	pal()
end


function gfx_draw_attack_number(fighter, ox, oy)
	spr(105, ox, oy)
	pal(42, 17)
	pal(58, 13)
	draw_number(fighter.attack, false, ox + 40, oy + 3)
	pal()
end


:: src/hgrid.lua
--[[pod_format="raw",created="2024-08-25 08:16:09",modified="2025-05-13 21:38:49",revision=4466]]
--- Hex Grids

--- Hex grids use the "double height" coordinate system:
---
---     (0,0)         (2,0)         (4,0)
---            (1,1)         (3,1)
---     (0,2)         (2,2)         (4,2)
---            (1,3)         (3,3)
---     (0,4)         (2,4)         (4,4)
---
--- The origin of the grid, `pos(0, 0)`, is at the top left.


-- Local Constants --------------------------------------------------------


local max_width <const> = 17
local max_height <const> = 8


-- Constructors -----------------------------------------------------------


local metatable = {}


function hgrid_new()
	local grid = {}
	metatable.default_origin(grid)
	setmetatable(grid, { __index = metatable })
	for i = 0, max_width * max_height do
		grid[i] = false
	end
	return grid
end


function metatable:new_grid()
	return hgrid_new()
end


function metatable:clone()
	local grid = self:new_grid()
	grid.origin = self.origin
	self:foreachpos(function(p, item) grid:set(p, item) end)
	return grid
end


-- Indexing ------------------------------------------------------------


function metatable:tiling()
	return "hex"
end


function metatable:get(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	return self[p.x + ((p.y // 2) * max_width)]
end


function metatable:set(p, value)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	self[p.x + ((p.y // 2) * max_width)] = value
end


function metatable:merge(p, state)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	local index = p.x + ((p.y // 2) * max_width)
	if not self[index] then
		self[index] = {}
	end
	for k, v in pairs(state) do
		self[index][k] = v
	end
end


function metatable:del(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	self[p.x + ((p.y // 2) * max_width)] = false
end


-- Screen Coordinates ---------------------------------------------------------


function metatable:default_origin()
	self.origin = { x = 116, y = 7 }
end


function metatable:compute_origin()
	local min_p = pos(max_width, max_height)
	local max_p = pos(0, 0)
	self:foreachpos(
		function(position, cell)
			if not cell or cell == 0 then
				return
			end
			if position.x < min_p.x then min_p.x = position.x end
			if position.y < min_p.y then min_p.y = position.y end
			if position.x > max_p.x then max_p.x = position.x end
			if position.y > max_p.y then max_p.y = position.y end
		end
	)
	local width = 1 + max_p.x - min_p.x
	local height = 1 + max_p.y - min_p.y
	self.origin = {
		x = (480 // 2) - ((width * 27) // 2) - (min_p.x * 27) - 4,
--		y = 20 + ((270 - 20) // 2) - ((height * 16) // 2) - (min_p.y * 16) - 8,
		y = 270 - (height * 16) - 16 - 2 - 3
	}
end


function metatable:coords_origin()
	return self.origin.x, self.origin.y
end


function metatable:coords_cell(p)
	local ox, oy = self:coords_origin()
	return ox + p.x * 27, oy + p.y * 16
end


function metatable:coords_gem(p)
	local ox, oy = self:coords_origin()
	return ox + (p.x * 27) + 3, oy + (p.y * 16) + 1
end


function metatable:pos(x, y)
	local ox, oy = self:coords_origin()
	x -= ox
	y -= oy + 1
	local px, py = x // 27, y // 16
	local dx, dy = x - (px * 27), y - (py * 16)
	if dx < 8 then
		if (px + py) % 2 == 0 and dy < 14 + (-2 * dx) then
			px -= 1
			py -= 1
		elseif (px + py) % 2 != 0 and dy > -1 + (2 * dx) then
			px -= 1
		end
	end
	py = (2 * ((py - (px % 2)) // 2)) + (px % 2)
	return pos(px, py)
end


function metatable:distance(p0, p1)
	-- TODO: is this correct?
	return (abs(p0.x - p1.x) + abs(p0.y - p1.y)) // 2
end


-- Iterating ----------------------------------------------------------


function metatable:foreachpos(func)
	for x = 0, max_width do
		for y = x % 2, max_height * 2 - 1, 2 do
			local p = pos(x, y)
			local item = self:get(p)
			if item then
				func(p, item)
			end
		end
	end
end	


function metatable:neighbours(p)
	return {
		{ position = p + pos(1, 1), direction = "horizontal_SE" },
		{ position = p + pos(0, 2), direction = "vertical" },
		{ position = p + pos(-1, 1), direction = "horizontal_NE" },
		{ position = p + pos(-1, -1), direction = "horizontal_SE" },
		{ position = p + pos(0, -2), direction = "vertical" },
		{ position = p + pos(1, -1), direction = "horizontal_NE" },
	}
end


function metatable:blast_radius(p)
	return {
		p + pos(0, 0),
		p + pos(0, -2),
		p + pos(1, -1),
		p + pos(1, 1),
		p + pos(0, 2),
		p + pos(-1, 1),
		p + pos(-1, -1),
	}
end

:: src/in_editor.lua
--[[pod_format="raw",created="2024-08-30 08:13:35",modified="2025-05-13 21:38:49",revision=2701]]
in_editor = {}

local tiling = "square"

local cells = false
local gems = false
local marks = false

local active_tool = 0
local ox, oy = 8, 8
local sx, sy = 32, 32

local tools = {
	[0] = cell_none,
	cell_good,
	cell_bad,
	rock_full,
	rock_cracked,
	rock_broken,
	cell_chest_air,
	cell_chest_fire,
	cell_chest_day,
	cell_chest_earth,
	cell_chest_water,
	cell_chest_night,
	cell_door,
	false,
	false,
	gem_gift,
	gem_bomb,
	false,
	gem_cat,
	gem_bat,
	gem_robot,
	false,
	false,
}



function in_editor:enter()
	if not cells then
		cells = logic_new_test_cells(tiling, true)
		gems = cells:new_grid()
	end
	cells:default_origin()
	gems:default_origin()
	marks = cells:new_grid()
end


function in_editor:exit()
end


function in_editor:update()
	if keyp("s") then
		tiling = "square"
		cells = false
		in_editor:enter()
	end
	if keyp("h") then
		tiling = "hex"
		cells = false
		in_editor:enter()
	end
	local mx, my, mb, _, _ = mouse()
	if mb == 0x1 and mx < 110 then
		mx -= ox
		my -= oy
		local x, y = clamp(mx // sx, 0, 2), clamp(my // sy, 0, 7)
		active_tool = clamp(x + 3 * y, 0, 22)
	elseif mb == 0x1 then
		local mp = cells:pos(mx, my)
		local tool = tools[active_tool]
		if tool == cell_none then
			local cell = cells:get(mp) or cell_none
			cell = (cell & ~cell_mask) | tool
			cells:set(mp, cell)
			gems:del(mp)
		elseif tool == cell_good or tool == cell_bad then
			local cell = cells:get(mp) or cell_none
			cell = (cell & ~cell_mask) | tool
			cells:set(mp, cell)
		elseif active_tool <= 12 then 
			local cell = cells:get(mp) or cell_none
			cell = (cell & cell_mask) | tool
			cells:set(mp, cell)
			gems:del(mp)
		elseif cells:get(mp) and cells:get(mp) & cell_mask != 0 then
			gems:set(mp, tool)
			local cell = cells:get(mp) or cell_none
			cell = (cell & cell_mask)
			cells:set(mp, cell)
		end
	end
	if mb == 0x2 then
		local mp = cells:pos(mx, my)
		local cell = cells:get(mp) or cell_none
		cell = (cell & cell_mask)
		cells:set(mp, cell)
		gems:del(mp)
	end
	if keyp("g") then
		in_game:load_from_editor(tiling, cells, gems)
		return in_game
	end
	return false
end


function in_editor:draw()
	cls(63)
	if not cells then
		return
	end
	local mx, _, _, _, _ = mouse()
	if mx <= 110 then
		window { cursor = "pointer" }
	else
		window { cursor = "crosshair" }
	end
	gfx_draw_cells(cells)
	gfx_draw_gems(cells, gems, marks, 0.0)
	-- Draw the panel
	rectfill(0, 0, 110, 269, 55)
	rectfill(ox, oy, ox + 28, oy + 28, 63)
	spr(33, ox + 1 * sx, oy + 0 * sy)
	spr(34, ox + 2 * sx, oy + 0 * sy)
	spr(48, ox + 0 * sx, oy + 1 * sy)
	spr(49, ox + 1 * sx, oy + 1 * sy)
	spr(50, ox + 2 * sx, oy + 1 * sy)
	spr(52, ox + 0 * sx, oy + 2 * sy)
	spr(53, ox + 1 * sx, oy + 2 * sy)
	spr(54, ox + 2 * sx, oy + 2 * sy)
	spr(55, ox + 0 * sx, oy + 3 * sy)
	spr(56, ox + 1 * sx, oy + 3 * sy)
	spr(57, ox + 2 * sx, oy + 3 * sy)
	spr(51, ox + 0 * sx, oy + 4 * sy)

	spr(8, ox + 0 * sx, oy + 5 * sy)
	spr(9, ox + 1 * sx, oy + 5 * sy)
--	spr(11, ox + 2 * sx, oy + 5 * sy)
	spr(10, ox + 0 * sx, oy + 6 * sy)
	spr(11, ox + 1 * sx, oy + 6 * sy)
	spr(12, ox + 2 * sx, oy + 6 * sy)
--	spr(14, ox + 0 * sx, oy + 7 * sy)
--	spr(15, ox + 1 * sx, oy + 7 * sy)

	local x, y = active_tool % 3, active_tool // 3
	rect(ox + x * sx - 1, oy + y * sy - 1, ox + x * sx + 29, oy + y * sy + 29, 7)
end
:: src/in_game.lua
--[[pod_format="raw",created="2024-08-27 17:11:11",modified="2025-05-13 21:38:49",revision=5964]]
in_game = {}


-- The Board
local tiling = "square"
local gravity = pos(0, 1)

local cells = false
local gems = false
local marks = false

local matches = {}

local prev_cells = false
local prev_gems = false
local prev_game = false

-- State Machine
local editor_requested = false
local substate = false
local clock = 0.0
local interaction = false

local starting_game = {
	turn = 0,
	in_cascade = false,
}
local game = deep_copy(starting_game)
local anim_turn = 0
local star_seed = 37


-----------------------------------------------------------------------


-- Functions for substate need to be global, because of Lua
-- forward-declaration rule for locals.


function creating_the_board()
--	cells = logic_new_test_cells(tiling)
--	gems = cells:new_grid()
	cells:compute_origin()
	gems.origin = cells.origin
	marks = cells:new_grid()
	matches = {}
	game = deep_copy(starting_game)
	game.player = logic_new_fighter()
	anim_turn = 0
	star_seed = math.random(37, 6584587)
	logic_fill_all_gems(cells, gems, marks)
	return creating_missing_gems
end


function creating_missing_gems()
	if clock == 0.0 then
		logic_fill_gems(cells, gems, marks)
	end
	clock += 1.0 / 8.0
	if clock < 1.0 then
		return creating_missing_gems
	end
	-- Clean-up
	marks:foreachpos(
		function(p, mark)
			if mark.name == "new" then
				marks:del(p)
			end
		end
	)
	return moving_things
end


function moving_things()
	if clock == 0.0 and game.turn > 0 then
		local something_moved = logic_mark_move(cells, gems, marks)
		if not something_moved then
			return starting_new_turn
		end
	end
	clock += 1.0 / 16.0
	if clock < 1.0 then
		return moving_things
	end
	logic_enact_move(cells, gems, marks)
	return starting_new_turn
end


function starting_new_turn()
	game.turn += 1
	anim_turn = 20
	game.in_cascade = false
	game.player:start_new_turn()
	return waiting_for_input
end


function waiting_for_input()
	local mx, my, mb, _, _ = mouse()
	if mb == 0x1 then
		local mp = cells:pos(mx, my)
		if gems:get(mp) then
			interaction = { name = "swap", position = mp, start = t() }
			return waiting_for_swap
		end
	end
	if keyp("del") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:set(p, gem_gift)
		marks = cells:new_grid()
		matches = {}
	end
	if keyp("w") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:set(p, gem_rainbow)
		marks:set(p, { name = "new" })
		matches = {}
		return checking_matches
	end
	if keyp("r") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		cells:set(p, (cells:get(p) or 0) | rock_full)
		gems:del(p)
		matches = {}
		return checking_matches
	end
	if keyp("a") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:set(p, gem_attack)
		marks:set(p, { name = "new" })
		matches = {}
		return checking_matches
	end
	if keyp("e") then
		editor_requested = true
		return creating_the_board
	end
	if keyp("z") then
		cells = prev_cells:clone()
		gems = prev_gems:clone()
		marks = cells:new_grid()
		game = deep_copy(prev_game)
	end
	if keyp("1") then color_gem_skin = 0 end
	if keyp("2") then color_gem_skin = 1 end
	if keyp("3") then color_gem_skin = 2 end
	if keyp("4") then
		color_gem_skin = (color_gem_skin - 1) % 6
	end
	if keyp("6") then
		color_gem_skin = (color_gem_skin + 1) % 6
	end
	if keyp("5") then
		local prev = color_gem_skin
		while prev == color_gem_skin do
			color_gem_skin = math.random(0, 5)
		end
	end
	return waiting_for_input
end


function waiting_for_swap()
	local mx, my, mb, _, _ = mouse()
	if mb ~= 0x1 then
		interaction = false
		return waiting_for_input
	end
	local mp = cells:pos(mx, my)
	if cells:distance(mp, interaction.position) ~= 1
		or (not gems:get(mp))
	then
		return waiting_for_swap
	end
	local success = logic_mark_swap(gems, marks, interaction.position, mp)
	interaction = false
	if not success then
		return waiting_for_input
	end
	prev_cells = cells:clone()
	prev_gems = gems:clone()
	prev_game = deep_copy(game)
	return swapping_two_gems
end


function swapping_two_gems()
	clock += 1.0 / 8.0
	if clock < 1.0 then
		return swapping_two_gems
	end
	logic_enact_swap(gems, marks)
	return checking_matches
end


function checking_matches()
	matches, marks = logic_find_matches(cells, gems)
	if #matches > 0 then
		game.player:count_points(game, gems, matches)
		return clearing_gems
	end
	return playing_enemy
end


function clearing_gems()
	clock += 1.0 / 24.0
	if clock < 1.0 then
		return clearing_gems
	end
	logic_enact_clear(gems, marks)
	return repairing_cells
end


local repairing_done = false
function repairing_cells()
	if clock == 0.0 then
		local is_something_repaired = logic_mark_repair(cells, marks, matches)
		if not is_something_repaired then
			return breaking_things
		end
	end
	clock += 1.0 / 8.0
	if clock < 0.5 then
		repairing_done = false
		return repairing_cells
	elseif not repairing_done then
		logic_enact_repair(cells, marks)
		repairing_done = true
		return repairing_cells
	elseif clock < 1.0 then
		return repairing_cells
	end
	return breaking_things
end


local breaking_done = false
function breaking_things()
	if clock == 0.0 then
		local something_broke = logic_mark_breakage(cells, gems, marks, matches)
		if not something_broke then
			return applying_gravity
		end
		breaking_done = false
	end
	clock += 1.0 / 32.0
	if clock < 0.5 then
		return breaking_things
	elseif not breaking_done then
		logic_enact_breakage(cells, gems, marks)
		breaking_done = true
		return breaking_things
	elseif clock < 1.0 then
		return breaking_things
	end
	return applying_gravity
end


function applying_gravity()
	if clock == 0.0 then
		local some_gems_are_falling = logic_mark_gravity(cells, gems, marks, gravity)
		if not some_gems_are_falling then
			return playing_enemy
		end
	end
	clock += 1.0 / 8.0
	if clock < 1.0 then
		return applying_gravity
	end
	logic_enact_gravity(gems, marks)
	return checking_matches
end


local mb_released
function playing_enemy()
	if clock == 0.0 then
		game.player:apply_points()
	end
	
	local _, _, mb = mouse()
	if clock == 0.0 then
		mb_released = (mb == 0)
	end
	if mb_released and mb ~= 0 then
		return creating_missing_gems
	end
	if mb == 0 then
		mb_released = true
	end
	
	clock += 1.0 / 60.0
	return playing_enemy
end


-----------------------------------------------------------------------


function in_game:load_from_editor(ed_tiling, ed_cells, ed_gems)
	tiling = ed_tiling
	if tiling == "square" then
		gravity = pos(0, 1)
	else
		gravity = pos(0, 2)
	end
	cells = ed_cells:clone()
	gems = ed_gems:clone()
	marks = cells:new_grid()
	matches = {}
	game = deep_copy(starting_game)
	substate = creating_the_board
end


-----------------------------------------------------------------------


function in_game:enter()
	editor_requested = false
	if not substate then
		substate = creating_the_board
	end
end


function in_game:exit()
end


function in_game:update()
	local next = substate()
	if next ~= substate then
		clock = 0.0
		substate = next
	end
	if anim_turn > 0 then
		anim_turn -= 1
	end
	if editor_requested then
		return in_editor
	end
	return false
end


function in_game:draw()
	if not cells then
		return
	end
	-- Starry background
	cls(63)
	
	-- Draw the board
	if cells:tiling() == "square" then
		spr(112, 0, 100)
	elseif cells:tiling() == "hex" then
		spr(113, 0, 100)
	end
	gfx_draw_cells(cells)
	gfx_draw_gems(cells, gems, marks, clock)
	
	-- Top bar
	spr(98, (480 // 2) - (35 // 2) - 17 - 4, 5)
	gfx_draw_turns((480 // 2) - (35 //2), 2, game.turn, anim_turn)
	spr(100, (480 // 2) + (35 // 2) + 4, 5)
	
	gfx_draw_health_bar(game.player, 4, 4)
	gfx_draw_armor_bar(game.player, 4, 4 + 20)
	gfx_draw_defense_bar(game.player, 4 + 60, 4 + 20)
	gfx_draw_dodge_bar(game.player, 4, 4 + 40)
	gfx_draw_special_bar(game.player, 4, 4 + 60)
	if game.player.attack ~= 0 then
		gfx_draw_attack_number(game.player, 200, 4 + 60)
	end

--	print("\#7Health: " .. tostr(game.player.health), 11, 30, 15)
--	print("\#7Armor: " .. tostr(game.player.armor), 14, 39, 30)
--	print("\#7Defense: " .. tostr(game.player.defense), 5, 48, 25)
--	print("\#7Dodge: " .. tostr(game.player.dodge), 5, 60, 20)
--	print("\#7Special: " .. tostr(game.player.special), 5, 73, 35)
--	print("\#7Attack: " .. tostr(game.player.attack), 160, 30, 15)
	
	-- Update the cursor
	local mx, my = mouse()
	local cursor_pos = cells:pos(mx, my)
	local cell = cells:get(cursor_pos)
	if cell and cell ~= 0
			and (substate == waiting_for_input or substate == waiting_for_swap) then
		window { cursor = "grab" }
	else
		window { cursor = "" }
	end
	if false then
		rectfill(mx + 4 - 10, my + 10, mx + 36, my + 20, 7)
		print(tostr(cursor_pos.x)..","..tostr(cursor_pos.y), mx + 6 - 10, my + 12, 0)
	end
end
:: src/sgrid.lua
--[[pod_format="raw",created="2024-08-24 07:17:45",modified="2025-05-13 21:38:49",revision=5085]]
--- Square Grids

--- The origin of the grid, `pos(0, 0)`, is at the top left.


-- Local Constants --------------------------------------------------------


local max_width <const> = 16
local max_height <const> = 9


-- Constructors -----------------------------------------------------------


local metatable = {}


function metatable:new_grid()
	return sgrid_new()
end


function sgrid_new()
	local grid = {}
	metatable.default_origin(grid)
	setmetatable(grid, { __index = metatable })
	for i = 0, max_width * max_height do
		grid[i] = false
	end
	return grid
end


function metatable:clone()
	local grid = self:new_grid()
	grid.origin = self.origin
	self:foreachpos(function(p, item) grid:set(p, item) end)
	return grid
end


-- Indexing --------------------------------------------------------------------


function metatable:tiling()
	return "square"
end


function metatable:get(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	return self[p.x + (p.y * max_width)]
end


function metatable:set(p, value)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	self[p.x + (p.y * max_width)] = value
end


function metatable:merge(p, state)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	local index = p.x + (p.y * max_width)
	if not self[index] then
		self[index] = {}
	end
	for k, v in pairs(state) do
		self[index][k] = v
	end
end


function metatable:del(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	self[p.x + (p.y * max_width)] = false
end


function metatable:distance(p0, p1)
	return abs(p0.x - p1.x) + abs(p0.y - p1.y)
end


-- Screen Coordinates ---------------------------------------------------------


function metatable:default_origin()
	self.origin = { x = 121, y = 4 }
end


function metatable:compute_origin()
	local min_p = pos(max_width, max_height)
	local max_p = pos(0, 0)
	self:foreachpos(
		function(position, cell)
			if not cell or cell == 0 then
				return
			end
			if position.x < min_p.x then min_p.x = position.x end
			if position.y < min_p.y then min_p.y = position.y end
			if position.x > max_p.x then max_p.x = position.x end
			if position.y > max_p.y then max_p.y = position.y end
		end
	)
	local width = 1 + max_p.x - min_p.x
	local height = 1 + max_p.y - min_p.y
	self.origin = {
		x = (480 // 2) - ((width * 29) // 2) - (min_p.x * 29),
--		y = 20 + ((270 - 20) // 2) - ((height * 29) // 2) - (min_p.y * 29),
		y = 270 -(height * 29) - 11
	}
end


function metatable:coords_origin()
	return self.origin.x, self.origin.y
end


function metatable:coords_cell(p)
	local ox, oy = self:coords_origin()
	return ox + p.x * 29, oy + p.y * 29
end


function metatable:coords_gem(p)
	local ox, oy = self:coords_origin()
	return ox + p.x * 29, oy + p.y * 29
end


function metatable:pos(x, y)
	local ox, oy = self:coords_origin()
	return pos((x - ox) // 29, (y - oy) // 29)
end


-- Iterating -------------------------------------------------------


function metatable:foreachpos(func)
	local p = pos(0, 0)
	for x = 0, max_width do
		for y = 0, max_height do
			local p = pos(x, y)
			local item = self:get(p)
			if item then
				func(p, item)
			end
		end
	end
end	


function metatable:neighbours(p)
	return {
		{ position = p + pos(1, 0), direction = "horizontal" },
		{ position = p + pos(0, 1), direction = "vertical" },
		{ position = p + pos(-1, 0), direction = "horizontal" },
		{ position = p + pos(0, -1), direction = "vertical" },
	}
end


function metatable:blast_radius(p)
	return {
		p + pos(0, 0),
		p + pos(1, 0),
		p + pos(1, 1),
		p + pos(0, 1),
		p + pos(-1, 1),
		p + pos(-1, 0),
		p + pos(-1, -1),
		p + pos(0, -1),
		p + pos(1, -1),
	}
end

:: src/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTI0IDA3OjE3OjA5Iixtb2RpZmllZD0iMjAyNS0w
NS0xMyAyMTozODo0OSJdXQ==
:: debug.lua
--[[pod_format="raw",created="2024-08-24 12:45:09",modified="2025-05-13 21:38:49",revision=1847]]
-- Detect uninitialized globals and typos
-- from @snowkittykira from the BBS


-- if you're using include(), include this after including everything else,
-- since most included modules will need to assign global variables on load

-- these globals are needed by picotron
_init = _init or false
_draw = _draw or false
_update = _update or false
-- these are used by the picotron terminal
cproj_draw = cproj_draw or false
cproj_update = cproj_update or false
_ = _ or false
_is_terminal_command = _is_terminal_command or false
k = k or false
res = res or false
-- gui needs these
drag_t = drag_t or false

local function unknown_variable (t, k)
  error (debug.traceback ('unknown variable ' .. tostring (k), 2))
end

setmetatable (_G, {
  __index = unknown_variable,
  __newindex = unknown_variable,
})
:: drakma.lua
b64$LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNC0wNC0wNyAwNzo0Mjo0NSIsbW9k
aWZpZWQ9IjIwMjUtMDUtMTMgMjE6Mzg6NDkiLHJldmlzaW9uPTMyNzldXQpfbW9kdWxlcyA9IHt9
CgotLSBBICdyZXF1aXJlJyBmdW5jdGlvbiBzaW1pbGFyIHRvIHN0YW5kYXJkIEx1YS4KLS0gSWRl
YSBmcm9tIGVsZ29waGVyIG9uIHRoZSBCQlMKZnVuY3Rpb24gcmVxdWlyZShuYW1lKQoJbG9jYWwg
Y2FjaGVkID0gX21vZHVsZXNbbmFtZV0KCWlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQKCglsb2Nh
bCBmaWxlbmFtZSA9IGZ1bGxwYXRoKG5hbWUgLi4gJy5sdWEnKQoJbG9jYWwgc3JjID0gZmV0Y2go
ZmlsZW5hbWUpIAoKCWlmICh0eXBlKHNyYykgIT0gInN0cmluZyIpIHBhbmljKCJjb3VsZCBub3Qg
aW5jbHVkZSAiIC4uIGZpbGVuYW1lKQoKCS0tIGh0dHBzOi8vd3d3Lmx1YS5vcmcvbWFudWFsLzUu
NC9tYW51YWwuaHRtbCNwZGYtbG9hZAoJLS0gY2h1bmsgbmFtZSAoZm9yIGVycm9yIHJlcG9ydGlu
ZykKCS0tIG1vZGUgKCJ0IiBmb3IgdGV4dCBvbmx5IC0tIG5vIGJpbmFyeSBjaHVuayBsb2FkaW5n
KQoJLS0gX0VOViB1cHZhbHVlCgktLSBAIGlzIGEgc3BlY2lhbCBjaGFyYWN0ZXIgdGhhdCB0ZWxs
cyBkZWJ1Z2dlciB0aGUgc3RyaW5nIGlzIGEgZmlsZW5hbWUKCWxvY2FsIGZ1bmMsIGVyciA9IGxv
YWQoc3JjLCAiQCIgLi4gZmlsZW5hbWUsICJ0IiwgX0VOVikKCWlmIChub3QgZnVuYykgcGFuaWMo
IlN5bnRheCBlcnJvcjoiLCB0b3N0cihlcnIpKQoKCWxvY2FsIG1vZHVsZSA9IGZ1bmMoKQoJX21v
ZHVsZXNbbmFtZV0gPSBtb2R1bGUKCglyZXR1cm4gbW9kdWxlCmVuZAoKCmZ1bmN0aW9uIHBhbmlj
KC4uLikKCWxvY2FsIGFyZ3MgPSB7IC4uLiB9Cglmb3JlYWNoKAoJCWFyZ3MsCgkJZnVuY3Rpb24o
c3RyKQoJCQlzZW5kX21lc3NhZ2UoMywgeyBldmVudCA9ICJyZXBvcnRfZXJyb3IiLCBjb250ZW50
ID0gc3RyIH0pCgkJZW5kCgkpCglzdG9wKCkKZW5kCgoKLS0gVGFibGUgdXRpbGl0eSBmdW5jdGlv
bnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0KCgpmdW5jdGlvbiBpc19lbXB0eSh0KQoJcmF3ZXF1YWwobmV4dCh0KSwgbmlsKQplbmQKCmZ1
bmN0aW9uIGRlZXBfY29weSh0LCBhbHJlYWR5KQoJaWYgKG5vdCBhbHJlYWR5KSBhbHJlYWR5ID0g
e30KCWlmIHR5cGUodCkgPT0gInRhYmxlIiB0aGVuCgkJaWYgYWxyZWFkeSBhbmQgYWxyZWFkeVt0
XSB0aGVuCgkJCXJldHVybiBhbHJlYWR5W3RdCgkJZW5kCgkJbG9jYWwgbmV3ID0ge30KCQlhbHJl
YWR5W3RdID0gbmV3CgkJZm9yIGssIHYgaW4gcGFpcnModCkgZG8KCQkJbmV3W2tdID0gZGVlcF9j
b3B5KHYsIGFscmVhZHkpCgkJZW5kCgkJcmV0dXJuIG5ldwoJZWxzZQoJCXJldHVybiB0CgllbmQK
ZW5kCgoKZnVuY3Rpb24gdG9zdHJyZWModCkKCWlmIHR5cGUodCkgIT0gInRhYmxlIiB0aGVuCgkJ
cmV0dXJuIHRvc3RyKHQpCgllbmQKCQoJbG9jYWwgcyA9IG5pbAoJZm9yIGssIHYgaW4gcGFpcnMo
dCkgZG8KCQlpZiBub3QocykgdGhlbgoJCQlzID0gInsgIgoJCWVsc2UKCQkJcyAuLj0gIiwgIgoJ
CWVuZAoJCXMgLi49IHRvc3RyKGspIC4uICIgPSAiIC4uIHRvc3RycmVjKHYpCgllbmQKCWlmIG5v
dCBzIHRoZW4KCQlyZXR1cm4gInt9IgoJZW5kCglzIC4uPSAiIH0iCgoJcmV0dXJuIHMKZW5kCgoK
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCgpmdW5jdGlvbiBjbGFtcCh2LCBtaW4sIG1heCkKCWlm
IHYgPCBtaW4gdGhlbgoJCXJldHVybiBtaW4KCWVuZAoJaWYgdiA_IG1heCB0aGVuCgkJcmV0dXJu
IG1heAoJZW5kCglyZXR1cm4gdgplbmQKCgpmdW5jdGlvbiBleHBfZGVjYXkoYSwgYiwgZGVjYXks
IGR0KQoJLS0tIExlcnAgc21vb3RoaW5nLCBidXQgZnJhbWVyYXRlLWluZGVwZW5kYW50LCBmcm9t
IEZyZXlhIEhvbG3DqXIKCS0tLSBodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PUxTTlF1
RkVET3lRCgktLS0gVXNlIGFzIGBhID0gZXhwX2RlY2F5KGEsIGIsIGRlY2F5LCBkdClgCglyZXR1
cm4gYiArIChhIC0gYikgKiBtYXRoLmV4cCgtIGRlY2F5ICogZHQpCmVuZAoKCi0tIFBvcyAtLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLQoKCi0tIFdBUk5JTkc6IGRvIG5vdCBmb3JnZXQgdGhhdCBgcG9zYCBpcyBh
IHJlZmVyZW5jZSB0eXBlLCBub3QgYSB2YWx1ZToKLS0gYXZvaWQgbW9kaWZ5aW5nIGluIHBsYWNl
LgpmdW5jdGlvbiBwb3MoeCwgeSkKCWxvY2FsIHAgPSB1c2VyZGF0YSgiaTE2IiwgMikKCXAueCA9
IHgKCXAueSA9IHkKCXJldHVybiBwCmVuZAoKCi0tIERyYXdpbmcgLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoK
Ci0tIEZyb20gU29waGllIG9uIHRoZSBkaXNjb3JkCmZ1bmN0aW9uIGdldF9kcmF3c3BhY2UoKQog
ICAgcmV0dXJuIHsKICAgICAgICBjYW1feD1wZWVrNCgweDU1MTApLAogICAgICAgIGNhbV95PXBl
ZWs0KDB4NTUxNCksCiAgICAgICAgY2xpcF9sPXBlZWsyKDB4NTUyOCksCiAgICAgICAgY2xpcF90
PXBlZWsyKDB4NTUyYSksCiAgICAgICAgY2xpcF9yPXBlZWsyKDB4NTUyYyksCiAgICAgICAgY2xp
cF9iPXBlZWsyKDB4NTUyZSksCiAgICB9CmVuZAoKCmZ1bmN0aW9uIHNldF9kcmF3c3BhY2UoZHJh
d3NwYWNlKQogICAgcG9rZTQoMHg1NTEwLGRyYXdzcGFjZS5jYW1feCkKICAgIHBva2U0KDB4NTUx
NCxkcmF3c3BhY2UuY2FtX3kpCiAgICBwb2tlMigweDU1MjgsZHJhd3NwYWNlLmNsaXBfbCkKICAg
IHBva2UyKDB4NTUyYSxkcmF3c3BhY2UuY2xpcF90KQogICAgcG9rZTIoMHg1NTJjLGRyYXdzcGFj
ZS5jbGlwX3IpCiAgICBwb2tlMigweDU1MmUsZHJhd3NwYWNlLmNsaXBfYikKZW5k
:: main.lua
--[[pod_format="raw",created="2024-03-30 05:39:34",modified="2025-05-13 21:38:49",revision=6643]]
include "drakma.lua"
include "src/constants.lua"
include "src/sgrid.lua"
include "src/hgrid.lua"
include "src/logic/combat.lua"
include "src/logic/creation.lua"
include "src/logic/matching.lua"
include "src/logic/mechanics.lua"
include "src/gfx.lua"
include "src/in_game.lua"
include "src/in_editor.lua"
--include "debug.lua"


local state = in_editor
--local state = in_game
local next_state = false


function _init()
	window { cursor = "" }
	fetch("pal/0.pal"):poke(0x5000)
	state:enter()
end


function _update()
	if next_state then
		state:exit()
		state = next_state
		state:enter()
	end
	next_state = state:update()
end


function _draw()
	state:draw()
	if key("shift") then
		print(string.format("\014% 3.0f", math.floor(0.5 + stat(1) * 100.0)) .. "%", 460, 100 - 6, 7)
	end
end
:: .info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTIzIDE4OjQ1OjEzIixtb2RpZmllZD0iMjAyNS0w
NS0xMyAyMTozODo0OSIscnVudGltZT0xOCxzdG9yZWQ9IjIwMjQtMDMtMzAgMDY6NTQ6MjQiLHdv
cmtzcGFjZXM9e3tsb2NhdGlvbj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0
aW9uPSJzZngvMC5zZngiLHdvcmtzcGFjZV9pbmRleD0yfSx7bG9jYXRpb249Im1haW4ubHVhIix3
b3Jrc3BhY2VfaW5kZXg9NX0se2xvY2F0aW9uPSJwYWwvMC5wYWwiLHdvcmtzcGFjZV9pbmRleD02
fX1dXQ==
:: [eoc]
