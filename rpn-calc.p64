picotron cartridge // www.picotron.net
version 2

:: doc/
:: gfx/
:: map/
:: sfx/
:: calc.lua
--[[pod_format="raw",created="2026-01-10 20:00:00",modified="2026-01-11 18:16:02",revision=1141]]
function op_plus()
	if depth() < 2 then
		show_error("+: need 2 numbers")
		return
	end
	local result = get(2) + get(1)
	local source = str(get(2)).."+"..str(get(1))
	cmd_drop()
	cmd_drop()
	push(result, source)
end


function op_minus()
	if depth() < 2 then
		show_error("-: need 2 numbers")
		return
	end
	local result = get(2) - get(1)
	local source = str(get(2)).."-"..str(get(1))
	cmd_drop()
	cmd_drop()
	push(result, source)
end


function op_negated()
	if depth() < 1 then
		show_error("~: need 1 number")
		return
	end
	local source = str(get(1)).." neg"
	local result = - get(1)
	cmd_drop()
	push(result, source)
end


function cmd_neg()
	if depth() < 1 then
		show_error("neg: need 1 number")
		return
	end
	local result = - get(1)
	local source = "neg("..str(get(1))..")"
	cmd_drop()
	push(result, source)
end


function op_times()
	if depth() < 2 then
		show_error("*: need 2 numbers")
		return
	end
	local result = get(2) * get(1)
	local source = str(get(2)).."*"..str(get(1))
	cmd_drop()
	cmd_drop()
	push(result, source)
end


function op_slash()
	if depth() < 2 then
		show_error("/: need 2 numbers")
		return
	end
	local result = get(2) / get(1)
	local source = str(get(2)).."/"..str(get(1))
	cmd_drop()
	cmd_drop()
	push(result, source)
end


function op_backslash()
	if depth() < 2 then
		show_error("\\: need 2 numbers")
		return
	end
	local result = get(2) // get(1)
	local source = str(get(2)).."\\"..str(get(1))
	cmd_drop()
	cmd_drop()
	push(result, source)
end


function op_mod()
	if depth() < 2 then
		show_error("%: need 2 numbers")
		return
	end
	local result = get(2) % get(1)
	local source = str(get(2)).."%"..str(get(1))
	cmd_drop()
	cmd_drop()
	push(result, source)
end


function op_pow()
	if depth() < 2 then
		show_error("^2: need 2 numbers")
		return
	end
	local result = get(2) ^ get(1)
	local source = str(get(2)).."^"..str(get(1))
	cmd_drop()
	cmd_drop()
	push(result, source)
end


function cmd_sq()
	if depth() < 1 then
		show_error("^: need 1 number")
		return
	end
	local result = get(1) ^ 2
	local source = str(get(1)).."^2"
	cmd_drop()
	push(result, source)
end


function cmd_sqrt()
	if depth() < 1 then
		show_error("sqrt: need 1 number")
		return
	end
	local result = sqrt(get(1))
	local source = "sqrt("..str(get(1))..")"
	cmd_drop()
	push(result, source)
end

:: config.lua
--[[pod_format="raw",created="2026-01-11 15:26:40",modified="2026-01-11 18:16:02",revision=255]]
config = {
	orientation = "classic", -- "classic" or "inverted"
}
:: entry.lua
--[[pod_format="raw",created="2026-01-10 13:36:29",modified="2026-01-11 18:16:02",revision=1700]]
local buffer = ""


function entry()
	return buffer
end


function update_entry()
	local changed = false
	while peektext() do
		clear_error()
		local c = readtext()
		if is_uppercase(c) then
			pick(letter_to_index(c, "uppercase"), c)
		else
			buffer ..= c
			changed = true
		end
	end
	if changed then
		buffer = parse(buffer)
		undo_checkpoint()
	end
	
	local plain = not key("shift") and not key("ctrl") and not key("alt")
	local shifted = key("shift") and not key("ctrl") and not key("alt")
	local ctrled = not key("shift") and key("ctrl") and not key("alt")
	local ctrl_shifted = key("shift") and key("ctrl") and not key("alt")
	
	if keyp("kp enter") then
		clear_error()
		buffer = parse(buffer.." ", false)
		undo_checkpoint()
	end
	
	if keyp("enter") then
		clear_error()
		if plain then
			cmd_dup()
		end
	end
	
	if keyp("del") then
		clear_error()
		if plain then
			cmd_drop()
		elseif shifted then
			-- TODO: interactive drop
		elseif ctrl_shifted then
			cmd_clear()
		end
	end
	
	if keyp("backspace") then
		clear_error()
		if plain then
			buffer = string.sub(buffer, 1, #buffer - 1)
		elseif ctrled then
			buffer = ""
		elseif shifted then
			cmd_dropfirst()
		elseif ctrl_shifted then
			cmd_clear()
		end
	end
	
	if keyp("tab") then
		clear_error()
		if plain then
			cmd_swap()
		elseif shifted then
			-- TODO: interactive swap
		end
	end
	
	if keyp("pageup") then
		clear_error()
		if plain then
			if config.orientation == "inverted" then
				cmd_unroll()
			else
				cmd_roll()
			end
		end
	end
	
	if keyp("pagedown") then
		clear_error()
		if plain then
			if config.orientation == "inverted" then
				cmd_roll()
			else
				cmd_unroll()
			end
		end
	end
end

:: error.lua
--[[pod_format="raw",created="2026-01-10 20:54:23",modified="2026-01-11 18:16:02",revision=1033]]
local error_msg = ""
local welcome_msg = "   rpn-calc\n\ntype ? for help"


function show_error(msg)
	error_msg = msg
end


function clear_error()
	error_msg = ""
	welcome_msg = ""
end


function draw_error(position)
	if welcome_msg ~= "" then
		local width = get_display():width()
		local height = get_display():height()
		local msg = "\014"..welcome_msg
		local w, h = print(msg, -1000, -1000)
		w += 1000; h += 1000
		w += 20; h += 14
		local x = (width - w) // 2
		local y = (height - h) // 2
		rrectfill(x + 2, y + 2, w - 1, h - 1, 0, 0)
		rrectfill(x, y, w - 1, h - 1, 0, 5)
		rrect(x + 2, y + 2, w - 5, h - 5, 0, 13)
		print(msg, x + 10, y + 7, 7)
		return
	end
	if error_msg == "" then
		return
	end
	local width = get_display():width()
	local msg = "\014"..error_msg
	local w, h = print(msg, -1000, -1000)
	w, h = w + 1000, h + 1000
	local y = 0
	if position == "bottom" then
		y = get_display():height() - h - 5
	end
	rrectfill(0, y, width, h + 5, 0, 8)
	print(msg, (width - w) // 2, y + 3, 7)
end

:: main.lua
--[[pod_format="raw",created="2026-01-10 13:14:25",modified="2026-01-11 18:16:02",revision=1753]]
include "config.lua"
include "stack.lua"
include "calc.lua"
include "parser.lua"
include "entry.lua"
include "error.lua"


local bg <const> = 2
local bg_alt <const> = 4
local fg <const> = 7
local fg_alt <const> = 0


local blink_timer = 0
local blink_speed <const> = 20


local undo_stack


function undo_checkpoint()
	undo_stack:checkpoint()
end


function _init()
	window {
		title = "RPN Calc",
		width = 136, height = 136,
		pauseable = false
	}
	
	undo_stack = create_undo_stack(
		function()
			local state = {
				stack = get_stack_state()
			}
			return state
		end,
		function(state)
			if type(state) == "table" and state.stack then
				set_stack_state(state.stack)
			end
		end
	)
end


function _update()
	blink_timer += 1
	blink_timer %= blink_speed * 2
	update_entry()
	if key("ctrl") then
		if key("shift") and keyp("z") then
			undo_stack:redo()
		elseif keyp("z") then
			undo_stack:undo()
		end
		if keyp("y") then
			undo_stack:redo()
		end
		if keyp("o") then
			if config.orientation == "classic" then
				config.orientation = "inverted"
			else
				config.orientation = "classic"
			end
		end
	end
	local mx, my, mb, _, wheel_y = mouse()
	if mb ~= 0 then
		clear_error()
	end
end


local entry_height <const> = 14
local stride <const> = 13


local function draw_stack_row(idx, y, width)
	if idx % 2 == 0 then
		rrectfill(0, y, width, stride, 0, bg)
	else
		rrectfill(0, y, width, stride, 0, bg_alt)
	end
	local item = get_item(idx)
	if item then
		print(index_to_letter(idx, "uppercase"), width - 6, y + 3, fg_alt)
		local value_str = str(item.value)
		local value_w = print(value_str, 0, -1000, 0)
		local source_w = print("\014"..item.source, 0, -1000, 0)
		if source_w + 2 < width - 12 - value_w then
			print("\014"..item.source, 2, y + 4, 0)
		elseif item.source ~= "" then
			print("...", 2, y + 4, 0)
		end
		print(value_str, width - 12 - value_w, y + 3, fg)
	end
end


function draw_entry(y)
	local entry_text = entry()
	local x_end = print(entry_text, 4, y + 4, fg)
	if (peek(0x547f) & 0x10) > 0 then
		if blink_timer <= blink_speed then
			rrectfill(x_end, y + 2, 6, 11, 0, entry_height)
		end
	else
		rrect(x_end, y + 2, 6, 11, 0, entry_height)
	end
end


function _draw()
	local width = get_display():width()
	local height = get_display():height()
	cls(0)
	-- The stack
	if config.orientation == "inverted" then
		local idx = 1
		for y = entry_height - 1, height, stride do
			draw_stack_row(idx, y, width)
			idx += 1
		end
		line(width - 9, entry_height - 1, width - 9, height, 0)
		draw_entry(-1)
		draw_error("bottom")
	else
		local idx = 1
		for y = height - entry_height - stride + 1, - stride, - stride do
			draw_stack_row(idx, y, width)
			idx += 1
		end
		line(width - 9, 0, width - 9, height - entry_height, 0)
		draw_entry(height - 14)
		draw_error("top")
	end
end


-----------------------------------------------------------------------------------------
-- Utils
-----------------------------------------------------------------------------------------


function str(v)
	if type(v) == "nil" then
		return "nil"
	elseif type(v) == "bool" then
		return v and "true" or "false"
	elseif type(v) == "number" then
		local s
		if v == 0 then
			s = "0"
		elseif abs(v) >= 0.001 and abs(v) <= 999999999999 then
			s = string.format("%f", v)
			if string.find(s, "%.") then
				s = string.gsub(s, "0*$", "")
				s = string.gsub(s, "%.$", "")
			end
		else
			s = string.format("%99e", v)
		end
--		local s = tostr(v)
--		s = string.gsub(s, "%.0$", "")
		return s
	elseif type(v) == "string" then
		return pod(v)
	elseif type(v) == "table" then
		local str = "{"
		for k, v in pairs(v) do
			str ..= stringify(k).."="..stringify(v)..","
		end
		return str.."}"
	else
		return "**unknown type**"
	end
end

:: parser.lua
--[[pod_format="raw",created="2026-01-10 14:19:08",modified="2026-01-11 18:16:02",revision=1652]]
local op_funcs = {
	["+"] = op_plus,
	["-"] = op_minus,
	["~"] = op_negated,
	["*"] = op_times,
	["/"] = op_slash,
	["\\"] = op_backslash,
	["%"] = op_mod,
	["^"] = op_pow,
	["@"] = cmd_sq,
	["$"] = cmd_sqrt,
}


local cmd_funcs = {
	["drop"] = cmd_drop,
	["dup"] = cmd_dup,
	["swap"] = cmd_swap,
	["neg"] = cmd_neg,
	["sq"] = cmd_sq,
	["sqrt"] = cmd_sqrt,
}


function parse(buffer, entered)
	local maybe_more = true
	while #buffer > 0 and maybe_more do
		maybe_more = false
		local c = buffer[1]
		local op_func = op_funcs[c]
		if is_number_char(c) then
			buffer, maybe_more = parse_number(buffer, entered)
		elseif is_space(c) then
			buffer, maybe_more = string.sub(buffer, 2), true
		elseif op_func then
			op_func()
			buffer, maybe_more = string.sub(buffer, 2), true
		elseif is_lowercase(c) then
			buffer, maybe_more = parse_identifier(buffer, entered)
--		elseif is_uppercase(c) then
--			pick(string.byte(c) - string.byte("A") + 1)
--			buffer, maybe_more = string.sub(buffer, 2), true
		else
			show_error("unknown character: "..c)
			buffer, maybe_more = string.sub(buffer, 2), true
		end
	end
	return buffer
end


function parse_number(buffer, entered)
	local pos = 1
	while is_number_char(buffer[pos]) do
		pos += 1
	end
	if pos > 1 and (pos - 1 < #buffer or entered) then
		local number = tonumber(string.sub(buffer, 1, pos - 1))
		push(number)
		return string.sub(buffer, pos), true
	end
	return buffer, false
end


function parse_identifier(buffer, entered)
	local pos = 1
	while is_lowercase(buffer[pos]) do
		pos += 1
	end
	if pos > 1 and (pos - 1 < #buffer or entered) then
		local identifier = string.sub(buffer, 1, pos - 1)
		if #identifier == 1 then
			pick(letter_to_index(identifier, "lowercase"), identifier)
		else
			local cmd_func = cmd_funcs[identifier]
			if cmd_func then
				cmd_func()
			else
				show_error([[unknown command: "]]..identifier..[["]])
			end
		end
		return string.sub(buffer, pos), true
	end
	return buffer, false
end


-------------------------------------------------------------------------------------------------


function is_space(char)
	if not char then return false end
	return char == " "
end


function is_number_char(char)
	if not char then return false end
	return (char >= "0" and char <= "9") or char == "."
end


function is_uppercase(char)
	if not char then return false end
	return char >= "A" and char <= "Z"
end


function is_lowercase(char)
	if not char then return false end
	return char >= "a" and char <= "z"
end

:: stack.lua
--[[pod_format="raw",created="2026-01-10 18:50:54",modified="2026-01-11 18:16:02",revision=1246]]
local stack = { }


function get_stack_state()
	return stack
end


function set_stack_state(stack_state)
	stack = stack_state
end


function depth()
	return #stack
end


function index_to_letter(idx, uppercase)
	if idx > 26 then return "" end
	local base = (uppercase == "uppercase") and "A" or "a"
	return string.char((#stack - idx) + string.byte(base))
end


function letter_to_index(char, uppercase)
	local base = (uppercase == "uppercase") and "A" or "a"
	local result = #stack - (string.byte(char) - string.byte(base))
	if result < 1 then
		return nil -- TODO: something safer?
	end
	return result
end


function get_item(index)
	local item = stack[#stack - (index - 1)]
	return item
end


function get(index)
	local item = get_item(index)
	return item and item.value or nil
end


function push_item(item)
	if not item or type(item) ~= "table" then
		return
	end
	add(stack, item)
end


function push(number, source)
	if not number or type(number) ~= "number" then
		return
	end
	add(stack, { value = number, source = source or "" })
end


-----------------------------------------------------------------------------------
-- Interactive Stack Manipulation
-----------------------------------------------------------------------------------


function pick(index, letter)
	if (not index) or (index > #stack) then
		show_error("pick: nothing on "..string.lower(letter))
		return
	end
	local value = get(index)
	if value then
		push(value)
	end
end


-----------------------------------------------------------------------------------
-- Commands
-----------------------------------------------------------------------------------


function cmd_drop()
	if #stack < 1 then
		show_error("drop: nothing on the stack")
		return
	end
	_ = deli(stack)
end


function cmd_dropfirst()
	if #stack < 1 then
		show_error("dropfar: nothing on the stack")
		return
	end
	_ = deli(stack, 1)
end


function cmd_clear()
	if #stack < 1 then
		show_error("clear: nothing on the stack")
		return
	end
	stack = {}
end


function cmd_dup()
	if #stack < 1 then
		show_error("dup: nothing on the stack")
		return
	end
	pick(1)
end


function cmd_swap()
	if #stack < 2 then
		show_error("swap: need 2 values")
		return
	end
	stack[#stack - 0], stack[#stack - 1] =
		stack[#stack - 1], stack[#stack - 0]
end


function cmd_roll()
	if #stack < 1 then
		show_error("dup: nothing on the stack")
		return
	end
	local far_item = deli(stack, 1)
	add(stack, far_item)
end


function cmd_roll()
	if #stack < 1 then
		show_error("roll: nothing on the stack")
		return
	end
	local far_item = deli(stack, 1)
	add(stack, far_item)
end


function cmd_unroll()
	if #stack < 1 then
		show_error("unroll: nothing on the stack")
		return
	end
	local bottom_item = deli(stack)
	add(stack, bottom_item, 1)
end

:: .info.pod
--[[pod,created="2025-11-13 21:07:43",modified="2026-01-11 18:16:02",runtime=24,workspaces={{location="main.lua",workspace_index=1},{location="gfx/0.gfx",workspace_index=2},{location="map/0.map",workspace_index=3},{location="sfx/0.sfx",workspace_index=4}}]]
:: doc/.info.pod
--[[pod,created="2026-01-10 13:20:37",modified="2026-01-11 18:16:02"]]
:: doc/rcalc.md
b64$LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNi0wMS0xMCAxMjo0MTo0OCIsbW9k
aWZpZWQ9IjIwMjYtMDEtMTEgMTg6MTY6MDIiLHJldmlzaW9uPTE3NDNdXQpSUE4gY2FsY3VsYXRv
cgoKRGVzaWduOiBzYW1lIGtleSBzZXF1ZW5jZSBmb3IgaW50ZXJhY3RpdmUgdXNlIGFuZCBleHBy
ZXNzaW9ucy4gSS5lLiB1c2UgZW50ZXIKYmV0d2VlbiBlbnRyaWVzIGZvciBzdGVwIGJ5IHN0ZXAg
ZGlzcGxheSwgb3Igc3BhY2UgZm9yIGNhbGN1bGF0aW5nIGFuIGV4cHJlc3Npb24KaW4gYSBzaW5n
bGUgZ28uCgpObyBvbi1zY3JlZW4ga2V5Ym9hcmQ6IHVzZSB0aGUgY29tcHV0ZXIncyBrZXlib2Fy
ZC4KCkRpc3BsYXkgdGhlIHN0YWNrLCBhcyB3ZWxsIGFzIGFueSB1c2VyLWRlZmluZWQgdmFyaWFi
bGVzIGFuZCBmdW5jdGlvbnMuCgpPbmUga2V5IG9wZXJhdGlvbnM6ICsgLSB_KG5lZ2F0aW9uKSAq
IC8gXiAlIFwgIQoKSW1tZWRpYXRlIHN0YWNrIG1hbmlwdWxhdGlvbjoKCi0gYGR1cGA6IFBnRG93
bgotIGBvdmVyYCwgYHBpY2tgOiBob2xkIFNoaWZ0ICsgaGl0IFBhZ2VEb3duIG11bHRpcGxlIHRp
bWVzCi0gYGRyb3BgOiBQZ1VwCi0gYGRyb3BuYDogaG9sZCBTaGlmdCArIGhpdCBQYWdlVXAgbXVs
dGlwbGUgdGltZXMKLSBgc3dhcGA6IFRhYgotIGByb3RgOiBTaGlmdCtUYWIKLSBlZGl0IEE6IElu
c2VydAotID8-PzogU2hpZnQrSW5zZXJ0CgpJbnRlcmFjdGl2ZSBwaWNrOiBzaGlmdCArIHN0YWNr
IGxldHRlcgoKQXNzaWduIHZhcmlhYmxlOiAiOiIgKyBsb3dlcmNhc2UgaWRlbnRpZmllcgoKRnVu
Y3Rpb24gY2FsbDogc3RhcnRzIHdpdGggYSBsb3dlcmNhc2UgbGV0dGVyLgoKVmFyaWFibGUgYW5k
IGZ1bmN0aW9uIGRlZmluaXRpb246IGxvd2VyY2FzZSB3b3JkLCB0aGVuICI9IiwgdGhlbiBleHBy
ZXNzaW9uLAp0aGVuIGVudGVyLiBFeHByZXNzaW9uIGlzIGEgc2VxdWVuY2Ugb2YgbnVtYmVycywg
b3BlcmF0aW9ucywgbG93ZXJjYXNlIHdvcmRzIGFuZAp1cHBlcmNhc2UgbGV0dGVycyBzZXBhcmF0
ZWQgYnkgc3BhY2Uu
:: doc/todo.md
b64$LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNi0wMS0xMSAxNzowNTowNCIsbW9k
aWZpZWQ9IjIwMjYtMDEtMTEgMTg6MTY6MDIiLHJldmlzaW9uPTEyN11dCi0gYWRkOiBpbnRlcmFj
dGl2ZSBkcm9wLCBzd2FwLCBhbmQgcm9sbAotIGFkZDogcmlnaHQtY2xpY2sgbWVudSBvbiBzdGFj
ayByb3dzCi0gYWRkOiBsZWZ0LWNsaWNrIG9uIHN0YWNrIHJvd3MgdG8gcGljawotIGFkZDogc2Ny
b2xsaW5nIHRoZSBzdGFjawotIGFkZDogaGVscCBzY3JlZW4KLSBhZGQ6IG1hbnVhbAotIGFkZDog
bWFjcm9zIGZvciBrZXlzIGApYCBgXWAgYH1gCg==
:: gfx/.info.pod
--[[pod,created="2025-11-13 21:07:43",modified="2026-01-11 18:16:02"]]
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAxLTE3IDEwOjM1OjQ4Iixtb2RpZmllZD0iMjAyNS0w
MS0xNyAxMDozNzo0NCIscmV2aXNpb249Ml1dbHo0AH4AAAASMQAA8yF7WzBdPXtibXA9cHh1AEMg
EBAE8FYHEAfAF9AXwAcQB-BWLGZsYWdzPTAscGFuX3gIAMt5PTAsem9vbT04fSw_AB-wMQD-----
-----------------------------------------------------------XUG09OH19
:: map/.info.pod
--[[pod,created="2025-11-13 21:07:43",modified="2026-01-11 18:16:02"]]
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAxLTE3IDEwOjM1OjQ4Iixtb2RpZmllZD0iMjAyNi0w
MS0xMCAxMjo0MTozMSIscmV2aXNpb249Ml1dbHo0AEwAAABQAAAA8Rx7e2JtcD1weHUATIAgIAD-
AAD---8DLGhpZGRlbj1mYWxzZSxwYW5feD0wCADSeT0wLHRpbGVfaD0xNgoAEHcKAIB6b29tPTF9
fQ==
:: sfx/.info.pod
--[[pod,created="2025-11-13 21:07:43",modified="2026-01-11 18:16:02"]]
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA3LTMxIDA4OjMwOjI4Iixtb2RpZmllZD0iMjAyNS0w
Ny0zMSAwODozMDoyOCIscmV2aXNpb249MF1dbHo0AKAAAAALCgAA-zBweHUAAygAAAQABA9AEAIO
AAGgASACoA4ADxAADfDKAQIDQA8PkAQFBgdADJAICQoLQAyQDwwPDQ8ODEAM8P8BAOv-J6oBEAYP
MBABIAEgAfAAAhACDhABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDjAA------_9
H-8BAKzPyA9AAA8QQP--sPD-AQD-6lD-----KQ==
:: [eoc]
