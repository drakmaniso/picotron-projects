picotron cartridge // www.picotron.net
version 2

:: .info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTIzIDE4OjQ1OjEzIixtb2RpZmllZD0iMjAyNS0x
MC0yMCAxOTozOTo0MCIscnVudGltZT0yMSxzdG9yZWQ9IjIwMjQtMDMtMzAgMDY6NTQ6MjQiLHdv
cmtzcGFjZXM9e3tsb2NhdGlvbj0ibWFpbi5sdWEiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRp
b249ImdmeC8wLmdmeCIsd29ya3NwYWNlX2luZGV4PTJ9LHtsb2NhdGlvbj0ic2Z4LzAuc2Z4Iix3
b3Jrc3BhY2VfaW5kZXg9NH0se2xvY2F0aW9uPSJwYWwvMC5wYWwiLHdvcmtzcGFjZV9pbmRleD03
fX1dXQ==
:: debug.lua
--[[pod_format="raw",created="2024-08-24 12:45:09",modified="2025-10-20 19:39:39",revision=558]]
-- Detect uninitialized globals and typos
-- from @snowkittykira from the BBS


-- if you're using include(), include this after including everything else,
-- since most included modules will need to assign global variables on load

-- these globals are needed by picotron
_init = _init or false
_draw = _draw or false
_update = _update or false
-- these are used by the picotron terminal
cproj_draw = cproj_draw or false
cproj_update = cproj_update or false
_ = _ or false
_is_terminal_command = _is_terminal_command or false
k = k or false
res = res or false
-- gui needs these
drag_t = drag_t or false

local function unknown_variable (t, k)
  error (debug.traceback ('unknown variable ' .. tostring (k), 2))
end

setmetatable (_G, {
  __index = unknown_variable,
  __newindex = unknown_variable,
})
:: docs/
:: docs/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTI2IDE0OjAzOjI1Iixtb2RpZmllZD0iMjAyNS0x
MC0yMCAxOTozOTozOSJdXQ==
:: docs/design.md
b64$LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNS0xMC0yMCAxOTowNjoyMiIsbW9k
aWZpZWQ9IjIwMjUtMTAtMjAgMTk6Mzk6MzkiLHJldmlzaW9uPTI4XV0KIyBEZXNpZ24KCiMjIFNw
ZWxscwoKLSBBbnRpZ3JhdjogY2hhbmdlIGdyYXZpdHkKCi0gUmFpbmJvd3M6IGNoYW5nZSByYW5k
b20gZ2VtcyBpbnRvIHJhaW5ib3cgZ2VtcwotIFJlcGxhY2U6IHJlcGxhY2Ugb25lIGdlbSB3aXRo
IGEgZGlmZmVyZW50IGNvbG9yCi0gUmVwYWludDogcmVwbGFjZSBhbGwgZ2VtcyBvZiBhIGNob3Nl
biBjb2xvciB3aXRoIGEgZGlmZmVyZW50IHJhbmRvbSBjb2xvcgotIFBhaW50OiByZXBsYWNlIHJh
bmRvbSBnZW1zIHdpdGggYSBjaG9zZW4gY29sb3IgKG1pZ2h0IGNyZWF0ZSBhIG1hdGNoKQoKLSBS
ZW1vdmU6IGNsZWFyIG9uZSBnZW0KLSBTbGFzaDogY2xlYXIgb25lIGxpbmUgb3IgY29sdW1uIChl
bmRzIHRoZSB0dXJuKQotIEV4cGxvZGU6IGNsZWFyIGEgOXg5IGFyZWEgKGVuZHMgdGhlIHR1cm4p
CgotIEZvcmNlOiBzd2FwIHR3byBhZGphY2VudCBnZW1zIHRoYXQgZG8gbm90IGNyZWF0ZSBhIG1h
dGNoCgotIFRlbGVwb3J0OiBzd2FwIHR3byBkaXN0YW50IGdlbXMgKG11c3QgY3JlYXRlIGEgbWF0
Y2gpCi0gRGlhZ29uYWw6IHN3YXAgdHdvIGdlbXMgZGlhZ29uYWxseSAobXVzdCBjcmVhdGUgYSBt
YXRjaCkKLSBQdXNoOiBwdXNoIGEgbGluZSBvciBhIGNvbHVtbiAobXVzdCBjcmVhdGUgYSBtYXRj
aCkKLSBNdWx0aXN3YXA6IHN3YXAgNig-KSBnZW1zIChtdXN0IGNyZWF0ZSBhIG1hdGNoKQotIENv
bm5lY3Q6IGRyYXcgYSBwYXRoIHRocm91Z2ggYWRqYWNlbnQgZ2VtcyBvZiB0aGUgc2FtZSBjb2xv
ciAobXVzdCBjcmVhdGUgYSBtYXRjaCkKLSBUb3VjaDogc2VsZWN0IGFuIGFyZWEgb2YgZ2VtcyBv
ZiB0aGUgc2FtZSBjb2xvciAobXVzdCBjcmVhdGUgYSBtYXRjaCkKCiMjIFJ1biBNb2RpZmllcnMK
CkhhcmRlcjoKLSBDaGFuZ2UgZGVmYXVsdCBtYXRjaGluZyBtZWNoYW5pYwotIEFkZCByYW5kb20g
cm9ja3MKLSBObyByZXJvbGwsIG5vIGJhbmlzaCwgbm8gbG9jaywgbm8gc2tpcAoKRWFzaWVyOgot
IDUgY29sb3JzIG9ubHkKLSBMb3dlciBzcGVsbCBjb3N0Ci0gQWxsIHNwZWxscyBmcm9tIHRoZSBz
dGFydAotIEFsbCBzcGVsbHMgZnVsbHkgdXBncmFkZWQ=
:: drakma.lua
b64$LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNC0wNC0wNyAwNzo0Mjo0NSIsbW9k
aWZpZWQ9IjIwMjUtMTAtMjAgMTk6Mzk6MzkiLHJldmlzaW9uPTE5OTBdXQpfbW9kdWxlcyA9IHt9
CgotLSBBICdyZXF1aXJlJyBmdW5jdGlvbiBzaW1pbGFyIHRvIHN0YW5kYXJkIEx1YS4KLS0gSWRl
YSBmcm9tIGVsZ29waGVyIG9uIHRoZSBCQlMKZnVuY3Rpb24gcmVxdWlyZShuYW1lKQoJbG9jYWwg
Y2FjaGVkID0gX21vZHVsZXNbbmFtZV0KCWlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQKCglsb2Nh
bCBmaWxlbmFtZSA9IGZ1bGxwYXRoKG5hbWUgLi4gJy5sdWEnKQoJbG9jYWwgc3JjID0gZmV0Y2go
ZmlsZW5hbWUpIAoKCWlmICh0eXBlKHNyYykgIT0gInN0cmluZyIpIHBhbmljKCJjb3VsZCBub3Qg
aW5jbHVkZSAiIC4uIGZpbGVuYW1lKQoKCS0tIGh0dHBzOi8vd3d3Lmx1YS5vcmcvbWFudWFsLzUu
NC9tYW51YWwuaHRtbCNwZGYtbG9hZAoJLS0gY2h1bmsgbmFtZSAoZm9yIGVycm9yIHJlcG9ydGlu
ZykKCS0tIG1vZGUgKCJ0IiBmb3IgdGV4dCBvbmx5IC0tIG5vIGJpbmFyeSBjaHVuayBsb2FkaW5n
KQoJLS0gX0VOViB1cHZhbHVlCgktLSBAIGlzIGEgc3BlY2lhbCBjaGFyYWN0ZXIgdGhhdCB0ZWxs
cyBkZWJ1Z2dlciB0aGUgc3RyaW5nIGlzIGEgZmlsZW5hbWUKCWxvY2FsIGZ1bmMsIGVyciA9IGxv
YWQoc3JjLCAiQCIgLi4gZmlsZW5hbWUsICJ0IiwgX0VOVikKCWlmIChub3QgZnVuYykgcGFuaWMo
IlN5bnRheCBlcnJvcjoiLCB0b3N0cihlcnIpKQoKCWxvY2FsIG1vZHVsZSA9IGZ1bmMoKQoJX21v
ZHVsZXNbbmFtZV0gPSBtb2R1bGUKCglyZXR1cm4gbW9kdWxlCmVuZAoKCmZ1bmN0aW9uIHBhbmlj
KC4uLikKCWxvY2FsIGFyZ3MgPSB7IC4uLiB9Cglmb3JlYWNoKAoJCWFyZ3MsCgkJZnVuY3Rpb24o
c3RyKQoJCQlzZW5kX21lc3NhZ2UoMywgeyBldmVudCA9ICJyZXBvcnRfZXJyb3IiLCBjb250ZW50
ID0gc3RyIH0pCgkJZW5kCgkpCglzdG9wKCkKZW5kCgoKLS0gVGFibGUgdXRpbGl0eSBmdW5jdGlv
bnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0KCgpmdW5jdGlvbiBpc19lbXB0eSh0KQoJcmF3ZXF1YWwobmV4dCh0KSwgbmlsKQplbmQKCmZ1
bmN0aW9uIGRlZXBfY29weSh0LCBhbHJlYWR5KQoJaWYgKG5vdCBhbHJlYWR5KSBhbHJlYWR5ID0g
e30KCWlmIHR5cGUodCkgPT0gInRhYmxlIiB0aGVuCgkJaWYgYWxyZWFkeSBhbmQgYWxyZWFkeVt0
XSB0aGVuCgkJCXJldHVybiBhbHJlYWR5W3RdCgkJZW5kCgkJbG9jYWwgbmV3ID0ge30KCQlhbHJl
YWR5W3RdID0gbmV3CgkJZm9yIGssIHYgaW4gcGFpcnModCkgZG8KCQkJbmV3W2tdID0gZGVlcF9j
b3B5KHYsIGFscmVhZHkpCgkJZW5kCgkJcmV0dXJuIG5ldwoJZWxzZQoJCXJldHVybiB0CgllbmQK
ZW5kCgoKZnVuY3Rpb24gdG9zdHJyZWModCkKCWlmIHR5cGUodCkgIT0gInRhYmxlIiB0aGVuCgkJ
cmV0dXJuIHRvc3RyKHQpCgllbmQKCQoJbG9jYWwgcyA9IG5pbAoJZm9yIGssIHYgaW4gcGFpcnMo
dCkgZG8KCQlpZiBub3QocykgdGhlbgoJCQlzID0gInsgIgoJCWVsc2UKCQkJcyAuLj0gIiwgIgoJ
CWVuZAoJCXMgLi49IHRvc3RyKGspIC4uICIgPSAiIC4uIHRvc3RycmVjKHYpCgllbmQKCWlmIG5v
dCBzIHRoZW4KCQlyZXR1cm4gInt9IgoJZW5kCglzIC4uPSAiIH0iCgoJcmV0dXJuIHMKZW5kCgoK
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCgpmdW5jdGlvbiBjbGFtcCh2LCBtaW4sIG1heCkKCWlm
IHYgPCBtaW4gdGhlbgoJCXJldHVybiBtaW4KCWVuZAoJaWYgdiA_IG1heCB0aGVuCgkJcmV0dXJu
IG1heAoJZW5kCglyZXR1cm4gdgplbmQKCgpmdW5jdGlvbiBleHBfZGVjYXkoYSwgYiwgZGVjYXks
IGR0KQoJLS0tIExlcnAgc21vb3RoaW5nLCBidXQgZnJhbWVyYXRlLWluZGVwZW5kYW50LCBmcm9t
IEZyZXlhIEhvbG3DqXIKCS0tLSBodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PUxTTlF1
RkVET3lRCgktLS0gVXNlIGFzIGBhID0gZXhwX2RlY2F5KGEsIGIsIGRlY2F5LCBkdClgCglyZXR1
cm4gYiArIChhIC0gYikgKiBtYXRoLmV4cCgtIGRlY2F5ICogZHQpCmVuZAoKCi0tIFBvcyAtLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLQoKCi0tIFdBUk5JTkc6IGRvIG5vdCBmb3JnZXQgdGhhdCBgcG9zYCBpcyBh
IHJlZmVyZW5jZSB0eXBlLCBub3QgYSB2YWx1ZToKLS0gYXZvaWQgbW9kaWZ5aW5nIGluIHBsYWNl
LgpmdW5jdGlvbiBwb3MoeCwgeSkKCWxvY2FsIHAgPSB1c2VyZGF0YSgiaTE2IiwgMikKCXAueCA9
IHgKCXAueSA9IHkKCXJldHVybiBwCmVuZAoKCi0tIERyYXdpbmcgLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoK
Ci0tIEZyb20gU29waGllIG9uIHRoZSBkaXNjb3JkCmZ1bmN0aW9uIGdldF9kcmF3c3BhY2UoKQog
ICAgcmV0dXJuIHsKICAgICAgICBjYW1feD1wZWVrNCgweDU1MTApLAogICAgICAgIGNhbV95PXBl
ZWs0KDB4NTUxNCksCiAgICAgICAgY2xpcF9sPXBlZWsyKDB4NTUyOCksCiAgICAgICAgY2xpcF90
PXBlZWsyKDB4NTUyYSksCiAgICAgICAgY2xpcF9yPXBlZWsyKDB4NTUyYyksCiAgICAgICAgY2xp
cF9iPXBlZWsyKDB4NTUyZSksCiAgICB9CmVuZAoKCmZ1bmN0aW9uIHNldF9kcmF3c3BhY2UoZHJh
d3NwYWNlKQogICAgcG9rZTQoMHg1NTEwLGRyYXdzcGFjZS5jYW1feCkKICAgIHBva2U0KDB4NTUx
NCxkcmF3c3BhY2UuY2FtX3kpCiAgICBwb2tlMigweDU1MjgsZHJhd3NwYWNlLmNsaXBfbCkKICAg
IHBva2UyKDB4NTUyYSxkcmF3c3BhY2UuY2xpcF90KQogICAgcG9rZTIoMHg1NTJjLGRyYXdzcGFj
ZS5jbGlwX3IpCiAgICBwb2tlMigweDU1MmUsZHJhd3NwYWNlLmNsaXBfYikKZW5k
:: gfx/
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNS0x
MC0yMCAxOTozOTozOSIsc3RvcmVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Il1d
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNS0x
MC0yMCAxODo0ODozMCIscmV2aXNpb249NTI0MF1dbHo0ANVhAACqAAEA8xR7WzBdPXtibXA9cHh1
AEMgEBAE8PAsZmxhZ3M9MCxwYW5feAgAz3k9MCx6b29tPTZ9LDEA-1DwER0dBPBPPxJAPuAODxYf
Kg8VDiAOHyofFg7QDg8qPxUuBQBADg81wB4ApBQfFS8WHxUfFA8TANUPFQ8UDxNPFQ8TDxQfKAAB
FQARLxUAEC8VADGQPyw_AFATLxUfEz4A-AYeHytgDyw-LS8VXy0-LB8VHywPK1ARAD8PNUATACXz
AFBPLC8TTywvKx8TLysfNVsANU8tLyIAH2ATAITvcD8rLn0eHR81gPwD8C7JAR3yPDkvKxAPD-AG
DysgHvAFTyzwBw0-LQ0O8AYNDD0ODzXwAx1sHfABDawN4A28HcANLB8qjA0OoA0sK4wdDpANLBuc
HQ4PNXAN-AAtDgYAKwpgBwAm7D0GAP8g3E0OCnANvE0OGnANrF0OCpAdbG0OGqAOzQ4awA6tDhrg
Hm0eGvABCm4q8ARq8BfNAB3wBU0PLOAOoA4PLQ7ADg0OkA4dDqAOoABAgA4tDgQA0QyADg0PKx0O
YA4dCw0OAFIbHW4dGwsAMyuNKxQAEq0SACr9AQYAkHAOLS5tLi0OcFQA8QkaDyoLDk0OCgsPGg4d
DgxgDh0OCRsJDi0GAAERADMtDikEAIAMYA49Lk0uPQkAIP0DSQD-Jm0vCW0OHEBbXQhdW3AOPQ4d
Dh0OPQ4cgDstHg0eLTtwGyAOrQ4cABuwHm0eHPABDG4s8ARsEAEf8AKLDytgDvAEHkAe8AQODyxO
DQ0A8DFNHtAuIA5tDiAuDzVAHi0eAA4NHw8NHA0OAB4tHiAObR4MDyoODAsODB5tDhAOfQ4MHgwe
DA59Dg81AA59Dg0cKwDwCX0OCgAOjQ5NDo0OCgA_bQ4tDm0_CgAOGt8A8AYaDgoQCgA_zT4KEAow
DhoOLQ5NDi0WAPAGcAoATk1OChAKkA4qDk0OKg4K0AogGwD-AiAK8AMODQ4a8AkOGvALCvBx6AAd
IBoPCgNwLPAKDysPFhQDIvAJEgAgDzUUABEfBgBBDzXwCwYA8AQE7yvADu8tDqAODf8sAA6QDg38
BgDwDhw_TD4cDg81YC4MDg8NHw8PDQ4sDgsfDwsODC5A0wHwBQ4KHxAKDiwOChkKDgwOHQ4wDg0M
FgAWGRUAAEAAsSAOHA4MDgsaCw4sBgAAFgAQCBUAAmEA8AIcDggwLvwBLhhACA78AQ4oYAYAYAiA
DjyOPAcAUiwOjQ4sCQBVDQ5MDgwNABB8CgAwkA4cCgCvHA4YoO4YwOjwMCoBKR8SKgEWULAODd8s
lgUFMgEXDC0BVTwOLA48JQEDDgAFIAEwXixeAgESCxcBYA8cHx0PHDABIh8dMQEYCxsBEQsbATAb
QAsVARErGwESCxsBFAsbARgLGwEVCxsBFQsbAW8boO4bwOsbAR-wGS8fK6AusA4fLR5wDi0ekA4f
LB0eQA48HR5gDkwdHhAOHA8NDw8PDRwWAPIEbB0eLA8PDxAPDzwdDiAOnB0eDB4AoVwOIA4sHmwd
HnwwA-ECHB4LDiwePB0eXA4LAC4rDgwQAKMMHR48DgsQKxAeEgByHS4MDgtwGxAA8QUMDi0eC8Ab
EB4bDjwNDgvwAhsADhwB4PABHhAOTA4LsB4gDg0e-wAhG2ALAHIADkwuGxAuCwCSDB0eLB47IA4d
DABAXB4rYAgA-xiMHiuADrweK7AOjB4r0A5sHivwAQ48HivwAw4cHivwBh4r8Akb8CI1AR3xCBYf
K2Ae8AAeDy0ODzVQDg8tHrAeHQ8sDQDwEA0fLB5wHh0cDh81YA48HkAOHTwOC3AOXA4wDkwOG4DL
ANAwDjw_QD48DhswDkwdDwBQHUwOC1AfABBABQAjUA4PACELcO4AAAUAYXAOLD4gPvEB8AMsHQ4L
EA4dLA4bkA48DhsgDjwWAAG3AxAwKwAQgIECEBxMABAcKgKADSwODD4APgxEABMNsAFxDhwdDgsO
HSAAEhzSAQEzAABzASQbgPQBABMAIAsQBQBgoA5cDhwuZQJADlwODNwFoA4LwA5cDg08DhsIAAGp
ATDgDky0ADDgDlyGAI-wAJ4b8AKbsFsBHdAyLyugHqAeLy0OcB4dBABAPywOQE8BALcFFB2OAqIO
EB4dTA4wDh08vgBBLB4dbIUEE1y7ALAeHZwOIA58Hh1sHpcB8QQQDlweHTweLA4LHhwOEA48Hh0M
DQDFDA4LAAsuCwAODC4dEACVHgsgKwAeLQ4MDwAhG2DrAAAKABGw7QDxCiAb8AEOTA4QHvADDiwO
DB4NDiAe4C5MDgAKAHKgGx4sHh0MDgBSLnALHlwOAHAdDguACx6MDQCwG6ALHrwOC9ALHowsAeAL
HmwOC-ADCx48DhvwBaUAvwvwCAseG-AKG-ARQwEd8gYanyvwAg4vLQ5dDvAADg0-LA5MDvBOAyBc
DqYBMVwO0DACMAwOXDMIIAwuGQAQsDcCIC81sAQEZQEQoBMAAD0BABQAAWgBEBwGBTAsDgAFAAQm
AHCQDg0_DzU_BAUAIwVBDjsAG2wAYKAODRwOQAUAEAwMAAGfAiANLGgAUjwOIA4NtgJgHD4LED4s
OQBQHA47IBvFAhBwHAABcQEBCgAkC1AGABBcTgCxXA5QDg0sPgswPjxRAGA8DjtAGw4MAkANTA6A
BQBBCzAePEYAcCweG0ALHixMAEEcHitw3gH-A1AODR4rsAseC1AeK-AAG2AbcG4JfTH9Aw4FAAFd
CRDNXQZ0YA4tTi1OLUgJBU4JEilNCR8JTQlGDyQNEB8yMQD--xfwJB0dBBAPN-AHDiAu8AUuAE7w
A04ATvABTiBO4E5ATsBOYE6gToBOgE6gTmBOwE5ATuBOIB8AACkA347wBW7wB07wB27wBY44ABgg
TgBrAG8gDvAHDhCrAAscNKsAb-83----PDUAHR84NQAhXzsN-zwNBgA_D4YAHE8POw88BAAhFx8M
AA84AP-------wcvDzuJBgwPVQgdHza6Bv-------3sOiQYHOwAPBAAZFx8MAA84AP-------wcv
DzyJBhxxjzwPPQ87rwYAEU8GADL-PAAHABABBwARzxQAF38gABEfBgAXjwwAF_8GAAIwACRfPDQA
ES8GABUPNAATL2QAFgRXABcfKQAEgwAQBwcAF98TABGfBgARPwYAGL8lABdvJQAmXzxWADb-PBIN
ACw-PCsAHR8YADb-PAgNABOfEwAWAiwAF38_AAN8AAVdACc7TyMAEx8jABYWEwAXf7gACBIAF886
AQIkARnfQwAWE5IACKsAD_QBGfEmIyAEcP82A_D_BdD_BcD_B7D_B6D_CZD_CYD_C3D_C2D_DVD_
DUD_DzD_DyD_ERD_EQD_NgAJABEgFQARQCEAEWAtABGAOQARoEUAEcBRAD-g-gMUGwweN44AHzeO
AHofOI4Aeh87jgB6HzyOAHofPY4AdQ97EhAfNdsBAvMw-zwF0P87BcD-PAew-zsHoP88CZD-OwmA
-zwLcP87C2D-PA1Q-zsNQP88DzD-Ow8g-zwREP87EQD-PBP-OxMADwATIB8AE0AvABNgPwATgE8A
E6BfABPAbwA-4P884AANHDMYBvAT8BW-NA8x0N80LzGg3zRPMYBfNF8yDzEPMA80XzFgTzR-MgsA
8AkvMk8xQE80jzIPMU8yTzEwPzT-MgE-MSAIAEEDPzEQCAC-HzEfMBAvNP8yBS8IABlxLzIPMf8y
AQwAch8xDzD-MgIMADIwDzQMABAfGAAADABQPzAQPzFyACAwIAgA8Q4BPzAwTzF-Mg8xXzJPMEBP
MW8yHzE-Mk8wYF8xP8UA-wYvMl8wgE8x3zCgLzHfMNAPMb8w8BU6BxwDIgFQnzQPMi8mAQAOAB8P
KgEQQjAPND8sARGfDQAhTzIxAWG-Mg8wXzI0ARGvPwAQPx4AEzI9AWAPMg8xjzL7AAC9AAFeACQy
LxkAEn8RAGA0HzIPMC8KABIxKQEB_AACfQAQL3YAARUAEDJaAABWAAAXACAPMBIAAi4AIzIfbwBF
HzSfMoIBVC8wHzS-IgAAZwBBHzQvMBEAIQ80DwASMcQARQ8wrzKfARRfDwACogGhbzIPME8yDzE-
MqkBMX8yH8QAIU8ysAEAIAETLx4AETCsARIw-wABuwEASwFSHzAfMR_-AT8PMj_-ATYAIgEQcKIA
YKBPNC8xQMUB4IBfNC8xMC80TzFgbzQvlwEAcQAhUE-rABAP6gFwMRAfND8yP78BAEsBAUUBVDEP
MAAfyAECywASHxIAAE8BMCAvNLoBQQAPNB-kAEEgLzR-KwEgMR-yAACBAAA0AACHAZIwHzFPMEAP
ND-FAfBSMi8wQE5gPzEvMj7wAy8xXkA-NIAdAB8xTjBdHFAdDzIMEC5AXUwwDBsOkD0bXCAMHhAt
HCA9SzxgLRscEC1rHB5ALSssAB1bDBsuQC07HAAdSwwrLjAtGwwbLAANDCsMDg4A-x4LDA0rDA4A
LDsMCz4wHRwNOx4APCtOUDwrLgAsjmAcXiAMjoBuMH6wLoAu8BNkAR3xBTZPNPADLgAOTzMPMgAu
wA4vMw8yDQBwDi8zDrAOPQUC8CAPMU2gDD0PMgxDDAs9DHAeDQwNG4MbDQweDUAeLRwzBRQFBBMc
Dh0bMA49CyMUBQIAogMLPQswDi0LIwUQALUEAy0LDDAMKwwTBBIAVCscQCwjDwBjFAMsUC4TDAB3
BRQDLkAOLQ8AYw4tMA4dCxEAEB8SAEMtCzAtEQDCCg8qGhQDHRswCx0MEgCCOgMEAysMQCwOAEcF
GhMEXwAvBBNfAAIIEAAaPQ8AJy0LfgALfQAAAgAAfAATK3sAAAIAAXwAj-8wASxw-zUE8SUf8BGE
LzT1AS5ADg8qDg8y9QEuDTAuDfQBLg0gLg31Ay4NEBkAgA30Aw4MDg0QBQAxZE5kDABwLg1UXg1U
LgkA8AB_Kw4Njg0QrgsMDwwPCgkMAPAPnQ4LDwwfCgmtIC1TDgsqCQ1TLTAeDVQeKQ4NVB4NCwAT
XgkAMWRNZAgAJvQDBwAi-ggEAHEO-QhA-zAH2QAfS9kAYSUvENoAVBEPDw8O2wBSER8PDw7cABAv
FwAD3gAfKt4AnBUV3gAQFk0yBN4AUxYfFA8T3gAAFwAP3gCkIxod3QBUGw8ZDxjdAFMbHxkPGN0A
ABcABN0AEx3cAC8eTdwAkRQf3ABUIA8eDx3cAFMgHx4PHdwAABcAD9wAoxQk3ABUJQ8jDyLcAFMl
HyMPItwAABcAD9wAXgvgCVZvNA8xP_QJAA4JAvwHAegJQB80DzIaCADJBwIVAAHyCQBkCCRfMicJ
Ez-NCBAwWAgAxwgyLzEvFwARMDwIER8qAEQ-MC80-wkBEAoAGwgBHQAdMRYKEB_tCA8YCgIBcQAf
bxoKASAfNIYADRwKAdAJASoABCAKER9fAB4fIAoAOQoCzgAJKAoRP8MKAxUABi4KAZgAA1cADzgK
AALSADQvMU8_ChFPOgAAXgA2PzAfRgozPzIvFwAAVwAANAABTgpiHzIfMV8wbgABdQEAVApXLzBP
NA8VAAFaCgGRCRYwKAADXgovPzBcCjsOmCAPMQDQoCMRBCAPNP8zDECRDSAOIGIBMP8xCfsBEBAM
AEYPMW8nBAAAEACWAA80PzMPMW8oBAAAEAACVwIJFgAAxgEPLAAFABYAFikEAAdCAAgWAB8yFgAG
NjM-MlQAKW8oLAAMFgAPLAACPwAPM94AATUQDzMBAa8g-zIODzFA-g0gUgEZkwUHBAAnAAcgFwIA
TwcAJwBAAAscOEAAkRAHIBcQBwAHMAIALxBHPwAcAX8AQgcwByACAA8-ACU-EBdAvgAkETBAAK8A
BwAHEAcARyAHQgAdb1cwN0AHMH0AIyAXEH0AETeBAQ9AACASRzcBAsIAHyA6ASECdwAOfwAPQgAb
EDeCAD8QFxBAABn-AgcLBAA-KhBeAB4fOh4NHg0ABQADf14NAD4dED2bAAwsMTRcAMEQHyowLg86
ED4NIA2yBwUDAH8QXgBeDQBdUQAdB60AQAAdAB58CEEQLh0AAwAPUwA1nx4dIC5AHg0eEPgAKmBA
Hg86IC5OAHAQLg0eAB4dTgBBXg0ALf8AL0AdUwAdwl8qAF4POh5NThBeEEQABaEALwBNoQAf4C8q
ID4POgAuLQAeHSBOAQEfHewBLAKhAADgAAX3AAUGABAg8gAfIJoBKAGaAD8APh2oADAMVgBxXg0A
Tg0QHbcAAE0BXy4dIC0QVQAa8QEKEAQQTyowbhCOAC4vOi4N6woPBQAQr44NAG4dEE4dME1wAAwc
OW8A-wMgLypQPg86ME4NIF4NMB0uDVADAAFAII4AjmUAH41eABwOzQDHAC0QLg1APg0wPh0gAwAf
MGEAMQFcACBQLlwAcTA_DUBOUA0PAC8uICEBKYEQLypgLg86ULYAQUAuHUAJACEALioEBH4BAbwA
EU1uAF9QLg1gLWQAHPUEjyoAjg86jg0ubS4NUG4gfhCOEE0AD74AK-EFIE8qMF4POhBuDQBOPQA_
HTAuHUBhADMALi2_AAPDAA9iACUEvAAnAD0fAQ8JAAU-YC0wQgIuAQUAfwBuHQBuDQDHADcPaAAE
oY4NAH4NEG4NIC3GAFAwTg0QXmEAbyA_HUA9IGQAGf4GXggEEP86SiAO-ztKDz0ADv87TA8_BgAw
AA89IQBMPiD9SsMAsS0yMy4zMTkwNDc2BgADbgCSLTAuNzE0Mjg1BgAvNjj3LAHQZhwE8Fj1UiAF
9FIDEAUAMA86AAcAHw4GAGt8EPNSHiD_UnoFUzI2Ljc13wASM88AHTHPAO_-9FIgBPNSDzsQBPNS
DgUAWw_0ACEREe0MYs8zEA80z8oMFt8HADEPNO_FDBHvDABmTzNfDj8zFgBlTzJfDj8yIAAcMxAA
Ee9JACYz3wcAEBAFAC8g3jsMGfICEREE8BQPFq8VMA8WvxQPEyAHAPEBEA8W3xUPEwAPFj8UXw4-
FAsAARIAUk8VXw4-GwAR3xcAFhUiACEV3zsAEhVJAAEHAE8wvvAVkAAcMN8zIB8BEhAkAQYyAQIW
AUE-Mj8OqxChNC8zHw4fMx8OXxgAFW8KADNfMh8iAFZPMh8OfzIBDRAACmAAAKABPxDeID4BM0BP
FT8OlUcBQgFUHw4fFB9GATJ-FR9BAQAJAAMjAFZfFB8OX0MBNAAPFRIAD04BK8EEBAQAHzsADh86
Dz0FAD8AHQBAAAsfMd0PLKEXCwTwAR87gE5QcAD-KVAeTzouIA4dDz1ADp0OIBxADr0eMD4dXG0_
HTxQDK0MUB4gHH0MUA4dDDAcPRxgDh0MUDyQHPAAcwAcUjAfO-AEcQAhTnAIAPAOIC5POh5gHz0g
Dp86DhAuMB69DgAPPR0_bVwdDgB5APACLBAMfRwgHnAcPRwwDh0MgDyFAE-wBBxA-BAeDzEA--_Y
8F8oKAT-PxYC-gUC-i4G-h0CTgLuAv4UBv4GBv4HAv4NAv4DAv4CAgYCjgb_DAJOAv4wAv4iAl4C
3gb_OwL_BQb_AQI_Av4RAgYC3gKOAj4CThIGDzIGEv4TAgYC-hYC-hcC-jQC-hAC-ioC-mMGvkIA
EBAbADAHAt43ABH_JgACKwAQA0oA-wA9Bk4C-iMC7gJeAp4G-iQkIxnCKCgErz8C-goCDgbuVgBg
bgI_Bv4JEwAhPgIIAADhAAEaABCuFQCA-gwC-hIC-jeGAKDuAgYCfga_Av4ACwF6BgI_Au4C3swA
0J4C-gECngJ_Bl4G-lCvABEuvwBgCAL_HQbeagAQR0AAMg0Cfi8AgS4CTgYuAv4eRQEQMYIA4AAG
-iAC-i4CLgJ_Bv4NJgAxDgZuhgAfAegAHOFvPwb_MQKOBo4C-hkGfr0BIFcGigAyCAJe4QAQzgwA
EN4aADBeAo5rABcTzQARfpQAoBcCrgK_Av4TAr7dAXRVBv4LAv4UOQFg-gUCfgJuOQAgFgK2AEEB
Av4LqwAxDAJOHQKBWwb_IQY_Aj4YAOEFAv4SBv4PAv4LBm4Cng0AHyDTABwgjz9cABEumgAQAsYA
cEQCfgaOAs53AgGUAGH_CALOAh5PAhAEaQAh-gTUAUEGAv4cEgACzQEQLVUBQf4CBq7PAkACAv4b
TwAQvukAFQbdARDeTwBSBQKOAi4VARIelQIxrgJOSgAQFyEBMB0GrgcBQR0C-gPaAFAFBv4lBkQA
ECIkACBOBk0CPw0CruYAHGD-PwsC-m9gADEiBp6TABMWZAFBAgb_HtEAETAmAhAScwGQ7gL_Mwb_
gwKOrgAi-gAqAEGuAv5OEABgDAKuBv4nVwIzfgK_RgAQNJgCAEkAzywC-g4C-lEC-h8GjqQAHhNs
sQIwAQKejwMYFkACEAHzAzEGAr6sABALjgBBQgb_Dk8DEAEvAUCuBv6RsQAkDAJwASH_MzYEUAwC
-joGEgAVFj8AEDauAEG_Av5SYwJPLQL_LqsAHhAZiQECtwFBIgL_BqUBUAUC-g8GCAFRHQJuAq70
AxA7ZwBSEQI_AgaCBADHABA6FAABIgIQbmwEEC4rABECzAARLYABEQxWABEcpgFBCQL_BCEDEARk
ARIeXwMCcwFQDAbOAo6FAzFEAl5QAE8NAv4ayAAeQjcG-gk8AzEQAr5BAxAG3AMBYQNBAwb_XHQD
AfUBIf4FOQUQAScAExaEAACtAwQNABHeqAASRtYDQAQC-jKBAQSRARAEWAUAvAAFOwBBHwL_JkcC
ECDEABACUwRPKwL_HsEAGQDsHPI8GinwCBkLDAsZ8AQZHCobGfAAGRxqGxmwGRyqGxlwGRzqGxlA
CRz6AwsKCDAJDPoFCQgPNSAJDFoZShlaCQgOIAkMSgkcCSoJHAlKDwCUOgk8CQoJPAk6DwA2TAlM
DQAUrAsANEoJjDIAXVoJbAlaFgBTSgk8CTwNAIQLWgkcCQoJHCcAUmoZKhlqGgAh_gUIAP8mCgn6
AxkIDjAYGeoZGB5ADhgZqhkYLnAOGBlqGRgusA4YGSoZGC7wAA4YKRgu8AQOKC7wCC52Sh7wDjSO
8AMOTxEPEA8RHxAO8AEODxGPDw8QDuAODxGvCQBQwA4PEc8JAFCgDg8R7wkA8ASADg8RXw8ufQ8Q
DmAODxFtDhwODABAQA4MjQsAQAsPDTALAFAsDm0OCppKQAx9DjwMABoJCwAzbQ5MCwBkC20OPA59
FgAECwAhC20CTgELADF9DhwLADAwCg4LAPAVbQ4KGUAKDn0uXQ4KGWAKDu0OChmACg7NDgoZoAoO
rQ4KGcAKMAD-ABngCo4KGfABihnwA4nwFhwBHXBN-xMBoA7Pw1QwFh8V_ACRFv8UAQ8VDxJgCwBV
Aw4PElAKADsPNUAMAEVvFE5tDQBTXQ5MDl0OAGQMTQ5sDk0NAF89DowOPQ0AKQlOAAhoADUPFW2C
ACUM-ZkAHhULABBQCwD-CAEODxIfNWAPEv4BCx81gPsBGqD6AfAvNwEd8Agx7xjADr8bDxoPGw8a
DrAODxvPGQ8aDk9QMA8b7wsABQkAwA81cA4PG-8ZAQ8aDgoAQW8ZLm0XAEBQDg8bAAIADgATUNUA
UwsODzUwOALwCgsOMA4MXR5MHl0LDgoQDgtdDowOXQsPFxAOAZSsDk0OCQoADgsLAPEAEAkOPQ6s
Dj0OCRoQCQ5NAUwRLBoA0DAJDk0_DD5NDgkaMAn9UvABDn0OCQpQCQ5tLm0OCRpQCZxKkgkKcAkO
7Q4JGgcA-wMKkAkOzQ4JGpAJ7gkKsOkawOpNKB-gNW8d8AQeLyAPHw8gHx9ST-ATHyBvHh8fHxzA
Dh8grx4PHw4PHKAODyDvHg4PHIAODyB-HpRTYRxwDg8gfQoAASUBcCCNDo0ODxwKAAK9AAAYAAF-
AxEMGQAFCwATC4oDpiwOfQ4LCiAODx8MAAOLAwALAB8JCwAAMjAOCVUCUQsaMA4JlgFgDgsKUAsJ
JAFACxpQCyQB-xMLCnALDu0OCxqACx6tHgsaoBsebR4bGsAKG24bKvAACmsq4lUiwBovIvAJDg8k
DyUPJM9IQA8lLyMKAFEFDg8lTwoAUQMODyVvCgBQAQ4PJY8KAFDgDg8lrwkAUMAODyXPCQARoC8A
QD5dDyTGAyElTVoCMCQOYC4CYiwOjQsOQAoAQK0LDiBNApAsDj0eXQ4PIRB7AhEs908QXc0EEAAd
ADA8LhwOAHAJEAoOTQ6MFVZCGSAKDoUDAZgEUk0OTA5NmgQ-TU5NnAQHAcgEMfABCi0AUPADCg4t
CADfBQouChnwByoZ8AkpsDABHxAmMAFRKQ8qDykwATAqLygKAPACAU4PKk8oDylOoA5PKm8oTykI
AWAqbygvD28gANBwDg8qXygPDy8RDw9fEQA-DzVgEwADQh8oKg0VAEUNLxQdFwDyAw0KLwwKDS8P
DQ8ULxYPFA0PKcUDICodGQASTRYAAC8AAF8lFy0UAPABLQ8pDiAODE0qbS8UTQ8nDmYlQf0HDydP
U4EMTS8jbS8ZTQ8A_Q4QDg8nLQ8jLyUPI00PGS8bDxktDycOHzUgDg8nHRgAER0YAEJADgwNFwBC
DS8eDRoAEQ0aAIBQDgwdLyMND4ADMR4NLzAAAMcAIgxdEwAfXRAABUFtLx5tDAD-EXAOTydtSw4f
NYBOC00LThngDgstCw5Z8AEOKw4Z8AcuvAEiH-9ESw4fNuwIGDcqSyruCDsqyyrvCEEK_wMKaAgT
DHAIDxIALR8LEgAGWgoJKssqywg-KksqzQhcAMdREx8EABQv2QgEEQAEBAAUD_kIDBkAFC-5CBcv
FQAABAAjPw8HCQwyAAUdAB5ANgAKdAAvDTA-AAQCeQAAb1IvNSAjABMPaAAHDyMAGAcTAA_MACgB
MwEfH2kAAQ8jABZIMA8NDrcBDSMAbh81QA8NDpMBARsAH2AbAAADNgBGgA8NDhMABPsBARsAF6A2
AANJAFLADw0OjwsA7_APDY4NHzXwAY0c8AOMUgo9APheDwQAASMPFGkKFw8VAAoEAATQCSUWLxMA
BgQAFi8fAA9jAAoCIwAPZQD-HCcVDxcAD2UAIgUTAA9lACcAvgsn-xS-CwDkAl-9ARyg-L8LPV8f
GQ8aDwQAABQf1wsPIQAKAu8LFy8XAAgEACMvGQYMBBEADwQACQMkDA5vAA93AAAPKQAWADsLDqAA
D6gAAh4wqAAPBAAKAsEIAWcAHw8EABABKAAvFxC5ABAGMgAwDg8XNQkDPQAPMwAXRBAPFw4TAA8E
AA9BDg8XHzMADycBDwFeAF8wDxcOH4kAER8fKwAXPg81ULQAD6wABR5QrAAMpAAecHkADJwADyMA
DnIPNZAPFw7PLgDPkA8X7g0PNbDtHMDsHQ5IRh8fHx4EABQPKw4XLxUAAAQAAzcONf8eATcOBBsA
BAQAIy8eRg41Dx4PFQAJWQABHANBIP8eBVYODmUANB8eDykAESBIAAQXAAgEAAQfABIfSAACKwAP
SgALHx9KABRPMA4PH9YAAhEfGwAP2AAIUlAPHA8fHQEALgI-HA4PbgADRnAPHA4TAAKoAAE0AHCA
Dxwerx4eCwD-C6AfHB5vHh4fHB81wA0fHG4cLfAADWwt8ARt-A47VR8jDyQfAA8TDw4AFR8IDxgv
EgAX4DEABRUAG8A4AAQEACsOoD8ABAQALg6ARwAGHQAfYE8ABAQEAC8OQFcABAQEAAAaXUgfIw0c
AgABgg9JDyUNHAIAQAwODyHpBEcNDA0cAgARLBcAWxAPIQ4MLwBaCx81IAsWAEgOCxpAEwAAu2MY
YBEAEQzLECcODDEAFKAPAAAtABTADQAAKQAT4A0AUA4LGvABDAAAIgAg8AMKAAAfAN-wBQsuCxrw
Bysa8Akq0w86XR8oDykf1w8Arw8TDwQAFF-fDzf-KAHFDwYhAAwEACUfKCcADzMAHBFQMwATA_UP
DjEADzkABGMgDg3-KAf7D08PKA0MAgABAXYPVQAODfwHDBA7HA0MAgAhHAsPEGAL-AMLDhqAXyoN
DB4ArxpQDg38AQsOCmAdAAAmCmAdABFcFQDxDFwLDgpwDktsSw4agE4LHA0cC04a4A4LLAsOWuoP
ThrwBy7TAQ-qD39vSxlLGUsK2xgCvworCTwJCwk8CSsK3RgARQorCawaABZKyRhvCksJbAlLGAAA
ETviGC87CuMYAm8KWxkrGVsbEM0fLhgQBG8PDw4fEQ4YEAYAHQAVHw4ADxYQASQOLz8AD4gPAi8O
Px8AABYvfQAAHwAIBg8KIQAvDk8fAAEDDwAMQAAOgAAPIQAGLRAvvgALYwAfLyABAA8EEAgBJQAI
IwAKBBB1Dw8uDQ8QPQEQUS0PEB0MAgAF_Q8DEAAgDA0YBoKgCw4tDB0MPdIFEY3MBRCOxgVfixrw
A4rhD6hgDxROHQ8V5gAEGgARDfQAIksODQEBFQCkCy0MDQ5rDg0MLREAACMAJosONwCICw0MHQ6L
Dg0zAD8Oiw4xABsNZABAHQwOSyMABTYAEAwNACEdTgYABjgAEx0CAAQ6ACcMHQIACjsABAIAAw8P
GAzMGp8KHzWA_gEZoPkND7BBLg0PGpwGEgxxByIbHQ0AISsOCABBHQwOUJQBAeoBAxIAABwLJwst
FABALQwOMKkBAAIAQh5LHgwKAABIGwBYAQHRAQI7AACCDgFOACEOq2gBAVYbGgwRAEUQCQ4NEQAS
DWIbAPMBUSsOCw4r9wEBZhsANQAyPgs_NQATGhEAADEAEQs-AAJMACNQCQ0AIw0uCAAChBsBvQAD
AgASLY8bAz8ABDsAHhoTAA6nGw_KDWU7Dx8Oiw0DzRsBwwFgIB0fHx0cmmojHC2FDTENDB2oaiAN
HBkAAt4MQwuNDgvTGzALLRzCahAOJgAiDA1lHxILLAAQK0cAFB1sHxQrSx8wLRwd-AECLwAAHAAA
LgABDAQELQAwbQ5LjxoiCTAUAAAtAACOGhEw5wEEWQAAPQAwUAoM_BtBChlQCqAAEx1xADNwCg4N
ABEM8hpwHq0eChmgGuFx-wAZwAkabhop8AAJainwBGkKDZ4-DyM_Bw0CXw4vJQ4PBQ0FAR0AAQoA
DQMNEQ86AAQXAA0BDQAdAEsNHA0eAg0C5AMSDmsMCQQNbAwOOy4bDgINIQ6L5QpiDgofNSAKEgAg
aw5IAAGkHAEQABFLqwwBqRwAEAASTjAAAK8cAtwMAi4AJaAK_AwBvRwCDQASDMMcEwwlAADHHAJN
AADJHACpAA7LHA-4DFEnLw70DK9fKA8OLxAPDl8oyAwBARsAC8QMAiMAIikNHQA3DS8T4xwyCSsJ
YAACunYH5BxCCSsJTRUABOMcYR0PKQkrCYsEAhkAAIkFAOgcNCltKuccLw0MAgACBvwcRiJtLxj8
HIEdDA8iLyQPIiYAhw8YLxoPGAwdAh0BHQASTRkABwIdAjQAIy8dMwAHAh2hIg0PHS8fDx0NLzAA
AOYAAgAGAxcAAPoDBgodARQABhodAFIAAg4AAQwdEUgMHf8MCB0MHQhOF_AOCC0IDlfwAQ4oDhfw
By4X8AknJA1sD-olCgOMDDMMuiyqDEO6DAoMCwAU2gkAI1qMCQAELgAsOqwjAAY3ADoLuiwuAA-V
JZIhfw8EAAK4DCOPDzUAAKgMIZ8PBAADlgwCDgAEwgsBDwARDzsABRMAE38TAA8XABJFEE8PHxcA
AgQANh8RTzYAIU8PaAwFHwAADAAYTz4AEz8bABg-FwA1-w8FQQw1-w8DKgw1-w8BHgwl7w8WDBbP
-xsfr-cbXAIzJhVQCgACrwsIDAAgjxQEAA8PAAVYXxRvFl8PAFwPFk8UDxMAAm8hCRcAEz8TAFwv
FC8WPy4AHE9BABi-DwAfP5AABxsVnwAHyQAfFQwAAQ_9GgcPfCZbAgoAAZAAQxv-GQM4GpJPGT8b
Dxk-G08zAAD3GSFfGdoLIxsPCAAUXxAaEV8VABMfBAADGQABvQVTGm8ZDxsEAAPYGRNvWQASbz0Y
ALgZE59VABKfEwAAZRkTjxMAFo94GQkTAAJgGQalAAVIGTX-GQMpGTX-GQEKGQIMAALzGBbv2xgB
CwAPwxhhBeAmAoEXDKgYM-8eAxQLpU8ePyAPHj8gTx6NGCFfHjVKIyAPCAAQXxsABBkAUw8eHyAP
CAASXzQAEyAbAFU-Hg8gjxMAZh9PHq8gTyIAB5sYbx9fHo8gX2wYA2VvHk8gbx5gGAKpAA9NGAAE
zgAAPhgS7zAADzAYEg8sJ2pUPyM-JW-tCiFPI-EKJCV-4wogXyPnCjQfJY-VCiNvIzwAkyAODX8j
TyWfI7gKIX8jhQAQJYglJF8jtAoRfxIACgQAJV8jvQoTbzUAAAQAEE8XALIfNSAPIQ5fI48lPw8A
cUAPIQ7-IwEMAFJgDyEO7xcAUoAPIQ7PCwBSoA8hDq8LAFLADyEOjwsAEeBeAAELAFPwAQ8hDl4A
Y-ADDyEOLwwA7wUPIS4MHzXwBywb8AkrgSdMAmIXDJ8XCAwAVn8oDw9-nAoRP38nYg0vFD0PKawE
UCpNCg0KFABTDxQNDE1-CoFdCi0PDy0MXV8XcwttOg8PPG12ClGtDyetCWIKoQttPyMPHj8ZbQml
BMEJXQ8jLQ8eLQ8ZXQlVCoAJTQ8jDQgNDz0nQQ0HTQlSCjALPSgSADEnPQlHCmELfQ8efQmdAGwL
-QEJDgYIAP8TcA5JbUkOFoBOCU0JThbgDgktCQ5W8AEOKQ4W8AcuFvAJJhoKVxIcGQpBCwwKGxsK
MSsMKh0KMUsMSh8KMWsMaiEK8QCLDIobCDAJCxxrHAtqGwolCsMLGhwrDyoMGisqGxkSAJQ6HyoM
KgsqKzkQAHELOgsqOzkK8AkgOgsbACUKCw8AVhoLKisaDwBVCgsqKyoPAEYbKis6HAA2KitKDQA1
GitaDQAzS0orCwCRGhspGyobKRoZDwBRK2kraSoYAFAKiQqJGmAKURppCmkaYgpRGkkKSRpkClEa
KQopGmYKUhoJCgkaaAofKmgKLSCPEU8EcB1vEA0MDuBzDlBMDR8PDCR4USwNTA0rA3lgTA0sDUsM
pnhAXE1bDJh40FwPKisMCwxbDA5ADh0nAEArDEscXwpADAsdHBwAYissGxwOC84JMgwrDRMANAsc
LhMAMDsNGyQAJgw_EQBYCwwrLCsRAEYMKyw7EAB1KxwrLEsMC0IApAscGwwLLEsMHhtoAHMcSyxL
DE4bNwrwAgxbDEsMXgsKHzVACgxbTF4LKQ9wDEsMLgtOCyUPcAwrDE4LLgshD3AMGwxOCx4LHw8w
HG4bGQ8vDHt5MC4w-xYBMgFB-xUBDSkKoRUPFA3vFQ0ODxQuCqQVHxQNzxUNHg8UUgmILxQfKg0M
jS4SAEIPFW8UCAALFwARXxcAHB8XABFPFwAcLxcAET8XABw-FwATLy4AHg9gABMfGwAeHxsAEw8b
ABwvGwARHxcAHj8yAAAXAB9PZAABPy8VX2AAATwvFW8XABjPDwAAlQBUzg8UHgsRAFELCu4LDg4A
Y1AOCv4BC40Kv-sBCR81gPkBGKD4jQolge8bDrAOHa8ashUQkLERUawNDxkM_XtRDYwNGwyJCkAN
LA2MLAMA_XtRDyp9OwzdBZANTA8qSwwLDEvXFWANTA07DBsMAACBCAAbAGE7DCscSwwBfABBAxEs
GwAUEA4AADcAAGsKEW0oAxFsvi4yDEsMJQNQTgsKCRAPAAMNABEZDQAxGyw7GgBRMA4MSzwLAAAB
FAEVA-ADCwoJUA4MO4w_CwoZUA4MKwyO_wJxCXAODBsMjvsC-w5wDgwLDK4LDgsKCZAOHK4bChmQ
DgzbCgmw6hnA6UIKJTM-IC8_CiIvH08VEB5BCiBPHxEKIB8frQhgIG8fDyBvNCIBSAoAcgohXx-p
CUIfDg8eUwoQHz0A5B8PKh8gHx8vHg8fHg8eYgpgPx8PIA8qFQowPx8_FwADFQBBKk8eDywAARUA
AnEKIU8fPQoQH4gAEE4XABMwQQACFQAUPywAEyAXABEvFwA2Lx8PRwBTIA5fIB8XAAAIABRPMQAQ
H0QAEw8aABgvMQAAGwARHxcAGj8XABFP1CICFwAVTqYAA0kANC8fTy4AEx8XAHU-Hz8eLx8_-AAB
gQBwLk0uDx4eDCYAEFCeAoFeDF4MDgwPHJYCQ24MbgyyClAcTgxOHDIbYRscLgwuHNsxH2zbMS8V
H60KAbkKBtcVEiRmFQK1CiEvJA8KA7kKVD8kDyU-vQohTySiCgLBChNPRAAUT8kKVE8kDyovEQAT
gCIAAoQVAyYAF2AmAAUqABlAFQASLxUAFyA-AAAVAARDAADrChVfFgBCLyNfJOgKAx4ABRgAUQ8k
Tg8j5QoDGwAJFwABxxMDMgAJFwARQBcACRMAFWBBAAUTABeAbwADEwAToBMAAw8AQMAODyQ2ARI_
DwAi4A5AABIuDwAj8AGuFhMeEAAiAw5NABMOEABDBQ4fJAsAIAcvBgAvCS0dCyQVHxsLAScLBR8L
RR8pDyrVFSAvKToLAScLQB8qbymsMgCpFSMOcDcAIl8p8BVDDycPKBwLAEAAEz9SABA-0xUGGwCY
Lyk-Ki8oPykvEwACkQsAnwsDFwAiUA5BABE-FwAwHyk-FwAATwsiTynHC1AvKC8pTxUAGyAVAABz
AAEZADUQDl8VAAAIADFPKA4LAiMpT2gWBRkAAnMAExAbAAkXAAELAgLDACEoLwgAEj8XADFADg8m
ABAPiAAEuAAAuAMAFwAqPyniACIpHzkAIykPQQAGEAEBEwAhXycEABUoQgGhHylvJw8obycfKJMG
IE8oTABBLydPKNwVAkAAAEQAEU49AiQoDzwAEF89AhAvJgBO8AcuHRgCD9ILQ-AdGDwLDAvwBBxq
G-AAHLoJwAzqCaAMGh8quhmADBouygkIYAwqHtoZCFAM_gToFcMwDGoZShlKGQgwDFoEI3M6GQgN
EAxa3jswKikIDQAA-yKTKikIDQAMWgmsCgD6AWoJjAkqOQgNAAt6CWwJOjkUABFq9SJzGkkIDRAL
avMi8CYqOQgdEAt6GSoZKkkIDTD6AUkIHTAJ6lkIDVAZqmkIHWApWokIHYAI6QgdoBipGB3ADRhp
GPwPEGj8Dx_QDQEeET-tFfEEDxDwBB8Rbw8fEPAAHxG-Dw8OwN8VIA6gNhVwHyq-Dx8OgAsAMC8q
z-pdEGABIoAfKt8PHw4NUJMVMC8OjxgAAP8KIRGPkiEwDw5-HgARMOcVARAAEG8QAACqDwBLFrIO
LxEPDl8PLw4NECIAFD8QAD8PNQASAAEAVgByTxEPDk8PPxIAJRCPJAAXPyQACRIAJRCPagAST3wA
FBCeAAEkAAAZExQQoAASPyQAYDCvDy8OLwwAABETQA7vD18WAGBQHw6vD28UAGBgLw5fD48KADCA
De8HAFCgHa8OHScFQB1vDh0bDV9tLvAEbosBIAHnFdEPFfAEHxZvFB8V8AAfdUmAwA8W7xQPE6Ck
IXAfKr8UHxOACwCQLyrPFA8TDxJgiBWQHyrfFB8TDxJQNxUQBBcAAIsBYRaPFE8TbxkAQDAPFn9P
kUEWDxNfEQAADQEBEwCwbxYPE08ULxMPEhB6PHEPE48WDxM-EQAAQwEPEwAJMy8UPxMAHhUTAA8m
AAEEcAAzLxRPgwAUFZYAET8mAACRARAVtgATPyIAUTD-FAFPGQBhMA8T7xRfFQBhUB8TrxRvFgBh
YC8TXxSPCwBBgA8S7wkAcKAfEq8THxKTAW8fEm8THxKVASkSGxMW8QLwBB8bbxkfGvAAHxu-GQ8Y
wA0WIBigyhVwHyq-GR8YgAsAkC8qzxkPGA8XYKEhkB8q3xkfGA8XUHQVMS8YfxoAAJgBoRuPGQ8Y
LxsPGG8gADAwDxscAFFPGw8YXxEAABkBJRuPEwBQLxgPFxAkAHEfGE8bHxhPEQAAUAEAFhZmGI8b
Dxg-EwCzXxkPGK8bDxgfGT8TAB4aEwAPJgABE2_UACIPGwgAMx8ZT4sAIBpvJgBBGz8YLy4AAKQB
AHMWASoAE08mAGEwnxkvGD8NAACrAUEY7xlfGABhUB8YrxlvFgBhYC8YXxmPCwBBgA8X7wkAcaAf
F68YHxerAV8XbxgfF6sBKQHDC1EPH-AEHzMW8AHwAB8gvx4PHcAPIO8eDx2g7BVwHyq-Hh8dgAsA
kC8qzx4PHQ8cYG8LEB_2CzAdfx51joFQDyCfHg8djx4AAK8BISCvDwAAHAASMBwAJA8gLQAAIAEl
IK8TAE0vHQ8cEQAAXwEBNwBeLyAPHW8TADNfHj8TABAfdQBVTyAPHU8TAB4gEwAFJgAzPx5PgwAl
H38TAAAmAACjAQEmABcvJgBDMJ8eLw0AAKMBQR3vHl8YAGFQHx2vHm8WAGFgLx1fHo8LAEGADxzv
CQBRoB8crx1oFn8OHxxvHR8cowEpAq0L8Aok8AQfJW8jHyTwAB8lvyMPIsAPJe8jDyKguwtwHyq-
Ix8igAsAkC8qzyMPIg8hYDwL4B8q3yMfIg8hUA8l-yMEFwAAnAFhJY8jPyJ-GQARMDcWQyIvJQ8R
AAAZAQUTAHGPIy8iDyEQdBYBEQARnxEAAFABBRMAXj8jHyI-FwAAemERDwgAEz8bABAkGwBZPyUv
Ih8XAAEyABqPKgAAgAARbxMAE0_TAAETABFPbwAAJgAArAFjJI8jTyI-IgBRMP8jAU8ZAGEwDyLv
I18VAGFQHyKvI28WAGFgLyJfI48LAEGADyHvCQBhoB8hryIfrQtvHyFvIh8hpQEpAl8L8Aop8AQf
Km8oHynwAB8qvygPJ8APKu8oDyegbQsAEgAwHyeACwAyLyovDj5AJw8mYNoKEB_ACyAPX-MJcyZQ
Dyp-KE8eAACwAbAqTygqDk8PDi8ULiAA0TAPKj5KDi8PDk8UHh8jAEQQDypOEgBALycPJhAAYloO
Dw8OXxAAAFUBdSpeSi5PFC4PADP_BT8LAIQpXk8jLk8ZHhAAICpOIBhVHg5fGQ4jAKNOTyMOLx4O
TxlPcQAkKT4SAAAkAACQAZMpTi8jDk8eDi8kAGEwjk8eLk8dAIEwDyd_Tx4eXxgAgVAfJ24vHg5v
GgBQYC8nXo0JAP8MgA8m7QwfNaAcrRwbwAscbRwr8AALbCvwBGuQ4QpwHhngCjIcShzgCnMMGQwq
DBkM4ApyDDkMCgw5DOAKUgxJDEkM1gozWgypCgBDagyJDOAKWgxpDDo5FABjagw5DDkM4ApADBkM
Cl8AAuAKPxwqHOAKCi-5AOAKfBkR4AohER_VIAXgCgEQAAngCiERL_1GBeAKJBE-EAAE4AoLEgAA
VgART7UgB_AKAyQAFz8kAAkSACUQj2oAB_AKJBEfJAAE4AoBEgAH4AofEeAKtycWb_AKWhZPEw8W
4ApYFm8TDxbgCloWjxMPFs0KDxMABQrgCgsTAA8mAAEEcAAK4AoBlgAK4AofFuAKvxob4ApYGy8Y
DxvgClobTxgPG_AKAxMABuAKWhtPGB8b4AogG497CgYTAAAsIUqvGA8b4AoLEwAPJgABE2_UACIP
GAgACuAKAEULGhvgCgEqAAjgCh8b4AqsGCDgChog4AoYIOAKNCAPHS0ABOAKAxMABuAKBxEABM0K
MCAvHVEXDRMACuAKMSBPHZUhBCYADhMABSYABLoKAuAKAxMAET_WCgLgCgFfAAjgCgMNAA-gCrsY
JeAKWiUvIg8l4AoBEwAI4AoBEQAK4AoBEwBePyMfJT8XAAAwIQDiCgrgCmklPyIvJR8XAAEyABqP
KgAAgAARbxMACOAKISVPbwAI4AofJeAK--9PJsoJ4Aon6gngCiD6Bd0KMcosStcKUNoMCgxK0wpB
_gAMSsYKInqMCAAh_gW3CiJarMkKIvoA0goQCzIAESrGCiLKLMAKLPoCvQogCbq9Ci8Zar0KfzT-
DwS6CgCYChOPtgoFDAAAIgIhEb8OAAKuCgUMAABOAgEOAAAmKxlvvAoTDwQABooKDxYAAi8Rb6Ir
ABUvNAAfb6ErABIfpgpHEA8QX6ArEB80AAC6AkIQ-w8Cxwo--w8BxAqyEK9HCgTECgYNAAADASEW
j6IrA7wKFY_gKwWpChmPoCsHwAoGoCsHngoTj6ArOE8UP0EAGK8iADY-Fm_8CgCOABFvHgAUHw8A
H1_4Crs1-xkEtQoz-xkFrgoVbxcrER8dABIQwQoIvCsWT7YKCrwrB74KABsAHG8TAAJaABY-mAoT
r1YAFW8TAB4bEwAFJgATX5AKBLYKGRm2CjL-GQIfAFEw-xkBTxYAD6wKoRTfqAo1-x4EpQoz-x4F
ogoVb9IrER8dABAQiQoK0isUT6oKG3-SKwIZAABTAQEbAADSKwfFClZvHq8gL4gKRv8eBT8uADiP
ID8bACMET30AQx_PHk__CgCFAUIf-x4CGwBRMP8eAU8WAA_OCrZYfyM-JY_OCgDgKwIRAAALASUl
j_IrA44KABEAFr9zCgAIChh-DwAG5ysHVAoXj_ArBAQABh8ABTYAAgQABzYANo8lH4YKQf8jAz88
CgEMABICGAAPfAqeGM94ChTfdApE-ygED3EKY68oDw_PKG0KMG8oKkwKQS8UTh8gAHAQDyp_Cg4K
FABTDxQODU5yCjB_Ci7xPgEPAAA8AWYqfjoPDz0PAFK_Dyd_PAwAIil_7SskPjwrAHUPIy4PHi4P
EgBgKX4PIw4LhgpiDxkOCS5MeAAwKW4rEwAwKS48MwpxEA8prg8eXhwAQDD_AUwUAEAwDO5cEABA
UByubBAAQGAsXowIAP8LgA8m7AgfNaAYrBgXwAcYbBgn8AAHaCfwBGdfClNAafAEGWMKAwY28g4Y
wAkcqgsJCKAJDOoJCIAJDPoBCQhgCQz6AwkIUAcANQ81MAdcGjArQxIQvlsSCsBbAQ4AACkgABsA
EAANABSsCwAxWgmM8EKNAAkLaglsCWoWABFaLiARWlQACCJDUx4QCQtqBVwwMAgLkABAHjAICQgA
QA5QCAmuAPEBHmAICeoJCB6ACBmqGQgeoDU2UR7ADhhpyysfaMwCIxBuZycDogoQHmsnAO4JYBAf
DcAOH14KQhAODw0mNjAODw0mNgJBNQAjNgJXNRFQNBUiLo1uNTIODxGtWwHMKwERXAB8WEIQDgyd
cFgQEBYAETx6WBkACwAzfQ5MCwAgDxAnXBSNFwAECwDCCX0OLA6dDgsKEA4JZABTCxoQDglkAFEK
MAsJjZFYIDALKKQjCwqZWC8aYJlYDw82AR8gbxM3AQNHCgE3AQFJCnEfEsAOHxav-7AwEqAOTwoz
Dg8S8TUfDvA1BSAwDuQUUE59Dg8SCwACeVkhDxI3ATFtDmwNAAGLWBCMhlkAUSQEDAAZCgsALw8V
FwACEglEAAE5AQPVWQA5ASN9TjcBL-0DNgFWEBg2AQP0CQE2ARAb9glxHxfADh8bry81IRegoTVQ
Dg8XgA7NCQCvNBFgCgAA0TQAkzVRfxkufQ4eCTIODxvGWiQPFxlcA20CA00CAEABTB5MHm0SAQMl
XAALACYPGgwABxcAIwldJlwSXTgBVF0_DD5dcQIBUVsAOgE-fS59OwFWAg8rApAJD1E1FyBgDpsT
ATlABi9cATsBQyCdDp0wNQLSAAEHCQCoAxEMGQAFCwACcQIA0V8CiAMHCwAARlweTMEDFAkLAAtx
AgICBA85AV0QIjkBA0QJATkBAUYJUh8hwA4f_zQgDyErKgFFNAAjKgJaNBFgCgBVAw4PIVAKAAE4
AYAlfyM_jQ4PIQsAEW0KASMPIaoDNiwOrTVcE705AQROXAEkAQZOXAAPACQPJE5cD7IDhxAnPgED
7wgBPgEB8QhQHybADh_0CGApDg8moA73CEUODyaAVFxBDg8mYA0AEk8NABhQDQABRwEByzQRT8s0
MA4PJhEAIC1KQVwxTxQtIwAArDQTPRIAACIAARAAEFrpNBFfEAAAXAGFDypNSi1PFE0PACT9BwsA
dilNTyMtTxkbACA9X-JbNQ1fGT0AMSk9TxtcNE8ZPXIAJCktEwAAhQARHxMAUD0vIw1PJ1wCJgCR
MA8mDyltTx5tIQBDMA8mDg0AAPw3QyYObS8aAPADYA8mDu0ODB81gAwerR4MG6Acj6oAaRMebmkT
DwoJXjcqSzoLCTgayxoMCU0K_wEKDgmCCjsJHAkrCRzeSw0QCSEKOxEJLTsKEglCCksJjC1MChQJ
CRgACRYJgQpLCRwJCwkcHgALGAkCnAAIGgkBvQAHGwkAQEwPHQlSJy8PzksCJQkTPxMAAhcAAzEJ
BBEAKx8P3koARAkVDxEADyEAABlQIQADWkwFHgABRwMJQQAKHUsBVEssDw0lAAEnKRsOJQAB-gIF
DkwOsUsBJQAKIwAGcUwHRgAbAPAAACUAC7UACiMALw5PIQABCBZMB1hMAxIABEYADyUAEQUTABAf
QioJJQAVH-kALxAPRQENAQsEB0wACicAA-BMMjAPDQ4CBopMAZNKAd4UEA1dQwbSSlULDzVQC4xM
ACcAAcEFFE0fAADHBQGaTA_zClQCTzUC6TUDuwoTPxMAAhcAA8cKCBUAAAQAAXtMH2AZAAAFt0wA
6QoEXgANOgABxAIFHwAEtUwTHQkLAAwBEQ2nSBIMBEwBj0oTHVFMAigAERBzTAOGTBMtpWMULYVM
AfBIEgA2ACEOi4MBAREAGQw0AB8JMwAAKQwdaQABLzUWLbpMIR0ONDUAJQACuEwRLZ9oASMAAgIA
AT9JFwrjARE9PkkmDi0PAAB5RxU9DQAwgAoeDQAfLThJBQ9vCzwXL1lMFi97CwgXAAknWQCPCxcf
FQAPBlkCH2BCAAQJSgAAxQsIFQAABAAQLmU8AdtGBdsLKRwN3EwhDRznCzcLHA3LTAB8SAEXAhks
FgARLBVoLQwN40wkCQAXAAHtAQsVAAPFTAITAB4NEwAPJgABJywN7UwhDSwpAgAfSQTvTAEeSQQT
AAjxTCENHDICAw0ABvNMEgw4AgLRAAQCABIsPAIERQAFQQAoGWAqABIsRgICEQASLEgCHmxIAg98
DEYQLxUACDVZAIgMBhEABx1NC5cMEA0DTTAdDgw_TBUNoQwQPaVMEw0YTQKoDBULqAwBBU0ATgEB
dEwBsAwBBE0QHSNLFRwaTRAAOU0yKw6NwAEANAAAqQEDtEwSAAlNADcCAzEAACUAMX0OSzhNEgBH
ADMOSw4vABAQ_AEELwASLQEEBGVNIjAKSwATLkkAAMMBEi0QTSIcHb0BIv0BsAEULRUAAKwBAQ0A
D-IDBQ-tDDwTP2pMFi-1DAQTAAAEABQ-AQ0XLxUABRkAABANCBUACR0AH1A2AAACagAFNg0GPABA
Ph0PJB8FAkMNAA8FIw4rSgUDSw0D5QU1Kw4dFwASEKIFEit9BRYM3gEVDSsAIQ0edQUF7wUAVQAB
Jk8BvwURAL8FEA4qTQblBQo7BiIJAIcAC-YFAhMAA4YGIwoZCAYzDU4dIwAP9gUBAtYFBCIAFlAR
ABItBAIJ9gUC6AcPBAIED7MNPAI-NgIEAB8vvw0AGB8gABYPDAAWH9MNAv9pBdcNBCIAAwQAAR0A
BxAAALU3ATgNA-MNBT1qBPcNMB0PKRBqA28AAvMcISkdNAAB9A0HLWoECA5QDQ8pDQwYAAIMTQEc
AAALAAE1AADtDQJPagUXDg9qTQQDIAAEZmoJLwACOmoBKAACO2oIMQAZPW9qEz2sACQMHTYAJC8e
NQATHUcOKAw9cWoFSg4iDA0CAAMaAAWXAANZDgIXAAZdDgLiUiMvHuNSBmcOAK9vADAKABgAQi0e
CxkyCmAZwAkbbhtKAh5rSgIPdxd8ACBNFDCDTYEQCQzKDAoMaloOI_oMMQ4jaowJACH6BwgAMwtK
rBEABCMAEws2ACMOEIJNIx4Qek0PUheeAgoAKQ81cE0JDQABHwMBACIBsUwJDQAByAIjEa_QIRaP
EwATjxMAChcAHxAXAAMvEV-3IQAWXzYAE1-sIQQfAAAMABVfmwAOmU0CRQ0HmU0ADQAVAyANAqZN
AOoCD6ZNBUAerw8eCwCAoB8NHm8PHh_mTTcNHw02SQ-JF3AgnxQEAAPCDAUNAAETAWAWfxRvFn8P
ACMQDuksIhQPEQABUgEnFn8JIgcXABNfEwAACSIVXxcAIxV-CSILQQAY3yIANT8Wr38AFRWOABof
DwAAjQEyEg8VxgAAjQEkEg7SABFQDAARARgAQWAPEg4HAQCNAVASHq8UHgsAcaAfEh5vFB4RIj4N
HxKNAQ8gGF0CCgACRAwx-xkFNgwAciECZyEhXxkdAAKDTQIFIgQNIgGLTQQZAAgNIgakTQEbABxv
EwACWgAPyk0HACYADhMADfBNOQ4PGqYAAaYBEhrDAACjATIXDxrcAACjASQXDugACONNJWAP101w
gA8XHq8ZHgsAcaAfFx5vGR4VIj4NHxejAQ_IGFMGzU0ELk0VMHBNITAOYSwBESIDck0QENxDCxEi
AXJNBBkACBEiEm80ABMAGwAAESIWnxMAVV8eryBfDwBHH-8eBy4APo8gbxsAIBAOrSwwTyB-GwAB
iQEG-k0C400RAxkAETDjTQLOAAbvTQCJAQ-vTRsP2BhwMm8jP7pNEzDTTQAVIiOfI5QLAigiABUi
AVhNBBEAEt8gABEADwAD_k0EDwABFAwK-E0CViwbDwQAHl82AAAEAAk2ADWPJV_LAEEk-yMFrk0G
DAAAlwEyIQ8k0AAAlwEkIQ7cAB9QLk4GQB6vIx4LAHGgHyEebyMeHSI_DR8hlwEPMRlJM-8oAVsL
M-8oA1QLAgoAAZcBcyqfKA8PnygtCxRfAE4RXSAAAA0LF20AThNtIQsSbQBOAjoKANMKAgNOBQ8A
NK0OrQwAFCkGTgUdABRtCE4WbSQAQw8jDQsKTiQJbXsAMCldKxQAISldigoAEQBBnQ8enR4AASYZ
If0DGQAwMA8mqRpQCA81UAgFD-EGCBdgCA7tDggXgAgerR4IF6AYHm0eJCIfbiQiXFEwKaApkDFY
EmAGAGMJHCobCUAGAIAMagsJIAkLepgK9gV6CwkACQyKCA81EAkMmgsJC5oJCAoAAHsKMaoLqgkA
FAwJABELpwpBEAn6BogKAAcAEw5-CpEeQAgZ6hkIHmD-VyEekHcKai6QCRuqGSkLxXAJDHoJegkI
DmAJCwkAMWoJCEQZkXAIShkIDggZOsEK-wQ5GB4AGDkIHqA4LiAOOB7APmA_dUkfZROO8AQOT7sK
gAMODV8PHQ8NCQCTfw8PDfACDg2PCAABwFcANkYEylcAcscBPAoS8GkKARUAFuALABHQvQoPCwAI
AJVYFq8LABKf9wkfwDcABAJsADgfNdBtACUNj4wADgoAQgEPDQ62AP8RAgwObw8ODA818AIMHl8P
DgzwAxx_DPADDzWMC-AEi0CsSh8PRQoDAKxKPxbPFEEKAhVwCgABeUYPTQoEM-8UBUoKAgoAAflJ
DwwABR8VGAANETAMABEDwgkGDAAAgAAx-xQCFgAECgA-DzVw7QkRD7BUKnUZTxjwBh4f7gkgAw7u
CSAPF1UCAt5WJPAACgAB-QEgG68LAAUJAAEnAgQLACGwHgsAMR8XkFIAc68ZLxofF2DnFqiPGQ8a
TxkPF0AOEgoEWQkREAwAEwf8CQIKAAH3BBcaDAAPGAACIBAOnQBRGg8ZHn1zCfAHIA8XHk0ODA8a
DQ4MDk0eDB81QBxOHA8AIBxOFAgyC0wLHQBwC0wrkEsMCgoAQgBL8AEKACzwBwgAb0wL8AhLoFgB
HUAbDx3wCk5g8AsODfAK-G4QHAcAYSAPHA3wCQ8AMA3wCBAAAJ8IBgoAMQ3wBsMVABUABQoAEA1J
0gIeVwASSgIqCSLwAb4VRA8c8AAKADAN0A5QNjUODxwJAGANsA4PIM8KAAUJACgNoAoAHx8UAAcw
sA6-CAATHQgAMA3QDDgJYAwd4BxuHKDUD50HI3M1XyLwBR4fNAkAHAhU8AIeHyX7VREBJBUEDAAF
fVYBDAADfQgv8AIYAAgEDAARAUAJBgwAIX8jiwkiDTAMABANM8shDyVyUgAGK3IODXAODyQOEABw
JJ8jDh0wHhgJAxIAdCWvI14fJR8PADIk3yO-ABE-EgAiMA71CCYNHwsAAVEEAC0rIw0fCgAQARUA
UnAO-yMATTEA_QgASA8QHfcIAFExnwwdbh0s8AAMbXnUI2MZTvAHDh84BjIO8AW2XSEQDz8CExCW
XTbQKRANAKYALxOACQsMCwkAFAAiDxNBBaUPE2AJDCoJCAAOWx0iDxMmHDAPE0BdIBUIGgABFjwA
hTEBsSlWCA81Dh9NAAIaAAGdVVZaCQgAHhgAApsxoDAZSgkIDQAPDR0WABE-FgD2ER1AaQgNEA0A
XxMfEh1wWA0wVy2QXUBdoF8iQF8YkB8iPgJEDTAPGL4EUh8XYA8ilgEAZS2hDQAPHRAPGA8aP3sw
EkAcABJPHAAAcjkwDx0AHwACmjAQMB8ABh0AAQZQBSEAANgwRA0gDyI-AAA_ACEvHk8vBiAAAEIA
JiQvXwACIQBhAA8XDxgvIgBUHUAPIS9gABRPHgAA0DBQHWAvIR00AAIWAIYNAC8XHYAtACgAcQ0Q
LdAvHS_lLzAN8AT-Lp8d8AVGHfAHTaClCVGRL0mASYAJSwlgBABhCww6CwlABwAQCAcAEVqkCUAM
WgsIBwABpwkwCwx6nQkQC50JIAyKFAIBnwknDJqXCQwIAAMoFDIeIAkoFDJACQsgFCEJCyAUMgkL
ygcAIAzanQlACwz6AMcUQAsM_gLIFAE1ACYOQAgAMIoJimYUBa0JQB5gCAu3AhAIFiNwHoAISQge
AAUAYKBIHiBIHr-LD60JJCB-ECJRYQ0fEU8PDQoAG2wHAAKuCcF8DQvwAQ4NjA4L8AAHAAEuCUOM
DgsKBwBQ0A4NDxEJAFLADg0JnAgAGawHABCcJG0BLQApGtA7AANCAABZABB8CABAAQ4NbAgAEQII
ACPwAwcAEwsHAK9_CwrwA4sK8ASKaAkeMDSPE3FYEBUHUhAN7RIQDXJYAMUSMA0OwAkAML8UDW9Y
AAQTEA08VwAHCREAPlcBCwBSAg0PEkALABEEVwkWDSYJDwsAOAFYAAJmCTJADg3lCQC1URQNUAky
Dg3PCgBCoA4NrwoAUsAPEg2PCwBA4A8SjoJcbwGMG-ADiz5YHwBGE0EFDm8aAQIA_RIRDVQJEA06
KzANDxcyAQJzEjXQDg1JCQ4KACCgLgoAgC8XgA4tzxktZRMQDQYJIAINSAkBCwBSBA0PFyALABEG
PgklDf8lCQ8LABekEA4NfxkODQwefEQJQQ1cDgvqaBBc2RjhQAteGw0MDhteCxpgWwoZAFIKWxqA
WgoAQgBa8AAKACzwBwgAX0sK8AhKPwknADsJUA7wCg4NDQAgCA7rDhAOCAARDBEAYAYODQ8gHDrd
QQ4NCxwTAHQEDg0LPA0OCAABAgNEC1wNDggAASMDRAt8DQ4IAAB2A1ILnA0PHAgAkwkKsA4NC7wO
CQcAXwqgDg3MBwAFELCZAxIJkgP-Bgka4AkNbA4JGvABCW4JGvADaRrwBSIkH6I0fyLwBA5vJA8h
-lMCDQkPDAAkASUJABcJEyQZCQEMAAEXCRGwCwkADAAA8gkTJNgIAA8AF5AJCRN-GQkkDyUSAAAr
CQDQCAcdCQAvCRBdEgAGIAkxryNfpVUEEAAAIBIKKQkUQBQJAkpVQu8jDg1BVRHPCgARoEUAAAoA
IsANdQCfHzXgDY4NHPABAGYkAR8JEU8ZCRANtyYRHRkJFw0YCRgNFwk1KwkAEQARDz5qYGAJCw8M
GhIJKA0vLAkTHxMJMAsPDLN1FA0UCREVkCUBFgkfCxYJI1YMAA8NHBYJcRxAaQgMEAwWCbUccFgM
MFcskFxAXBYJkk8kDyEMMA8YTwoJEx8ICRQMCAkAFiQECgkCsVcAHgAAZQgNCgkYJB0ADAoJGgwK
CREfFhYJDAkXDAwJAUQADQwJExwMCR0MDAlWHGAvIRwWAHcMAC8XHIAsDAk1DBAsDAkSDAwJjxzw
BUYc8AdMDAlScDVZ8AQpHDtcHfAnTFsZsBl8axmACZyLCWAJrJsIUAk7bHsZCA81QAlrPGs5CEAJ
ixwrOjkIDjAJq2pJCDAJq3o5JWABBwDAMAmbeikIHjAJi4opsggBBwCwUAg5K5oZCB5QCGkPABJg
BwD-GnAIaXoZCB5wCHlaKQgOkAjpCB6gCNkIDsAIuQge0Ah5KB7wAHg_8AJ_OAwfwDY_8AgOPxEe
8AUOba8GEI3aB1AvEE0vDyQFIC8QrxGANdAOPxB-Dx4HAADLEUE1sA5PCQAVDQkAYQ81kA5fEBsS
BQkAAPAMIV8QMRwFCQAAGQ1QbxCvDy5kHTJfEM8UAHAwDw0_HxDfFgDxADAMXt8PLgwPNSAMfq8P
PgkAQY6PD04JAEL_BwwLBgD-BTAc-gMcG0ALLM4sK3AbzDvAy-AU_wAd8B9yTxPwBh5PFh7wAh5t
HxQO4B5tTA6wHh8VbVwOgB47XXwOYA5rLawOQA6bzA4wBQAAzwQwm6wuPRwxq5w_-iIwq4xOtiIo
m5wHAECLHnxOpyJAO25cTo0i-xiuLF4KGVAa-gAaGXAJGr4aKaAJGn4aKeAJGi4qKfADCSo58Acp
8DfBAB1wUo8Y8AIef7sR8BjgDo8bPxoOwA6PG18aDqAOnxtvGg6ADp8bLxlPGg8XcA6fG08ZPxru
BzFgDo-TGxEerBsgGm9ASCAaLhoAkkAOLxovG68ZPg0AJV8aCwA-Txq-CwAAPz8azwsAADUvGg4M
AGIfGh6-GU4MAGAPGj6fGV4MAHBQDxdOXxl_bAhQUA8X-gMqAv8HDf4BDRyADe4NHKAtrg0cwByt
HPAAvNUBH-EUbI8d8AIejyBekB7NPx8eYA48nWwOQB5MbR8efA4wDmw9ezz1WTB82y7HGjFs6y7H
ATBc6z65AUA8PrtOV44wfqs_U47wFX6LPgoZQApuiz4KCWAKbms_ChlwCl5bPgoZkApeK04KGaAK
znJiFa7okiAKbn9x7xouGhnwBQkqKfAIKfA2wwAdMBk-IpQDESWUA1Ae8AIOnYsD8QkfJH0cDtAO
TE08DsAOXD1MDqAObB8jHUz-25BsTyNcDoAOXGsPAHJwDyEuLHs8CgAkTosJAC2bLAkAgA4cCg81
cApO4ABRcApea04HACFbXgcAIEteGyX-IF47XgoJkApuG24KCaAK3goZsAq_ChnQCp4KGfAACn4K
GfACGj4aGfAECTop8Ac5hAUeMFB-JkQNECrtIfAPrQ8pHsAOvSwOoA7NPA6ADiydXA5gDkyNbA5Q
Dlxt4OFyMA58XVwfJwoA0V8oTD8nDjAOXL8oTyecA0QfJyzPDABSPyfPKF8LADRPJ78LADRfJ68L
ADBvJ48LAAC2EVB-J18obxYAUUAO-ycE0FtQ-ycCDh_xEYAnAA4fNZAO3yoA-wCwDq8nHh810K4r
8ACr8DNwBlEQNzdn8DMfKgwY8AQZHgwOChwY8AAZHiwOKhwYsBkeTA5KHBhwGR5sDmocGEAJHowO
ihwIIAgenA6aGwgQCAwKHmweDGobCQuDD-EkCAwqHiweCgsKHCobKQsIDRAIDDouGgsaGxwLOQsI
HRAIDEoMGgsaKwoMSQsIDSAIDFoMDgBRWQsIDTAdACArGhsAER0NADEKKyooABBAKAAhGyomABBQ
GQAhCzolAAAMABBsIQBgYAgMOgtpYwD-Gw1wCAwaC4kLGQsIHXAIDAoLqQsJCwgNgAgMC8kbCA2Q
COsIHaDoHcDt8EvkHkA4DvALCicSDd5eAPgSEwgJAAEqDIEPKg8RDyoPDxoACg8AATcMcg8qHxEP
Kh8gAAoPAAJbFGIqLxEPKi8gAAoPAAHiGHIPKj8RDyo-IAATACAAAHsjBCQAE9AjACIPD6QyNg8N
0CYAGBAqABSwKgAlEB8sABSwLABWEB8PHxAsABOQLABEHw8vECwAE5AsAAAUABcfWAATcCwAE38o
ABFw5gBjHyqOHxAfIwABTShRER8qzh_QMQCkB2MfKv4BHxAVJDD-EAPxGUBg-w0DInAvA-D96h7h
VC8T8AgeHyoPFh8S8AQJAFAPKg8UHw8AAKkdUS8WDyovDwAQsGtNQRYPKk8OAJFwHh8qbxYPKm8O
APAEQA4fKo8WDyqPFB8WDxIgDQ8qnxftAewjkA0QDQwPKmwbD5kLYBQcagwPFRMAUAoLPBsaTT5A
OgwOCecL8g8NDBoLDBsqCSopChwKDB4JDQgADQwqCzoJKik6DC4PALQaDAocCgkqKSocDiIAsQoM
OhwaKRocPgwOEQCCHGocGQocbgweAP82miyeDA0IEA0ZigyOGQ0YIB0ZagxuGR0YQAgdGUoMThkd
KHAIHRkqDC4ZHSiwCB0ZCgwOGR0o8AAIHSkdKPAECC0o8AgoMgYfME3-GK5oISoBkyOhKv8bAQ8q
DxdgDd0i8xEq7xsPKg4PGw1QDQwfGQ8qzAseDA0PNUANDC8ZC6wLLg0ART8Zqz4LAHQLSg8aGgkM
EQBgOgs6CRoZDwARCA4ARioJGikOAFYaCRopCg8AVgoJGikaDwBGCRopKg4ANhopOg0ANgopSg0A
JilaDAATnAoAUioJrgkuCwBSGgnOCR4LAP8JCgnuCQ4MDQhQDQz_AQkNGGAN_QENGID9JGgk8Alt
Px1vHPABDx0vKn8gDxzgDx0PKh8gDyqbZRIf9SJAHw8cwBcAEC_oZgIXAANcZjoPHKAZABUvGQAQ
gBkAED8ZAAIXAAIUIxAfnEUJGQAVLxkAEEAZABFPewABU2YhIE8XAGAgDx1-Kp9lZyEcEBJxAPEZ
Yg8gXx0PH8BiIx9PEwAQTxMAFB_aZiYgbxMAEUB-ZgITABI-EwATYBMAFk8TACGADq0NIiBPEVAA
EwAToBMAFi8TACLADhkBABMAEh8TABPgEwAWDxMAAHgZIx8PFAATDxQAFgMUAAEQACIFDsYkAAwA
IgcOCACPCQ4d8AsN8BrOZiRQKg8lDyFNAAAJADEqDyMPABAF7ARCJQ8qHw8AEAMjBRElXWYADwAQ
ARoFQSUPKj8PABDgWmRBJQ8qTw4AEMDzIUElDypfDgAToA4AAFcAAhIAc4ANDyUfKj9NAGA-Iy8k
DXATABEjiQAAFQAAtGUAtiMRJHcDIGANJgAAGQBkDBsMDyU_FABzOwobDBscChAAgAo7CgsMGxwL
EAARCQ8ARgwbHBsOADQbHCsNAKIbHA4KHCsKDhweEADwBhw_CisKPiwNCXANDF4KCwpeDA0ZgAsA
AAkA0KANDE4MTgwNGcANDD5wA9EZ4A0MLgwuDA0Z8AENeO5BDRnwA2btAAoAjwUNLA0Z8ActP3wi
MDLPJkwBIb8pp-ICeSMB3gYAmiMSjzpmLSkOEQAzDzWQHWYSb2FlLSkOEQACzgYAAGYQX7FlAsFx
BDlmBHZlA1BmBCZmMh8oHywAE1AsAAIVABQ-LAATMCwAEx-2ZQNSZlApDjAOX6IAAxcAQS8oXylA
CgA3ZhMfEwADKgABRQAMN2YRKWMKAC4ANj8pPyoAEVAqAAJGZgMmABFQJgA1bylP4wABWwAjbyf2
AB4fEwABLQEBTWYjjydAAR4fEwABdwEiKa8eADCwDs8SAH-Qzh3gzfAUxApRgJN58AUJDEsIagkg
CQsnEwAIADQKGQoKACAICwsAMmDZKAgAQgkM_wAJAAEDGgAIAOD5AggOMDn4BA4wCQz7BT0REAuV
UAAIACH5AjYAQTAJ_AMJADRA7ghSAGTwBAgLChsKABM6CAAQSQcAf3gO8AV_8GbLAB0gU06vHxIR
EgkAZgQE6ToPDAAnNT7wBBcABFkAFQMSAAMHAD014E4SAASIAA4YAAoSAA8ZACcvkF4ZAAIkTlBq
HgsZAAMHABE-xQAgQA4iHgwcAAMHAANEFRJAegAfHyUAARAfd4gHJgAXPxwAKA8NEgABIQAZXx0A
Fl8ZABBuEAAAZxIiEG4TAK--DQYPNVD9B-AsMCMfghPwCA4vFQ8SwQETFSGWCQwAIwB_DAAQXnQk
EG8MABFfMgAgkA68rxQOCwAzDxSuKQAEEAA8Dp8SEgAhDxJDAA8YAAEASlsGGAAlUE4YAEAPFD4d
CAAAoIcQPokkET8LAAARAEMfEg8VHAAQPDYAAa2hIA8SFDlxHB0LDE0OCxQAID4NaTkwDgsM0MkQ
TgRDIjsMEwAQW4g1QwogKg4QAGJsDQ4LSlAOAAAZSBKQCwATrgoAEtsHAEBsC2qQqTcBoxxCDF4M
DQoAEmsJADIBWg4JABAHnPEABwAfOzcaIkBM-xgDXHxCbxoPFwYAEZDQLQBuLgMHACE1gC0kIT4N
FAA1DT4NFQAwDQ4fEgACGAAGDAADHAA0DxcfHAAwHA8XrgAAGgAACAATLSYBMQ4LChEAFasLAFNc
Cw8bTA0AUl0OCwxdCwASPjoBEF4NABRLVgFDCpA6DgwANQta0AsAAKb1DwwAGiTQXgsAUk6QDglM
DAAcTIMAQG4LDG4JAF-7AgqQ_sUNIDCG-x1pAQGSCgMGAAAoARIf4C0DBwABEgBBDx4_DRQAAWsB
AxUAMA0OHxIAAhgABgwAAxwANQ8cHxwABQwABRwAMC0ODAkAEAwIADA1YC4MAFBcCw0OfNMugBsN
DmsNDmsM5APwAwv9Aw4MCkAOC-4EDApAHvwFCiIAUPsCDBpQF3nwEg4MCmAOC-4CDApgLvwCCnAK
DgnbDCqADgvNDgwKoA4L3gYAj-wACrD6AfBMHwEdMEufIsEFNCVvJJgkFCSYJAAMAEYPIz4NDgBp
DQ4fIQ8kEQA8DyEfEQAB7wADDgCQXE7QDgsNDpsMKx6zC60ODArADgsNjg0JADUObAsLAFAMDyU7
DAgAIW5gDwAhCz0OAFIJSwwKUBEAEg0DAAAbABYOFQATGxQANg0eDRYAJT0MMgAEFQAAawAWPA8A
Q3sNDksNACL9AggAIP4DBwCP-AUKYPoG8EnxzR8wJuCerXBBnlAOTyYKAM0IAPA4FycQAADmBQCK
cBQnGwAEDgABGQAAQW8BDwkHHwAIFAADJQA7DyceJgAZKRUABScAKg4fJwB8Kg8oHykODSYAES8Q
AAIMADANLyj-9AQgAEcMDydeBgABFgAAgjiEKg1LDA0LDUsUADQL-AMeAFB-Jw0MmgsA8QGeDQwK
nglADlsNCx0MnQ4JJgARCggAcwxqCwxqDQwNACMKXgQAAw8AIQ49BgA2Gx0OIwAxDiwKBwA2CywO
KQAzHg0MFgAzDAoeFwA1DQw9FQAjHRsrACFcCksAIgtcIwARaiAAQw1qDgmlAI9QeU6Z4EnwGGIK
PVBtPTZ9fQ==
:: gfx/1.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA5LTEzIDEzOjUxOjM5Iixtb2RpZmllZD0iMjAyNC0w
OS0xMyAxMzo1MzoxOCIscmV2aXNpb249OV1dbHo0AG0AAAAFMQAA8xR7WzBdPXtibXA9cHh1AEMg
EBAE8PAsZmxhZ3M9MCxwYW5feAgAz3k9MCx6b29tPTh9LDEA----------------------------
------------------------------------51BtPTh9fQ==
:: main.lua
--[[pod_format="raw",created="2024-03-30 05:39:34",modified="2025-10-20 19:39:39",revision=5354]]
include "drakma.lua"
include "src/constants.lua"
include "src/sgrid.lua"
include "src/hgrid.lua"
include "src/logic/creation.lua"
include "src/logic/matching.lua"
include "src/logic/spells.lua"
include "src/logic/mechanics.lua"
include "src/gfx.lua"
include "src/in_game.lua"
include "src/in_editor.lua"
--include "debug.lua"


local state = in_editor
--local state = in_game
local next_state = false


function _init()
	window { cursor = "" }
	fetch("pal/0.pal"):poke(0x5000)
	state:enter()
end


function _update()
	if next_state then
		state:exit()
		state = next_state
		state:enter()
	end
	next_state = state:update()
end


function _draw()
	state:draw()
	print(string.format("\014% 3.0f", (stat(1) * 100.0)) .. "%", 460, 1, 1)
end

:: map/
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNS0x
MC0yMCAxOTozOTozOSIsc3RvcmVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Il1d
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNC0w
OS0wMSAwNzozNDozNSIscmV2aXNpb249MzA3NV1dbHo0AMEAAABZEAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD-------_x0zIwMDAzMDAwNDAwMDYMAC81MIAAWxMxCAATNYAALzYw
AQBbFzb8ABMxDAAPAQBVBHwBAAABEzAMAA_AAVkTMXQAEzB4ABcxjAAPAAFVEzaEAAQMAC81MAEA
--------nvEJIiksaGlkZGVuPWZhbHNlLHBhbl94PTQ3CQDSeT0wLHRpbGVfaD0yOQoAEHcKAIB6
b29tPTF9fQ==
:: pal/
:: pal/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTIzIDE4OjU0OjE5Iixtb2RpZmllZD0iMjAyNS0x
MC0yMCAxOTozOTozOSJdXQ==
:: pal/0.pal
b64$LS1bW3BvZCxiZ19jb2xvcj0wLGJsYWNrZXN0X2NvbG9yPTAsY3JlYXRlZD0iMjAyNC0wOC0y
MyAxODo1OTowOSIsaGlkZGVuPXtbMF09ZmFsc2UsZmFsc2UsZmFsc2UsdHJ1ZSx0cnVlLHRydWUs
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0
cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1
ZSx0cnVlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlfSxoaWRkZW5fdG9nZ2xl
cz17WzBdPWZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlfSxodWVfb2Zmc2V0PS0wLjY4MTQ0MDQ0MzIx
MzMsaWNvbj11c2VyZGF0YSgidTgiLDE2LDE2LCIwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAw
MDAwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDYwMTAwMDAwMDAwMDAwMTA3MDcwNzA3MDcwNzA3MDcw
NjA2MDEwMDAwMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA2MDYwNjAxMDAwMDAwMDEwNzA3MDcwNzA3
MDcwNzA3MDYwNjA2MDYwMTAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzAxMDAwMDAxMDcw
NzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDEwNzA3MDYwNjAxMDEwZDBkMDEwMTA3MDcwMTAw
MDAwMTA3MDcwNjA2MDEwMTBkMGQwMTAxMDcwNzAxMDAwMDAxMDcwNzAxMDEwNzA3MDYwNjBkMGQw
NzA3MDEwMDAwMDEwNzA3MDEwMTA3MDcwNjA2MGQwZDA3MDcwMTAwMDAwMTA3MDcwZDBkMDEwMTBk
MGQwNjA2MDcwNzAxMDAwMDAxMDcwNzBkMGQwMTAxMGQwZDA2MDYwNzA3MDEwMDAwMDEwNzA3MDcw
NzA3MDcwNzA3MDcwNzA3MDcwMTAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzAxMDAwMDAx
MDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMCIpLGxvY2tlZD17WzBdPWZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlfSxsb3djb2xfaWNvbj10cnVlLG1vZGlmaWVkPSIy
MDI1LTEwLTIwIDE5OjAyOjQ0Iixva3BhbF92ZXJzaW9uPSIxLjIuMyIscGlja2Vyc19tb2RlPSJs
aW5lYXJfaHVlIixyZXZpc2lvbj00NjUwLHRlc3RfY3ViZV9jb2xvcnM9e1swXT17MSwxLDF9LHsx
LDEsMX0sezEsMSwxfSx7MSwxLDF9LHsxLDEsMX0sezEsMSwxfSx7MSwxLDF9LHsxLDEsMX0sezEs
MSwxfSx7MSwxLDF9LHsxLDEsMX0sezEsMSwxfSx7MSwxLDF9LHsxLDEsMX0sezEsMSwxfSx7MSwx
LDF9LHsxLDEsMX0sezEsMSwxfSx7MSwxLDF9LHsxLDEsMX0sezEsMSwxfSx7MSwxLDF9LHsxLDEs
MX0sezEsMSwxfX0sdGVzdF9tb2RlPSJyYW1wcyIsdGVzdF9yYW1wX2NvbG9ycz11c2VyZGF0YSgi
dTgiLDEwLDI3LCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAiKSx3aGl0ZXN0X2NvbG9yPTdd
XWx6NAD1AQAAFQIAAP0FdXNlcmRhdGEoImkzMiIsNjQsIjABAPANMzQzZjYyMDA4MjNmMzgwMDk4
NDczZjAwOWY1MQgAkTQ1NTM4MTAwZgEA8DAwMDc0MWY2NTAwYTgyNTkyMDBlMjQ5YmEwMGVmODNj
NTAwZjhiYmQ5MDA3NzJjMTYwMGEyMzIxOTAwZDU0ZjJIAPAsMzgyNTcwMGZjYmM5YzAwNjc0OTEz
MDA5YzcxMWEwMGQ2YTIyNTAwZWRjNDU0MDBmYmUxOTkwMDJkNTMYAPAWMzE2ZTMyMDA1MGEzMmMw
MDg3ZDQ1NjAwYmZmMjk1MDAxNjU4NQgA8Bw3Nzk3ZDAwMjBiNGIzMDA1Y2Q4ZDIwMGFjZjZmMDAw
NDcyMjg2MDA1ZTI2IADQOGQzYmVkMDBhZTgxZrAAkDhjNGZjMDA1MwIAQDAwYjICAEAwMGUzAgBA
MDBmNAIAAMgAAAIAQDAwMWQCAEAwMDJlAgBAMDA0NgIAQDAwOWICAEAwMGMxAgDgMDA0ZjRiM2Uw
MDczNmHgAPATOWU4Zjc0MDBhYTlkODUwMGJlYjVhNDAwNTg1OTVkMDA2OAIAUTAwNmY2uQARNwEA
UDAwODY4rwHwEDAzZjI3MmEwMDViMzYzYTAwNjYzZjQzMDA3MTQ4NGIgAeA1YTVjMDAyYTM0NTQi
KQ==
:: sfx/
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNS0x
MC0yMCAxOTozOTozOSIsc3RvcmVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Il1d
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM1Iixtb2RpZmllZD0iMjAyNS0w
NS0xMiAyMTowODoyMSIscmV2aXNpb249NDU2Nl1dbHo0ABoBAABSCAAA8CdweHUAAygAAAQABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDBAUGBwAP-5AICQoLDwwPDQ8ODw8QAPAADQ8RDxIPEw8UDxUP
Fg8XEwDxAQ8YDxkPGg8bDxwPHQ8eDx8UAPEAIA8hDyIPIw8kDyUPJg8nFADxACgPKQ8qDysPLA8t
Dy4PLxQA8QAwDzEPMg8zDzQPNQ82DzcUAP8FOA85DzoPOw88Dz0PPg8-AA--8P8BAOv-J1oBEAYP
IBABIAEgAfAAAhACDBABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDDAAAh9EMAAc
H0AwAPIf-wEA3L-4D0AADUD--7DwcAoA--9kH-8BAP_ZUP----8g
:: src/
:: src/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTI0IDA3OjE3OjA5Iixtb2RpZmllZD0iMjAyNS0x
MC0yMCAxOTozOTozOSJdXQ==
:: src/constants.lua
--[[pod_format="raw",created="2024-08-24 15:17:10",modified="2025-10-20 19:39:39",revision=3619]]
--- Match3 Global Constants


-- Gems and cells ------------------------------------------------------

-- Cells
cell_mask = 0x3
cell_none = 0x0
cell_good = 0x1
cell_bad = 0x2

-- Obstacles
rock_full = 0x10
rock_cracked = 0x20
rock_broken = 0x30
cell_door = 0x40
cell_chest_air = 0x50
cell_chest_fire = 0x60
cell_chest_day = 0x70
cell_chest_earth = 0x80
cell_chest_water = 0x90
cell_chest_night = 0xa0

obstacle_mask = 0xf0

-- Color gems
gem_air = 0x100
gem_fire = 0x200
gem_day = 0x300
gem_earth = 0x400
gem_water = 0x500
gem_night = 0x600
gem_rainbow = 0x700

gem_color_first = gem_air
gem_color_last = gem_rainbow

-- Black gems
gem_gift = 0x800
gem_bomb = 0x900
gem_cat = 0xa00
gem_bat = 0xb00
gem_robot = 0xc00
gem_robot_asleep = 0xd00
gem_robot_asleep2 = 0xe00

gem_names = {
	[gem_air] = "Air",
	[gem_fire] = "Fire",
	[gem_day] = "Day",
	[gem_earth] = "Earth",
	[gem_water] = "Water",
	[gem_night] = "Night",
	[gem_rainbow] = "Rainbow",
}


----------------------------------------------------------------------




sprites_color_gem = {
	[gem_air] = 1,
	[gem_fire] = 2,
	[gem_day] = 3,
	[gem_earth] = 4,
	[gem_water] = 5,
	[gem_night] = 6,
	[gem_rainbow] = 7,
}


sprites = {
	[gem_air] = 160,
	[gem_fire] = 161,
	[gem_day] = 162,
	[gem_earth] = 163,
	[gem_water] = 164,
	[gem_night] = 165,
	[gem_rainbow] = 166,
	[cell_none] = 31,
	[cell_good] = 32,
	[cell_bad] = 34,
	[gem_gift] = 8,
	[gem_bomb] = 9,
	[gem_cat] = 10,
	[gem_bat] = 11,
	[gem_robot] = 12,
	[gem_robot_asleep] = 13,
	[gem_robot_asleep2] = 13,
	[rock_full] = 48,
	[rock_cracked] = 49,
	[rock_broken] = 50,
	[cell_door] = 51,
	[cell_chest_air] = 52,
	[cell_chest_fire] = 53,
	[cell_chest_day] = 54,
	[cell_chest_earth] = 55,
	[cell_chest_water] = 56,
	[cell_chest_night] = 57,
}

:: src/gfx.lua
--[[pod_format="raw",created="2024-08-24 12:06:13",modified="2025-10-20 19:39:39",revision=5462]]
--- Graphics


local cell_width = 29
local cell_height = 29


function gfx_draw_cells(cells)
	local function draw_cell(p, cell)
		local x, y = cells:coords_cell(p)
		local sprite
		if cells:tiling() == "square" then
			if cell & cell_mask == cell_good then
				sprite = 32
			elseif cell & cell_mask == cell_bad then
				sprite = 34
			end
			sprite += (p.x + p.y) % 2
		elseif cells:tiling() == "hex" then
			if cell & cell_mask == cell_good then
				sprite = 40
			elseif cell & cell_mask == cell_bad then
				sprite = 43
			end
			sprite += (p.y + (p.x * 3)) % 3
		end
		spr(sprite, x, y)
		x, y = cells:coords_gem(p)
		if cell and cell & cell_mask == cell_bad then
			pal(53, 58)
		end
		if cell & obstacle_mask == 0 then
		elseif cell & obstacle_mask == rock_full then
			spr(48, x, y)
		elseif cell & obstacle_mask == rock_cracked then
			spr(49, x, y)
		elseif cell & obstacle_mask == rock_broken then
			spr(50, x, y)
		elseif cell & obstacle_mask == cell_door then
			spr(51, x, y)
		elseif cell & obstacle_mask == cell_chest_air then
			spr(52, x, y)
		elseif cell & obstacle_mask == cell_chest_fire then
			spr(53, x, y)
		elseif cell & obstacle_mask == cell_chest_day then
			spr(54, x, y)
		elseif cell & obstacle_mask == cell_chest_earth then
			spr(55, x, y)
		elseif cell & obstacle_mask == cell_chest_water then
			spr(56, x, y)
		elseif cell & obstacle_mask == cell_chest_night then
			spr(57, x, y)
		end	
		pal(53, 53)
	end
	cells:foreachpos(draw_cell)
	-- TODO: move border construction out of the hot loop
	local function draw_borders(p, cell)
		local x, y = cells:coords_cell(p)
		if cells:tiling() == "square" then
			local cell_S = cells:get(p + pos(0, 1))
			local cell_W = cells:get(p + pos(-1, 0))
			local cell_E = cells:get(p + pos(1, 0))
			local cell_N = cells:get(p + pos(0, -1))
			if cell & cell_good != 0 then
				if not cell_S or cell_S & cell_good == 0 then
					line(x, y + 28, x + 28, y + 28, 53)
				end
				if not cell_E or cell_E & cell_good == 0 then
					line(x + 28, y, x + 28, y + 28, 53)
				end
				if not cell_N or cell_N & cell_good == 0 then
					line(x, y, x + 28, y, 57)
				end
				if not cell_W or cell_W & cell_good == 0 then
					line(x, y, x, y + 28, 57)
				end
			elseif cell & cell_bad != 0 then
				if cell_N and cell_N & cell_good != 0 then
					line(x, y, x + 28, y, 58)
				end
				if cell_W and cell_W & cell_good != 0 then
					line(x, y, x, y + 28, 58)
				end
			end
		end
	end
	cells:foreachpos(draw_borders)
end


-----------------------------------------------------------------------


--color_gem_skin = math.random(0, 14)
color_gem_skin = 4

function reskin_gems()
	local base = 128 + color_gem_skin * 8
	sprites[gem_air] = base + 0
	sprites[gem_fire] = base + 1
	sprites[gem_day] = base + 2
	sprites[gem_earth] = base + 3
	sprites[gem_water] = base + 4
	sprites[gem_night] = base + 5
	sprites[gem_rainbow] = base + 6
end


local function scaled_gem(sprite, x, y, size)
	local w, h = flr(29 * size + 0.5) // 2 * 2 + 1, flr(29 * size + 0.5) // 2 * 2 + 1
	local x, y = x + ((29 - w) / 2), y + ((29 - h) / 2)
	sspr(sprite, 0, 0, 29, 29, x, y, w, h)
end


local function draw_exploded_gem(gem, x, y, clock, new_clock)
	local size = 32 * new_clock
	local colour = 10 + (gem - 1) * 5
	oval(x - size, y - size, x + 29 + size, y + 29 + size, colour + 1)
	if clock < 0.25 then
		ovalfill(x + 2, y + 2, x + 25, y + 25, 7)
	elseif clock < 0.50 then
		ovalfill(x + 2, y + 2, x + 25, y + 25, colour + 2)
	elseif clock < 0.75 then
		ovalfill(x + 1, y + 1, x + 27, y + 27, colour + 1)
	elseif clock < 1.0 then
		ovalfill(x, y, x + 29, y + 29, colour)
	end
end


function gfx_draw_gems(cells, gems, states, clock)
	local function draw_gem(p, gem)
		local x, y = gems:coords_gem(p)
		local sprite = sprites[gem]
		local cell = cells:get(p)
		if cell and cell & cell_mask == cell_bad then
			pal(53, 58)
		end
		local state = states:get(p)
		if not state or state.name == "broken" then
			spr(sprite, x, y)
		elseif state.name == "new" then
			scaled_gem(sprite, x, y, clock)
		elseif state.name == "matching" then
		elseif state.name == "falling" or state.name == "swapping"
		then
			local dest_x, dest_y = gems:coords_gem(state.target)
			local ix, iy = x + clock * (dest_x - x), y + clock * (dest_y - y)
			spr(sprite, ix, iy)
		elseif state.name == "moving" then
			x, y = gems:coords_gem(state.source, gem)
			local dest_x, dest_y = gems:coords_gem(state.target)
			scaled_gem(sprites[state.target_gem], dest_x, dest_y, 1.0)
		end
		pal(53, 53)	
	end
	gems:foreachpos(draw_gem)
	local new_clock = clock * clock * clock * clock
	gems:foreachpos(
		function(p, gem)
			local x, y = gems:coords_gem(p)
			local sprite = sprites[gem]
			local cell = cells:get(p)
			if cell and cell & cell_mask == cell_bad then
				pal(53, 58)
			end
			local state = states:get(p)
			if state and state.name == "matching" then
				draw_exploded_gem(gem, x, y, clock, new_clock)
			elseif state and state.name == "moving" then
				x, y = gems:coords_gem(state.source, gem)
				local dest_x, dest_y = gems:coords_gem(state.target)
				local ix, iy = x + clock * (dest_x - x), y + clock * (dest_y - y)
				spr(sprites[state.moving_gem], ix, iy)
			end
		end
	)
end


-----------------------------------------------------------------------


function gfx_draw_turns(ox, oy, turn, anim_turn)
	spr(64, ox, oy)
	local hundreds = (turn // 100) % 10
	local tens = (turn // 10) % 10
	local ones = turn % 10
	local anim = anim_turn // 2
	pal(7, 1)
	clip(ox + 7, oy + 3, 3 * 8, 11)
	-- hundreds
	if anim == 0 or (turn % 100) > 0 then
		spr(65 + hundreds, ox + 7, oy + 5)
	else
		spr(65 + hundreds, ox + 7, oy + 5 + anim)
		spr(65 + ((hundreds - 1) % 10), ox + 7, oy + 5 + anim - 10)
	end
	-- tens
	if anim == 0 or ones > 0 then
		spr(65 + tens, ox + 7 + 8, oy + 5)
	else
		spr(65 + tens, ox + 7 + 8, oy + 5 + anim)
		spr(65 + ((tens - 1) % 10), ox + 7 + 8, oy + 5 + anim - 10)
	end
	-- ones
	spr(65 + ones, ox + 7 + 2 * 8, oy + 5 + anim)
	spr(65 + ((ones - 1) % 10), ox + 7 + 2 * 8, oy + 5 + anim - 10)
	clip()
	pal(7, 7)
end


function gfx_draw_mana(ox, oy, mana, zoomed)
	local base_char
	local char_width
	if zoomed then
		base_char = 85
		char_width = 11
		oy -= 3
	else
		base_char = 75
		char_width = 8
	end
	local thousands = (mana // 1000) % 10
	local hundreds = (mana // 100) % 10
	local tens = (mana // 10) % 10
	local ones = mana % 10
	local digits = 4
	if mana < 10 then
		digits = 1
	elseif mana < 100 then
		digits = 2
	elseif mana < 1000 then
		digits = 3
	else
		digits = 4
	end
	ox -= (digits * char_width) // 2
	if mana >= 1000 then
		spr(base_char + thousands, ox, oy)
		ox += char_width
	end
	if mana >= 100 then
		spr(base_char + hundreds, ox, oy)
		ox += char_width
	end
	if mana >= 10 then
		spr(base_char + tens, ox, oy)
		ox += char_width
	end
	spr(base_char + ones, ox, oy)
end


function gfx_draw_mana_bar(ox, oy, mana)
	spr(95, ox, oy)
	if mana == 0 then
		return
	end
	local size = min(91, flr(0.5 + 91*(mana / 250)))
	rectfill(ox+1, oy+2, ox+1+size, oy+5, 40)
	line(ox+1+size, oy+2, ox+1+size, oy+5, 39)
	line(ox+1, oy+2, ox+1, oy+5, 41)
	if size > 1 then
		line(ox+2, oy+1, ox+1+size-1, oy+1, 41)
		line(ox+2, oy+6, ox+1+size-1, oy+6, 39)
	end
end
:: src/hgrid.lua
--[[pod_format="raw",created="2024-08-25 08:16:09",modified="2025-10-20 19:39:39",revision=3177]]
--- Hex Grids

--- Hex grids use the "double height" coordinate system:
---
---     (0,0)         (2,0)         (4,0)
---            (1,1)         (3,1)
---     (0,2)         (2,2)         (4,2)
---            (1,3)         (3,3)
---     (0,4)         (2,4)         (4,4)
---
--- The origin of the grid, `pos(0, 0)`, is at the top left.


-- Local Constants --------------------------------------------------------


local max_width <const> = 17
local max_height <const> = 7


-- Constructors -----------------------------------------------------------


local metatable = {}


function hgrid_new()
	local grid = {}
	metatable.default_origin(grid)
	setmetatable(grid, { __index = metatable })
	for i = 0, max_width * max_height do
		grid[i] = false
	end
	return grid
end


function metatable:new_grid()
	local result = hgrid_new()
	result.origin = self.origin
	return result
end


function metatable:clone()
	local grid = self:new_grid()
	grid.origin = self.origin
	self:foreachpos(function(p, item) grid:set(p, item) end)
	return grid
end


-- Indexing ------------------------------------------------------------


function metatable:tiling()
	return "hex"
end


function metatable:get(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	return self[p.x + ((p.y // 2) * max_width)]
end


function metatable:set(p, value)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	self[p.x + ((p.y // 2) * max_width)] = value
end


function metatable:merge(p, state)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	local index = p.x + ((p.y // 2) * max_width)
	if not self[index] then
		self[index] = {}
	end
	for k, v in pairs(state) do
		self[index][k] = v
	end
end


function metatable:del(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	self[p.x + ((p.y // 2) * max_width)] = false
end


-- Screen Coordinates ---------------------------------------------------------


function metatable:default_origin()
	self.origin = { x = 6, y = 7 }
end


function metatable:compute_origin()
	local min_p = pos(max_width, max_height)
	local max_p = pos(0, 0)
	self:foreachpos(
		function(position, cell)
			if not cell or cell == 0 then
				return
			end
			if position.x < min_p.x then min_p.x = position.x end
			if position.y < min_p.y then min_p.y = position.y end
			if position.x > max_p.x then max_p.x = position.x end
			if position.y > max_p.y then max_p.y = position.y end
		end
	)
	local width = 1 + max_p.x - min_p.x
	local height = 1 + max_p.y - min_p.y
	self.origin = {
		x = (480 // 2) - ((width * 27) // 2) - (min_p.x * 27) - 4,
		y = ((270 - 32) // 2) - ((height * 16) // 2) - (min_p.y * 16) - 8,
	}
end


function metatable:coords_origin()
	return self.origin.x, self.origin.y
end


function metatable:coords_cell(p)
	local ox, oy = self:coords_origin()
	return ox + p.x * 27, oy + p.y * 16
end


function metatable:coords_gem(p)
	local ox, oy = self:coords_origin()
	return ox + (p.x * 27) + 3, oy + (p.y * 16) + 1
end


function metatable:pos(x, y)
	local ox, oy = self:coords_origin()
	x -= ox
	y -= oy + 1
	local px, py = x // 27, y // 16
	local dx, dy = x - (px * 27), y - (py * 16)
	if dx < 8 then
		if (px + py) % 2 == 0 and dy < 14 + (-2 * dx) then
			px -= 1
			py -= 1
		elseif (px + py) % 2 != 0 and dy > -1 + (2 * dx) then
			px -= 1
		end
	end
	py = (2 * ((py - (px % 2)) // 2)) + (px % 2)
	return pos(px, py)
end


function metatable:distance(p0, p1)
	-- TODO: is this correct?
	return (abs(p0.x - p1.x) + abs(p0.y - p1.y)) // 2
end


-- Iterating ----------------------------------------------------------


function metatable:foreachpos(func)
	for x = 0, max_width do
		for y = x % 2, max_height * 2 - 1, 2 do
			local p = pos(x, y)
			local item = self:get(p)
			if item then
				func(p, item)
			end
		end
	end
end	


function metatable:neighbours(p)
	return {
		{ position = p + pos(1, 1), direction = "horizontal_SE" },
		{ position = p + pos(0, 2), direction = "vertical" },
		{ position = p + pos(-1, 1), direction = "horizontal_NE" },
		{ position = p + pos(-1, -1), direction = "horizontal_SE" },
		{ position = p + pos(0, -2), direction = "vertical" },
		{ position = p + pos(1, -1), direction = "horizontal_NE" },
	}
end


function metatable:blast_radius(p)
	return {
		p + pos(0, 0),
		p + pos(0, -2),
		p + pos(1, -1),
		p + pos(1, 1),
		p + pos(0, 2),
		p + pos(-1, 1),
		p + pos(-1, -1),
	}
end

:: src/in_editor.lua
--[[pod_format="raw",created="2024-08-30 08:13:35",modified="2025-10-20 19:39:39",revision=1412]]
in_editor = {}

local tiling = "square"

local cells = false
local gems = false
local marks = false

local active_tool = 1
local oy = 270 - 32 + 2
local sx = 32

local tools = {
	[0] = cell_none,
	cell_good,
	cell_bad,
	rock_full,
	rock_cracked,
	rock_broken,
	gem_gift,
	gem_bomb,
	gem_cat,
	gem_bat,
	gem_robot,
	cell_door,
	cell_chest_air,
	cell_chest_fire,
	cell_chest_day,
	cell_chest_earth,
	cell_chest_water,
	cell_chest_night,
}


function in_editor:enter()
	if not cells then
		cells = logic_new_test_cells(tiling, true)
		cells:compute_origin()
		gems = cells:new_grid()
	end
	marks = cells:new_grid()
end


function in_editor:exit()
end


function in_editor:update()
	if keyp("s") then
		tiling = "square"
		cells = false
		in_editor:enter()
	end
	if keyp("h") then
		tiling = "hex"
		cells = false
		in_editor:enter()
	end
	local mx, my, mb, _, _ = mouse()
	if mb == 0x1 and my >= oy then
		active_tool = clamp(mx // sx, 0, #tools)
	elseif mb == 0x1 then
		local mp = cells:pos(mx, my)
		local tool = tools[active_tool]
		if tool == cell_none then
			local cell = cells:get(mp) or cell_none
			cell = (cell & ~cell_mask) | tool
			cells:set(mp, cell)
			gems:del(mp)
		elseif tool == cell_good or tool == cell_bad then
			local cell = cells:get(mp) or cell_none
			cell = (cell & ~cell_mask) | tool
			cells:set(mp, cell)
		elseif
			tool == rock_full
			or tool == rock_cracked
			or tool == rock_broken
			or tool == cell_chest_air
			or tool == cell_chest_fire
			or tool == cell_chest_day
			or tool == cell_chest_earth
			or tool == cell_chest_water
			or tool == cell_chest_night
			or tool == cell_door
		then
			local cell = cells:get(mp) or cell_none
			cell = (cell & cell_mask) | tool
			cells:set(mp, cell)
			gems:del(mp)
		elseif cells:get(mp) and cells:get(mp) & cell_mask != 0 then
			gems:set(mp, tool)
			local cell = cells:get(mp) or cell_none
			cell = (cell & cell_mask)
			cells:set(mp, cell)
		end
	end
	if mb == 0x2 then
		local mp = cells:pos(mx, my)
		local cell = cells:get(mp) or cell_none
		cell = (cell & cell_mask)
		cells:set(mp, cell)
		gems:del(mp)
	end
	if keyp("g") then
		in_game:load_from_editor(tiling, cells, gems)
		return in_game
	end
	return false
end


function in_editor:draw()
	cls(63)
	if not cells then
		return
	end
	local _, my, _, _, _ = mouse()
	if my >= oy then
		window { cursor = "pointer" }
	else
		window { cursor = "crosshair" }
	end
	gfx_draw_cells(cells)
	gfx_draw_gems(cells, gems, marks, 0.0)
	-- Draw the panel
--	rectfill(0, 0, 110, 269, 55)
--	rectfill(ox, oy, ox + 28, oy + 28, 63)
	for i, tool in pairs(tools) do
		if tool then
			spr(sprites[tool], 0 + i * 32, oy)
		end
	end 

	local x = active_tool
	rect(x * sx - 1, oy - 1, x * sx + 29, oy + 29, 7)
end
:: src/in_game.lua
--[[pod_format="raw",created="2024-08-27 17:11:11",modified="2025-10-20 19:39:39",revision=4675]]
in_game = {}


-- The Board
local tiling = "square"
local gravity = pos(0, 1)

local cells = false
local gems = false
local marks = false

local matches = {}

local prev_cells = false
local prev_gems = false
local prev_stats = false

-- State Machine
local editor_requested = false
local substate = false
local clock = 0.0
local interaction = false

local starting_stats = {
	turn = 0,
	mana = 0,
	colours = {
		[gem_air] = 0,
		[gem_fire] = 0,
		[gem_day] = 0,
		[gem_earth] = 0,
		[gem_water] = 0,
		[gem_night] = 0,
	},
	in_cascade = false,
}
local stats = deep_copy(starting_stats)
local anim_turn = 0
local displayed_mana = 0
local star_seed = 37


-----------------------------------------------------------------------


-- Functions for substate need to be global, because of Lua
-- forward-declaration rule for locals.


function creating_the_board()
--	cells = logic_new_test_cells(tiling)
--	gems = cells:new_grid()
	cells:compute_origin()
	gems.origin = cells.origin
	marks = cells:new_grid()
	matches = {}
	stats = deep_copy(starting_stats)
	anim_turn = 0
	displayed_mana = 0
	star_seed = math.random(37, 6584587)
	return creating_missing_gems
end


function creating_missing_gems()
	if clock == 0.0 then
		logic_fill_gems(cells, gems, marks)
	end
	clock += 1.0 / 8.0
	if clock < 1.0 then
		return creating_missing_gems
	end
	-- Clean-up
	marks:foreachpos(
		function(p, mark)
			if mark.name == "new" then
				marks:del(p)
			end
		end
	)
	return moving_things
end


function moving_things()
	if clock == 0.0 and stats.turn > 0 then
		local something_moved = logic_mark_move(cells, gems, marks)
		if not something_moved then
			return starting_new_turn
		end
	end
	clock += 1.0 / 16.0
	if clock < 1.0 then
		return moving_things
	end
	logic_enact_move(cells, gems, marks)
	return starting_new_turn
end


function starting_new_turn()
	stats.turn += 1
	anim_turn = 20
	stats.in_cascade = false
	return waiting_for_input
end


function waiting_for_input()
	local mx, my, mb, _, _ = mouse()
	if mb == 0x1 then
		local mp = cells:pos(mx, my)
		if gems:get(mp) then
			interaction = { name = "swap", position = mp, start = t() }
			return waiting_for_swap
		end
	end
	if keyp("del") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:set(p, gem_gift)
		marks = cells:new_grid()
		matches = {}
	end
	if keyp("w") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:set(p, gem_rainbow)
		marks:set(p, { name = "new" })
		matches = {}
		return checking_matches
	end
	if keyp("r") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		cells:set(p, (cells:get(p) or 0) | rock_full)
		gems:del(p)
		matches = {}
		return checking_matches
	end
	if keyp("a") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:set(p, gem_air)
		marks:set(p, { name = "new" })
		matches = {}
		return checking_matches
	end
	if keyp("m") then
		return checking_matches
	end
	if keyp("e") then
		editor_requested = true
		return creating_the_board
	end
	if keyp("z") then
		cells = prev_cells:clone()
		gems = prev_gems:clone()
		marks = cells:new_grid()
		stats = deep_copy(prev_stats)
	end
	if keyp("4") then
		color_gem_skin = (color_gem_skin - 1) % 16
		reskin_gems()
	end
	if keyp("5") then
		color_gem_skin = 4
		reskin_gems()
	end
	if keyp("6") then
		color_gem_skin = (color_gem_skin + 1) % 16
		reskin_gems()
	end
	if keyp("0") then
		local prev = color_gem_skin
		while prev == color_gem_skin do
			color_gem_skin = math.random(0, 14)
		end
		reskin_gems()
	end
	return waiting_for_input
end


function waiting_for_swap()
	local mx, my, mb, _, _ = mouse()
	if mb != 0x1 then
		interaction = false
		return waiting_for_input
	end
	local mp = cells:pos(mx, my)
	if cells:distance(mp, interaction.position) != 1
		or (not gems:get(mp))
	then
		return waiting_for_swap
	end
	local success = logic_mark_swap(gems, marks, interaction.position, mp)
	interaction = false
	if not success then
		return waiting_for_input
	end
	prev_cells = cells:clone()
	prev_gems = gems:clone()
	prev_stats = deep_copy(stats)
	return swapping_two_gems
end


function swapping_two_gems()
	clock += 1.0 / 8.0
	if clock < 1.0 then
		return swapping_two_gems
	end
	logic_enact_swap(gems, marks)
	return checking_matches
end


function checking_matches()
	matches, marks = logic_find_matches(cells, gems)
	if #matches > 0 then
		local _ = logic_gain_mana(stats, matches)
		return clearing_gems
	end
	return creating_missing_gems
end


function clearing_gems()
	clock += 1.0 / 16.0
	if clock < 1.0 then
		return clearing_gems
	end
	logic_enact_clear(gems, marks)
	return repairing_cells
end


local repairing_done = false
function repairing_cells()
	if clock == 0.0 then
		local is_something_repaired = logic_mark_repair(cells, marks, matches)
		if not is_something_repaired then
			return breaking_things
		end
	end
	clock += 1.0 / 16.0
	if clock < 0.5 then
		repairing_done = false
		return repairing_cells
	elseif not repairing_done then
		logic_enact_repair(cells, marks)
		repairing_done = true
		return repairing_cells
	elseif clock < 1.0 then
		return repairing_cells
	end
	return breaking_things
end


local breaking_done = false
function breaking_things()
	if clock == 0.0 then
		local something_broke = logic_mark_breakage(cells, gems, marks, matches)
		if not something_broke then
			return applying_gravity
		end
		breaking_done = false
	end
	clock += 1.0 / 32.0
	if clock < 0.5 then
		return breaking_things
	elseif not breaking_done then
		logic_enact_breakage(cells, gems, marks)
		breaking_done = true
		return breaking_things
	elseif clock < 1.0 then
		return breaking_things
	end
	return applying_gravity
end


function applying_gravity()
	if clock == 0.0 then
		local some_gems_are_falling = logic_mark_gravity(cells, gems, marks, gravity)
		if not some_gems_are_falling then
			return creating_missing_gems
		end
	end
	clock += 1.0 / 8.0
	if clock < 1.0 then
		return applying_gravity
	end
	logic_enact_gravity(gems, marks)
	return checking_matches
end


-----------------------------------------------------------------------


function in_game:load_from_editor(ed_tiling, ed_cells, ed_gems)
	tiling = ed_tiling
	if tiling == "square" then
		gravity = pos(0, 1)
	else
		gravity = pos(0, 2)
	end
	cells = ed_cells:clone()
	gems = ed_gems:clone()
	marks = cells:new_grid()
	matches = {}
	stats = deep_copy(starting_stats)
	substate = creating_the_board
end


-----------------------------------------------------------------------


function in_game:enter()
	editor_requested = false
	if not substate then
		substate = creating_the_board
	end
end


function in_game:exit()
end


function in_game:update()
	local next = substate()
	if next != substate then
		clock = 0.0
		substate = next
	end
	if anim_turn > 0 then
		anim_turn -= 1
	end
	if displayed_mana < stats.mana then
		displayed_mana += 0.50
	elseif displayed_mana >= stats.mana then
		displayed_mana = stats.mana
	end
	if editor_requested then
		return in_editor
	end
	return false
end


function in_game:draw()
	if not cells then
		return
	end
	-- Starry background
	local hash = star_seed
	for x = 0, 11 do
		for y = 0, 6 do
			hash = hash~(hash << 13); hash = hash~(hash >> 17); hash = hash~(hash << 5)
			local flipped = (x+y)%2 == 0
			spr(120 + (hash%8), 0 + x * 40, 0 + y * 40, flipped, flipped)
		end
	end
	-- Draw the board
	gfx_draw_cells(cells)
	gfx_draw_gems(cells, gems, marks, clock)
	-- Draw the panel
	local oy = 270 - 32 + 10
--	rectfill(0, 0, 110, 269, 60)
--	line(0, 0, 110, 0, 62)
--	line(0, 50, 110, 50, 62)
--	line(0, 0, 0, 269, 62)
--	line(110, 0, 110, 269, 58)
--	line(0, 49, 110, 49, 58)
--	line(0, 269, 110, 269, 58)
	-- Top bar
--	spr(102, 6, 10)
	spr(98, 2, oy)
	spr(100, 19, oy)
	gfx_draw_turns(480 - 37, oy, stats.turn, anim_turn)
--	spr(102, 101, 10)
	-- Mana
--	spr(104, 16, 56)
	gfx_draw_mana(60, oy + 3, flr(displayed_mana), displayed_mana < stats.mana)
--	spr(105, 71, 56)
--	gfx_draw_mana_bar(300, oy + 3, flr(displayed_mana))
--	for i = 0, 5 do
--		spr(96, 4, 84 + i * 30)
--	end
--	cursor(11, 95, 58)
--	print("Change Gravity")
--	cursor(10, 94, 22)
--	print("Change Gravity")
	--[[
	print("")
	print("Air: " .. tostr(stats.colours[gem_air]))
	print("Fire: " .. tostr(stats.colours[gem_fire]))
	print("Day: " .. tostr(stats.colours[gem_day]))
	print("Earth: " .. tostr(stats.colours[gem_earth]))
	print("Water: " .. tostr(stats.colours[gem_water]))
	print("Night: " .. tostr(stats.colours[gem_night]))
	]]--
	-- Update the cursor
	local mx, my = mouse()
	local cursor_pos = cells:pos(mx, my)
	local cell = cells:get(cursor_pos)
	if cell and cell != 0 then
		window { cursor = "grab" }
	else
		window { cursor = "" }
	end
	if false then
		rectfill(mx + 4 - 10, my + 10, mx + 36, my + 20, 7)
		--print(tostr(cursor_pos.x)..","..tostr(cursor_pos.y), mx + 6 - 10, my + 12, 0)
		local gem = gems:get(cursor_pos)
		print(string.format("%x", gem or 0), mx + 6 - 10, my + 12, 0)
	end
end
:: src/logic/
:: src/logic/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTMwIDA2OjI0OjM5Iixtb2RpZmllZD0iMjAyNS0x
MC0yMCAxOTozOTozOSJdXQ==
:: src/logic/creation.lua
--[[pod_format="raw",created="2024-08-30 06:25:09",modified="2025-10-20 19:39:39",revision=2166]]
--- Board Creation Logic


function logic_new_test_cells(tiling, for_editor)
	local grid
	local size
	if tiling == "square" then
		grid = sgrid_new()
		for x = 4, 11 do
			for y = 0, 7 do
				grid:set(pos(x, y), cell_good)
			end
		end
	elseif tiling == "hex" then
		grid = hgrid_new()
		for i = 0, 4 do
			for y = i, 12 - i, 2 do
				grid:set(pos(8 + i, y), cell_good)
				grid:set(pos(8 - i, y), cell_good)
			end
		end
	end
	return grid
end


------------------------------------------------------------------------


--local function random_gem()
--	if false and rnd() < 0.05 then
--		local gem = gem_rainbow + flr(rnd(6))
--		if gem == gem_robot_E then
--			gem += flr(rnd(4))
--		end
--		return gem
--	end
--	return gem_color_first + flr(rnd(gem_color_last - gem_color_first))
--end
local bag_of_gems = {}
local rejected_gems = {}


local function random_gem()
	while #bag_of_gems == 0 do
		bag_of_gems = rejected_gems
		rejected_gems = {}
		for i = gem_air, gem_night, 0x100 do
			add(rejected_gems, i)
		end
	end
	local idx = math.random(1, #bag_of_gems)
	local gem = bag_of_gems[idx]
	deli(bag_of_gems, idx)
	return gem
end


function logic_fill_gem_at(cells, gems, states, p)
	local cell = cells:get(p) or 0
	if (cell & cell_mask == 0) or (cell & obstacle_mask != 0) then
		return
	end
	local test = (gems:tiling() == "square") and logic_test_sqr_match_at or logic_test_hex_match_at
	local gem = gems:get(p)
	if not gem then
		local attempts = 0
		local found = false
		while attempts < 16 and not found do
			if gem then
				add(rejected_gems, gem)
			end
			gem = random_gem()
			gems:set(p, gem)
			found = not test(gems, p)
			attempts += 1
		end
		if attempts == 16 then
			gem = gem_gift
			gems:set(p, gem)
		end
		states:set(p, { name = "new" })
	end
end


function logic_fill_gems(cells, gems, states)
	-- TODO: transform into a coroutine
	-- TODO: fill in reverse gravity order
	cells:foreachpos(
		function(p, _)
			logic_fill_gem_at(cells, gems, states, p)
		end
	)
end

:: src/logic/matching.lua
--[[pod_format="raw",created="2024-08-24 08:12:55",modified="2025-10-20 19:39:39",revision=3462]]
--- Matching Logic

-- The matching algorithm has two phases:
--
-- 1. First, a linear sweep through all the gems, and for each gem involved in a match
--    creates a mark registering which direction(s) matched.
-- 2. Then a flood-fill algorithm is used to group matches together.


local function logic_is_matching(gem1, gem2)
	if (not gem1) or (not gem2) then
		return false
	end
	
	-- Only colored gems can match.
	if (gem1 < gem_color_first) or (gem1 > gem_color_last) then
		return false
	end
	if (gem2 < gem_color_first) or (gem2 > gem_color_last) then
		return false
	end

	return (gem1 == gem2) or (gem1 == gem_rainbow)
		or (gem2 == gem_rainbow)
end


--------------------------------------------------------------------------


local function test_3(gems, p0, p1, p2)
	local gem0 = gems:get(p0)
	local gem1 = gems:get(p1)
	local gem2 = gems:get(p2)
	return logic_is_matching(gem0, gem1)
		and logic_is_matching(gem0, gem2)
		and logic_is_matching(gem1, gem2)
end


local function test_4(gems, p0, p1, p2, p3)
	local gem0 = gems:get(p0)
	local gem1 = gems:get(p1)
	local gem2 = gems:get(p2)
	local gem3 = gems:get(p3)
	return logic_is_matching(gem0, gem1)
		and logic_is_matching(gem0, gem2)
		and logic_is_matching(gem0, gem3)
		and logic_is_matching(gem1, gem2)
		and logic_is_matching(gem1, gem3)
		and logic_is_matching(gem2, gem3)
end


function logic_test_sqr_match_at(gems, p)
	local S = p + pos(0, 1)
	local SS = p + pos(0, 2)
	local N = p + pos(0, -1)
	local NN = p + pos(0, -2)
	local E = p + pos(1, 0)
	local EE = p + pos(2, 0)
	local W = p + pos(-1, 0)
	local WW = p + pos(-2, 0)
	local SE = p + pos(1, 1)
	local SW = p + pos(-1, 1)
	local NE = p + pos(1, -1)
	local NW = p + pos(-1, -1)
	return test_3(gems, SS, S, p) or test_3(gems, S, p, N) or test_3(gems, p, N, NN)
		or test_3(gems, EE, E, p) or test_3(gems, E, p, W) or test_3(gems, p, W, WW)
		or test_4(gems, p, S, SE, E) or test_4(gems, p, S, SW, W) 
		or test_4(gems, p, N, NE, E) or test_4(gems, p, N, NW, W)
end


function logic_test_hex_match_at(gems, p)
	local S = p + pos(0, 2)
	local S_S = p + pos(0, 4)
	local N = p + pos(0, -2)
	local N_N = p + pos(0, -4)
	local SE = p + pos(1, 1)
	local SE_SE = p + pos(2, 2)
	local SW = p + pos(-1, 1)
	local SW_SW = p + pos(-2, 2)
	local NE = p + pos(1, -1)
	local NE_NE = p + pos(2, -2)
	local NW = p + pos(-1, -1)
	local NW_NW = p + pos(-2, -2)
	local E = p + pos(2, 0)
	local W = p + pos(-2, 0)
	return test_3(gems, S_S, S, p) or test_3(gems, S, p, N) or test_3(gems, p, N, N_N)
		or test_3(gems, SE_SE, SE, p) or test_3(gems, SE, p, NW) or test_3(gems, p, NW, NW_NW)
		or test_3(gems, NE_NE, NE, p) or test_3(gems, NE, p, SW) or test_3(gems, p, SW, SW_SW)
		or test_4(gems, p, SE, S, SW) or test_4(gems, p, NE, N, NW)
		or test_4(gems, p, NE, E, SE) or test_4(gems, p, NW, W, SW)
end


local function check_3_and_mark(gems, p0, p1, p2, mark, marks)
	if test_3(gems, p0, p1, p2) then
		marks:merge(p0, mark)
		marks:merge(p1, mark)
		marks:merge(p2, mark)
	end
end


local function check_4_and_mark(gems, p0, p1, p2, p3, mark, marks)
	if test_4(gems, p0, p1, p2, p3) then
		marks:merge(p0, mark)
		marks:merge(p1, mark)
		marks:merge(p2, mark)
		marks:merge(p3, mark)
	end
end


local function mark_sgrid_matches_at(gems, p0, marks)
	check_3_and_mark( gems,
		p0,
		p0 + pos(0, 1),
		p0 + pos(0, 2),
		{ name = "matching", vertical = true }, marks )
	check_3_and_mark( gems,
		p0,
		p0 + pos(1, 0),
		p0 + pos(2, 0),
		{ name = "matching", horizontal= true }, marks )
	check_4_and_mark( gems,
		p0,
		p0 + pos(1, 0),
		p0 + pos(0, 1),
		p0 + pos(1, 1),
		{ name = "matching", vertical = true, horizontal = true }, marks )
end


local function mark_hgrid_matches_at(gems, p0, marks)
	check_3_and_mark( gems,
		p0,
		p0 + pos(0, 2),
		p0 + pos(0, 4),
		{ name = "matching", vertical = true }, marks )
	check_3_and_mark( gems,
		p0,
		p0 + pos(1, 1),
		p0 + pos(2, 2),
		{ name = "matching", horizontal_SE = true }, marks )
	check_3_and_mark( gems,
		p0,
		p0 + pos(1, -1),
		p0 + pos(2, -2),
		{ name = "matching", horizontal_NE = true }, marks )
	local p1 = p0 + pos(1, 1)
	local p2 = p0 + pos(1, -1)
	local p3 = p0 + pos(2, 0)
	if test_4(gems, p0, p1, p2, p3) then
		marks:merge(p0, { name = "matching", vertical = true, horizontal_NE = true, horizontal_SE = true})
		marks:merge(p1, { name = "matching", vertical = true, horizontal_SE = true })
		marks:merge(p2, { name = "matching", vertical = true, horizontal_NE = true })
		marks:merge(p3, { name = "matching", vertical = true, horizontal_NE = true, horizontal_SE = true})
	end
end


local function mark_all_matches(gems)
	local marks = gems:new_grid()
	if gems:tiling() == "square" then
		gems:foreachpos(
			function(p, _gem)
				mark_sgrid_matches_at(gems, p, marks)
			end
		)
	elseif gems:tiling() == "hex" then
		gems:foreachpos(
			function(p, _gem)
				mark_hgrid_matches_at(gems, p, marks)
			end
		)
	end
	return marks
end


---------------------------------------------------------------------------


local function group_this_match(cells, gems, marks, p)
	-- A simple flood-fill algorithm to group all
	-- intersecting linear matches together.
	local colour = gem_rainbow
	local positions = {}
	local one_good_cell = false
	local remaining = { p }
	local rainbows = {}
	while #remaining > 0 do
		local current = deli(remaining)
		local gem = gems:get(current)
		local mark = marks:get(current)
		if mark and mark.name == "matching"
			and (not mark.counted)
			and logic_is_matching(colour, gem)
		then
			if gem == gem_rainbow then
				-- Rainbow gems can be part of multiple matches,
				-- so they need to be unflagged at the end.
				add(rainbows, current)
			else
				colour = gem
			end
			add(positions, current)
			marks:merge(current, { counted = true })
			local cell = cells:get(current)
			if cell and cell & cell_mask == cell_good then
				one_good_cell = true
			end
			local neighbours = gems:neighbours(current)
			foreach(
				neighbours,
				function(n)
					local s = marks:get(n.position)
					if not s then
						return
					end
					if s and s.name == "matching"
						and (not s.counted)
						and s[n.direction]
					then
						add(remaining, n.position)
					end
				end
			)
		end
	end
	foreach(
		rainbows,
		function(p)
			marks:merge(p, { counted = false })
		end
	)
	return { colour = colour, positions = positions, one_good_cell = one_good_cell }
end


function logic_find_matches(cells, gems)
	local marks = mark_all_matches(gems)
	local matches = {}
	marks:foreachpos(
		function(p, mark)
			if mark and mark.name == "matching"
				and (not mark.counted)
			then
				local match = group_this_match(cells, gems, marks, p)
				if match.colour == gem_rainbow then
					-- Ignore, as this is probably a stray rainbow that was unflagged
					-- at the end of `count_this_match`.
					-- TODO: an edge case is when there is a legitime match of
					-- only rainbow gems (e.g. 3 rainbows surrounded by black things).
				else
					add(matches, match)
				end
			end
		end
	)
	return matches, marks
end
:: src/logic/mechanics.lua
--[[pod_format="raw",created="2024-08-30 06:41:59",modified="2025-10-20 19:39:39",revision=2115]]
--- Core Mechanics Logic


function logic_mark_gravity(cells, gems, marks, gravity)
	local some_gems_are_falling = false
	gems:foreachpos(
		function(p, gem)
			local below = p + gravity
			local distance = 0
			local cell_below = cells:get(below) or cell_none
			while (cell_below & cell_mask != cell_none)
				and (cell_below & obstacle_mask == 0)
			do
				if (not gems:get(below)) then
					some_gems_are_falling = true
					distance += 1
				end
				below += gravity
				cell_below = cells:get(below) or cell_none
			end
			if distance > 0 then
				marks:set(p, { name = "falling", target = p + distance * gravity })
			end
		end
	)
	return some_gems_are_falling
end


function logic_enact_gravity(gems, marks)
	local fell_gems = {}
	marks:foreachpos(
		function(p, mark)
			if mark.name == "falling" then
				local new_p = mark.target
				add(fell_gems, { gem = gems:get(p), pos = new_p })
				gems:del(p)
				marks:del(p)
			end
		end
	)
	foreach(fell_gems,
		function(fell_gem)
			gems:set(fell_gem.pos, fell_gem.gem)
			marks:del(fell_gem.pos)
		end
	)
end


------------------------------------------------------------------------


function logic_mark_swap(gems, marks, source, target)
	local gem0 = gems:get(source)
	local gem1 = gems:get(target)
	local test = (gems:tiling() == "square") and logic_test_sqr_match_at or logic_test_hex_match_at
	gems:set(source, gem1)
	gems:set(target, gem0)
	local matched = test(gems, target) or test(gems, source)
	gems:set(source, gem0)
	gems:set(target, gem1)
	if not matched then
		return false
	end
	marks:set(source, {
		name = "swapping",
		selected = true,
		target = target,
	})
	marks:set(target, {
		name = "swapping",
		target = source,
	})
	return true
end


function logic_enact_swap(gems, marks)
	local reinsert = {}
	marks:foreachpos(
		function(p, mark)
			if mark.name == "swapping" then
				add(reinsert, { gem = gems:get(p), position = mark.target })
				gems:del(p)
				marks:del(p)
			end
		end
	)
	foreach(
		reinsert,
		function(r) gems:set(r.position, r.gem) end
	)
end


-------------------------------------------------------------------------


function logic_enact_clear(gems, marks)
	marks:foreachpos(
		function(p, mark)
			if mark.name == "matching" then
				gems:del(p)
				marks:del(p)
			end
		end
	)
end

-------------------------------------------------------------------------


function logic_mark_repair(cells, marks, matches)
	local is_something_repaired = false
	foreach(
		matches,
		function(match)
			if match.one_good_cell then
				foreach(
					match.positions,
					function(position)
						local cell = cells:get(position) or 0
						if cell & cell_mask == cell_bad then
							marks:set(position, { name = "repaired" })
							is_something_repaired = true
						end
					end
				)
			end
		end
	)
	return is_something_repaired
end


function logic_enact_repair(cells, marks)
	local to_be_unmarked = {}
	marks:foreachpos(
		function(position, mark)
			if mark.name == "repaired" then
				local cell = cells:get(position)
				cell = (cell & ~cell_mask) | cell_good
				cells:set(position, cell)
				add(to_be_unmarked, position)
			end
		end
	)
	foreach(to_be_unmarked, function(p) marks:del(p) end)
end


----------------------------------------------------------------------


function logic_mark_breakage(cells, gems, marks, matches)
	local something_broke = false
	foreach(
		matches,
		function(match)
			foreach(
				match.positions,
				function(position)
					local neighbours = cells:neighbours(position)
					foreach(
						neighbours,
						function(n)
							local cell = (cells:get(n.position) or 0) & obstacle_mask
							if cell >= rock_full and cell <= rock_broken then
								marks:set(n.position, { name = "broken" })
								something_broke = true
							end
							local gem = gems:get(n.position) or 0
							if #match.positions > 3 then
								if gem == gem_cat or gem == gem_bat
									or gem == gem_robot_asleep
									or gem == gem_bomb
								then
									marks:set(n.position, { name = "broken" })
									something_broke = true
								elseif gem == gem_robot then
									gems:set(n.position, gem_robot_asleep2)
								end
							elseif gem == gem_bomb then
								marks:set(n.position, { name = "broken", exploded = true })
								something_broke = true
							end
						end
					)
				end
			)
		end
	)
	return something_broke
end


function logic_enact_breakage(cells, gems, marks)
	local to_be_unmarked = {}
	marks:foreachpos(
		function(position, mark)
			if mark.name == "broken" then
				local cell = cells:get(position) or 0
				if cell & obstacle_mask == rock_full then
					cells:set(position, (cell & cell_mask) | rock_cracked)
				elseif cell & obstacle_mask == rock_cracked then
					cells:set(position, (cell & cell_mask) | rock_broken)
				elseif cell & obstacle_mask == rock_broken then
					cells:set(position, (cell & cell_mask))
				end
				local gem = gems:get(position) or 0
				if gem == gem_cat or gem == gem_bat
					or gem == gem_robot_asleep
					or gem == gem_bomb
				then
					gems:del(position)
				end
				if gem == gem_bomb and mark.exploded then
					local neighbours = cells:blast_radius(position)
					foreach(
						neighbours,
						function(p)
							local cell = cells:get(p)
							if cell then
								cells:set(p, cell_bad | (cell & obstacle_mask))
							end
						end
					)
				end
				add(to_be_unmarked, position)
			end
		end
	)
	foreach(to_be_unmarked, function(p) marks:del(p) end)
end


-----------------------------------------------------------------------


function logic_mark_move(cells, gems, marks)
	local something_moved = false
	local movers = {}
	gems:foreachpos(
		function(position, gem)
			if gem == gem_cat or gem == gem_bat or gem == gem_robot then
				add(movers, position)
			elseif gem == gem_robot_asleep2 then
				gems:set(position, gem_robot_asleep)
			elseif gem == gem_robot_asleep then
				gems:set(position, gem_robot)
			end
		end
	)
	foreach(
		movers,
		function(position)
			local neighbours = cells:neighbours(position)
			local possibilities = {}
			foreach(
				neighbours,
				function(neighbour)
					local cell = cells:get(neighbour.position) or 0
					local gem = gems:get(neighbour.position) or 0
					if (cell & obstacle_mask == 0)
						and (cell & cell_mask != 0)
						and (gem < gem_rainbow)
					then
						add(possibilities, neighbour.position)
					end
				end
			)
			if #possibilities > 0 then
				something_moved = true
				local target = possibilities[math.random(1, #possibilities)]
				local moving_gem = gems:get(position)
				gems:del(position)
				local target_gem = gems:get(target)
				gems:set(target, moving_gem)
				local source_gem
				logic_fill_gem_at(cells, gems, marks, position)
				source_gem = gems:get(position)
				marks:set(target, {
					name = "moving",
					source = position,
					target = target,
					moving_gem = moving_gem,
					target_gem = target_gem,
					source_gem = source_gem,
				})
				if moving_gem == gem_bat or moving_gem == gem_robot then
					local cell = cells:get(target)
					cell = cell_bad | (cell & obstacle_mask)
					cells:set(target, cell)
				end
			end
		end
	)
	return something_moved
end


function logic_enact_move(cells, gems, marks)
	marks:foreachpos(
		function(position, mark)
			if mark.name == "moving" then
				if mark.moving_gem == gem_robot then
				end
			end
		end
	)
	marks:foreachpos(function(p, _) marks:del(p) end)
end
:: src/logic/spells.lua
--[[pod_format="raw",created="2024-08-30 06:37:36",modified="2025-10-20 19:39:39",revision=994]]
--- Spell Logic


function logic_gain_mana(stats, matches)
	local gained = false
	foreach(
		matches,
		function(match)
			local count = #(match.positions)
			if count > 3 then
				stats.mana += 10 * (count - 3)
				gained = true
			end
			if stats.in_cascade then
				stats.mana += 5
				gained = true
			end
			stats.in_cascade = true
			if match.colour == gem_rainbow then
				foreach(
					{ gem_air, gem_fire, gem_day, gem_earth, gem_water, gem_night },
					function(g) stats.colour[g] += count end
				)
			else
				stats.colours[match.colour] += count
			end
		end
	)
	return gained
end

:: src/sgrid.lua
--[[pod_format="raw",created="2024-08-24 07:17:45",modified="2025-10-20 19:39:39",revision=3796]]
--- Square Grids

--- The origin of the grid, `pos(0, 0)`, is at the top left.


-- Local Constants --------------------------------------------------------


local max_width <const> = 16
local max_height <const> = 8


-- Constructors -----------------------------------------------------------


local metatable = {}


function metatable:new_grid()
	local result = sgrid_new()
	result.origin = self.origin
	return result
end


function sgrid_new()
	local grid = {}
	metatable.default_origin(grid)
	setmetatable(grid, { __index = metatable })
	for i = 0, max_width * max_height do
		grid[i] = false
	end
	return grid
end


function metatable:clone()
	local grid = self:new_grid()
	grid.origin = self.origin
	self:foreachpos(function(p, item) grid:set(p, item) end)
	return grid
end


-- Indexing --------------------------------------------------------------------


function metatable:tiling()
	return "square"
end


function metatable:get(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	return self[p.x + (p.y * max_width)]
end


function metatable:set(p, value)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	self[p.x + (p.y * max_width)] = value
end


function metatable:merge(p, state)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	local index = p.x + (p.y * max_width)
	if not self[index] then
		self[index] = {}
	end
	for k, v in pairs(state) do
		self[index][k] = v
	end
end


function metatable:del(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	self[p.x + (p.y * max_width)] = false
end


function metatable:distance(p0, p1)
	return abs(p0.x - p1.x) + abs(p0.y - p1.y)
end


-- Screen Coordinates ---------------------------------------------------------


function metatable:default_origin()
	self.origin = { x = 10, y = 4 }
end


function metatable:compute_origin()
	local min_p = pos(max_width, max_height)
	local max_p = pos(0, 0)
	self:foreachpos(
		function(position, cell)
			if not cell or cell == 0 then
				return
			end
			if position.x < min_p.x then min_p.x = position.x end
			if position.y < min_p.y then min_p.y = position.y end
			if position.x > max_p.x then max_p.x = position.x end
			if position.y > max_p.y then max_p.y = position.y end
		end
	)
	local width = 1 + max_p.x - min_p.x
	local height = 1 + max_p.y - min_p.y
	self.origin = {
		x = (480 // 2) - ((width * 29) // 2) - (min_p.x * 29),
		y = ((270 - 32) // 2) - ((height * 29) // 2) - (min_p.y * 29),
	}
end


function metatable:coords_origin()
	return self.origin.x, self.origin.y
end


function metatable:coords_cell(p)
	local ox, oy = self:coords_origin()
	return ox + p.x * 29, oy + p.y * 29
end


function metatable:coords_gem(p)
	local ox, oy = self:coords_origin()
	return ox + p.x * 29, oy + p.y * 29
end


function metatable:pos(x, y)
	local ox, oy = self:coords_origin()
	return pos((x - ox) // 29, (y - oy) // 29)
end


-- Iterating -------------------------------------------------------


function metatable:foreachpos(func)
	local p = pos(0, 0)
	for x = 0, max_width do
		for y = 0, max_height do
			local p = pos(x, y)
			local item = self:get(p)
			if item then
				func(p, item)
			end
		end
	end
end	


function metatable:neighbours(p)
	return {
		{ position = p + pos(1, 0), direction = "horizontal" },
		{ position = p + pos(0, 1), direction = "vertical" },
		{ position = p + pos(-1, 0), direction = "horizontal" },
		{ position = p + pos(0, -1), direction = "vertical" },
	}
end


function metatable:blast_radius(p)
	return {
		p + pos(0, 0),
		p + pos(1, 0),
		p + pos(1, 1),
		p + pos(0, 1),
		p + pos(-1, 1),
		p + pos(-1, 0),
		p + pos(-1, -1),
		p + pos(0, -1),
		p + pos(1, -1),
	}
end

:: [eoc]
