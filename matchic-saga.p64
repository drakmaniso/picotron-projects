picotron cartridge // www.picotron.net
version 2

:: docs/
:: docs/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTI2IDE0OjAzOjI1Iixtb2RpZmllZD0iMjAyNS0w
OS0xNyAwNTo1NDoyMCJdXQ==
:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNS0w
OS0xNyAwNTo0OTo1MyIscmV2aXNpb249NTIwMV1dbHo0AApiAAAj_gAA8xR7WzBdPXtibXA9cHh1
AEMgEBAE8PAsZmxhZ3M9MCxwYW5feAgAz3k9MCx6b29tPTZ9LDEA-1DwER0dBPBPPxJAPuAODxYf
Kg8VDiAOHyofFg7QDg8qPxUuBQBADg81wB4ApBQfFS8WHxUfFA8TANUPFQ8UDxNPFQ8TDxQfKAAB
FQARLxUAEC8VADGQPyw_AFATLxUfEz4A-AYeHytgDyw-LS8VXy0-LB8VHywPK1ARAD8PNUATACXz
AFBPLC8TTywvKx8TLysfNVsANU8tLyIAH2ATAITvcD8rLn0eHR81gPwD8C7JAR3yPDkvKxAPD-AG
DysgHvAFTyzwBw0-LQ0O8AYNDD0ODzXwAx1sHfABDawN4A28HcANLB8qjA0OoA0sK4wdDpANLBuc
HQ4PNXAN-AAtDgYAKwpgBwAm7D0GAP8g3E0OCnANvE0OGnANrF0OCpAdbG0OGqAOzQ4awA6tDhrg
Hm0eGvABCm4q8ARq8BfNAB3wBU0PLOAOoA4PLQ7ADg0OkA4dDqAOoABAgA4tDgQA0QyADg0PKx0O
YA4dCw0OAFIbHW4dGwsAMyuNKxQAEq0SACr9AQYAkHAOLS5tLi0OcFQA8QkaDyoLDk0OCgsPGg4d
DgxgDh0OCRsJDi0GAAERADMtDikEAIAMYA49Lk0uPQkAIP0DSQD-Jm0vCW0OHEBbXQhdW3AOPQ4d
Dh0OPQ4cgDstHg0eLTtwGyAOrQ4cABuwHm0eHPABDG4s8ARsEAEf8AKLDytgDvAEHkAe8AQODyxO
DQ0A8DFNHtAuIA5tDiAuDzVAHi0eAA4NHw8NHA0OAB4tHiAObR4MDyoODAsODB5tDhAOfQ4MHgwe
DA59Dg81AA59Dg0cKwDwCX0OCgAOjQ5NDo0OCgA_bQ4tDm0_CgAOGt8A8AYaDgoQCgA_zT4KEAow
DhoOLQ5NDi0WAPAGcAoATk1OChAKkA4qDk0OKg4K0AogGwD-AiAK8AMODQ4a8AkOGvALCvBx6AAd
IBoPCgNwLPAKDysPFhQDIvAJEgAgDzUUABEfBgBBDzXwCwYA8AQE7yvADu8tDqAODf8sAA6QDg38
BgDwDhw_TD4cDg81YC4MDg8NHw8PDQ4sDgsfDwsODC5A0wHwBQ4KHxAKDiwOChkKDgwOHQ4wDg0M
FgAWGRUAAEAAsSAOHA4MDgsaCw4sBgAAFgAQCBUAAmEA8AIcDggwLvwBLhhACA78AQ4oYAYAYAiA
DjyOPAcAUiwOjQ4sCQBVDQ5MDgwNABB8CgAwkA4cCgCvHA4YoO4YwOjwMCoBKR8SKgEWULAODd8s
lgUFMgEXDC0BVTwOLA48JQEDDgAFIAEwXixeAgESCxcBYA8cHx0PHDABIh8dMQEYCxsBEQsbATAb
QAsVARErGwESCxsBFAsbARgLGwEVCxsBFQsbAW8boO4bwOsbAR-wGS8fK6AusA4fLR5wDi0ekA4f
LB0eQA48HR5gDkwdHhAOHA8NDw8PDRwWAPIEbB0eLA8PDxAPDzwdDiAOnB0eDB4AoVwOIA4sHmwd
HnwwA-ECHB4LDiwePB0eXA4LAC4rDgwQAKMMHR48DgsQKxAeEgByHS4MDgtwGxAA8QUMDi0eC8Ab
EB4bDjwNDgvwAhsADhwB4PABHhAOTA4LsB4gDg0e-wAhG2ALAHIADkwuGxAuCwCSDB0eLB47IA4d
DABAXB4rYAgA-xiMHiuADrweK7AOjB4r0A5sHivwAQ48HivwAw4cHivwBh4r8Akb8CI1AR3xCBYf
K2Ae8AAeDy0ODzVQDg8tHrAeHQ8sDQDwEA0fLB5wHh0cDh81YA48HkAOHTwOC3AOXA4wDkwOG4DL
ANAwDjw_QD48DhswDkwdDwBQHUwOC1AfABBABQAjUA4PACELcO4AAAUAYXAOLD4gPvEB8AMsHQ4L
EA4dLA4bkA48DhsgDjwWAAG3AxAwKwAQgIECEBxMABAcKgKADSwODD4APgxEABMNsAFxDhwdDgsO
HSAAEhzSAQEzAABzASQbgPQBABMAIAsQBQBgoA5cDhwuZQJADlwODNwFoA4LwA5cDg08DhsIAAGp
ATDgDky0ADDgDlyGAI-wAJ4b8AKbsFsBHdAyLyugHqAeLy0OcB4dBABAPywOQE8BALcFFB2OAqIO
EB4dTA4wDh08vgBBLB4dbIUEE1y7ALAeHZwOIA58Hh1sHpcB8QQQDlweHTweLA4LHhwOEA48Hh0M
DQDFDA4LAAsuCwAODC4dEACVHgsgKwAeLQ4MDwAhG2DrAAAKABGw7QDxCiAb8AEOTA4QHvADDiwO
DB4NDiAe4C5MDgAKAHKgGx4sHh0MDgBSLnALHlwOAHAdDguACx6MDQCwG6ALHrwOC9ALHowsAeAL
HmwOC-ADCx48DhvwBaUAvwvwCAseG-AKG-ARQwEd8gYanyvwAg4vLQ5dDvAADg0-LA5MDvBOAyBc
DqYBMVwO0DACMAwOXDMIIAwuGQAQsDcCIC81sAQEZQEQoBMAAD0BABQAAWgBEBwGBTAsDgAFAAQm
AHCQDg0_DzU_BAUAIwVBDjsAG2wAYKAODRwOQAUAEAwMAAGfAiANLGgAUjwOIA4NtgJgHD4LED4s
OQBQHA47IBvFAhBwHAABcQEBCgAkC1AGABBcTgCxXA5QDg0sPgswPjxRAGA8DjtAGw4MAkANTA6A
BQBBCzAePEYAcCweG0ALHixMAEEcHitw3gH-A1AODR4rsAseC1AeK-AAG2AbcG4JfTH9Aw4FAAFd
CRDNXQZ0YA4tTi1OLUgJBU4JEilNCR8JTQlGDyQNEB8yMQD--0ifHR0E-zf---88NQALHTE1AB84
NQAhXzsN-zwNBgA_D4YAHQc7AA8GADgPhgAMD6cBHQ0TBU8POw88BAAhFx8MAA84AP-------wcv
DzuJBh0HOwAPBAAZFx8MAA84AP-------wcvDzyJBhxxjzwPPQ87rwYAEU8GADL-PAAHABABBwAR
zxQAF38gABEfBgAXjwwAF_8GAAIwACRfPDQAES8GABUPNAATL2QAFgRXABcfKQAEgwAQBwcAF98T
ABGfBgARPwYAGL8lABdvJQAmXzxWADb-PBINACw-PCsAHR8YADb-PAgNABOfEwAWAiwAF38_AAN8
AAVdACc7TyMAEx8jABYWEwAXf7gACBIAF886AQIkARnfQwAWE5IACKsAD_QBGfEmIyAEcP82A_D_
BdD_BcD_B7D_B6D_CZD_CYD_C3D_C2D_DVD_DUD_DzD_DyD_ERD_EQD_NgAJABEgFQARQCEAEWAt
ABGAOQARoEUAEcBRAD-g-gOXFAweNY4AHzeOAHofOI4AevMzOwPg-zwF0P87BcD-PAew-zsHoP88
CZD-OwmA-zwLcP87C2D-PA1Q-zsNQP88DzD-Ow8g-zwREP87EQD-PBP-OxMADwATIB8AE0AvABNg
PwATgE8AE6BfABPAbwA-4P88rwAODoARDzEAewBCAQQ9AxOfSQMg4G4IADC_0C4HABCOBQDwAE7A
-gYPPbANDzv_AA0MLvIBoE4NDD4NDI4NDA76AfEFLg0M-gZgng0MXg0MLg0MPlAM-gsHAsE_DQzu
DQx_IA4NDM4vAPIAPhCeDQz_Ag0MDgAM-gQNBAAQAzYAEABFAEIMEP4AWgBRIAxuDQxvAAM3AkG_
DQx_XgARYG4AEHAcABCORAIBQACRHg2gXg0M7rAOJgAhnsA6AM-QXg0MzuCuDQxODXCvExzwE-AV
vzQPMdDfNC8xoN80TzGAXzRfMg8xDzAPNF8xYE80fzILAPAJLzJPMUBPNI8yDzFPMk8xMD80-zIB
PzEgCABBAz8xEAgAvx8xHzAQLzT-MgUvCAAZcS8yDzH-MgEMAHIfMQ8w-zICDAAyMA80DAAQHxgA
AAwAUD8wED8xcgAgMCAIAPEOAT8wME8xfzIPMV8yTzBATzFvMh8xPzJPMGBfMT-FAP8GLzJfMIBP
Md8woC8x3zDQDzG-MPAVCAccAyIBUJ80DzIvJgEADgAfDyoBEEIwDzQ-LAERnw0AIU8yMQFhvzIP
MF8yNAERrz8AED8eABMyPQFgDzIPMY8y_wAAvQABXgAkMi8ZABJ-EQBgNB8yDzAvCgASMSkBAfgA
An0AEC92AAEVABAyWgAAVgAAFwAgDzASAAIuACMyH28ARR80nzKCAVQvMB80vyIAAGcAQR80LzAR
ACEPNA8AEjHEAEUPMK8ynwEUXw8AAqIBoW8yDzBPMg8xPzKpATF-Mh-EACFPMrABACABEy8eABEw
rAESMP8AAbsBAEsBUh8wHzEfvwE-DzI-vwE2ACIBEHCiAGCgTzQvMUDFAeCAXzQvMTAvNE8xYG80
L5cBAHEAIVBP6wAQD_oBcDEQHzQ-Mj_-AQBLAQFFAVQxDzAAH8gBAssAEh8SAABPATAgLzS6AUEA
DzQf5ABBIC80fysBIDEf8gAAgQAANAAAhwGSMB8xTzBADzQ-xQHwUjIvMEBOYD8xLzI_8AMvMV5A
PzSAHQAfMU4wXRxQHQ8yDBAuQF1MMAwbDpA9G1wgDB4QLRwgPUs8YC0bHBAtaxweQC0rLAAdWwwb
LkAtOxwAHUsMKy4wLRsMGywADQwrDA4OAP8eCwwNKwwOACw7DAs_MB0cDTseADwrTlA8Ky4ALI5g
HF4gDI6AbjB_sC6ALvATZAEd8QU2TzTwAy4ADk8zDzIALsAOLzMPMg0AcA4vMw6wDj0FAvAHDzFN
oAw9DzIMQwwLPQxwHg0MDRuDG9IE8AZAHi0cMwUUBQQTHA4dGzAOPQsjFAUCAKIDCz0LMA4tCyMF
EAC1BAMtCwwwDCsMEwQSAFQrHEAsIw8AYxQDLFAuEwwAdwUUAy5ADi0PAGMOLTAOHQsRABAfEgBD
LQswLREAwgoPKhoUAx0bMAsdDBIAgjoDBAMrDEAsDgBHBRoTBF8ALwQTXwACCBAAGj0PACctC34A
C30AAAIAAHwAEyt7AAACAAF8AI--MAEscP81BEIfH-ARhC809QEuQA4PKg4PMvUBLg0wLg30AS4N
IC4N9QMuDRAZAIAN9AMODA4NEAUAMWROZAwAcC4NVF4NVC4JAPAAfisODY4NEK4LDA8MDwoJDADw
D50OCw8MHwoJrSAtUw4LKgkNUy0wHg1UHikODVQeDQsAE14JADFkTWQIACb0AwcAIv4IBABxDv0I
QP8wB9kAH0vZAGElLxDaAFQRDw8PDtsAUhEfDw8O3AAQLxcAA94AHyreAJwVFd4AEBaeKwTeAFMW
HxQPE94AABcAD94ApCMaHd0AVBsPGQ8Y3QBTGx8ZDxjdAAAXAATdABMd3AAvHk3cAJEUH9wAVCAP
Hg8d3ABTIB8eDx3cAAAXAA-cAKMUJNwAVCUPIw8i3ABTJR8jDyLcAAAXAA-cAF4L4AlWbzQPMT-k
CQAOCQL8BwHoCUAfNA8yGggAyQcCFQAB8gkAZAgkXzInCRM-zQgQMFgIAMcIMi8xLxcAETA8CBEf
KgBEPzAvNP8JARAKABsIAR0AHTEWChAfrQgPGAoCAXEAH28aCgEgHzSGAA0cCgHQCQEqAAQgChEf
XwAeHyAKADkKAs4ACSgKET-DCgMVAAYuCgGYAANXAA84CgAC0gA0LzFPPgoRTzoAAF4ANj8wH0YK
Mz8yLxcAAFcAADQAAU4KYh8yHzFfMG4AAXUBAFQKVy8wTzQPFQABWgoBkQkWMCgAA14KLz8wXAo7
DoQODzEA0PAIIxMEIA8W-xUMQA8W-xQOIA8WLxT-MAlOBhAQDABGDzBvJwQAABcAVgAPFj8VEwAA
BABwPxUPEw8WPy0AFigEACE-FBYAGxUWAB8VFgAIAEIAFikEAAFCAB8VFgACHxYWAAgIWAAGQgAM
FgAPLAAJCNwAAfMAHxUKAQE1EA8VLQGvIP8UDg8TQP4NIH4BGZMFBwQAJwAHIBcCAE8HACcAQAAL
HDhAAJEQByAXEAcABzACAC8QRz8AHAF-AEIHMAcgAgAPPwAlPxAXQL4AJBEwQACvAAcABxAHAEcg
B0IAHW9XMDdABzB9ACMgFxB9ABE3gQEPQAAgEkc3AQLCAB8gOgEhAncADn8AD0IAGxA3ggA-EBcQ
QAAZ-wIHCwQAPyoQXgAeHzoeDR4NAAUAA39eDQA_HRA9mwAMLDE0XADBEB8qMC4POhA_DSAN3gcF
AwB-EF4AXg0AXVEAHQetAEAAHQAeqAhBEC4dAAMAD1MANZ8eHSAuQB4NHhD4ACpgQB4POiAuTgBw
EC4NHgAeHU4AQV4NAC3-AC9AHVMAHcJfKgBeDzoeTU4QXhBEAAWhAC8ATaEAH_AvKiA_DzoALi0A
Hh0gTgEBHx3sASwCoQAA4AAF9wAFBgAQIPIAHyCaASgBmgA-AD4dqAAwDFYAcV4NAE4NEB23AABN
AV8uHSAtEFUAGvEBChAEEE8qMG4QjgAuLzouDRcLDwUAEK_ODQBuHRBOHTBNcAAMHDlvAP8DIC8q
UD4POjBODSBeDTAdLg1QAwABQCCOAI5lAB_NXgAcDs0AxwAtEC4NQD4NMD4dIAMAHzBhADEBXAAg
UC5cAHEwPg1ATlANDwAvLiAhASmBEC8qYC4POlC2AEFALh1ACQAhAC4qBAR_AQG8ABFNbgBfUC4N
YC1kABz1BI8qAI4POo4NLm0uDVBuIH4QjhBNAA__ACvxBSBPKjBeDzoQbg0ATj0APh0wLh1AYQAz
AC4tvgADwwAPYgAlBLwAJwA9HwEPCQAFP2AtMEICLgEFAH8Abh0Abg0AxwA3D2gABKGODQB_DRBu
DSAtxgBQME4NEF5hAG8gPh1APSBkABn_Bl4IBBD-OkogDv87Sg89AA7-O0wPPgYAMAAPPSEATD4g
-UrDALEtMjMuMzE5MDQ3NgYAA24Aki0wLjcxNDI4NQYAIjY4fgAKWQTQZhwE8Fj1UiAF9FIDEAUA
MA86AAcAHw4GAGt8EPNSHiD_UnoFUzI2Ljc13wAfM5caAQDPAO_-9FIgBPNSDzsQBPNSDgUAWw_0
ACHAEQ4EEA8WrxUwDxa-4AsCBwBSEA8W3xUEDTEUXw4yDBI6EwCDDzpPFV8OPxUSAAIaABcVJgAS
FRQAMAAPFUkAFB8JAK8POiC-Ex86ML4QOQwZXxEOBPADnwAREwASAASdABIAnAAWAJsAEgCaABIQ
jwASIAcAPzC_II8AHA8tAQNATxU-DmBAAZIAUR8OHxQfdAAAIwEzfxUfLwEACgAiTxUWAFlfFB8O
XzEBJg8VFAAPPQFND68ABBYArgAUAK0AFgCsAANCARYAqgAPTQEqwQQEBAAfOwAOHzoPPQUAPwAd
AEAACx8xBRAsoRcLBPABHzuATlBwAP8pUB5POi4gDh0PPUAOnQ4gHEAOvR4wPh1cbT4dPFAMrQxQ
HiAcfQxQDh0MMBw9HGAOHQxQPJAc8ABzABxSMB878ARxACFOcAgA8A4gLk86HmAfPSAOnzoOEC4w
Hr0OAA89HT5tXB0OAHkA8AIsEAx9HCAecBw9HDAOHQyAPIUAT-AEHEAkER4PMQD--5jwXygoBP8-
FgL_BQL_Lgb_HQJOAu4C-hQG-gYG-gcC-g0C-gMC-gICBgKOBv4MAk4C-jAC-iICXgLeBv47Av4F
Bv4BAj4C-hECBgLeAo4CPgJOEgYPMgYS-hMCBgL_FgL_FwL_NAL_EAL_KgL_Ywa_QgAQEBsAMAcC
3jcAEf4mAAIrABADSgD-AD0GTgL_IwLuAl4Cngb_JLMjGcIoKASvPwL_CgIOBu5WAGBuAj4G-gkT
ACE_AggAAOEAARoAEK4VAID_DAL_EgL_N4YAoO4CBgJ_Br4C-gALAXoGAj4C7gLezADQngL_AQKe
An4GXgb_UK8AES6-AGAIAv4dBt5qABBHQAAyDQJ_LwCBLgJOBi4C-h5FARAxggDgAAb_IAL_LgIu
An4G-g0mADEOBm6GAB8B6AAc4W8-Bv4xAo4GjgL_GQZ_vQEgVwaKADIIAl7hABDODAAQ3hoAMF4C
jmsAFxPNABF_lACgFwKuAr4C-hMCvt0BdFUG-gsC-hQ5AWD_BQJ_Am45ACAWArYAQQEC-gurADEM
Ak4dAoFbBv4hBj4CPhgA4QUC-hIG-g8C-gsGbgKeDQAfINMAHCCPP1wAES6aABACxgBwRAJ_Bo4C
zncCAZQAYf4IAs4CHk8CEARpACH_BNQBQQYC-hwSAALNARAtVQFB-gIGrs8CQAIC-htPABC_6QAV
Bt0BEN5PAFIFAo4CLhUBEh6VAjGuAk5KABAXIQEwHQauBwFBHQL_A9oAUAUG-iUGRAAQIiQAIE4G
TQI-DQKu5gAcYP8-CwL_b2AAMSIGnpMAExZkAUECBv4e0QARMCYCEBJzAZDuAv4zBv6DAo6uACL_
ACoAQa4C-k4QAGAMAq4G-idXAjN_Ar5GABA0mAIASQDPLAL_DgL_UQL_HwaOpAAeE2yxAjABAp6P
AxgWQAIQAfMDMQYCvqwAEAuOAEFCBv4OTwMQAS8BQK4G-pGxACQMAnABIf4zNgRQDAL_OgYSABUW
PwAQNq4AQb4C-lJjAk8tAv4uqwAeEBmJAQK3AUEiAv4GpQFQBQL_DwYIAVEdAm4CrvQDEDtnAFIR
Aj4CBoIEAMcAEDoUAAEiAhBubAQQLisAEQLMABEtgAERDFYAERymAUEJAv4EIQMQBGQBEh5fAwJz
AVAMBs4CjoUDMUQCXlAATw0C-hrIAB5CNwb_CTwDMRACvkEDEAbcAwFhA0EDBv5cdAMB9QEh-gU5
BRABJwATFoQAAK0DBA0AEd6oABJG1gNABAL_MoEBBJEBEARYBQC8AAU7AEEfAv4mRwIQIMQAEAJT
BE8rAv4ewQAZABQd8jwaKfAIGQsMCxnwBBkcKhsZ8AAZHGobGbAZHKobGXAZHOobGUAJHPoDCwoI
MAkM_gUJCA81IAkMWhlKGVoJCA4gCQxKCRwJKgkcCUoPAJQ6CTwJCgk8CToPADZMCUwNABSsCwA0
SgmMMgBdWglsCVoWAFNKCTwJPA0AhAtaCRwJCgkcJwBSahkqGWoaACH6BQgA-yYKCfoDGQgOMBgZ
6hkYHkAOGBmqGRgucA4YGWoZGC6wDhgZKhkYLvAADhgpGC7wBA4oLvAILu9DHvAONI7wAw5PEQ8Q
DxEfEA7wAQ4PEY8PDxAO4A4PEa8JAFDADg8RzwkAUKAODxHvCQDwBIAODxFfDy59DxAOYA4PEW0O
HA4MAEBADgyNCwBACw8NMAsAUCwObQ4KE0RADH0OPAwAGgkLADNtDkwLAGQLbQ48Dn0WAAQLACEL
bXtHAQsAMX0OHAsAMDAKDgsA8BVtDgoZQAoOfS5dDgoZYAoO7Q4KGYAKDs0OChmgCg6tDgoZwAow
AP8AGeAKjgoZ8AGKGfADifAWHAEdcE3-EwGgDs88TjAWHxX4AJEW-xQBDxUPEmALAFUDDg8SUAoA
Ow81QAwARW8UTm0NAFNdDkwOXQ4AZAxNDmwOTQ0AXz0OjA49DQApCU4ACGgANQ8VbYIAJQz9mQAe
FQsAEFALAP8IAQ4PEh81YA8S-gELHzWA_wEaoPoB8C83AR3wCDHvGMAOvxsPGg8bDxoOsA4PG88Z
DxoOyEkwDxvvCwAFCQDADzVwDg8b-xkBDxoOCgBBbxkubRcAQFAODxsAAgAOABNQ1QBTCw4PNTA4
AvAKCw4wDgxdHkweXQsOChAOC10OjA5dCw8XEA4BlKwOTQ4JCgAOCwsA8QIQCQ49DqwOPQ4JGhAJ
Dk0OLMZJABoA0DAJDk0_DD5NDgkaMAl2TPABDn0OCQpQCQ5tLm0OCRpQCRVEkgkKcAkO7Q4JGgcA
-wMKkAkOzQ4JGpAJ7gkKsOkawOp1KB-gNW8d8AQeLyAPHw8gHx-LSPATHyBvHh8fHxzADh8grx4P
Hw4PHKAODyDvHg4PHIAODyB-Hg1NYRxwDg8gfQoAASUBcCCNDo0ODxwKAAK9AAAYAAF-AxEMGQAF
CwATC4oDpiwOfQ4LCiAODx8MAAOLAwALAB8JCwAAMjAOCVUCUQsaMA4JlgFgDgsKUAsJJAFACxpQ
CyQB-xMLCnALDu0OCxqACx6tHgsaoBsebR4bGsAKG24bKvAACmsqW08i8AUaLyLwCQ4PJA8lDyQO
8AcODyUvIwoAUQUODyVPCgBRAw4PJW8KAFABDg8ljwoAUOAODyWvCQBQwA4PJc8JABGgLwBAPl0P
JMYDISVNWgIwJA5gLgJiLA6NCw5ACgBArQsOIE0CkCwOPR5dDg8hEHsCESxwSRBdzQQQAB0AMDwu
HA4AcAkQCg5NDoyOT0IZIAoOhQMBmARSTQ5MDk2aBD9NTk2cBAcByAQx8AEKLQBQ8AMKDi0IAN8F
Ci4KGfAHKhnwCSmwMAEfECYwAVEpDyoPKTABMCovKAoA8AIBTg8qTygPKU6gDk8qbyhPKQgBYCpv
KC8PbyAA0HAODypfKA8PLxEPD18RAD8PNWATAANCHygqDRUARQ0vFB0XAPIDDQovDAoNLw8NDxQv
Fg8UDQ8pxQMgKh0ZABJNFgAALwAAhyUXLRQA8AEtDykOIA4MTSptLxRNDycOjiVB-QcPJ8hMgQxN
LyNtLxlNDwD5DhAODyctDyMvJQ8jTQ8ZLxsPGS0PJw4fNSAODycdGAARHRgAQkAODA0XAEINLx4N
GgARDRoAgFAODB0vIw0PgAMxHg0vMAAAxwAiDF0TAB9dEAAFQW0vHm0MAP8RcA5PJ21LDh81gE4L
TQtOGeAOCy0LDlnwAQ4rDhnwBy68ASIf-zdFDh827AgYNypLKu4IOyrLKu8IQQr7AwpoCBMMcAgP
EgAtHwsSAAZaCgkqyyrLCD8qSyrNCFwAQEsTHwQAFC-ZCAQRAAQEABQP6QgMGQAUL-kIFy8VAAAE
ACM-DwcJDDIABR0AHkA2AAp0AC8NMD8ABAJ5AADoSy81ICMAEw9oAAcPIwAYBxMAD4wAKAEzAR8f
aQABDyMAFkgwDw0OtwENIwBuHzVADw0OkwEBGwAfYBsAAAM2AEaADw0OEwAE_wEBGwAXoDYAA0kA
UsAPDQ6PCwDv4A8Njg0fNfABjRzwA4xSCj0AcVgPBAABIw8UaQoXDxUACgQABNAJJRYvEwAGBAAW
Lx8AD2MACgIjAA9lAP8cJxUPFwAPZQAiBRMAD2UAJwC_Cyf-FL8LAOQCX-0BHKD8vws9Xx8ZDxoP
BAAAFB-XCw8hAAoC7wsXLxcACAQAIy8ZBgwEEQAPBAAJAyQMDm8AD3cAAA8pABYAOwsOoAAPqAAC
HjCoAA8EAAoCwQgBZwAfDwQAEAEoAC8XELkAEAYyADAODxc1CQM9AA8zABdEEA8XDhMADwQAD0EO
DxcfMwAPJwEPAV4AXzAPFw4fiQARHx8rABc_DzVQtAAPrAAFHlCsAAykAB5weQAMnAAPIwAOcg81
kA8XDs8uAM_QDxfuDQ81sO0cwOwdDkhGHx8fHgQAFA8rDhcvFQAABAADNw41-x4BNw4EGwAEBAAj
Lx5GDjUPHg8VAAlZAAEcA0Eg-x4FVg4OZQA0Hx4PKQARIEgABBcACAQABB8AEh9IAAIrAA9KAAsf
H0oAFE8wDg8f1gACER8bAA-YAAhSUA8cDx8dAQAuAj8cDg9uAANGcA8cDhMAAqgAATQAcIAPHB6v
Hh4LAP8LoB8cHm8eHh8cHzXADR8cbhwt8AANbC3wBG38DjtVHyMPJB8ADxMPDgAVHwgPGC8SABfg
MQAFFQAbwDgABAQAKw6gPwAEBAAuDoBHAAYdAB9gTwAEBAQALw5AVwAEBAQAAJNWSB8jDRwCAAGC
D0kPJQ0cAgBADA4PIekERw0MDRwCABEsFwBbEA8hDgwvAFoLHzUgCxYASA4LGkATAAA0XRhgEQAR
DMsQJw4MMQAUoA8AAC0AFMANAAApABPgDQBQDgsa8AEMAAAiACDwAwoAAB8A3-AFCy4LGvAHKxrw
CSrTDzpdHygPKR-XDwCvDxMPBAAUX98PN-8oAcUPBiEADAQAJR8oJwAPMwAcEVAzABMD5Q8OMQAP
OQAEYyAODf8oB-sPTw8oDQwCAAEBdg9VAA4N-AcMEDscDQwCACEcCw8QYAv8AwsOGvlYKg0MHgCv
GlAODfwBCw4KYB0AACYKYB0AEVwVAPEMXAsOCnAOS2xLDhqATgscDRwLThrgDgssCw5a6g9OGvAH
LtMBD_oPf29LGUsZSwrbGAK-CisJPAkLCTwJKwrdGABFCisJrBoAFkrJGG8KSwlsCUsYAAARO_IY
LzsK4xgCbwpbGSsZWxsQzR8uGBAEbw8PDh8RDhgQBgAdABUfDgAPFhABJA4vPwAPiA8CLw4-HwAA
Fi99AAAfAAgGDwohAC8OTx8AAQMPAAxAAA6AAA8hAAYtEC__AAtjAB8vIAEADwQQCAElAAgjAAoE
EHUPDy4NDxA9ARBRLQ8QHQwCAAX5DwMQACAMDRgGgqALDi0MHQw90gURjcwFEI7GBV_LGvADiuEP
qGAPFE4dDxXmAAQaABEN9AAiSw4NAQEVAKQLLQwNDmsODQwtEQAAIwAmiw43AIgLDQwdDosODTMA
Pw6LDjEAGw1kAEAdDA5LIwAFNgAQDA0AIR1OBgAGOAATHQIABDoAJwwdAgAKOwAEAgADDw8YDMwa
nwofNYD6ARmg_Q0PsEEuDQ8anAYSDHEHIhsdDQAhKw4IAEEdDA5QlAEB6gEDEgAAHAsnCy0UAEAt
DA4wqQEAAgBCHkseDAoAAEgbAFgBAdEBAjsAAIIOAU4AIQ6raAEBVhsaDBEARRAJDg0RABINYhsA
8wFRKw4LDiv3AQFmGwA1ADI_Cz41ABMaEQAAMQARCz8AAkwAI1AJDQAjDS4IAAKEGwG9AAMCABIt
jxsDPwAEOwAeGhMADqcbD4oNZTsPHw6LDQPNGwHDAWAgHR8fHRwTZCMcLYUNMQ0MHSFkIA0cGQAC
3gxDC40OC9MbMAstHDtkEA4mACIMDWUfEgssABArRwAUHWwfFCtLHzAtHB38AQIvAAAcAAAuAAEM
BAQtADBtDkuPGiIJMBQAAC0AAI4aETDnAQRZAAA9ADBQCgz4G0EKGVAKoAATHXEAM3AKDg0AEQzy
GnAerR4KGaAaWmv-ABnACRpuGinwAAlqKfAEaQoNnj8PIz4HDQJfDi8lDg8FDQUBHQABCgANAw0R
DzoABBcADQENAB0ASw0cDR4CDQLkAxIOawwJBA1sDA47LhsOAg0hDovlCmIOCh81IAoSACBrDkgA
AaQcARAAEUurDAGpHAAQABJOMAAArxwC3AwCLgAloAr4DAG9HAINABIMwxwTDCUAAMccAk0AAMkc
AKkADsscD-gMUScvDvQMr18oDw4vEA8OXyjIDAEBGwALxAwCIwAiKQ0dADcNLxPjHDIJKwlgAAIz
cAfkHEIJKwlNFQAE4xxhHQ8pCSsJiwQCGQAAiQUA6Bw0KW0q5xwvDQwCAAIG-BxGIm0vGPwcgR0M
DyIvJA8iJgCHDxgvGg8YDB0CHQEdABJNGQAHAh0CNAAjLx0zAAcCHaEiDQ8dLx8PHQ0vMAAA5gAC
AAYDFwAA_gMGCh0BFAAGGh0AUgACDgABDB0RSAwd-wwIHQwdCE4X4A4ILQgOV-ABDigOF-AHLhfw
CSckDWwP_iUKA4wMMwy6LKoMQ7oMCgwLABTaCQAjWowJAAQuACw6rCMABjcAOgu6LC4AD9UlkiF-
DwQAArgMI48PNQAAqAwhnw8EAAOWDAIOAATCCwEPABEPOwAFEwATfxMADxcAEkUQTw8fFwACBAA2
HxFPNgAhTw9oDAUfAAAMABhPPgATPxsAGD8XADX-DwVBDDX-DwMqDDX-DwEeDCXvDxYMFs--Gx_v
9xtcAjMmFVAKAAKvCwgMACCPFAQADw8ABVhfFG8WXw8AXA8WTxQPEwACbyEJFwATPxMAXC8ULxY-
LgAcT0EAGL8PAB8-kAAHGxWfAAfJAB8VDAABD70aBw98JlsCCgABkABDG-8ZAzgakk8ZPxsPGT8b
TzMAAPcZIV8Z2gsjGw8IABRfEBoRXxUAEx8EAAMZAAG9BVMabxkPGwQAA9gZE29ZABJvPRgAuBkT
n1UAEp8TAABlGROPEwAWj3gZCRMAAmAZBqUABUgZNf8ZAykZNf8ZAQoZAgwAAvMYFu-bGAELAA-D
GGEF4CYCgRcMqBgz-x4DFAulTx4-IA8ePyBPHo0YIV8eXUojIA8IABBfGwAEGQBTDx4fIA8IABJf
NAATIBsAVT8eDyCPEwBmH08eryBPIgAHmxhvH18ejyBfbBgDZW8eTyBvHmAYAqkAD00YAATOAAA_
GBLvMAAPMBgSDywnalQ-Iz8lb_0KIU8j8QokJX-jCiBfI_cKNB8lj9UKI28jPACTIA4NfyNPJZ8j
uAohfyOFABAliCUkXyO0ChF-EgAKBAAlXyO9ChNvNQAABAAQTxcAsh81IA8hDl8jjyU-DwBxQA8h
Dv8jAQwAUmAPIQ7vFwBSgA8hDs8LAFKgDyEOrwsAUsAPIQ6PCwAR4F4AAQsAU-ABDyEOXgBj8AMP
IQ4vDADvBQ8hLgwfNfAHLBvwCSuBJ0wCYhcMnxcIDABWfygPD3_cChE-fydiDS8UPQ8prARQKk0K
DQoUAFMPFA0MTX8KgV0KLQ8PLQxdXxdzC206Dw88bXYKUa0PJ60JYgqhC20-Iw8ePxltCaUEwQld
DyMtDx4tDxldCVUKgAlNDyMNCA0PPSdBDQdNCVIKMAs9KBIAMSc9CUcKYQt9Dx59CZ0AbAv9AQkO
BggA-xNwDkltSQ4WgE4JTQlOFuAOCS0JDlbwAQ4pDhbwBy4W8AkmGgpXEhwZCkELDAobGwoxKwwq
HQoxSwxKHwoxawxqIQrxAIsMihsIMAkLHGscC2obCiUKwwsaHCsPKgwaKyobGRIAlDofKgwqCyor
ORAAcQs6Cyo7OQrwCSA6CxsAJQoLDwBWGgsqKxoPAFUKCyorKg8ARhsqKzocADYqK0oNADUaK1oN
ADNLSisLAJEaGykbKhspGhkPAFEraStpKhgAUAqJCokaYApRGmkKaRpiClEaSQpJGmQKURopCika
ZgpSGgkKCRpoCh8qaAotII8RTwRwHW8QDQwO4HMOUEwNHw8MnXFRLA1MDSt8cmBMDSwNSwwfckBc
TVsMEXLQXA8qKwwLDFsMDkAOHScAQCsMSxxfCkAMCx0cHABiKywbHA4LzgkyDCsNEwA0CxwuEwAw
Ow0bJAAmDD4RAFgLDCssKxEARgwrLDsQAHUrHCssSwwLQgCkCxwbDAssSwweG2gAcxxLLEsMThs3
CvACDFsMSwxeCwofNUAKDFtMXgspD3AMSwwuC04LJQ9wDCsMTgsuCyEPcAwbDE4LHgsfDzAcbhsZ
Dy8Me3kwLjD-FgEyAUH-FQENKQqhFQ8UDe8VDQ4PFC4KpBUfFA3PFQ0eDxRSCYgvFB8qDQyNLhIA
Qg8VbxQIAAsXABFfFwAcHxcAEU8XABwvFwARPxcAHD8XABMvLgAeD2AAEx8bAB4fGwATDxsAHC8b
ABEfFwAePzIAABcAH09kAAE-LxVfYAABPC8VbxcAGM8PAACVAFTODxQeCxEAUQsK7gsODgBjUA4K
-gELjQq-_wEJHzWA_QEYoPiNCiWB7xsOsA4drxqyFQCgdWENrA0PGQxydVENjA0bDIkKQA0sDYws
AwBydVEPKn07DN0FkA1MDypLDAsMS9cVYA1MDTsMGwwAAIEIABsAYTsMKxxLDHp1AEEDESwbABQQ
DgAANwAAawoRbSgDEWy_LjIMSwwlA1BOCwoJEA8AAw0AERkNADEbLDsaAFEwDgxLPAsAAAEUARUD
8AMLCglQDgw7jD4LChlQDgwrDI77AnEJcA4MGwyO_wL-DnAODAsMrgsOCwoJkA4crhsKGZAODNsK
CbDqGcDpQgolMz8gLz4KIi8fTxUQHkEKIE8fEQogHx_tCGAgbx8PIG80IgFICgByCiFfH_kJQh8O
Dx5TChAfPQDkHw8qHyAfHy8eDx8eDx5iCmA-Hw8gDyoVCjA-Hz4XAAMVAEEqTx4PLAABFQACcQoh
Tx89ChAfiAAQThcAEzBBAAIVABQ-LAATIBcAES8XADYvHw9HAFMgDl8gHxcAAAgAFE8xABAfRAAT
DxoAGC8xAAAbABEfFwAaPxcAEU-UIgIXABVOpgADSQA0Lx9PLgATHxcAdT8fPx4vHz78AAGBAHAu
TS4PHh4MJgAQUJ4CgV4MXgwODA8clgJDbgxuDLIKUBxODE4cMhthGxwuDC4c2zEfbNsxLxUfrQoB
uQoG1xUSJGYVArUKIS8kDwoDuQpUPyQPJT_9CiFPJKIKAsEKE09EABRPyQpUTyQPKi8RABOAIgAC
hBUDJgAXYCYABSoAGUAVABIvFQAXID8AABUABEMAAOsKFV8WAEIvI18k6AoDHgAFGABRDyRODyPl
CgMbAAkXAAHHEwMyAAkXABFAFwAJEwAVYEEABRMAF4BvAAMTABOgEwADDwBAwA4PJDYBEj4PACLg
DkAAEi4PACPwAa4WEx4QACIDDk0AEw4QAEMFDh8kCwAgBy8GAC8JLR0LJBUfGwsBJwsFHwtFHykP
KtUVIC8pOgsBJwtAHypvKawyAKkVIw5wNwAiXynwFUMPJw8oHAsAQAATP1IAED-TFQYbAJgvKT8q
Lyg-KS8TAAKRCwCfCwMXACJQDkEAET8XADAfKT8XAABPCyJPKccLUC8oLylPFQAbIBUAAHMAARkA
NRAOXxUAAAgAMU8oDgsCIylPaBYFGQACcwATEBsACRcAAQsCAsMAISgvCAASPxcAMUAODyYAEA_I
AAS4AAC4AwAXACo-KeIAIikfOQAjKQ9BAAYQAQETACFfJwQAFShCAaEfKW8nDyhvJx8okwYgTyhM
AEEvJ08o3BUCQAAARAARTj0CJCgPPAAQXz0CEC8mAE7wBy4dGAIP0gtD8B0YPAsMC-AEHGob8AAc
ugnADOoJoAwaHyq6GYAMGi7KCQhgDCoe2hkIUAz6BOgVwzAMahlKGUoZCDAMWgQjczoZCA0QDFre
OzAqKQgNAAD-IpMqKQgNAAxaCawKAPoBagmMCSo5CA0AC3oJbAk6ORQAEWr1InMaSQgNEAtq8yLw
Jio5CB0QC3oZKhkqSQgNMPoBSQgdMAnqWQgNUBmqaQgdYClaiQgdgAjpCB2gGKkYHcANGGkY-A8Q
aPwPH5ANAR4RP_0V8QQPEPAEHxFvDx8Q8AAfEb8PDw7A3xUgDqA2FXAfKr8PHw6ACwAwLyrPIl4Q
YAEigB8q3w8fDg1QkxUwLw6PGAAA-wohEY_SITAPDn8eABEw5xUBEAAQbxAAAKoPAEsWsg4vEQ8O
Xw8vDg0QIgAUPxAAPw81ABIAAQBWAHJPEQ8OTw8-EgAlEI8kABc-JAAJEgAlEI9qABJPfAAUEJ4A
ASQAABkTFBCgABI-JABgMK8PLw4vDAAAERNADu8PXxYAYFAfDq8PbxQAYGAvDl8PjwoAMIAN7wcA
UKAdrw4dJwVAHW8OHRsNX20u8ARuiwEgAecV0Q8V8AQfFm8UHxXwAB90SYDADxbvFA8ToKQhcB8q
vxQfE4ALADAvKs-eSSASYIgVkB8q3xQfEw8SUDcVEAQXAACLAWEWjxRPE28ZAEAwDxZ-yIpBFg8T
XxEAAA0BARMAsG8WDxNPFC8TDxIQejxxDxOPFg8TPxEAAEMBDxMACTMvFD8TAB4VEwAPJgABBHAA
My8UT4MAFBWWABE-JgAAkQEQFbYAEz8iAFEw-xQBTxkAYTAPE_8UXxUAYVAfE68UbxYAYWAvE18U
jwsAQYAPEu8JAHCgHxKvEx8SkwFvHxJvEx8SlQEpEhsTFvEC8AQfG28ZHxrwAB8bvxkPGMANFiAY
oMoVcB8qvxkfGIALAJAvKs8ZDxgPF2ChIZAfKt8ZHxgPF1B0FTEvGH8aAACYAaEbjxkPGC8bDxhv
IAAwMA8bHABRTxsPGF8RAAAZASUbjxMAUC8YDxcQJABxHxhPGx8YTxEAAFABABYWZhiPGw8YPxMA
s18ZDxivGw8YHxk-EwAeGhMADyYAARNvlAAiDxsIADMfGU_LACAabyYAQRs-GC8uAACkAQBzFgEq
ABNPJgBhMJ8ZLxg-DQAAqwFBGO8ZXxgAYVAfGK8ZbxYAYWAvGF8ZjwsAQYAPF_8JAHGgHxevGB8X
qwFfF28YHxerASkBwwtRDx-wBB8zFvAB8AAfIL8eDx3ADyDvHg8doOwVcB8qvx4fHYALAJAvKs8e
Dx0PHGBvCxAftgswHX8e7oeBUA8gnx4PHY8eAACvASEgrw8AABwAEjAcACQPIC0AACABJSCvEwBN
Lx0PHBEAAF8BATcAXi8gDx1vEwAzXx4-EwAQH3UAVU8gDx1PEwAeIBMABSYAMz8eT4MAJR9-EwAA
JgAAowEBJgAXLyYAQzCfHi8NAACjAUEd7x5fGABhUB8drx5vFgBhYC8dXx6PCwBBgA8c7wkAUaAf
HK8daBZ-Dh8cbx0fHKMBKQKtC-AKJPAEHyVvIx8k8AAfJb8jDyLADyXvIw8ioLsLcB8qvyMfIoAL
AJAvKs8jDyIPIWA8C_AfKt8jHyIPIVAPJf8jBBcAAJwBYSWPIz8ifxkAETA3FkMiLyUPEQAAGQEF
EwBxjyMvIg8hEHQWAREAEZ8RAABQAQUTAF4-Ix8iPxcAAKJhEQ8IABM-GwAQJBsAWT8lLyIfFwAB
MgAajyoAAIAAEW8TABNPkwABEwART28AACYAAKwBYySPI08iPyIAUTD-IwFPGQBhMA8i7yNfFQBh
UB8iryNvFgBhYC8iXyOPCwBBgA8h7wkAYaAfIa8iH60Lbx8hbyIfIaUBKQJfC-AKKfAEHypvKB8p
8AAfKr8oDyfADyrvKA8noG0LABIAMB8ngAsAMi8qLw4_QCcPJmDaChAfgAsgD1-zCXMmUA8qfyhP
HgAAsAGwKk8oKg5PDw4vFC4gANEwDyo_Sg4vDw5PFB4fIwBEEA8qThIAQC8nDyYQAGJaDg8PDl8Q
AABVAXUqXkouTxQuDwAz-gU-CwCEKV5PIy5PGR4QACAqTiAYVR4OXxkOIwCjTk8jDi8eDk8ZT3EA
JCk_EgAAJAAAkAGTKU4vIw5PHg4vJABhMI5PHi5PHQCBMA8nfk8eHl8YAIFQHyduLx4ObxoAUGAv
J16NCQD-DIAPJu0MHzWgHK0cG8ALHG0cK-AAC2wr8ARrkOEKcB4Z4AoyHEoc4ApzDBkMKgwZDOAK
cgw5DAoMOQzgClIMSQxJDNYKM1oMqQoAQ2oMiQzgCloMaQw6ORQAY2oMOQw5DOAKQAwZDApfAALg
Cj8cKhzgCgov_QDgCnwZEeAKIREflSAF4AoBEAAJ4AohES-tRgXgCiQRPxAABOAKCxIAAFYAEU_1
IAfgCgMkABc-JAAJEgAlEI9qAAfgCiQRHyQABOAKARIAB_AKHxHgCrcnFm-gCloWTxMPFuAKWBZv
Ew8W4AohFo-YYgjNCg8TAAUK4AoLEwAPJgABBHAACuAKAZYACuAKHxbgCr8aG_AKWBsvGA8b4Apa
G08YDxvgCgMTAAbgClobTxgfG_AKIBuPewoGEwAALCFKrxgPG_AKCxMADyYAARNvlAAiDxgIAArg
CgBFCxob4AoBKgAI4AofG_AKrBgg4AoaIOAKGCDgCjQgDx0tAATgCgMTAAbgCgcRAATNCjAgLx1R
Fw0TAArgCjEgTx2VIQQmAA4TAAUmAAS6CgLgCgMTABE-lgoC4AoBXwAI4AoDDQAP4Aq7GCXgClol
LyIPJeAKARMACOAKAREACuAKARMAXj8jHyU-FwAAMCEA4goK4AppJT8iLyUfFwABMgAajyoAAIAA
EW8TAAjgCiElT28ACOAKHyXgCv--TybKCeAKJ_oJ4Aog_gXdCjHKLErXClDaDAoMStMKQfoADErG
CiJ6jAgAIfoFtwoiWqzJCiL6ANIKEAsyABEqxgoiyizACiz6Ar0KIAm6vQovGWq9Cn80-w8EugoA
mAoTj7YKBQwAACICIRG-DgACrgoFDAAATgIBDgAAJisZb7wKEw8EAAaKCg8WAAIvEW_iKwAVLzQA
H2_hKwASH6YKRxAPEF_gKxAfNAAAugJCEP8PAscKP-8PAcQKshCvRwoExAoGDQAAAwEhFo_iKwO8
ChWPoCsFqQoZj6ArB8AKBqArB54KE4_gKzhPFD9BABivIgA2PxZvvAoAjgARbx4AFB8PAB9fuAq7
Nf8ZBLUKM-8ZBa4KFW8XKxEfHQASEMEKCLwrFk_2Cgq8Kwe_CgAbABxvEwACWgAWP5gKE69WABVv
EwAeGxMABSYAE1_QCgS2ChkZtgoy-xkCHwBRMP8ZAU8WAA_sCqEU36gKNf8eBKUKM-8eBaIKFW-S
KxEfHQAQEIkKCtIrFE_qCht-0isCGQAAUwEBGwAA0isHxQpWbx6vIC_ICkb-HgU-LgA4jyA-GwAj
BE99AEMfjx5PvgoAhQFCH-8eAhsAUTD-HgFPFgAPjgq2WH8jPyWPjgoA4CsCEQAACwElJY-iKwOO
CgARABa-cwoACAoYfw8ABucrB1QKF4-gKwQEAAYfAAU2AAIEAAc2ADaPJR_GCkH-IwM-PAoBDAAS
AhgAD3wKnhjPeAoU33QKRP8oBA9xCmOvKA8PjyhtCjBvKCpMCkEvFE4fIABwEA8qfgoOChQAUw8U
Dg1Ocgowfgou8T4BDwAAPAFmKn46Dw89DwBSvg8nfjwMACIpfu0rJD48KwB1DyMuDx4uDxIAYCl_
DyMOC4YKYg8ZDgkuTHgAMCluKxMAMCkuPDMKcRAPKa4PHl4cAEAw-gFMFABAMAzuXBAAQFAcrmwQ
AEBgLF6MCAD-C4APJuwIHzWgGKwYF8AHGGwYJ-AAB2gn8ARnXwpTQGnwBBljCgMGNvIOGMAJHKoL
CQigCQzqCQiACQz6AQkIYAkM_gMJCFAHADUPNTAHXBowK0MSEL5bEgrAWwEOAAApIAAbABAADQAU
rAsAMVoJjPBCjQAJC2oJbAlqFgARWi4gEVpUAAgiQ1MeEAkLagVcMDAIC5AAQB4wCAkIAEAOUAgJ
rgDxAR5gCAnqCQgegAgZqhkIHqA1NlEewA4YacsrH2jMAiMQbmcnA6IKEB5rJwDuCWAQHw3ADh9e
CkIQDg8NJjYwDg8NJjYCQTUAIzYCVzURUDQVIi6NbjUyDg8RrVsBzCsBEVwAfFhCEA4MnXBYEBAW
ABE8elgZAAsAM30OTAsAIA8QJ1wUjRcABAsAwgl9DiwOnQ4LChAOCWQAUwsaEA4JZABRCjALCY2R
WCAwC6GdIwsKmVgvGmCZWA8PNgEfIG8TNwEDRwoBNwEBSQpxHxLADh8Wr3iqMBKgDk8KMw4PEvE1
Hw7wNQUgMA7kFFBOfQ4PEgsAAnlZIQ8SNwExbQ5sDQABi1gQjIZZAFEkBAwAGQoLAC8PFRcAAhIJ
RAABOQED1VkAOQEjfU43AS-9AzYBVhAYNgED9AkBNgEQG-YJcR8XwA4fG68vNSEXoKE1UA4PF4AO
zQkArzQRYAoAANE0AJM1UX8ZLn0OHgkyDg8bxlokDxcZXANtAgNNAgBAAUweTB5tEgEDJVwACwAm
DxoMAAcXACMJXSZcEl04AVRdPgw_XXECAVFbADoBP30ufTsBVgIPKwKQCQ9RNRcgYA6bEwE5QAYv
XAE7AUMgnQ6dMDUC0gABBwkAqAMRDBkABQsAAnECANFfAogDBwsAAEZcHkzBAxQJCwALcQICAgQP
OQFdECI5AQNECQE5AQFGCVIfIcAOH-s0IA8hKyoBRTQAIyoCWjQRYAoAVQMODyFQCgABOAGAJX8j
Po0ODyELABFtCgEjDyGqAzYsDq01XBO9OQEETlwBJAEGTlwADwAkDyROXA_yA4cQJz4BA_8IAT4B
AfEIUB8mwA4ftAhgKQ4PJqAO9whFDg8mgFRcQQ4PJmANABJPDQAYUA0AAUcBAcs0EU-LNDAODyYR
ACAtSkFcMU8ULSMAAKw0Ez0SAAAiAAEQABBa6TQRXxAAAFwBhQ8qTUotTxRNDwAk-QcLAHYpTU8j
LU8ZGwAgPV-yWzUNXxk9ADEpPU8bXDRPGT1yACQpLRMAAIUAER8TAFA9LyMNTydcAiYAkTAPJg8p
bU8ebSEAQzAPJg4NAAD8N0MmDm0vGgDwA2APJg7tDgwfNYAMHq0eDBugHAikAGkTHm5pEw8KCV43
Kks6Cwk4GssaDAlNCvsBCg4Jggo7CRwJKwkc3ksNEAkhCjsRCS07ChIJQgpLCYwtTAoUCQkYAAkW
CYEKSwkcCQsJHB4ACxgJApwACBoJAb0ABxsJAEBMDx0JUicvD85LAiUJEz8TAAIXAAMxCQQRACsf
D95KAEQJFQ8RAA8hAAAZUCEAA1pMBR4AAUcDCUEACh1LAVRLLA8NJQABJykbDiUAAf4CBQ5MDrFL
ASUACiMABnFMB0YAGwDwAAAlAAu1AAojAC8OTyEAAQgWTAdYTAMSAARGAA8lABEFEwAQH0IqCSUA
FR-5AC8QD0UBDQELBAdMAAonAAPwTDIwDw0OAgaKTAGTSgHeFBANXUMG0kpVCw81UAuMTAAnAAHB
BRRNHwAAxwUBmkwPswpUAk81Auk1A7sKEz8TAAIXAAPHCggVAAAEAAF7TB9gGQAABbdMAOkKBF4A
DToAAcQCBR8ABLVMEx0JCwAMARENp0gSDARMAY9KEx1RTAIoABEQc0wDhkwTLaVjFC2FTAHwSBIA
NgAhDouDAQERABkMNAAfCTMAACkMHWkAAS81Fi26TCEdDjQ1ACUAArhMES2faAEjAAICAAE-SRcK
4wERPT5JJg4tDwAAeUcVPQ0AMIAKHg0AHy04SQUPbws8Fy9ZTBYvewsIFwAJJ1kAjwsXHxUADwZZ
Ah9gQgAECUoAAMULCBUAAAQAEC5lPAHbRgXbCykcDdxMIQ0c5ws3CxwNy0wAfEgBFwIZLBYAESwV
aC0MDeNMJAkAFwAB7QELFQADxUwCEwAeDRMADyYAAScsDe1MIQ0sKQIAH0kE70wBHkkEEwAI8Uwh
DRwyAgMNAAbzTBIMOAIC0QAEAgASLDwCBEUABUEAKBlgKgASLEYCAhEAEixIAh5sSAIPfAxGEC8V
AAg1WQCIDAYRAAcdTQuXDBANA00wHQ4MPkwVDaEMED2lTBMNGE0CqAwVC6gMAQVNAE4BAXRMAbAM
AQRNEB0jSxUcGk0QADlNMisOjcABADQAAKkBA7RMEgAJTQA3AgMxAAAlADF9Dks4TRIARwAzDksO
LwAQEPgBBC8AEi0BBARlTSIwCksAEy5JAADDARItEE0iHB29ASL9AbABFC0VAACsAQENAA-yAwUP
7Qw8Ez9qTBYv9QwEEwAABAAUPwENFy8VAAUZAAAQDQgVAAkdAB9QNgAAAmoABTYNBjwAQD4dDyQf
BQJDDQAPBSMOK0oFA0sNA_UFNSsOHRcAEhCiBRIrfQUWDN4BFQ0rACENHnUFBe8FAFUAASZPAb8F
EQC-BRAOKk0G5QUKOwYiCQCHAAv2BQITAAOGBiMKGQgGMw1OHSMAD-YFAQLWBQQiABZQEQASLQQC
CfYFAugHDwQCBA_zDTwCPzYCBAAfL78NABgfIAAWDwwAFh-TDQL-aQXXDQQiAAMEAAEdAAcQAAC1
NwE4DQPzDQU9agT3DTAdDykQagNvAALzHCEpHTQAAfQNBy1qBAgOUA0PKQ0MGAACDE0BHAAACwAB
NQAA7Q0CT2oFFw4Pak0EAyAABGZqCS8AAjpqASgAAjtqCDEAGT1vahM9rAAkDB02ACQvHjUAEx1H
DigMPXFqBUoOIgwNAgADGgAFlwADWQ4CFwAGXQ4C4lIjLx7jUgZnDgCvbwAwCgAYAEItHgsZMgpg
GcAJG24bSgIea0oCD3cXfAAgTRQwg02BEAkMygwKDGpaDiPqDDEOI2qMCQAh_gcIADMLSqwRAAQj
ABMLNgAjDhCCTSMeEHpND1IXngIKACkPNXBNCQ0AAR8DAQAiAbFMCQ0AAcgCIxGvkCEWjxMAE48T
AAoXAB8QFwADLxFf9yEAFl82ABNf7CEEHwAADAAVX5sADplNAkUNB5lNAA0AFQMgDQKmTQDqAg_m
TQVAHq8PHgsAgKAfDR5vDx4fpk03DR8NNkkPyRdwIJ8UBAADwgwFDQABEwFgFn8UbxZ-DwAjEA7p
LCIUDxEAAVIBJxZ-CSIHFwATXxMAAAkiFV8XACMVfwkiC0EAGN8iADU-Fq9-ABUVjgAaHw8AAI0B
MhIPFcYAAI0BJBIO0gARUAwAEQEYAEFgDxIOBwEAjQFQEh6vFB4LAHGgHxIebxQeESI_DR8SjQEP
IBhdAgoAAkQMMf8ZBTYMAHIhAmchIV8ZHQACg00CBSIEDSIBi00EGQAIDSIGpE0BGwAcbxMAAloA
D8pNBwAmAA4TAA3wTTkODxqmAAGmARIawwAAowEyFw8a3AAAowEkFw7oAAjjTSVgD9dNcIAPFx6v
GR4LAHGgHxcebxkeFSI_DR8XowEPiBhTBs1NBC5NFTBwTSEwDmEsAREiA3JNEBDcQwsRIgFyTQQZ
AAgRIhJvNAATABsAABEiFp8TAFVfHq8gXw8ARx--HgcuAD6PIG8bACAQDq0sME8gfxsAAYkBBv5N
AuNNEQMZABEw400CzgAG700AiQEP700bD9gYcDJvIz_6TRMw000AFSIjnyOUCwIoIgAVIgFYTQQR
ABLfIAARAA8AA-pNBA8AARQMCvxNAlYsGw8EAB5fNgAABAAJNgA1jyVfiwBBJP8jBa5NBgwAAJcB
MiEPJNAAAJcBJCEO3AAfUC5OBkAeryMeCwBxoB8hHm8jHh0iPg0fIZcBDzEZSTP-KAFbCzP-KANU
CwIKAAGXAXMqnygPD58oLQsUXwBOEV0gAAANCxdtAE4TbSELEm0ATgI6CgDTCgIDTgUPADStDq0M
ABQpBk4FHQAUbQhOFm0kAEMPIw0LCk4kCW17ADApXSsUACEpXYoKABEAQZ0PHp0eAAEmGSH9AxkA
MDAPJqkaUAgPNVAIBQ-xBggXYAgO7Q4IF4AIHq0eCBegGB5tHiQiH24kIlxRMCmgKZAxWBJgBgBj
CRwqGwlABgCADGoLCSAJC3qYCvYFegsJAAkMiggPNRAJDJoLCQuaCQgKAAB7CjGqC6oJABQMCQAR
C6cKQRAJ_gaICgAHABMOfwqRHkAIGeoZCB5g-1chHpB3CmoukAkbqhkpC8VwCQx6CXoJCA5gCQsJ
ADFqCQhEGZFwCEoZCA4IGTrBCv8EORgeABg5CB6gOC4gDjgewD5gPnVJH2UTjvAEDk_7CoADDg1f
Dx0PDQkAk38PDw3wAg4NjwgAAcBXADZGBMpXAOvAATwKEvBpCgEVABbgCwAR0L0KDwsACACVWBav
CwASn-cJH8A3AAQCbAA4HzXQbQAlDY_MAA4KAEIBDw0OtgD-EQIMDm8PDgwPNfACDB5fDw4M8AMc
fgzwAw81jAvwBItArEofD0UKAwCsSj8WzxRBCgIVcAoAAXlGD00KBDP-FAVKCgIKAAH5SQ8MAAUf
FRgADREwDAARA8IJBgwAAIAAMf8UAhYABAoAPw81cO0JEQ_wVCp1GU8Y8AYeH_4JIAMO7gkgDxdV
AgLeViTwAAoAAf0BIBuvCwAFCQABJwIECwAhsB4LADEfF5BSAHOvGS8aHxdg5xaojxkPGk8ZDxdA
DhIKBFkJERAMABMH-AkCCgAB9wQXGgwADxgAAiAQDp0AURoPGR59cwnwByAPFx5NDgwPGg0ODA5N
HgwfNUAcThwPACAcThQIMgtMCx0AcAtMK5BLDAoKAEIAS-ABCgAs8AcIAG9MC-AIS6BYAR1AGw8d
8ApOYPALDg3wCvxuEBwHAGEgDxwN8AkPADAN8AgQAACfCAYKADEN8AbDFQAVAAUKABANwssCHlcA
EkoCKgki8AG_FUQPHPAACgAwDdAOUDY1Dg8cCQBgDbAODyDPCgAFCQAoDaAKAB8fFAAHMLAOvwgA
Ex0IADAN0Aw4CWAMHeAcbhwZzg_dByNzNV8i8AUeHzQJABwIVPACHh8l_1URASQVBAwABX1WAQwA
A30IL-ACGAAIBAwAEQFACQYMACF-I4sJIg0wDAAQDazEIQ8lclIABityDg1wDg8kDhAAcCSfIw4d
MB4YCQMSAHQlryNeHyUfDwAyJN8jvwARPxIAIjAO9QgmDR8LAAFRBAAtKyMNHwoAEAEVAFJwDv8j
AE0xAPkIAEgPEB33CABRMZ8MHW4dLPAADG3yzSNjGU7wBw4fOAYyDvAFtl0hEA8-AhMQll020CkQ
DQCmAC8TgAkLDAsJABQAIg8TQQWlDxNgCQwqCQgADlsdIg8TJhwwDxNAXSAVCBoAARY8AIUxAbEp
VggPNQ4fTQACGgABnVVWWgkIAB4YAAKbMaAwGUoJCA0ADw0dFgARPxYA9hEdQGkIDRANAF8THxId
cFgNMFctkF1AXaBfIkBfGJAfIj4CRA0wDxi_BFIfF2APIpYBAGUtoQ0ADx0QDxgPGj97MBJAHAAS
TxwAAHI5MA8dAB8AApowEDAfAAYdAAEGUAUhAADYMEQNIA8iPwAAPgAhLx5PLwYgAABCACYkL18A
AiEAYQAPFw8YLyIAVB1ADyEvYAAUTx4AANAwUB1gLyEdNAACFgCGDQAvFx2ALQAoAHENEC3QLx0v
pS8wDfAE-y6fHfAFRh3wB02gpQlRkS9JgEmACUsJYAQAYQsMOgsJQAcAEAgHABFapAlADFoLCAcA
AacJMAsMep0JEAudCSAMihQCAZ8JJwyalwkMCAADKBQyHiAJKBQyQAkLIBQhCQsgFDIJC8oHACAM
2p0JQAsM_gDHFEALDPoCyBQBNQAmDkAIADCKCYpmFAWtCUAeYAgLtwIQCBYjcB6ACEkIHgAFAK_g
SB4gSB7ATkBOrQkkIH8QIlFhDR8RTw8NCgAbbAcAAq4JwXwNC-ABDg2MDgvwAAcAAS4JQ4wOCwoH
AFDQDg0PEQkAUsAODQmcCAAZrAcAEJwkbQEtACka0DsAA0IAAFkAEHwIAEABDg1sCAARAggAI-AD
BwATCwcAr34LCvADiwrwBIpoCR4wNI8TcVgQFQdSEA3tEhANclgAxRIwDQ7ACQAwvxQNb1gABBMQ
DTxXAAcJEQA_VwELAFICDQ8SQAsAEQRXCRYNJgkPCwA4AVgAAmYJMkAODeUJALVRFA1QCTIODc8K
AEKgDg2vCgBSwA8SDY8LAEDgDxKOglxvAYwb8AOLPlgfAEYTQQUObxoBAgD5EhENVAkQDTorMA0P
FzIBAnMSNdAODUkJDgoAIKAuCgCALxeADi3PGS1lExANBgkgAg1ICQELAFIEDQ8XIAsAEQY_CSUN
-yUJDwsAF6QQDg1-GQ4NDB58RAlBDVwOC_poEFzZGOFAC14bDQwOG14LGmBbChkAUgpbGoBaCgBC
AFrwAAoALPAHCABfSwrwCEo-CScAOwlQDvAKDg0NACAIDusOEA4IABEMEQBgBg4NDyAcs9ZBDg0L
HBMAdAQODQs8DQ4IAAECA0QLXA0OCAABIwNEC3wNDggAAHYDUgucDQ8cCACTCQqwDg0LvA4JBwBf
CqAODcwHAAUQsJkDEgmSA-8GCRrgCQ1sDgka8AEJbgka8ANpGvAFIiQfojR-IvAEDm8kDyH_UwIN
CQ8MACQBJQkAFwkTJBkJAQwAARcJEbALCQAMAADyCRMk2AgADwAXkAkJE38ZCSQPJRIAACsJANAI
Bx0JAC8JEF0SAAYgCTGvI1_lVQQQAAAgEgopCRRAFAkCSlVC7yMODUFVEc8KABGgRQAACgAiwA11
AJ8fNeANjg0c8AEAZiQBHwkRTxkJEA23JhEdGQkXDRgJGA0XCTUrCQARABEPPmpgYAkLDwwaEgko
DS8sCRMfEwkwCw8Ms3UUDRQJERWQJQEWCR8LFgkjVgwADw0cFglxHEBpCAwQDBYJtRxwWAwwVyyQ
XEBcFgmSTyQPIQwwDxhPCgkTHwgJFAwICQAWJAQKCQKxVwAeAABlCA0KCRgkHQAMCgkaDAoJER8W
FgkMCRcMDAkBRAANDAkTHAwJHQwMCVYcYC8hHBYAdwwALxccgCwMCTUMECwMCRIMDAmPHPAFRhzw
B0wMCVJwNVnwBCkcO1wd8CdMWxmwGXxrGYAJnIsJYAmsmwhQCTtsexkIDzVACWs8azkIQAmLHCs6
OQgOMAmrakkIMAmrejklYAEHAMAwCZt6KQgeMAmLiimyCAEHALBQCDkrmhkIHlAIaQ8AEmAHAP8a
cAhpehkIHnAIeVopCA6QCOkIHqAI2QgOwAi5CB7QCHkoHvAAeD7wAn44DB-ANj7wCA4-ER7wBQ5t
rwYQjdoHUC8QTS8PJAUgLxCvEYA10A4-EH8PHgcAAMsRQTWwDk8JABUNCQBhDzWQDl8QGxIFCQAA
8AwhXxAxHAUJAAAZDVBvEK8PLmQdMl8QzxQAcDAPDT4fEN8WAPEAMAxe3w8uDA81IAx_rw8_CQBB
jo8PTgkAQv4HDAsGAP8FMBz_AxwbQAssziwrcBvMO8DL8BT7AB3wH3JPE-AGHk8WHvACHm0fFA7g
Hm1MDrAeHxVtXA6AHjtdfA5gDmstrA5ADpvMDjAFAADPBDCbrC49HDGrnD7_IjCrjE62IiibnAcA
QIsefE6nIkA7blxOjSL-GK4sXgoZUBr_ABoZcAkavhopoAkafhop4AkaLiop8AMJKjnwBynwN8EA
HXBSjxjwAh5-uxHwGOAOjxs-Gg7ADo8bXxoOoA6fG28aDoAOnxsvGU8aDxdwDp8bTxk-Gu4HMWAO
j9MbER6sGyAab0BIIBouGgCSQA4vGi8brxk_DQAlXxoLAD9PGr8LAAA-PxrPCwAANS8aDgwAYh8a
Hr8ZTgwAYA8aPp8ZXgwAcFAPF05fGX5sCFBQDxf_AyoC-wcN-gENHIAN7g0coC2uDRzAHK0c8AC8
1QEf8RRsjx3wAh6PIF6QHs0-Hx5gDjydbA5AHkxtHx58DjAObD17PPVZMHzbLscaMWzrLscBMFzr
PrkBQDw_u05XjjB_qz5TjvAVfos_ChlACm6LPgoJYApuaz4KGXAKXls_ChmQCl4rTgoZoArOcmIV
ruiSIApuf3HvGi4aGfAFCSop8Agp8DbDAB0wGT8ilAMRJZQDUB7wAg6diwPxCR8kfRwO0A5MTTwO
wA5cPUwOoA5sHyMdTHjVkGxPI1wOgA5caw8AcnAPIS4sezwKACROiwkALZssCQCADhwKDzVwCk7g
AFFwCl5rTgcAIVteBwAgS14bJf8gXjteCgmQCm4bbgoJoAreChmwCr4KGdAKngoZ8AAKfgoZ8AIa
PhoZ8AQJOinwBzmEBR4wUH8mRA0QKu0h8A_tDykewA69LA6gDs08DoAOLJ1cDmAOTI1sDlAOXG1Z
23IwDnxdXB8nCgDRXyhMPycOMA5cvyhPJ5wDRB8nLM8MAFI-J88oXwsANE8nvwsANF8nrwsAMG8n
jwsAALYRUH8nXyhvFgBRQA7-JwTQW1D-JwIOH7ERgCcADh81kA7fKgD-ALAOryceHzXQrivwAKvw
M3AGURA3N2fwMx8qDBjwBBkeDA4KHBjwABkeLA4qHBiwGR5MDkocGHAZHmwOahwYQAkejA6KHAgg
CB6cDpobCBAIDAoebB4MahsJC4MP8SQIDCoeLB4KCwocKhspCwgNEAgMOi4aCxobHAs5CwgdEAgM
SgwaCxorCgxJCwgNIAgMWgwOAFFZCwgNMB0AICsaGwARHQ0AMQorKigAEEAoACEbKiYAEFAZACEL
OiUAAAwAEGwhAGBgCAw6C2ljAP8bDXAIDBoLiQsZCwgdcAgMCgupCwkLCA2ACAwLyRsIDZAI6wgd
oOgdwO3wxN0eQDgO8AsKJxIN3l4A_BITCAkAASoMgQ8qDxEPKg8PGgAKDwABNwxyDyofEQ8qHyAA
Cg8AAlsUYiovEQ8qLyAACg8AAeIYcg8qPxEPKj8gABMAIAAAeyMEJAAT0CMAIg8PpDI2Dw3QJgAY
ECoAFLAqACUQHywAFLAsAFYQHw8fECwAE5AsAEQfDy8QLAATkCwAABQAFx9YABNwLAATfygAEXDm
AGMfKo4fEB8jAAFNKFERHyrOH5AxAKQHYx8q-gEfEBUkMP8QA-EZQGD-DQMicC8D8HbkHuFULxPw
CB4fKg8WHxLwBAkAUA8qDxQfDwAAqR1RLxYPKi8PABCwa01BFg8qTw4AkXAeHypvFg8qbw4A8ARA
Dh8qjxYPKo8UHxYPEiANDyqfkOYB7COQDRANDA8qbBsPmQtgFBxqDA8VEwBQCgs8GxpNPkA6DA4J
5wvyDw0MGgsMGyoJKikKHAoMHgkNCAANDCoLOgkqKToMLg8AtBoMChwKCSopKhwOIgCxCgw6HBop
Ghw_DA4RAIIcahwZChxuDB4A-zaaLJ4MDQgQDRmKDI4ZDRggHRlqDG4ZHRhACB0ZSgxOGR0ocAgd
GSoMLhkdKLAIHRkKDA4ZHSjwAAgdKR0o8AQILSjwCCgyBh8wTf8YrmghKgGTI6Eq-xsBDyoPF2AN
3SLzESrvGw8qDg8bDVANDB8ZDyrMCx4MDQ81QA0MLxkLrAsuDQBFPxmrPgsAdAtKDxoaCQwRAGA6
CzoJGhkPABEIDgBGKgkaKQ4AVhoJGikKDwBWCgkaKRoPAEYJGikqDgA2Gik6DQA2CilKDQAmKVoM
ABOcCgBSKgmuCS4LAFIaCc4JHgsA-wkKCe4JDgwNCFANDP4BCQ0YYA35AQ0YgP0kaCTwCW0-HW8c
8AEPHS8qfyAPHOAPHQ8qHyAPKptlEh-1IkAfDxzAFwAQL6hmAhcAA1xmOg8coBkAFS8ZABCAGQAQ
PxkAAhcAAhQjEB_cRQkZABUvGQAQQBkAEU97AAFTZiEgTxcAYCAPHX8qn2VnIRwQEnEA8RliDyBf
HQ8fwGIjH08TABBPEwAUH5pmJiBvEwARQH9mAhMAEj8TABNgEwAWTxMAIYAOrQ0iIE8RUAATABOg
EwAWLxMAIsAOGQEAEwASHxMAE_ATABYPEwAAeBkjHw8UABMPFAAWAxQAARAAIgUOxiQADAAiBw4I
AI8JDh3wCw3wGs5mJFAqDyUPIU0AAAkAMSoPIw8AEAXsBEIlDyofDwAQAyMFESVdZgAPABABGgVB
JQ8qPw8AEOBaZEElDypPDgAQwPMhQSUPKl8OABOgDgAAVwACEgBzgA0PJR8qP00AYD8jLyQNcBMA
ESOJAAAVAAC0ZQC2IxEkdwMgYA0mAAAZAGQMGwwPJT4UAHM7ChsMGxwKEACACjsKCwwbHAsQABEJ
DwBGDBscGw4ANBscKw0AohscDgocKwoOHB4QAPAGHD4KKwo_LA0JcA0MXgoLCl4MDRmACwAACQDQ
oA0MTgxODA0ZwA0MPnAD0RngDQwuDC4MDRnwAQ3x50ENGfAD3_YACgCPBQ0sDRnwBy0-fCIwMs8m
TAEhvykg7AJ5IwHeBgCaIxKPOmYtKQ4RADMPNZAdZhJvYWUtKQ4RAALOBgAAZhBfsWUCwXEEOWYE
dmUDUGYEJmYyHygfLAATUCwAAhUAFD8sABMwLAATH-ZlA1JmUCkOMA5fogADFwBBLyhfKUAKADdm
Ex8TAAMqAAFFAAw3ZhEpYwoALgA2Pyk-KgARUCoAAkZmAyYAEVAmADVvKU-jAAFbACNvJ-YAHh8T
AAEtAQFNZiOPJ0ABHh8TAAF3ASIprx4AMLAOzxIAf9DOHeDN8BTEClGAk3nwBQkMSwhqCSAJCycT
AAgANAoZCgoAIAgLCwAyYNkoCABCCQz7AAkAAQMaAAgA4PkCCA4wOfgEDjAJDPsFPREQC5VQAAgA
IfkCNgBBMAn4AwkANEDuCFIAZPAECAsKGwoAEzoIABBJBwB-eA7wBX7wZssAHSBTTq8fEhESCQBm
BATpOg8MACc1PvAEFwAEWQAVAxIAAwcAPTXgThIABIgADhgAChIADxkAJy_QXhkAAiROUGoeCxkA
AwcAET-FACBADiIeDBwAAwcAA0QVEkB6AB8fJQABEB93iAcmABc-HAAoDw0SAAEhABlfHQAWXxkA
EG4QAABnEiIQbhMAr-8NBg81UP0H8CwwIx_CE-AIDi8VDxLBARMVIZYJDAAjAH4MABBedCQQbwwA
EV8yACCQDruvFA4LADMPFK4pAAQQADwOnxISACEPEkMADxgAAQBKWwYYACVQThgAQA8UPh0IAACg
hxA_iSQRPwsAABEAQx8SDxUcABA8NgABraEgDxIUOXEcHQsMTQ4LFAAgPg1pOTAOCwz4yRBOBEMi
OwwTABBbiDVDCiAqDhAAYmwNDgtKUA4AABlIEpALABOuCgAS2wcAQGwLapCpNwGjHEIMXgwNCgAS
awkAMgFaDgkAEAcV6wAHAB87NxoiQEz-GANcfEJvGg8XBgARkNAtAG4uAwcAITWALSQhPg0UADUN
Pg0VADANDh8SAAIYAAYMAAMcADQPFx8cADAcDxeuAAAaAAAIABMtJgExDgsKEQAVqwsAU1wLDxtM
DQBSXQ4LDF0LABI_OgEQXg0AFEtWAUMKkDoODAA1C1rQCwAAH_8PDAAaJNBeCwBSTpAOCUwMABxM
gwBAbgsMbgkAX-sCCpD6xQ0gMIb-HWkBAZIKAwYAACgBEh-gLQMHAAESAEEPHj4NFAABawEDFQAw
DQ4fEgACGAAGDAADHAA1DxwfHAAFDAAFHAAwLQ4MCQAQDAgAMDVgLgwAUFwLDQ580y6AGw0Oaw0O
awzkA-ADC-0DDgwKQA4L-gQMCkAe-AUKIgBQ_wIMGlAXefASDgwKYA4L-gIMCmAu-AIKcAoOCdsM
KoAOC80ODAqgDgveBgCP-AAKsPoB8EwfAR0wS58iwQU0JW8kmCQUJJgkAAwARg8jPg0OAGkNDh8h
DyQRADwPIR8RAAHvAAMOAJBcTtAOCw0OmwwrHrMLrQ4MCsAOCw2ODQkANQ5sCwsAUAwPJTsMCAAh
bmAPACELPQ4AUglLDApQEQASDQMAABsAFg4VABMbFAA2DR4NFgAlPQwyAAQVAABrABY8DwBDew0O
Sw0AIv0CCAAg-gMHAI-8BQpg_gbwSRnOHzAm4J6tcEGeUA5PJgoAzQgA8DgXJxAAAOYFAIpwFCcb
AAQOAAEZAABBbwEPCQcfAAgUAAMlADsPJx4mABkpFQAFJwAqDh8nAHwqDygfKQ4NJgARLxAAAgwA
MA0vKHjuBCAARwwPJ14GAAEWAACCOIQqDUsMDQsNSxQANAv8Ax4AUH8nDQyaCwDxAZ4NDAqeCUAO
Ww0LHQydDgkmABEKCABzDGoLDGoNDA0AIwpeBAADDwAhDj0GADYbHQ4jADEOLAoHADYLLA4pADMe
DQwWADMMCh4XADUNDD0VACMdGysAIVwKSwAiC1wjABFqIABDDWoOCaUAj1B5TpngSfAYYgo9UG09
Nn19
:: gfx/1.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA5LTEzIDEzOjUxOjM5Iixtb2RpZmllZD0iMjAyNC0w
OS0xMyAxMzo1MzoxOCIscmV2aXNpb249OV1dbHo0AG0AAAAFMQAA8xR7WzBdPXtibXA9cHh1AEMg
EBAE8PAsZmxhZ3M9MCxwYW5feAgAz3k9MCx6b29tPTh9LDEA----------------------------
------------------------------------51BtPTh9fQ==
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNS0w
OS0xNyAwNTo1NDoyMCIsc3RvcmVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Il1d
:: map/
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNC0w
OS0wMSAwNzozNDozNSIscmV2aXNpb249MzA3NV1dbHo0AMEAAABZEAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD-------_x0zIwMDAzMDAwNDAwMDYMAC81MIAAWxMxCAATNYAALzYw
AQBbFzb8ABMxDAAPAQBVBHwBAAABEzAMAA_AAVkTMXQAEzB4ABcxjAAPAAFVEzaEAAQMAC81MAEA
--------nvEJIiksaGlkZGVuPWZhbHNlLHBhbl94PTQ3CQDSeT0wLHRpbGVfaD0yOQoAEHcKAIB6
b29tPTF9fQ==
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNS0w
OS0xNyAwNTo1NDoyMCIsc3RvcmVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Il1d
:: pal/
:: pal/0.pal
b64$LS1bW3BvZCxiZ19jb2xvcj0wLGJsYWNrZXN0X2NvbG9yPTAsY3JlYXRlZD0iMjAyNC0wOC0y
MyAxODo1OTowOSIsaGlkZGVuPXtbMF09ZmFsc2UsZmFsc2UsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0
cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1
ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUs
dHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRy
dWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVl
LHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0
cnVlfSxoaWRkZW5fdG9nZ2xlcz17WzBdPXRydWUsdHJ1ZSx0cnVlLHRydWV9LGh1ZV9vZmZzZXQ9
MCxpY29uPXVzZXJkYXRhKCJ1OCIsMTYsMTYsIjAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAw
MDAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNjAxMDAwMDAwMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA2
MDYwMTAwMDAwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDYwNjA2MDEwMDAwMDAwMTA3MDcwNzA3MDcw
NzA3MDcwNjA2MDYwNjAxMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDEwNzA3
MDcwNzA3MDcwNzA3MDcwNzA3MDcwMTAwMDAwMTA3MDcwNjA2MDEwMTBkMGQwMTAxMDcwNzAxMDAw
MDAxMDcwNzA2MDYwMTAxMGQwZDAxMDEwNzA3MDEwMDAwMDEwNzA3MDEwMTA3MDcwNjA2MGQwZDA3
MDcwMTAwMDAwMTA3MDcwMTAxMDcwNzA2MDYwZDBkMDcwNzAxMDAwMDAxMDcwNzBkMGQwMTAxMGQw
ZDA2MDYwNzA3MDEwMDAwMDEwNzA3MGQwZDAxMDEwZDBkMDYwNjA3MDcwMTAwMDAwMTA3MDcwNzA3
MDcwNzA3MDcwNzA3MDcwNzAxMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDEw
MTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAwIiksbG9ja2VkPXtbMF09ZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2V9LGxvd2NvbF9pY29uPXRydWUsbW9kaWZpZWQ9IjIw
MjUtMDUtMTIgMjE6MDg6MjEiLG9rcGFsX3ZlcnNpb249IjEuMi4yIixwaWNrZXJzX21vZGU9Imxp
bmVhcl9odWUiLHJldmlzaW9uPTQ2NDAsdGVzdF9jdWJlX2NvbG9ycz17WzBdPXsxNSwzMSw0fSx7
MzEsNCwyMH0sezQsMjAsMjF9LHsxMCw5LDI1fSx7OSwyNSwyNH0sezgsMjQsMn0sezI2LDExLDI3
fSx7MTEsMjcsM30sezI3LDMsMTl9LHsyOCwxNywxOX0sezI4LDEyLDE2fSx7MTIsMTYsMX0sezYs
MjksMTN9LHsyOSwxMywxOH0sezEzLDE4LDF9LHs3LDIzLDE0fSx7MjMsMTQsMTN9LHsxNCwzMCwx
OH0sezcsNiwyMn0sezYsMjIsNX0sezIyLDUsMjF9LHsxLDEsMX0sezEsMSwxfSx7MSwxLDF9fSx0
ZXN0X21vZGU9ImN1YmVzIix0ZXN0X3JhbXBfY29sb3JzPXVzZXJkYXRhKCJ1OCIsMTAsMjcsIjAw
MTgwODE5MDkwYTFhMGIxYjAwMDYwMDAwMDAwMDAwMDAwMDAzMDAxNjAwMDAwMDAwMDAwMDAwMTMw
MDA1MDAwMDAwMDAwMDAwMDAwMTAwMGQwMDAwMDAwMDAwMDAwMDEwMDAxZDAwMDAwMDAwMDAwMDAw
MTEwMDE3MDAwMDAwMDAwMDAwMDAwYzAwMGUwMDAwMDAwMDAwMDAwMDFjMDAxZTEyMDIxNTE0MDQx
ZjBmMDcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxNDA0MWYwZjA4MTgwMjAwMDAxNTA1MTYwNjA3
MTcwZTFlMDAwMDAxMTAxMTBjMWMxZDBkMTIwMDAwMTMwMzFiMGIxYTBhMDkxOTAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCIpLHdoaXRlc3RfY29sb3I9N11dbHo0APEBAAAVAgAA
-QV1c2VyZGF0YSgiaTMyIiw2NCwiMAEA8A00YzM2NWEwMDgyM2YzODAwOTg0NzNmMDA5ZjUxCACR
NjQ0ODc3MDBmAQDwODAwNzQxZjY1MDBhODI1OTIwMGUyNDliYTAwZWY4M2M1MDBmOGJiZDkwMDc3
MmMxNjAwYTIzMjE5MDBkNTRmMjEwMGYzODI1UADwJGNiYzljMDA2NzQ5MTMwMDljNzExYTAwZDZh
MjI1MDBlZGM0NTQwMGZiZTE5OTAwMmQ1MxgA8BYzMTZlMzIwMDUwYTMyYzAwODdkNDU2MDBiZmYy
OTUwMDE2NTg1CADwDTc3OTdkMDAyMGI0YjMwMDVjZDhkMjAwYWNmNmb4ALA3MjI4NjAwNWUyNiAA
0DhkM2JlZDAwYWU4MWawAJA4YzRmYzAwNTMCAEAwMGIyAgBAMDBlMwIAQDAwZjQCAADIAAACAEAw
MDFkAgBAMDAyZQIAQDAwNDYCAEAwMDliAgBAMDBjMQIA4DAwNGY0YjNlMDA3MzZh4ADwEzllOGY3
NDAwYWE5ZDg1MDBiZWI1YTQwMDU4NTk1ZDAwNjgCAFEwMDZmNrkAETcBAFAwMDg2OK8B8QYwM2Yy
NzJhMDA1YjM3MzQwMDY2NDBgAFAwNDk0NCgAIDVjEAGANDAyYzRkIik=
:: pal/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTIzIDE4OjU0OjE5Iixtb2RpZmllZD0iMjAyNS0w
OS0xNyAwNTo1NDoyMCJdXQ==
:: sfx/
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM1Iixtb2RpZmllZD0iMjAyNS0w
NS0xMiAyMTowODoyMSIscmV2aXNpb249NDU2Nl1dbHo0ABoBAABSCAAA8CdweHUAAygAAAQABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDBAUGBwAP-5AICQoLDwwPDQ8ODw8QAPAADQ8RDxIPEw8UDxUP
Fg8XEwDxAQ8YDxkPGg8bDxwPHQ8eDx8UAPEAIA8hDyIPIw8kDyUPJg8nFADxACgPKQ8qDysPLA8t
Dy4PLxQA8QAwDzEPMg8zDzQPNQ82DzcUAP8FOA85DzoPOw88Dz0PPg8-AA--8P8BAOv-J1oBEAYP
IBABIAEgAfAAAhACDBABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDDAAAh9EMAAc
H0AwAPIf-wEA3L-4D0AADUD--7DwcAoA--9kH-8BAP_ZUP----8g
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNS0w
OS0xNyAwNTo1NDoyMCIsc3RvcmVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Il1d
:: src/
:: src/logic/
:: src/logic/creation.lua
--[[pod_format="raw",created="2024-08-30 06:25:09",modified="2025-05-12 21:08:21",revision=1779]]
--- Board Creation Logic


function logic_new_test_cells(tiling, for_editor)
	local grid
	local size
	if tiling == "square" then
		grid = sgrid_new()
		for x = 2, 9 do
			for y = 0, 7 do
				grid:set(pos(x, y), cell_good)
			end
		end
	elseif tiling == "hex" then
		grid = hgrid_new()
		for i = 0, 4 do
			for y = i, 12 - i, 2 do
				grid:set(pos(6 + i, y), cell_good)
				grid:set(pos(6 - i, y), cell_good)
			end
		end
	end
	return grid
end


------------------------------------------------------------------------


--local function random_gem()
--	if false and rnd() < 0.05 then
--		local gem = gem_rainbow + flr(rnd(6))
--		if gem == gem_robot_E then
--			gem += flr(rnd(4))
--		end
--		return gem
--	end
--	return gem_color_first + flr(rnd(gem_color_last - gem_color_first))
--end
local bag_of_gems = {}
local rejected_gems = {}


local function random_gem()
	while #bag_of_gems == 0 do
		bag_of_gems = rejected_gems
		rejected_gems = {}
		for i = gem_air, gem_night do
			add(rejected_gems, i)
		end
	end
	local idx = math.random(1, #bag_of_gems)
	local gem = bag_of_gems[idx]
	deli(bag_of_gems, idx)
	return gem
end


function logic_fill_gem_at(cells, gems, states, p)
	local cell = cells:get(p) or 0
	if (cell & cell_mask == 0) or (cell & rock_mask != 0) then
		return
	end
	local test = (gems:tiling() == "square") and logic_test_sqr_match_at or logic_test_hex_match_at
	local gem = gems:get(p)
	if not gem then
		local attempts = 0
		local found = false
		while attempts < 16 and not found do
			if gem then
				add(rejected_gems, gem)
			end
			gem = random_gem()
			gems:set(p, gem)
			found = not test(gems, p)
			attempts += 1
		end
		if attempts == 16 then
			gem = gem_gift
			gems:set(p, gem)
		end
		states:set(p, { name = "new" })
	end
end


function logic_fill_gems(cells, gems, states)
	-- TODO: transform into a coroutine
	-- TODO: fill in reverse gravity order
	cells:foreachpos(
		function(p, _)
			logic_fill_gem_at(cells, gems, states, p)
		end
	)
end

:: src/logic/matching.lua
--[[pod_format="raw",created="2024-08-24 08:12:55",modified="2025-05-12 21:08:21",revision=3075]]
--- Matching Logic

-- The matching algorithm has two phases:
--
-- 1. First, a linear sweep through all the gems, and for each gem involved in a match
--    creates a mark registering which direction(s) matched.
-- 2. Then a flood-fill algorithm is used to group matches together.


local function logic_is_matching(gem1, gem2)
	if (not gem1) or (not gem2) then
		return false
	end
	
	-- Only colored gems can match.
	if (gem1 < gem_color_first) or (gem1 > gem_color_last) then
		return false
	end
	if (gem2 < gem_color_first) or (gem2 > gem_color_last) then
		return false
	end

	return (gem1 == gem2) or (gem1 == gem_rainbow)
		or (gem2 == gem_rainbow)
end


--------------------------------------------------------------------------


local function test_3(gems, p0, p1, p2)
	local gem0 = gems:get(p0)
	local gem1 = gems:get(p1)
	local gem2 = gems:get(p2)
	return logic_is_matching(gem0, gem1)
		and logic_is_matching(gem0, gem2)
		and logic_is_matching(gem1, gem2)
end


local function test_4(gems, p0, p1, p2, p3)
	local gem0 = gems:get(p0)
	local gem1 = gems:get(p1)
	local gem2 = gems:get(p2)
	local gem3 = gems:get(p3)
	return logic_is_matching(gem0, gem1)
		and logic_is_matching(gem0, gem2)
		and logic_is_matching(gem0, gem3)
		and logic_is_matching(gem1, gem2)
		and logic_is_matching(gem1, gem3)
		and logic_is_matching(gem2, gem3)
end


function logic_test_sqr_match_at(gems, p)
	local S = p + pos(0, 1)
	local SS = p + pos(0, 2)
	local N = p + pos(0, -1)
	local NN = p + pos(0, -2)
	local E = p + pos(1, 0)
	local EE = p + pos(2, 0)
	local W = p + pos(-1, 0)
	local WW = p + pos(-2, 0)
	local SE = p + pos(1, 1)
	local SW = p + pos(-1, 1)
	local NE = p + pos(1, -1)
	local NW = p + pos(-1, -1)
	return test_3(gems, SS, S, p) or test_3(gems, S, p, N) or test_3(gems, p, N, NN)
		or test_3(gems, EE, E, p) or test_3(gems, E, p, W) or test_3(gems, p, W, WW)
		or test_4(gems, p, S, SE, E) or test_4(gems, p, S, SW, W) 
		or test_4(gems, p, N, NE, E) or test_4(gems, p, N, NW, W)
end


function logic_test_hex_match_at(gems, p)
	local S = p + pos(0, 2)
	local S_S = p + pos(0, 4)
	local N = p + pos(0, -2)
	local N_N = p + pos(0, -4)
	local SE = p + pos(1, 1)
	local SE_SE = p + pos(2, 2)
	local SW = p + pos(-1, 1)
	local SW_SW = p + pos(-2, 2)
	local NE = p + pos(1, -1)
	local NE_NE = p + pos(2, -2)
	local NW = p + pos(-1, -1)
	local NW_NW = p + pos(-2, -2)
	local E = p + pos(2, 0)
	local W = p + pos(-2, 0)
	return test_3(gems, S_S, S, p) or test_3(gems, S, p, N) or test_3(gems, p, N, N_N)
		or test_3(gems, SE_SE, SE, p) or test_3(gems, SE, p, NW) or test_3(gems, p, NW, NW_NW)
		or test_3(gems, NE_NE, NE, p) or test_3(gems, NE, p, SW) or test_3(gems, p, SW, SW_SW)
		or test_4(gems, p, SE, S, SW) or test_4(gems, p, NE, N, NW)
		or test_4(gems, p, NE, E, SE) or test_4(gems, p, NW, W, SW)
end


local function check_3_and_mark(gems, p0, p1, p2, mark, marks)
	if test_3(gems, p0, p1, p2) then
		marks:merge(p0, mark)
		marks:merge(p1, mark)
		marks:merge(p2, mark)
	end
end


local function check_4_and_mark(gems, p0, p1, p2, p3, mark, marks)
	if test_4(gems, p0, p1, p2, p3) then
		marks:merge(p0, mark)
		marks:merge(p1, mark)
		marks:merge(p2, mark)
		marks:merge(p3, mark)
	end
end


local function mark_sgrid_matches_at(gems, p0, marks)
	check_3_and_mark( gems,
		p0,
		p0 + pos(0, 1),
		p0 + pos(0, 2),
		{ name = "matching", vertical = true }, marks )
	check_3_and_mark( gems,
		p0,
		p0 + pos(1, 0),
		p0 + pos(2, 0),
		{ name = "matching", horizontal= true }, marks )
	check_4_and_mark( gems,
		p0,
		p0 + pos(1, 0),
		p0 + pos(0, 1),
		p0 + pos(1, 1),
		{ name = "matching", vertical = true, horizontal = true }, marks )
end


local function mark_hgrid_matches_at(gems, p0, marks)
	check_3_and_mark( gems,
		p0,
		p0 + pos(0, 2),
		p0 + pos(0, 4),
		{ name = "matching", vertical = true }, marks )
	check_3_and_mark( gems,
		p0,
		p0 + pos(1, 1),
		p0 + pos(2, 2),
		{ name = "matching", horizontal_SE = true }, marks )
	check_3_and_mark( gems,
		p0,
		p0 + pos(1, -1),
		p0 + pos(2, -2),
		{ name = "matching", horizontal_NE = true }, marks )
	local p1 = p0 + pos(1, 1)
	local p2 = p0 + pos(1, -1)
	local p3 = p0 + pos(2, 0)
	if test_4(gems, p0, p1, p2, p3) then
		marks:merge(p0, { name = "matching", vertical = true, horizontal_NE = true, horizontal_SE = true})
		marks:merge(p1, { name = "matching", vertical = true, horizontal_SE = true })
		marks:merge(p2, { name = "matching", vertical = true, horizontal_NE = true })
		marks:merge(p3, { name = "matching", vertical = true, horizontal_NE = true, horizontal_SE = true})
	end
end


local function mark_all_matches(gems)
	local marks = gems:new_grid()
	if gems:tiling() == "square" then
		gems:foreachpos(
			function(p, _gem)
				mark_sgrid_matches_at(gems, p, marks)
			end
		)
	elseif gems:tiling() == "hex" then
		gems:foreachpos(
			function(p, _gem)
				mark_hgrid_matches_at(gems, p, marks)
			end
		)
	end
	return marks
end


---------------------------------------------------------------------------


local function group_this_match(cells, gems, marks, p)
	-- A simple flood-fill algorithm to group all
	-- intersecting linear matches together.
	local colour = gem_rainbow
	local positions = {}
	local one_good_cell = false
	local remaining = { p }
	local rainbows = {}
	while #remaining > 0 do
		local current = deli(remaining)
		local gem = gems:get(current)
		local mark = marks:get(current)
		if mark and mark.name == "matching"
			and (not mark.counted)
			and logic_is_matching(colour, gem)
		then
			if gem == gem_rainbow then
				-- Rainbow gems can be part of multiple matches,
				-- so they need to be unflagged at the end.
				add(rainbows, current)
			else
				colour = gem
			end
			add(positions, current)
			marks:merge(current, { counted = true })
			local cell = cells:get(current)
			if cell and cell & cell_mask == cell_good then
				one_good_cell = true
			end
			local neighbours = gems:neighbours(current)
			foreach(
				neighbours,
				function(n)
					local s = marks:get(n.position)
					if not s then
						return
					end
					if s and s.name == "matching"
						and (not s.counted)
						and s[n.direction]
					then
						add(remaining, n.position)
					end
				end
			)
		end
	end
	foreach(
		rainbows,
		function(p)
			marks:merge(p, { counted = false })
		end
	)
	return { colour = colour, positions = positions, one_good_cell = one_good_cell }
end


function logic_find_matches(cells, gems)
	local marks = mark_all_matches(gems)
	local matches = {}
	marks:foreachpos(
		function(p, mark)
			if mark and mark.name == "matching"
				and (not mark.counted)
			then
				local match = group_this_match(cells, gems, marks, p)
				if match.colour == gem_rainbow then
					-- Ignore, as this is probably a stray rainbow that was unflagged
					-- at the end of `count_this_match`.
					-- TODO: an edge case is when there is a legitime match of
					-- only rainbow gems (e.g. 3 rainbows surrounded by black things).
				else
					add(matches, match)
				end
			end
		end
	)
	return matches, marks
end
:: src/logic/mechanics.lua
--[[pod_format="raw",created="2024-08-30 06:41:59",modified="2025-05-12 21:08:21",revision=1728]]
--- Core Mechanics Logic


function logic_mark_gravity(cells, gems, marks, gravity)
	local some_gems_are_falling = false
	gems:foreachpos(
		function(p, gem)
			local below = p + gravity
			local distance = 0
			local cell_below = cells:get(below) or cell_none
			while (cell_below & cell_mask != cell_none)
				and (cell_below & rock_mask == 0)
			do
				if (not gems:get(below)) then
					some_gems_are_falling = true
					distance += 1
				end
				below += gravity
				cell_below = cells:get(below) or cell_none
			end
			if distance > 0 then
				marks:set(p, { name = "falling", target = p + distance * gravity })
			end
		end
	)
	return some_gems_are_falling
end


function logic_enact_gravity(gems, marks)
	local fell_gems = {}
	marks:foreachpos(
		function(p, mark)
			if mark.name == "falling" then
				local new_p = mark.target
				add(fell_gems, { gem = gems:get(p), pos = new_p })
				gems:del(p)
				marks:del(p)
			end
		end
	)
	foreach(fell_gems,
		function(fell_gem)
			gems:set(fell_gem.pos, fell_gem.gem)
			marks:del(fell_gem.pos)
		end
	)
end


------------------------------------------------------------------------


function logic_mark_swap(gems, marks, source, target)
	local gem0 = gems:get(source)
	local gem1 = gems:get(target)
	local test = (gems:tiling() == "square") and logic_test_sqr_match_at or logic_test_hex_match_at
	gems:set(source, gem1)
	gems:set(target, gem0)
	local matched = test(gems, target) or test(gems, source)
	gems:set(source, gem0)
	gems:set(target, gem1)
	if not matched then
		return false
	end
	marks:set(source, {
		name = "swapping",
		selected = true,
		target = target,
	})
	marks:set(target, {
		name = "swapping",
		target = source,
	})
	return true
end


function logic_enact_swap(gems, marks)
	local reinsert = {}
	marks:foreachpos(
		function(p, mark)
			if mark.name == "swapping" then
				add(reinsert, { gem = gems:get(p), position = mark.target })
				gems:del(p)
				marks:del(p)
			end
		end
	)
	foreach(
		reinsert,
		function(r) gems:set(r.position, r.gem) end
	)
end


-------------------------------------------------------------------------


function logic_enact_clear(gems, marks)
	marks:foreachpos(
		function(p, mark)
			if mark.name == "matching" then
				gems:del(p)
				marks:del(p)
			end
		end
	)
end

-------------------------------------------------------------------------


function logic_mark_repair(cells, marks, matches)
	local is_something_repaired = false
	foreach(
		matches,
		function(match)
			if match.one_good_cell then
				foreach(
					match.positions,
					function(position)
						local cell = cells:get(position) or 0
						if cell & cell_mask == cell_bad then
							marks:set(position, { name = "repaired" })
							is_something_repaired = true
						end
					end
				)
			end
		end
	)
	return is_something_repaired
end


function logic_enact_repair(cells, marks)
	local to_be_unmarked = {}
	marks:foreachpos(
		function(position, mark)
			if mark.name == "repaired" then
				local cell = cells:get(position)
				cell = (cell & ~cell_mask) | cell_good
				cells:set(position, cell)
				add(to_be_unmarked, position)
			end
		end
	)
	foreach(to_be_unmarked, function(p) marks:del(p) end)
end


----------------------------------------------------------------------


function logic_mark_breakage(cells, gems, marks, matches)
	local something_broke = false
	foreach(
		matches,
		function(match)
			foreach(
				match.positions,
				function(position)
					local neighbours = cells:neighbours(position)
					foreach(
						neighbours,
						function(n)
							local cell = (cells:get(n.position) or 0) & rock_mask
							if cell >= rock_full and cell <= rock_broken then
								marks:set(n.position, { name = "broken" })
								something_broke = true
							end
							local gem = gems:get(n.position) or 0
							if #match.positions > 3 then
								if gem == gem_cat or gem == gem_bat
									or gem == gem_robot_asleep
									or gem == gem_bomb
								then
									marks:set(n.position, { name = "broken" })
									something_broke = true
								elseif gem == gem_robot then
									gems:set(n.position, gem_robot_asleep2)
								end
							elseif gem == gem_bomb then
								marks:set(n.position, { name = "broken", exploded = true })
								something_broke = true
							end
						end
					)
				end
			)
		end
	)
	return something_broke
end


function logic_enact_breakage(cells, gems, marks)
	local to_be_unmarked = {}
	marks:foreachpos(
		function(position, mark)
			if mark.name == "broken" then
				local cell = cells:get(position) or 0
				if cell & rock_mask == rock_full then
					cells:set(position, (cell & cell_mask) | rock_cracked)
				elseif cell & rock_mask == rock_cracked then
					cells:set(position, (cell & cell_mask) | rock_broken)
				elseif cell & rock_mask == rock_broken then
					cells:set(position, (cell & cell_mask))
				end
				local gem = gems:get(position) or 0
				if gem == gem_cat or gem == gem_bat
					or gem == gem_robot_asleep
					or gem == gem_bomb
				then
					gems:del(position)
				end
				if gem == gem_bomb and mark.exploded then
					local neighbours = cells:blast_radius(position)
					foreach(
						neighbours,
						function(p)
							local cell = cells:get(p)
							if cell then
								cells:set(p, cell_bad | (cell & rock_mask))
							end
						end
					)
				end
				add(to_be_unmarked, position)
			end
		end
	)
	foreach(to_be_unmarked, function(p) marks:del(p) end)
end


-----------------------------------------------------------------------


function logic_mark_move(cells, gems, marks)
	local something_moved = false
	local movers = {}
	gems:foreachpos(
		function(position, gem)
			if gem == gem_cat or gem == gem_bat or gem == gem_robot then
				add(movers, position)
			elseif gem == gem_robot_asleep2 then
				gems:set(position, gem_robot_asleep)
			elseif gem == gem_robot_asleep then
				gems:set(position, gem_robot)
			end
		end
	)
	foreach(
		movers,
		function(position)
			local neighbours = cells:neighbours(position)
			local possibilities = {}
			foreach(
				neighbours,
				function(neighbour)
					local cell = cells:get(neighbour.position) or 0
					local gem = gems:get(neighbour.position) or 0
					if (cell & rock_mask == 0)
						and (cell & cell_mask != 0)
						and (gem < gem_rainbow)
					then
						add(possibilities, neighbour.position)
					end
				end
			)
			if #possibilities > 0 then
				something_moved = true
				local target = possibilities[math.random(1, #possibilities)]
				local moving_gem = gems:get(position)
				gems:del(position)
				local target_gem = gems:get(target)
				gems:set(target, moving_gem)
				local source_gem
				logic_fill_gem_at(cells, gems, marks, position)
				source_gem = gems:get(position)
				marks:set(target, {
					name = "moving",
					source = position,
					target = target,
					moving_gem = moving_gem,
					target_gem = target_gem,
					source_gem = source_gem,
				})
				if moving_gem == gem_bat or moving_gem == gem_robot then
					local cell = cells:get(target)
					cell = cell_bad | (cell & rock_mask)
					cells:set(target, cell)
				end
			end
		end
	)
	return something_moved
end


function logic_enact_move(cells, gems, marks)
	marks:foreachpos(
		function(position, mark)
			if mark.name == "moving" then
				if mark.moving_gem == gem_robot then
				end
			end
		end
	)
	marks:foreachpos(function(p, _) marks:del(p) end)
end
:: src/logic/shuffle.lua
--[[pod_format="raw",created="2024-09-13 09:11:02",modified="2025-05-12 21:08:21",revision=593]]

:: src/logic/spells.lua
--[[pod_format="raw",created="2024-08-30 06:37:36",modified="2025-05-12 21:08:21",revision=607]]
--- Spell Logic


function logic_gain_mana(stats, matches)
	local gained = false
	foreach(
		matches,
		function(match)
			local count = #(match.positions)
			if count > 3 then
				stats.mana += 10 * (count - 3)
				gained = true
			end
			if stats.in_cascade then
				stats.mana += 5
				gained = true
			end
			stats.in_cascade = true
			if match.colour == gem_rainbow then
				foreach(
					{ gem_air, gem_fire, gem_day, gem_earth, gem_water, gem_night },
					function(g) stats.colour[g] += count end
				)
			else
				stats.colours[match.colour] += count
			end
		end
	)
	return gained
end

:: src/logic/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTMwIDA2OjI0OjM5Iixtb2RpZmllZD0iMjAyNS0w
OS0xNyAwNTo1NDoyMCJdXQ==
:: src/constants.lua
--[[pod_format="raw",created="2024-08-24 15:17:10",modified="2025-05-12 21:08:21",revision=3232]]
--- Match3 Global Constants


-- Gems and cells ------------------------------------------------------

-- Color gems
gem_air = 0x01
gem_fire = 0x02
gem_day = 0x03
gem_earth = 0x04
gem_water = 0x05
gem_night = 0x06
gem_rainbow = 0x07

gem_color_first = gem_air
gem_color_last = gem_rainbow

-- Black gems
gem_gift = 0x08
gem_bomb = 0x09
gem_cat = 0x0a
gem_bat = 0x0b
gem_robot = 0x0c
gem_robot_asleep = 0x0d
gem_robot_asleep2 = 0x0e

gem_names = {
	[gem_air] = "Air",
	[gem_fire] = "Fire",
	[gem_day] = "Day",
	[gem_earth] = "Earth",
	[gem_water] = "Water",
	[gem_night] = "Night",
	[gem_rainbow] = "Rainbow",
}


-- Cells
cell_mask = 0x03
cell_none = 0x00
cell_good = 0x01
cell_bad = 0x02

-- Rocks
rock_full = 0x10
rock_cracked = 0x20
rock_broken = 0x30
cell_door = 0x40
cell_chest_air = 0x50
cell_chest_fire = 0x60
cell_chest_day = 0x70
cell_chest_earth = 0x80
cell_chest_water = 0x90
cell_chest_night = 0xa0

rock_mask = 0xf0

:: src/gfx.lua
--[[pod_format="raw",created="2024-08-24 12:06:13",modified="2025-05-12 21:08:21",revision=5075]]
--- Graphics


local cell_width = 29
local cell_height = 29


function gfx_draw_cells(cells)
	local function draw_cell(p, cell)
		local x, y = cells:coords_cell(p)
		local sprite
		if cells:tiling() == "square" then
			if cell & cell_mask == cell_good then
				sprite = 32
				sprite += (p.x + p.y) % 2
			elseif cell & cell_mask == cell_bad then
				sprite = 34
				sprite += p.y % 2
			end
		elseif cells:tiling() == "hex" then
			if cell & cell_mask == cell_good then
				sprite = 40
				sprite += (p.y + (p.x * 3)) % 3
			elseif cell & cell_mask == cell_bad then
				sprite = 43
			end
		end
		spr(sprite, x, y)
		x, y = cells:coords_gem(p)
		if cell and cell & cell_mask == cell_bad then
			pal(53, 58)
		end
		if cell & rock_mask == 0 then
		elseif cell & rock_mask == rock_full then
			spr(48, x, y)
		elseif cell & rock_mask == rock_cracked then
			spr(49, x, y)
		elseif cell & rock_mask == rock_broken then
			spr(50, x, y)
		elseif cell & rock_mask == cell_door then
			spr(51, x, y)
		elseif cell & rock_mask == cell_chest_air then
			spr(52, x, y)
		elseif cell & rock_mask == cell_chest_fire then
			spr(53, x, y)
		elseif cell & rock_mask == cell_chest_day then
			spr(54, x, y)
		elseif cell & rock_mask == cell_chest_earth then
			spr(55, x, y)
		elseif cell & rock_mask == cell_chest_water then
			spr(56, x, y)
		elseif cell & rock_mask == cell_chest_night then
			spr(57, x, y)
		end	
		pal(53, 53)
	end
	cells:foreachpos(draw_cell)
	-- TODO: move border construction out of the hot loop
	local function draw_borders(p, cell)
		local x, y = cells:coords_cell(p)
		if cells:tiling() == "square" then
			local cell_S = cells:get(p + pos(0, 1))
			local cell_W = cells:get(p + pos(-1, 0))
			local cell_E = cells:get(p + pos(1, 0))
			local cell_N = cells:get(p + pos(0, -1))
			if cell & cell_good != 0 then
				if not cell_S or cell_S & cell_good == 0 then
					line(x, y + 28, x + 28, y + 28, 53)
				end
				if not cell_E or cell_E & cell_good == 0 then
					line(x + 28, y, x + 28, y + 28, 53)
				end
				if not cell_N or cell_N & cell_good == 0 then
					line(x, y, x + 28, y, 57)
				end
				if not cell_W or cell_W & cell_good == 0 then
					line(x, y, x, y + 28, 57)
				end
			elseif cell & cell_bad != 0 then
				if cell_N and cell_N & cell_good != 0 then
					line(x, y, x + 28, y, 58)
				end
				if cell_W and cell_W & cell_good != 0 then
					line(x, y, x, y + 28, 58)
				end
			end
		end
	end
	cells:foreachpos(draw_borders)
end


-----------------------------------------------------------------------


local sprites_color_gem = {
	[gem_air] = 1,
	[gem_fire] = 2,
	[gem_day] = 3,
	[gem_earth] = 4,
	[gem_water] = 5,
	[gem_night] = 6,
	[gem_rainbow] = 7,
}


local sprites_other_gem = {
	[gem_gift] = 8,
	[gem_bomb] = 9,
	[gem_cat] = 10,
	[gem_bat] = 11,
	[gem_robot] = 12,
	[gem_robot_asleep] = 13,
	[gem_robot_asleep2] = 13,
}

--color_gem_skin = math.random(0, 14)
color_gem_skin = 0
local function gem_sprite(gem)
	local base = 128 + color_gem_skin * 8
	if gem >= gem_air and gem <= gem_rainbow then
		return sprites_color_gem[gem] - 1 + base
	else
		return sprites_other_gem[gem]
	end
end


local function scaled_gem(sprite, x, y, size)
	local w, h = flr(29 * size + 0.5) // 2 * 2 + 1, flr(29 * size + 0.5) // 2 * 2 + 1
	local x, y = x + ((29 - w) / 2), y + ((29 - h) / 2)
	sspr(sprite, 0, 0, 29, 29, x, y, w, h)
end


local function draw_exploded_gem(gem, x, y, clock, new_clock)
	local size = 32 * new_clock
	local colour = 10 + (gem - 1) * 5
	oval(x - size, y - size, x + 29 + size, y + 29 + size, colour + 1)
	if clock < 0.25 then
		ovalfill(x + 2, y + 2, x + 25, y + 25, 7)
	elseif clock < 0.50 then
		ovalfill(x + 2, y + 2, x + 25, y + 25, colour + 2)
	elseif clock < 0.75 then
		ovalfill(x + 1, y + 1, x + 27, y + 27, colour + 1)
	elseif clock < 1.0 then
		ovalfill(x, y, x + 29, y + 29, colour)
	end
end


function gfx_draw_gems(cells, gems, states, clock)
	local function draw_gem(p, gem)
		local x, y = gems:coords_gem(p)
		local sprite = gem_sprite(gem)
		local cell = cells:get(p)
		if cell and cell & cell_mask == cell_bad then
			pal(53, 58)
		end
		local state = states:get(p)
		if not state or state.name == "broken" then
			spr(sprite, x, y)
		elseif state.name == "new" then
			scaled_gem(sprite, x, y, clock)
		elseif state.name == "matching" then
		elseif state.name == "falling" or state.name == "swapping"
		then
			local dest_x, dest_y = gems:coords_gem(state.target)
			local ix, iy = x + clock * (dest_x - x), y + clock * (dest_y - y)
			spr(sprite, ix, iy)
		elseif state.name == "moving" then
			x, y = gems:coords_gem(state.source, gem)
			local dest_x, dest_y = gems:coords_gem(state.target)
			scaled_gem(gem_sprite(state.target_gem), dest_x, dest_y, 1.0)
		end
		pal(53, 53)	
	end
	gems:foreachpos(draw_gem)
	local new_clock = clock * clock * clock * clock
	gems:foreachpos(
		function(p, gem)
			local x, y = gems:coords_gem(p)
			local sprite = gem_sprite(gem)
			local cell = cells:get(p)
			if cell and cell & cell_mask == cell_bad then
				pal(53, 58)
			end
			local state = states:get(p)
			if state and state.name == "matching" then
				draw_exploded_gem(gem, x, y, clock, new_clock)
			elseif state and state.name == "moving" then
				x, y = gems:coords_gem(state.source, gem)
				local dest_x, dest_y = gems:coords_gem(state.target)
				local ix, iy = x + clock * (dest_x - x), y + clock * (dest_y - y)
				spr(gem_sprite(state.moving_gem), ix, iy)
			end
		end
	)
end


-----------------------------------------------------------------------


function gfx_draw_turns(ox, oy, turn, anim_turn)
	spr(64, ox, oy)
	local hundreds = (turn // 100) % 10
	local tens = (turn // 10) % 10
	local ones = turn % 10
	local anim = anim_turn // 2
	pal(7, 1)
	clip(ox + 7, oy + 3, ox + 7 + 3 * 8, oy + 3 + 8)
	-- hundreds
	if anim == 0 or (turn % 100) > 0 then
		spr(65 + hundreds, ox + 7, oy + 6)
	else
		spr(65 + hundreds, ox + 7, oy + 6 + anim)
		spr(65 + ((hundreds - 1) % 10), ox + 7, oy + 6 + anim - 10)
	end
	-- tens
	if anim == 0 or ones > 0 then
		spr(65 + tens, ox + 7 + 8, oy + 6)
	else
		spr(65 + tens, ox + 7 + 8, oy + 6 + anim)
		spr(65 + ((tens - 1) % 10), ox + 7 + 8, oy + 6 + anim - 10)
	end
	-- ones
	spr(65 + ones, ox + 7 + 2 * 8, oy + 6 + anim)
	spr(65 + ((ones - 1) % 10), ox + 7 + 2 * 8, oy + 6 + anim - 10)
	clip()
	pal(7, 7)
end


function gfx_draw_mana(ox, oy, mana, zoomed)
	local base_char
	local char_width
	if zoomed then
		base_char = 85
		char_width = 11
		oy -= 3
	else
		base_char = 75
		char_width = 8
	end
	local thousands = (mana // 1000) % 10
	local hundreds = (mana // 100) % 10
	local tens = (mana // 10) % 10
	local ones = mana % 10
	local digits = 4
	if mana < 10 then
		digits = 1
	elseif mana < 100 then
		digits = 2
	elseif mana < 1000 then
		digits = 3
	else
		digits = 4
	end
	ox -= (digits * char_width) // 2
	if mana >= 1000 then
		spr(base_char + thousands, ox, oy)
		ox += char_width
	end
	if mana >= 100 then
		spr(base_char + hundreds, ox, oy)
		ox += char_width
	end
	if mana >= 10 then
		spr(base_char + tens, ox, oy)
		ox += char_width
	end
	spr(base_char + ones, ox, oy)
end


function gfx_draw_mana_bar(ox, oy, mana)
	spr(95, ox, oy)
	if mana == 0 then
		return
	end
	local size = min(91, flr(0.5 + 91*(mana / 250)))
	rectfill(ox+1, oy+2, ox+1+size, oy+5, 40)
	line(ox+1+size, oy+2, ox+1+size, oy+5, 39)
	line(ox+1, oy+2, ox+1, oy+5, 41)
	if size > 1 then
		line(ox+2, oy+1, ox+1+size-1, oy+1, 41)
		line(ox+2, oy+6, ox+1+size-1, oy+6, 39)
	end
end
:: src/hgrid.lua
--[[pod_format="raw",created="2024-08-25 08:16:09",modified="2025-05-12 21:08:21",revision=2790]]
--- Hex Grids

--- Hex grids use the "double height" coordinate system:
---
---     (0,0)         (2,0)         (4,0)
---            (1,1)         (3,1)
---     (0,2)         (2,2)         (4,2)
---            (1,3)         (3,3)
---     (0,4)         (2,4)         (4,4)
---
--- The origin of the grid, `pos(0, 0)`, is at the top left.


-- Local Constants --------------------------------------------------------


local max_width <const> = 13
local max_height <const> = 8


-- Constructors -----------------------------------------------------------


local metatable = {}


function hgrid_new()
	local grid = {}
	metatable.default_origin(grid)
	setmetatable(grid, { __index = metatable })
	for i = 0, max_width * max_height do
		grid[i] = false
	end
	return grid
end


function metatable:new_grid()
	return hgrid_new()
end


function metatable:clone()
	local grid = self:new_grid()
	grid.origin = self.origin
	self:foreachpos(function(p, item) grid:set(p, item) end)
	return grid
end


-- Indexing ------------------------------------------------------------


function metatable:tiling()
	return "hex"
end


function metatable:get(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	return self[p.x + ((p.y // 2) * max_width)]
end


function metatable:set(p, value)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	self[p.x + ((p.y // 2) * max_width)] = value
end


function metatable:merge(p, state)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	local index = p.x + ((p.y // 2) * max_width)
	if not self[index] then
		self[index] = {}
	end
	for k, v in pairs(state) do
		self[index][k] = v
	end
end


function metatable:del(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	self[p.x + ((p.y // 2) * max_width)] = false
end


-- Screen Coordinates ---------------------------------------------------------


function metatable:default_origin()
	self.origin = { x = 116, y = 7 }
end


function metatable:compute_origin()
	local min_p = pos(max_width, max_height)
	local max_p = pos(0, 0)
	self:foreachpos(
		function(position, cell)
			if not cell or cell == 0 then
				return
			end
			if position.x < min_p.x then min_p.x = position.x end
			if position.y < min_p.y then min_p.y = position.y end
			if position.x > max_p.x then max_p.x = position.x end
			if position.y > max_p.y then max_p.y = position.y end
		end
	)
	local width = 1 + max_p.x - min_p.x
	local height = 1 + max_p.y - min_p.y
	self.origin = {
		x = 110 + ((480 - 110) // 2) - ((width * 27) // 2) - (min_p.x * 27) - 4,
		y = (270 // 2) - ((height * 16) // 2) - (min_p.y * 16) - 8,
	}
end


function metatable:coords_origin()
	return self.origin.x, self.origin.y
end


function metatable:coords_cell(p)
	local ox, oy = self:coords_origin()
	return ox + p.x * 27, oy + p.y * 16
end


function metatable:coords_gem(p)
	local ox, oy = self:coords_origin()
	return ox + (p.x * 27) + 3, oy + (p.y * 16) + 1
end


function metatable:pos(x, y)
	local ox, oy = self:coords_origin()
	x -= ox
	y -= oy + 1
	local px, py = x // 27, y // 16
	local dx, dy = x - (px * 27), y - (py * 16)
	if dx < 8 then
		if (px + py) % 2 == 0 and dy < 14 + (-2 * dx) then
			px -= 1
			py -= 1
		elseif (px + py) % 2 != 0 and dy > -1 + (2 * dx) then
			px -= 1
		end
	end
	py = (2 * ((py - (px % 2)) // 2)) + (px % 2)
	return pos(px, py)
end


function metatable:distance(p0, p1)
	-- TODO: is this correct?
	return (abs(p0.x - p1.x) + abs(p0.y - p1.y)) // 2
end


-- Iterating ----------------------------------------------------------


function metatable:foreachpos(func)
	for x = 0, max_width do
		for y = x % 2, max_height * 2 - 1, 2 do
			local p = pos(x, y)
			local item = self:get(p)
			if item then
				func(p, item)
			end
		end
	end
end	


function metatable:neighbours(p)
	return {
		{ position = p + pos(1, 1), direction = "horizontal_SE" },
		{ position = p + pos(0, 2), direction = "vertical" },
		{ position = p + pos(-1, 1), direction = "horizontal_NE" },
		{ position = p + pos(-1, -1), direction = "horizontal_SE" },
		{ position = p + pos(0, -2), direction = "vertical" },
		{ position = p + pos(1, -1), direction = "horizontal_NE" },
	}
end


function metatable:blast_radius(p)
	return {
		p + pos(0, 0),
		p + pos(0, -2),
		p + pos(1, -1),
		p + pos(1, 1),
		p + pos(0, 2),
		p + pos(-1, 1),
		p + pos(-1, -1),
	}
end

:: src/in_editor.lua
--[[pod_format="raw",created="2024-08-30 08:13:35",modified="2025-05-12 21:08:21",revision=1025]]
in_editor = {}

local tiling = "square"

local cells = false
local gems = false
local marks = false

local active_tool = 0
local ox, oy = 8, 8
local sx, sy = 32, 32

local tools = {
	[0] = cell_none,
	cell_good,
	cell_bad,
	rock_full,
	rock_cracked,
	rock_broken,
	cell_chest_air,
	cell_chest_fire,
	cell_chest_day,
	cell_chest_earth,
	cell_chest_water,
	cell_chest_night,
	cell_door,
	false,
	false,
	gem_gift,
	gem_bomb,
	false,
	gem_cat,
	gem_bat,
	gem_robot,
	false,
	false,
}



function in_editor:enter()
	if not cells then
		cells = logic_new_test_cells(tiling, true)
		gems = cells:new_grid()
	end
	cells:default_origin()
	gems:default_origin()
	marks = cells:new_grid()
end


function in_editor:exit()
end


function in_editor:update()
	if keyp("s") then
		tiling = "square"
		cells = false
		in_editor:enter()
	end
	if keyp("h") then
		tiling = "hex"
		cells = false
		in_editor:enter()
	end
	local mx, my, mb, _, _ = mouse()
	if mb == 0x1 and mx < 110 then
		mx -= ox
		my -= oy
		local x, y = clamp(mx // sx, 0, 2), clamp(my // sy, 0, 7)
		active_tool = clamp(x + 3 * y, 0, 22)
	elseif mb == 0x1 then
		local mp = cells:pos(mx, my)
		local tool = tools[active_tool]
		if tool == cell_none then
			local cell = cells:get(mp) or cell_none
			cell = (cell & ~cell_mask) | tool
			cells:set(mp, cell)
			gems:del(mp)
		elseif tool == cell_good or tool == cell_bad then
			local cell = cells:get(mp) or cell_none
			cell = (cell & ~cell_mask) | tool
			cells:set(mp, cell)
		elseif active_tool <= 12 then 
			local cell = cells:get(mp) or cell_none
			cell = (cell & cell_mask) | tool
			cells:set(mp, cell)
			gems:del(mp)
		elseif cells:get(mp) and cells:get(mp) & cell_mask != 0 then
			gems:set(mp, tool)
			local cell = cells:get(mp) or cell_none
			cell = (cell & cell_mask)
			cells:set(mp, cell)
		end
	end
	if mb == 0x2 then
		local mp = cells:pos(mx, my)
		local cell = cells:get(mp) or cell_none
		cell = (cell & cell_mask)
		cells:set(mp, cell)
		gems:del(mp)
	end
	if keyp("g") then
		in_game:load_from_editor(tiling, cells, gems)
		return in_game
	end
	return false
end


function in_editor:draw()
	cls(63)
	if not cells then
		return
	end
	local mx, _, _, _, _ = mouse()
	if mx <= 110 then
		window { cursor = "pointer" }
	else
		window { cursor = "crosshair" }
	end
	gfx_draw_cells(cells)
	gfx_draw_gems(cells, gems, marks, 0.0)
	-- Draw the panel
	rectfill(0, 0, 110, 269, 55)
	rectfill(ox, oy, ox + 28, oy + 28, 63)
	spr(33, ox + 1 * sx, oy + 0 * sy)
	spr(34, ox + 2 * sx, oy + 0 * sy)
	spr(48, ox + 0 * sx, oy + 1 * sy)
	spr(49, ox + 1 * sx, oy + 1 * sy)
	spr(50, ox + 2 * sx, oy + 1 * sy)
	spr(52, ox + 0 * sx, oy + 2 * sy)
	spr(53, ox + 1 * sx, oy + 2 * sy)
	spr(54, ox + 2 * sx, oy + 2 * sy)
	spr(55, ox + 0 * sx, oy + 3 * sy)
	spr(56, ox + 1 * sx, oy + 3 * sy)
	spr(57, ox + 2 * sx, oy + 3 * sy)
	spr(51, ox + 0 * sx, oy + 4 * sy)

	spr(8, ox + 0 * sx, oy + 5 * sy)
	spr(9, ox + 1 * sx, oy + 5 * sy)
--	spr(11, ox + 2 * sx, oy + 5 * sy)
	spr(10, ox + 0 * sx, oy + 6 * sy)
	spr(11, ox + 1 * sx, oy + 6 * sy)
	spr(12, ox + 2 * sx, oy + 6 * sy)
--	spr(14, ox + 0 * sx, oy + 7 * sy)
--	spr(15, ox + 1 * sx, oy + 7 * sy)

	local x, y = active_tool % 3, active_tool // 3
	rect(ox + x * sx - 1, oy + y * sy - 1, ox + x * sx + 29, oy + y * sy + 29, 7)
end
:: src/in_game.lua
--[[pod_format="raw",created="2024-08-27 17:11:11",modified="2025-05-12 21:08:21",revision=4288]]
in_game = {}


-- The Board
local tiling = "square"
local gravity = pos(0, 1)

local cells = false
local gems = false
local marks = false

local matches = {}

local prev_cells = false
local prev_gems = false
local prev_stats = false

-- State Machine
local editor_requested = false
local substate = false
local clock = 0.0
local interaction = false

local starting_stats = {
	turn = 0,
	mana = 0,
	colours = {
		[gem_air] = 0,
		[gem_fire] = 0,
		[gem_day] = 0,
		[gem_earth] = 0,
		[gem_water] = 0,
		[gem_night] = 0,
	},
	in_cascade = false,
}
local stats = deep_copy(starting_stats)
local anim_turn = 0
local displayed_mana = 0
local star_seed = 37


-----------------------------------------------------------------------


-- Functions for substate need to be global, because of Lua
-- forward-declaration rule for locals.


function creating_the_board()
--	cells = logic_new_test_cells(tiling)
--	gems = cells:new_grid()
	cells:compute_origin()
	gems.origin = cells.origin
	marks = cells:new_grid()
	matches = {}
	stats = deep_copy(starting_stats)
	anim_turn = 0
	displayed_mana = 0
	star_seed = math.random(37, 6584587)
	return creating_missing_gems
end


function creating_missing_gems()
	if clock == 0.0 then
		logic_fill_gems(cells, gems, marks)
	end
	clock += 1.0 / 8.0
	if clock < 1.0 then
		return creating_missing_gems
	end
	-- Clean-up
	marks:foreachpos(
		function(p, mark)
			if mark.name == "new" then
				marks:del(p)
			end
		end
	)
	return moving_things
end


function moving_things()
	if clock == 0.0 and stats.turn > 0 then
		local something_moved = logic_mark_move(cells, gems, marks)
		if not something_moved then
			return starting_new_turn
		end
	end
	clock += 1.0 / 16.0
	if clock < 1.0 then
		return moving_things
	end
	logic_enact_move(cells, gems, marks)
	return starting_new_turn
end


function starting_new_turn()
	stats.turn += 1
	anim_turn = 20
	stats.in_cascade = false
	return waiting_for_input
end


function waiting_for_input()
	local mx, my, mb, _, _ = mouse()
	if mb == 0x1 then
		local mp = cells:pos(mx, my)
		if gems:get(mp) then
			interaction = { name = "swap", position = mp, start = t() }
			return waiting_for_swap
		end
	end
	if keyp("del") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:set(p, gem_gift)
		marks = cells:new_grid()
		matches = {}
	end
	if keyp("w") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:set(p, gem_rainbow)
		marks:set(p, { name = "new" })
		matches = {}
		return checking_matches
	end
	if keyp("r") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		cells:set(p, (cells:get(p) or 0) | rock_full)
		gems:del(p)
		matches = {}
		return checking_matches
	end
	if keyp("a") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:set(p, gem_air)
		marks:set(p, { name = "new" })
		matches = {}
		return checking_matches
	end
	if keyp("m") then
		return checking_matches
	end
	if keyp("e") then
		editor_requested = true
		return creating_the_board
	end
	if keyp("z") then
		cells = prev_cells:clone()
		gems = prev_gems:clone()
		marks = cells:new_grid()
		stats = deep_copy(prev_stats)
	end
	if keyp("1") then color_gem_skin = 0 end
	if keyp("2") then color_gem_skin = 1 end
	if keyp("3") then color_gem_skin = 2 end
	if keyp("4") then
		color_gem_skin = (color_gem_skin - 1) % 16
	end
	if keyp("5") then color_gem_skin = 0 end
	if keyp("6") then
		color_gem_skin = (color_gem_skin + 1) % 16
	end
	if keyp("7") then color_gem_skin = 2 end
	if keyp("8") then
		local prev = color_gem_skin
		while prev == color_gem_skin do
			color_gem_skin = math.random(0, 14)
		end
	end
	if keyp("9") then color_gem_skin = 15 end
	return waiting_for_input
end


function waiting_for_swap()
	local mx, my, mb, _, _ = mouse()
	if mb != 0x1 then
		interaction = false
		return waiting_for_input
	end
	local mp = cells:pos(mx, my)
	if cells:distance(mp, interaction.position) != 1
		or (not gems:get(mp))
	then
		return waiting_for_swap
	end
	local success = logic_mark_swap(gems, marks, interaction.position, mp)
	interaction = false
	if not success then
		return waiting_for_input
	end
	prev_cells = cells:clone()
	prev_gems = gems:clone()
	prev_stats = deep_copy(stats)
	return swapping_two_gems
end


function swapping_two_gems()
	clock += 1.0 / 8.0
	if clock < 1.0 then
		return swapping_two_gems
	end
	logic_enact_swap(gems, marks)
	return checking_matches
end


function checking_matches()
	matches, marks = logic_find_matches(cells, gems)
	if #matches > 0 then
		local _ = logic_gain_mana(stats, matches)
		return clearing_gems
	end
	return creating_missing_gems
end


function clearing_gems()
	clock += 1.0 / 16.0
	if clock < 1.0 then
		return clearing_gems
	end
	logic_enact_clear(gems, marks)
	return repairing_cells
end


local repairing_done = false
function repairing_cells()
	if clock == 0.0 then
		local is_something_repaired = logic_mark_repair(cells, marks, matches)
		if not is_something_repaired then
			return breaking_things
		end
	end
	clock += 1.0 / 16.0
	if clock < 0.5 then
		repairing_done = false
		return repairing_cells
	elseif not repairing_done then
		logic_enact_repair(cells, marks)
		repairing_done = true
		return repairing_cells
	elseif clock < 1.0 then
		return repairing_cells
	end
	return breaking_things
end


local breaking_done = false
function breaking_things()
	if clock == 0.0 then
		local something_broke = logic_mark_breakage(cells, gems, marks, matches)
		if not something_broke then
			return applying_gravity
		end
		breaking_done = false
	end
	clock += 1.0 / 32.0
	if clock < 0.5 then
		return breaking_things
	elseif not breaking_done then
		logic_enact_breakage(cells, gems, marks)
		breaking_done = true
		return breaking_things
	elseif clock < 1.0 then
		return breaking_things
	end
	return applying_gravity
end


function applying_gravity()
	if clock == 0.0 then
		local some_gems_are_falling = logic_mark_gravity(cells, gems, marks, gravity)
		if not some_gems_are_falling then
			return creating_missing_gems
		end
	end
	clock += 1.0 / 8.0
	if clock < 1.0 then
		return applying_gravity
	end
	logic_enact_gravity(gems, marks)
	return checking_matches
end


-----------------------------------------------------------------------


function in_game:load_from_editor(ed_tiling, ed_cells, ed_gems)
	tiling = ed_tiling
	if tiling == "square" then
		gravity = pos(0, 1)
	else
		gravity = pos(0, 2)
	end
	cells = ed_cells:clone()
	gems = ed_gems:clone()
	marks = cells:new_grid()
	matches = {}
	stats = deep_copy(starting_stats)
	substate = creating_the_board
end


-----------------------------------------------------------------------


function in_game:enter()
	editor_requested = false
	if not substate then
		substate = creating_the_board
	end
end


function in_game:exit()
end


function in_game:update()
	local next = substate()
	if next != substate then
		clock = 0.0
		substate = next
	end
	if anim_turn > 0 then
		anim_turn -= 1
	end
	if displayed_mana < stats.mana then
		displayed_mana += 0.50
	elseif displayed_mana >= stats.mana then
		displayed_mana = stats.mana
	end
	if editor_requested then
		return in_editor
	end
	return false
end


function in_game:draw()
	if not cells then
		return
	end
	-- Starry background
	local hash = star_seed
	for x = 0, 9 do
		for y = 0, 6 do
			hash = hash~(hash << 13); hash = hash~(hash >> 17); hash = hash~(hash << 5)
			local flipped = (x+y)%2 == 0
			spr(120 + (hash%8), 110 + x * 40, 0 + y * 40, flipped, flipped)
		end
	end
	-- Draw the board
	gfx_draw_cells(cells)
	gfx_draw_gems(cells, gems, marks, clock)
	-- Draw the panel
	rectfill(0, 0, 110, 269, 60)
	line(0, 0, 110, 0, 62)
	line(0, 50, 110, 50, 62)
	line(0, 0, 0, 269, 62)
	line(110, 0, 110, 269, 58)
	line(0, 49, 110, 49, 58)
	line(0, 269, 110, 269, 58)
	-- Top bar
	spr(102, 6, 10)
	spr(98, 14, 5)
	gfx_draw_turns(37, 2, stats.turn, anim_turn)
	spr(100, 79, 5)
	spr(102, 101, 10)
	-- Mana
	spr(104, 16, 56)
	gfx_draw_mana(56, 56, flr(displayed_mana), displayed_mana < stats.mana)
	spr(105, 71, 56)
	gfx_draw_mana_bar(8, 71, flr(displayed_mana))
	for i = 0, 5 do
		spr(96, 4, 84 + i * 30)
	end
	cursor(11, 95, 58)
	print("Change Gravity")
	cursor(10, 94, 22)
	print("Change Gravity")
	--[[
	print("")
	print("Air: " .. tostr(stats.colours[gem_air]))
	print("Fire: " .. tostr(stats.colours[gem_fire]))
	print("Day: " .. tostr(stats.colours[gem_day]))
	print("Earth: " .. tostr(stats.colours[gem_earth]))
	print("Water: " .. tostr(stats.colours[gem_water]))
	print("Night: " .. tostr(stats.colours[gem_night]))
	]]--
	-- Update the cursor
	local mx, my = mouse()
	local cursor_pos = cells:pos(mx, my)
	local cell = cells:get(cursor_pos)
	if cell and cell != 0 then
		window { cursor = "grab" }
	else
		window { cursor = "" }
	end
	if false then
		rectfill(mx + 4 - 10, my + 10, mx + 36, my + 20, 7)
		print(tostr(cursor_pos.x)..","..tostr(cursor_pos.y), mx + 6 - 10, my + 12, 0)
	end
end
:: src/sgrid.lua
--[[pod_format="raw",created="2024-08-24 07:17:45",modified="2025-05-12 21:08:21",revision=3409]]
--- Square Grids

--- The origin of the grid, `pos(0, 0)`, is at the top left.


-- Local Constants --------------------------------------------------------


local max_width <const> = 12
local max_height <const> = 9


-- Constructors -----------------------------------------------------------


local metatable = {}


function metatable:new_grid()
	return sgrid_new()
end


function sgrid_new()
	local grid = {}
	metatable.default_origin(grid)
	setmetatable(grid, { __index = metatable })
	for i = 0, max_width * max_height do
		grid[i] = false
	end
	return grid
end


function metatable:clone()
	local grid = self:new_grid()
	grid.origin = self.origin
	self:foreachpos(function(p, item) grid:set(p, item) end)
	return grid
end


-- Indexing --------------------------------------------------------------------


function metatable:tiling()
	return "square"
end


function metatable:get(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	return self[p.x + (p.y * max_width)]
end


function metatable:set(p, value)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	self[p.x + (p.y * max_width)] = value
end


function metatable:merge(p, state)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	local index = p.x + (p.y * max_width)
	if not self[index] then
		self[index] = {}
	end
	for k, v in pairs(state) do
		self[index][k] = v
	end
end


function metatable:del(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	self[p.x + (p.y * max_width)] = false
end


function metatable:distance(p0, p1)
	return abs(p0.x - p1.x) + abs(p0.y - p1.y)
end


-- Screen Coordinates ---------------------------------------------------------


function metatable:default_origin()
	self.origin = { x = 121, y = 4 }
end


function metatable:compute_origin()
	local min_p = pos(max_width, max_height)
	local max_p = pos(0, 0)
	self:foreachpos(
		function(position, cell)
			if not cell or cell == 0 then
				return
			end
			if position.x < min_p.x then min_p.x = position.x end
			if position.y < min_p.y then min_p.y = position.y end
			if position.x > max_p.x then max_p.x = position.x end
			if position.y > max_p.y then max_p.y = position.y end
		end
	)
	local width = 1 + max_p.x - min_p.x
	local height = 1 + max_p.y - min_p.y
	self.origin = {
		x = 110 + ((480 - 110) // 2) - ((width * 29) // 2) - (min_p.x * 29),
		y = (270 // 2) - ((height * 29) // 2) - (min_p.y * 29),
	}
end


function metatable:coords_origin()
	return self.origin.x, self.origin.y
end


function metatable:coords_cell(p)
	local ox, oy = self:coords_origin()
	return ox + p.x * 29, oy + p.y * 29
end


function metatable:coords_gem(p)
	local ox, oy = self:coords_origin()
	return ox + p.x * 29, oy + p.y * 29
end


function metatable:pos(x, y)
	local ox, oy = self:coords_origin()
	return pos((x - ox) // 29, (y - oy) // 29)
end


-- Iterating -------------------------------------------------------


function metatable:foreachpos(func)
	local p = pos(0, 0)
	for x = 0, max_width do
		for y = 0, max_height do
			local p = pos(x, y)
			local item = self:get(p)
			if item then
				func(p, item)
			end
		end
	end
end	


function metatable:neighbours(p)
	return {
		{ position = p + pos(1, 0), direction = "horizontal" },
		{ position = p + pos(0, 1), direction = "vertical" },
		{ position = p + pos(-1, 0), direction = "horizontal" },
		{ position = p + pos(0, -1), direction = "vertical" },
	}
end


function metatable:blast_radius(p)
	return {
		p + pos(0, 0),
		p + pos(1, 0),
		p + pos(1, 1),
		p + pos(0, 1),
		p + pos(-1, 1),
		p + pos(-1, 0),
		p + pos(-1, -1),
		p + pos(0, -1),
		p + pos(1, -1),
	}
end

:: src/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTI0IDA3OjE3OjA5Iixtb2RpZmllZD0iMjAyNS0w
OS0xNyAwNTo1NDoyMCJdXQ==
:: debug.lua
--[[pod_format="raw",created="2024-08-24 12:45:09",modified="2025-05-12 21:08:21",revision=171]]
-- Detect uninitialized globals and typos
-- from @snowkittykira from the BBS


-- if you're using include(), include this after including everything else,
-- since most included modules will need to assign global variables on load

-- these globals are needed by picotron
_init = _init or false
_draw = _draw or false
_update = _update or false
-- these are used by the picotron terminal
cproj_draw = cproj_draw or false
cproj_update = cproj_update or false
_ = _ or false
_is_terminal_command = _is_terminal_command or false
k = k or false
res = res or false
-- gui needs these
drag_t = drag_t or false

local function unknown_variable (t, k)
  error (debug.traceback ('unknown variable ' .. tostring (k), 2))
end

setmetatable (_G, {
  __index = unknown_variable,
  __newindex = unknown_variable,
})
:: drakma.lua
b64$LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNC0wNC0wNyAwNzo0Mjo0NSIsbW9k
aWZpZWQ9IjIwMjUtMDUtMTIgMjE6MDg6MjEiLHJldmlzaW9uPTE2MDNdXQpfbW9kdWxlcyA9IHt9
CgotLSBBICdyZXF1aXJlJyBmdW5jdGlvbiBzaW1pbGFyIHRvIHN0YW5kYXJkIEx1YS4KLS0gSWRl
YSBmcm9tIGVsZ29waGVyIG9uIHRoZSBCQlMKZnVuY3Rpb24gcmVxdWlyZShuYW1lKQoJbG9jYWwg
Y2FjaGVkID0gX21vZHVsZXNbbmFtZV0KCWlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQKCglsb2Nh
bCBmaWxlbmFtZSA9IGZ1bGxwYXRoKG5hbWUgLi4gJy5sdWEnKQoJbG9jYWwgc3JjID0gZmV0Y2go
ZmlsZW5hbWUpIAoKCWlmICh0eXBlKHNyYykgIT0gInN0cmluZyIpIHBhbmljKCJjb3VsZCBub3Qg
aW5jbHVkZSAiIC4uIGZpbGVuYW1lKQoKCS0tIGh0dHBzOi8vd3d3Lmx1YS5vcmcvbWFudWFsLzUu
NC9tYW51YWwuaHRtbCNwZGYtbG9hZAoJLS0gY2h1bmsgbmFtZSAoZm9yIGVycm9yIHJlcG9ydGlu
ZykKCS0tIG1vZGUgKCJ0IiBmb3IgdGV4dCBvbmx5IC0tIG5vIGJpbmFyeSBjaHVuayBsb2FkaW5n
KQoJLS0gX0VOViB1cHZhbHVlCgktLSBAIGlzIGEgc3BlY2lhbCBjaGFyYWN0ZXIgdGhhdCB0ZWxs
cyBkZWJ1Z2dlciB0aGUgc3RyaW5nIGlzIGEgZmlsZW5hbWUKCWxvY2FsIGZ1bmMsIGVyciA9IGxv
YWQoc3JjLCAiQCIgLi4gZmlsZW5hbWUsICJ0IiwgX0VOVikKCWlmIChub3QgZnVuYykgcGFuaWMo
IlN5bnRheCBlcnJvcjoiLCB0b3N0cihlcnIpKQoKCWxvY2FsIG1vZHVsZSA9IGZ1bmMoKQoJX21v
ZHVsZXNbbmFtZV0gPSBtb2R1bGUKCglyZXR1cm4gbW9kdWxlCmVuZAoKCmZ1bmN0aW9uIHBhbmlj
KC4uLikKCWxvY2FsIGFyZ3MgPSB7IC4uLiB9Cglmb3JlYWNoKAoJCWFyZ3MsCgkJZnVuY3Rpb24o
c3RyKQoJCQlzZW5kX21lc3NhZ2UoMywgeyBldmVudCA9ICJyZXBvcnRfZXJyb3IiLCBjb250ZW50
ID0gc3RyIH0pCgkJZW5kCgkpCglzdG9wKCkKZW5kCgoKLS0gVGFibGUgdXRpbGl0eSBmdW5jdGlv
bnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0KCgpmdW5jdGlvbiBpc19lbXB0eSh0KQoJcmF3ZXF1YWwobmV4dCh0KSwgbmlsKQplbmQKCmZ1
bmN0aW9uIGRlZXBfY29weSh0LCBhbHJlYWR5KQoJaWYgKG5vdCBhbHJlYWR5KSBhbHJlYWR5ID0g
e30KCWlmIHR5cGUodCkgPT0gInRhYmxlIiB0aGVuCgkJaWYgYWxyZWFkeSBhbmQgYWxyZWFkeVt0
XSB0aGVuCgkJCXJldHVybiBhbHJlYWR5W3RdCgkJZW5kCgkJbG9jYWwgbmV3ID0ge30KCQlhbHJl
YWR5W3RdID0gbmV3CgkJZm9yIGssIHYgaW4gcGFpcnModCkgZG8KCQkJbmV3W2tdID0gZGVlcF9j
b3B5KHYsIGFscmVhZHkpCgkJZW5kCgkJcmV0dXJuIG5ldwoJZWxzZQoJCXJldHVybiB0CgllbmQK
ZW5kCgoKZnVuY3Rpb24gdG9zdHJyZWModCkKCWlmIHR5cGUodCkgIT0gInRhYmxlIiB0aGVuCgkJ
cmV0dXJuIHRvc3RyKHQpCgllbmQKCQoJbG9jYWwgcyA9IG5pbAoJZm9yIGssIHYgaW4gcGFpcnMo
dCkgZG8KCQlpZiBub3QocykgdGhlbgoJCQlzID0gInsgIgoJCWVsc2UKCQkJcyAuLj0gIiwgIgoJ
CWVuZAoJCXMgLi49IHRvc3RyKGspIC4uICIgPSAiIC4uIHRvc3RycmVjKHYpCgllbmQKCWlmIG5v
dCBzIHRoZW4KCQlyZXR1cm4gInt9IgoJZW5kCglzIC4uPSAiIH0iCgoJcmV0dXJuIHMKZW5kCgoK
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCgpmdW5jdGlvbiBjbGFtcCh2LCBtaW4sIG1heCkKCWlm
IHYgPCBtaW4gdGhlbgoJCXJldHVybiBtaW4KCWVuZAoJaWYgdiA_IG1heCB0aGVuCgkJcmV0dXJu
IG1heAoJZW5kCglyZXR1cm4gdgplbmQKCgpmdW5jdGlvbiBleHBfZGVjYXkoYSwgYiwgZGVjYXks
IGR0KQoJLS0tIExlcnAgc21vb3RoaW5nLCBidXQgZnJhbWVyYXRlLWluZGVwZW5kYW50LCBmcm9t
IEZyZXlhIEhvbG3DqXIKCS0tLSBodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PUxTTlF1
RkVET3lRCgktLS0gVXNlIGFzIGBhID0gZXhwX2RlY2F5KGEsIGIsIGRlY2F5LCBkdClgCglyZXR1
cm4gYiArIChhIC0gYikgKiBtYXRoLmV4cCgtIGRlY2F5ICogZHQpCmVuZAoKCi0tIFBvcyAtLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLQoKCi0tIFdBUk5JTkc6IGRvIG5vdCBmb3JnZXQgdGhhdCBgcG9zYCBpcyBh
IHJlZmVyZW5jZSB0eXBlLCBub3QgYSB2YWx1ZToKLS0gYXZvaWQgbW9kaWZ5aW5nIGluIHBsYWNl
LgpmdW5jdGlvbiBwb3MoeCwgeSkKCWxvY2FsIHAgPSB1c2VyZGF0YSgiaTE2IiwgMikKCXAueCA9
IHgKCXAueSA9IHkKCXJldHVybiBwCmVuZAoKCi0tIERyYXdpbmcgLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoK
Ci0tIEZyb20gU29waGllIG9uIHRoZSBkaXNjb3JkCmZ1bmN0aW9uIGdldF9kcmF3c3BhY2UoKQog
ICAgcmV0dXJuIHsKICAgICAgICBjYW1feD1wZWVrNCgweDU1MTApLAogICAgICAgIGNhbV95PXBl
ZWs0KDB4NTUxNCksCiAgICAgICAgY2xpcF9sPXBlZWsyKDB4NTUyOCksCiAgICAgICAgY2xpcF90
PXBlZWsyKDB4NTUyYSksCiAgICAgICAgY2xpcF9yPXBlZWsyKDB4NTUyYyksCiAgICAgICAgY2xp
cF9iPXBlZWsyKDB4NTUyZSksCiAgICB9CmVuZAoKCmZ1bmN0aW9uIHNldF9kcmF3c3BhY2UoZHJh
d3NwYWNlKQogICAgcG9rZTQoMHg1NTEwLGRyYXdzcGFjZS5jYW1feCkKICAgIHBva2U0KDB4NTUx
NCxkcmF3c3BhY2UuY2FtX3kpCiAgICBwb2tlMigweDU1MjgsZHJhd3NwYWNlLmNsaXBfbCkKICAg
IHBva2UyKDB4NTUyYSxkcmF3c3BhY2UuY2xpcF90KQogICAgcG9rZTIoMHg1NTJjLGRyYXdzcGFj
ZS5jbGlwX3IpCiAgICBwb2tlMigweDU1MmUsZHJhd3NwYWNlLmNsaXBfYikKZW5k
:: main.lua
--[[pod_format="raw",created="2024-03-30 05:39:34",modified="2025-05-12 21:08:21",revision=4967]]
include "drakma.lua"
include "src/constants.lua"
include "src/sgrid.lua"
include "src/hgrid.lua"
include "src/logic/creation.lua"
include "src/logic/matching.lua"
include "src/logic/spells.lua"
include "src/logic/mechanics.lua"
include "src/gfx.lua"
include "src/in_game.lua"
include "src/in_editor.lua"
--include "debug.lua"


local state = in_editor
--local state = in_game
local next_state = false


function _init()
	window { cursor = "" }
	fetch("pal/0.pal"):poke(0x5000)
	state:enter()
end


function _update()
	if next_state then
		state:exit()
		state = next_state
		state:enter()
	end
	next_state = state:update()
end


function _draw()
	state:draw()
	print(string.format("\014% 3.0f", (stat(1) * 100.0)) .. "%", 460, 264, 1)
end
:: .info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTIzIDE4OjQ1OjEzIixtb2RpZmllZD0iMjAyNS0w
OS0xNyAwNTo1NDoyMCIscnVudGltZT0yMCxzdG9yZWQ9IjIwMjQtMDMtMzAgMDY6NTQ6MjQiLHdv
cmtzcGFjZXM9e3tsb2NhdGlvbj0ibWFpbi5sdWEiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRp
b249ImdmeC8wLmdmeCIsd29ya3NwYWNlX2luZGV4PTJ9LHtsb2NhdGlvbj0ic2Z4LzAuc2Z4Iix3
b3Jrc3BhY2VfaW5kZXg9NH0se2xvY2F0aW9uPSJwYWwvMC5wYWwiLHdvcmtzcGFjZV9pbmRleD03
fX1dXQ==
:: [eoc]
