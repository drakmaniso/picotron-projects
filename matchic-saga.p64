picotron cartridge // www.picotron.net
version 2

:: docs/
:: docs/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTI2IDE0OjAzOjI1Iixtb2RpZmllZD0iMjAyNS0w
Mi0yMyAxNTowOTowNSJdXQ==
:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNS0w
Mi0yMyAxNTowOTowNCIscmV2aXNpb249NTA2MV1dbHo0ACFXAAAQ1wAA8xR7WzBdPXtibXA9cHh1
AEMgEBAE8PAsZmxhZ3M9MCxwYW5feAgAz3k9MCx6b29tPTZ9LDEA-1DwER0dBPBPPxJAPuAODxYf
Kg8VDiAOHyofFg7QDg8qPxUuBQBADg81wB4ApBQfFS8WHxUfFA8TANUPFQ8UDxNPFQ8TDxQfKAAB
FQARLxUAEC8VADGQPyw_AFATLxUfEz4A-AYeHytgDyw-LS8VXy0-LB8VHywPK1ARAD8PNUATACXz
AFBPLC8TTywvKx8TLysfNVsANU8tLyIAH2ATAITvcD8rLn0eHR81gPwD8C7JAR3yPDkvKxAPD-AG
DysgHvAFTyzwBw0-LQ0O8AYNDD0ODzXwAx1sHfABDawN4A28HcANLB8qjA0OoA0sK4wdDpANLBuc
HQ4PNXAN-AAtDgYAKwpgBwAm7D0GAP8g3E0OCnANvE0OGnANrF0OCpAdbG0OGqAOzQ4awA6tDhrg
Hm0eGvABCm4q8ARq8BfNAB3wBU0PLOAOoA4PLQ7ADg0OkA4dDqAOoABAgA4tDgQA0QyADg0PKx0O
YA4dCw0OAFIbHW4dGwsAMyuNKxQAEq0SACr9AQYAkHAOLS5tLi0OcFQA8QkaDyoLDk0OCgsPGg4d
DgxgDh0OCRsJDi0GAAERADMtDikEAIAMYA49Lk0uPQkAIP0DSQD-Jm0vCW0OHEBbXQhdW3AOPQ4d
Dh0OPQ4cgDstHg0eLTtwGyAOrQ4cABuwHm0eHPABDG4s8ARsEAEf8AKLDytgDvAEHkAe8AQODyxO
DQ0A8DFNHtAuIA5tDiAuDzVAHi0eAA4NHw8NHA0OAB4tHiAObR4MDyoODAsODB5tDhAOfQ4MHgwe
DA59Dg81AA59Dg0cKwDwCX0OCgAOjQ5NDo0OCgA_bQ4tDm0_CgAOGt8A8AYaDgoQCgA_zT4KEAow
DhoOLQ5NDi0WAPAGcAoATk1OChAKkA4qDk0OKg4K0AogGwD-AiAK8AMODQ4a8AkOGvALCvBx6AAd
IBoPCgNwLPAKDysPFhQDIvAJEgAgDzUUABEfBgBBDzXwCwYA8AQE7yvADu8tDqAODf8sAA6QDg38
BgDwDhw_TD4cDg81YC4MDg8NHw8PDQ4sDgsfDwsODC5A0wHwBQ4KHxAKDiwOChkKDgwOHQ4wDg0M
FgAWGRUAAEAAsSAOHA4MDgsaCw4sBgAAFgAQCBUAAmEA8AIcDggwLvwBLhhACA78AQ4oYAYAYAiA
DjyOPAcAUiwOjQ4sCQBVDQ5MDgwNABB8CgAwkA4cCgCvHA4YoO4YwOjwMCoBKR8SKgEWULAODd8s
lgUFMgEXDC0BVTwOLA48JQEDDgAFIAEwXixeAgESCxcBYA8cHx0PHDABIh8dMQEYCxsBEQsbATAb
QAsVARErGwESCxsBFAsbARgLGwEVCxsBFQsbAW8boO4bwOsbAR-wGS8fK6AusA4fLR5wDi0ekA4f
LB0eQA48HR5gDkwdHhAOHA8NDw8PDRwWAPIEbB0eLA8PDxAPDzwdDiAOnB0eDB4AoVwOIA4sHmwd
HnwwA-ECHB4LDiwePB0eXA4LAC4rDgwQAKMMHR48DgsQKxAeEgByHS4MDgtwGxAA8QUMDi0eC8Ab
EB4bDjwNDgvwAhsADhwB4PABHhAOTA4LsB4gDg0e-wAhG2ALAHIADkwuGxAuCwCSDB0eLB47IA4d
DABAXB4rYAgA-xiMHiuADrweK7AOjB4r0A5sHivwAQ48HivwAw4cHivwBh4r8Akb8CI1AR3xCBYf
K2Ae8AAeDy0ODzVQDg8tHrAeHQ8sDQDwEA0fLB5wHh0cDh81YA48HkAOHTwOC3AOXA4wDkwOG4DL
ANAwDjw_QD48DhswDkwdDwBQHUwOC1AfABBABQAjUA4PACELcO4AAAUAYXAOLD4gPvEB8AMsHQ4L
EA4dLA4bkA48DhsgDjwWAAG3AxAwKwAQgIECEBxMABAcKgKADSwODD4APgxEABMNsAFxDhwdDgsO
HSAAEhzSAQEzAABzASQbgPQBABMAIAsQBQBgoA5cDhwuZQJADlwODNwFoA4LwA5cDg08DhsIAAGp
ATDgDky0ADDgDlyGAI-wAJ4b8AKbsFsBHdAyLyugHqAeLy0OcB4dBABAPywOQE8BALcFFB2OAqIO
EB4dTA4wDh08vgBBLB4dbIUEE1y7ALAeHZwOIA58Hh1sHpcB8QQQDlweHTweLA4LHhwOEA48Hh0M
DQDFDA4LAAsuCwAODC4dEACVHgsgKwAeLQ4MDwAhG2DrAAAKABGw7QDxCiAb8AEOTA4QHvADDiwO
DB4NDiAe4C5MDgAKAHKgGx4sHh0MDgBSLnALHlwOAHAdDguACx6MDQCwG6ALHrwOC9ALHowsAeAL
HmwOC-ADCx48DhvwBaUAvwvwCAseG-AKG-ARQwEd8gYanyvwAg4vLQ5dDvAADg0-LA5MDvBOAyBc
DqYBMVwO0DACMAwOXDMIIAwuGQAQsDcCIC81sAQEZQEQoBMAAD0BABQAAWgBEBwGBTAsDgAFAAQm
AHCQDg0_DzU_BAUAIwVBDjsAG2wAYKAODRwOQAUAEAwMAAGfAiANLGgAUjwOIA4NtgJgHD4LED4s
OQBQHA47IBvFAhBwHAABcQEBCgAkC1AGABBcTgCxXA5QDg0sPgswPjxRAGA8DjtAGw4MAkANTA6A
BQBBCzAePEYAcCweG0ALHixMAEEcHitw3gH-A1AODR4rsAseC1AeK-AAG2AbcG4JfTH9Aw4FAAFd
CRDNXQZ0YA4tTi1OLUgJBU4JEilNCR8JTQlGDyQNEB8yMQD--0ifHR0E-zf---88NQALHTE1AB84
NQAhXzsN-zwNBgA_D4YAHQc7AA8GADgPhgAMD6cBHQ0TBU8POw88BAAhFx8MAA84AP-------wcv
DzuJBh0HOwAPBAAZFx8MAA84AP-------wcvDzyJBhxxjzwPPQ87rwYAEU8GADL-PAAHABABBwAR
zxQAF38gABEfBgAXjwwAF_8GAAIwACRfPDQAES8GABUPNAATL2QAFgRXABcfKQAEgwAQBwcAF98T
ABGfBgARPwYAGL8lABdvJQAmXzxWADb-PBINACw-PCsAHR8YADb-PAgNABOfEwAWAiwAF38_AAN8
AAVdACc7TyMAEx8jABYWEwAXf7gACBIAF886AQIkARnfQwAWE5IACKsAD_QBGfEmIyAEcP82A_D_
BdD_BcD_B7D_B6D_CZD_CYD_C3D_C2D_DVD_DUD_DzD_DyD_ERD_EQD_NgAJABEgFQARQCEAEWAt
ABGAOQARoEUAEcBRAD-g-gOXFAweNY4AHzeOAHofOI4AevMzOwPg-zwF0P87BcD-PAew-zsHoP88
CZD-OwmA-zwLcP87C2D-PA1Q-zsNQP88DzD-Ow8g-zwREP87EQD-PBP-OxMADwATIB8AE0AvABNg
PwATgE8AE6BfABPAbwA-4P88rwAODoARDzEAewBCAQQ9AxOfSQMg4G4IADC_0C4HABCOBQDwAE7A
-gYPPbANDzv_AA0MLvIBoE4NDD4NDI4NDA76AfEFLg0M-gZgng0MXg0MLg0MPlAM-gsHAsE_DQzu
DQx_IA4NDM4vAPIAPhCeDQz_Ag0MDgAM-gQNBAAQAzYAEABFAEIMEP4AWgBRIAxuDQxvAAM3AkG_
DQx_XgARYG4AEHAcABCORAIBQACRHg2gXg0M7rAOJgAhnsA6AM-QXg0MzuCuDQxODXCvExzwE-AV
vzQPMdDfNC8xoN80TzGAXzRfMg8xDzAPNF8xYE80fzILAPAJLzJPMUBPNI8yDzFPMk8xMD80-zIB
PzEgCABBAz8xEAgAvx8xHzAQLzT-MgUvCAAZcS8yDzH-MgEMAHIfMQ8w-zICDAAyMA80DAAQHxgA
AAwAUD8wED8xcgAgMCAIAPEOAT8wME8xfzIPMV8yTzBATzFvMh8xPzJPMGBfMT-FAP8GLzJfMIBP
Md8woC8x3zDQDzG-MPAVCAccAyIBUJ80DzIvJgEADgAfDyoBEEIwDzQ-LAERnw0AIU8yMQFhvzIP
MF8yNAERrz8AED8eABMyPQFgDzIPMY8y_wAAvQABXgAkMi8ZABJ-EQBgNB8yDzAvCgASMSkBAfgA
An0AEC92AAEVABAyWgAAVgAAFwAgDzASAAIuACMyH28ARR80nzKCAVQvMB80vyIAAGcAQR80LzAR
ACEPNA8AEjHEAEUPMK8ynwEUXw8AAqIBoW8yDzBPMg8xPzKpATF-Mh-EACFPMrABACABEy8eABEw
rAESMP8AAbsBAEsBUh8wHzEfvwE-DzI-vwE2ACIBEHCiAGCgTzQvMUDFAeCAXzQvMTAvNE8xYG80
L5cBAHEAIVBP6wAQD_oBcDEQHzQ-Mj_-AQBLAQFFAVQxDzAAH8gBAssAEh8SAABPATAgLzS6AUEA
DzQf5ABBIC80fysBIDEf8gAAgQAANAAAhwGSMB8xTzBADzQ-xQHwUjIvMEBOYD8xLzI_8AMvMV5A
PzSAHQAfMU4wXRxQHQ8yDBAuQF1MMAwbDpA9G1wgDB4QLRwgPUs8YC0bHBAtaxweQC0rLAAdWwwb
LkAtOxwAHUsMKy4wLRsMGywADQwrDA4OAP8eCwwNKwwOACw7DAs_MB0cDTseADwrTlA8Ky4ALI5g
HF4gDI6AbjB_sC6ALvATZAEd8QU2TzTwAy4ADk8zDzIALsAOLzMPMg0AcA4vMw6wDj0FAvAHDzFN
oAw9DzIMQwwLPQxwHg0MDRuDG9IE8AZAHi0cMwUUBQQTHA4dGzAOPQsjFAUCAKIDCz0LMA4tCyMF
EAC1BAMtCwwwDCsMEwQSAFQrHEAsIw8AYxQDLFAuEwwAdwUUAy5ADi0PAGMOLTAOHQsRABAfEgBD
LQswLREAwgoPKhoUAx0bMAsdDBIAgjoDBAMrDEAsDgBHBRoTBF8ALwQTXwACCBAAGj0PACctC34A
C30AAAIAAHwAEyt7AAACAAF8AI--MAEscP81BEIfH-ARhC809QEuQA4PKg4PMvUBLg0wLg30AS4N
IC4N9QMuDRAZAIAN9AMODA4NEAUAMWROZAwAcC4NVF4NVC4JAPAAfisODY4NEK4LDA8MDwoJDADw
D50OCw8MHwoJrSAtUw4LKgkNUy0wHg1UHikODVQeDQsAE14JADFkTWQIACb0AwcAIv4IBABxDv0I
QP8wB9kAH0vZAGElLxDaAFQRDw8PDtsAUhEfDw8O3AAQLxcAA94AHyreAJwVFd4AEBaeKwTeAFMW
HxQPE94AABcAD94ApCMaHd0AVBsPGQ8Y3QBTGx8ZDxjdAAAXAATdABMd3AAvHk3cAJEUH9wAVCAP
Hg8d3ABTIB8eDx3cAAAXAA-cAKMUJNwAVCUPIw8i3ABTJR8jDyLcAAAXAA-cAF4L4AlWbzQPMT-k
CQAOCQL8BwHoCUAfNA8yGggAyQcCFQAB8gkAZAgkXzInCRM-zQgQMFgIAMcIMi8xLxcAETA8CBEf
KgBEPzAvNP8JARAKABsIAR0AHTEWChAfrQgPGAoCAXEAH28aCgEgHzSGAA0cCgHQCQEqAAQgChEf
XwAeHyAKADkKAs4ACSgKET-DCgMVAAYuCgGYAANXAA84CgAC0gA0LzFPPgoRTzoAAF4ANj8wH0YK
Mz8yLxcAAFcAADQAAU4KYh8yHzFfMG4AAXUBAFQKVy8wTzQPFQABWgoBkQkWMCgAA14KLz8wXAo7
DoQODzEA0PAIIxMEIA8W-xUMQA8W-xQOIA8WLxT-MAlOBhAQDABGDzBvJwQAABcAVgAPFj8VEwAA
BABwPxUPEw8WPy0AFigEACE-FBYAGxUWAB8VFgAIAEIAFikEAAFCAB8VFgACHxYWAAgIWAAGQgAM
FgAPLAAJCNwAAfMAHxUKAQE1EA8VLQGvIP8UDg8TQP4NIH4BGZMFBwQAJwAHIBcCAE8HACcAQAAL
HDhAAJEQByAXEAcABzACAC8QRz8AHAF-AEIHMAcgAgAPPwAlPxAXQL4AJBEwQACvAAcABxAHAEcg
B0IAHW9XMDdABzB9ACMgFxB9ABE3gQEPQAAgEkc3AQLCAB8gOgEhAncADn8AD0IAGxA3ggA-EBcQ
QAAZ-wIHCwQAPyoQXgAeHzoeDR4NAAUAA39eDQA_HRA9mwAMLDE0XADBEB8qMC4POhA_DSAN3gcF
AwB-EF4AXg0AXVEAHQetAEAAHQAeqAhBEC4dAAMAD1MANZ8eHSAuQB4NHhD4ACpgQB4POiAuTgBw
EC4NHgAeHU4AQV4NAC3-AC9AHVMAHcJfKgBeDzoeTU4QXhBEAAWhAC8ATaEAH_AvKiA_DzoALi0A
Hh0gTgEBHx3sASwCoQAA4AAF9wAFBgAQIPIAHyCaASgBmgA-AD4dqAAwDFYAcV4NAE4NEB23AABN
AV8uHSAtEFUAGvEBChAEEE8qMG4QjgAuLzouDRcLDwUAEK_ODQBuHRBOHTBNcAAMHDlvAP8DIC8q
UD4POjBODSBeDTAdLg1QAwABQCCOAI5lAB_NXgAcDs0AxwAtEC4NQD4NMD4dIAMAHzBhADEBXAAg
UC5cAHEwPg1ATlANDwAvLiAhASmBEC8qYC4POlC2AEFALh1ACQAhAC4qBAR_AQG8ABFNbgBfUC4N
YC1kABz1BI8qAI4POo4NLm0uDVBuIH4QjhBNAA__ACvxBSBPKjBeDzoQbg0ATj0APh0wLh1AYQAz
AC4tvgADwwAPYgAlBLwAJwA9HwEPCQAFP2AtMEICLgEFAH8Abh0Abg0AxwA3D2gABKGODQB_DRBu
DSAtxgBQME4NEF5hAG8gPh1APSBkABn_Bl4IBBD-OkogDv87Sg89AA7-O0wPPgYAMAAPPSEATD4g
-UrDALEtMjMuMzE5MDQ3NgYAA24Aki0wLjcxNDI4NQYAIjY4fgAKWQTQZhwE8Fj1UiAF9FIDEAUA
MA86AAcAHw4GAGt8EPNSHiD_UnoFUzI2Ljc13wAfM5caAQDPAO_-9FIgBPNSDzsQBPNSDgUAWw_0
ACHAEQ4EEA8WrxUwDxa-4AsCBwBSEA8W3xUEDTEUXw4yDBI6EwCDDzpPFV8OPxUSAAIaABcVJgAS
FRQAMAAPFUkAFB8JAK8POiC-Ex86ML4QOQwZXxEOBPADnwAREwASAASdABIAnAAWAJsAEgCaABIQ
jwASIAcAPzC_II8AHA8tAQNATxU-DmBAAZIAUR8OHxQfdAAAIwEzfxUfLwEACgAiTxUWAFlfFB8O
XzEBJg8VFAAPPQFND68ABBYArgAUAK0AFgCsAANCARYAqgAPTQEqwQQEBAAfOwAOHzoPPQUAPwAd
AEAACx8xBRAsoRcLBPABHzuATlBwAP8pUB5POi4gDh0PPUAOnQ4gHEAOvR4wPh1cbT4dPFAMrQxQ
HiAcfQxQDh0MMBw9HGAOHQxQPJAc8ABzABxSMB878ARxACFOcAgA8A4gLk86HmAfPSAOnzoOEC4w
Hr0OAA89HT5tXB0OAHkA8AIsEAx9HCAecBw9HDAOHQyAPIUAT-AEHEAkER4PMQD--5jwXygoBP8-
FgL_BQL_Lgb_HQJOAu4C-hQG-gYG-gcC-g0C-gMC-gICBgKOBv4MAk4C-jAC-iICXgLeBv47Av4F
Bv4BAj4C-hECBgLeAo4CPgJOEgYPMgYS-hMCBgL_FgL_FwL_NAL_EAL_KgL_Ywa_QgAQEBsAMAcC
3jcAEf4mAAIrABADSgD-AD0GTgL_IwLuAl4Cngb_JLMjGcIoKASvPwL_CgIOBu5WAGBuAj4G-gkT
ACE_AggAAOEAARoAEK4VAID_DAL_EgL_N4YAoO4CBgJ_Br4C-gALAXoGAj4C7gLezADQngL_AQKe
An4GXgb_UK8AES6-AGAIAv4dBt5qABBHQAAyDQJ_LwCBLgJOBi4C-h5FARAxggDgAAb_IAL_LgIu
An4G-g0mADEOBm6GAB8B6AAc4W8-Bv4xAo4GjgL_GQZ_vQEgVwaKADIIAl7hABDODAAQ3hoAMF4C
jmsAFxPNABF_lACgFwKuAr4C-hMCvt0BdFUG-gsC-hQ5AWD_BQJ_Am45ACAWArYAQQEC-gurADEM
Ak4dAoFbBv4hBj4CPhgA4QUC-hIG-g8C-gsGbgKeDQAfINMAHCCPP1wAES6aABACxgBwRAJ_Bo4C
zncCAZQAYf4IAs4CHk8CEARpACH_BNQBQQYC-hwSAALNARAtVQFB-gIGrs8CQAIC-htPABC_6QAV
Bt0BEN5PAFIFAo4CLhUBEh6VAjGuAk5KABAXIQEwHQauBwFBHQL_A9oAUAUG-iUGRAAQIiQAIE4G
TQI-DQKu5gAcYP8-CwL_b2AAMSIGnpMAExZkAUECBv4e0QARMCYCEBJzAZDuAv4zBv6DAo6uACL_
ACoAQa4C-k4QAGAMAq4G-idXAjN_Ar5GABA0mAIASQDPLAL_DgL_UQL_HwaOpAAeE2yxAjABAp6P
AxgWQAIQAfMDMQYCvqwAEAuOAEFCBv4OTwMQAS8BQK4G-pGxACQMAnABIf4zNgRQDAL_OgYSABUW
PwAQNq4AQb4C-lJjAk8tAv4uqwAeEBmJAQK3AUEiAv4GpQFQBQL_DwYIAVEdAm4CrvQDEDtnAFIR
Aj4CBoIEAMcAEDoUAAEiAhBubAQQLisAEQLMABEtgAERDFYAERymAUEJAv4EIQMQBGQBEh5fAwJz
AVAMBs4CjoUDMUQCXlAATw0C-hrIAB5CNwb_CTwDMRACvkEDEAbcAwFhA0EDBv5cdAMB9QEh-gU5
BRABJwATFoQAAK0DBA0AEd6oABJG1gNABAL_MoEBBJEBEARYBQC8AAU7AEEfAv4mRwIQIMQAEAJT
BE8rAv4ewQAZABQd8EAYa-AEG2ob8AAbugnAC_oJoAsaHMoJgAsaLMoZYAsqHOoJCFAL_gQJCA81
MAtqGUoZShkIMAtaCRwJKgkcCToZCA4QC1oJPAkKCTwJKikIDQAwTAlMCwBjDgALWgmsCgBgagmM
CSo5CgBqeglsCTo5FACAagk8CTwJGklNAFBqCRwJCl8A-y85CB4QC3oZKhkqSQgOMPoBSQgeMAnq
WQgOUAm6aQgeYBlqiQgegPkACB6gGKkYHsAOGGkYLvAADmgu8ARukBweHYAYbxDwBB5vDylF8C_9
Dw7ADu0MoA4dHxG9DA8NgA4dLxHNDA8NYA4tHxHdHA8NUA59LI0MCw81MA6NDB8RDH0cCzAOnQwa
DG0cC4NCwK0MKgxdLAsQDp0MOgkAJwkACgBijQxKDE08CgA9OgxdCgCwKgxdTAsJEA6NDBoUACEZ
EFoA-yc9TAsJMK0sLUwLGTAM7VwLCVAcrWwLGWALHF2MCxmAC_wLGaAbrBsZwAkbbBsp8AAJaynw
BGkIASAQFQgBEhQIARQTCAFQFr0MDxIIAVAWzQwPEggBkxbdHA8SUA79BAcBIExtBAFifQxPFgxd
BQFgfQxvFgxNBgFwbQyKDD0sC25HAwsAEgkKAC8tPAoABVF9DGoMLQcBUX0MSgw9BwEhjUwFAS-9
AQQBThAaBAESGQQBYBjADu0PFwUBYBu9DxgPFwYBIBvNCgAABwHyABvdHxgPF1AOjS8YfQwPFxIC
cS8bDG0cDxcPAUAbDF0cGAAA0AEADQDiLA8XEA59HE8bHE0sDxcTAUOPGww9DQB-XQyvGwwdPA0A
DRBtZABiCwwrDB1MXQCgbTwLPC08DxcfNS8CMQsMTRgAUDCdLD1MFQAALwEAEQDwEFAPFwytbAof
NWAKHF2MChmACuwKGaAarBoZwAkabBo0AR9qNAEkEB80ARIeNAEUHDgCUCC9Dx0MMgFAIM0PHRxE
8AAfIE0PHX0bDFAOnQuNCwwwAfAArQuNGwwwDp0LDyALfRsMzgARrQwAICsMCgAQCgkAAPQAgp0L
KgttKwwJCgAgXTsKAF_NC0oLTQoAADA9Sww7AgAKACA7DDsCIQsqFABgMJ0rPUsMPgLwEVsMCVAM
C61rDBlgDBtdiwwZgAzrDBmgHKscGcAJHGscCwEfbAsBJBAkCwESIwsBFCELAUElvQ8iCwFBJc0P
IgsBUCXdHyIMQwMCCAEwjTt9CAFEfQsvJQgBAQwAEI0IAVJtCyoLnQgBAAsAMT0bPQoBAAwAYi0L
CgstOw4ANTorGgwAE4oKAFx9C2oLLRABEUsOAS-9AQ0BTxApDQESKA0BFCYNAUEqvQ8nDQFxKi0v
D20PJxABwSotTw9dHycMUA59TxUAABYB8QpNKg1PDw0vFC0fJwwwDj1KDS8PDU8UHR8nIQEUTRAA
wS8nDBAOTVoNDw8NXw4AACoBY11KLU8ULQ0AM-0FPxYAY08jLU8ZHQ4ApE1fIw0PHg1fGQ0RAJJP
Iw0vHg1PGU9jABQ9EAAwPycMXgOCTS8jDU8eDS8gAGAwjU8eLU8aAHAwDH1PHh1fFQCQUAwPJ20v
Hg1vGACfYAwfJ12LDB81VAEGDygOSgGFAUBs8AQc5QfwCRy6CcAM6gmgDBofKsoJgAwaLsoZYAwq
HuYHEwzmB1AMahxKHOYH8AgMWgwZDCoMGQw6GQgNEAxaDDkMCgw5DOYHYAxaDEkMSQsAYw0ADFoM
qQoAYGoMiQwqOQoAanoMaQw6ORQA8AJqDDkMOQwaSQgNEAtqDBkMCl8A0TkIHRALehwqHCpJCA3m
BxEd5gcRDeYHER3mBxAd5gcQHeYH-wEdwA0YaRgt8AANaC3wBG2Q2h4ZAo4CEBGOAoAPHxDwAB6-
D_gHoO8PDw6gDh8PHyoQAADtB1EfDy8qzwwAoGAOLw8fKt8PHw7zB0B-Dy6NFgABrAPkDh8ODn0c
Dw0wDp0OHA73BzIOLA73ByAOPAkAJwoACgBijQ5MDk08CgA9PA5dCgDALA5dTAsKEA8QjQ4cFQAw
GhAJWwCxPUwLCjCtLi1MCxr0BhEK9AYSGvQGEBr0BhAa9Ab-ABrAChtsGyrwAAprKvAEahoBIBAW
GgEwFB8VGgEQFPoHUO8UDxOg7BQQKhAAAP8HUR8ULyrPDACgYA4vFB8q3xQfEwUIMP8UBBUAABkB
QI8UTm0VAJAwDn0OTxMOXRwXAACjUsRsDk0sDxIQDm0OjA4MCAILABIKCgAvLTwKAAUAPQARLRwB
YRV9DkwOPRwBIY1OGgEv-QEZAU4QGxkBMBkfGhkBEBkPCCDvGRAIYh8ZHyq-GRIIYh8ZLyrPGRQI
Yi8ZHyrfGRYIQI8ZLn0WAAIzAjMvGA4XCDMOTA4lCQAWAgEzAlV9HkweTQ0BAhcBb10OrA4dPAoA
BTFtDixhUREdGwFjGm0_DD4tNwIwDA5NHQE2nS49HgEvCwwfAUMQIB8BMB4fHx8BEB76B-EI7x4P
HKAOHx4fKr8eDx0PHIAOHx4vKs8MAKBgDi8eHypPHg59ZFJQUA6dDo0XAAAgATCtDo0UAABRAyAP
HVwDEhxTA2QMDn0sDxwKAAE5AlOdDiwObV8DFSxBAwZfAwgKABE9HgEXHzkCRw4sDj0eAR8LHgFK
ECUeATAjHyQeARAjDQjxCO8jDyGgDh8jHyq-Iw8iDyGADh8jLyrPDADwAmAOLyMfKt8jHyIPIVAO
-yMEFQAAHAFAjyM_fRUAADsCIC8iHQESIVYDcSwOjSwPIRAMAhSdVgNELA49HlgDESwAUQRSAz88
LhxeAwgfJF4DAA8iAU8QKiIBMCgfKSIBECgiCPID7ygPJqAOHygevQ8nDyaADh0uJAhiDyZgDi0e
JAgkDyYlCCsPJiYIKQ8mJwgAIAAJKAgpDyYpCAAgAAYqCCQPJisIKQ8mLAgsDyYtCCsPJi4IABEA
NxAPKTAIMA8mHxIABzIIJQ8mMwgAHQAyMA8mNQgAGAA0UA8mNwgAHABwYA8mHyddjAsAf4APJuwL
HzXcDB8fODwIMA8hEBkg_gUeEDHKKEoYEFDaCAoIShQQQfoACEoHECJ6iAgAIfoF_A8iWqgKEDL6
AAgJAAAyABEqBxAiyigBEC-6Av4PPx83-g8uBPYOU60LjRwLBwCDChAOvQuNLAsHAHMKAA69Cw0L
pwR8Cw0LDQtdPAwAQW0bDQsCABMblgMhCx0QACEdC9UFgA5dOw0LDTsdkwM-Dv0C8AZAHzcBEDYL
CwEhjWvWBkONC00L-whDCw0rDQwAg20rDQstKy08GAATS64FIgutCAAhO239ADGtC235AD_tC136
AFQP9w8fJP0E3wcg-QUSAJEwDm08DTxNHxg7DMB9DB0MDQwdDE0vGAwOAAGZWyIMTccNMH0MbQsA
AIIFUDwNPD07CgBfrQwNDG0KAABRXUsMChBbADEtOwwMAjFLDAq_DQCeBTJbDAq_DRIavg0QGmoM
EBpqDGAawAocaxwTAR9sEwERD9YPKDfdHx3LDkP9BRsMCwE3GwwKCQEUKwgBMwwNHP0AQQw9DH0K
ADFtrC3xACH9BQcAIn2MFAEh-QT9AD2NTE37AB8M_wBKD8YPIyF9PM4QAPIAEY38AEGNDA0cww8x
jQy96AAijUzwAGKNDC0MDSz0ADONDA0CAAQQADQtDC0MACGMHQIBL-0DAQFcD7oPDBTNtw833R8n
AQExrQ8PAgEwbS8KZQdCLxRNGw0DMQ8KDRIAQg8UDQkJAmQKLQ8PLQkQA0M6Dw85DADyAb0LfTsM
CAAOfT8jDx4-GT0NAHYPIy0PHi0PDwAgDQeOB8APGQ0GLUsMCBAObScQANEmLTsMGBAOrQVdSwwI
KQERGCkBEggpARIYKQEQGCkBEBgpAf8AGMAIHGscKPAACGwo8ARoKQEND1MHYiH6BVIHQvoGKQgG
AAA2BxgGTAcLBwARBEYHL-oDRQdGHzZFBzZC-QUcCwYAAOUCMgYsCwYAJQoABwAvBTwHAAARBCUG
L-0DHQdHDx4XLQ-jAKQPBgcxAggAAPcDZP0GLxgPFwgAAN0DBwoALwU-CgAJJARPRAAyAz8Y2xYi
-QIUAEEw-QFPEwA4MA8Y2hY-Cx81EQEMD9oWSA8EBwEh-QUFBkL9BisMBgAlCgAHAC8FOwcAAALu
Bg-sBUoPsxYsD_QApg-QBhgP5ACgD4sGI-IdafAEGTwLDAsZ8AAZHGobGMAJHKoLCQigCQzqCQiA
CQz6AQkIYAkM_gMJCFAHAPMBDzUwCQxaGUoZWgkIMAkMSgseUEoJCA4QDwACDB4xSgkIDgAADR4A
GwAQAA0AFKwLAFFaCYwJWgsAbQtqCWwJahYAEVoSHhFaVAAjC1oTHrBaCQgeEAkLahkqGTIAMDAI
C5AAQB4wCAkIAEAOUAgJrgDQHmAICeoJCB6ACBmqGdoGPxlqGdwGL8Bu8AQePxEPEA8RDxBCAiAf
EUYW8AMfDcAOHxGvDw8QDg8NoA4PEe8hFnGADg8R-w8BQRYACgARAz8WYw8Rbw8ujUAWYA8RfQ4c
Dg4AMDAODPEVIX0ODxQQDNESEH3JYhAMHBYgfQ4IBggLAACjEQILAHQPEH0OPA6NFwAECwAQCRUS
IJ0OOQYSCWQAAD0GEwlkAIAKMAsJjS5tDtYRAJpfANgRAMtfAEgGMA7tDjcFMB6tHjkFMR5tHjsF
H247BSoQEzcBAFBsMRYPFTcBEBZjFnEfEsAOHxavcWyAEqAODxbvFA5BBwBrOiABDkIHAAoAIAMO
QwcECgABNgFgFn8UTn0OXhZxDxZtDkwObRkAYRAODG0ObA0AgBAODF0OjA5dTgEVAAwAGQoLAC8P
FRcAAhIJRAABOQECXAABOQEjfU43AS-9AzYBVhAYNgFxGw8aDxsPGjYBEBuAFrAfF8AOHxuvGQ8a
DpMHUA8b7xkOkgdgDxv-GQEOkgcACgAgAw6SB3EPG38ZLn0OKwdBDg8bfVYCAJkHEwzbAAE2AQNN
AgBAAUweTB5tEgFhDE0OrA5NCwAmDxoMAAcXACMJXYQWEl04AVRdPgw_XXECMgwOjToBP30ufTsB
VhAdOwFxIA8fDyAPHzsBECCcFoAfHMAOHyCvHsoZgBygDg8g7x4OmRZgDyD-HgEOlxZADyCPHpAD
YRxQDg8gjQoAATsBICCdkBYQHAoAAtIAIw8cqAMRDBkABQsAAnECAF0WAogDBwsAAn4WDcEDFAkL
AAtxAgICBA85AV0QIjkBcSUPJA8lDyQ5ARAltxawHyHADh8lryMPJA63FlAPJe8jDrQWYA8l-yMB
DrIWAAoAIAMOsBYECgABOAFgJX8jPo0OshYxDyVtCgEjDyGqA2EsDq0ODyGqAzMsDr05ARFdthYD
eAITXbcWAg8AMQ8kXbkWD7IDiRAnPgFxKg8pDyoPKT4BECrTFrAfJsAOHyqvKA8pDtMWUA8q7ygO
0hZwDypvKC8Pbw0AEWANABJPDQAYUA0AAUcBMyo-KNoWQD0ODyYRABMtyhYRLSMAAJBDBO0WACIA
ARAAA90WET0iAFAADg8qTd4WFU0PACT9BwsAISlN4BYGGwAUPeEWBT0ABtAWFD1yACQpLRMAAIUA
ER8TABQ95BYCJgCjMA8mDyltTx5tDucWEw4NAAHnFjMObS8aAGFgDyYO7Q4dH3AerR4MG6AcAWb-
ABvACxxuHCvwAAtsK-AEawcJhyH6BQQJIrosqghhDMoMCgxq_ggj6gzVCCNqjAkAIfoHCAAzC0qs
EQAEIwATCzYAAOsII7os5Qgv_gXiCKECCgAC4Qggnw8EAAHiCAcNAAFBAgBQACARrw8ACQ0AAXAC
AQ8AVg8PDxGPEwATjxMAChcAHxAXAANFEV8PHxcAAgQANh8RXzYAIV8P-UkFHwAADAAVX5sAQxBP
Dz8bADA-EU8XAAHgAkEQ-w8FIwBSMA8NDxDnAADYAiQNDvMAEVAMABEBGABBYA8NDigBALsZUA0e
rw8eCwAwoB8NHhGgHw0fNcANHw1uHMggHmzIIA9ZCWIgnxQEAANbCQUNAAETAWAWfxRvFn8PAAIN
AFIPFk8UDxEAAVIBARMAWg8ULxYPFwATXxMAVS8ULxZfFwASFS4AHE9BABjfIgA1PxavfwAVFY4A
Gh8PAACNATISDxXGAACNASQSDtIAEVAMABEBGABBYA8SDgcBAI0BUBIerxQeCwAwoB8SyBEhHxKN
AR4SjQEPsAldAgoAAq8JMf8ZBa0JwQ8bXxk-Gw8ZPxtfGR0AYRAODxtvGQJLIxsPCAAQbxsABBkA
Mw8ZHwQAAxkAAVIBARsAHG8TAAJaAAYTACMan1YAFp8mAA4TAAwmAEkQDg8apgABpgESGsMAAKMB
MhcPGtwAAKMBJBcO6AARUAwAEQEYAEFgDxcOHQEAowFQFx6vGR4LADCgHxeIEiEfF6MBHhejAQ8Y
ClMz-x4DFwoCCgACFwoz-x4FFwoQX1gAUx4-IF8eHApBDyBvHslLIyAPCAAQbxsABBkAUw8eHyAP
CAASbzQAEwAbAFY-Hg8gnxMAVV8eryBfDwBHH-8eBy4APo8gbxsAkBAODx9-Hk8gfxsAAYkBEh_p
AACJATIcDx-CAACJASQcDs4AEVAMABEBGABBYA8cDgMBAIkBUBwerx4eCwAwoB8cABMhHxyJAR4c
iQEPaAppY28jPyWfI2oKIW8jZkwCEQABDwEwJX8jhkwAXAABdQoCEQAS3yAAEQAPADhPJZ8PADEP
JS8zADUvJV8XABIkRgAKBAAeXzYAAAQACTYANY8lX4sAhyT-IwUODyEfDAAAlwEyIQ8k0AAAlwEk
IQ7cABFQDAARARgAQWAPIQ4RAQCXAVAhHq8jHgsAMKAfIbMTIR8hlwEeIZcBD8EKSTP-KAG_CjP-
KAO7CgIKAAGXAXMqnygPEJ8otAqhXygrDQ8QDS8VXSAAAKUKEG3oHoMPEA0PFQ0MbbkKYW0LLQ8Q
LQ8AAUABZiptOw8QPA8ANK0OrQwAhyltPyQPHz8aLAB2DyQtDx8tDxMAQCltDyRyGnQfDQ8aDQlt
ewAwKV0qFAAhKV2BCgARAEGdDx_dHgABtgoh-QMZADAwDyY5DFAIDzVQCDoM-xYIF2AIDu0OCBeA
CB6tHggXoBgebR4YF8AHGG4YJ-AAB2gn8ARnqgpPkDApoCmQGSsZYAQAYwkbKhsJQAYA9hELagsJ
IAkLeggwCQt6CwkACQuKCA81EAkLmgsJC5oJCAoAAHQKO6oLqgkAAaAKQRAJ_gaBCgAHABMOeArx
AR5ACBnqGQgeYBgZqhkYHpBwCqEukAkbqhkIoAkLIgsQC5kKp3AJC3oJegkIDmAJADFqCQjhEyBw
CBYiMQgZOroK-wQ5GB4AGDkIHqA4LiAOOB7APmA_jlYfcBOO8AQOfxDYdGANXw8dDw0JAJN-Dw8N
8AIODY8IABB-iQkj8AEJACAPNWZ0AS4KBQkANQ814AoAT9AODZ8KAAdFwA4NrwoAEp-iCR-AMgAD
Eo8eAAQKAAhkAD7wAA4KAEIBDw0OqwD-EQIMDm8PDgwPNfACDB5fDw4M8AMcfgzwAw81jAvwBItA
JgEdETUtChFvJwqQHW8UHR7ADh3MHwohDexzdwDBeRJwBwABE3hD-AMOCwcAgwowDg38BQ4LBwAv
CiAIABQSMD8AExoIAIIKUA78Ag4LGgcAUgpwCw7sgw8SrIMPHWyDDw9Yfh_AGU8Y8AYeTxoNAlAd
bxkPF-MBEI9VCCPwAAkAAZgBEK8KAAQIAALSAQIKACCwHgoA_QcfF5AeLa8ZLR8XYA4dLxkNjA1M
DxdABgEARgRTDfwHDgsHAC8KAAgABPEaEA6MDg0MHnwOCxogCx5MDgsNDA4LDkweCxpAG04bDQwO
G04bGmAKSwoZAFIKSyqQSgoAQgBK8AEKACzwBwgAb0sK8AhKoB4BHUAbDx3wHnez8AsODfAKDg8f
DxwHADMN8AkIABAICAAA-QcGCgBxDfAGDg8fLxUABQoAEA2pfiEfTxUAQQMODx_ICGHwAQ4PH48K
ABQACgBgDdAODx_vCgAFCQBgDbAODx-PCgAFCQAvDaAKABQwsA6-CAATHQgAMA3QDJYIYAwd4Bxu
HACBD-sGI4A1XyLwBR5PJHQHYvACHh8kL2kHZfABDh8kPwwANw8kTwwAA9UHL-ACGAAIBAwAABgA
F28MACF-I_MIIg0wDAAQDY13MA8kDRB6sw8kjyMODXAODyQOEACknyMOHTAeDyQPIxIAda8jHj0f
JB8QAABJCAJyDwFHCCYNHwsAAM4DAAsAMwINHwoAEAEVAEBwDv8jUYAwNYANSwgAmg4QHUkI3x0f
NcAMHW4dLPAADG3NgCOwGU7wBw5PEA7wBQ62EhAPKwIiDU-iBDXQKRAMAIUALxOACSsJABEAEQ9Z
hKRgCQsqCQgADg0vFgABYVFgFQ8TQAkLOxoDGQBBEw8VT4cuETAXAEYPNQ4fMQACGgAwDzUgORo2
CAAeGAARHxgAoDAZSgkIDAAPDRwWABE-FgDwERxAaQgMEAwAXxMfEhxwWAwwVyyQXEBcoF8iQF8Y
kB8iHwKwDDAPGE8aHxdgDyIZAgCbK6EMAA8dEA8YDxo-8C0QQBoAEk8aAHAPHQ8fDx0AHQARTx0A
STAPIg8dABceIQAAPx8mDCAiAAAhACEvHhotBiAAAUIAFi9CAAIhAGEADxcPGC8iAFQcQA8hLx4A
FE8eAABtH1YcYC8hHBYAhwwALxccgCwAEgBwECzQLx0vHoIt-wEM8ARfHQ8cHPAFRhzwB0yg1AhO
kS9JgEmACUsJYAQAYQsMOgsJQAcAEAgHABFa1whADFoLCAcAAtoIJQx60AggDIoBAgHJCCcMmsoI
DAgAA1QTMh4gCVQTEkCzCCEeYMEIUh6ACQvKBwAhDNrQCDAM_gDzE0ALDPoC9BMBNQAmDkAIADCK
CYqSEwXgCDEeYAijAhAI5BxwHoAISQgeAAUAr6BIHiBIHsBOQE7gCCYQDtcIUR8RTw8NCgAbbAcA
AucIMHwNC-IGUYwOC-AABwABcghDjA4LCgcAUNAODQ8RCQBSwA4NCZwIABmsBwBRnA4LGsAtACka
0DsAA0IAAFkAEHwIAEABDg1sCAARAggAI-ADBwATCwcAr34LCvADiwrwBIqsCB6QNI8T8AMOjxUO
ZAAAGRIwDQ7gCQBQnxQNDsAJADC-FA2gfQAwEhANQn0AxhIgAA3aEgELAFICDQ8SQAsAEQTNEkEN
-xQFExIfIAsAOQFYAAJ3EjVADg1qEiQODWkSMg4NzwoAQqAODa8KAFLADxINjwsAUOAPEo4MMwZ-
jBvwA4vwFnISIUEFDm8aAQIAJRISDe8IAPYbMA0PFzIBLxuf6AgFBgoAIKAuCgCALxeADi3PGS2R
EhANfBIhAg3yCAALAFIEDQ8XIAsAEQZmEkEN-xkHPAAfAAsAGFIQDg1-GQoJANgRUyAPFw1cDQmB
XA4LHzVAC14OCVNeCxpgWw0JQlsagFoKAE8AWvAADQlEAAIJUA7wCg4NDQAgCA76GBAOCAARDBEA
YAYODQ8gHGiJQQ4NCxwTAHQEDg0LPA0OCAABAgNEC1wNDggAASMDRAt8DQ4IAAB2A1ILnA0PHAgA
kwkKsA4NC7wOCQcAXwqgDg3MBwAFELCZAxIJkgP-Bgka4AkNbA4JGvABCW4JGvADaRrwBakaH6A0
fyLwBA5vJA8hugkxJA8l4QgPDAAkAfkIAesIA-UQJPAC6wgSsN8IVm8jDg2g3QgADwAXkN0IE3-t
CDcPJQ7-CBFQEgAnDyMDCRBdEgAXHwMJIF8kbBEEEAAOAwkUQO4IAJUDQA8k7yMKAABnCRHPCgAR
oEUAAAoAIsANdQD-AR814A2ODRzwAY0c8AOM8Bb5CClfDxEvDx37CCA8Dwwa-QgByWEC-wg5Dww6
AQkAikwPAwl5NA8bLwUJAh0CDwcJNAFCFQ8JCdQC3REwLBlgBABgCRwqHAlABgCACEAJDGsMCSAG
AABvHEB6DAkABgAB3xEwDJsMBAAAdBwgmgwEAADzCEIMqwyrCQAyqgyqCQAw_wcMBQlADPoFDOAR
QAz7BQzhEUAM_gMM4REwHOsc4REwHKoc4REwHGsc4REwHKocAx0i6wwDHZAMCHAJDHsMewzYEUIM
egx6CQAwawwIBADADnAJDDocCA4IHDoMAQkQPOIRHzziETIREeIRANWFER-ZhQPqEQIPAAATAAME
CQQPACMfDxEAFQ8RAAIkABsBJAABghEHEwACJgAaADkAEg8qAB-gFgACGNCHAANBAA8WAAgeH0IA
HMAsAAcYAAdwAAGwAB8fFgACD3AACAYSAANAAAAUAA-cABUKHAEPEwAGPAEPDXoBFwxPABINyhIm
HQ9dAADSEi99DNISLiAWHtISACIFASYFAtoSAg0ABxUAAC8KUgwPFRwLAgAgDA0RHUUNDAscAgAw
DQpw4gcWCyMAEQoJEwcTAAAlAFlQDg0cCyYAKgkwEwAAJgAaMFwAAigAGyBNABIcFAAMPAAvCSA9
ACkbMCgAOw0KGaAAAE4ACtgASgwNChnYADkNCgkOARANJUQUHS8AUh0KGaAaDgARHTREFm00RA_0
EyYRG7QTQg8aDxkEABMdzgoFEQAEBAASDc0TDxkAAgLvAgcUAAYEAD8NDxccAAkCawMPHgAHNrAe
DRIACR4AAS0UBhAACAQAAkEUA54AUQwPGQwLAgBRDQwLDB1fCy8MCwIAAAM-Ag8aAAIBSAsvCwwC
AAIvDQocAAkvCQAdAEMWEKwANh0LHaoAQxkgCh0LAEINCw0KJQDxAx0KGUAaTRoNCw0aTRoZYAlK
CR0AUglKKZBJCgBCAEnwAQoAJfAHCAAQLQYAX0oJ8AhJ9BQuMyAPHAcAAfQUEyD0FAKNHRccCwAQ
DewUMyAfHxkAAA0AEy8ZABAEJQBAHx8eH0keAf8UECANADIfHg8RABEBSSgiDyAHFQDkHRMfIAAS
IBAVFCARAARfAAAUABKvHwAVsF0ABSMAESApFQdIAAVMAACuHhbPCwAOOAAvDaA5AA4AWwAHHgAB
wwAvHbClAAAxDdAOMR8AIABP4BxvIHAVLxQlcBUASx0gJA9THQJFFQIRABYfEQAUDxEAGCQTACUk
HyYAAEgADyYAHwQVAAkoABgkFQAaIxcAArMVJiUfFwASJbwVEiWHDAdGAAEcADFwDhwZABgMSQBg
HyMMHTAeGwMBGwDTGw8kGwobChscPRwLChQAIwobAgCHPAsKGwwNCTATAAACAJYMDRkwDgwLChsC
AEoMDQlQEwCIDA0ZUA4MGwojADlwDgwhADSADRwzAGIcDRmgHRwLAHAdGcAJHWwd1wUfbdcFJAAN
DQTtBwATDQIMAAEQAAFDAwcPAAIdDQYuCAkjDQoXAAB5mhEPhZpsYAlKCAAOGgAEKw0mawgbAAUZ
ACAfFCsNEmopDSMPEDYABBsAEhUuDSF7CHQADBwAERQ0DagJaggNAA8NHQ8TGQCXHUAZSwgNEA0A
awDFEh1wWA0wXC2QXUBdQA0FdwJSIQ0wDxgZBgAEAEMfGGAPHQABIQAlIQ1SDRcZBAAQGF0WFSMo
AGMhDQ8dDx45DSkPGQQAAmQNB1EAAN4MEx8tAAYnAAErABANbg0VIy4AMyEPHfUDHx0sAAAAWAAI
VgAdT4EAZBcdQA8hD_gAJA8dfwQCng0CJgBiFx1gLyEdlAAAHgDQDxwNAC8XHYAtAA8dbw4AOBAt
0DoANQ3wBJYAnxwd8AVHHfAHTYwNT-A4NynwCBkfKgwY8AQZHgwOChwY8AAZHiwOKhwYsBkeTA5K
HBhwGR5sDmocGEAJHowOihwIIAgenA6aGwgQCAwKHmweDGobCQucFvEkCAwqHiweCgsKHCobKQsI
DRAIDDouGgsaGxwLOQsIHRAIDEoMGgsaKwoMSQsIDSAIDFoMDgBRWQsIDTAdACArGhsAER0NADEK
KyooABBAKAAhGyomABBQGQAhCzolAAAMABBsIQBgYAgMOgtpYwD-Gw1wCAwaC4kLGQsIHXAIDAoL
qQsJCwgNgAgMC8kbCA2QCOsIHaDoHcDt8JKXHoA4DvALDg8qD1MHIB8qWQMj8AgJAAFDE4EPKg8R
DyoPDxoACg8AAVATZg8qHxEPKhsEBw8AArIFYiovEQ8qLyAACg8AAY4Mcg8qPxEPKj8gABMAIAAA
wCkEJAAT0CMAABQAAicAFtAmABgQKgAUsCoAJRAfLAAUsCwAVhAfDx8QLAATkCwARB8PLxAsABOQ
LAAAFAAXH1gAE3AsABN-KAARcOYAYx8qjh8QHyMAEVAZAWEfKs4fEA8TAINQDh8q-gEfEFoqMP8Q
A70Nn2D-DQMfNYD9A0SeH_FULxPwCB4fKg8WHxLwBAkAUA8qDxQfDwAA7iNRLxYPKi8PABCwoUdB
Fg8qTw4AkXAeHypvFg8qbw4A8ARADh8qjxYPKo8UHxYPEiANDyqfXqABMSqRDRANDA8qbBsPGgVQ
HGoMDxUTAFAKCzwbGiI2QDoMDgndBfIPDQwaCwwbKgkqKQocCgweCQ0IAA0MKgs6CSopOgwuDwC0
GgwKHAoJKikqHA4iALEKDDocGikaHD4MDhEAghxqHBkKHG4MHgDwJposngwNCBANGYoMjhkNGCAd
GWoMbhkdGEAIHRlKDE4ZHShwCB0ZKgwuGR0osAgdGQoMDhkd8z3vHSkdKPAECC0o8Ago8DZWAR2R
Tf8YAaAO-yoB2CmhKv8bAQ8qDxdgDSIpMCrvG0ZzwBsNUA0MHxkPKswLHuMHk0ANDC8ZC6wLLg0A
RT8Zqz4LAHQLSg8aGgkMEQBgOgs6CRoZDwARCA4ARioJGikOAFYaCRopCg8AVgoJGikaDwBGCRop
Kg4ANhopOg0ANgopSg0AJilaDAATnAoAUioJrgkuCwBSGgnOCR4LAP8QCgnuCQ4MDQhQDQz_AQkN
GGAN_QENGID9ARig_AHwLz0BHfAJbT8dbxzwAQ8dLyp-IA8c4A8dDyofIA8qigoSHzopQB8PHMAX
AEAvIA8qKhQCpQoRLxkAGqAZABUvGQAQgBkAED8ZAAIXAAJZKUofDxxgGQAVLxkAEEAZABFPewAg
Lx_FKRFPFwCRIA8dfyqfIG8fvSkyH18e3AtBXx0PH2mYATQUARMAEE8TADMfNSATABZvEwBTQA4P
Hz8TABI-EwATYBMAFk8TABGAXCECEwASLxMAE6ATABYvEwAiwA4ZAQATABIfEwAT4BMAFg8TACHw
Ab4hAhQAEw8UABYDFAABEAAhBQ7uCwEMACIHDggAjwkOHfALDfAayAEdMhovIv0FMCUPIU0AAAkA
EipgCwBoAGIqHyUPKh8PABADIwVCJQ8qLw8AEAEaBUElDyo-DwCR4A4PKk8lDypPDgAQwDgoUiUP
Kl8jfQsCDgAAVwACEgBzgA0PJR8qP00AYD8jLyQNcBMAESOJAAAVAACFCAD7KREkdwMgYA0mAAAZ
AGQMGwwPJT4UAHM7ChsMGxwKEACACjsKCwwbHAsQABEJDwBGDBscGw4ANBscKw0AohscDgocKwoO
HB4QAPECHD4KKwo_LA0JcA0MXgoLCl5jCyEMXgkA0KANDE4MTgwNGcANDD5wA9EZ4A0MLgwuDA0Z
8AENv6FBDRnwA62gAAoA3wUNLA0Z8ActGfAJKbCRAR0wMs8mTAEhvynupQK_KQHeBgDfKZ2PKA8p
DycPKQ4RABEP1gYgLymENDAPKS8TAA0RAALOBnBPKQ8qXylPEQAADwAgPymoNHIPKR8oDyk-JgAT
UCYAES8XABIfLAATUCwAAhUAFD8sABMwLAARHxcAUi8pDygPMAAwMA5fogADFwAwLyhfLgBzIA4P
KU8oHxMAAyoAAUUAIyk-KgAUP4gAAQwjIClPawAGKgARUCoANi8pTyYAEVAmADVvKU-jAAFbACNv
J-YAHh8TAAEtAQGcACOPJ0ABHh8TAAF3ASIprx4AMLAOzxIAf9DOHeDN8BTBClMwCwwKwQowKwwq
vwrxDEsMShiwGWsMahhwGYsMihhACasMqgggCBybDLcKgRocaxwLahsZtQr0DzocKxwqGyobOQgO
EAhKLGorSQgeEAhaC4oLWQgOIAkAlDAIWgtqC1kIHgkAJA5ACQBQUAhaC0obAP8mUAhaa1kIDmAI
SgtpC0kIDnAIKguJCykIHnAIGgupCxkIDoAICgvJCwkIDpAI6QgeoOgewO6LCiUREYsKAcc0EQ_N
CgQLAAGPCiEfEPEzFw0LAAGHChIv3AkXDQsAAX8KEj-eCRcNCwABdwphTxAPEU8PcwoSP2AAEhAc
ADPQDk8QAAAfABHQHgAVLx4AM7AOTxAAAB4AEbAeABVPHgAUkFcAAR4AEZAeABVvHgARcB4AEX8c
AJJwDi8QHxGOHxCpAHFQDh8QHxHOUAoAOwoUETsKUEAPDf4FIQCP-QUcYPwF8C03CiMAbhwhDxQ5
CiAvFdEzATUKIE8VCjQAMQowbxUPfzSQEnAejxUPFo8UKQowrxUPiTQAJQpgFp8VHxYPuTMAEgpw
DxQPFm8VH0YAIBVvqjRQDRANHxT7dwLENBA-SqoBKQoQLyo0EBXQNAF8qiEVLhYAID8U1zQ0DxU_
JAAQFaWqACQAIg4MIgCSHxQMOxxrHD4MRwDwAAsMaxwrHG4MDg0KAA0MmyoK8BcKEA2rDK4NGiAd
iwyOHRpACh1rDG4dKnAKHUsMTh0qsAodKwwuHY4q7x0LDA4dKvAECi0q8AgqIgom0BoBDoAPFw8b
-xoBDxsiCgC6M-EC7xoPGx4NUA0vGQ8bzxoPGy71CZE-GQ8brxoPGz4OAFNPGa8bTgoAbw8bjxkP
Gg4AZzWfGk6iADKuDxqhAFEvGQ8aznkBYUANHxkM7nUBASIK-wAMDRtgDf4BDRuA-QEboPsiCiEx
Lx1-IgoA0hQSTwAKACgKEy8PABAvcFQCDwATbw8AQ6APHT8PACE-HgwKE08PACFPHgIKAA8AE48P
AENADx1fDwAiXx7wCUAg-x8B7wkAMgAAGAAhbx3rCRNfDwAhXx3nCQAPABRvDwAzQA5PDwAhTx3f
CRJPXwACDwAzgA4-DwAhPx3XCRI-qgACDwAzwA4vDwAhLx3PCQALABQPDwAADxUDEAAiHx3HCRUf
DAAiBQ48Hw-DCTcB6BQRI8UJER9xIQHBCREvbCEBvQkRPwIiAbkJEk-kH1Eh4A5fJJMJICHAWCIh
JW-fVBJvSgAxJG8jqQlCIx8lP0YA0yQ-Ix8kDg1wDS8jHyUoIBAkpAkRLn8JIU8jQgAkJE4OAB8k
DgAhEC9kAGIMTyMMDhxXAJAPIxw_DCsMPhwnIsBwDW4MCwxuDRqADW4HAPAZoA1eDF4NGsANTgxO
DRrgDT4MPg0a8AENLgwuDRrwAw0eDB4NGvAFDeeAjxrwBy0a8AkqkwklAYwJCZUJEx_CCTkfJw4N
AAAOBhM-egk5PycODQAADAYRX4MJY18nDnAOTxoAIU8n3ggTXw8AQV8nDlAcABSPHAAzMA5fDwAj
XyddCRSfVQkQX7cIAhoAACkAE08PACFPJ0UJAB4AFG8eABFQHgAUbx4AUlAOXyhvGgAzcA4-JAkQ
PxoACQ8AANEAEx8cCRAfHgAJDwALKQkDCwAPLQlX8BQ1GjnwBCocOxnwABpMWxmwGnxrGYAKnIsJ
YAqsmwhQCTtsexYJwEAJazxrOQhACYscK7JU4jAJq2pJCDAJq3o5CA4gBwDAMAmbeikIHjAJi4op
KioBBwBgUAg5K5oZCwkQaQ8AEmAHAFBwCGl6GQcJNHlaKfwIwAjZCA7ACLkIHtAIeaxIX3g_8AJ_
hBcf0DY-D-AIDj8RHvAFDm0oKPEajQ7wAQ8OLxBNLg8O8AAMLxB_DA810Aw-EH4c0Aw7jgwPNbAM
S44MDw0HAJIKDzWQDFueDAoGAHIJcAxbrhwKBgDwEglQDGuuLApQDFvOHAoJMAo8G94sCjAKXN4s
CgkgCnyuPAcAMIyOTAcAJPwHBgD-BTAa-AMaGUAJKswqKXAZyjnAyfAU1QAdMHJPFDAeUBYfE-AC
-x-wHA8T4B5vFk4PE7AdHxVvFl4NgB0-FV8Wfg1gDW8VLxauDUANnxXODTANnM5cGbANnK4tDxIQ
DayePXVCqA2sjk0LCgANnJ4HAMCMHX5NCxoQDTxtXk0_Qv8YrS5dCxpQG-0AGxpwChu9GyqgCht9
GyrgChstKyrwAworOvAHKvA3ywAdgFKPGfACHn8bARhg4A6PGz8abE3wD48bXxoPGKAOnxtvGg8Y
gA6fGy5PGg8XcA6fG04-Go0ecGAOjxtuHxpLJRBQexdQbxuODxraJADtCXQYLxovG64-DgAmXxoM
AD9PGr4MAAI-PxrODAACYS8aDxjOPQ0AYg0fGh2_TQsAUA8aPZ5dCwD-F1APF01efQwfNVAM-QMM
C3AM-QEMG4AM7QwboCytDBvAG6wb8AC74wEf8Bdsjx7wAh6PIB4-HZAdzyA-Hx1gDTyfIGwNQB1M
ax58DTANbDt_PKw-wA183i0PHBANbO4tCs4B8ANc7j0KCQANPD2_TQoJEAp9rj2JHv81fY49ChlA
Cm2OPQoJYAptbj0KGXAKXV49ChmQCl0uTQoZoArNChnACq0KGeAKjQoZ8AEKbQoZ8AMaLRoZ8AUJ
KinwCCn2CR8wGT8jfgMRJX4DYB7wAg8inXUD8iUfJH0bDNAMS007DMAMWz1LDKAMax4dSwwPNYAM
a05bDIAMW25LDApwDyEsK347DApwCUyOBwApnisHADAMGwkIACCOPAcAMVxuTAcAIV5cBwD-Jk5c
CRqACVw_XAkKkAlsHmwJCqAJ3AkasAm8CRrQCZwJGvAACXwJGvACGTwZGvAECjkq8Ac6XR8eMFB-
JpolECpxQvEQrQ8pHsAOvSwOoA7NPA6ADiydXA5gDkyNbA5QDlxtfFEGUnxdXB8nCgBAXyhMP4AG
MVy-KJcGZCAOHycszwwAUj8nzyhfCwA0Tye-CwA0XyevCwAwbyePCwAAlwZQfydfKG8WAFFADv8n
BIwGMf8nAnoGMf8nAGQGId8nUQbfryceHzXQrivwAKvwM3sPT7Ao8AgYLBjwBBgcKTga8hgYHBkq
GRwYsBgcGWsZHBhwGBwZqhkcGDAYHBnrGRwYEAgMGfoDGQwsGkAJ_wUJsydBCAwJ_goAEBAUACAD
CbcnABQAAAoAJA4gFAAAwycAFUQQDIIPMAwJ_woAJA5AFABgDlAIDAnrHQAACQAQ6hIAE2ASAGAO
cAgMCcobAAAJABDLEgBQgAgM6QyIBp-sCB6Q_AEOsP60CyCwOA3wCw0PEQ3wCg1uCaHwCA0ODw4O
DfAIQQkAhQ8QDaCtMQwODQoAEgsVACAEDQ0fEBAWAAELABIKFwAiAg3XHgAYAAcMADMJ8AANABAb
GgAIDQA0CdANMB85DA4NDQAlCbAOABAKdwALDwAhCZB5AAYRAAwQACcJcBEAAYgADREAkAlQDQ78
Aw4NUHcPfwlQ-QUZYPl2DyLwBRLwCB4vFh7wBB4dLxMdHvAAHh0cXB4gHB29sSMcL2seIRwdvrEF
eh4GFwATMDEAHh8bABAQ8CVFHxQLGgIAMRwNDswjGBoCAAEFLyAADq8ZCAIAMAwNDhYkRwwKCxoC
ABQKFwANRAAfCUMAMxkcLQAQHBUAJx4dFQBnChwdHgkgEwBkHB0eKTAJEQAADgAScA4AACoAgCmw
CR4dLB0e5SCPHi0eKfAECS7qBSOQTP8XA4AO-xsDua9A-xgDDfKvEwwPHw8EAAgBXgEfQCsA--_h
MPwDDR4_r-0DDhtg-gMbgPuMHiCAba8c8AEOryDbNSGvHdk1IwwfDiJRHx8PHgzjNRAM7xEGFwAR
DO81IAzvHgAdYB4AAyIAAMwABA8ABgQAEA8bAABbKzP-HgUKAAZvAAl3AADcESQNDHwiBgQAARsA
FEB-AADkEQwmAAEiAAChAAt3AADyETINDI8gAAHpAAgcABXgyQAiDA3wETINDC8sACHwAxwAAgwA
EQWUNEAb8AcOBgBvCQ4b8AsLdAwfkBovIfAJDi8lDkgAMS8iDa4yEAzPIxIMTDgFqyYhDA2BN0IM
Cx8jsAUV4MUFEgywASUKCw8AGKC0BQOnARgaEQAZcNUFAUoCGWD-BQH7BRxgNwAsCWA4AB8JNwA3
GHATAFcMDQ4ZgBEAABAAFaAQAAAwABUZ9AAADQAT4A0AAAwAASgBEgolAABEARAsCACPBQ4tDhnw
By6-Gycgzyr3tjGvJw0bETANDydYGg8EAAAhJw0MtwUQAAkEAAFrAR_QHwAGAyMAASEABxMACgQA
AUQAH3AjAAoDJwAfcGkACgWQAB9QJwAOAysAH1B1AA4FoAAfMCsAEgMvAB8wgQASBbAAHiBcAA_L
AC8B1wMfMAoBFQ81AREBUgAOMwEPzwEgAUoADs0BD1kCGAFCAA5XAgmEAADeON8NDhuwDs0OC9DO
G_DLEx1VgCsZ8AQZGyob61HwCBtqGxmwGRuqGxlwGRvqGxkwGRv6AxsZLD4iBwtXPgD0eCNqC5Va
AutaIVoLTz4TOutaQToLCB4PAADsWiA6CwkUQQs6CawLABAwCwAQjAsAER6pN0FsCUoLPz4DFgAA
QT4RKuxaUCoLCB5QGAAC7FoAHABwYAkLShkqGTIAcnAJC_oLCB4HACIOgAcAP5AJ66kNKQEvHSEQ
DxwvAS4cAi0dAksnBgsAATgdMg8QLxgABgsAATgdAascA7snKBAuuCeFEA8PDh8RDh_6JyEQHxEA
Fw_8J1QQLw8OLxMAIvAAJAAWPyQAEtAjABQ-RwAS0CIAFE8QAABGAgQiAAWwJwkQAACmAgBBHQBn
ABRfpichEE_KABNfIgBXcA4PEG8SAAAQAEJ-Dy5dHgBwUA4PEP0DDFgdIPwFIUdf_wUaYPpLHSYi
LxXVDRIU1Q0RbNANEazHDRHstg0xbE5sow1wfA5PFg58DXVRoQ1sDm8WDmwNDxKRDW9cDo8WDlwO
AC0KVAAFbgBRDzUAHxKFAPASGw81IBsd7B0bKjAKGx2sHRsqcAobHWwdGyqwChsdLB0bHx0wGy0b
HR0fKx0dIzBM-xg9DRIaPQ0wGQMNC1EDCQABbgoHCwBEfxkufAwAZGwOLxsObA4Ab1wOTxsOXA4A
AxBMXjQUTA4AMDwOj7HBAw4AbywOrxsOLA4AERA8cAA2Cw4rPABFTD4LPlcAVXwOCw58DQAGpwAv
-AMKAAYAQgsADD8wYP8X0ikf_kYLIhAdRgsRH0YLER6WCTFcDlyPCTFsDmyHCTF8DnwtC2F8Dg8g
DnwfC1GMDgsOjAQLkIwOKw6MDQ8cICAAUSsOfA0K-gqAXA5LDlwNChnlAHEOSw5MDQoZ374wSw48
CzYAGwFQSw4sDQohCTEsDisLAFDADg0sLgkAEOCQQhEKFAkAOQACEAkiChnACiAKGXgKvwoZ8AkK
GfALCfA3phwjIi8kwAoSI8AKFkwOQwD-QgGrChGsDgERzAwBQkw_XA1rvyAvJTQCESGovyAvJbIB
ESGJChAsDgAZjA4AOTweLBAARywOCw4SADg7LhsPABaLDQBUPA5rDjwNAAJAASEPIXEHIExOCwAB
JAwRzAkAEKCoACEPIRYMEYwJAAE_ASIPIQgMAi4AAkIBAQoAMQUOLQgAIAcvBgAvCSpYCioTKIMH
Ic8oQApDTC8PTNMHgUwPDy8RDw9MGApRTAsvEQsaAHBwDg0cLwoMEABDDC8UHO4JggovDA8KDCsM
-lUB2AcATjgCGAASTBYAPxwNDhQAAQEqCXE8LwpsLxQ8lAkj-AVuCXM8LyNsLxk8IwDzABwPIy8l
DyNMDxkvGw8ZHDgJDRYAAXkAEgwWAABDDQIZAAQVCeMcLyMMDx4vIA8eDC8ZHNAAEkwSABNM7wgG
DwACCAEzLx5MxwhCzA0OCq8IEBqvCG8K0M4a4MqvCFBwk3jwBQhaCGkHRQhaCA4GAIAaCCoIDmD4
AQYAOgj6AwYAIDD4FBYr_gYGAHL4BCoIDkDuPAAFSgAHBgB-eA7wBX7wZqQAHUBTTfAIf1xPDzXw
BwgAGEBN8AQNnJEAvswBCQAyDOBNBwABDgAPCQALIZBdCQBBXVANPhEAai4NPg0MQA0AIS4dDQAg
HS4NAF9_DS4NfgkAAo-9BwxQ-AfwLLo6H2AS8AgOLxRfOBsHCACRAH4vFG6gDv0ASQJE-QAODAYA
MS2eLQcAOA59DgkAIVBOCQAQTvLLYC0eLQ5tDvF9TA4tDj0LAJBOLQ4tXi1ODCAgX0G9DkxQBwAl
DJAHAHDeDJAOnQ5sBQAyDPAABgBwfi0ODPABXGoAIvAHBgBvTgzwCEyg7BQhwZAOfxkOfQ6QDn0O
fUjEAAgAIQyAuAAhLR5RxACtAC09DgsAEa4HAAMvAAkHABBe1gChDJA8Di0OLQ5c0AcAPwzwAwgA
CxHQNgAfkFEAAk-_AwyQac8hMIb-HOEAGh7bAA-iAAMABAAICwDYYC4tXi1_UA79BQ4MQAYAMf4H
DDATJxxQEcWwYP4FDHAMDu0OLIAAXxGgBQCP-gEMsPwB8Ey3AB0gS5_dIwBYTgB6CwwIAEIvIx4t
CgABqAAICAB3rtAOzQ4MwAUAMS1uLQcAABDOI35gGM4wXQ4MaQIAtMUFDQAaTQsAER3IAgA-ABE_
CQAr-QQGAI-_Bgxg-AbwSXGqH3Em4J4vKJ5QKwMAmAETQAoAFwwJAAGcAQKeARVAkwEPDQAAS14t
Xi2fAQIGADqeLZ4RAAMGAAUyAApIAAkNAAh8AAWSAA0JAABiAI9QfE6c4EzwGDoGHg8xAP_SUG09
Nn19
:: gfx/1.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA5LTEzIDEzOjUxOjM5Iixtb2RpZmllZD0iMjAyNC0w
OS0xMyAxMzo1MzoxOCIscmV2aXNpb249OV1dbHo0AG0AAAAFMQAA8xR7WzBdPXtibXA9cHh1AEMg
EBAE8PAsZmxhZ3M9MCxwYW5feAgAz3k9MCx6b29tPTh9LDEA----------------------------
------------------------------------51BtPTh9fQ==
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNS0w
Mi0yMyAxNTowOTowNSIsc3RvcmVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Il1d
:: map/
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNC0w
OS0wMSAwNzozNDozNSIscmV2aXNpb249MzA3NV1dbHo0AMEAAABZEAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD-------_x0zIwMDAzMDAwNDAwMDYMAC81MIAAWxMxCAATNYAALzYw
AQBbFzb8ABMxDAAPAQBVBHwBAAABEzAMAA_AAVkTMXQAEzB4ABcxjAAPAAFVEzaEAAQMAC81MAEA
--------nvEJIiksaGlkZGVuPWZhbHNlLHBhbl94PTQ3CQDSeT0wLHRpbGVfaD0yOQoAEHcKAIB6
b29tPTF9fQ==
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNS0w
Mi0yMyAxNTowOTowNSIsc3RvcmVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Il1d
:: pal/
:: pal/0.pal
b64$LS1bW3BvZCxiZ19jb2xvcj0wLGJsYWNrZXN0X2NvbG9yPTAsY3JlYXRlZD0iMjAyNC0wOC0y
MyAxODo1OTowOSIsaGlkZGVuPXtbMF09dHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1
ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUs
dHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRy
dWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVl
LHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0
cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1
ZX0saGlkZGVuX3RvZ2dsZXM9e1swXT10cnVlLHRydWUsdHJ1ZSx0cnVlfSxpY29uPXVzZXJkYXRh
KCJ1OCIsMTYsMTYsIjAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMTA3MDcwNzA3
MDcwNzA3MDcwNjAxMDAwMDAwMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA2MDYwMTAwMDAwMDAwMDEw
NzA3MDcwNzA3MDcwNzA3MDYwNjA2MDEwMDAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNjA2MDYwNjAx
MDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDcw
NzA3MDcwMTAwMDAwMTA3MDcwNjA2MDEwMTBkMGQwMTAxMDcwNzAxMDAwMDAxMDcwNzA2MDYwMTAx
MGQwZDAxMDEwNzA3MDEwMDAwMDEwNzA3MDEwMTA3MDcwNjA2MGQwZDA3MDcwMTAwMDAwMTA3MDcw
MTAxMDcwNzA2MDYwZDBkMDcwNzAxMDAwMDAxMDcwNzBkMGQwMTAxMGQwZDA2MDYwNzA3MDEwMDAw
MDEwNzA3MGQwZDAxMDEwZDBkMDYwNjA3MDcwMTAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcw
NzAxMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDEwMTAxMDEwMTAxMDEwMTAx
MDEwMTAxMDEwMTAwIiksbG9ja2VkPXtbMF09ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2V9LG1vZGlmaWVkPSIyMDI1LTAyLTIzIDE1OjA5OjA0Iixva3BhbF92ZXJzaW9u
PSIxLjAuMyIscmV2aXNpb249NDU1NSx0ZXN0X2N1YmVfY29sb3JzPXtbMF09ezE1LDMxLDR9LHsz
MSw0LDIwfSx7NCwyMCwyMX0sezEwLDksMjV9LHs5LDI1LDI0fSx7OCwyNCwyfSx7MjYsMTEsMjd9
LHsxMSwyNywzfSx7MjcsMywxOX0sezI4LDE3LDE5fSx7MjgsMTIsMTZ9LHsxMiwxNiwxfSx7Niwy
OSwxM30sezI5LDEzLDE4fSx7MTMsMTgsMX0sezcsMjMsMTR9LHsyMywxNCwxM30sezE0LDMwLDE4
fSx7Nyw2LDIyfSx7NiwyMiw1fSx7MjIsNSwyMX0sezEsMSwxfSx7MSwxLDF9LHsxLDEsMX19LHdo
aXRlc3RfY29sb3I9N11dbHo0APEBAAAVAgAA-QV1c2VyZGF0YSgiaTMyIiw2NCwiMAEA8A00YzM2
NWEwMDgyM2YzODAwOTg0NzNmMDA5ZjUxCACRNjQ0ODc3MDBmAQDwODAwNzQxZjY1MDBhODI1OTIw
MGUyNDliYTAwZWY4M2M1MDBmOGJiZDkwMDc3MmMxNjAwYTIzMjE5MDBkNTRmMjEwMGYzODI1UADw
JGNiYzljMDA2NzQ5MTMwMDljNzExYTAwZDZhMjI1MDBlZGM0NTQwMGZiZTE5OTAwMmQ1MxgA8BYz
MTZlMzIwMDUwYTMyYzAwODdkNDU2MDBiZmYyOTUwMDE2NTg1CADwDTc3OTdkMDAyMGI0YjMwMDVj
ZDhkMjAwYWNmNmb4ALA3MjI4NjAwNWUyNiAA0DhkM2JlZDAwYWU4MWawAJA4YzRmYzAwNTMCAEAw
MGIyAgBAMDBlMwIAQDAwZjQCAADIAAACAEAwMDFkAgBAMDAyZQIAQDAwNDYCAEAwMDliAgBAMDBj
MQIA4DAwNGY0YjNlMDA3MzZh4ADwEzllOGY3NDAwYWE5ZDg1MDBiZWI1YTQwMDU4NTk1ZDAwNjgC
AFEwMDZmNrkAETcBAFAwMDg2OK8B8QYwM2YyNzJhMDA1YjM3MzQwMDY2NDBgAFAwNDk0NCgAIDVj
EAGANDAyYzRkIik=
:: pal/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTIzIDE4OjU0OjE5Iixtb2RpZmllZD0iMjAyNS0w
Mi0yMyAxNTowOTowNSJdXQ==
:: sfx/
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM1Iixtb2RpZmllZD0iMjAyNS0w
Mi0yMyAxNTowOTowNCIscmV2aXNpb249NDQ4M11dbHo0ABoBAABSCAAA8CdweHUAAygAAAQABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDBAUGBwAP-5AICQoLDwwPDQ8ODw8QAPAADQ8RDxIPEw8UDxUP
Fg8XEwDxAQ8YDxkPGg8bDxwPHQ8eDx8UAPEAIA8hDyIPIw8kDyUPJg8nFADxACgPKQ8qDysPLA8t
Dy4PLxQA8QAwDzEPMg8zDzQPNQ82DzcUAP8FOA85DzoPOw88Dz0PPg8-AA--8P8BAOv-J1oBEAYP
IBABIAEgAfAAAhACDBABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDDAAAh9EMAAc
H0AwAPIf-wEA3L-4D0AADUD--7DwcAoA--9kH-8BAP_ZUP----8g
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNS0w
Mi0yMyAxNTowOTowNSIsc3RvcmVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Il1d
:: src/
:: src/logic/
:: src/logic/creation.lua
--[[pod_format="raw",created="2024-08-30 06:25:09",modified="2025-02-23 15:09:04",revision=1683]]
--- Board Creation Logic


function logic_new_test_cells(tiling, for_editor)
	local grid
	local size
	if tiling == "square" then
		grid = sgrid_new()
		for x = 2, 9 do
			for y = 0, 7 do
				grid:set(pos(x, y), cell_good)
			end
		end
	elseif tiling == "hex" then
		grid = hgrid_new()
		for i = 0, 4 do
			for y = i, 12 - i, 2 do
				grid:set(pos(6 + i, y), cell_good)
				grid:set(pos(6 - i, y), cell_good)
			end
		end
	end
	return grid
end


------------------------------------------------------------------------


--local function random_gem()
--	if false and rnd() < 0.05 then
--		local gem = gem_rainbow + flr(rnd(6))
--		if gem == gem_robot_E then
--			gem += flr(rnd(4))
--		end
--		return gem
--	end
--	return gem_color_first + flr(rnd(gem_color_last - gem_color_first))
--end
local bag_of_gems = {}
local rejected_gems = {}


local function random_gem()
	while #bag_of_gems == 0 do
		bag_of_gems = rejected_gems
		rejected_gems = {}
		for i = gem_air, gem_night do
			add(rejected_gems, i)
		end
	end
	local idx = math.random(1, #bag_of_gems)
	local gem = bag_of_gems[idx]
	deli(bag_of_gems, idx)
	return gem
end


function logic_fill_gem_at(cells, gems, states, p)
	local cell = cells:get(p) or 0
	if (cell & cell_mask == 0) or (cell & rock_mask != 0) then
		return
	end
	local test = (gems:tiling() == "square") and logic_test_sqr_match_at or logic_test_hex_match_at
	local gem = gems:get(p)
	if not gem then
		local attempts = 0
		local found = false
		while attempts < 16 and not found do
			if gem then
				add(rejected_gems, gem)
			end
			gem = random_gem()
			gems:set(p, gem)
			found = not test(gems, p)
			attempts += 1
		end
		if attempts == 16 then
			gem = gem_gift
			gems:set(p, gem)
		end
		states:set(p, { name = "new" })
	end
end


function logic_fill_gems(cells, gems, states)
	-- TODO: transform into a coroutine
	-- TODO: fill in reverse gravity order
	cells:foreachpos(
		function(p, _)
			logic_fill_gem_at(cells, gems, states, p)
		end
	)
end

:: src/logic/matching.lua
--[[pod_format="raw",created="2024-08-24 08:12:55",modified="2024-09-13 09:08:06",revision=2979]]
--- Matching Logic

-- The matching algorithm has two phases:
--
-- 1. First, a linear sweep through all the gems, and for each gem involved in a match
--    creates a mark registering which direction(s) matched.
-- 2. Then a flood-fill algorithm is used to group matches together.


local function logic_is_matching(gem1, gem2)
	if (not gem1) or (not gem2) then
		return false
	end
	
	-- Only colored gems can match.
	if (gem1 < gem_color_first) or (gem1 > gem_color_last) then
		return false
	end
	if (gem2 < gem_color_first) or (gem2 > gem_color_last) then
		return false
	end

	return (gem1 == gem2) or (gem1 == gem_rainbow)
		or (gem2 == gem_rainbow)
end


--------------------------------------------------------------------------


local function test_3(gems, p0, p1, p2)
	local gem0 = gems:get(p0)
	local gem1 = gems:get(p1)
	local gem2 = gems:get(p2)
	return logic_is_matching(gem0, gem1)
		and logic_is_matching(gem0, gem2)
		and logic_is_matching(gem1, gem2)
end


local function test_4(gems, p0, p1, p2, p3)
	local gem0 = gems:get(p0)
	local gem1 = gems:get(p1)
	local gem2 = gems:get(p2)
	local gem3 = gems:get(p3)
	return logic_is_matching(gem0, gem1)
		and logic_is_matching(gem0, gem2)
		and logic_is_matching(gem0, gem3)
		and logic_is_matching(gem1, gem2)
		and logic_is_matching(gem1, gem3)
		and logic_is_matching(gem2, gem3)
end


function logic_test_sqr_match_at(gems, p)
	local S = p + pos(0, 1)
	local SS = p + pos(0, 2)
	local N = p + pos(0, -1)
	local NN = p + pos(0, -2)
	local E = p + pos(1, 0)
	local EE = p + pos(2, 0)
	local W = p + pos(-1, 0)
	local WW = p + pos(-2, 0)
	local SE = p + pos(1, 1)
	local SW = p + pos(-1, 1)
	local NE = p + pos(1, -1)
	local NW = p + pos(-1, -1)
	return test_3(gems, SS, S, p) or test_3(gems, S, p, N) or test_3(gems, p, N, NN)
		or test_3(gems, EE, E, p) or test_3(gems, E, p, W) or test_3(gems, p, W, WW)
		or test_4(gems, p, S, SE, E) or test_4(gems, p, S, SW, W) 
		or test_4(gems, p, N, NE, E) or test_4(gems, p, N, NW, W)
end


function logic_test_hex_match_at(gems, p)
	local S = p + pos(0, 2)
	local S_S = p + pos(0, 4)
	local N = p + pos(0, -2)
	local N_N = p + pos(0, -4)
	local SE = p + pos(1, 1)
	local SE_SE = p + pos(2, 2)
	local SW = p + pos(-1, 1)
	local SW_SW = p + pos(-2, 2)
	local NE = p + pos(1, -1)
	local NE_NE = p + pos(2, -2)
	local NW = p + pos(-1, -1)
	local NW_NW = p + pos(-2, -2)
	local E = p + pos(2, 0)
	local W = p + pos(-2, 0)
	return test_3(gems, S_S, S, p) or test_3(gems, S, p, N) or test_3(gems, p, N, N_N)
		or test_3(gems, SE_SE, SE, p) or test_3(gems, SE, p, NW) or test_3(gems, p, NW, NW_NW)
		or test_3(gems, NE_NE, NE, p) or test_3(gems, NE, p, SW) or test_3(gems, p, SW, SW_SW)
		or test_4(gems, p, SE, S, SW) or test_4(gems, p, NE, N, NW)
		or test_4(gems, p, NE, E, SE) or test_4(gems, p, NW, W, SW)
end


local function check_3_and_mark(gems, p0, p1, p2, mark, marks)
	if test_3(gems, p0, p1, p2) then
		marks:merge(p0, mark)
		marks:merge(p1, mark)
		marks:merge(p2, mark)
	end
end


local function check_4_and_mark(gems, p0, p1, p2, p3, mark, marks)
	if test_4(gems, p0, p1, p2, p3) then
		marks:merge(p0, mark)
		marks:merge(p1, mark)
		marks:merge(p2, mark)
		marks:merge(p3, mark)
	end
end


local function mark_sgrid_matches_at(gems, p0, marks)
	check_3_and_mark( gems,
		p0,
		p0 + pos(0, 1),
		p0 + pos(0, 2),
		{ name = "matching", vertical = true }, marks )
	check_3_and_mark( gems,
		p0,
		p0 + pos(1, 0),
		p0 + pos(2, 0),
		{ name = "matching", horizontal= true }, marks )
	check_4_and_mark( gems,
		p0,
		p0 + pos(1, 0),
		p0 + pos(0, 1),
		p0 + pos(1, 1),
		{ name = "matching", vertical = true, horizontal = true }, marks )
end


local function mark_hgrid_matches_at(gems, p0, marks)
	check_3_and_mark( gems,
		p0,
		p0 + pos(0, 2),
		p0 + pos(0, 4),
		{ name = "matching", vertical = true }, marks )
	check_3_and_mark( gems,
		p0,
		p0 + pos(1, 1),
		p0 + pos(2, 2),
		{ name = "matching", horizontal_SE = true }, marks )
	check_3_and_mark( gems,
		p0,
		p0 + pos(1, -1),
		p0 + pos(2, -2),
		{ name = "matching", horizontal_NE = true }, marks )
	local p1 = p0 + pos(1, 1)
	local p2 = p0 + pos(1, -1)
	local p3 = p0 + pos(2, 0)
	if test_4(gems, p0, p1, p2, p3) then
		marks:merge(p0, { name = "matching", vertical = true, horizontal_NE = true, horizontal_SE = true})
		marks:merge(p1, { name = "matching", vertical = true, horizontal_SE = true })
		marks:merge(p2, { name = "matching", vertical = true, horizontal_NE = true })
		marks:merge(p3, { name = "matching", vertical = true, horizontal_NE = true, horizontal_SE = true})
	end
end


local function mark_all_matches(gems)
	local marks = gems:new_grid()
	if gems:tiling() == "square" then
		gems:foreachpos(
			function(p, _gem)
				mark_sgrid_matches_at(gems, p, marks)
			end
		)
	elseif gems:tiling() == "hex" then
		gems:foreachpos(
			function(p, _gem)
				mark_hgrid_matches_at(gems, p, marks)
			end
		)
	end
	return marks
end


---------------------------------------------------------------------------


local function group_this_match(cells, gems, marks, p)
	-- A simple flood-fill algorithm to group all
	-- intersecting linear matches together.
	local colour = gem_rainbow
	local positions = {}
	local one_good_cell = false
	local remaining = { p }
	local rainbows = {}
	while #remaining > 0 do
		local current = deli(remaining)
		local gem = gems:get(current)
		local mark = marks:get(current)
		if mark and mark.name == "matching"
			and (not mark.counted)
			and logic_is_matching(colour, gem)
		then
			if gem == gem_rainbow then
				-- Rainbow gems can be part of multiple matches,
				-- so they need to be unflagged at the end.
				add(rainbows, current)
			else
				colour = gem
			end
			add(positions, current)
			marks:merge(current, { counted = true })
			local cell = cells:get(current)
			if cell and cell & cell_mask == cell_good then
				one_good_cell = true
			end
			local neighbours = gems:neighbours(current)
			foreach(
				neighbours,
				function(n)
					local s = marks:get(n.position)
					if not s then
						return
					end
					if s and s.name == "matching"
						and (not s.counted)
						and s[n.direction]
					then
						add(remaining, n.position)
					end
				end
			)
		end
	end
	foreach(
		rainbows,
		function(p)
			marks:merge(p, { counted = false })
		end
	)
	return { colour = colour, positions = positions, one_good_cell = one_good_cell }
end


function logic_find_matches(cells, gems)
	local marks = mark_all_matches(gems)
	local matches = {}
	marks:foreachpos(
		function(p, mark)
			if mark and mark.name == "matching"
				and (not mark.counted)
			then
				local match = group_this_match(cells, gems, marks, p)
				if match.colour == gem_rainbow then
					-- Ignore, as this is probably a stray rainbow that was unflagged
					-- at the end of `count_this_match`.
					-- TODO: an edge case is when there is a legitime match of
					-- only rainbow gems (e.g. 3 rainbows surrounded by black things).
				else
					add(matches, match)
				end
			end
		end
	)
	return matches, marks
end
:: src/logic/mechanics.lua
--[[pod_format="raw",created="2024-08-30 06:41:59",modified="2024-09-13 09:08:06",revision=1632]]
--- Core Mechanics Logic


function logic_mark_gravity(cells, gems, marks, gravity)
	local some_gems_are_falling = false
	gems:foreachpos(
		function(p, gem)
			local below = p + gravity
			local distance = 0
			local cell_below = cells:get(below) or cell_none
			while (cell_below & cell_mask != cell_none)
				and (cell_below & rock_mask == 0)
			do
				if (not gems:get(below)) then
					some_gems_are_falling = true
					distance += 1
				end
				below += gravity
				cell_below = cells:get(below) or cell_none
			end
			if distance > 0 then
				marks:set(p, { name = "falling", target = p + distance * gravity })
			end
		end
	)
	return some_gems_are_falling
end


function logic_enact_gravity(gems, marks)
	local fell_gems = {}
	marks:foreachpos(
		function(p, mark)
			if mark.name == "falling" then
				local new_p = mark.target
				add(fell_gems, { gem = gems:get(p), pos = new_p })
				gems:del(p)
				marks:del(p)
			end
		end
	)
	foreach(fell_gems,
		function(fell_gem)
			gems:set(fell_gem.pos, fell_gem.gem)
			marks:del(fell_gem.pos)
		end
	)
end


------------------------------------------------------------------------


function logic_mark_swap(gems, marks, source, target)
	local gem0 = gems:get(source)
	local gem1 = gems:get(target)
	local test = (gems:tiling() == "square") and logic_test_sqr_match_at or logic_test_hex_match_at
	gems:set(source, gem1)
	gems:set(target, gem0)
	local matched = test(gems, target) or test(gems, source)
	gems:set(source, gem0)
	gems:set(target, gem1)
	if not matched then
		return false
	end
	marks:set(source, {
		name = "swapping",
		selected = true,
		target = target,
	})
	marks:set(target, {
		name = "swapping",
		target = source,
	})
	return true
end


function logic_enact_swap(gems, marks)
	local reinsert = {}
	marks:foreachpos(
		function(p, mark)
			if mark.name == "swapping" then
				add(reinsert, { gem = gems:get(p), position = mark.target })
				gems:del(p)
				marks:del(p)
			end
		end
	)
	foreach(
		reinsert,
		function(r) gems:set(r.position, r.gem) end
	)
end


-------------------------------------------------------------------------


function logic_enact_clear(gems, marks)
	marks:foreachpos(
		function(p, mark)
			if mark.name == "matching" then
				gems:del(p)
				marks:del(p)
			end
		end
	)
end

-------------------------------------------------------------------------


function logic_mark_repair(cells, marks, matches)
	local is_something_repaired = false
	foreach(
		matches,
		function(match)
			if match.one_good_cell then
				foreach(
					match.positions,
					function(position)
						local cell = cells:get(position) or 0
						if cell & cell_mask == cell_bad then
							marks:set(position, { name = "repaired" })
							is_something_repaired = true
						end
					end
				)
			end
		end
	)
	return is_something_repaired
end


function logic_enact_repair(cells, marks)
	local to_be_unmarked = {}
	marks:foreachpos(
		function(position, mark)
			if mark.name == "repaired" then
				local cell = cells:get(position)
				cell = (cell & ~cell_mask) | cell_good
				cells:set(position, cell)
				add(to_be_unmarked, position)
			end
		end
	)
	foreach(to_be_unmarked, function(p) marks:del(p) end)
end


----------------------------------------------------------------------


function logic_mark_breakage(cells, gems, marks, matches)
	local something_broke = false
	foreach(
		matches,
		function(match)
			foreach(
				match.positions,
				function(position)
					local neighbours = cells:neighbours(position)
					foreach(
						neighbours,
						function(n)
							local cell = (cells:get(n.position) or 0) & rock_mask
							if cell >= rock_full and cell <= rock_broken then
								marks:set(n.position, { name = "broken" })
								something_broke = true
							end
							local gem = gems:get(n.position) or 0
							if #match.positions > 3 then
								if gem == gem_cat or gem == gem_bat
									or gem == gem_robot_asleep
									or gem == gem_bomb
								then
									marks:set(n.position, { name = "broken" })
									something_broke = true
								elseif gem == gem_robot then
									gems:set(n.position, gem_robot_asleep2)
								end
							elseif gem == gem_bomb then
								marks:set(n.position, { name = "broken", exploded = true })
								something_broke = true
							end
						end
					)
				end
			)
		end
	)
	return something_broke
end


function logic_enact_breakage(cells, gems, marks)
	local to_be_unmarked = {}
	marks:foreachpos(
		function(position, mark)
			if mark.name == "broken" then
				local cell = cells:get(position) or 0
				if cell & rock_mask == rock_full then
					cells:set(position, (cell & cell_mask) | rock_cracked)
				elseif cell & rock_mask == rock_cracked then
					cells:set(position, (cell & cell_mask) | rock_broken)
				elseif cell & rock_mask == rock_broken then
					cells:set(position, (cell & cell_mask))
				end
				local gem = gems:get(position) or 0
				if gem == gem_cat or gem == gem_bat
					or gem == gem_robot_asleep
					or gem == gem_bomb
				then
					gems:del(position)
				end
				if gem == gem_bomb and mark.exploded then
					local neighbours = cells:blast_radius(position)
					foreach(
						neighbours,
						function(p)
							local cell = cells:get(p)
							if cell then
								cells:set(p, cell_bad | (cell & rock_mask))
							end
						end
					)
				end
				add(to_be_unmarked, position)
			end
		end
	)
	foreach(to_be_unmarked, function(p) marks:del(p) end)
end


-----------------------------------------------------------------------


function logic_mark_move(cells, gems, marks)
	local something_moved = false
	local movers = {}
	gems:foreachpos(
		function(position, gem)
			if gem == gem_cat or gem == gem_bat or gem == gem_robot then
				add(movers, position)
			elseif gem == gem_robot_asleep2 then
				gems:set(position, gem_robot_asleep)
			elseif gem == gem_robot_asleep then
				gems:set(position, gem_robot)
			end
		end
	)
	foreach(
		movers,
		function(position)
			local neighbours = cells:neighbours(position)
			local possibilities = {}
			foreach(
				neighbours,
				function(neighbour)
					local cell = cells:get(neighbour.position) or 0
					local gem = gems:get(neighbour.position) or 0
					if (cell & rock_mask == 0)
						and (cell & cell_mask != 0)
						and (gem < gem_rainbow)
					then
						add(possibilities, neighbour.position)
					end
				end
			)
			if #possibilities > 0 then
				something_moved = true
				local target = possibilities[math.random(1, #possibilities)]
				local moving_gem = gems:get(position)
				gems:del(position)
				local target_gem = gems:get(target)
				gems:set(target, moving_gem)
				local source_gem
				logic_fill_gem_at(cells, gems, marks, position)
				source_gem = gems:get(position)
				marks:set(target, {
					name = "moving",
					source = position,
					target = target,
					moving_gem = moving_gem,
					target_gem = target_gem,
					source_gem = source_gem,
				})
				if moving_gem == gem_bat or moving_gem == gem_robot then
					local cell = cells:get(target)
					cell = cell_bad | (cell & rock_mask)
					cells:set(target, cell)
				end
			end
		end
	)
	return something_moved
end


function logic_enact_move(cells, gems, marks)
	marks:foreachpos(
		function(position, mark)
			if mark.name == "moving" then
				if mark.moving_gem == gem_robot then
				end
			end
		end
	)
	marks:foreachpos(function(p, _) marks:del(p) end)
end
:: src/logic/shuffle.lua
--[[pod_format="raw",created="2024-09-13 09:11:02",modified="2025-02-23 15:09:04",revision=497]]

:: src/logic/spells.lua
--[[pod_format="raw",created="2024-08-30 06:37:36",modified="2024-09-07 08:00:48",revision=511]]
--- Spell Logic


function logic_gain_mana(stats, matches)
	local gained = false
	foreach(
		matches,
		function(match)
			local count = #(match.positions)
			if count > 3 then
				stats.mana += 10 * (count - 3)
				gained = true
			end
			if stats.in_cascade then
				stats.mana += 5
				gained = true
			end
			stats.in_cascade = true
			if match.colour == gem_rainbow then
				foreach(
					{ gem_air, gem_fire, gem_day, gem_earth, gem_water, gem_night },
					function(g) stats.colour[g] += count end
				)
			else
				stats.colours[match.colour] += count
			end
		end
	)
	return gained
end

:: src/logic/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTMwIDA2OjI0OjM5Iixtb2RpZmllZD0iMjAyNS0w
Mi0yMyAxNTowOTowNSJdXQ==
:: src/constants.lua
--[[pod_format="raw",created="2024-08-24 15:17:10",modified="2025-02-23 15:09:04",revision=3136]]
--- Match3 Global Constants


-- Gems and cells ------------------------------------------------------

-- Color gems
gem_air = 0x01
gem_fire = 0x02
gem_day = 0x03
gem_earth = 0x04
gem_water = 0x05
gem_night = 0x06
gem_rainbow = 0x07

gem_color_first = gem_air
gem_color_last = gem_rainbow

-- Black gems
gem_gift = 0x08
gem_bomb = 0x09
gem_cat = 0x0a
gem_bat = 0x0b
gem_robot = 0x0c
gem_robot_asleep = 0x0d
gem_robot_asleep2 = 0x0e

gem_names = {
	[gem_air] = "Air",
	[gem_fire] = "Fire",
	[gem_day] = "Day",
	[gem_earth] = "Earth",
	[gem_water] = "Water",
	[gem_night] = "Night",
	[gem_rainbow] = "Rainbow",
}


-- Cells
cell_mask = 0x03
cell_none = 0x00
cell_good = 0x01
cell_bad = 0x02

-- Rocks
rock_full = 0x10
rock_cracked = 0x20
rock_broken = 0x30
cell_door = 0x40
cell_chest_air = 0x50
cell_chest_fire = 0x60
cell_chest_day = 0x70
cell_chest_earth = 0x80
cell_chest_water = 0x90
cell_chest_night = 0xa0

rock_mask = 0xf0

:: src/gfx.lua
--[[pod_format="raw",created="2024-08-24 12:06:13",modified="2025-02-23 15:09:04",revision=4979]]
--- Graphics


local cell_width = 29
local cell_height = 29


function gfx_draw_cells(cells)
	local function draw_cell(p, cell)
		local x, y = cells:coords_cell(p)
		local sprite
		if cells:tiling() == "square" then
			if cell & cell_mask == cell_good then
				sprite = 32
				sprite += (p.x + p.y) % 2
			elseif cell & cell_mask == cell_bad then
				sprite = 34
				sprite += p.y % 2
			end
		elseif cells:tiling() == "hex" then
			if cell & cell_mask == cell_good then
				sprite = 40
				sprite += (p.y + (p.x * 3)) % 3
			elseif cell & cell_mask == cell_bad then
				sprite = 43
			end
		end
		spr(sprite, x, y)
		x, y = cells:coords_gem(p)
		if cell and cell & cell_mask == cell_bad then
			pal(53, 58)
		end
		if cell & rock_mask == 0 then
		elseif cell & rock_mask == rock_full then
			spr(48, x, y)
		elseif cell & rock_mask == rock_cracked then
			spr(49, x, y)
		elseif cell & rock_mask == rock_broken then
			spr(50, x, y)
		elseif cell & rock_mask == cell_door then
			spr(51, x, y)
		elseif cell & rock_mask == cell_chest_air then
			spr(52, x, y)
		elseif cell & rock_mask == cell_chest_fire then
			spr(53, x, y)
		elseif cell & rock_mask == cell_chest_day then
			spr(54, x, y)
		elseif cell & rock_mask == cell_chest_earth then
			spr(55, x, y)
		elseif cell & rock_mask == cell_chest_water then
			spr(56, x, y)
		elseif cell & rock_mask == cell_chest_night then
			spr(57, x, y)
		end	
		pal(53, 53)
	end
	cells:foreachpos(draw_cell)
	-- TODO: move border construction out of the hot loop
	local function draw_borders(p, cell)
		local x, y = cells:coords_cell(p)
		if cells:tiling() == "square" then
			local cell_S = cells:get(p + pos(0, 1))
			local cell_W = cells:get(p + pos(-1, 0))
			local cell_E = cells:get(p + pos(1, 0))
			local cell_N = cells:get(p + pos(0, -1))
			if cell & cell_good != 0 then
				if not cell_S or cell_S & cell_good == 0 then
					line(x, y + 28, x + 28, y + 28, 53)
				end
				if not cell_E or cell_E & cell_good == 0 then
					line(x + 28, y, x + 28, y + 28, 53)
				end
				if not cell_N or cell_N & cell_good == 0 then
					line(x, y, x + 28, y, 57)
				end
				if not cell_W or cell_W & cell_good == 0 then
					line(x, y, x, y + 28, 57)
				end
			elseif cell & cell_bad != 0 then
				if cell_N and cell_N & cell_good != 0 then
					line(x, y, x + 28, y, 58)
				end
				if cell_W and cell_W & cell_good != 0 then
					line(x, y, x, y + 28, 58)
				end
			end
		end
	end
	cells:foreachpos(draw_borders)
end


-----------------------------------------------------------------------


local sprites_color_gem = {
	[gem_air] = 1,
	[gem_fire] = 2,
	[gem_day] = 3,
	[gem_earth] = 4,
	[gem_water] = 5,
	[gem_night] = 6,
	[gem_rainbow] = 7,
}


local sprites_other_gem = {
	[gem_gift] = 8,
	[gem_bomb] = 9,
	[gem_cat] = 10,
	[gem_bat] = 11,
	[gem_robot] = 12,
	[gem_robot_asleep] = 13,
	[gem_robot_asleep2] = 13,
}

--color_gem_skin = math.random(0, 14)
color_gem_skin = 0
local function gem_sprite(gem)
	local base = 128 + color_gem_skin * 8
	if gem >= gem_air and gem <= gem_rainbow then
		return sprites_color_gem[gem] - 1 + base
	else
		return sprites_other_gem[gem]
	end
end


local function scaled_gem(sprite, x, y, size)
	local w, h = flr(29 * size + 0.5) // 2 * 2 + 1, flr(29 * size + 0.5) // 2 * 2 + 1
	local x, y = x + ((29 - w) / 2), y + ((29 - h) / 2)
	sspr(sprite, 0, 0, 29, 29, x, y, w, h)
end


local function draw_exploded_gem(gem, x, y, clock, new_clock)
	local size = 32 * new_clock
	local colour = 10 + (gem - 1) * 5
	oval(x - size, y - size, x + 29 + size, y + 29 + size, colour + 1)
	if clock < 0.25 then
		ovalfill(x + 2, y + 2, x + 25, y + 25, 7)
	elseif clock < 0.50 then
		ovalfill(x + 2, y + 2, x + 25, y + 25, colour + 2)
	elseif clock < 0.75 then
		ovalfill(x + 1, y + 1, x + 27, y + 27, colour + 1)
	elseif clock < 1.0 then
		ovalfill(x, y, x + 29, y + 29, colour)
	end
end


function gfx_draw_gems(cells, gems, states, clock)
	local function draw_gem(p, gem)
		local x, y = gems:coords_gem(p)
		local sprite = gem_sprite(gem)
		local cell = cells:get(p)
		if cell and cell & cell_mask == cell_bad then
			pal(53, 58)
		end
		local state = states:get(p)
		if not state or state.name == "broken" then
			spr(sprite, x, y)
		elseif state.name == "new" then
			scaled_gem(sprite, x, y, clock)
		elseif state.name == "matching" then
		elseif state.name == "falling" or state.name == "swapping"
		then
			local dest_x, dest_y = gems:coords_gem(state.target)
			local ix, iy = x + clock * (dest_x - x), y + clock * (dest_y - y)
			spr(sprite, ix, iy)
		elseif state.name == "moving" then
			x, y = gems:coords_gem(state.source, gem)
			local dest_x, dest_y = gems:coords_gem(state.target)
			scaled_gem(gem_sprite(state.target_gem), dest_x, dest_y, 1.0)
		end
		pal(53, 53)	
	end
	gems:foreachpos(draw_gem)
	local new_clock = clock * clock * clock * clock
	gems:foreachpos(
		function(p, gem)
			local x, y = gems:coords_gem(p)
			local sprite = gem_sprite(gem)
			local cell = cells:get(p)
			if cell and cell & cell_mask == cell_bad then
				pal(53, 58)
			end
			local state = states:get(p)
			if state and state.name == "matching" then
				draw_exploded_gem(gem, x, y, clock, new_clock)
			elseif state and state.name == "moving" then
				x, y = gems:coords_gem(state.source, gem)
				local dest_x, dest_y = gems:coords_gem(state.target)
				local ix, iy = x + clock * (dest_x - x), y + clock * (dest_y - y)
				spr(gem_sprite(state.moving_gem), ix, iy)
			end
		end
	)
end


-----------------------------------------------------------------------


function gfx_draw_turns(ox, oy, turn, anim_turn)
	spr(64, ox, oy)
	local hundreds = (turn // 100) % 10
	local tens = (turn // 10) % 10
	local ones = turn % 10
	local anim = anim_turn // 2
	pal(7, 1)
	clip(ox + 7, oy + 3, ox + 7 + 3 * 8, oy + 3 + 8)
	-- hundreds
	if anim == 0 or (turn % 100) > 0 then
		spr(65 + hundreds, ox + 7, oy + 6)
	else
		spr(65 + hundreds, ox + 7, oy + 6 + anim)
		spr(65 + ((hundreds - 1) % 10), ox + 7, oy + 6 + anim - 10)
	end
	-- tens
	if anim == 0 or ones > 0 then
		spr(65 + tens, ox + 7 + 8, oy + 6)
	else
		spr(65 + tens, ox + 7 + 8, oy + 6 + anim)
		spr(65 + ((tens - 1) % 10), ox + 7 + 8, oy + 6 + anim - 10)
	end
	-- ones
	spr(65 + ones, ox + 7 + 2 * 8, oy + 6 + anim)
	spr(65 + ((ones - 1) % 10), ox + 7 + 2 * 8, oy + 6 + anim - 10)
	clip()
	pal(7, 7)
end


function gfx_draw_mana(ox, oy, mana, zoomed)
	local base_char
	local char_width
	if zoomed then
		base_char = 85
		char_width = 11
		oy -= 3
	else
		base_char = 75
		char_width = 8
	end
	local thousands = (mana // 1000) % 10
	local hundreds = (mana // 100) % 10
	local tens = (mana // 10) % 10
	local ones = mana % 10
	local digits = 4
	if mana < 10 then
		digits = 1
	elseif mana < 100 then
		digits = 2
	elseif mana < 1000 then
		digits = 3
	else
		digits = 4
	end
	ox -= (digits * char_width) // 2
	if mana >= 1000 then
		spr(base_char + thousands, ox, oy)
		ox += char_width
	end
	if mana >= 100 then
		spr(base_char + hundreds, ox, oy)
		ox += char_width
	end
	if mana >= 10 then
		spr(base_char + tens, ox, oy)
		ox += char_width
	end
	spr(base_char + ones, ox, oy)
end


function gfx_draw_mana_bar(ox, oy, mana)
	spr(95, ox, oy)
	if mana == 0 then
		return
	end
	local size = min(91, flr(0.5 + 91*(mana / 250)))
	rectfill(ox+1, oy+2, ox+1+size, oy+5, 40)
	line(ox+1+size, oy+2, ox+1+size, oy+5, 39)
	line(ox+1, oy+2, ox+1, oy+5, 41)
	if size > 1 then
		line(ox+2, oy+1, ox+1+size-1, oy+1, 41)
		line(ox+2, oy+6, ox+1+size-1, oy+6, 39)
	end
end
:: src/hgrid.lua
--[[pod_format="raw",created="2024-08-25 08:16:09",modified="2024-09-13 09:08:06",revision=2694]]
--- Hex Grids

--- Hex grids use the "double height" coordinate system:
---
---     (0,0)         (2,0)         (4,0)
---            (1,1)         (3,1)
---     (0,2)         (2,2)         (4,2)
---            (1,3)         (3,3)
---     (0,4)         (2,4)         (4,4)
---
--- The origin of the grid, `pos(0, 0)`, is at the top left.


-- Local Constants --------------------------------------------------------


local max_width <const> = 13
local max_height <const> = 8


-- Constructors -----------------------------------------------------------


local metatable = {}


function hgrid_new()
	local grid = {}
	metatable.default_origin(grid)
	setmetatable(grid, { __index = metatable })
	for i = 0, max_width * max_height do
		grid[i] = false
	end
	return grid
end


function metatable:new_grid()
	return hgrid_new()
end


function metatable:clone()
	local grid = self:new_grid()
	grid.origin = self.origin
	self:foreachpos(function(p, item) grid:set(p, item) end)
	return grid
end


-- Indexing ------------------------------------------------------------


function metatable:tiling()
	return "hex"
end


function metatable:get(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	return self[p.x + ((p.y // 2) * max_width)]
end


function metatable:set(p, value)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	self[p.x + ((p.y // 2) * max_width)] = value
end


function metatable:merge(p, state)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	local index = p.x + ((p.y // 2) * max_width)
	if not self[index] then
		self[index] = {}
	end
	for k, v in pairs(state) do
		self[index][k] = v
	end
end


function metatable:del(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	self[p.x + ((p.y // 2) * max_width)] = false
end


-- Screen Coordinates ---------------------------------------------------------


function metatable:default_origin()
	self.origin = { x = 116, y = 7 }
end


function metatable:compute_origin()
	local min_p = pos(max_width, max_height)
	local max_p = pos(0, 0)
	self:foreachpos(
		function(position, cell)
			if not cell or cell == 0 then
				return
			end
			if position.x < min_p.x then min_p.x = position.x end
			if position.y < min_p.y then min_p.y = position.y end
			if position.x > max_p.x then max_p.x = position.x end
			if position.y > max_p.y then max_p.y = position.y end
		end
	)
	local width = 1 + max_p.x - min_p.x
	local height = 1 + max_p.y - min_p.y
	self.origin = {
		x = 110 + ((480 - 110) // 2) - ((width * 27) // 2) - (min_p.x * 27) - 4,
		y = (270 // 2) - ((height * 16) // 2) - (min_p.y * 16) - 8,
	}
end


function metatable:coords_origin()
	return self.origin.x, self.origin.y
end


function metatable:coords_cell(p)
	local ox, oy = self:coords_origin()
	return ox + p.x * 27, oy + p.y * 16
end


function metatable:coords_gem(p)
	local ox, oy = self:coords_origin()
	return ox + (p.x * 27) + 3, oy + (p.y * 16) + 1
end


function metatable:pos(x, y)
	local ox, oy = self:coords_origin()
	x -= ox
	y -= oy + 1
	local px, py = x // 27, y // 16
	local dx, dy = x - (px * 27), y - (py * 16)
	if dx < 8 then
		if (px + py) % 2 == 0 and dy < 14 + (-2 * dx) then
			px -= 1
			py -= 1
		elseif (px + py) % 2 != 0 and dy > -1 + (2 * dx) then
			px -= 1
		end
	end
	py = (2 * ((py - (px % 2)) // 2)) + (px % 2)
	return pos(px, py)
end


function metatable:distance(p0, p1)
	-- TODO: is this correct?
	return (abs(p0.x - p1.x) + abs(p0.y - p1.y)) // 2
end


-- Iterating ----------------------------------------------------------


function metatable:foreachpos(func)
	for x = 0, max_width do
		for y = x % 2, max_height * 2 - 1, 2 do
			local p = pos(x, y)
			local item = self:get(p)
			if item then
				func(p, item)
			end
		end
	end
end	


function metatable:neighbours(p)
	return {
		{ position = p + pos(1, 1), direction = "horizontal_SE" },
		{ position = p + pos(0, 2), direction = "vertical" },
		{ position = p + pos(-1, 1), direction = "horizontal_NE" },
		{ position = p + pos(-1, -1), direction = "horizontal_SE" },
		{ position = p + pos(0, -2), direction = "vertical" },
		{ position = p + pos(1, -1), direction = "horizontal_NE" },
	}
end


function metatable:blast_radius(p)
	return {
		p + pos(0, 0),
		p + pos(0, -2),
		p + pos(1, -1),
		p + pos(1, 1),
		p + pos(0, 2),
		p + pos(-1, 1),
		p + pos(-1, -1),
	}
end

:: src/in_editor.lua
--[[pod_format="raw",created="2024-08-30 08:13:35",modified="2024-09-13 09:08:06",revision=929]]
in_editor = {}

local tiling = "square"

local cells = false
local gems = false
local marks = false

local active_tool = 0
local ox, oy = 8, 8
local sx, sy = 32, 32

local tools = {
	[0] = cell_none,
	cell_good,
	cell_bad,
	rock_full,
	rock_cracked,
	rock_broken,
	cell_chest_air,
	cell_chest_fire,
	cell_chest_day,
	cell_chest_earth,
	cell_chest_water,
	cell_chest_night,
	cell_door,
	false,
	false,
	gem_gift,
	gem_bomb,
	false,
	gem_cat,
	gem_bat,
	gem_robot,
	false,
	false,
}



function in_editor:enter()
	if not cells then
		cells = logic_new_test_cells(tiling, true)
		gems = cells:new_grid()
	end
	cells:default_origin()
	gems:default_origin()
	marks = cells:new_grid()
end


function in_editor:exit()
end


function in_editor:update()
	if keyp("s") then
		tiling = "square"
		cells = false
		in_editor:enter()
	end
	if keyp("h") then
		tiling = "hex"
		cells = false
		in_editor:enter()
	end
	local mx, my, mb, _, _ = mouse()
	if mb == 0x1 and mx < 110 then
		mx -= ox
		my -= oy
		local x, y = clamp(mx // sx, 0, 2), clamp(my // sy, 0, 7)
		active_tool = clamp(x + 3 * y, 0, 22)
	elseif mb == 0x1 then
		local mp = cells:pos(mx, my)
		local tool = tools[active_tool]
		if tool == cell_none then
			local cell = cells:get(mp) or cell_none
			cell = (cell & ~cell_mask) | tool
			cells:set(mp, cell)
			gems:del(mp)
		elseif tool == cell_good or tool == cell_bad then
			local cell = cells:get(mp) or cell_none
			cell = (cell & ~cell_mask) | tool
			cells:set(mp, cell)
		elseif active_tool <= 12 then 
			local cell = cells:get(mp) or cell_none
			cell = (cell & cell_mask) | tool
			cells:set(mp, cell)
			gems:del(mp)
		elseif cells:get(mp) and cells:get(mp) & cell_mask != 0 then
			gems:set(mp, tool)
			local cell = cells:get(mp) or cell_none
			cell = (cell & cell_mask)
			cells:set(mp, cell)
		end
	end
	if mb == 0x2 then
		local mp = cells:pos(mx, my)
		local cell = cells:get(mp) or cell_none
		cell = (cell & cell_mask)
		cells:set(mp, cell)
		gems:del(mp)
	end
	if keyp("g") then
		in_game:load_from_editor(tiling, cells, gems)
		return in_game
	end
	return false
end


function in_editor:draw()
	cls(63)
	if not cells then
		return
	end
	local mx, _, _, _, _ = mouse()
	if mx <= 110 then
		window { cursor = "pointer" }
	else
		window { cursor = "crosshair" }
	end
	gfx_draw_cells(cells)
	gfx_draw_gems(cells, gems, marks, 0.0)
	-- Draw the panel
	rectfill(0, 0, 110, 269, 55)
	rectfill(ox, oy, ox + 28, oy + 28, 63)
	spr(33, ox + 1 * sx, oy + 0 * sy)
	spr(34, ox + 2 * sx, oy + 0 * sy)
	spr(48, ox + 0 * sx, oy + 1 * sy)
	spr(49, ox + 1 * sx, oy + 1 * sy)
	spr(50, ox + 2 * sx, oy + 1 * sy)
	spr(52, ox + 0 * sx, oy + 2 * sy)
	spr(53, ox + 1 * sx, oy + 2 * sy)
	spr(54, ox + 2 * sx, oy + 2 * sy)
	spr(55, ox + 0 * sx, oy + 3 * sy)
	spr(56, ox + 1 * sx, oy + 3 * sy)
	spr(57, ox + 2 * sx, oy + 3 * sy)
	spr(51, ox + 0 * sx, oy + 4 * sy)

	spr(8, ox + 0 * sx, oy + 5 * sy)
	spr(9, ox + 1 * sx, oy + 5 * sy)
--	spr(11, ox + 2 * sx, oy + 5 * sy)
	spr(10, ox + 0 * sx, oy + 6 * sy)
	spr(11, ox + 1 * sx, oy + 6 * sy)
	spr(12, ox + 2 * sx, oy + 6 * sy)
--	spr(14, ox + 0 * sx, oy + 7 * sy)
--	spr(15, ox + 1 * sx, oy + 7 * sy)

	local x, y = active_tool % 3, active_tool // 3
	rect(ox + x * sx - 1, oy + y * sy - 1, ox + x * sx + 29, oy + y * sy + 29, 7)
end
:: src/in_game.lua
--[[pod_format="raw",created="2024-08-27 17:11:11",modified="2025-02-23 15:09:04",revision=4192]]
in_game = {}


-- The Board
local tiling = "square"
local gravity = pos(0, 1)

local cells = false
local gems = false
local marks = false

local matches = {}

local prev_cells = false
local prev_gems = false
local prev_stats = false

-- State Machine
local editor_requested = false
local substate = false
local clock = 0.0
local interaction = false

local starting_stats = {
	turn = 0,
	mana = 0,
	colours = {
		[gem_air] = 0,
		[gem_fire] = 0,
		[gem_day] = 0,
		[gem_earth] = 0,
		[gem_water] = 0,
		[gem_night] = 0,
	},
	in_cascade = false,
}
local stats = deep_copy(starting_stats)
local anim_turn = 0
local displayed_mana = 0
local star_seed = 37


-----------------------------------------------------------------------


-- Functions for substate need to be global, because of Lua
-- forward-declaration rule for locals.


function creating_the_board()
--	cells = logic_new_test_cells(tiling)
--	gems = cells:new_grid()
	cells:compute_origin()
	gems.origin = cells.origin
	marks = cells:new_grid()
	matches = {}
	stats = deep_copy(starting_stats)
	anim_turn = 0
	displayed_mana = 0
	star_seed = math.random(37, 6584587)
	return creating_missing_gems
end


function creating_missing_gems()
	if clock == 0.0 then
		logic_fill_gems(cells, gems, marks)
	end
	clock += 1.0 / 8.0
	if clock < 1.0 then
		return creating_missing_gems
	end
	-- Clean-up
	marks:foreachpos(
		function(p, mark)
			if mark.name == "new" then
				marks:del(p)
			end
		end
	)
	return moving_things
end


function moving_things()
	if clock == 0.0 and stats.turn > 0 then
		local something_moved = logic_mark_move(cells, gems, marks)
		if not something_moved then
			return starting_new_turn
		end
	end
	clock += 1.0 / 16.0
	if clock < 1.0 then
		return moving_things
	end
	logic_enact_move(cells, gems, marks)
	return starting_new_turn
end


function starting_new_turn()
	stats.turn += 1
	anim_turn = 20
	stats.in_cascade = false
	return waiting_for_input
end


function waiting_for_input()
	local mx, my, mb, _, _ = mouse()
	if mb == 0x1 then
		local mp = cells:pos(mx, my)
		if gems:get(mp) then
			interaction = { name = "swap", position = mp, start = t() }
			return waiting_for_swap
		end
	end
	if keyp("del") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:set(p, gem_gift)
		marks = cells:new_grid()
		matches = {}
	end
	if keyp("w") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:set(p, gem_rainbow)
		marks:set(p, { name = "new" })
		matches = {}
		return checking_matches
	end
	if keyp("r") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		cells:set(p, (cells:get(p) or 0) | rock_full)
		gems:del(p)
		matches = {}
		return checking_matches
	end
	if keyp("a") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:set(p, gem_air)
		marks:set(p, { name = "new" })
		matches = {}
		return checking_matches
	end
	if keyp("m") then
		return checking_matches
	end
	if keyp("e") then
		editor_requested = true
		return creating_the_board
	end
	if keyp("z") then
		cells = prev_cells:clone()
		gems = prev_gems:clone()
		marks = cells:new_grid()
		stats = deep_copy(prev_stats)
	end
	if keyp("1") then color_gem_skin = 5 end
	if keyp("2") then color_gem_skin = 8 end
	if keyp("3") then color_gem_skin = 10 end
	if keyp("4") then
		color_gem_skin = (color_gem_skin - 1) % 15
	end
	if keyp("5") then color_gem_skin = 0 end
	if keyp("6") then
		color_gem_skin = (color_gem_skin + 1) % 15
	end
	if keyp("7") then color_gem_skin = 2 end
	if keyp("8") then
		local prev = color_gem_skin
		while prev == color_gem_skin do
			color_gem_skin = math.random(0, 14)
		end
	end
	if keyp("9") then color_gem_skin = 15 end
	return waiting_for_input
end


function waiting_for_swap()
	local mx, my, mb, _, _ = mouse()
	if mb != 0x1 then
		interaction = false
		return waiting_for_input
	end
	local mp = cells:pos(mx, my)
	if cells:distance(mp, interaction.position) != 1
		or (not gems:get(mp))
	then
		return waiting_for_swap
	end
	local success = logic_mark_swap(gems, marks, interaction.position, mp)
	interaction = false
	if not success then
		return waiting_for_input
	end
	prev_cells = cells:clone()
	prev_gems = gems:clone()
	prev_stats = deep_copy(stats)
	return swapping_two_gems
end


function swapping_two_gems()
	clock += 1.0 / 16.0
	if clock < 1.0 then
		return swapping_two_gems
	end
	logic_enact_swap(gems, marks)
	return checking_matches
end


function checking_matches()
	matches, marks = logic_find_matches(cells, gems)
	if #matches > 0 then
		local _ = logic_gain_mana(stats, matches)
		return clearing_gems
	end
	return creating_missing_gems
end


function clearing_gems()
	clock += 1.0 / 16.0
	if clock < 1.0 then
		return clearing_gems
	end
	logic_enact_clear(gems, marks)
	return repairing_cells
end


local repairing_done = false
function repairing_cells()
	if clock == 0.0 then
		local is_something_repaired = logic_mark_repair(cells, marks, matches)
		if not is_something_repaired then
			return breaking_things
		end
	end
	clock += 1.0 / 16.0
	if clock < 0.5 then
		repairing_done = false
		return repairing_cells
	elseif not repairing_done then
		logic_enact_repair(cells, marks)
		repairing_done = true
		return repairing_cells
	elseif clock < 1.0 then
		return repairing_cells
	end
	return breaking_things
end


local breaking_done = false
function breaking_things()
	if clock == 0.0 then
		local something_broke = logic_mark_breakage(cells, gems, marks, matches)
		if not something_broke then
			return applying_gravity
		end
		breaking_done = false
	end
	clock += 1.0 / 32.0
	if clock < 0.5 then
		return breaking_things
	elseif not breaking_done then
		logic_enact_breakage(cells, gems, marks)
		breaking_done = true
		return breaking_things
	elseif clock < 1.0 then
		return breaking_things
	end
	return applying_gravity
end


function applying_gravity()
	if clock == 0.0 then
		local some_gems_are_falling = logic_mark_gravity(cells, gems, marks, gravity)
		if not some_gems_are_falling then
			return creating_missing_gems
		end
	end
	clock += 1.0 / 16.0
	if clock < 1.0 then
		return applying_gravity
	end
	logic_enact_gravity(gems, marks)
	return checking_matches
end


-----------------------------------------------------------------------


function in_game:load_from_editor(ed_tiling, ed_cells, ed_gems)
	tiling = ed_tiling
	if tiling == "square" then
		gravity = pos(0, 1)
	else
		gravity = pos(0, 2)
	end
	cells = ed_cells:clone()
	gems = ed_gems:clone()
	marks = cells:new_grid()
	matches = {}
	stats = deep_copy(starting_stats)
	substate = creating_the_board
end


-----------------------------------------------------------------------


function in_game:enter()
	editor_requested = false
	if not substate then
		substate = creating_the_board
	end
end


function in_game:exit()
end


function in_game:update()
	local next = substate()
	if next != substate then
		clock = 0.0
		substate = next
	end
	if anim_turn > 0 then
		anim_turn -= 1
	end
	if displayed_mana < stats.mana then
		displayed_mana += 0.50
	elseif displayed_mana >= stats.mana then
		displayed_mana = stats.mana
	end
	if editor_requested then
		return in_editor
	end
	return false
end


function in_game:draw()
	if not cells then
		return
	end
	-- Starry background
	local hash = star_seed
	for x = 0, 9 do
		for y = 0, 6 do
			hash = hash~(hash << 13); hash = hash~(hash >> 17); hash = hash~(hash << 5)
			local flipped = (x+y)%2 == 0
			spr(120 + (hash%8), 110 + x * 40, 0 + y * 40, flipped, flipped)
		end
	end
	-- Draw the board
	gfx_draw_cells(cells)
	gfx_draw_gems(cells, gems, marks, clock)
	-- Draw the panel
	rectfill(0, 0, 110, 269, 60)
	line(0, 0, 110, 0, 62)
	line(0, 50, 110, 50, 62)
	line(0, 0, 0, 269, 62)
	line(110, 0, 110, 269, 58)
	line(0, 49, 110, 49, 58)
	line(0, 269, 110, 269, 58)
	-- Top bar
	spr(102, 6, 10)
	spr(98, 14, 5)
	gfx_draw_turns(37, 2, stats.turn, anim_turn)
	spr(100, 79, 5)
	spr(102, 101, 10)
	-- Mana
	spr(104, 16, 56)
	gfx_draw_mana(56, 56, flr(displayed_mana), displayed_mana < stats.mana)
	spr(105, 71, 56)
	gfx_draw_mana_bar(8, 71, flr(displayed_mana))
	for i = 0, 5 do
		spr(96, 4, 84 + i * 30)
	end
	cursor(11, 95, 58)
	print("Change Gravity")
	cursor(10, 94, 22)
	print("Change Gravity")
	--[[
	print("")
	print("Air: " .. tostr(stats.colours[gem_air]))
	print("Fire: " .. tostr(stats.colours[gem_fire]))
	print("Day: " .. tostr(stats.colours[gem_day]))
	print("Earth: " .. tostr(stats.colours[gem_earth]))
	print("Water: " .. tostr(stats.colours[gem_water]))
	print("Night: " .. tostr(stats.colours[gem_night]))
	]]--
	-- Update the cursor
	local mx, my = mouse()
	local cursor_pos = cells:pos(mx, my)
	local cell = cells:get(cursor_pos)
	if cell and cell != 0 then
		window { cursor = "grab" }
	else
		window { cursor = "" }
	end
	if false then
		rectfill(mx + 4 - 10, my + 10, mx + 36, my + 20, 7)
		print(tostr(cursor_pos.x)..","..tostr(cursor_pos.y), mx + 6 - 10, my + 12, 0)
	end
end
:: src/sgrid.lua
--[[pod_format="raw",created="2024-08-24 07:17:45",modified="2024-09-13 09:08:06",revision=3313]]
--- Square Grids

--- The origin of the grid, `pos(0, 0)`, is at the top left.


-- Local Constants --------------------------------------------------------


local max_width <const> = 12
local max_height <const> = 9


-- Constructors -----------------------------------------------------------


local metatable = {}


function metatable:new_grid()
	return sgrid_new()
end


function sgrid_new()
	local grid = {}
	metatable.default_origin(grid)
	setmetatable(grid, { __index = metatable })
	for i = 0, max_width * max_height do
		grid[i] = false
	end
	return grid
end


function metatable:clone()
	local grid = self:new_grid()
	grid.origin = self.origin
	self:foreachpos(function(p, item) grid:set(p, item) end)
	return grid
end


-- Indexing --------------------------------------------------------------------


function metatable:tiling()
	return "square"
end


function metatable:get(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	return self[p.x + (p.y * max_width)]
end


function metatable:set(p, value)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	self[p.x + (p.y * max_width)] = value
end


function metatable:merge(p, state)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	local index = p.x + (p.y * max_width)
	if not self[index] then
		self[index] = {}
	end
	for k, v in pairs(state) do
		self[index][k] = v
	end
end


function metatable:del(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	self[p.x + (p.y * max_width)] = false
end


function metatable:distance(p0, p1)
	return abs(p0.x - p1.x) + abs(p0.y - p1.y)
end


-- Screen Coordinates ---------------------------------------------------------


function metatable:default_origin()
	self.origin = { x = 121, y = 4 }
end


function metatable:compute_origin()
	local min_p = pos(max_width, max_height)
	local max_p = pos(0, 0)
	self:foreachpos(
		function(position, cell)
			if not cell or cell == 0 then
				return
			end
			if position.x < min_p.x then min_p.x = position.x end
			if position.y < min_p.y then min_p.y = position.y end
			if position.x > max_p.x then max_p.x = position.x end
			if position.y > max_p.y then max_p.y = position.y end
		end
	)
	local width = 1 + max_p.x - min_p.x
	local height = 1 + max_p.y - min_p.y
	self.origin = {
		x = 110 + ((480 - 110) // 2) - ((width * 29) // 2) - (min_p.x * 29),
		y = (270 // 2) - ((height * 29) // 2) - (min_p.y * 29),
	}
end


function metatable:coords_origin()
	return self.origin.x, self.origin.y
end


function metatable:coords_cell(p)
	local ox, oy = self:coords_origin()
	return ox + p.x * 29, oy + p.y * 29
end


function metatable:coords_gem(p)
	local ox, oy = self:coords_origin()
	return ox + p.x * 29, oy + p.y * 29
end


function metatable:pos(x, y)
	local ox, oy = self:coords_origin()
	return pos((x - ox) // 29, (y - oy) // 29)
end


-- Iterating -------------------------------------------------------


function metatable:foreachpos(func)
	local p = pos(0, 0)
	for x = 0, max_width do
		for y = 0, max_height do
			local p = pos(x, y)
			local item = self:get(p)
			if item then
				func(p, item)
			end
		end
	end
end	


function metatable:neighbours(p)
	return {
		{ position = p + pos(1, 0), direction = "horizontal" },
		{ position = p + pos(0, 1), direction = "vertical" },
		{ position = p + pos(-1, 0), direction = "horizontal" },
		{ position = p + pos(0, -1), direction = "vertical" },
	}
end


function metatable:blast_radius(p)
	return {
		p + pos(0, 0),
		p + pos(1, 0),
		p + pos(1, 1),
		p + pos(0, 1),
		p + pos(-1, 1),
		p + pos(-1, 0),
		p + pos(-1, -1),
		p + pos(0, -1),
		p + pos(1, -1),
	}
end

:: src/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTI0IDA3OjE3OjA5Iixtb2RpZmllZD0iMjAyNS0w
Mi0yMyAxNTowOTowNSJdXQ==
:: debug.lua
--[[pod_format="raw",created="2024-08-24 12:45:09",modified="2024-09-01 05:15:15",revision=75]]
-- Detect uninitialized globals and typos
-- from @snowkittykira from the BBS


-- if you're using include(), include this after including everything else,
-- since most included modules will need to assign global variables on load

-- these globals are needed by picotron
_init = _init or false
_draw = _draw or false
_update = _update or false
-- these are used by the picotron terminal
cproj_draw = cproj_draw or false
cproj_update = cproj_update or false
_ = _ or false
_is_terminal_command = _is_terminal_command or false
k = k or false
res = res or false
-- gui needs these
drag_t = drag_t or false

local function unknown_variable (t, k)
  error (debug.traceback ('unknown variable ' .. tostring (k), 2))
end

setmetatable (_G, {
  __index = unknown_variable,
  __newindex = unknown_variable,
})
:: drakma.lua
b64$LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNC0wNC0wNyAwNzo0Mjo0NSIsbW9k
aWZpZWQ9IjIwMjQtMDktMTMgMDk6MzQ6MjQiLHJldmlzaW9uPTE1MDddXQpfbW9kdWxlcyA9IHt9
CgotLSBBICdyZXF1aXJlJyBmdW5jdGlvbiBzaW1pbGFyIHRvIHN0YW5kYXJkIEx1YS4KLS0gSWRl
YSBmcm9tIGVsZ29waGVyIG9uIHRoZSBCQlMKZnVuY3Rpb24gcmVxdWlyZShuYW1lKQoJbG9jYWwg
Y2FjaGVkID0gX21vZHVsZXNbbmFtZV0KCWlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQKCglsb2Nh
bCBmaWxlbmFtZSA9IGZ1bGxwYXRoKG5hbWUgLi4gJy5sdWEnKQoJbG9jYWwgc3JjID0gZmV0Y2go
ZmlsZW5hbWUpIAoKCWlmICh0eXBlKHNyYykgIT0gInN0cmluZyIpIHBhbmljKCJjb3VsZCBub3Qg
aW5jbHVkZSAiIC4uIGZpbGVuYW1lKQoKCS0tIGh0dHBzOi8vd3d3Lmx1YS5vcmcvbWFudWFsLzUu
NC9tYW51YWwuaHRtbCNwZGYtbG9hZAoJLS0gY2h1bmsgbmFtZSAoZm9yIGVycm9yIHJlcG9ydGlu
ZykKCS0tIG1vZGUgKCJ0IiBmb3IgdGV4dCBvbmx5IC0tIG5vIGJpbmFyeSBjaHVuayBsb2FkaW5n
KQoJLS0gX0VOViB1cHZhbHVlCgktLSBAIGlzIGEgc3BlY2lhbCBjaGFyYWN0ZXIgdGhhdCB0ZWxs
cyBkZWJ1Z2dlciB0aGUgc3RyaW5nIGlzIGEgZmlsZW5hbWUKCWxvY2FsIGZ1bmMsIGVyciA9IGxv
YWQoc3JjLCAiQCIgLi4gZmlsZW5hbWUsICJ0IiwgX0VOVikKCWlmIChub3QgZnVuYykgcGFuaWMo
IlN5bnRheCBlcnJvcjoiLCB0b3N0cihlcnIpKQoKCWxvY2FsIG1vZHVsZSA9IGZ1bmMoKQoJX21v
ZHVsZXNbbmFtZV0gPSBtb2R1bGUKCglyZXR1cm4gbW9kdWxlCmVuZAoKCmZ1bmN0aW9uIHBhbmlj
KC4uLikKCWxvY2FsIGFyZ3MgPSB7IC4uLiB9Cglmb3JlYWNoKAoJCWFyZ3MsCgkJZnVuY3Rpb24o
c3RyKQoJCQlzZW5kX21lc3NhZ2UoMywgeyBldmVudCA9ICJyZXBvcnRfZXJyb3IiLCBjb250ZW50
ID0gc3RyIH0pCgkJZW5kCgkpCglzdG9wKCkKZW5kCgoKLS0gVGFibGUgdXRpbGl0eSBmdW5jdGlv
bnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0KCgpmdW5jdGlvbiBpc19lbXB0eSh0KQoJcmF3ZXF1YWwobmV4dCh0KSwgbmlsKQplbmQKCmZ1
bmN0aW9uIGRlZXBfY29weSh0LCBhbHJlYWR5KQoJaWYgKG5vdCBhbHJlYWR5KSBhbHJlYWR5ID0g
e30KCWlmIHR5cGUodCkgPT0gInRhYmxlIiB0aGVuCgkJaWYgYWxyZWFkeSBhbmQgYWxyZWFkeVt0
XSB0aGVuCgkJCXJldHVybiBhbHJlYWR5W3RdCgkJZW5kCgkJbG9jYWwgbmV3ID0ge30KCQlhbHJl
YWR5W3RdID0gbmV3CgkJZm9yIGssIHYgaW4gcGFpcnModCkgZG8KCQkJbmV3W2tdID0gZGVlcF9j
b3B5KHYsIGFscmVhZHkpCgkJZW5kCgkJcmV0dXJuIG5ldwoJZWxzZQoJCXJldHVybiB0CgllbmQK
ZW5kCgoKZnVuY3Rpb24gdG9zdHJyZWModCkKCWlmIHR5cGUodCkgIT0gInRhYmxlIiB0aGVuCgkJ
cmV0dXJuIHRvc3RyKHQpCgllbmQKCQoJbG9jYWwgcyA9IG5pbAoJZm9yIGssIHYgaW4gcGFpcnMo
dCkgZG8KCQlpZiBub3QocykgdGhlbgoJCQlzID0gInsgIgoJCWVsc2UKCQkJcyAuLj0gIiwgIgoJ
CWVuZAoJCXMgLi49IHRvc3RyKGspIC4uICIgPSAiIC4uIHRvc3RycmVjKHYpCgllbmQKCWlmIG5v
dCBzIHRoZW4KCQlyZXR1cm4gInt9IgoJZW5kCglzIC4uPSAiIH0iCgoJcmV0dXJuIHMKZW5kCgoK
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCgpmdW5jdGlvbiBjbGFtcCh2LCBtaW4sIG1heCkKCWlm
IHYgPCBtaW4gdGhlbgoJCXJldHVybiBtaW4KCWVuZAoJaWYgdiA_IG1heCB0aGVuCgkJcmV0dXJu
IG1heAoJZW5kCglyZXR1cm4gdgplbmQKCgpmdW5jdGlvbiBleHBfZGVjYXkoYSwgYiwgZGVjYXks
IGR0KQoJLS0tIExlcnAgc21vb3RoaW5nLCBidXQgZnJhbWVyYXRlLWluZGVwZW5kYW50LCBmcm9t
IEZyZXlhIEhvbG3DqXIKCS0tLSBodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PUxTTlF1
RkVET3lRCgktLS0gVXNlIGFzIGBhID0gZXhwX2RlY2F5KGEsIGIsIGRlY2F5LCBkdClgCglyZXR1
cm4gYiArIChhIC0gYikgKiBtYXRoLmV4cCgtIGRlY2F5ICogZHQpCmVuZAoKCi0tIFBvcyAtLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLQoKCi0tIFdBUk5JTkc6IGRvIG5vdCBmb3JnZXQgdGhhdCBgcG9zYCBpcyBh
IHJlZmVyZW5jZSB0eXBlLCBub3QgYSB2YWx1ZToKLS0gYXZvaWQgbW9kaWZ5aW5nIGluIHBsYWNl
LgpmdW5jdGlvbiBwb3MoeCwgeSkKCWxvY2FsIHAgPSB1c2VyZGF0YSgiaTE2IiwgMikKCXAueCA9
IHgKCXAueSA9IHkKCXJldHVybiBwCmVuZAoKCi0tIERyYXdpbmcgLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoK
Ci0tIEZyb20gU29waGllIG9uIHRoZSBkaXNjb3JkCmZ1bmN0aW9uIGdldF9kcmF3c3BhY2UoKQog
ICAgcmV0dXJuIHsKICAgICAgICBjYW1feD1wZWVrNCgweDU1MTApLAogICAgICAgIGNhbV95PXBl
ZWs0KDB4NTUxNCksCiAgICAgICAgY2xpcF9sPXBlZWsyKDB4NTUyOCksCiAgICAgICAgY2xpcF90
PXBlZWsyKDB4NTUyYSksCiAgICAgICAgY2xpcF9yPXBlZWsyKDB4NTUyYyksCiAgICAgICAgY2xp
cF9iPXBlZWsyKDB4NTUyZSksCiAgICB9CmVuZAoKCmZ1bmN0aW9uIHNldF9kcmF3c3BhY2UoZHJh
d3NwYWNlKQogICAgcG9rZTQoMHg1NTEwLGRyYXdzcGFjZS5jYW1feCkKICAgIHBva2U0KDB4NTUx
NCxkcmF3c3BhY2UuY2FtX3kpCiAgICBwb2tlMigweDU1MjgsZHJhd3NwYWNlLmNsaXBfbCkKICAg
IHBva2UyKDB4NTUyYSxkcmF3c3BhY2UuY2xpcF90KQogICAgcG9rZTIoMHg1NTJjLGRyYXdzcGFj
ZS5jbGlwX3IpCiAgICBwb2tlMigweDU1MmUsZHJhd3NwYWNlLmNsaXBfYikKZW5k
:: main.lua
--[[pod_format="raw",created="2024-03-30 05:39:34",modified="2025-02-23 15:09:04",revision=4871]]
include "drakma.lua"
include "src/constants.lua"
include "src/sgrid.lua"
include "src/hgrid.lua"
include "src/logic/creation.lua"
include "src/logic/matching.lua"
include "src/logic/spells.lua"
include "src/logic/mechanics.lua"
include "src/gfx.lua"
include "src/in_game.lua"
include "src/in_editor.lua"
--include "debug.lua"


local state = in_editor
--local state = in_game
local next_state = false


function _init()
	window { cursor = "" }
	fetch("pal/0.pal"):poke(0x5000)
	state:enter()
end


function _update()
	if next_state then
		state:exit()
		state = next_state
		state:enter()
	end
	next_state = state:update()
end


function _draw()
	state:draw()
	print(string.format("\014% 3.0f", (stat(1) * 100.0)) .. "%", 460, 264, 1)
end
:: .info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTIzIDE4OjQ1OjEzIixtb2RpZmllZD0iMjAyNS0w
Mi0yMyAxNTowOTowNSIscnVudGltZT0xMyxzdG9yZWQ9IjIwMjQtMDMtMzAgMDY6NTQ6MjQiLHdv
cmtzcGFjZXM9e3tsb2NhdGlvbj0ibWFpbi5sdWEjMTIiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9j
YXRpb249InNyYy9pbl9nYW1lLmx1YSMxIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJz
cmMvbG9naWMvY3JlYXRpb24ubHVhIzEiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InNy
Yy9sb2dpYy9zaHVmZmxlLmx1YSMxIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJzcmMv
Y29uc3RhbnRzLmx1YSMxIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJzcmMvZ2Z4Lmx1
YSMxIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJnZngvMC5nZngiLHdvcmtzcGFjZV9p
bmRleD0yfSx7bG9jYXRpb249InNmeC8wLnNmeCIsd29ya3NwYWNlX2luZGV4PTR9LHtsb2NhdGlv
bj0icGFsLzAucGFsIix3b3Jrc3BhY2VfaW5kZXg9N319XV0=
:: [eoc]
