picotron cartridge // www.picotron.net
version 2

:: docs/
:: gfx/
:: map/
:: pal/
:: sfx/
:: src/
:: src/logic/
:: debug.lua
--[[pod_format="raw",created="2024-08-24 12:45:09",modified="2025-11-25 20:56:55",revision=1245]]
-- Detect uninitialized globals and typos
-- from @snowkittykira from the BBS


-- if you're using include(), include this after including everything else,
-- since most included modules will need to assign global variables on load

-- these globals are needed by picotron
_init = _init or false
_draw = _draw or false
_update = _update or false
-- these are used by the picotron terminal
cproj_draw = cproj_draw or false
cproj_update = cproj_update or false
_ = _ or false
_is_terminal_command = _is_terminal_command or false
k = k or false
res = res or false
-- gui needs these
drag_t = drag_t or false

local function unknown_variable (t, k)
  error (debug.traceback ('unknown variable ' .. tostring (k), 2))
end

setmetatable (_G, {
  __index = unknown_variable,
  __newindex = unknown_variable,
})
:: main.lua
--[[pod_format="raw",created="2024-03-30 05:39:34",modified="2025-11-25 20:56:55",revision=6041]]
include "drakma.lua"
include "src/constants.lua"
include "src/sgrid.lua"
include "src/hgrid.lua"
include "src/logic/creation.lua"
include "src/logic/matching.lua"
include "src/logic/spells.lua"
include "src/logic/mechanics.lua"
include "src/gfx.lua"
include "src/in_game.lua"
include "src/in_editor.lua"
--include "debug.lua"


local state = in_editor
--local state = in_game
local next_state = false


function _init()
	window { cursor = "" }
	fetch("pal/1.pal"):poke(0x5000)
	for c = 0, 63 do
		for i = 0, 63 do
			poke(0xa000 + (7 * 64) + i, i + 1)
			--poke(0xb000 + (c * 64) + i, i + 1)
		end
	end
	poke(0xb000 + (7 * 64) + 2, 3)
--	poke(0xb000 + (7 * 64) + 3, 4)
	state:enter()
end


function _update()
	if next_state then
		state:exit()
		state = next_state
		state:enter()
	end
	next_state = state:update()
end


function _draw()
	state:draw()
	print(string.format("\014% 3.0f", (stat(1) * 100.0)) .. "%", 460, 1, 1)
end

:: src/constants.lua
--[[pod_format="raw",created="2024-08-24 15:17:10",modified="2025-11-25 20:56:55",revision=4306]]
--- Match3 Global Constants


-- Gems and cells ------------------------------------------------------

-- Cells
cell_mask = 0x3
cell_none = 0x0
cell_good = 0x1
cell_bad = 0x2

-- Obstacles
rock_full = 0x10
rock_cracked = 0x20
rock_broken = 0x30
cell_door = 0x40
cell_chest_air = 0x50
cell_chest_fire = 0x60
cell_chest_day = 0x70
cell_chest_earth = 0x80
cell_chest_water = 0x90
cell_chest_night = 0xa0

obstacle_mask = 0xf0

-- Color gems
gem_air = 0x100
gem_fire = 0x200
gem_day = 0x300
gem_earth = 0x400
gem_water = 0x500
gem_night = 0x600
gem_white = 0x700
gem_rainbow = 0x800

gem_color_first = gem_air
gem_color_last = gem_rainbow

-- Black gems
gem_gift = 0x900
gem_bomb = 0xa00
gem_cat = 0xb00
gem_bat = 0xc00
gem_robot = 0xd00
gem_robot_asleep = 0xe00
gem_robot_asleep2 = 0xf00

gem_names = {
	[gem_air] = "Air",
	[gem_fire] = "Fire",
	[gem_day] = "Day",
	[gem_earth] = "Earth",
	[gem_water] = "Water",
	[gem_night] = "Night",
	[gem_white] = "White",
	[gem_rainbow] = "Rainbow",
}


----------------------------------------------------------------------




sprites_color_gem = {
	[gem_air] = 1,
	[gem_fire] = 2,
	[gem_day] = 3,
	[gem_earth] = 4,
	[gem_water] = 5,
	[gem_night] = 6,
	[gem_white] = 7,
	[gem_rainbow] = 8,
}


sprites = {
	[gem_air] = 128,
	[gem_fire] = 129,
	[gem_day] = 130,
	[gem_earth] = 131,
	[gem_water] = 132,
	[gem_night] = 133,
	[gem_white] = 134,
	[gem_rainbow] = 135,
	[cell_none] = 31,
	[cell_good] = 32,
	[cell_bad] = 34,
	[gem_gift] = 8,
	[gem_bomb] = 9,
	[gem_cat] = 24,
	[gem_bat] = 11,
	[gem_robot] = 12,
	[gem_robot_asleep] = 13,
	[gem_robot_asleep2] = 13,
	[rock_full] = 48,
	[rock_cracked] = 49,
	[rock_broken] = 50,
	[cell_door] = 51,
	[cell_chest_air] = 52,
	[cell_chest_fire] = 53,
	[cell_chest_day] = 54,
	[cell_chest_earth] = 55,
	[cell_chest_water] = 56,
	[cell_chest_night] = 57,
}

:: src/gfx.lua
--[[pod_format="raw",created="2024-08-24 12:06:13",modified="2025-11-25 20:56:55",revision=6149]]
--- Graphics


local cell_width = 29
local cell_height = 29

function gfx_draw_cells(cells)
	local function draw_cell(p, cell)
		local x, y = cells:coords_cell(p)
		local sprite
		if cells:tiling() == "square" then
			if cell & cell_mask == cell_good then
				sprite = 32
				sprite += (p.x + p.y) % 2
			elseif cell & cell_mask == cell_bad then
				sprite = 34
				sprite += p.y % 2
			end
		elseif cells:tiling() == "hex" then
			if cell & cell_mask == cell_good then
				sprite = 40
				sprite += (p.y + (p.x * 3)) % 3
			elseif cell & cell_mask == cell_bad then
				sprite = 47 -- 43
				--sprite += (p.y + (p.x * 3)) % 3
			end
		end
		if cell then
			spr(sprite, x, y)
		end
		x, y = cells:coords_gem(p)
		if cell and cell & cell_mask == cell_bad then
			pal(53, 58)
		end
		local obstacle = cell & obstacle_mask
		if obstacle ~= 0 then
			spr(sprites[obstacle], x, y)
		end
		pal(53, 53)
	end
	cells:foreachpos(draw_cell)
	-- TODO: move border construction out of the hot loop
	local function draw_borders(p, cell)
		local x, y = cells:coords_cell(p)
		if cells:tiling() == "square" then
			local cell_S = cells:get(p + pos(0, 1))
			local cell_W = cells:get(p + pos(-1, 0))
			local cell_E = cells:get(p + pos(1, 0))
			local cell_N = cells:get(p + pos(0, -1))
			if cell & cell_mask == cell_good then
				if not cell_S or cell_S & cell_mask ~= cell_good then
					line(x, y + 28, x + 28, y + 28, 53)
				end
				if not cell_E or cell_E & cell_mask ~= cell_good then
					line(x + 28, y, x + 28, y + 28, 53)
				end
				if not cell_N or cell_N & cell_mask ~= cell_good then
					line(x, y, x + 28, y, 57)
				end
				if not cell_W or cell_W & cell_mask ~= cell_good then
					line(x, y, x, y + 28, 57)
				end
			elseif cell & cell_mask == cell_bad then
				if cell_N and cell_N & cell_mask == cell_good then
					line(x, y, x + 28, y, 58)
				end
				if cell_W and cell_W & cell_mask == cell_good then
					line(x, y, x, y + 28, 58)
				end
			end
		elseif cells:tiling() == "hex" then
			local cell_S = cells:get(p + pos(0, 2))
			local cell_SW = cells:get(p + pos(-1, 1))
			local cell_SE = cells:get(p + pos(1, 1))
			local cell_N = cells:get(p + pos(0, -2))
			local cell_NW = cells:get(p + pos(-1, -1))
			local cell_NE = cells:get(p + pos(1, -1))
			if cell & cell_mask == cell_good then
				if not cell_SE or cell_SE & cell_mask ~= cell_good then
					line(x + 26, y + 31, x + 34, y + 15, 53)
				end
				if not cell_NE or cell_NE & cell_mask ~= cell_good then
					line(x + 26, y, x + 34, y + 15, 53)
				end
				if not cell_N or cell_N & cell_mask ~= cell_good then
					line(x + 8, y, x + 26, y, 57)
				end
				if not cell_NW or cell_NW & cell_mask ~= cell_good then
					line(x + 8, y, x, y + 15, 57)
				end
				if not cell_SW or cell_SW & cell_mask ~= cell_good then
					line(x + 8, y + 31, x, y + 16, 57)
				end
				if not cell_S or cell_S & cell_mask ~= cell_good then
					line(x + 8, y + 31, x + 26, y + 31, 53)
				end
			elseif cell & cell_mask == cell_bad then
				if cell_N and cell_N & cell_mask == cell_good then
					line(x + 8, y, x + 26, y, 58)
				end
				if cell_NW and cell_NW & cell_mask == cell_good then
					line(x + 8, y, x, y + 15, 58)
				end
			end
		end
	end
	cells:foreachpos(draw_borders)
end


-----------------------------------------------------------------------


--color_gem_skin = math.random(0, 14)
color_gem_skin = 0

function reskin_gems()
	local base = 128 + color_gem_skin * 8
	sprites[gem_air] = base + 0
	sprites[gem_fire] = base + 1
	sprites[gem_day] = base + 2
	sprites[gem_earth] = base + 3
	sprites[gem_water] = base + 4
	sprites[gem_night] = base + 5
	sprites[gem_white] = base + 6
	sprites[gem_rainbow] = base + 7
end


local function scaled_gem(sprite, x, y, size)
	local w, h = flr(29 * size + 0.5) // 2 * 2 + 1, flr(29 * size + 0.5) // 2 * 2 + 1
	local x, y = x + ((29 - w) / 2), y + ((29 - h) / 2)
	sspr(sprite, 0, 0, 29, 29, x, y, w, h)
end


local function draw_exploded_gem(gem, x, y, clock, new_clock)
	local size = 32 * new_clock
	local colour = 10 + (gem - 1) * 5
	oval(x - size, y - size, x + 29 + size, y + 29 + size, colour + 1)
	if clock < 0.25 then
		ovalfill(x + 2, y + 2, x + 25, y + 25, 7)
	elseif clock < 0.50 then
		ovalfill(x + 2, y + 2, x + 25, y + 25, colour + 2)
	elseif clock < 0.75 then
		ovalfill(x + 1, y + 1, x + 27, y + 27, colour + 1)
	elseif clock < 1.0 then
		ovalfill(x, y, x + 29, y + 29, colour)
	end
end


function gfx_draw_gems(cells, gems, states, clock)
	local function draw_gem(p, gem)
		local x, y = gems:coords_gem(p)
		local sprite = sprites[gem]
		local cell = cells:get(p)
		if cell and cell & cell_mask == cell_bad then
			pal(53, 58)
		end
		local state = states:get(p)
		if not state or state.name == "broken" then
			spr(sprite, x, y)
		elseif state.name == "new" then
			scaled_gem(sprite, x, y, clock)
		elseif state.name == "matching" then
		elseif state.name == "falling" or state.name == "swapping"
		then
			local dest_x, dest_y = gems:coords_gem(state.target)
			local ix, iy = x + clock * (dest_x - x), y + clock * (dest_y - y)
			spr(sprite, ix, iy)
		elseif state.name == "moving" then
			x, y = gems:coords_gem(state.source, gem)
			local dest_x, dest_y = gems:coords_gem(state.target)
			scaled_gem(sprites[state.target_gem], dest_x, dest_y, 1.0)
		end
		pal(53, 53)	
	end
	gems:foreachpos(draw_gem)
	local new_clock = clock * clock * clock * clock
	gems:foreachpos(
		function(p, gem)
			local x, y = gems:coords_gem(p)
			local sprite = sprites[gem]
			local cell = cells:get(p)
			if cell and cell & cell_mask == cell_bad then
				pal(53, 58)
			end
			local state = states:get(p)
			if state and state.name == "matching" then
				draw_exploded_gem(gem, x, y, clock, new_clock)
			elseif state and state.name == "moving" then
				x, y = gems:coords_gem(state.source, gem)
				local dest_x, dest_y = gems:coords_gem(state.target)
				local ix, iy = x + clock * (dest_x - x), y + clock * (dest_y - y)
				spr(sprites[state.moving_gem], ix, iy)
			end
		end
	)
end


-----------------------------------------------------------------------


function gfx_draw_turns(ox, oy, turn, anim_turn)
	local hundreds = (turn // 100) % 10
	local tens = (turn // 10) % 10
	local ones = turn % 10
	local anim = anim_turn // 2
	pal(7, 1)
	clip(ox + 7, oy + 3, 3 * 8, 11)
	-- hundreds
	if anim == 0 or (turn % 100) > 0 then
		spr(65 + hundreds, ox + 7, oy + 5)
	else
		spr(65 + hundreds, ox + 7, oy + 5 + anim)
		spr(65 + ((hundreds - 1) % 10), ox + 7, oy + 5 + anim - 10)
	end
	-- tens
	if anim == 0 or ones > 0 then
		spr(65 + tens, ox + 7 + 8, oy + 5)
	else
		spr(65 + tens, ox + 7 + 8, oy + 5 + anim)
		spr(65 + ((tens - 1) % 10), ox + 7 + 8, oy + 5 + anim - 10)
	end
	-- ones
	spr(65 + ones, ox + 7 + 2 * 8, oy + 5 + anim)
	spr(65 + ((ones - 1) % 10), ox + 7 + 2 * 8, oy + 5 + anim - 10)
	clip()
	pal(7, 7)
end


function gfx_draw_mana(ox, oy, mana, zoomed)
	local base_char
	local char_width
	if zoomed then
		base_char = 85
		char_width = 11
		oy -= 3
	else
		base_char = 75
		char_width = 8
	end
	local thousands = (mana // 1000) % 10
	local hundreds = (mana // 100) % 10
	local tens = (mana // 10) % 10
	local ones = mana % 10
	local digits = 4
	if mana < 10 then
		digits = 1
	elseif mana < 100 then
		digits = 2
	elseif mana < 1000 then
		digits = 3
	else
		digits = 4
	end
	ox -= (digits * char_width) // 2
	if mana >= 1000 then
		spr(base_char + thousands, ox, oy)
		ox += char_width
	end
	if mana >= 100 then
		spr(base_char + hundreds, ox, oy)
		ox += char_width
	end
	if mana >= 10 then
		spr(base_char + tens, ox, oy)
		ox += char_width
	end
	spr(base_char + ones, ox, oy)
end


function gfx_draw_mana_bar(ox, oy, mana)
	spr(95, ox, oy)
	if mana == 0 then
		return
	end
	local size = min(91, flr(0.5 + 91*(mana / 250)))
	rectfill(ox+1, oy+2, ox+1+size, oy+5, 40)
	line(ox+1+size, oy+2, ox+1+size, oy+5, 39)
	line(ox+1, oy+2, ox+1, oy+5, 41)
	if size > 1 then
		line(ox+2, oy+1, ox+1+size-1, oy+1, 41)
		line(ox+2, oy+6, ox+1+size-1, oy+6, 39)
	end
end
:: src/hgrid.lua
--[[pod_format="raw",created="2024-08-25 08:16:09",modified="2025-11-25 20:56:55",revision=3864]]
--- Hex Grids

--- Hex grids use the "double height" coordinate system:
---
---     (0,0)         (2,0)         (4,0)
---            (1,1)         (3,1)
---     (0,2)         (2,2)         (4,2)
---            (1,3)         (3,3)
---     (0,4)         (2,4)         (4,4)
---
--- The origin of the grid, `pos(0, 0)`, is at the top left.


-- Local Constants --------------------------------------------------------


local max_width <const> = 17
local max_height <const> = 7


-- Constructors -----------------------------------------------------------


local metatable = {}


function hgrid_new()
	local grid = {}
	metatable.default_origin(grid)
	setmetatable(grid, { __index = metatable })
	for i = 0, max_width * max_height do
		grid[i] = false
	end
	return grid
end


function metatable:new_grid()
	local result = hgrid_new()
	result.origin = self.origin
	return result
end


function metatable:clone()
	local grid = self:new_grid()
	grid.origin = self.origin
	self:foreachpos(function(p, item) grid:set(p, item) end)
	return grid
end


-- Indexing ------------------------------------------------------------


function metatable:tiling()
	return "hex"
end


function metatable:get(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	return self[p.x + ((p.y // 2) * max_width)]
end


function metatable:set(p, value)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	self[p.x + ((p.y // 2) * max_width)] = value
end


function metatable:merge(p, state)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	local index = p.x + ((p.y // 2) * max_width)
	if not self[index] then
		self[index] = {}
	end
	for k, v in pairs(state) do
		self[index][k] = v
	end
end


function metatable:del(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	self[p.x + ((p.y // 2) * max_width)] = false
end


-- Screen Coordinates ---------------------------------------------------------


function metatable:default_origin()
	self.origin = { x = 6, y = 7 }
end


function metatable:compute_origin()
	local min_p = pos(max_width, max_height)
	local max_p = pos(0, 0)
	self:foreachpos(
		function(position, cell)
			if not cell or cell == 0 then
				return
			end
			if position.x < min_p.x then min_p.x = position.x end
			if position.y < min_p.y then min_p.y = position.y end
			if position.x > max_p.x then max_p.x = position.x end
			if position.y > max_p.y then max_p.y = position.y end
		end
	)
	local width = 1 + max_p.x - min_p.x
	local height = 1 + max_p.y - min_p.y
	self.origin = {
		x = (480 // 2) - ((width * 27) // 2) - (min_p.x * 27) - 4,
		y = ((270 - 32) // 2) - ((height * 16) // 2) - (min_p.y * 16) - 8,
	}
end


function metatable:coords_origin()
	return self.origin.x, self.origin.y
end


function metatable:coords_cell(p)
	local ox, oy = self:coords_origin()
	return ox + p.x * 27, oy + p.y * 16
end


function metatable:coords_gem(p)
	local ox, oy = self:coords_origin()
	return ox + (p.x * 27) + 3, oy + (p.y * 16) + 1
end


function metatable:pos(x, y)
	local ox, oy = self:coords_origin()
	x -= ox
	y -= oy + 1
	local px, py = x // 27, y // 16
	local dx, dy = x - (px * 27), y - (py * 16)
	if dx < 8 then
		if (px + py) % 2 == 0 and dy < 14 + (-2 * dx) then
			px -= 1
			py -= 1
		elseif (px + py) % 2 != 0 and dy > -1 + (2 * dx) then
			px -= 1
		end
	end
	py = (2 * ((py - (px % 2)) // 2)) + (px % 2)
	return pos(px, py)
end


function metatable:distance(p0, p1)
	-- TODO: is this correct?
	return (abs(p0.x - p1.x) + abs(p0.y - p1.y)) // 2
end


-- Iterating ----------------------------------------------------------


function metatable:foreachpos(func)
	for x = 0, max_width do
		for y = x % 2, max_height * 2 - 1, 2 do
			local p = pos(x, y)
			local item = self:get(p)
			if item then
				func(p, item)
			end
		end
	end
end	


function metatable:neighbours(p)
	return {
		{ position = p + pos(1, 1), direction = "horizontal_SE" },
		{ position = p + pos(0, 2), direction = "vertical" },
		{ position = p + pos(-1, 1), direction = "horizontal_NE" },
		{ position = p + pos(-1, -1), direction = "horizontal_SE" },
		{ position = p + pos(0, -2), direction = "vertical" },
		{ position = p + pos(1, -1), direction = "horizontal_NE" },
	}
end


function metatable:blast_radius(p)
	return {
		p + pos(0, 0),
		p + pos(0, -2),
		p + pos(1, -1),
		p + pos(1, 1),
		p + pos(0, 2),
		p + pos(-1, 1),
		p + pos(-1, -1),
	}
end

:: src/in_editor.lua
--[[pod_format="raw",created="2024-08-30 08:13:35",modified="2025-11-25 20:56:55",revision=2099]]
in_editor = {}

local tiling = "square"

local cells = false
local gems = false
local marks = false

local active_tool = 1
local oy = 270 - 32 + 2
local sx = 32

local tools = {
	[0] = cell_none,
	cell_good,
	cell_bad,
	rock_full,
	rock_cracked,
	rock_broken,
	gem_gift,
	gem_bomb,
	gem_cat,
	gem_bat,
	gem_robot,
	cell_door,
	cell_chest_air,
	cell_chest_fire,
	cell_chest_day,
	cell_chest_earth,
	cell_chest_water,
	cell_chest_night,
}


function in_editor:enter()
	if not cells then
		cells = logic_new_test_cells(tiling, true)
		cells:compute_origin()
		gems = cells:new_grid()
	end
	marks = cells:new_grid()
end


function in_editor:exit()
end


function in_editor:update()
	if keyp("s") then
		tiling = "square"
		cells = false
		in_editor:enter()
	end
	if keyp("h") then
		tiling = "hex"
		cells = false
		in_editor:enter()
	end
	local mx, my, mb, _, _ = mouse()
	if mb == 0x1 and my >= oy then
		active_tool = clamp(mx // sx, 0, #tools)
	elseif mb == 0x1 then
		local mp = cells:pos(mx, my)
		local tool = tools[active_tool]
		if tool == cell_none then
			local cell = cells:get(mp) or cell_none
			cell = (cell & ~cell_mask) | tool
			cells:set(mp, cell)
			gems:del(mp)
		elseif tool == cell_good or tool == cell_bad then
			local cell = cells:get(mp) or cell_none
			cell = (cell & ~cell_mask) | tool
			cells:set(mp, cell)
		elseif
			tool == rock_full
			or tool == rock_cracked
			or tool == rock_broken
			or tool == cell_chest_air
			or tool == cell_chest_fire
			or tool == cell_chest_day
			or tool == cell_chest_earth
			or tool == cell_chest_water
			or tool == cell_chest_night
			or tool == cell_door
		then
			local cell = cells:get(mp) or cell_none
			cell = (cell & cell_mask) | tool
			cells:set(mp, cell)
			gems:del(mp)
		elseif cells:get(mp) and cells:get(mp) & cell_mask != 0 then
			gems:set(mp, tool)
			local cell = cells:get(mp) or cell_none
			cell = (cell & cell_mask)
			cells:set(mp, cell)
		end
	end
	if mb == 0x2 then
		local mp = cells:pos(mx, my)
		local cell = cells:get(mp) or cell_none
		cell = (cell & cell_mask)
		cells:set(mp, cell)
		gems:del(mp)
	end
	if keyp("g") then
		in_game:load_from_editor(tiling, cells, gems)
		return in_game
	end
	return false
end


function in_editor:draw()
	cls(2)
	if not cells then
		return
	end
	local _, my, _, _, _ = mouse()
	if my >= oy then
		window { cursor = "pointer" }
	else
		window { cursor = "crosshair" }
	end
	gfx_draw_cells(cells)
	gfx_draw_gems(cells, gems, marks, 0.0)
	-- Draw the panel
--	rectfill(0, 0, 110, 269, 55)
--	rectfill(ox, oy, ox + 28, oy + 28, 63)
	for i, tool in pairs(tools) do
		if tool then
			spr(sprites[tool], 0 + i * 32, oy)
		end
	end 

	local x = active_tool
	rect(x * sx - 1, oy - 1, x * sx + 29, oy + 29, 7)
end
:: src/in_game.lua
--[[pod_format="raw",created="2024-08-27 17:11:11",modified="2025-11-25 20:56:55",revision=5362]]
in_game = {}


-- The Board
local tiling = "square"
local gravity = pos(0, 1)

local cells = false
local gems = false
local marks = false

local matches = {}

local prev_cells = false
local prev_gems = false
local prev_stats = false

-- State Machine
local editor_requested = false
local substate = false
local clock = 0.0
local interaction = false

local starting_stats = {
	turn = 0,
	mana = 0,
	colours = {
		[gem_air] = 0,
		[gem_fire] = 0,
		[gem_day] = 0,
		[gem_earth] = 0,
		[gem_water] = 0,
		[gem_night] = 0,
		[gem_white] = 0,
	},
	in_cascade = false,
}
local stats = deep_copy(starting_stats)
local anim_turn = 0
local displayed_mana = 0
local star_seed = 37


-----------------------------------------------------------------------


-- Functions for substate need to be global, because of Lua
-- forward-declaration rule for locals.


function creating_the_board()
--	cells = logic_new_test_cells(tiling)
--	gems = cells:new_grid()
	cells:compute_origin()
	gems.origin = cells.origin
	marks = cells:new_grid()
	matches = {}
	stats = deep_copy(starting_stats)
	anim_turn = 0
	displayed_mana = 0
	star_seed = math.random(37, 6584587)
	return creating_missing_gems
end


function creating_missing_gems()
	if clock == 0.0 then
		logic_fill_gems(cells, gems, marks)
	end
	clock += 1.0 / 8.0
	if clock < 1.0 then
		return creating_missing_gems
	end
	-- Clean-up
	marks:foreachpos(
		function(p, mark)
			if mark.name == "new" then
				marks:del(p)
			end
		end
	)
	return moving_things
end


function moving_things()
	if clock == 0.0 and stats.turn > 0 then
		local something_moved = logic_mark_move(cells, gems, marks)
		if not something_moved then
			return starting_new_turn
		end
	end
	clock += 1.0 / 16.0
	if clock < 1.0 then
		return moving_things
	end
	logic_enact_move(cells, gems, marks)
	return starting_new_turn
end


function starting_new_turn()
	stats.turn += 1
	anim_turn = 20
	stats.in_cascade = false
	return waiting_for_input
end


function waiting_for_input()
	local mx, my, mb, _, _ = mouse()
	if mb == 0x1 then
		local mp = cells:pos(mx, my)
		if gems:get(mp) then
			interaction = { name = "swap", position = mp, start = t() }
			return waiting_for_swap
		end
	end
	if keyp("del") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:set(p, gem_gift)
		marks = cells:new_grid()
		matches = {}
	end
	if keyp("w") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:set(p, gem_white)
		marks:set(p, { name = "new" })
		matches = {}
		return checking_matches
	end
	if keyp("r") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:set(p, gem_rainbow)
		marks:set(p, { name = "new" })
		matches = {}
		return checking_matches
	end
	if keyp("b") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		cells:set(p, (cells:get(p) or 0) | rock_full)
		gems:del(p)
		matches = {}
		return checking_matches
	end
	if keyp("a") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:set(p, gem_air)
		marks:set(p, { name = "new" })
		matches = {}
		return checking_matches
	end
	if keyp("m") then
		return checking_matches
	end
	if keyp("e") then
		editor_requested = true
		return creating_the_board
	end
	if keyp("z") then
		cells = prev_cells:clone()
		gems = prev_gems:clone()
		marks = cells:new_grid()
		stats = deep_copy(prev_stats)
	end
	if keyp("0") then
		fetch("pal/0.pal"):poke(0x5000)
	end
	if keyp("1") then
		fetch("pal/1.pal"):poke(0x5000)
	end
	if keyp("3") then
		fetch("pal/3.pal"):poke(0x5000)
	end
	if keyp("4") then
		color_gem_skin = (color_gem_skin - 1) % 16
		reskin_gems()
	end
	if keyp("5") then
		color_gem_skin = 0
		reskin_gems()
	end
	if keyp("6") then
		color_gem_skin = (color_gem_skin + 1) % 16
		reskin_gems()
	end
	if keyp("7") then
		local prev = color_gem_skin
		while prev == color_gem_skin do
			color_gem_skin = math.random(0, 14)
		end
		reskin_gems()
	end
	return waiting_for_input
end


function waiting_for_swap()
	local mx, my, mb, _, _ = mouse()
	if mb != 0x1 then
		interaction = false
		return waiting_for_input
	end
	local mp = cells:pos(mx, my)
	if cells:distance(mp, interaction.position) != 1
		or (not gems:get(mp))
	then
		return waiting_for_swap
	end
	local success = logic_mark_swap(gems, marks, interaction.position, mp)
	interaction = false
	if not success then
		return waiting_for_input
	end
	prev_cells = cells:clone()
	prev_gems = gems:clone()
	prev_stats = deep_copy(stats)
	return swapping_two_gems
end


function swapping_two_gems()
	clock += 1.0 / 8.0
	if clock < 1.0 then
		return swapping_two_gems
	end
	logic_enact_swap(gems, marks)
	return checking_matches
end


function checking_matches()
	matches, marks = logic_find_matches(cells, gems)
	if #matches > 0 then
		local _ = logic_gain_mana(stats, matches)
		return clearing_gems
	end
	return creating_missing_gems
end


function clearing_gems()
	clock += 1.0 / 16.0
	if clock < 1.0 then
		return clearing_gems
	end
	logic_enact_clear(gems, marks)
	return repairing_cells
end


local repairing_done = false
function repairing_cells()
	if clock == 0.0 then
		local is_something_repaired = logic_mark_repair(cells, marks, matches)
		if not is_something_repaired then
			return breaking_things
		end
	end
	clock += 1.0 / 16.0
	if clock < 0.5 then
		repairing_done = false
		return repairing_cells
	elseif not repairing_done then
		logic_enact_repair(cells, marks)
		repairing_done = true
		return repairing_cells
	elseif clock < 1.0 then
		return repairing_cells
	end
	return breaking_things
end


local breaking_done = false
function breaking_things()
	if clock == 0.0 then
		local something_broke = logic_mark_breakage(cells, gems, marks, matches)
		if not something_broke then
			return applying_gravity
		end
		breaking_done = false
	end
	clock += 1.0 / 32.0
	if clock < 0.5 then
		return breaking_things
	elseif not breaking_done then
		logic_enact_breakage(cells, gems, marks)
		breaking_done = true
		return breaking_things
	elseif clock < 1.0 then
		return breaking_things
	end
	return applying_gravity
end


function applying_gravity()
	if clock == 0.0 then
		local some_gems_are_falling = logic_mark_gravity(cells, gems, marks, gravity)
		if not some_gems_are_falling then
			return creating_missing_gems
		end
	end
	clock += 1.0 / 8.0
	if clock < 1.0 then
		return applying_gravity
	end
	logic_enact_gravity(gems, marks)
	return checking_matches
end


-----------------------------------------------------------------------


function in_game:load_from_editor(ed_tiling, ed_cells, ed_gems)
	tiling = ed_tiling
	if tiling == "square" then
		gravity = pos(0, 1)
	else
		gravity = pos(0, 2)
	end
	cells = ed_cells:clone()
	gems = ed_gems:clone()
	marks = cells:new_grid()
	matches = {}
	stats = deep_copy(starting_stats)
	substate = creating_the_board
end


-----------------------------------------------------------------------


function in_game:enter()
	editor_requested = false
	if not substate then
		substate = creating_the_board
	end
end


function in_game:exit()
end


function in_game:update()
	local next = substate()
	if next != substate then
		clock = 0.0
		substate = next
	end
	if anim_turn > 0 then
		anim_turn -= 1
	end
	if displayed_mana < stats.mana then
		displayed_mana += 0.25
	elseif displayed_mana > stats.mana then
		displayed_mana = stats.mana
	end
	if editor_requested then
		return in_editor
	end
	return false
end


function in_game:draw()
	if not cells then
		return
	end
	-- Starry background
	local hash = star_seed
	for x = 0, 11 do
		for y = 0, 6 do
			hash = hash~(hash << 13); hash = hash~(hash >> 17); hash = hash~(hash << 5)
			local flipped = (x+y)%2 == 0
			spr(120 + (hash%8), 0 + x * 40, 0 + y * 40, flipped, flipped)
		end
	end
	-- The board
	gfx_draw_cells(cells)
	gfx_draw_gems(cells, gems, marks, clock)
	-- Bottom Panel
	local oy = 270 - 26
	poke(0x5508, 0xff)
	poke(0x550b, 0x3f)
	rectfill(0, oy - 2, 479, oy + 25 + 2, 7 | (2 << 6))
	poke(0x550b, 0x00)
	poke(0x5508, 0x3f)
	
	spr(104, 0, oy)
	spr(105, 25, oy)
	pal(53, 2)
	gfx_draw_mana(25 + 34, oy + 5, flr(displayed_mana), displayed_mana < stats.mana)
	pal(53, 53)
	spr(108, 25 + 64, oy)
	spr(109, 25 + 64 + 72, oy)
	spr(110, 25 + 64 + 2 * 72, oy)
	spr(111, 25 + 64 + 3 * 72, oy)
	spr(106, 480 - 103, oy)
	pal(53, 2)
	gfx_draw_mana(480 - 103 + 20, oy + 5, flr(12), false)
	spr(96, 480 - 103 + 30, oy + 5)
	gfx_draw_mana(480 - 103 + 20 + 28, oy + 5, flr(24), false)
	pal(53, 53)
	spr(107, 480 - 39, oy)
	pal(53, 2)
	gfx_draw_mana(480 - 19, oy + 5, stats.turn, false)
	pal(53, 53)
--	gfx_draw_turns(480 - 36, oy + 1, stats.turn, anim_turn)
	-- Update the cursor
	local mx, my = mouse()
	local cursor_pos = cells:pos(mx, my)
	local cell = cells:get(cursor_pos)
	if cell and cell != 0 then
		window { cursor = "grab" }
	else
		window { cursor = "" }
	end
	if false then
		rectfill(mx + 4 - 10, my + 10, mx + 36, my + 20, 7)
		--print(tostr(cursor_pos.x)..","..tostr(cursor_pos.y), mx + 6 - 10, my + 12, 0)
		local gem = gems:get(cursor_pos)
		print(string.format("%x", gem or 0), mx + 6 - 10, my + 12, 0)
	end
end
:: src/logic/creation.lua
--[[pod_format="raw",created="2024-08-30 06:25:09",modified="2025-11-25 20:56:55",revision=2853]]
--- Board Creation Logic


function logic_new_test_cells(tiling, for_editor)
	local grid
	local size
	if tiling == "square" then
		grid = sgrid_new()
		for x = 4, 11 do
			for y = 0, 7 do
				grid:set(pos(x, y), cell_good)
			end
		end
	elseif tiling == "hex" then
		grid = hgrid_new()
		for i = 0, 4 do
			for y = i, 12 - i, 2 do
				grid:set(pos(8 + i, y), cell_good)
				grid:set(pos(8 - i, y), cell_good)
			end
		end
	end
	return grid
end


------------------------------------------------------------------------


--local function random_gem()
--	if false and rnd() < 0.05 then
--		local gem = gem_rainbow + flr(rnd(6))
--		if gem == gem_robot_E then
--			gem += flr(rnd(4))
--		end
--		return gem
--	end
--	return gem_color_first + flr(rnd(gem_color_last - gem_color_first))
--end
local bag_of_gems = {}
local rejected_gems = {}


local function random_gem()
	while #bag_of_gems == 0 do
		bag_of_gems = rejected_gems
		rejected_gems = {}
		for i = gem_air, gem_night, 0x100 do
			add(rejected_gems, i)
		end
	end
	local idx = math.random(1, #bag_of_gems)
	local gem = bag_of_gems[idx]
	deli(bag_of_gems, idx)
	return gem
end


function logic_fill_gem_at(cells, gems, states, p)
	local cell = cells:get(p) or 0
	if (cell & cell_mask == 0) or (cell & obstacle_mask != 0) then
		return
	end
	local test = (gems:tiling() == "square") and logic_test_sqr_match_at or logic_test_hex_match_at
	local gem = gems:get(p)
	if not gem then
		local attempts = 0
		local found = false
		while attempts < 16 and not found do
			if gem then
				add(rejected_gems, gem)
			end
			gem = random_gem()
			gems:set(p, gem)
			found = not test(gems, p)
			attempts += 1
		end
		if attempts == 16 then
			gem = gem_gift
			gems:set(p, gem)
		end
		states:set(p, { name = "new" })
	end
end


function logic_fill_gems(cells, gems, states)
	-- TODO: transform into a coroutine
	-- TODO: fill in reverse gravity order
	cells:foreachpos(
		function(p, _)
			logic_fill_gem_at(cells, gems, states, p)
		end
	)
end

:: src/logic/matching.lua
--[[pod_format="raw",created="2024-08-24 08:12:55",modified="2025-11-25 20:56:55",revision=4149]]
--- Matching Logic

-- The matching algorithm has two phases:
--
-- 1. First, a linear sweep through all the gems, and for each gem involved in a match
--    creates a mark registering which direction(s) matched.
-- 2. Then a flood-fill algorithm is used to group matches together.


local function logic_is_matching(gem1, gem2)
	if (not gem1) or (not gem2) then
		return false
	end
	
	-- Only colored gems can match.
	if (gem1 < gem_color_first) or (gem1 > gem_color_last) then
		return false
	end
	if (gem2 < gem_color_first) or (gem2 > gem_color_last) then
		return false
	end

	return (gem1 == gem2) or (gem1 == gem_rainbow)
		or (gem2 == gem_rainbow)
end


--------------------------------------------------------------------------


local function test_3(gems, p0, p1, p2)
	local gem0 = gems:get(p0)
	local gem1 = gems:get(p1)
	local gem2 = gems:get(p2)
	return logic_is_matching(gem0, gem1)
		and logic_is_matching(gem0, gem2)
		and logic_is_matching(gem1, gem2)
end


local function test_4(gems, p0, p1, p2, p3)
	local gem0 = gems:get(p0)
	local gem1 = gems:get(p1)
	local gem2 = gems:get(p2)
	local gem3 = gems:get(p3)
	return logic_is_matching(gem0, gem1)
		and logic_is_matching(gem0, gem2)
		and logic_is_matching(gem0, gem3)
		and logic_is_matching(gem1, gem2)
		and logic_is_matching(gem1, gem3)
		and logic_is_matching(gem2, gem3)
end


function logic_test_sqr_match_at(gems, p)
	local S = p + pos(0, 1)
	local SS = p + pos(0, 2)
	local N = p + pos(0, -1)
	local NN = p + pos(0, -2)
	local E = p + pos(1, 0)
	local EE = p + pos(2, 0)
	local W = p + pos(-1, 0)
	local WW = p + pos(-2, 0)
	local SE = p + pos(1, 1)
	local SW = p + pos(-1, 1)
	local NE = p + pos(1, -1)
	local NW = p + pos(-1, -1)
	return test_3(gems, SS, S, p) or test_3(gems, S, p, N) or test_3(gems, p, N, NN)
		or test_3(gems, EE, E, p) or test_3(gems, E, p, W) or test_3(gems, p, W, WW)
		or test_4(gems, p, S, SE, E) or test_4(gems, p, S, SW, W) 
		or test_4(gems, p, N, NE, E) or test_4(gems, p, N, NW, W)
end


function logic_test_hex_match_at(gems, p)
	local S = p + pos(0, 2)
	local S_S = p + pos(0, 4)
	local N = p + pos(0, -2)
	local N_N = p + pos(0, -4)
	local SE = p + pos(1, 1)
	local SE_SE = p + pos(2, 2)
	local SW = p + pos(-1, 1)
	local SW_SW = p + pos(-2, 2)
	local NE = p + pos(1, -1)
	local NE_NE = p + pos(2, -2)
	local NW = p + pos(-1, -1)
	local NW_NW = p + pos(-2, -2)
	local E = p + pos(2, 0)
	local W = p + pos(-2, 0)
	return test_3(gems, S_S, S, p) or test_3(gems, S, p, N) or test_3(gems, p, N, N_N)
		or test_3(gems, SE_SE, SE, p) or test_3(gems, SE, p, NW) or test_3(gems, p, NW, NW_NW)
		or test_3(gems, NE_NE, NE, p) or test_3(gems, NE, p, SW) or test_3(gems, p, SW, SW_SW)
		or test_4(gems, p, SE, S, SW) or test_4(gems, p, NE, N, NW)
		or test_4(gems, p, NE, E, SE) or test_4(gems, p, NW, W, SW)
end


local function check_3_and_mark(gems, p0, p1, p2, mark, marks)
	if test_3(gems, p0, p1, p2) then
		marks:merge(p0, mark)
		marks:merge(p1, mark)
		marks:merge(p2, mark)
	end
end


local function check_4_and_mark(gems, p0, p1, p2, p3, mark, marks)
	if test_4(gems, p0, p1, p2, p3) then
		marks:merge(p0, mark)
		marks:merge(p1, mark)
		marks:merge(p2, mark)
		marks:merge(p3, mark)
	end
end


local function mark_sgrid_matches_at(gems, p0, marks)
	check_3_and_mark( gems,
		p0,
		p0 + pos(0, 1),
		p0 + pos(0, 2),
		{ name = "matching", vertical = true }, marks )
	check_3_and_mark( gems,
		p0,
		p0 + pos(1, 0),
		p0 + pos(2, 0),
		{ name = "matching", horizontal= true }, marks )
	check_4_and_mark( gems,
		p0,
		p0 + pos(1, 0),
		p0 + pos(0, 1),
		p0 + pos(1, 1),
		{ name = "matching", vertical = true, horizontal = true }, marks )
end


local function mark_hgrid_matches_at(gems, p0, marks)
	check_3_and_mark( gems,
		p0,
		p0 + pos(0, 2),
		p0 + pos(0, 4),
		{ name = "matching", vertical = true }, marks )
	check_3_and_mark( gems,
		p0,
		p0 + pos(1, 1),
		p0 + pos(2, 2),
		{ name = "matching", horizontal_SE = true }, marks )
	check_3_and_mark( gems,
		p0,
		p0 + pos(1, -1),
		p0 + pos(2, -2),
		{ name = "matching", horizontal_NE = true }, marks )
	local p1 = p0 + pos(1, 1)
	local p2 = p0 + pos(1, -1)
	local p3 = p0 + pos(2, 0)
	if test_4(gems, p0, p1, p2, p3) then
		marks:merge(p0, { name = "matching", vertical = true, horizontal_NE = true, horizontal_SE = true})
		marks:merge(p1, { name = "matching", vertical = true, horizontal_SE = true })
		marks:merge(p2, { name = "matching", vertical = true, horizontal_NE = true })
		marks:merge(p3, { name = "matching", vertical = true, horizontal_NE = true, horizontal_SE = true})
	end
end


local function mark_all_matches(gems)
	local marks = gems:new_grid()
	if gems:tiling() == "square" then
		gems:foreachpos(
			function(p, _gem)
				mark_sgrid_matches_at(gems, p, marks)
			end
		)
	elseif gems:tiling() == "hex" then
		gems:foreachpos(
			function(p, _gem)
				mark_hgrid_matches_at(gems, p, marks)
			end
		)
	end
	return marks
end


---------------------------------------------------------------------------


local function group_this_match(cells, gems, marks, p)
	-- A simple flood-fill algorithm to group all
	-- intersecting linear matches together.
	local colour = gem_rainbow
	local positions = {}
	local one_good_cell = false
	local remaining = { p }
	local rainbows = {}
	while #remaining > 0 do
		local current = deli(remaining)
		local gem = gems:get(current)
		local mark = marks:get(current)
		if mark and mark.name == "matching"
			and (not mark.counted)
			and logic_is_matching(colour, gem)
		then
			if gem == gem_rainbow then
				-- Rainbow gems can be part of multiple matches,
				-- so they need to be unflagged at the end.
				add(rainbows, current)
			else
				colour = gem
			end
			add(positions, current)
			marks:merge(current, { counted = true })
			local cell = cells:get(current)
			if cell and cell & cell_mask == cell_good then
				one_good_cell = true
			end
			local neighbours = gems:neighbours(current)
			foreach(
				neighbours,
				function(n)
					local s = marks:get(n.position)
					if not s then
						return
					end
					if s and s.name == "matching"
						and (not s.counted)
						and s[n.direction]
					then
						add(remaining, n.position)
					end
				end
			)
		end
	end
	foreach(
		rainbows,
		function(p)
			marks:merge(p, { counted = false })
		end
	)
	return { colour = colour, positions = positions, one_good_cell = one_good_cell }
end


function logic_find_matches(cells, gems)
	local marks = mark_all_matches(gems)
	local matches = {}
	marks:foreachpos(
		function(p, mark)
			if mark and mark.name == "matching"
				and (not mark.counted)
			then
				local match = group_this_match(cells, gems, marks, p)
				if match.colour == gem_rainbow then
					-- Ignore, as this is probably a stray rainbow that was unflagged
					-- at the end of `count_this_match`.
					-- TODO: an edge case is when there is a legitime match of
					-- only rainbow gems (e.g. 3 rainbows surrounded by black things).
				else
					add(matches, match)
				end
			end
		end
	)
	return matches, marks
end
:: src/logic/mechanics.lua
--[[pod_format="raw",created="2024-08-30 06:41:59",modified="2025-11-25 20:56:55",revision=2802]]
--- Core Mechanics Logic


function logic_mark_gravity(cells, gems, marks, gravity)
	local some_gems_are_falling = false
	gems:foreachpos(
		function(p, gem)
			local below = p + gravity
			local distance = 0
			local cell_below = cells:get(below) or cell_none
			while (cell_below & cell_mask != cell_none)
				and (cell_below & obstacle_mask == 0)
			do
				if (not gems:get(below)) then
					some_gems_are_falling = true
					distance += 1
				end
				below += gravity
				cell_below = cells:get(below) or cell_none
			end
			if distance > 0 then
				marks:set(p, { name = "falling", target = p + distance * gravity })
			end
		end
	)
	return some_gems_are_falling
end


function logic_enact_gravity(gems, marks)
	local fell_gems = {}
	marks:foreachpos(
		function(p, mark)
			if mark.name == "falling" then
				local new_p = mark.target
				add(fell_gems, { gem = gems:get(p), pos = new_p })
				gems:del(p)
				marks:del(p)
			end
		end
	)
	foreach(fell_gems,
		function(fell_gem)
			gems:set(fell_gem.pos, fell_gem.gem)
			marks:del(fell_gem.pos)
		end
	)
end


------------------------------------------------------------------------


function logic_mark_swap(gems, marks, source, target)
	local gem0 = gems:get(source)
	local gem1 = gems:get(target)
	local test = (gems:tiling() == "square") and logic_test_sqr_match_at or logic_test_hex_match_at
	gems:set(source, gem1)
	gems:set(target, gem0)
	local matched = test(gems, target) or test(gems, source)
	gems:set(source, gem0)
	gems:set(target, gem1)
	if not matched then
		return false
	end
	marks:set(source, {
		name = "swapping",
		selected = true,
		target = target,
	})
	marks:set(target, {
		name = "swapping",
		target = source,
	})
	return true
end


function logic_enact_swap(gems, marks)
	local reinsert = {}
	marks:foreachpos(
		function(p, mark)
			if mark.name == "swapping" then
				add(reinsert, { gem = gems:get(p), position = mark.target })
				gems:del(p)
				marks:del(p)
			end
		end
	)
	foreach(
		reinsert,
		function(r) gems:set(r.position, r.gem) end
	)
end


-------------------------------------------------------------------------


function logic_enact_clear(gems, marks)
	marks:foreachpos(
		function(p, mark)
			if mark.name == "matching" then
				gems:del(p)
				marks:del(p)
			end
		end
	)
end

-------------------------------------------------------------------------


function logic_mark_repair(cells, marks, matches)
	local is_something_repaired = false
	foreach(
		matches,
		function(match)
			if match.one_good_cell then
				foreach(
					match.positions,
					function(position)
						local cell = cells:get(position) or 0
						if cell & cell_mask == cell_bad then
							marks:set(position, { name = "repaired" })
							is_something_repaired = true
						end
					end
				)
			end
		end
	)
	return is_something_repaired
end


function logic_enact_repair(cells, marks)
	local to_be_unmarked = {}
	marks:foreachpos(
		function(position, mark)
			if mark.name == "repaired" then
				local cell = cells:get(position)
				cell = (cell & ~cell_mask) | cell_good
				cells:set(position, cell)
				add(to_be_unmarked, position)
			end
		end
	)
	foreach(to_be_unmarked, function(p) marks:del(p) end)
end


----------------------------------------------------------------------


function logic_mark_breakage(cells, gems, marks, matches)
	local something_broke = false
	foreach(
		matches,
		function(match)
			foreach(
				match.positions,
				function(position)
					local neighbours = cells:neighbours(position)
					foreach(
						neighbours,
						function(n)
							local cell = (cells:get(n.position) or 0) & obstacle_mask
							if cell >= rock_full and cell <= rock_broken then
								marks:set(n.position, { name = "broken" })
								something_broke = true
							end
							local gem = gems:get(n.position) or 0
							if #match.positions > 3 then
								if gem == gem_cat or gem == gem_bat
									or gem == gem_robot_asleep
									or gem == gem_bomb
								then
									marks:set(n.position, { name = "broken" })
									something_broke = true
								elseif gem == gem_robot then
									gems:set(n.position, gem_robot_asleep2)
								end
							elseif gem == gem_bomb then
								marks:set(n.position, { name = "broken", exploded = true })
								something_broke = true
							end
						end
					)
				end
			)
		end
	)
	return something_broke
end


function logic_enact_breakage(cells, gems, marks)
	local to_be_unmarked = {}
	marks:foreachpos(
		function(position, mark)
			if mark.name == "broken" then
				local cell = cells:get(position) or 0
				if cell & obstacle_mask == rock_full then
					cells:set(position, (cell & cell_mask) | rock_cracked)
				elseif cell & obstacle_mask == rock_cracked then
					cells:set(position, (cell & cell_mask) | rock_broken)
				elseif cell & obstacle_mask == rock_broken then
					cells:set(position, (cell & cell_mask))
				end
				local gem = gems:get(position) or 0
				if gem == gem_cat or gem == gem_bat
					or gem == gem_robot_asleep
					or gem == gem_bomb
				then
					gems:del(position)
				end
				if gem == gem_bomb and mark.exploded then
					local neighbours = cells:blast_radius(position)
					foreach(
						neighbours,
						function(p)
							local cell = cells:get(p)
							if cell then
								cells:set(p, cell_bad | (cell & obstacle_mask))
							end
						end
					)
				end
				add(to_be_unmarked, position)
			end
		end
	)
	foreach(to_be_unmarked, function(p) marks:del(p) end)
end


-----------------------------------------------------------------------


function logic_mark_move(cells, gems, marks)
	local something_moved = false
	local movers = {}
	gems:foreachpos(
		function(position, gem)
			if gem == gem_cat or gem == gem_bat or gem == gem_robot then
				add(movers, position)
			elseif gem == gem_robot_asleep2 then
				gems:set(position, gem_robot_asleep)
			elseif gem == gem_robot_asleep then
				gems:set(position, gem_robot)
			end
		end
	)
	foreach(
		movers,
		function(position)
			local neighbours = cells:neighbours(position)
			local possibilities = {}
			foreach(
				neighbours,
				function(neighbour)
					local cell = cells:get(neighbour.position) or 0
					local gem = gems:get(neighbour.position) or 0
					if (cell & obstacle_mask == 0)
						and (cell & cell_mask != 0)
						and (gem < gem_rainbow)
					then
						add(possibilities, neighbour.position)
					end
				end
			)
			if #possibilities > 0 then
				something_moved = true
				local target = possibilities[math.random(1, #possibilities)]
				local moving_gem = gems:get(position)
				gems:del(position)
				local target_gem = gems:get(target)
				gems:set(target, moving_gem)
				local source_gem
				logic_fill_gem_at(cells, gems, marks, position)
				source_gem = gems:get(position)
				marks:set(target, {
					name = "moving",
					source = position,
					target = target,
					moving_gem = moving_gem,
					target_gem = target_gem,
					source_gem = source_gem,
				})
				if moving_gem == gem_bat or moving_gem == gem_robot then
					local cell = cells:get(target)
					cell = cell_bad | (cell & obstacle_mask)
					cells:set(position, cell)
				end
			end
		end
	)
	return something_moved
end


function logic_enact_move(cells, gems, marks)
	marks:foreachpos(
		function(position, mark)
			if mark.name == "moving" then
				if mark.moving_gem == gem_robot then
				end
			end
		end
	)
	marks:foreachpos(function(p, _) marks:del(p) end)
end
:: src/logic/spells.lua
--[[pod_format="raw",created="2024-08-30 06:37:36",modified="2025-11-25 20:56:55",revision=1681]]
--- Spell Logic


function logic_gain_mana(stats, matches)
	local gained = false
	foreach(
		matches,
		function(match)
			local count = #(match.positions)
			if count > 3 then
				stats.mana += 10 * (count - 3)
				gained = true
			end
			if stats.in_cascade then
				stats.mana += 5
				gained = true
			end
			stats.in_cascade = true
			if match.colour == gem_rainbow then
				foreach(
					{ gem_air, gem_fire, gem_day, gem_earth, gem_water, gem_night },
					function(g) stats.colour[g] += count end
				)
			else
				stats.colours[match.colour] += count
			end
		end
	)
	return gained
end

:: src/sgrid.lua
--[[pod_format="raw",created="2024-08-24 07:17:45",modified="2025-11-25 20:56:55",revision=4483]]
--- Square Grids

--- The origin of the grid, `pos(0, 0)`, is at the top left.


-- Local Constants --------------------------------------------------------


local max_width <const> = 16
local max_height <const> = 8


-- Constructors -----------------------------------------------------------


local metatable = {}


function metatable:new_grid()
	local result = sgrid_new()
	result.origin = self.origin
	return result
end


function sgrid_new()
	local grid = {}
	metatable.default_origin(grid)
	setmetatable(grid, { __index = metatable })
	for i = 0, max_width * max_height do
		grid[i] = false
	end
	return grid
end


function metatable:clone()
	local grid = self:new_grid()
	grid.origin = self.origin
	self:foreachpos(function(p, item) grid:set(p, item) end)
	return grid
end


-- Indexing --------------------------------------------------------------------


function metatable:tiling()
	return "square"
end


function metatable:get(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	return self[p.x + (p.y * max_width)]
end


function metatable:set(p, value)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	self[p.x + (p.y * max_width)] = value
end


function metatable:merge(p, state)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	local index = p.x + (p.y * max_width)
	if not self[index] then
		self[index] = {}
	end
	for k, v in pairs(state) do
		self[index][k] = v
	end
end


function metatable:del(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	self[p.x + (p.y * max_width)] = false
end


function metatable:distance(p0, p1)
	return abs(p0.x - p1.x) + abs(p0.y - p1.y)
end


-- Screen Coordinates ---------------------------------------------------------


function metatable:default_origin()
	self.origin = { x = 10, y = 4 }
end


function metatable:compute_origin()
	local min_p = pos(max_width, max_height)
	local max_p = pos(0, 0)
	self:foreachpos(
		function(position, cell)
			if not cell or cell == 0 then
				return
			end
			if position.x < min_p.x then min_p.x = position.x end
			if position.y < min_p.y then min_p.y = position.y end
			if position.x > max_p.x then max_p.x = position.x end
			if position.y > max_p.y then max_p.y = position.y end
		end
	)
	local width = 1 + max_p.x - min_p.x
	local height = 1 + max_p.y - min_p.y
	self.origin = {
		x = (480 // 2) - ((width * 29) // 2) - (min_p.x * 29),
		y = ((270 - 32) // 2) - ((height * 29) // 2) - (min_p.y * 29),
	}
end


function metatable:coords_origin()
	return self.origin.x, self.origin.y
end


function metatable:coords_cell(p)
	local ox, oy = self:coords_origin()
	return ox + p.x * 29, oy + p.y * 29
end


function metatable:coords_gem(p)
	local ox, oy = self:coords_origin()
	return ox + p.x * 29, oy + p.y * 29
end


function metatable:pos(x, y)
	local ox, oy = self:coords_origin()
	return pos((x - ox) // 29, (y - oy) // 29)
end


-- Iterating -------------------------------------------------------


function metatable:foreachpos(func)
	local p = pos(0, 0)
	for x = 0, max_width do
		for y = 0, max_height do
			local p = pos(x, y)
			local item = self:get(p)
			if item then
				func(p, item)
			end
		end
	end
end	


function metatable:neighbours(p)
	return {
		{ position = p + pos(1, 0), direction = "horizontal" },
		{ position = p + pos(0, 1), direction = "vertical" },
		{ position = p + pos(-1, 0), direction = "horizontal" },
		{ position = p + pos(0, -1), direction = "vertical" },
	}
end


function metatable:blast_radius(p)
	return {
		p + pos(0, 0),
		p + pos(1, 0),
		p + pos(1, 1),
		p + pos(0, 1),
		p + pos(-1, 1),
		p + pos(-1, 0),
		p + pos(-1, -1),
		p + pos(0, -1),
		p + pos(1, -1),
	}
end

:: .info.pod
--[[pod,created="2024-08-23 18:45:13",modified="2025-11-25 20:56:55",runtime=24,stored="2024-03-30 06:54:24",workspaces={{location="main.lua",workspace_index=1},{location="gfx/0.gfx",workspace_index=2},{location="sfx/0.sfx",workspace_index=4},{location="pal/0.pal",workspace_index=7},{location="pal/1.pal",workspace_index=7},{location="pal/3.pal",workspace_index=7}}]]
:: docs/.info.pod
--[[pod,created="2024-08-26 14:03:25",modified="2025-11-25 20:56:55"]]
:: docs/design.md
b64$LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNS0xMC0yMCAxOTowNjoyMiIsbW9k
aWZpZWQ9IjIwMjUtMTEtMjUgMjA6NTY6NTUiLHJldmlzaW9uPTcxNV1dCiMgRGVzaWduCgojIyBT
cGVsbHMKCi0gQW50aWdyYXY6IGNoYW5nZSBncmF2aXR5CgotIFJhaW5ib3dzOiBjaGFuZ2UgcmFu
ZG9tIGdlbXMgaW50byByYWluYm93IGdlbXMKLSBSZXBsYWNlOiByZXBsYWNlIG9uZSBnZW0gd2l0
aCBhIGRpZmZlcmVudCBjb2xvcgotIFJlcGFpbnQ6IHJlcGxhY2UgYWxsIGdlbXMgb2YgYSBjaG9z
ZW4gY29sb3Igd2l0aCBhIGRpZmZlcmVudCByYW5kb20gY29sb3IKLSBQYWludDogcmVwbGFjZSBy
YW5kb20gZ2VtcyB3aXRoIGEgY2hvc2VuIGNvbG9yIChtaWdodCBjcmVhdGUgYSBtYXRjaCkKCi0g
UmVtb3ZlOiBjbGVhciBvbmUgZ2VtCi0gU2xhc2g6IGNsZWFyIG9uZSBsaW5lIG9yIGNvbHVtbiAo
ZW5kcyB0aGUgdHVybikKLSBFeHBsb2RlOiBjbGVhciBhIDl4OSBhcmVhIChlbmRzIHRoZSB0dXJu
KQoKLSBGb3JjZTogc3dhcCB0d28gYWRqYWNlbnQgZ2VtcyB0aGF0IGRvIG5vdCBjcmVhdGUgYSBt
YXRjaAoKLSBUZWxlcG9ydDogc3dhcCB0d28gZGlzdGFudCBnZW1zIChtdXN0IGNyZWF0ZSBhIG1h
dGNoKQotIERpYWdvbmFsOiBzd2FwIHR3byBnZW1zIGRpYWdvbmFsbHkgKG11c3QgY3JlYXRlIGEg
bWF0Y2gpCi0gUHVzaDogcHVzaCBhIGxpbmUgb3IgYSBjb2x1bW4gKG11c3QgY3JlYXRlIGEgbWF0
Y2gpCi0gTXVsdGlzd2FwOiBzd2FwIDYoPykgZ2VtcyAobXVzdCBjcmVhdGUgYSBtYXRjaCkKLSBD
b25uZWN0OiBkcmF3IGEgcGF0aCB0aHJvdWdoIGFkamFjZW50IGdlbXMgb2YgdGhlIHNhbWUgY29s
b3IgKG11c3QgY3JlYXRlIGEgbWF0Y2gpCi0gVG91Y2g6IHNlbGVjdCBhbiBhcmVhIG9mIGdlbXMg
b2YgdGhlIHNhbWUgY29sb3IgKG11c3QgY3JlYXRlIGEgbWF0Y2gpCgojIyBSdW4gTW9kaWZpZXJz
CgpIYXJkZXI6Ci0gQ2hhbmdlIGRlZmF1bHQgbWF0Y2hpbmcgbWVjaGFuaWMKLSBBZGQgcmFuZG9t
IHJvY2tzCi0gTm8gcmVyb2xsLCBubyBiYW5pc2gsIG5vIGxvY2ssIG5vIHNraXAKCkVhc2llcjoK
LSA1IGNvbG9ycyBvbmx5Ci0gTG93ZXIgc3BlbGwgY29zdAotIEFsbCBzcGVsbHMgZnJvbSB0aGUg
c3RhcnQKLSBBbGwgc3BlbGxzIGZ1bGx5IHVwZ3JhZGVk
:: drakma.lua
b64$LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNC0wNC0wNyAwNzo0Mjo0NSIsbW9k
aWZpZWQ9IjIwMjUtMTEtMjUgMjA6NTY6NTUiLHJldmlzaW9uPTI2NzddXQpfbW9kdWxlcyA9IHt9
CgotLSBBICdyZXF1aXJlJyBmdW5jdGlvbiBzaW1pbGFyIHRvIHN0YW5kYXJkIEx1YS4KLS0gSWRl
YSBmcm9tIGVsZ29waGVyIG9uIHRoZSBCQlMKZnVuY3Rpb24gcmVxdWlyZShuYW1lKQoJbG9jYWwg
Y2FjaGVkID0gX21vZHVsZXNbbmFtZV0KCWlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQKCglsb2Nh
bCBmaWxlbmFtZSA9IGZ1bGxwYXRoKG5hbWUgLi4gJy5sdWEnKQoJbG9jYWwgc3JjID0gZmV0Y2go
ZmlsZW5hbWUpIAoKCWlmICh0eXBlKHNyYykgIT0gInN0cmluZyIpIHBhbmljKCJjb3VsZCBub3Qg
aW5jbHVkZSAiIC4uIGZpbGVuYW1lKQoKCS0tIGh0dHBzOi8vd3d3Lmx1YS5vcmcvbWFudWFsLzUu
NC9tYW51YWwuaHRtbCNwZGYtbG9hZAoJLS0gY2h1bmsgbmFtZSAoZm9yIGVycm9yIHJlcG9ydGlu
ZykKCS0tIG1vZGUgKCJ0IiBmb3IgdGV4dCBvbmx5IC0tIG5vIGJpbmFyeSBjaHVuayBsb2FkaW5n
KQoJLS0gX0VOViB1cHZhbHVlCgktLSBAIGlzIGEgc3BlY2lhbCBjaGFyYWN0ZXIgdGhhdCB0ZWxs
cyBkZWJ1Z2dlciB0aGUgc3RyaW5nIGlzIGEgZmlsZW5hbWUKCWxvY2FsIGZ1bmMsIGVyciA9IGxv
YWQoc3JjLCAiQCIgLi4gZmlsZW5hbWUsICJ0IiwgX0VOVikKCWlmIChub3QgZnVuYykgcGFuaWMo
IlN5bnRheCBlcnJvcjoiLCB0b3N0cihlcnIpKQoKCWxvY2FsIG1vZHVsZSA9IGZ1bmMoKQoJX21v
ZHVsZXNbbmFtZV0gPSBtb2R1bGUKCglyZXR1cm4gbW9kdWxlCmVuZAoKCmZ1bmN0aW9uIHBhbmlj
KC4uLikKCWxvY2FsIGFyZ3MgPSB7IC4uLiB9Cglmb3JlYWNoKAoJCWFyZ3MsCgkJZnVuY3Rpb24o
c3RyKQoJCQlzZW5kX21lc3NhZ2UoMywgeyBldmVudCA9ICJyZXBvcnRfZXJyb3IiLCBjb250ZW50
ID0gc3RyIH0pCgkJZW5kCgkpCglzdG9wKCkKZW5kCgoKLS0gVGFibGUgdXRpbGl0eSBmdW5jdGlv
bnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0KCgpmdW5jdGlvbiBpc19lbXB0eSh0KQoJcmF3ZXF1YWwobmV4dCh0KSwgbmlsKQplbmQKCmZ1
bmN0aW9uIGRlZXBfY29weSh0LCBhbHJlYWR5KQoJaWYgKG5vdCBhbHJlYWR5KSBhbHJlYWR5ID0g
e30KCWlmIHR5cGUodCkgPT0gInRhYmxlIiB0aGVuCgkJaWYgYWxyZWFkeSBhbmQgYWxyZWFkeVt0
XSB0aGVuCgkJCXJldHVybiBhbHJlYWR5W3RdCgkJZW5kCgkJbG9jYWwgbmV3ID0ge30KCQlhbHJl
YWR5W3RdID0gbmV3CgkJZm9yIGssIHYgaW4gcGFpcnModCkgZG8KCQkJbmV3W2tdID0gZGVlcF9j
b3B5KHYsIGFscmVhZHkpCgkJZW5kCgkJcmV0dXJuIG5ldwoJZWxzZQoJCXJldHVybiB0CgllbmQK
ZW5kCgoKZnVuY3Rpb24gdG9zdHJyZWModCkKCWlmIHR5cGUodCkgIT0gInRhYmxlIiB0aGVuCgkJ
cmV0dXJuIHRvc3RyKHQpCgllbmQKCQoJbG9jYWwgcyA9IG5pbAoJZm9yIGssIHYgaW4gcGFpcnMo
dCkgZG8KCQlpZiBub3QocykgdGhlbgoJCQlzID0gInsgIgoJCWVsc2UKCQkJcyAuLj0gIiwgIgoJ
CWVuZAoJCXMgLi49IHRvc3RyKGspIC4uICIgPSAiIC4uIHRvc3RycmVjKHYpCgllbmQKCWlmIG5v
dCBzIHRoZW4KCQlyZXR1cm4gInt9IgoJZW5kCglzIC4uPSAiIH0iCgoJcmV0dXJuIHMKZW5kCgoK
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCgpmdW5jdGlvbiBjbGFtcCh2LCBtaW4sIG1heCkKCWlm
IHYgPCBtaW4gdGhlbgoJCXJldHVybiBtaW4KCWVuZAoJaWYgdiA_IG1heCB0aGVuCgkJcmV0dXJu
IG1heAoJZW5kCglyZXR1cm4gdgplbmQKCgpmdW5jdGlvbiBleHBfZGVjYXkoYSwgYiwgZGVjYXks
IGR0KQoJLS0tIExlcnAgc21vb3RoaW5nLCBidXQgZnJhbWVyYXRlLWluZGVwZW5kYW50LCBmcm9t
IEZyZXlhIEhvbG3DqXIKCS0tLSBodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PUxTTlF1
RkVET3lRCgktLS0gVXNlIGFzIGBhID0gZXhwX2RlY2F5KGEsIGIsIGRlY2F5LCBkdClgCglyZXR1
cm4gYiArIChhIC0gYikgKiBtYXRoLmV4cCgtIGRlY2F5ICogZHQpCmVuZAoKCi0tIFBvcyAtLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLQoKCi0tIFdBUk5JTkc6IGRvIG5vdCBmb3JnZXQgdGhhdCBgcG9zYCBpcyBh
IHJlZmVyZW5jZSB0eXBlLCBub3QgYSB2YWx1ZToKLS0gYXZvaWQgbW9kaWZ5aW5nIGluIHBsYWNl
LgpmdW5jdGlvbiBwb3MoeCwgeSkKCWxvY2FsIHAgPSB1c2VyZGF0YSgiaTE2IiwgMikKCXAueCA9
IHgKCXAueSA9IHkKCXJldHVybiBwCmVuZAoKCi0tIERyYXdpbmcgLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoK
Ci0tIEZyb20gU29waGllIG9uIHRoZSBkaXNjb3JkCmZ1bmN0aW9uIGdldF9kcmF3c3BhY2UoKQog
ICAgcmV0dXJuIHsKICAgICAgICBjYW1feD1wZWVrNCgweDU1MTApLAogICAgICAgIGNhbV95PXBl
ZWs0KDB4NTUxNCksCiAgICAgICAgY2xpcF9sPXBlZWsyKDB4NTUyOCksCiAgICAgICAgY2xpcF90
PXBlZWsyKDB4NTUyYSksCiAgICAgICAgY2xpcF9yPXBlZWsyKDB4NTUyYyksCiAgICAgICAgY2xp
cF9iPXBlZWsyKDB4NTUyZSksCiAgICB9CmVuZAoKCmZ1bmN0aW9uIHNldF9kcmF3c3BhY2UoZHJh
d3NwYWNlKQogICAgcG9rZTQoMHg1NTEwLGRyYXdzcGFjZS5jYW1feCkKICAgIHBva2U0KDB4NTUx
NCxkcmF3c3BhY2UuY2FtX3kpCiAgICBwb2tlMigweDU1MjgsZHJhd3NwYWNlLmNsaXBfbCkKICAg
IHBva2UyKDB4NTUyYSxkcmF3c3BhY2UuY2xpcF90KQogICAgcG9rZTIoMHg1NTJjLGRyYXdzcGFj
ZS5jbGlwX3IpCiAgICBwb2tlMigweDU1MmUsZHJhd3NwYWNlLmNsaXBfYikKZW5k
:: gfx/.info.pod
--[[pod,created="2024-03-30 05:39:34",modified="2025-11-25 20:56:55",stored="2024-03-30 05:39:34"]]
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNS0x
MS0yNSAyMDo0OToxNCIscmV2aXNpb249NTM5OV1dbHo0ANNwAAAsHwEA8xR7WzBdPXtibXA9cHh1
AEMgEBAE8PAsZmxhZ3M9MCxwYW5feAgAz3k9MCx6b29tPTZ9LDEA-1DwER0dBPBPPxJAPuAODxYf
Kg8VDiAOHyofFg7QDg8qPxUuBQBADg81wB4ApBQfFS8WHxUfFA8TANUPFQ8UDxNPFQ8TDxQfKAAB
FQARLxUAEC8VADGQPyw_AFATLxUfEz4A-AYeHytgDyw-LS8VXy0-LB8VHywPK1ARAD8PNUATACXz
AFBPLC8TTywvKx8TLysfNVsANU8tLyIAH2ATAITvcD8rLn0eHR81gPwD8C7JAQsdM8kB8jw5LysQ
Dw-wBg8rIB7wBU8s8AcNPy0NDvAGDQw9Dg818AMdbB3wAQ2sDeANvB3ADSwfKowNDqANLCuMHQ6Q
DSwbnB0ODzVwDfwALQ4GACsKYAcAJuw9BgD-INxNDgpwDbxNDhpwDaxdDgqQHWxtDhqgDs0OGsAO
rQ4a4B5tHhrwAQpuKvAEavAXzQAd9kaD-ywJIA5fDy8rbw8vK18PDhAOXw4vK28OLytfDg4QDj3_
AT0OEA4tDv8tAQ8rLQ4QDi8NDg8t7gwPKy8NDiA_DA7PKw8uDA8rLiAOLw8ODA4PKy8UBAABGwAh
Lw9CAAAcACgPFAQANC8rDyQAEy0jAFELDxQLCgIAZSoLDy4MCxgAFAoCAEMrCQwLiABBDA4LKgIA
QQkMCyiNAETLCQwLigBB2QwLJz4AIfwBMQAhPfvLAP8EXSttK10OEA5YK2grWA4g_wnwgzUBHfAC
iw8rYA7wBB5AHvAEDg8sTg0NAPAxTR7QLiAObQ4gLg81QB4tHgAODR8PDRwNDgAeLR4gDm0eDA8q
DgwLDgwebQ4QDn0ODB4MHgwOfQ4PNQAOfQ4NHCsA8CJ9DgoADo0OTQ6NDgoAPm0OLQ5tPgoADhoO
-QMOGg4KEAoAPs0_ChAKMA4aDi0OTQ4tFgDwBnAKAE5NTgoQCpAOKg5NDioOCtAKIBsA-wIgCvAD
Dg0OGvAJDhrwCwrwcegAHSAaDy8DcCzwCg8rDxY5AyLwCRIAIA81FAARHwYAQQ818AsGAPAEBO8r
wA7vLQ6gDg3-LAAOkA4N-AYA8CYcPkw_HA4PNWAuDA4PDR8PDw0OLA4LHw8LDgwuQA4dDgwOCh8Q
Cg4sDgoZCg4MDh0OMA4NDBYAFhkVAABAADAgDhzxAUEaCw4sBgAAFgAQCBUAAmEA8AIcDggwLvwB
LhhACA78AQ4oYAYAYAiADjyOPAcAUiwOjQ4sCQBVDQ5MDgwNABB8CgAwkA4cCgCvHA4YoO4YwOjw
MCoBKR8SKgEWULAODd8suwUFMgEXDC0BVTwOLA48JQEDDgAFIAEwXixeAgESCxcBYA8cHx0PHDAB
Ih8dMQEYCxsBEQsbATAbQAsVARErGwESCxsBFAsbARgLGwEVCxsBFQsbAW8boO4bwOsbAR-wGS8f
K6AusA4fLR5wDi0ekA4fLB0eQA48HR5gDkwdHhAOHA8NDw8PDRwWAPIEbB0eLA8PDxAPDzwdDiAO
nB0eDB4AoVwOIA4sHmwdHnwwA-ECHB4LDiwePB0eXA4LAC4rDgwQAKMMHR48DgsQKxAeEgByHS4M
DgtwGxAA8QUMDi0eC8AbEB4bDjwNDgvwAhsADhwB4PABHhAOTA4LsB4gDg0e-wAhG2ALAHIADkwu
GxAuCwCSDB0eLB47IA4dDABAXB4rYAgA-xiMHiuADrweK7AOjB4r0A5sHivwAQ48HivwAw4cHivw
Bh4r8Akb8CI1AR3xCBYfK2Ae8AAeDy0ODzVQDg8tHrAeHQ8sDQDwEA0fLB5wHh0cDh81YA48HkAO
HTwOC3AOXA4wDkwOG4DLANAwDjw_QD48DhswDkwdDwBQHUwOC1AfABBABQAjUA4PACELcO4AAAUA
YXAOLD4gPvEB8AMsHQ4LEA4dLA4bkA48DhsgDjwWAAG3AxAwKwAQgIECEBxMABAcKgKADSwODD4A
PgxEABMNsAFxDhwdDgsOHSAAEhzSAQEzAABzASQbgPQBABMAIAsQBQBgoA5cDhwuZQJCDlwODPIF
gMAOXA4NPA4bCAABqQEw4A5MtAAw4A5chgCP8ACeG-ACm7BbAR3QMi8roB6gHi8tDnAeHQQAQD8s
DkBPAQC3BRQdjgKiDhAeHUwOMA4dPL4AQSweHWyFBBNcuwCwHh2cDiAOfB4dbB6XAfEEEA5cHh08
HiwOCx4cDhAOPB4dDA0AxQwOCwALLgsADgwuHRAAlR4LICsAHi0ODA8AIRtg6wAACgARsO0A8Qog
G-ABDkwOEB7wAw4sDgweDQ4gHuAuTA4ACgByoBseLB4dDA4AUi5wCx5cDgBwHQ4LgAsejA0AsBug
Cx68DgvQCx6MLAHgCx5sDgvwAwsePA4b8AWlAL8L8AgLHhvwChvwEUMBHfIGGp8r8AIOLy0OXQ7w
AA4NPywOTA7wTgMgXA6mATFcDtAwApAMDlwOwA4NDC4ZABCwNwIgLzWwBARlARCgEwAAPQEAFAAB
aAEQHAYFMCwOAAUABCYAcJAODT4PNT4EBQAjBUEOOwAbbABgoA4NHA5ABQAQDAwAAZ8CIA0saABS
PA4gDg22AmAcPgsQPiw5AFAcDjsgG8UCEHAcAAFxAQEKACQLUAYAEFxOALFcDlAODSw_CzA_PFEA
YDwOO0AbDgwCQA1MDoAFAEELMB48RgBwLB4bQAseLEwAQRweK3DeAf8DUA4NHiuwCx4LUB4r8AAb
YBtwXgEd8Q9mHyzwBR4gDh8UHvABHh0OEA4NDxYdHhCOEB4dDA0ABdMNLB0eHQwvKQwdHh0sEwCx
PE0PFS8pDxVNPA1TAfIBDSxNDxUMDykMDxVNLA0OABQAEF0SAFpdLA0OHw8AIA81VwbQLQ8pDh0M
CwwdCw4tDCQAARUAgB4NDxUrCg0eEwAAgQTxE00aSxpNDhlgDi07LjstDhlwDh0bDhsuGw4bHQ4J
gA4NKw4CABANDQBwSw4bDhsOSwsA-yFbTlsOCZAOSwgPCggHCEsOGaAOOwgnCDsOGcAOOyg7Dhng
HmseGfABCW4p8ARp8FE4AR3wBE0fLMAeoA4fFA6gDh0OkA4fFg2wAQDZAwCsATENDmAGAAD0ATAN
bg0EBgC4AVFNLxNNHAwAN40KjQcAgT0PFRxNHAk9DABSKQwtDCkLAJIPKQ4pDSkIDj0-AHINLhkN
GS4NQgBQPD0oPTwJAJAMKCwILgg8GAwNAHBIDhguGA5IMgJASA4YDgsAkBtwDlgeDwgeWKMCgEgH
DwoHBgdI-QT-DzgHJgc4DhvAHignKB4b4AseSB4r8AILTivwBkvwUhIBHZESLyzALpAOHy8SAXEP
NYAODQ8oFQEiDA0PABEcFgEiHA3IBRANAAMSLA0AITwNRAMRDUUDAFcHADYHIhuQEwACBgAAaQMQ
LhYAwMAODSwtLA0OG_AOjW0EgQ6NDgvwAA6tHgTwHA8pDk0KDg0OC9AOHR5NHh0OwA7tDqA_DRwO
LwwOHA0_gA4ADh0eHA4JDhzABACqA0BcDlwNFAZgDR48DjweCwAQHpgIQEweC5AaBEAcHiweswCA
DsAOHWwdDhsDDb8b8AELbivwBGvwNCYBJRcTJgEfFSYBRCIvEicBVwotCi0KKwGADR8UHQodGQ0y
AcAJDykOCQ0KDQkIDgk2AfMCDQkeCS0JHgkNDsAOLTkNOS0_ARgLPgEfBz4BZfALdS8s8AgeLxYe
8AUOLR8VHQ7wAw4dXA0O8AI3CjCQDlBDB5EpDyscDxQeYA48AXF8Dw8vEA5AYAFhMA4NfD8PfwQR
LEwBMWw-D3gE8Q08DU4PE2wPFB4fNUAOrA8UTA8TDi81UA78AQ8U0gOwTG1cDxQOcA48jVwxCwEI
AIALcA48HxRNbAkAYApMSlwPE6YBUAkKvAoJlgH-BBmaGQ4bsB6ZHhvQC54r8AGb8FDvAB2AOB8b
8AsODxrGCyI_EAkAQAMOPxpaAdAPNU7ADh0fGR0OHQ5NkgbxIC8XHl0ODxkfFw0OkA4MHw4OHRwd
HxkNDh8ODA0OgAwbDh0MGw8ZDQwLDA0OGwwOrBDxBgsfEA0PGQwfEAsMDxkLHxAMDRoLDBoAsCoP
GRoPFhoLDxkKBwAxKg8sFwCzCg8WagsPGUoPFhoSAIMqDxZaCxoJSg8A8Ap6CQoLeggPNWAI_gEJ
CggHYAgaCSoJagk6CwD-SwoPD4oJSgYKCAdwCAoGSglqBgoIF3AICjZqBg8VFgoIB5AICgYFpgoI
F6AIClYFNgoIF8AIChYFVgoIF_AICmYKCBfwAQgaJhoIF-ADGCoYF-AGKCfwCCfwGVoBHeAwDyzg
DqAODy4OwA4PEMAFYS4OoA4fEIMDYi8uDoAOLwwAYA8uDh0OYBoAEQwQAHENHh1uHB4MkANiLh0v
KTwuDABCHi0aXBcAMF0ajAcAQE0qbBoIAFA9Siw6DSMCcC0uai4tDnD2A4AbDyoPKw5KDgcAQA8b
Dh25BcIdDgkfKwkOKg4JGAkSAJEtDikOKg4pDi0NAEEKLkouBwYwHapdTwDwBGovCio9DhtAWFoH
Oh1YcA46DhoCAP8IHQ4bgDgqHgoeKjhwGCAOqg4bABiwHmp1AykELAEQKV4JRQ6QDh27BCAtDgQA
QQyADg0lAVIdDg0ODCMBIh0eCwAzLo0uFAASrRIAKv0BBgAAGAEUbRgBER8YARJNGAEQH4oOAFUA
YQsfKwsOLYcPARIAMy0OKwQAgAxgDj0uTS49CQAg-QNNAP8tbS8KbQ4cQFpdCV1acA49Dh8qDhgO
PQ4cgDodCB4NHggdOnAaIA4tSC0OHAAasB4dKB0eHPABDG4s8ARsGgEnHzkaASGEDQ8uHQsdCw0h
ASEdCwIAAx8AoRstCw0LDQstHy0QADEtCx0QACEdClYAO30LfTsBGBY7ARIWKQEiDQtUAjENCw1W
AiALDRYAQQsdDikTAEApDh0LEQAgLQuJACEuC1ABcA0bPUs9Gw1eAPEBPRsNLwkNGz0OHEBYXQdd
WFABMSkOFlABgTgdBh4GHgYdZgIgLUZQAV8YsB4dJlABMh8QUAEIIQ8NUQEhCw0OAFIbHW4dGwsA
pCsNDw8dCh0KDSsbABEKAgADHwCRGi0KDQoNCi0aDwAxLQodDwAEUAEcClABGBVQARMVUAETClAB
EgpQAREKUAERClABEQpQATEKDgyrA0AdCh0uWgCCYA4NGj1KPRpQARAaUAEaGlABHxFQAUkTTVAB
Hy1QAQkfK1ABBRSNSQE6rRsNtQMCBgAJMAG0Gg8qCw5NDgoLDxq4A1EJGwkOLQYAA7cDEykEAA_3
AwEQCbcDUFtdCF1bFwEA1QYAFgH3BDstHg0eLTtwGyAOrQ4cABuwHm0QAR8XEAF9Mf0DDgUAAf8A
E833AEROLU4t6gAF8AASKe8AHwnvAEYPNhoQHDIgAfAhEA838AcOIC7wBS4ATvADTgBO8AFOIE7g
TkBOwE5gTqBOgE6ATqBOYE7ATkBO4E4gHwAAKQDfjvAFbvAHTvAHbvAFjjgAGCBOAGsAbyAO8AcO
EOEaHG--N----zw1AB0fODUAIV87Df88DQYAPg_GAB0HOwAPBgA4D4gcHg89AaJPDzwPPQQAIRcf
DAAPOAD-------8HHw9MCB0QjzUAITuvBgARTwYAMv88AAcAEAEHABHPFAAXfyAAAZsAJzuPDAAX
7wYAAjAAJF88NAARLwYAFQ80ABMvZAAWBFcAFx8pAASDABAHBwAX3xMAEZ8GABE-BgAYvyUAF28l
ACZfPFYANv88Eg0ALD88KwAdHxgANv88CA0AE58TABYCLAAXfz4AA3wABV0AJztPIwATHyMAFhYT
ABd-uAAIEgAXzzoBAiQBGd9DABYTkgAIqwAP5AEZ8SYjIARw-zYD4P4F0P4FwP4HsP4HoP4JkP4J
gP4LcP4LYP4NUP4NQP4PMP4PIP4REP4RAP42AAkAESAVABFAIQARYC0AEYA5ABGgRQARwFEAP_D_
A_AZDB43jgAfN44Aeh84jgB6HzuOAHofPI4Aeh89jgB1D3gMEB812wEC8zD-PAXQ-zsFwP88B7D-
Oweg-zwJkP87CYD-PAtw-zsLYP88DVD-Ow1A-zwPMP87DyD-PBEQ-zsRAP88E-87EwAPABMgHwAT
QC8AE2A-ABOATwAToF8AE8BvAF-g-zwDcBgGHPAF8BW-Pg870N8_Lzug3z5PO4BfPl_lBKA6Dz5f
O2BPPn89CwCALz1PO0BPPo8ZBcA9TzswPz7-PQE-OyAIAEEDPzsQCAC-HzsfOhAvPv89BS8IABkQ
LwIFIT0BDAByHzsPOv89AgwAMjoPPgwAEB8YAAAMAFA-OhA-O3IAIDogCADxDgE-OjBPO389Dztf
PU86QE87bz0fOz89TzpgXzs-xQD-Bi89XzqATzvfOqAvO9860A87vzrwFSIBI1CfPg88LyYBAA4A
Hw8qARBCOg8_PywBEZ8NACFPPTEBYb89DzpfPTQBEa8-ABA-HgATPT0BAPYFII89_wAAvQABXgAk
PC8ZABJ-EQBgPh89DzovCgBAOx86IDUBAPgAAn0AYC86Dz5QLiEAET9TAFAOLz0POhAAYzswLh89
H2kA4B6fPR87IA0eLz0NLzoekgD-Vh0QLR89DQ86Hiy-PSwgDQwdDA5LDKssQBwOWwyrLDAbDmsM
Sw07PCAbDXscKw1LPCALLXsMKw07PDBNaxwLDDtMQE1bDAAMHRtMYF0LHRwADRtcgE1MAB1coC1c
EB080A1MMA0cewEgAN4AEHAAAmCgTz4vO0CBAeCAXz4vOzAvPk87YG8_L1MBgQ89PztQTz4PBAGg
Dz0vOxAfPj89P3sBIh89GAEAHAAkAB_EAQAQADI-PR8SABIfRgEAdgEwAA8_QQIQPxAAIH89eAFg
Ox89PzowgQAANADQHz0vOjAfO086QA8_P24AEDtyAfBQQE5gPzsvPT7wAy87XkA-PoAdAB87TjBd
HFAdDzwMEC5AXUwwDBsOkD0fPVwgDB4QLRwgPUo8YC0aHBAtahweQC0qLAAdWgwaLkAtOhwAHUoM
Ki4wLRoMGiwADQwqDA4OAP8eCgwNKgwOACw6DAo_MB0cDToeADwqTlA8Ki4ALI5gHF4gDI6AbjB_
sC6ALvATZQEd8QU2Ty-wAy4ADk8nDy4ALsAOLycPLg0A8CEOLycOsA49DyZPLg8mTaAMPQ8uDE86
DA8uPQxwHg0MDRuPOhsNDB4NQB4tHDoPPB-bCPEOOxocDh0bMA49CyoZDzwZCBkICgs9CzAOLQsq
CBkCALUJCi0LDDAMKwwaCRIAVCscQCwqDwBjGQosUC4aDAB3CBkKLkAOLQ8AYw4tMA4dCxEAkx8U
CBkKLQswLREAwgcPKhcZCh0bMAsdDBIAgjcKCQorDEAsDgBHCBcaCV8ALwkaXwACCBAAGj0PACct
C34AGhl9AAACAAB8ABMrewAAAgABfACv-ywBLHD-NQTwEZwBHfAXhC8v-zwBLy9ADg8qDg8u-zwB
Lg8uMC4N-zsBLg0gLg3-PAMuDRAdAEEN-zsDCAAALxxQDW87TmsIAIAQLg1bXg1bLgkA8BZ_Lwsd
jg0QrgoMDwwPCg8JDY4NEJ0OCg8MHwoPCa0gLV86DgovGADhXzotMB4NWx4vCR1bHg0LABJNCQAx
a01rCAAm_wMHACL_CAQAzw79CED-NQdw_QTwS_cAaxQQ5wBUEQ8PDw7nAFQRHw8PDucAABgABecA
Hw7nAKMUFecAEBYiMQTnAFQWHxQPE_cAABgABecAHxPnAKMUGucAVBsPGQ8Y5wBUGx8ZDxjnAAAY
AAXnAB8Y5wCjFB-nAFQgDx4PHecAVCAfHg8d5wAAGAAF5wAfHecAoxQk5wBUJQ8jDyLnAFQlHyMP
IucAABgABecAHyLnAFUOoBkPGgoqGDwaChE8hQgSPBoKAQ0AMT88TxoKAQ0AIk88GgpSPA86Xzwa
CgE-ADE-PA9XBwIaChA8WREDGgoYPBoKAoQRAW8AJB88GgoBGwAwHztvlgcBfQAAGgoRPxUAEDxa
AABWAAAXACAPOhIAAi4AIzwfbwAyHz6fEwAAaQBULzofPr8iAABnAEEfPi86EQAhDz4PABI7xABF
DzqvPLkLFF8PAAK8C2BvPA86TzzdEAHDCzF-PB-EACFPPMoLACABEy8eACAwT7QAEjr-AAHVCwBL
AWEfOh87HzzZCyAPPHoJLy882QswwCwPL-8uCDAODy-_BkQkaiAe-yYFHwkAYj8mHp0eLQwAgi0O
Dy8NDyt9BwAUHRUAEB0AMRJtBwAgDRwUAHI9HyscfRscDQC-TRydHB0cCiAe-QUGABsQPXoAIxwK
eAByC30OCQ0LHRAAQB0LDG0FABANDwAiPRttAB0KbADf-AcKIA78CAow_gnwDh4BQ0UfLJ8mIAFL
DywRDh4BAhMACBwBQx6dHysbAWH9ARwdHAuuAA8GABpzPR6dHC0cCxoBcg8rfQwRDh0QAEQdCgxt
DgBRPRocfR4oADZNHN0_ADD8BwsWAT8LMPsWAUpCHywvJhAAIC8mBgERfwYAHx8UAAgIbAIv-QUI
ADMwPR8sLAEACwBGLQwRDioBCA0AAmoCBSEBDycBAA9OBU3wESMRBCBPLg85Dy7-OQZADy7-Nw4g
Dy4vN-81CS83DzUQDABGDzVvJwQAABAAlgAPLj84DzVvKAQAABAARg8uPzcSAAAEAAAQAA8sAAYA
FgAWKQQAB0IACBYAHzcWAAY2OT83VAApbygsAAwWAA8sAAI-AA853gABNRAPOQEBMCD-N7gxP-4N
IFYBGZMFBwQAJwAHIBcCAE8HACcAQAALHDhAAJEQByAXEAcABzACAC8QRz8AHAF-AEIHMAcgAgAP
PwAlPxAXQL4AJBEwQACvAAcABxAHAEcgB0IAHW9XMDdABzB9ACMgFxB9ABE3gQEPQAAgEkc3AQLC
AB8gOgEhAncADn8AD0IAGxA3ggA-EBcQQAAZ-wIHCwQAPyoQXgAeHzUeDR4NAAUAA39eDQA_HRA9
mwAMLDE0XADBEB8qMC4PNRA_DSANBwoFAwB-EF4AXg0AXVEAHQetAEAAHQAe2ApBEC4dAAMAD1MA
NZ8eHSAuQB4NHhD4ACpgQB4PNSAuTgBwEC4NHgAeHU4AQV4NAC3-AC9AHVMAHcJfKgBeDzUeTU4Q
XhBEAAWhAC8ATaEAH_AvKiA_DzUALi0AHh0gTgEBHx3sASwCoQAA4AAF9wAFBgAQIPIAHyCaASgB
mgA-AD4dqAAwDFYAcV4NAE4NEB23AABNAV8uHSAtEFUAGvEBChAEEE8qMG4QjgAuLzUuDUMNDwUA
EK_ODQBuHRBOHTBNcAAMHDlvAP8DIC8qUD4PNTBODSBeDTAdLg1QAwABQCCOAI5lAB_NXgAcDs0A
xwAtEC4NQD4NMD4dIAMAHzBhADEBXAAgUC5cAHEwPg1ATlANDwAvLiAhASmBEC8qYC4PNVC2AEFA
Lh1ACQAhAC4qBAR_AQG8ABFNbgBfUC4NYC1kABz1BI8qAI4PNY4NLm0uDVBuIH4QjhBNAA__ACvx
BSBPKjBeDzUQbg0ATj0APh0wLh1AYQAzAC4tvgADwwAPYgAlBLwAJwA9HwEPCQAFP2AtMEICLgEF
AH8Abh0Abg0AxwA3D2gABKGODQB_DRBuDSAtxgBQME4NEF5hAG8gPh1APSBkABkgXggkCxviMwCx
LTIzLjMxOTA0NzYGAANCAJItMC43MTQyODUGACI2OFIADYIEEDAeBiowHgQADDg8UzI2Ljc1WQAS
M0kAGTFJACFmHL8LBAEAHyNAAB0VEcsLYm85EA8uz6gLFt8HADEPLu9jCxHvDABmTzhfLD84FgBl
TzdfLD83IAAcORAAEe9JACY53wcAEBAFAC8g3hkLGfICEREE8BQPFq8VMA8WvxQPEyAHAPEBEA8W
3xUPEwAPFj8UXw4-FAsAARIAUk8VXw4-GwAR3xcAFhUiACEV3zsAEhVJAAEHAE8wvvAVkAAcMN85
IB8BEhAkAQYyAQIWAVE-Nz8sbwYBkS84HywfOB8sXxgAFW8KADNfNx8iAFZPNx8sfzIBDRAACmAA
AKABPxDeID4BM0BPFT8OwEcBQgFUHw4fFB9GATJ-FR9BAQAJAAMjAFZfFB8OX0MBNAAPFRIAD04B
K08EBATwvwcND2EsLIkZGgTwOgLwCAMA0VCvKGACUK4CUAJgolARAB_uEAALCQMAHyKAABmPQBoE
8K8C8C8DABz1CAMmABYgJhA2ICbwBALwAwYSBhIGAAYiBAAg8AMWACECAAMAOAYCEAUAKfACHAAk
ABYcACQAFhwAMxACABkAARsAAQoAABsAsQQCQAIQEgACAAIgCAAr8EPsAFYxNS42MwEAA-oAQjEw
Ljb9AC8xMP4AMECQNhAG-wAyIDYACABgJiAmYAKQ_wAWFgcBFQIMAHIyAAYyUAKQ5gAkEhDvAAMO
AIVGAgAmAhAmAiIAIwIwCAAB9wBwMAZCEBIGAgQAQEACkDYHACEmEhoAAAoA-xYQNgIANhJAApAG
MhACUCIgEgYCAAJQIhAyEDLwAQYC8AEmEvAOJAErICcaxwWQtwbwFTYQBiAG8wAA_AEwsAYwDgBB
FhAGABYAEuAQAJQGQAYgBhAmsAYYAAAQADBABrAuAgEMAE8ANvBDoQIZgUgaBPDHAvA3AwDxBgIy
ADIQQgASIBKQEvABAvABQgBCABAAIYAiEADREjASABIAEjASIBJwMhIAIDIQEgAlMhA0AEgCMgBC
EAARBB4AGDBUAKISMEIAMgAyUFLgQQAHDwAfNwMADRuA3QBGLTkuNooHJjgyiwcXMBgAPjcyNjgk
D-0ABiqAIv0AS3BC8AD9AFsCEBLwAP8AOCLwAP8AKoAi-wBJcCLwAv8AAlYAKTIQEAAfNwEBkx2g
-wACNAAG-wACIgAG-wADMgAP-wAGEWBAAB83-wBxBasAA-8AAtoBCP8ALIAy-wAxcBIANgAGAQE5
cFLg-wEoUuD-ACqAEv8AAhAAHzf-AFoAewT7CW3yCdACbycCbgJuAtACbygCbQJtAtACbQgAq28p
AmwCbALQAmwIAAwpAAQIABJuUgBP8gnwS9sESFYtMTEuMwEAEzT-AEYxLjE2AQAfNwIoAYxUGATw
lwLwQwMAcVAWIBYgRiAGAPEN8BwCUCYAJhBmECYQFhBm8BsCUGYQFiAWEDYAFggANBbwFxMAFmYR
ABEW6QBSZhAWADY1AAMgABAQSgACIgAAKwAIBAAPFQAAI-AbkgAMAwAfRAQBTqBgRjBGMEYgFvAg
3gARZrYAGyChABJgtAAcYBEAACsBLCAWMwAUZiAAAU0AAyAAQhcCYFZrAS8QZu4AUFNAGATwb2MI
CwMAETB6AhEQBgCH8BUCMBYAFgCjAmHwFAIwBgACABMgCAAFFwCkIAYARgAGEBYARg8ABwQABCIA
ChMAL-AvAwAEHTDsABg21wAEZw5HMy44MwEADncKD_wAChFAUAlLEAbwGJwAAREAFUAPAEBQBvAR
9wAjJgDkAA0xAAEiACJANjkBLwBG2gBTDwIMCg8xAGPwSigoBPIWA-IFA-IuBPIdA0ID4gPyFATy
BgTyBwPyDQPyAwPyAgMEA4IE8gwDQgPyMAPyIgNSA9IE8jsD8gUE8gEDMgPyEQMEA9IDggMyA0IT
BAUEE-ITAwQDVgDwABcD8jQD8hAD8ioD8mMEskEAEBAbADAHA9I2ACDyBiYAAisAEANJAP8APQRC
A-IjA_IDUgOSBPIkyAALHDXIAIKiA-IKAwIE4lUAYGIDMgTyCRMAITIDCAAA3wABGgABKACA8gwD
8hID8jeFAKDiAwQDcgSyA-IACQF5BAMyA_ID0soA0JID8gEDkgNyBFIE8lCtABEivQBgCAPyHQTS
aQAQRz8AMg0Dci8AgSIDQgQiA-IeQgEQMYEA4AAE8iAD8i4DIgNyBPINJgAxDgRihQAfAeYAHNFi
BPIxA4IEggPyGQRyuQEgVwSJADIIA1LfABDCDAAQ0hoAMFIDgmoAFhPLABFykgCgFwOiA7ID8hMD
stgBdFUE8gsD8hQ2AWDyBQNyA2I4ACAWA7QAQQED8gupADEMA0IYAoFbBPIhBDIDMhgA4QUD8hIE
8g8D8gsEYgOSDQAfINEAHBCCWwARIpkAEALEAHBEA3IEggPCcQIBkwBh8ggDwgMSSgIQBGgAIfIE
0AFBBgPyHBIAAskBEC1SAUHyAgSiyQJAAgPyG08AELLoABUG2QEQ0k8AUQUDggMiEwESEo8CMaID
QkkAEBcfATAdBKIFAUEdA-ID2ABQBQTyJQRDABAiJAAgQgRIAj8NA6LkABwAKwEQb18AMSIEkpEA
ExZhAUECBPIezwARMCECEBJwAZDiA-IzBPKDA4KsACLyACoAQaID8k4QAGAMA6IE8idSAjNyA7JG
AEE0A-IDbwLPLAPyDgPyUQPyHwSCowAdE2yrAjABA5KHAxcWOwIQAekDMQQDsqoAEAuMAEFCBPIO
RwMQASwBQKIE8pGvADMMAwRsASHyMywEUAwD8joEEgAVFj8AEDasAEGyA-JSXgJPLQPyLqkAHRAZ
hQECswEAhwMBoQFQBQPyDwQFAVEdA2IDousDEDtmAFIRAzIDBHgEAMYAEDoUAAEdAhBiYgQQLisA
EQLLABEtfQERDFYAERyjAUEJA-IEuQEQBGEBEhJYAwJwAVAMBMIDgn4DMUQDUlAATw0D8hrHAB1C
NwTyCTUDMRADsjoDEAbUAwFaA0EDBPJcbQMB8QEh8gUuBRABJwATFoMAAKYDBA0AEdKnABJGzwNA
BAPyMn8BBI8BEARNBQC7AAU7AEEfA-ImQwIQIMMAEAKBA08rA-IewAAZAH4h8z4aKfAIGRwLGfAE
GRwLDAobGfAAGRwrDCobGbAZHEsMShsZcBkcawxqGxlACRyLDIobCDAJCxxrHAtqGwoIDzUgCQsa
HCsPKgwaKyobGRIAlDofKgwqCyorORAAkQs6Cyo7OQoIDg0AABsAJQoLDwBWGgsqKxoPAFUKCyor
Kg8ARhsqKzocADYqK0oNADUaK1oNADNLSisLAJEaGykbKhspGhkPAFEraStpKhgA-y8KiQqJGggO
MBgaaQppGhgeQA4YGkkKSRoYLnAOGBopCikaGC6wDhgaCQoJGhgu8AAOGCoYLvAEDigu8AgusNQi
HfADNI7wAw6PEQ7wAQ4dbxANDA7gLE1QTA0fDwzVQ1EsDUwNK6FRYEwNLA1LDFlNQFxNWwxTTdBc
DyorDAsMWwwOQA4dJwDAKwxLHA8NMA4MCx0cHACAKywbHA4LDw16UzIMKw0TADQLHC4TADA7DRsk
ACYMPhEAWAsMKywrEQBGDCssOxAAdSscKyxLDAtCAKQLHBsMCyxLDB4baABwHEssSwxOGw0A-z4w
Dw0MWwxLDF4LCh81QAoMW0xeCwoZYAoMSwwuC04LChmACgwrDE4LLgsKGaAKDBsMTgseCwoZwAoc
bhsKGeAKDHsKGfABihnwA4nwFlgBHZBN-xMBoA7-FgEyAXD-FQENDxJgBkfwBhQN7xUNDg8UDxJQ
Dg8VHxQNzxUNHg8A6A81QA4PFS8UHyoNDI0uEgBCDxVvFAgACxcAEV8XABwfFwARTxcAHC8XABE-
FwAcPxcAEy8uAB4PYAATHxsAHh8bABMPGwAcLxsAER8XAB4-MgAAFwAfT2QAAT8vFV9gAAE8LxVv
FwAYzw8AAJUAVM4PFB4LEQBRCwruCw4OAP8MUA4K-gELDxIfNWAPEvsBCR81gPkBGKD4AfAvxwEd
8gAx7xjADu8bDrAOHa8aDQzvWTAMDazmTQCvT2QcDYwNGwylUhCMLAMAo1JADyp9OxYAwFAODUwP
KksMCwxLDJpUUEwNOwwbDAABslOQTA8qOwwrHEsMSU8BQQMRLBsAFBAOAAA3AFEPFxAObSgDIGwK
K1QyDEsMJQNQTgsKCRAPAAMNABEZDQAxGyw7GgBRMA4MSzwLABAZCwAhLEsWAPAAUA4MO4w_CwoZ
UA4MKwyO_wJxCXAODBsMjvsC-w5wDgwLDK4LDgsKCZAOHK4bChmQDgzbCgmw6hnA6YQzH6A1bx3w
BB4-IC8fDlnwCB8gLx8PIC8eHx8ewA4fIE8fDyBPHh8fQEjwBSBvHw8gbx4PHw8cgA4PIA8fDyBf
BADQHg8fDg8eDxxwDg8gHz0AwB8PKh8gHx8vHg8fHhkAAGIB8AAPID8fDyAPKg8gPx4-Hz4XAAMV
AEEqTx4PLAASPiwAMTAOD3cAET8XADAfH04XABMwQQACFQAUPywAEyAXABEvFwA2Lx8PRwBTIA5f
IB8XAAAIABRPMQAQH0QAEw8aABgvMQAAGwARHxcAGj8XAACiABMfFwAVTqYAA0kANC8fTy4AEx8X
AHU-Hz8eLx8_-AABgQBwLk0uDx4eDCYAEFCeAoFeDF4MDgwPHJYCMW4MbhoA-hCADxwcTgxOHAsf
NaAbHC4MLhwbGsAKG2wbKvAACmsqgGAP4QEQoBovIvAJDh8lDyR0SEEPJQ8kAi_RJA7wBQ4PJR8k
Ay8QJFVScQ8lLyQPJS8OAJABDg8lPyQPJT8OAJDgDg8lTyQPJU8NABPADQAARAABEQASoBEAJCov
EQATgCIAABEABSYAF2AmAAUqABlAFQASLxUAFyA-AAAVAARDAFUPIRAOXxYAYC8jXyQPIW0DAx4A
BRgAUA8kTg8jGwATEBsACRcANR81IDIACRcAEUAXAAkTABVgQQAFEwAXgG8AAxMAE6ATAAMPAEDA
Dg8kNgESPg8AIuAOQAASLg8AAFkBECRxARMeEAAiAw5NABMOEABDBQ4fJAsAIAcvBgAvCS0wCB6A
GG8m8AUObyrVAWINLykNLyguVAMLACAPNRBVQD8pDT8YAAYLAPEADzXQDg1PKQ1PKA0OsB4dCgAx
DykNC12xDSwHDQwvKAwbHR5JCCAMB1cIEEtEXiENfAwAIHsNSFlwbA0rDBsca00AQAAODVwOADA8
Ww11YXB9GwwbLAt8CwDBDVsMCwwbLBsMXycLEAARaw4AEmkNAMF7PBsMeQsOChAOHUs9CJAJDEkb
DhogHh1iBfMXKQwZGx4aQAoeDQxLDEkMCx4qcAoODUsMSQsOKrAODTsMOQsOGtAJABAK3gBlKwwp
Cw4aCgD-AgrwAg4tDCsOGvADbhrwBWqQUQMe8CMo8AkIHAsI8AcIDAsMCg8QDfABSAwbDB8PDxAd
LxKgCEwrDxEvDw8QPxUPEoAIHFsPEBAAAG8HUA8ZDxdwNgAwOx8QFzYBFAAQGBYAAD1UYQwbDBsf
EDw2EBAaABYfGgDnKx8qDxEPKh8PDxQ-FS8YAEIPKj8P6AchDxoYAABzBAAYAAF0AAIaABAfGgAQ
HY8EEEBKAAF6AAIaAFEvGh8YLxoAHSAaAGAPGQ8aTx2LAkgQCCwvMwASGT8FER9lA1AACAsKP1lc
Ch4AMx0fIoUDXwgPED8PHgADkh81IA0PEB8PH2QIMBofGSoFFR8eAENADQ8QaQgwGh8ZrQUVDxwA
IlANhQgCVAAzPx8vcAAyYA8SeAhCPxgPGm0AWA8iDyMfHwAAjgAQTxMBMR8vHTgABh0Awh8VTxgf
HQ8eHx1PIuEAUXAPEk8ZJQFBHR8iT3wAcYA-Fw8cDx4oAEAiDyNP5wMAEQAkDx1MAHlfNfABDxwv
yAMP_AsfAU4NIgsMTw0SKk0NEWpLDRGqSQ0R6kcNsfoDCwoIMAkM_gUJIQ1wDFoZShlaCagMogxK
CRwJKgkcCUoPAJQ6CTwJCgk8CToPADZMCUwNABSsCwA0SgmMMgBdWglsCVoWAFNKCTwJPA0AhAta
CRwJCgkcJwBSahkqGWoaACH6BQgAUAoJ_gMZLQ0xGeoZKw1AGaoZGCkNMRlqGScNMhkqGSUNHykl
DS0gTxH5AiEfEMEGUBGPDw8QvQYxEa8PX1MwDxHPCQBQoA4PEe8JAKCADg8RXw8ufQ8QnwZQEW0O
HA4MAEBADgyNCwARCygNALtjMG0OCgsIQAx9DjwMABoJCwAzbQ5MCwBkC20OPA59FgAECwAhC20C
ZAELADF9DhwLADAwCg4LALBtDgoZQAoOfS5dDvYMMA7tDvIMMA7NDu4MMA6tDuoMADAATxngCo7p
DC4Qz_hqMBYfFfgAYRb-FAEPFfAMURb-FAMO6wwDCgABqwsJDABFbxRObQ0AU10OTA5dDgBkDE0O
bA5NDQBfPQ6MDj0NACkJTgAIaAA1DxVtggAlDP2ZAB4VCwAAsg0z-QEOWQy--gELHzWA_wEaoPpZ
DCXxAr8bDxoPGw8aDrAODxvPGQ8aYAwwDxvvCwAFCQAAxwmADxv-GQEPGg4KAEFvGS5tFwBAUA4P
GwACAA4AE1DVABELWwwCOAKhCw4wDgxdHkweXfMGcAtdDowOXQtRDMQMTQ6sDk0OCQoADgsLAPEA
EAkOPQ6sDj0OCRoQCQ5NAWIRLBoA0DAJDk0_DD5NDgkaMAn9aPABDn0OCQpQCQ5tLm0OCRpQCa9T
kgkKcAkO7Q4JGgcA-wMKkAkOzQ4JGpAJ7gkKsOkawOpADCURLxAMEx9EDGBvHh8fHxxBDBGvHgwQ
HD8MMu8eDjoMIH8eqzUBMAwRfQoAASUBUiCNDo0OFgwCvQACZwtBDI0ODBkABQsAEwuKA2AsDn0O
CwqgCwYMAAOLAwALAB8JCwAAMjAOCVUCUQsaMA4JlgFgDgsKUAsJJAFACxpQCyQB8AMLCnALDu0O
CxqACx6tHgsaoBu-XQCHCx9uhwsvAX0LA4kLFS_FCxVPgQsVb30LFI95CxSvdQsVz20LMyM_XWcL
EU1aAgBeCxAMCwBCjQsOQAoAQK0LDiBNAmAsDj0eXQ47CxAMDQAA92UQXc0EEAAdADA8LhwOAHAJ
EAoOTQ6MylZCGSAKDoUDAZgEUk0OTA5NmgQ-TU5NnAQHAcgEMfABCi0AUPADCg4tCADPBQouChnw
ByoZ8AkpxAokgT8qDykPKg8pHgEwKm8oCgAUAgoAAcgKMQ8qjxYABQoAAMYKMA8qrwsA8AywHg8q
zygPKR5wHh8q7ygfKR5ADh8q-ygDHylmDFAq-ygHD8FsBAoAABcBCQwAHykYABAFDABAEA4fJ1wA
wCcOHzUgHh8n7ygfJ1xf8QwNHg8nzygPJx4tcA0ODK8oDA4tsA4MiwwOHdAHAJMN8AAODGsMDh0I
AO8N8AIObA4d8ANuHfAFbZ8KHyAvJmkCAzcBUAcODyovDAFQ8AFODyrQC7FOoA5PKm8oTykOgEkB
IS8PTQHScA4PKl8oDw8vEQ8PX0gBH2ATAANCHygqDRUARQ0vFB0XAPAADQovDAoNLw8NDxQvFg8U
lmIB-gQgKh0ZABJNFgAALwAAzz0XLRQAABNlkyAODE0qbS8UTZABFP1fAYMMTS8jbS8ZTWIB8QMP
Jy0PIy8lDyNNDxkvGw8ZLQ9uAUkODycdGAARHRgAQkAODA0XAEINLx4NGgARDRoAgFAODB0vIw0P
uQQxHg0vMAAAxwAiDF0TAB9dEAAFQW0vHm0MAP4RcA5PJ21LDh81gE4LTQtOGeAOCy0LDlnwAQ4r
DhnwBy71Ag-xCSo3Kksq8wk7Kssq9AlBCvsDCm0JEwx1CQ8SAC0fCxIABloKCSrLKtAJPypLKtIJ
XAAkDRMfBAAUL94JBBEABAQAFA-uCQwZABQv-gkXLxUAIR8PqgwCDAoMMgAFHQAeQDYACnQALw0w
PwAEAnkAEg4DFw8jABIPaAAHDyMAGAcTAA_MACgBMwEfH2kAAQ8jABZIMA8NDrcBDSMAbh81QA8N
DpMBARsAH2AbAAADNgBGgA8NDhMABPsBARsAF6A2AANJAFLADw0OjwsAUOAPDY4NlBFfjRzwA4xX
Cz0C1g4OBAAjDxRuCxcPFQAKBAAE1QolFi8TAAYEABYvHwAPYwAKAiMAD2UA-xwBGxAfH2UAKQUT
AA9lACcAwwwn-xTEDADkAl-9ARyg-MQMPV8fGQ8aDwQAABQf3AwPIQAKAvQMFy8XAAgEACMvGQsN
BBEADwQACQMpDQ5vAA93AAAPKQAWAEAMDqAAD6gAAh4wqAAPBAAKAo0IAWcAHw8EABABKAAvFxC5
ABAGMgAQDuMTHgBlAA8zAA1EEA8XDhMADwQAD0EODxcfMwAPJwEPAV4AXzAPFw4fiQARHx8rABc_
DzVQtAAPrAAFHlCsAAykAB5weQAMnAAPIwAOcg81kA8XDs8uAM_QDxfuDQ81sO0cwOwiD0hGHx8f
HgQAFA8wDxcvFQAABAADPA81-x4BPA8EGwAEBAAjLx5LDwABFQQVAAlZAAEcA0Eg-x4FWw8OZQAA
iRUDKQARIEgABBcACAQABB8AEh9IAAIrAA9KAAsfH0oAFABKGw-WAAICZRsP2AAIUlAPHA8fHQEA
LgI-HA4PbgADRnAPHA4TAAKoABMOhRsxHq8e0Bv-C6AfHB5vHh4fHB81wA0fHG4cLfAADWwt8ARt
ARA7Ih8jFRoCBRAADxoGEgATASoABRIAF_AxAAUVABvAOAAEBAArDqA-AAQEAC4OgEcABh0AH2BP
AAQEBAAvDkBXAAQEBAAAGBpIHyMNHAIAAYcQSQ8lDRwCACAMDmYXEAAUHRccAgARLBcAWxAPIQ4M
LwBaCx81IAsWAEgOCxpAEwAAwHoYYBEAEQzQEScODDEAFKAPAAAtABTADQAAKQAT4A0AUA4LGvAB
DAAAIgAg8AMKAAAfAN-wBQsuCxrwBysa8Akq2BA8SA8oDykEAATkEAwYABUP9BAXHxIAFh8AEQgX
AAUbAC6wHhkABB0AASQRDx0AAQIhAAM8ERcvFQAMBAAjLyhXEQ5jAA9WAAUD7g8O3gAPBAAKAH8P
HwBoAB0BMwAFEwAPagCFJikfEwAPagARAHQSD5QBDASPEh8fSgAGBqcSHx9qAAQCuxIdHxoAAssS
ghsPKQsKCwob0hIjCwoCAAPaEgUOAA-gElASH7AAC_QSF1_0ABRf7BIx-ygBLQMC0hIGIQAdD_UA
BScADzMAHBFQMwATA-ISDjEADzkABDIgDg1SFAIaAy8NDAIAAQMwAjUN-AcZEzscDQwCACEcCxwT
YAv8AwsOGsZ5Kg0MHgCvGlAODfwBCw4KYB0AACYKYB0AEVwVAPEMXAsOCnAOS2xLDhqATgscDRwL
ThrgDgssCw5a9xJOGvAHLhQFD-cSS29LGUsZSwrtHAK-CisJPAkLCTwJKwrvHABFCisJrBoAFkrb
HG8KSwlsCUsYAAARO-QcLzsK9RwCbwpbGSsZWygTzR8uJRMEbw8PDh8RDiUTBgAdABUfDgAPIxMB
JA4vPwAPlRICLw4-HwAAFi99AAAfAAgTEgohAC8OTx8AAQMPAAxAAA6AAA8hAAYtEC__AAtjAB8v
IAEADxETCAElAAgjAAoRE3UPDy4NDxA9DhNRLQ8QHQwCAAUGEwMQACAMDSUJEKBjfDIdDD3fCBGN
2QgQjtMIX4sa8AOK7hKoYQ8UTh0PFap9AxoAEQ30ACJLDg0BARUAEAtMfRBrXX0EEQAAIwAmiw43
AIgLDQwdDosODTMAPw6LDjEAGw1kAADAXgAjAAU2ABAMDQAhHU4GAAY4ABMdAgAEOgAnDB0CAAo7
AAQCAAMcEhgM3h6fCh81gPoBGaD5GhKwQS4NDxpoBhIMPQciGx0NACErDggAEB2dKxELFAABYgEB
EgAAKQ4nCy0UABAtqCsQCwoAYg0MHkseDAoAAFofAFgBAdEBAjsAAI8RAU4AIQ6raAEBaB8aDBEA
RRAJDg0RABINdB8A8wFRKw4LDiv3AQF4HwA1ADI_Cz41ABMaEQAhDQygfCMMDUwAI1AJDQAjDS4I
AAKWHwG9AAMCABItoR8DPwAEOwAeGhMADrkfD5cQZTsPHw6YEAPfHwHDAWAgHR8fHRyshCMcLZIQ
MQ0MHbqEIA0cGQAC6w9DC40OC_UfMAstHNSEEA4mACIMDXcjEgssABArRwAUHX4jFCtdIzAtHB38
AQIvAAAcAAAuAAEMBAQtADBtDkuhHgBvLRMdLQAhLQ5zLSUNDFkAAD0AMFAKDAogQQoZUAqgABMd
cQAzcAoODQARDAQf8AgerR4KGaAaHm0eGhnACRpuGinwAAlqKVSBHxcXEJw-DyM_FBACUw4vJQ4P
FwANEhABHQAFGwAJEBARDzoABBcADQ4QAB0ASw0cDR4PEALkAxIOeA8JERBsDA47LhsODxAhDoux
CmIOCh81IAoSACBrDkgAAbYgARAAEUu4DwG7IAAQABJOMAAAwSAC6Q8CLgAloAoFEAHPIAINABIM
1SATDCUAANkgAk0AANsgAKkAD90gSwQPDAQEAA8FEP---zknLw4BEK9fKA8OLxAPDl8o1Q8BARsA
BuQAByMAIikNHQA3DS8T-SIyCSsJYAACMpQH-iJCCSsJTRUABP0iYR0PKQkrCcwHAhkAAMoIAAIj
NCltKgEjLw0MAgACBhYjRiJtLxgWI4EdDA8iLyQPIiYAhw8YLxoPGAwdHCMBHQASTRkABxwjAjQA
Iy8dMwAHHCOhIg0PHS8fDx0NLzAAAOYAAkEJAxcAADsHBiQjARQABjQjAFIAAg4AASYjEUgmI-8M
CB0MHQhOF_AOCC0IDlfwAQ4oDhfwBy4X8AknGS1VA5kPMwy6LLcPQ7oMCgwLABTaCQAjWowJAAQu
ACw6rCMABjcAOgu6LC4AD-QskiF-DwQAAsUPI48PNQAAtQ8hnw8EAAOjDwIOAATPDgEPABEPOwAF
EwATfxMADxcAEkUQTw8fFwACBAA2HxFPNgAhTw91DwUfAAAMABhPPgATPxsAGD8XADX-DwVODzX-
DwM3DzX-DwErDyXvDyMPFs8ZIh_vESJcAlItFVAKAAK8DggMACCPFAQADw8ABVhfFG8WXw8AXA8W
TxQPEwACVScJFwATPxMAXC8ULxY-LgAcT0EAGL8PAB8-kAAHGxWfAAfJAB8VDAABD9cgBw_bLVsC
CgABkABDG-8ZA1Igkk8ZPxsPGT8bTzMAABEgIV8Z5w4jGw8IABRfKiARXxUAEx8EAAMZAAGJBVMa
bxkPGwQAA-IfE29ZABJvVx4A0h8Tn1UAEp8TAAB-HxOPEwAWj5IfCRMAAnofBqUABWIfNf8ZA0Mf
Nf8ZASQfAgwAAg0fFu-1HgELAA-dHmEF-y0Cmx0Mwh4z-x4DIQ6lTx4-IA8ePyBPHqceIV8ej2gj
IA8IABBfGwAEGQBTDx4fIA8IABJfNAATIBsAdj8eDyCPHg7IOTavIE8iAAe1Hm8fXx6PIF_GHgNl
bx5PIG8eeh4CqQAPZx4ABM4AAFgeEu8wAA9KHhIPSy5qVD8jPyVv_g0hTyP_DSQlf-ANIF8j9A00
HyWP4g0jbyM8AJMgDg1-I08lnyPFDSF-I4UAECVuKyRfI8ENEX8SAAoEACVfI8oNE281AAAEABBP
FwCyHzUgDyEOXyOPJT8PAHFADyEO-yMBDABSYA8hDu8XAFKADyEOzwsAUqAPIQ6vCwBSwA8hDo8L
ABHgXgABCwBT8AEPIQ5eAGPwAw8hDi8MAFAFDyEuDJ41Xywb8Akrww08AQoAD6AuElRfKA8nX3sN
VG8oDydvZw0ADQATDwQAFG9XDRePFQAUjzsNM28oLxUAQS8nbyh5CQBvAASZLgBTDDNPKE8jAD9P
J08jAAMPRgADHSlyAAJxDBpvngAEYQwTbw8ABE0MA98AD-0ugwLRGwwOHAgMAGV-KA8PfygPABE-
_y4wDS8UpZIC4AsQTVOJEA-2LjMNDE3hC4FdCi0PDy0MXc4bcwttOg8PPG2rAVGtDyetCVoBoQtt
PyMPHj8ZbQlSAcEJXQ8jLQ8eLQ8ZXQm3C4AJTQ8jDQgND7kuQQ0HTQm0CzALPSgSADEnPQmpC2EL
fQ8efQmdAGwL-QEJDgYIAP8TcA5JbUkOFoBOCU0JThbgDgktCQ5W8AEOKQ4W8AcuFvAJJvkCH-Ac
PAsMC-AEHGob8AAcugnADOoJoAwaHyq6GYAMGi7KCQhgDCoe2hkIUAz6BHgLwzAMahlKGUoZCDAM
WqEbczoZCA0QDFqNODAqKQgNAACcG5MqKQgNAAxaCawKAPoBagmMCSo5CA0AC3oJbAk6ORQAEWqS
G3MaSQgNEAtqkBvwJio5CB0QC3oZKhkqSQgNMPoBSQgdMAnqWQgNUBmqaQgdYClaiQgdgAjpCB2g
GKkYHcANGGkYjAUQaIwFD3ACHiEYP30L8QQPEPAEHxFvDx8Q8AAfEb8PDw7AbwsgDqDGCnAfKr8P
Hw6ACwAwLyrPAXIQYJ4agB8q3w8fDg1QIwswLw6PGAAA5gchEY8vGjAPDn8eABEwdwsBEAAQbxAA
ADoFANsLQA4vEQ9VoDIODRAiABQ-EAAAXFsPEgAAAFYAck8RDw5PDz8SACUQjyQAFz8kAAkSACUQ
j2oAEk98ABQQngABJAAAqQgUEKAAEj8kAGAwrw8vDi8MAAChCEAO7w9fFgBgUB8Orw9vFABgYC8O
Xw_PCgAwgA3vBwBQoB2vDh04P0Adbw4dEw1fbS7wBG6LASABdwvRDxXwBB8WbxQfFfAAHx5cgMAP
Fu8UDxOgQRpwHyq-FB8TgAsAkC8qzxQPEw8SYBgLkB8q3xQfEw8SUMcKEAQXAACLAWEWjxRPE28Z
AEAwDxZ-I6RBFg8TXxEAAA0BARMAsG8WDxNPFC8TDxIQKTlxDxOPFg8TPxEAAEMBDxMACTMvFD8T
AB4VEwAPJgABBHAAMy8UT4MAFBWWABE-JgAAkQEQFbYAEz8iAFEw-xQBTxkAYTAPE_8UXxUAYVAf
E68UbxYAYWAvE18UjwsAQYAPEu8JAHCgHxKvEx8SkwFvHxJvEx8SlQEpEhujC-EC8AQfG28ZHxrw
AB8bvxkPGMCdCyAYoFoLcB8qvxkfGIALAJAvKs8ZDxgPF2A_GpAfKt8ZHxgPF1AECzEvGH8aAACY
AaEbjxkPGC8bDxhvIAAwMA8bHABRTxsPGF8RAAAZASUbjxMAUC8YDxcQJABxHxhPGx8YTxEAAFAB
AKYLZhiPGw8YPxMAs18ZDxivGw8YHxk-EwAeGhMADyYAARNvlAAiDxsIADMfGU_LACAabyYAQRs-
GC8uAACkAQADDAEqABNPJgBhMJ8ZLxg-DQAAqwFBGO8ZXxgAYVAfGK8ZbxYAYWAvGF8ZjwsAQYAP
F_8JAHGgHxevGB8XqwFfF28YHxerASkBxQtCDx-wBMML8AHwAB8gvx4PHcAPIO8eDx2gfAtwHyq-
Hh8dgAsAMC8qz-E_IRxgCxoAx0UgHX8TP5EcUA8gnx4PHY8eAACvASEgrw8AABwAEjAcACQPIC0A
ACABJSCvEwBNLx0PHBEAAF8BATcAXi8gDx1vEwAzXx4-EwAQH3UAVU8gDx1PEwAeIBMABSYAMz8e
T4MAJR9-EwAAJgAAowEBJgAXLyYAQzCfHi8NAACjAUEd7x5fGABhUB8drx5vFgBhYC8dXx6PCwBB
gA8c7wkAUaAfHK8d_At-Dh8cbx0fHKMBKQK_RfAKJPAEHyVvIx8k8AAfJb8jDyLADyXvIw8ioMAL
cB8qvyMfIoALADAvKs_QQCAhYGQLMB8q3wZBcCFQDyX-IwQXAACcAWEljyM-In8ZABEwxwtDIi8l
DxEAABkBBRMAcY8jLyIPIRAEDAERABGfEQAAUAEFEwBePyMfIj8XAABYdREPCAATPxsAECQbAFk-
JS8iHxcAATIAGo8qAACAABFvEwATT5MAARMAEU9vAAAmAACsAWMkjyNPIj8iAFEw-yMBTxkAYTAP
Iu8jXxUAYVAfIq8jbxYAYWAvIl8jjwsAQYAPIe8JAGGgHyGvIh__RW8fIW8iHyGlASkDFAwg8ATE
C-ADHynwAB8qvygPJ8APKu8oDyegRRYAEgAwHyeACwAyLyovhDlAJw8mYLAKAGEZkE8PXygfJw8m
UIMKE08eAACwAbAqTygqDk8PDi8ULiAAUDAPKj5KjadBTxQeHyMARBAPKk4SAEAvJw8mEABiWg4P
Dw5fEAAAVQF1Kl5KLk8ULg8AM-4FPwsAhCleTyMuTxkeEAAgKk6wDVUeDl8ZDiMAo05PIw4vHg5P
GU9xACQpPhIAACQAAJABkylOLyMOTx4OLyQAYTCOTx4uTx0AgTAPJ35PHh5fGACBUB8nbi8eDm8a
AFBgLydejQkA8AeADybtDB81oBytHBvACxxtHCvwAAtsyJcPjQH-rQ86DAseGTkMMhxKHDkMcwwZ
DCoMGQw5DHIMOQwKDDkMOQxADEkMSQsAADkMIwypCgBDagyJDDkMWgxpDDo5FABjagw5DDkMOQxA
DBkMCl8AAjkMPxwqHDkMCi-5ADkMfBkROQwhER9_FwU5DAEQAAk5DCERL-VEBTkMJBE-EAAEOQwL
EgAAVgART54XBzkMAyQAFz8kAAkSACUQj2oABzkMJBEfJAAEOQwBEgAHOQwfETkMtycWbzkMWhZP
Ew8WOQxYFm8TDxY5DFoWjxMPFiYMDxMABQo5DAsTAA8mAAEEcAAKOQwBlgAKOQwfFjkMvxobOQww
Gy8Y_QsGOQxaG08YDxs5DAMTAAY5DFobTxgfGzkMIBuP1AsGEwAAFRhKrxgPGzkMCxMADyYAARNv
lAAiDxgIAAo5DACeDBobOQwBKgAIOQwfGzkMrBggOQwaIDkMGCA5DDQgDx0tAAQ5DAMTAAY5DAcR
AAQmDDAgLx27Ug0TAAo5DDEgTx1_GAQmAA4TAAUmAAQTDAI5DAMTABE-7wsCOQwBXwAIOQwDDQAP
OQy7GCU5DFolLyIPJTkMARMACDkMAREACjkMARMAXj8jHyU-FwAAGRgAOwwKOQxpJT8iLyUfFwAB
MgAajyoAAIAAEW8TAAg5DCElT28ACDkMHyU5DP---7APcxgAQvoFGQgGAHINEAz6BikIBgAlDQAH
ABEFCgwCBwAFDgARBBMMIfoDDAwv_gJCGJc0-w8EBgwy-w8F-wsCCQAB_Asy-w8G8QsCCQAB2AsJ
CwAUBbgLBgsAChYAFATHCzT-DwPACzL-DwK5Cz--DwG2C7Iz-xQFswsDCgAA8gBDFv8UBqULAwoA
ABMBCwwAFQVqCwcMAAsYACMET1IAABIjET8xCwEMABICGAAPcQu0Nf8ZBG4LM-8ZBWcLAwoAAP4A
Qxv-GQZZCwMKAAAgAQsMABUFHgsHDAALGAAjBE9SAFEa-xkDP9YKAQwAEgIYAFEw-xkBTxYADxYL
oRTfEgs1-x4EDwsz-x4FDAsDCgAA-gBDIP8eBv4KAwoAACABCwwAFQXDCgcMAAsYACMET1IAAOQi
ET_DCgEMABICGABRMP8eAU8WAA-DCrYz-yMFwAoDCgAA-gBDJf8jBrIKAwoAACABCwwAFQVnCgcM
AAsYACMET1IAUST-IwM-LgoBDAASAhgAD24KnhjP3QgU39kIRP8oBA-WCDP-KAXPCAMKAAD_AEMq
-ygGwwgDCgAAIAELDAAGuwgHDAALGAAjBE9SAFEp-ygDP20IAQwAEgIYAFEw-ygBTxYAVTAPJ_8o
mwglryiZCDFfKI8LAEGADybvCQBxoB8mrycfJlABXiZvJx8mUAEPpAgiIGpPwQcgDFqcEwGqCPAB
Co8PLxQPGIAMGi8qbw9fFKlbkWAMKh8qXw9vFBVbkRxQDCpfD38ULw0AAMQIAw8AwS8eDyEwDCpP
D38UPw0AMg81EA8AMU8ZL0ZeQRAMKj8PABE-DwCoDzUADBpPD28UXxEAEz8RAAO2W3YLGi8PbxRv
EQCVDAo-D18UbxlPIgAjCi8RABEvEQCREAsvD08UbxlfIQARHxAAET8QAAIgACEwHw8AE28fAKMw
Dw4PDy8UXxl-IACBUA8OHxRPGY8PAADPJXIYLxmfHj8j4QIyHJ8eXFt1oB8cTx5fI_UCHyPlAipA
afAEGZkBAyIu8g4YwAkcqgsJCKAJDOoJCIAJDPoBCQhgCQz6AwkIUAcANQ81MEJbGjBUPhIQ_VoS
CvtaAQ4AALUiABsAEAANABSsCwAxWgmMGT6NAAkLaglsCWoWABFauiIRWlQACEs_RB4QCQtAWzAw
CAuQAEAeMAgJCABADlAICa4A8QEeYAgJ6gkIHoAIGaoZCB6gUS5RHsAOGGlPLh9oKAEjEG4EZAOJ
ChAexSkBiwpQHw3ADh81FkIQDg8NQi4wDg8NQi4CXS0APy4Ccy0RUGcWIi6Nii0yDg8R6FoARy4C
TFsAt1dCEA4MnatXEBAWABE8tVcZAAsAM30OTAsAIA8QYlsUjRcABAsAwgl9DiwOnQ4LChAOCWQA
UwsaEA4JZABRCjALCY3MVyAwC3asIwsK1FcvGmDUVw8PNgEfIG8TNwEDiAoBNwEBigpxHxLADh8W
r1-GMBKgDpAKMw4PEg0uHw4MLgUgMA4XFlBOfQ4PEgsAArRYIQ8SNwExbQ5sDQABxlcQjMFYAEIm
BAwAGQoLAC8PFRcAAhIJRAABOQEDEFkAOQEjfU43AS-9AzYBVhAYNgEDbgoBNgEQG3AKcR8XwA4f
G69LLSEXoL0tUA4PF4AO9wkAyywRYAoAAO0sAK8tQX8ZLn3KLACQLQIBWiQPF1RbA20CA00CAEAB
TB5MHm0SAQNgWwALACYPGgwABxcAIwldYVsSXTgBVF0_DD5dcQIBjFoAOgE-fS59OwFWAqxnAlkK
D20tFyBgDs4UAWI7BmpbATsBQyCdDp1MLQLSAAECCgCoAxEMGQAFCwACcQIADF8CiAMHCwAAgVse
TMEDFAkLAAtxAgICBA85AV0QIjkBA0IKATkBAUQKUh8hwA4fFy0gDyEQLQFhLAAMLQJ2LBFgCgBV
Aw4PIVAKAAE4AYAlfyM_jQ4PIQsAEW0KASMPIaoDNiwOrXBbE705AQSJWwEkAQaJWwAPACQPJIlb
D7IDhxAnPgEDMAoBPgEBMgpSHybADh-KLEAPJqAOOApCDg8mgJEsIA9vDQARYA0AEk8NABhQDQAB
RwEBUSsRT1ErMA4PJhEAIC1KQ1oxTxQtIwAAMisTPRIAACIAARAAEFpvKxFfEAACxSxlTUotTxRN
DwAk-QcLAHYpTU8jLU8ZGwAgPV-0WTUNXxk9ADEpPU8dWjRPGT1yACQpLRMAAIUAER8TAFA9LyMN
TylaAiYAojAPJg8pbU8ebQ5wCiMmDg0AAOcIQyYObS8aAPADYA8mDu0ODB81gAwerR4MG6Ac3bIA
DxMebg8TD5AB-6gPZgoANypLOmcKOBrLGmgKTQr7AQpqCoIKOwkcCSsJHGNIDWwKIQo7bQotOwpu
CkIKSwmMskgKcAoJGAAJcgqBCksJHAkLCRweAAt0CgKcAAh2CgG9AAd3CgDFSA95ClInLw9TSAKB
ChM-EwACFwADjQoEEQArHw9jRwCgChUPEQAPIQAAGVAhAAPfSAUeAAETAwlBAAqiRwHZRywPDSUA
AQ8tGw4lAAHKAgWTSA42SAElAAojAAb2SAdGABsA8AAAJQALtQAKIwAvDk8hAAEIm0gH3UgDEgAE
RgAPJQARBRMAEB8qLgklABUf_QAvEA9FAQ0B1wMHTAAKJwADdUkyMA8NDgIGD0kBGEcBexYQDaE8
BldHVQsPNVALEUkAJwABHQcUTR8AACMHAR9JDw8MVATcSBY-FwwTPxMAAhcAAyMMCBUABQBJH2AZ
AAAFPEkARQwPOkkIFzAfAAQ6SRMdZQwADAERDSxFEgyJSBAQFEcTHdZIAigAERD4SAMLSRMtPGQU
LQpJAXVFEgA2ACEOi4MBAREAGQw0AB8JMwAAKQwdaQABKHMWLT9JMB0OCi1zFR09SREtNmkBIwAC
AgABxEUXCuMBET3DRSYOLQ8AAP5DFT0NADCACh4NAB8tvUUFD8sMPAj-SBYv1wwIFwAGHwAD6wwP
VkkFBZhYH2BCAAQJSgAAIQ0IFQAABAAQLkc0A15JAzcNKRwNYUkhDRxDDTcLHA1QSQABRQEXAhks
FgARLKxoLQwNaEkkCQAXAAHtAQsVAANKSQITAB4NEwAPJgABJywNckkhDSwpAgCkRQR0SQGjRQQT
AAh2SSENHDICAw0ABnhJEgw4AgLRAAQCABIsPAIERQAFQQAoGWAqABIsRgICEQASLEgCHmxIAg-Y
DUYcL8dYAOQNGR8VAAOiSQvzDRANiEkUHVZJBP0NED0qSRMNnUkCBA4VCwQOAYpJAE4BAflIAQwO
AYlJEB2oRxUcn0kQAL5JMisOjcABADQAAKkBAzlJEgCOSQA3AgMxAAAlADF9Dku9SRIARwAzDksO
LwAQEPgBBC8AEi0BBATqSSIwCksAEy5JAADDARItlUkiHB29ASL9AbABFC0VAACsAQENAA-yAwUP
SQ48Ez-vSBYvUQ4EEwAABAAUP10OFy8VAAUZAABsDgQRAA0dAB9QNgAAAmoABZIOBjwAQD4dDyQf
BQKfDgAPBSMOK0oFA6cOA_UFNSsOHRcAEhCiBRIrfQUWDN4BFQ0rACENHnUFBe8FAFUAAatLAb8F
EQC-BRAOr0kG5QUKOwYiCQCHAAv2BQITAAOGBiMKGQgGMw1OHSMAD-YFAQLWBQQiABZQEQASLQQC
CfYFAugHDwQCBA9-DTwAcDoGeUcOiw0YHyAAFg8MABYfnw0CXWkFow0LGUkBHQAHEAAyKQ8oBA0D
vw0Fm2kEww0wHQ8pbmkDbwACC0IhKR00AAHADQeLaQTUDVANDykNDBgAAlBGARwAAAsAATUAALkN
Aq1pBeMND65GBAMgAATEaQkvAAKYaQEoAAKZaQgxABk9zWkTPawAJAwdNgAkLx41ABMdEw4QDBIO
Bc9pBRYOIgwNAgADGgAFlwADJQ4CFwAGKQ4CZ08jLx5oTwYzDgBGcCILHqxPQi0eCxkyCmAZwAkb
bhtKAh9rSgL--28P6RokAK5IFDARSYEQCQzKDAoManAQI_oMRxAjaowJACH6BwgAMwtKrBEABCMA
Ews2ACMOEBBJIx4QCEkPxBqeAgoAKQ81-kgJDQAB6wIBSTEBP0gJDQABlAIjEa_-SBaPEwATjxMA
ChcAHxAXAAM_EV8PJ0kWXzYAEF83MQcfAAAMABVfmwAOJ0kCWw8HJ0kADQAVAzYPAjRJALYCDzRJ
BUAerw8eCwCAoB8NHm8PHh80STcNHw3ERA87G3AgnxQEAAPYDgUNAAETAWAWfxRvFn8PACMQDo4x
IhQPEQABUgEnFn83SQcXABNfEwAAN0kVXxcAIxV-N0kLQQAY3yIANT8Wr38AFRWOABofDwAAjQEy
Eg8VxgAAjQEkEg7SABFQDAARARgAQWAPEg4HAQCNAVASHq8UHgsAcaAfEh5vFB79JT4NHxKNAQ_S
G10CCgACWg4x-xkFTA4A8DACskghXxkdAAIRSQHoDgVXSQEZSQQZAAhXSQYySQEbABxvEwACWgAP
WEkHACYADhMADX5JOQ4PGqYAAaYBEhrDAACjATIXDxrcAACjASQXDugACHFJJWAPZUlwgA8XHq8Z
HgsAcaAfFx5vGR5QJj4NHxejAQ-6G1MGW0kEvEgVMP5IITAOBjEBcUkDAEkQEOuDC3FJAQBJBBkA
CHFJEm80ABMAGwAAcUkWnxMAVV8eryBfDwBHH-8eBy4APo8gbxsAIBAOUjEQT0VYMQ8cHw8ABYxJ
AnFJEQMZABEwcUkCzgAGfUkAiQEPfUkbD0occGNvIz8lnyOtDSFvI8kNAhEAJA81W0kAhUkB5kgE
EQAS3yAAEQAPAAOISQQPAA_KSQAC_zAbDwQAHl82AAAEAAk2ADWPJV_LAADsJgE8SQYMAACXATIh
DyTQAACXASQhDtwAH1C8SQZAHq8jHgsAcaAfIR5vIx7rIz4NHyGXAQ8TG0kz-ygBJwsz-ygDIAsC
CgABlwFzKp8oDw_fKPkKEV8OC0ENLxRdIAAA2QoXbfhHE23tChJt_EcCBgoAnwoC_0cFDwA0rQ6t
DAAUKf5HBR0AFG0ASBZtJABDDyMNCwJIJAltewAwKV0rFAAhKV1WCgARAEGdDx6dHgABCBsh-QMZ
ADAwDyYbHhAIEIIAGxH-FggXYAgO7Q4IF4AIHq0eCBegGB5tHhgXwAcYbhgn8AAHaCfwBGd5Af_Y
UTApoCmQBFUSYAYAYwkcKhsJQAYAgAxqCwkgCQt63Qv2BXoLCQAJDIoIDzUQCQyaCwkLmgkICgAA
wAsxqguqCQAUDAkAEQvsC0EQCfoGzQsABwATDsQLkR5ACBnqGQgeYNJUIR6QvAtqLpAJG6oZbgzF
cAkMegl6CQgOYAkLCQAxagkInxyRcAhKGQgOCBk6Bgz-BDkYHgAYOQgeoDguIA44HsA_YD6KUB9l
E47wBA5PAAyAAw4NXw8dDw0JAEB-Dw8NAIcTjwgAAZNUAS5VA51UAB2GAYELEvCuCwEVABbgCwAR
0AIMDwsACABoVRavCwASnzwLH8A3AAQCbAA4HzXQbQAlDY_MAA4KAEIBDw0OtgD-EQIMDm8PDgwP
NfACDB5fDw4M8AMcfgzwAw81jAvwBItAwVEfD4oLAwAAjD8WzxSGCwIVcAoAAQRND5ILBDP-FAWP
CwIKAAFbUQ8MAAUfFRgADREwDAARAwcLBgwAAIAAMf8UAhYABAoAPw81cDILEQ_DUSp1GU8Y8AYe
HzMLIAMOMwsgDxdVAgKxUyTwAAoAAf0BIBuvCwAFCQABJwIECwAhsB4LADEfF5BSAHOvGS8aHxdg
QhoQj4eHWBkPF0AOVwsEngoREAwAEwdBCwIKAAHDBBcaDAAPGAACIBAOnQBRGg8ZHn24CoAgDxce
TQ4MD7fXoA5NHgwfNUAcThwPACAcTlkJMgtMCx0AYAtMK5BLDAfYUgsAS-ABCgAs8AcIAG9MC-AI
S6BYAR1AGw8d8NZjYPALDg3wCulxEBwHAGEgDxwN8AkPADEN8AiQcjYODxwKADEN8AYeGQAVAAUK
ABANO_wC8VMAnlECbwoi8AEZGUQPHPAACgAwDdAOOjw1Dg8cCQBgDbAODyDPCgAFCQAoDaAKAB8f
FAAHMLAOvwgAEx0IADAN0Ax9CmAMHeAcbhy37g-iCCNzNV8i8AUeH3kKAGEJZPACHh8lL_ZSAX8Y
BAwABVBTAQwAA8IJL-ACGAAIBAwAEQGFCgYMACF-I9AKIg0wDAAQDTjYIg8le1miJY8jDg1wDg8k
DhAAcCSfIw4dMB5dCgMSAHQlryNeHyUfDwAyJN8jvwARPxIAIjAOOgomDR8LAAFRBAAlMSMNHwoA
EAEVAFJwDv8jAEU2AD4KAI0QEB08CgBJNp4MHW4dLPAADG0x2A9-vUVjGU7wBw4fbAYyDvAFvVoh
EA9zAhMQnVo20CkQDQCmAC8TgAkLDAsJABQAIg8TdQWlDxNgCQwqCQgADuogIg8TtR8wDxNA7CMV
CBoAATRCALE2AZwuVggPNQ4fTQACGgAhDzWgbDYIAB4YAALNNqAwGUoJCA0ADw0dFgARPxYA9hEd
QGkIDRANAF8THxIdcFgNMFctkF1AXaBfIkBfGJAfInICRA0wDxjyBFIfF2APIsoBAE4zoQ0ADx0Q
DxgPGj8HNhJAHAASTxwAAJA-MA8dAB8AEU8fABAwHwAGHQABzXUFIQAAPTZEDSAPIj8AAD4AIS8e
AzUGIAAAQgAmJC9fAAIhADAADxdVMAAiAFQdQA8hL2AAFE8eAABhNlAdYC8hHTQAAhYAhg0ALxcd
gC0AKABxDRAt0C8dL4A1MA3wBOg0jx3wBUYd8AdNzwQekS9JgEmACUsJYAQAYQsMOgsJQAcAEAgH
ABFapAlADFoLCAcAAacJMAsMep0JEAudCSAMiuABAZ8JJwyalwkMCAADbRUyHiAJbRUyQAkLZRUh
CQtlFTIJC8oHACAM2p0JQAsM_gAMFkALDPoCDRYBNQAmDkAIADCKCYqrFQWtCUAeYAgLgwIQCHEm
cB6ACEkIHgAFAK_gSB4gSB7ATkBOrQkkIH8QN1dhDR8RTw8NCgAbbAcAAq4JgnwNC-ABDg2Mx_Ux
jA4LLglDjA4LCgcAUNAODQ8RCQBSwA4NCZwIABmsBwAQnARtAS0AKRrQOwADQgAAWQAQfAgAQAEO
DWwIABECCAAj8AMHABMLBwCvfgsK8AOLCvAEimgJHoA0jxPwAw6PFZNZEA0yFBANxpkAChQAduYQ
DXddEA3DmUEPFt8UG_cABwkRAJKYAQsAUgINDxJACwARBFcJFg0mCQ8LADgBWAACZgkyQA4N5QkA
CZMUDVAJMg4NzwoAQqAODa8KAFLADxINjwsAQOAPEo5VWW8BjBvwA4tBXx8AixRBBQ5vGgECAD4U
EQ1UCRAN8S8wDQ8XMgECuBM10A4NSQkOCgAgoC4KAIAvF4AOLc8ZLaoUEA0GCSACDUgJAQsAUgQN
DxcgCwARBj4JJQ3-JQkPCwAXpBAODX8ZDg0MHnxECUENXA4LymgQXOoZ4UALXhsNDA4bXgsaYFsK
GQBSClsagFoKAEIAWvAACgAs8AcIAF9LCvAISj8JJwA7CSAO8BXqUA818AgOtw4QDggAEQwRAGAG
Dg0PIBxR90EODQscEwB0BA4NCzwNDggAAQIDEwtl6AAIAAEjA0QLfA0OCAAAdgNSC5wNDxwIAJMJ
CrAODQu8DgkHAF8KoA4NzAcABRCwmQMSCZID-wMJGuAJDWwOCRrwAQluCRrwA2mVkyLBNH8i8AQO
byQPIfADG10BDQkPDAAkASUJABcJEyQZCQEMAAEXCRGwCwkADAAA8gkTJNgIAA8AF5AJCRN-GQkk
DyUSAAArCQDQCAcdCQAvCRBdEgAGIAkQr9WWJSUvEAAAZRMKKQkUQBQJAp6WQu8jDg2VlhHPCgAR
oEUAAAoAIsANdQCeHzXgDY4NHPAB02IPHwlLEU8ZCRANRioRHRkJFw0YCRgNFwk1KwkAEQARDxFn
QGAJCw_mzUgADg0vLAkTHxMJMAsPDMd1FA0UCREVHykBFgkfCxYJI1YMAA8NHBYJcRxAaQgMEAwW
CbUccFgMMFcskFxAXBYJkk8kDyEMMA8YTwoJEx8ICRQMCAkApScECgkCOZkAHgAAZQgNCgkYJB0A
DAoJGgwKCREfjxcJDAkXDAwJAUQADQwJExwMCR0MDAlWHGAvIRwWAHcMAC8XHIAsDAk1DBAsDAkS
DAwJjxzwBUYc8AdMnAQegJN58AUJDEsIbQQgCQu-AQAIADQKGQoKACAICwsAMmDZKAgAQgkM_wAJ
AAHPCAAIAPAE_QIIDjA5_AQOMAkM_wUIDjAJC-FDAAgAIfkCNgBBMAn4AwkANEDuCFIAZPAECAsK
GwoAEzoIABBJBwB-eA7wBX7wZssAHSBTTnsOMBEfEEsCAGZeBBAtDwwAJzU_8AQXAARZABUDEgAD
BwA9NeBOEgAEiAAOGAAKEgAPGQAnL5BeGQACJE5QAg0LGQADBwARP8UAIEAOugwMHAADBwAD3AMS
QHoAHx8lAAEQHyN3ByYAFz8cACgPDRIAASEAGV8dABZfGQAQbhAAAPsDIhBuEwCv-w0GDzVQ-Qfw
LPwRH4IT8AgOLxUPEsEBExXahwkMACMAfgwAEF5AExBvDAARXzIAIJAOdLgUDgsAMw8UrikABBAA
PA6fEhIAIQ8SQwAPGAABAABQBhgAJVBOGABADxQ_HQgAAEx2ED5VExE-CwAAEQBDHxIPFRwAEDw2
AAFrlCAPEjsrcRwdCwxNDgsUACA_DZArgA4LDC0LDA1OhzYiOwwTABBbrydDCiAqDhAAYmwNDgtK
UA4AAJw7EpALABOuCgAS2wcAQGwLapDQKQFvC0IMXgwNCgASawkAMgFaDgkAEAda_gAHAB87Awki
QEz-GAP7Z0JvGg8XBgARkOEdAH8eAwcAITWA_RIhPg0UADUNPg0VADANDh8SAAIYAAYMAAMcADQP
Fx8cADAcDxeuAAAaAAAIABMtJgExDgsKEQAVqwsAU1wLDxtMDQBSXQ4LDF0LABI_OgEQXg0AFEtW
AUMKkDoODAA1C1rQCwAAZP4PDAAaJNBeCwBSTpAOCUwMABxMgwBAbgsMbgkAj-sCCpD6A-AuaQEd
MIb-HWkBABeiExwGAAAoARIf8R0DBwABEgBBDx4_DRQAAWsBAxUAMA0OHxIAAhgABgwAAxwANQ8c
HxwABQwABRwAMC0ODAkAEAwIADA1YC4MAFBcCw0OfOQegBsNDmsNDmsM5APwAwv9Aw4MCkAOC-4E
DApAHvwFCiIAUPsCDBpQIGPwEg4MCmAOC-4CDApgLvwCCnAKDgnbDCqADgvNDgwKoA4L3gYAj-wA
CrD6AfBMHwEdMEufIsEFNCVvJGQTFyRwEwB4dRYNDgBpDQ4fIQ8kEQA8DyEfEQAB7wADDgAwXE7Q
2_4gmwz3DLMLrQ4MCsAOCw2ODQkANQ5sCwsAUAwPJTsMCAAhbmAPACELPQ4AUglLDApQEQASDQMA
ABsAFg4VABMbFAA2DR4NFgAlPQwyAAQVAABrABY8DwBDew0OSw0AIv0CCAAg-gMHAI-8BQpg_gbw
SSbYH7Mm4J4fKg8pnlAOT2kcAs0oFycQACE1QC8cJA8nGwAEDgABGQAA1GYB5CgHHwAIFAADJQA7
DyceJgAZKRUABScAKg4fJwAgKg_hZxwNJgARLxAAAgwAZQ0vKA4NDCAARwwPJ14GAAEWAABfKIQq
DUsMDQsNSxQANAv8Ax4AUH8nDQyaCwDxAZ4NDAqeCUAOWw0LHQydDgkmABEKCABzDGoLDGoNDA0A
IwpeBAADDwAhDj0GADYbHQ4jADEOLAoHADYLLA4pADMeDQwWADMMCh4XADUNDD0VACMdGysAIVwK
SwAiC1wjABFqIABDDWoOCaUAj1B5TpngSfAY9QH--xRwNVnwBCkcO8Qq8BpMWxmwGXxrGYAJnIsJ
YAmsmwhQCTtsexkIDzVACWs8azkIQAmLHCs6OfQLkKtqSQgwCat6OXpzAQcAwDAJm3opCB4wCYuK
KdUUAQcAsFAIOSuaGQgeUAhpDwASYAcA-xpwCGl6GQgecAh5WikIDpAI6QgeoAjZCA7ACLkIHtAI
eSge8AB4PvACflsYH8A2PvAIDj8RHvAFDm3SEhCN-RNQLxBNLw9HEUEvEH8PDmxQPxB-Dx4HAADu
HUE1sA5PCQAVDQkAAPAJIV8QPh4FCQAAExkhXxCZKQUJAAA8GVBvEK8PLswqMl8QzxQAcDAPDT4f
EN8WAPEAMAxe3w8uDA81IAx_rw8_CQBBjo8PTgkAQv4HDAsGAP8FMBz_AxwbQAssziwrcBvMO8DL
8BT7AB3wH3JPE-AGHk8WHvACHm0fFA7gHm1MDrAeHxVtXA6AHjtdfA5gDmstrA5ADpvMDjAFAADy
EDCbrC6lKTGrnD58MjCrjE40MiibnAcAQIsefE4lMkA7blxOCzL-GK4sXgoZUBr_ABoZcAkavhop
oAkafhop4AkaLiop8AMJKjnwBynwN8EAHXBSjxjwAh5-3h3xGOAOjxs-Gg7ADo8bXxoOoA6fG28a
DoAOnxsvGU8aDxdwDp8bTxk-GpOlIQ6POykRHhQpMBpvG78dEC4aAJJADi8aLxuvGT4NACVfGgsA
P08avwsAAD8-Gs8LAAA1LxoODABiHxoevxlODABgDxo_nxleDABwUA8XTl8Zfo8UUFAPF-4DKgL-
Bw3_AQ0cgA3uDRygLa4NHMAcrRzwALzVAR-xFGyPHfACHo8gXpAezT8fHmAOPJ1sDkAeTG0fHnwO
MA5sPXs8zGwwfNsuLygxbOsuxwEwXOs_uQFAPD67TmyeMH6rPmie8BV_iz4KGUAKbos_CglgCm5r
PgoZcApeWz4KGZAKXitOChmgCs6UfRWu-aIgCm6Cfe8aLhoZ8AUJKinwCCnwNsMAHTAZPyKUAxEl
lANQHvACDp2LA-EJHyR9HA7QDkxNPA7ADlw9TA6gDmwfIx1MJ-WQbE8jXA6ADlxrDwBycA8hLix7
PAoAJE6LCQAtmywJAIAOHAoPNXAKTuAAUXAKXmtOBwAhW14HACBLXpk0-yBeO14KCZAKbhtuCgmg
Ct4KGbAKvgoZ0AqeChnwAAp_ChnwAho_GhnwBAk6KfAHOQwNHjBQfyZnGRAqVS-xEK0PKR7ADr0s
DqAOzTwOgA4snVwOYA5MjWwOUA5cbXzzdFJ8XVwfJwoA0V8oTD8nDjAOXL8oTyecA0QfJyzPDABS
PyfPKF8LADRPJ78LADRfJ68LADBvJ48LAADZHVB-J18obxYAUUAO-ycEt25Q-ycCDh-UHYAnAA4f
NZAO3yoAMLAOrzZwj9CuK-AAq-Az7AD-ChA3-3o0HAsYZrUUGGa1ExhmtRMYZrUUGGa18QogCAsM
mwyaCwoIEAgLChxrDA8qC2obCQoIwamAKhwrHyoKCwrrtAATAPAKEAgLOiwaCxpLOQoIHhAIC0oL
GgsaKwoLSQa1QAgLWhsNAFFZCggOMBwAICsaGgARHg0AMQorKicAYUAIC1orKiUAYVAIC0obOiMA
AAsAEGsfAHBgCAs6C2kKZrWQcAgLGguJChkKhAfgCwoLqQoJCggOgAgbyRqPB6-qCB6g6B7A7vAw
JgEdQDgO8AubQQA6IgGqEgA7IgIJAAEEGRIPvhICuB8KDwABERkBWRMiER8gAAoPAAKHDSIRL2Wr
ACAACg8AIQ81SSYiPxCyQgNYJkAvEA8qYAAEJAAS0CMAIyoP5EIzDw3QRgABhgAHKgAUsCoAJRAf
LAAUsCwARRAfDy8qABKQKgAAXKwDKAATkCgAACYAFx9UABNwKgATfygAEXDiAGMfEY4fEB8jAAEf
Q1EQHxHOH44AAFcIQh8R-gGfFGBQDw3-DwPHJkBg-w0Dy3kPRRAg4VQvE-AIHh8WDxUfEvAECQAA
XTEACTIBiiYgLxUIIQAPAGCwHh8WTxX_IAAOABBwpiYjFQ80MmBADh8WjxV2Y1AfFQ8SIFYdERUd
-gBsMfADFQ0QDQwPFmwfKg8UDAscawwLEQBhCw8WPBobubYgDguJGIANDBsKDBorDP22wQsMHgsN
CQANDCsKOyMAEi4PAEEbDAsc2LMzHA4LIgCxCww7HBssGxw_Cw4RAHEcazwLHG4bHADwDZssngsN
CRANHIsMjhsNGSAdHGsMbhsdGUAJHRwAt-AGHSlwCR0cKwwuGx0psAkdHAsMDhsdBDafHRwLHSnw
BAkt5AYjME3-GNe2IxsBrTGgGgEPGw8XYA0PGvcwoO8aDxsODxkNUA1TQHAPG88aDxseGKMAb60A
qUBlG68aDxsuEgC3PxkfKg8bDypvGz4UAAF-GACxrRoaFgARPxYAGy8WABEvFgAbPxYAEx8sAACf
QAoaABMPGgAbHxoAER8WAB0vMAAAFgAfP0YAADsvGk8WADs-Gl8SADivGj7_AGMarg8ZLgwQAFIc
C84MHg0A-woLDAvuDA4MDQpQDQv_AQwNGmAN-AENGoD9XKokcG0-HW8c8AFjblB-Hw8c4JMiEB87
tTQeDx8EADAPHMAXAACTtREPEwARH7K0Mw8coBcAEioXABM-FwAxgA8dEbUQKhUAQy8fDx6ltCMc
YBkAEiAZABUvGQAyQA8db7UE4LQRTxcAgSAPHX8g-x8B9TExH18e1GJRH18dDx-gCQInAAATAEFP
HQ8ernYCEwAWbxMAEUALtQITABI-EwATYBMAFk8TAADSExMvEwASLxMAE6ATABYvEwAiwA4QAQAT
ABIfEwAT4BMAFg8TAACwJgEQAAJGGwIUACoDDhAAQgUOHx8KABAHIx8AmK9-Dh3wCw3wGmt4HwRY
tSAPIU0AEiXdHQEPAAhatQJWHhQlW7UpDyFctTMPIeDvtBFPDgAQwIwnQSQPKl8OABOgDgAAVwAC
EgBzgA0PJB8lP00A0D8jLyQNcA0MHyMfJQxHtWAMCwwLHB7RBGBgDQw7DyWNsxQ_DwAAYLJRLD4L
DQoNAGQLDBscCwwPAEUcGxwbDQBEDBscKw0AkRscDiwrDA4bHg8A8AYsPgwrDD4rDQpwDQteDAsM
XgsNGoALAAAJAPARoA0LTgtOCw0awA0LPgs_Cw0a4A0LLgsuCw0a8AENCx40BWAa8AMNCw4tBa8a
8AUNKw0a8ActNJQipTLPJuAODyq-KQ5PewEoBwEcEgBpewCbeh0OEQABIgcxKi8pHj0QKfF6HQ4R
AAEcB3AqTykPKl8pNnsBInogPykVPQBePTIPKT8mABNQJgATLx2JASwAE1AsAAIVABQ-LAATMCwA
ER8XABAvSRICMAAwMA5fogADFwAANgAhTyhXCgAJABYfFQAFRwAjKT8sABQ-igARHxcAEE9tAAYq
ABFQKgA2LylPJgARUCYANW8pT_UAAVsAIW8nFRMAIgANEwABLwEBngATj_57Lg4fEwABeQEiKa8e
AAALABC-FAB-0M4d4M3wFNkB-_NQbT02fX0=
:: gfx/1.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA5LTEzIDEzOjUxOjM5Iixtb2RpZmllZD0iMjAyNC0w
OS0xMyAxMzo1MzoxOCIscmV2aXNpb249OV1dbHo0AG0AAAAFMQAA8xR7WzBdPXtibXA9cHh1AEMg
EBAE8PAsZmxhZ3M9MCxwYW5feAgAz3k9MCx6b29tPTh9LDEA----------------------------
------------------------------------51BtPTh9fQ==
:: map/.info.pod
--[[pod,created="2024-03-30 05:39:34",modified="2025-11-25 20:56:55",stored="2024-03-30 05:39:34"]]
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNC0w
OS0wMSAwNzozNDozNSIscmV2aXNpb249MzA3NV1dbHo0AMEAAABZEAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD-------_x0zIwMDAzMDAwNDAwMDYMAC81MIAAWxMxCAATNYAALzYw
AQBbFzb8ABMxDAAPAQBVBHwBAAABEzAMAA_AAVkTMXQAEzB4ABcxjAAPAAFVEzaEAAQMAC81MAEA
--------nvEJIiksaGlkZGVuPWZhbHNlLHBhbl94PTQ3CQDSeT0wLHRpbGVfaD0yOQoAEHcKAIB6
b29tPTF9fQ==
:: pal/.info.pod
--[[pod,created="2024-08-23 18:54:19",modified="2025-11-25 20:56:55"]]
:: pal/0.pal
b64$LS1bW3BvZCxiZ19jb2xvcj0wLGJsYWNrZXN0X2NvbG9yPTAsY3JlYXRlZD0iMjAyNC0wOC0y
MyAxODo1OTowOSIsaGlkZGVuPXtbMF09ZmFsc2UsZmFsc2UsZmFsc2UsdHJ1ZSx0cnVlLHRydWUs
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0
cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2V9LGhpZGRlbl90
b2dnbGVzPXtbMF09ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2V9LGh1ZV9vZmZzZXQ9LTAuNjgxNDQw
NDQzMjEzMyxpY29uPXVzZXJkYXRhKCJ1OCIsMTYsMTYsIjAwMDEwMTAxMDEwMTAxMDEwMTAxMDEw
MDAwMDAwMDAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNjAxMDAwMDAwMDAwMDAxMDcwNzA3MDcwNzA3
MDcwNzA2MDYwMTAwMDAwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDYwNjA2MDEwMDAwMDAwMTA3MDcw
NzA3MDcwNzA3MDcwNjA2MDYwNjAxMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAw
MDEwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwMTAwMDAwMTA3MDcwNjA2MDEwMTBkMGQwMTAxMDcw
NzAxMDAwMDAxMDcwNzA2MDYwMTAxMGQwZDAxMDEwNzA3MDEwMDAwMDEwNzA3MDEwMTA3MDcwNjA2
MGQwZDA3MDcwMTAwMDAwMTA3MDcwMTAxMDcwNzA2MDYwZDBkMDcwNzAxMDAwMDAxMDcwNzBkMGQw
MTAxMGQwZDA2MDYwNzA3MDEwMDAwMDEwNzA3MGQwZDAxMDEwZDBkMDYwNjA3MDcwMTAwMDAwMTA3
MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzAxMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEw
MDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAwIiksbG9ja2VkPXtbMF09ZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2V9LGxvd2NvbF9pY29uPXRydWUsbW9kaWZp
ZWQ9IjIwMjUtMTAtMjEgMTI6MTk6NTMiLG9rcGFsX3ZlcnNpb249IjEuMi4zIixwaWNrZXJzX21v
ZGU9ImxpbmVhcl9odWUiLHJldmlzaW9uPTQ2NTQsdGVzdF9jdWJlX2NvbG9ycz17WzBdPXsxLDEs
MX0sezEsMSwxfSx7MSwxLDF9LHsxLDEsMX0sezEsMSwxfSx7MSwxLDF9LHsxLDEsMX0sezEsMSwx
fSx7MSwxLDF9LHsxLDEsMX0sezEsMSwxfSx7MSwxLDF9LHsxLDEsMX0sezEsMSwxfSx7MSwxLDF9
LHsxLDEsMX0sezEsMSwxfSx7MSwxLDF9LHsxLDEsMX0sezEsMSwxfSx7MSwxLDF9LHsxLDEsMX0s
ezEsMSwxfSx7MSwxLDF9fSx0ZXN0X21vZGU9InJhbXBzIix0ZXN0X3JhbXBfY29sb3JzPXVzZXJk
YXRhKCJ1OCIsMTAsMjcsIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCIpLHdoaXRlc3RfY29s
b3I9N11dbHo0APIBAAAVAgAA-QV1c2VyZGF0YSgiaTMyIiw2NCwiMAEA8A0zNDNmNjIwMDgyM2Yz
ODAwOTg0NzNmMDA5ZjUxCACRNDU1MzgxMDBmAQDwMDAwNzQxZjY1MDBhODI1OTIwMGUyNDliYTAw
ZWY4M2M1MDBmOGJiZDkwMDc3MmMxNjAwYTIzMjE5MDBkNTRmMkgA8CwzODI1NzAwZmNiYzljMDA2
NzQ5MTMwMDljNzExYTAwZDZhMjI1MDBlZGM0NTQwMGZiZTE5OTAwMmQ1MxgA8BYzMTZlMzIwMDUw
YTMyYzAwODdkNDU2MDBiZmYyOTUwMDE2NTg1CADwHDc3OTdkMDAyMGI0YjMwMDVjZDhkMjAwYWNm
NmYwMDA0NzIyODYwMDVlMjYgANA4ZDNiZWQwMGFlODFmsACQOGM0ZmMwMDUzAgBAMDBiMgIAQDAw
ZTMCAEAwMGY0AgAAyAAAAgBAMDAxZAIAQDAwMmUCAEAwMDQ2AgBAMDA5YgIAQDAwYzECAOAwMDRm
NGIzZTAwNzM2YeAA8BM5ZThmNzQwMGFhOWQ4NTAwYmViNWE0MDA1ODU5NWQwMDY4AgBRMDA2Zja5
ABE3AQBQMDA4NjivAVEwNjEzOFAAsGM0MjQ5MDA4OTRjsABAOTk1N0AA8AFhNzZiNmUwMDJhMzQ1
NCIp
:: pal/1.pal
b64$LS1bW3BvZCxiZ19jb2xvcj0wLGJsYWNrZXN0X2NvbG9yPTAsY3JlYXRlZD0iMjAyNS0xMC0y
MSAxNjo1MDozMSIsaGlkZGVuPXtbMF09ZmFsc2UsZmFsc2UsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0
cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1
ZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUs
dHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSxmYWxzZSxm
YWxzZSxmYWxzZSxmYWxzZSxmYWxzZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVl
LHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0
cnVlLHRydWUsdHJ1ZX0saGlkZGVuX3RvZ2dsZXM9e1swXT10cnVlLGZhbHNlLGZhbHNlLHRydWV9
LGh1ZV9vZmZzZXQ9LTAuMzM3OTUwMTM4NTA0MTYsaWNvbj11c2VyZGF0YSgidTgiLDE2LDE2LCIw
MDAxMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAwMDAwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDYwMTAw
MDAwMDAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNjA2MDEwMDAwMDAwMDAxMDcwNzA3MDcwNzA3MDcw
NzA2MDYwNjAxMDAwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDYwNjA2MDYwMTAwMDAwMTA3MDcwNzA3
MDcwNzA3MDcwNzA3MDcwNzAxMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDEw
NzA3MDYwNjAxMDEwZDBkMDEwMTA3MDcwMTAwMDAwMTA3MDcwNjA2MDEwMTBkMGQwMTAxMDcwNzAx
MDAwMDAxMDcwNzAxMDEwNzA3MDYwNjBkMGQwNzA3MDEwMDAwMDEwNzA3MDEwMTA3MDcwNjA2MGQw
ZDA3MDcwMTAwMDAwMTA3MDcwZDBkMDEwMTBkMGQwNjA2MDcwNzAxMDAwMDAxMDcwNzBkMGQwMTAx
MGQwZDA2MDYwNzA3MDEwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwMTAwMDAwMTA3MDcw
NzA3MDcwNzA3MDcwNzA3MDcwNzAxMDAwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMCIp
LGxvY2tlZD17WzBdPWZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlfSxt
b2RpZmllZD0iMjAyNS0xMS0yNSAyMDoyMzo1MiIsb2twYWxfdmVyc2lvbj0iMS4yLjMiLHBpY2tl
cnNfbW9kZT0ibGluZWFyX2h1ZSIscmV2aXNpb249MzksdGVzdF9jdWJlX2NvbG9ycz17WzBdPXsx
LDEsMX0sezEsMSwxfSx7MSwxLDF9LHsxLDEsMX0sezEsMSwxfSx7MSwxLDF9LHsxLDEsMX0sezEs
MSwxfSx7MSwxLDF9LHsxLDEsMX0sezEsMSwxfSx7MSwxLDF9LHsxLDEsMX0sezEsMSwxfSx7MSwx
LDF9LHsxLDEsMX0sezEsMSwxfSx7MSwxLDF9LHsxLDEsMX0sezEsMSwxfSx7MSwxLDF9LHsxLDEs
MX0sezEsMSwxfSx7MSwxLDF9fSx0ZXN0X21vZGU9InJhbXBzIix0ZXN0X3JhbXBfY29sb3JzPXVz
ZXJkYXRhKCJ1OCIsMTAsMjcsIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCIpLHdoaXRlc3Rf
Y29sb3I9N11dbHo0APMBAAAVAgAA-QV1c2VyZGF0YSgiaTMyIiw2NCwiMAEA8RoyYTM0NTQwMDM0
M2Y2MjAwNDU1MzgxMDA2YzdhYTQwMDljYTdjNzAwZgEA8DgwMDcyMjA2YTAwYTgyNTkyMDBlMjQ5
YmEwMGVmODNjNTAwZjhiYmQ5MDA3YTI4MWMwMGEyMzIxOTAwZDU0ZjIxMDBmMzgyNVAA8RNjYmM5
YzAwNjc0OTEzMDA5YjcyMWEwMGQ0YTMyNDAwZWRjmADwTmZiZTE5OTAwMjY1NDJkMDAzMTZlMzIw
MDUwYTMyYzAwODdkNDU2MDBiZmYyOTUwMDE0NTU2ODAwMTU3NjhlMDAyMGIwY2IwMDY1ZDRlNzAw
YjhmMmY5MDA0MTFjN_gA8AQyMWNhNjAwOGYwMWVmMDBiMDZkIACgZDZiMGZkMDA1MwIAQDAwYjIC
AEAwMGUzAgBAMDBmNAIAAMgAAAIAQDAwMWQCAEAwMDJlAgBAMDA0NgIAANgAAAIAQDAwYzECAOAw
MDRmNGIzZTAwNzM2YeAA8AU5ZThmNzQwMGFhOWQ4NTAwYmViNXgBoDU4NTk1ZDAwNjgCAEAwMDZm
AgAxMDA3AQDhMDA4NjgzODAwMDYxMzhQALBjNDI0OTAwODk0Y7AAQDk5NTdAAPABYTc2YjZlMDBm
ZjAwMDAiKQ==
:: pal/3.pal
b64$LS1bW3BvZCxiZ19jb2xvcj0wLGJsYWNrZXN0X2NvbG9yPTAsY3JlYXRlZD0iMjAyNS0xMS0y
NSAyMDo1MzozMyIsaGlkZGVuPXtbMF09ZmFsc2UsZmFsc2UsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0
cnVlLHRydWUsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsdHJ1ZSx0cnVl
LHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0
cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWV9LGhpZGRlbl90b2dnbGVzPXtb
MF09ZmFsc2UsZmFsc2UsZmFsc2UsdHJ1ZX0saHVlX29mZnNldD0tMC4zMzc5NTAxMzg1MDQxNixp
Y29uPXVzZXJkYXRhKCJ1OCIsMTYsMTYsIjAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAw
MDAwMTA3MDcwNzA3MDcwNzA3MDcwNjAxMDAwMDAwMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA2MDYw
MTAwMDAwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDYwNjA2MDEwMDAwMDAwMTA3MDcwNzA3MDcwNzA3
MDcwNjA2MDYwNjAxMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDEwNzA3MDcw
NzA3MDcwNzA3MDcwNzA3MDcwMTAwMDAwMTA3MDcwNjA2MDEwMTBkMGQwMTAxMDcwNzAxMDAwMDAx
MDcwNzA2MDYwMTAxMGQwZDAxMDEwNzA3MDEwMDAwMDEwNzA3MDEwMTA3MDcwNjA2MGQwZDA3MDcw
MTAwMDAwMTA3MDcwMTAxMDcwNzA2MDYwZDBkMDcwNzAxMDAwMDAxMDcwNzBkMGQwMTAxMGQwZDA2
MDYwNzA3MDEwMDAwMDEwNzA3MGQwZDAxMDEwZDBkMDYwNjA3MDcwMTAwMDAwMTA3MDcwNzA3MDcw
NzA3MDcwNzA3MDcwNzAxMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDEwMTAx
MDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAwIiksbG9ja2VkPXtbMF09ZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2V9LG1vZGlmaWVkPSIyMDI1LTExLTI1IDIwOjU1OjEyIixv
a3BhbF92ZXJzaW9uPSIxLjIuMyIscGlja2Vyc19tb2RlPSJsaW5lYXJfaHVlIixyZXZpc2lvbj0x
LHRlc3RfY3ViZV9jb2xvcnM9e1swXT17MSwxLDF9LHsxLDEsMX0sezEsMSwxfSx7MSwxLDF9LHsx
LDEsMX0sezEsMSwxfSx7MSwxLDF9LHsxLDEsMX0sezEsMSwxfSx7MSwxLDF9LHsxLDEsMX0sezEs
MSwxfSx7MSwxLDF9LHsxLDEsMX0sezEsMSwxfSx7MSwxLDF9LHsxLDEsMX0sezEsMSwxfSx7MSwx
LDF9LHsxLDEsMX0sezEsMSwxfSx7MSwxLDF9LHsxLDEsMX0sezEsMSwxfX0sdGVzdF9tb2RlPSJy
YW1wcyIsdGVzdF9yYW1wX2NvbG9ycz11c2VyZGF0YSgidTgiLDEwLDI3LCIwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAiKSx3aGl0ZXN0X2NvbG9yPTddXWx6NAADAQAAFQIAAP0FdXNlcmRhdGEo
ImkzMiIsNjQsIjABAPEaMmEzNDU0MDAzNDNmNjIwMDQ1NTM4MTAwNmM3YWE0MDA5Y2E3YzcwMGYB
AEAwMDQ4AgBAMDA2OAIAMTAwOQIAQDAwYWQCAEAwMGNmAgAPKADfIDFkAgBAMDAyZQIAQDAwNDYC
AEAwMDliAgBAMDBjMQIA4DAwNGY0YjNlMDA3MzZheAHwBTllOGY3NDAwYWE5ZDg1MDBiZWI1eAFm
NTg1OTVkeAAgNmYCADEwMDcBAOEwMDg2ODM4MDAwNjEzOFAA8ARjNDI0OTAwODk0YzUzMDA5OTU3
QADwAWE3NmI2ZTAwZmYwMDAwIik=
:: sfx/.info.pod
--[[pod,created="2024-03-30 05:39:34",modified="2025-11-25 20:56:55",stored="2024-03-30 05:39:34"]]
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM1Iixtb2RpZmllZD0iMjAyNS0w
NS0xMiAyMTowODoyMSIscmV2aXNpb249NDU2Nl1dbHo0ABoBAABSCAAA8CdweHUAAygAAAQABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDBAUGBwAP-5AICQoLDwwPDQ8ODw8QAPAADQ8RDxIPEw8UDxUP
Fg8XEwDxAQ8YDxkPGg8bDxwPHQ8eDx8UAPEAIA8hDyIPIw8kDyUPJg8nFADxACgPKQ8qDysPLA8t
Dy4PLxQA8QAwDzEPMg8zDzQPNQ82DzcUAP8FOA85DzoPOw88Dz0PPg8-AA--8P8BAOv-J1oBEAYP
IBABIAEgAfAAAhACDBABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDDAAAh9EMAAc
H0AwAPIf-wEA3L-4D0AADUD--7DwcAoA--9kH-8BAP_ZUP----8g
:: src/.info.pod
--[[pod,created="2024-08-24 07:17:09",modified="2025-11-25 20:56:55"]]
:: src/logic/.info.pod
--[[pod,created="2024-08-30 06:24:39",modified="2025-11-25 20:56:55"]]
:: [eoc]
