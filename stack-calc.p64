picotron cartridge // www.picotron.net
version 2

:: doc/
:: gfx/
:: map/
:: sfx/
:: src/
:: main.lua
--[[pod_format="raw",created="2026-01-10 13:14:25",modified="2026-01-13 18:18:48",revision=3255]]
include "src/config.lua"
include "src/state.lua"
include "src/stack.lua"
include "src/calc.lua"
include "src/parser.lua"
include "src/entry.lua"
include "src/error.lua"
include "src/soft_wrap.lua"
include "src/keyboard.lua"
include "src/help.lua"

local bg0 <const> = 19
local bg1 <const> = 3
local bg2 <const> = 27
local fg <const> = 7
local fg_alt <const> = 0


local width_kbd <const> = 130
local height_kbd <const> = 110


local blink_timer = 0
local blink_speed <const> = 20


function _init()
	window {
		title = "Stack Calc",
		width = width_kbd, height = 2 * height_kbd,
		pauseable = false
	}
	init_undo_stack()
	init_help()
	on_event("resize",
		function(msg)
			local width = max(msg.width, 68)
			local height = max(msg.height, 3 * 13)
			if config.with_keyboard then
				if config.keyboard_below then
					width = max(msg.width, width_kbd)
					height = max(msg.height, height_kbd + 3 * 13)
				else
					width = max(msg.width, width_kbd + 68)
					height = max(msg.height, height_kbd)
				end
			end
			if width ~= msg.width or height ~= msg.height then
				send_message(pid(), { event = "resize", width = width, height = height })
			end
		end
	)
end


function _update()
	blink_timer += 1
	blink_timer %= blink_speed * 2
	if is_help_shown() then
		update_help()
		return
	end
	update_entry()
	local width_win = get_display():width()
	local height_win = get_display():height()
	window { cursor = "default" }
	if config.with_keyboard then
		local x_kbd = width_win - width_kbd
		local y_kbd = height_win - height_kbd
		update_keyboard(x_kbd, y_kbd, width_kbd, height_kbd)
	end
	if key("ctrl") then
		if key("shift") and keyp("z") then
			undo_stack:redo()
		elseif keyp("z") then
			undo_stack:undo()
		end
		if keyp("y") then
			undo_stack:redo()
		end
		-- TODO: should not change config
		if keyp("k") then
			config.with_keyboard = not config.with_keyboard
			local width = get_display():width()
			local height = get_display():height()
			if config.with_keyboard then
				if config.keyboard_below then
					height += height_kbd
				else
					width += width_kbd
				end
			else
				if config.keyboard_below then
					height -= height_kbd
				else
					width -= width_kbd
				end
			end
			send_message(pid(), { event = "resize", width = width, height = height })
		end
		if keyp("l") then
			config.keyboard_below = not config.keyboard_below
			local width = get_display():width()
			local height = get_display():height()
			if config.with_keyboard then
				if config.keyboard_below then
					width -= width_kbd
					height += height_kbd
				else
					width += width_kbd
					height -= height_kbd
				end
			end
			send_message(pid(), { event = "resize", width = width, height = height })
		end
		if keyp("b") then
			config.big_rows = not config.big_rows
		end
	end
	local mx, my, mb, _, wheel_y = mouse()
--	if mb ~= 0 then
--		clear_error()
--	end
end


local function draw_stack_row(idx, y, width, no_entry)
	local h_row = height_row()
	if idx % 2 == (no_entry and 0 or 1) then
		rrectfill(0, y, width, h_row, 0, bg1)
	else
		rrectfill(0, y, width, h_row, 0, bg2)
	end
	local item = get_item(idx)
	line(width - 9, y, width - 9, y + h_row - 1, 19)
	if item then
		local y_letter = y + h_row - 10
		print(index_to_letter(idx, "lowercase"), width - 6, y_letter, fg_alt)
		local text_value = str(item.value)
		local w_value = print(text_value, 0, -1000, 0)
		local big_rows = h_row > 20
		if item.source ~= "" then
			local text_source = "\014"..item.source..(big_rows and "=" or "")
			local w_source = print(text_source, 0, -1000, 0)
			local source_fits = w_source + 2 < width - 12 - w_value
			if source_fits or big_rows then
				print(text_source, 2, y + 4, 0)
			else
				print("...", 2, y + 4, 0)
			end
		end
		print(text_value, width - 14 - w_value, y + h_row - 10, fg)
	end
end


function draw_entry(y, width)
	local h_row = height_row()
	rrectfill(0, y, width, h_row, 0, 1)
	local text_entry = entry()
	local w = print(text_entry, 0, -1000)
	local x_end = print(text_entry, width - 14 - w, y + h_row - 10, fg)
	if (peek(0x547f) & 0x10) > 0 then
		if blink_timer <= blink_speed then
			rrectfill(x_end, y + h_row - 12, 6, 11, 0, 14)
		end
	else
		rrect(x_end, y + h_row - 12, 6, 11, 0, 14)
	end
end


function draw_stack(width, height)
	local has_entry = entry() ~= nil
	local idx = 1
	local h_row = height_row()
	local y_start = height - h_row
	if has_entry then
		y_start -= h_row
	end
	for y = y_start, - h_row, - h_row do
		draw_stack_row(idx, y, width, has_entry)
		idx += 1
	end
	if has_entry then
		draw_entry(height - h_row, width)
	end
end


function _draw()
	cls(13)
	local width_win = get_display():width()
	local height_win = get_display():height()
	local width_stack, height_stack = width_win, height_win
	if config.with_keyboard then
		if config.keyboard_below then
			height_stack -= height_kbd
		else
			width_stack -= width_kbd
		end
	end

	if is_help_shown() then
		draw_help()
		return
	end
	draw_stack(width_stack, height_stack)
	draw_error(width_stack, height_stack)
	if config.with_keyboard then
		local x_kbd = width_win - width_kbd
		local y_kbd = height_win - height_kbd
		draw_keyboard(x_kbd, y_kbd, width_kbd, height_kbd)
	end
end


-----------------------------------------------------------------------------------------
-- Utils
-----------------------------------------------------------------------------------------


function str(v)
	if type(v) == "nil" then
		return "nil"
	elseif type(v) == "bool" then
		return v and "true" or "false"
	elseif type(v) == "number" then
		local s
		if v == 0 then
			s = "0"
		elseif abs(v) >= 0.001 and abs(v) <= 999999999999 then
			s = string.format("%f", v)
			if string.find(s, "%.") then
				s = string.gsub(s, "0*$", "")
				s = string.gsub(s, "%.$", "")
			end
		else
			s = string.format("%99e", v)
		end
--		local s = tostr(v)
--		s = string.gsub(s, "%.0$", "")
		return s
	elseif type(v) == "string" then
		return pod(v)
	elseif type(v) == "table" then
		local str = "{"
		for k, v in pairs(v) do
			str ..= stringify(k).."="..stringify(v)..","
		end
		return str.."}"
	else
		return "**unknown type**"
	end
end

:: manual.txt
--[[pod_format="raw",created="2026-01-12 12:42:40",icon=userdata("u8",16,16,"000001010101010101010101010000000001040404040404040404040401000001070104040404040404040404040100000101040404040f0f0f0404040401000001040404040f0f040f0f04040401000107010404040404040f0f040404010000010104040404040f0f040404040100000104040404040f0f0404040404010001070104040404040404040404040100000101040404040f0f04040404040100000104040404040404040404040401000107010404040404040404040401010000010101010101010101010101070100000101070707070707070707070401000000010404040404040404040401000000000001010101010101010101000000"),modified="2026-01-13 18:18:48",revision=958]]
## Quick Ref

```
Stack manipulation:
  \f2Enter\fd=dup  \f2Tab\fd=swap
  \f2Backspace\fd=drop  \f2Del\fd=dropfirst
  \f2PageUp\fd=roll \f2PageDown\fd=unroll\fi

Math operators:
  \f2+ - * /
  \f2~\fd=neg
  \f2\\fd=idiv \f2%\fd=mod
  \f2^\fd=pow \f2@\fd=sq \f2$\fd=sqrt\fi
```

## Introduction

This calculator uses postfix notation (aka RPN) instead
of traditional algebraic notation. This means the operators
follows their operands, instead of being infixed between them.

For example, to add 2 and 3 together, you should type
"2(enter)3+" instead of "2+3=" on a traditional calculator.
The postfix approach is especially useful when you're doing
repeated calculations on a small set of numbers; i.e. for the
problems that would be cumbersome to type on a traditional
calculator, but too trivial to merit a full-blown program.

:: src/calc.lua
--[[pod_format="raw",created="2026-01-10 20:00:00",modified="2026-01-13 18:18:48",revision=2643]]
function op_plus()
	if depth() < 2 then
		show_error("+: need 2 numbers")
		return
	end
	local result = get(2) + get(1)
	local source = str(get(2)).."+"..str(get(1))
	cmd_drop()
	cmd_drop()
	push(result, source)
end


function op_minus()
	if depth() < 2 then
		show_error("-: need 2 numbers")
		return
	end
	local result = get(2) - get(1)
	local source = str(get(2)).."-"..str(get(1))
	cmd_drop()
	cmd_drop()
	push(result, source)
end


function op_negated()
	if depth() < 1 then
		show_error("~: need 1 number")
		return
	end
	local source = "neg("..str(get(1))..")"
	local result = - get(1)
	cmd_drop()
	push(result, source)
end


function cmd_neg()
	if depth() < 1 then
		show_error("neg: need 1 number")
		return
	end
	local result = - get(1)
	local source = "neg("..str(get(1))..")"
	cmd_drop()
	push(result, source)
end


function op_times()
	if depth() < 2 then
		show_error("*: need 2 numbers")
		return
	end
	local result = get(2) * get(1)
	local source = str(get(2)).."*"..str(get(1))
	cmd_drop()
	cmd_drop()
	push(result, source)
end


function op_slash()
	if depth() < 2 then
		show_error("/: need 2 numbers")
		return
	end
	local result = get(2) / get(1)
	local source = str(get(2)).."/"..str(get(1))
	cmd_drop()
	cmd_drop()
	push(result, source)
end


function op_backslash()
	if depth() < 2 then
		show_error("\\: need 2 numbers")
		return
	end
	local result = get(2) // get(1)
	local source = str(get(2)).."\\"..str(get(1))
	cmd_drop()
	cmd_drop()
	push(result, source)
end


function op_mod()
	if depth() < 2 then
		show_error("%: need 2 numbers")
		return
	end
	local result = get(2) % get(1)
	local source = str(get(2)).."%"..str(get(1))
	cmd_drop()
	cmd_drop()
	push(result, source)
end


function op_pow()
	if depth() < 2 then
		show_error("^2: need 2 numbers")
		return
	end
	local result = get(2) ^ get(1)
	local source = str(get(2)).."^"..str(get(1))
	cmd_drop()
	cmd_drop()
	push(result, source)
end


function cmd_sq()
	if depth() < 1 then
		show_error("^: need 1 number")
		return
	end
	local result = get(1) ^ 2
	local source = str(get(1)).."^2"
	cmd_drop()
	push(result, source)
end


function cmd_sqrt()
	if depth() < 1 then
		show_error("sqrt: need 1 number")
		return
	end
	local result = sqrt(get(1))
	local source = "sqrt("..str(get(1))..")"
	cmd_drop()
	push(result, source)
end

:: src/config.lua
--[[pod_format="raw",created="2026-01-11 15:26:40",modified="2026-01-13 18:18:48",revision=1757]]
config = {
	big_rows = false,
	with_keyboard = true,
	keyboard_below = true,
}


function height_row()
	return config.big_rows and 21 or 13
end

:: src/entry.lua
--[[pod_format="raw",created="2026-01-10 13:36:29",modified="2026-01-13 18:18:48",revision=3202]]
local buffer = nil


function entry()
	return buffer
end


function append(expr)
	if not buffer then
		buffer = expr
	else
		buffer ..= expr
	end
	buffer = parse(buffer)
	undo_stack:checkpoint()
end


function update_entry()
	local changed = false
	while peektext() do
		clear_error()
		local c = readtext()
		if is_uppercase(c) then
			pick(letter_to_index(c, "uppercase"), c)
		else
			if not buffer then
				buffer = ""
			end
			if c == "?" then
				show_help()
			else
				buffer ..= c
				changed = true
			end
		end
	end
	if changed then
		buffer = parse(buffer)
		undo_stack:checkpoint()
	end
		
	local plain = not key("shift") and not key("ctrl") and not key("alt")
	local shifted = key("shift") and not key("ctrl") and not key("alt")
	local ctrled = not key("shift") and key("ctrl") and not key("alt")
	local ctrl_shifted = key("shift") and key("ctrl") and not key("alt")
	
	if keyp("kp enter") then
		clear_error()
		buffer = parse((buffer or "") .. " ")
		undo_stack:checkpoint()
	end
	
	if keyp("enter") then
		clear_error()
		if plain and buffer then
			buffer = parse(buffer .. " ")
			undo_stack:checkpoint()
		elseif plain and not buffer then
			cmd_dup()
			undo_stack:checkpoint()
		elseif shifted then
			cmd_dup()
			undo_stack:checkpoint()
		end
	end
	
	if keyp("backspace") then
		clear_error()
		if plain and buffer then
			buffer = string.sub(buffer, 1, #buffer - 1)
		elseif ctrled then
			buffer = ""
		elseif plain and not buffer then
			cmd_drop()
			undo_stack:checkpoint()
		elseif shifted then
			-- works when editing an entry
			cmd_drop()
			undo_stack:checkpoint()
		elseif ctrl_shifted then
			cmd_clear()
			undo_stack:checkpoint()
		end
	end
	
	if keyp("del") then
		clear_error()
		if plain and buffer then
			buffer = ""
		elseif plain and not buffer then
			cmd_dropfirst()
			undo_stack:checkpoint()
		elseif shifted then
			cmd_dropfirst()
			undo_stack:checkpoint()
		elseif ctrl_shifted then
			cmd_clear()
			undo_stack:checkpoint()
		end
	end
	
	if keyp("tab") then
		clear_error()
		if plain then
			buffer = parse((buffer or "") .. " swap ")
			undo_stack:checkpoint()
		elseif shifted then
			cmd_swap()
			undo_stack:checkpoint()
		end
	end
	
	if keyp("pageup") then
		clear_error()
		if plain then
			buffer = parse((buffer or "") .. " roll ")
			undo_stack:checkpoint()
		elseif shifted then
			cmd_roll()
			undo_stack:checkpoint()
		end
	end
	
	if keyp("pagedown") then
		clear_error()
		if plain then
			buffer = parse((buffer or "") .. " unroll ")
			undo_stack:checkpoint()
		elseif shifted then
			cmd_roll()
			undo_stack:checkpoint()
		end
	end
end

:: src/error.lua
--[[pod_format="raw",created="2026-01-10 20:54:23",modified="2026-01-13 18:18:48",revision=2535]]
local error_msg = ""
local welcome_msg = "  stack calc\n\ntype ? for help"


function show_error(msg)
	error_msg = msg
end


function clear_error()
	error_msg = ""
	welcome_msg = ""
end


function draw_error(width, height)
	if welcome_msg ~= "" then
		local msg = "\014"..welcome_msg
		local w, h = print(msg, -1000, -1000)
		w += 1000; h += 1000
		w += 20; h += 14
		local x = (width - w) // 2
		local y = (height - h) // 2
		rrectfill(x + 2, y + 2, w - 1, h - 1, 0, 0)
		rrectfill(x, y, w - 1, h - 1, 0, 5)
		rrect(x + 2, y + 2, w - 5, h - 5, 0, 22)
		print(msg, x + 10, y + 7, 7)
		return
	end
	if error_msg == "" then
		return
	end
	local msg = "\014"..error_msg
	local w, h = print(msg, -1000, -1000)
	w, h = w + 1000, h + 1000
	local y = 0
	rrectfill(0, y, width, h + 5, 0, 8)
	print(msg, (width - w) // 2, y + 3, 7)
end

:: src/help.lua
--[[pod_format="raw",created="2026-01-12 11:43:13",modified="2026-01-13 18:18:48",revision=1018]]
local help_shown = false
local help_text = ""
local help_lines = {}
local help_current_line = 1
local resize_timer = 0
local resize_needed = true
local small_font = true


function is_help_shown()
	return help_shown
end


function show_help()
	help_shown = true 
end


function hide_help()
	help_shown = false
end


local function resize_help()
	if resize_timer == 0 then
		resize_needed = true
	end
end


function init_help()
	help_text = fetch("manual.txt")
	on_event("resize", function() resize_help() end)
	resize_help()
end


function update_help()
	if resize_timer > 0 then
		resize_timer -= 1
	elseif resize_needed then
		local width = get_display():width() - 2
		small_font = width < 160
		help_lines = soft_wrap(help_text, width, small_font)
		resize_timer = 15
	end
	
	while peektext() do
		local c = readtext()
		if c == "?" then
			hide_help()
		end
	end
	
	local _mx, _my, _mb, _wheel_x, wheel_y = mouse()
	if wheel_y ~= 0 then
		local nb_lines = get_display():height() // (small_font and 6 or 11)
		help_current_line = mid(
			1,
			help_current_line - (wheel_y * 3),	
			#help_lines - nb_lines + 1
		)
	end
end


function draw_help(x, y, w, h)
	local h_window = get_display():height()
	local w_window = get_display():width()
	cls(7)
	cursor(2, 2)
	color(18)
	local l = help_current_line
	local y = 0
	while y < h_window and l <= #help_lines do
		if small_font then
			print("\014"..string.lower(help_lines[l]))
			y += 6
		else
			print(help_lines[l])
			y += 11
		end
		l += 1
	end
end

:: src/keyboard.lua
--[[pod_format="raw",created="2026-01-13 12:59:02",modified="2026-01-13 18:18:48",revision=286]]
local kbd = {
	-- First row
	{
		{ sprite = 0, expr = " clear ", },
		{ sprite = 1, expr = "", },
		{ sprite = 2, expr = "", },
		{ sprite = 3, expr = "", },
		{ sprite = 4, expr = "", },
		{ sprite = 5, expr = "", },
	},
	-- Second row
	{
		{ sprite = 8, expr = "", },
		{ sprite = 9, expr = "", },
		{ sprite = 10, expr = "", },
		{ sprite = 11, expr = "", },
		{ sprite = 12, expr = "", },
		{ sprite = 13, expr = "", },
	},
	-- Third row
	{
		{ sprite = 16, expr = "", },
		{ sprite = 17, expr = "", },
		{ sprite = 18, expr = "", },
		{ sprite = 19, expr = " 1 swap /", },
		{ sprite = 20, expr = " sq ", },
		{ sprite = 21, expr = " sqrt ", },
	},
	-- Fourth row
	{
		{ sprite = 24, expr = "", },
		{ sprite = 25, expr = "7", },
		{ sprite = 26, expr = "8", },
		{ sprite = 27, expr = "9", },
		{ sprite = 28, expr = "^", },
		{ sprite = 29, expr = "", },
	},
	-- Fifth row
	{
		{ sprite = 32, expr = " roll ", },
		{ sprite = 33, expr = "4", },
		{ sprite = 34, expr = "5", },
		{ sprite = 35, expr = "6", },
		{ sprite = 36, expr = "*", },
		{ sprite = 37, expr = "/", },
	},
	-- Sixth row
	{
		{ sprite = 40, expr = " unroll ", },
		{ sprite = 41, expr = "1", },
		{ sprite = 42, expr = "2", },
		{ sprite = 43, expr = "3", },
		{ sprite = 44, expr = "+", },
		{ sprite = 45, expr = "-", },
	},
	-- Sixth row
	{
		{ sprite = 48, expr = " swap ", },
		{ sprite = 49, expr = "0", },
		{ sprite = 50, expr = ".", },
		{ sprite = 51, expr = " ~ ", },
		{ sprite = 52, expr = " ", }, -- TODO
		nil,
	},
}


local kbd_state = {}
for j = 1, 7 do
	add(kbd_state, {})
	for i = 1, 6 do
		add(kbd_state[j], false)
	end
end


function update_keyboard(x, y, width, height)
	local mx, my, mb, wheel_x, wheel_y = mouse()
	mx -= x; my -= y
	if mx >= 0 and mx <= width and my >= 0 and my <= height then
		window { cursor = "pointer" }
	end
	if mb == 1 then
		local i, j = 1 + (mx // 21), 1 + (my // 15)
		if i == 6 and j == 7 then i = 5 end
		local key = kbd[j] and kbd[j][i]
		if key then
			if not kbd_state[j][i] then
				clear_error()
				kbd_state[j][i] = true
				append(key.expr)
			end
		end
	else
		for i = 1, 6 do
			for j = 1, 7 do
				kbd_state[j][i] = false
			end
		end
	end
end


function draw_keyboard(x, y, width, height)
	camera(-x, -y)
	rrectfill(0, 0, width, height, 0, 13)
	for i = 0, 5 do
		for j = 0, 6 do
			local x_key = 4 + i * 21--24
			local y_key = 4 + j * 15
			local key = kbd[j + 1][i + 1]
			if key ~= nil then
				local sprite = key.sprite
				if kbd_state[j + 1][i + 1] then
					sprite += 64
				end
				spr(sprite, x_key, y_key)
			end
--			rrectfill(x_key, y_key, 17, 11, 1, 6)
--			print("8", x_key + 6, y_key + 2, 0)
		end
	end
	camera()
end

:: src/parser.lua
--[[pod_format="raw",created="2026-01-10 14:19:08",modified="2026-01-13 18:18:48",revision=3154]]
local op_funcs = {
	["+"] = op_plus,
	["-"] = op_minus,
	["~"] = op_negated,
	["*"] = op_times,
	["/"] = op_slash,
	["\\"] = op_backslash,
	["%"] = op_mod,
	["^"] = op_pow,
	["@"] = cmd_sq,
	["$"] = cmd_sqrt,
}


local cmd_funcs = {
	["drop"] = cmd_drop,
	["clear"] = cmd_clear,
	["dup"] = cmd_dup,
	["swap"] = cmd_swap,
	["roll"] = cmd_roll,
	["unroll"] = cmd_unroll,
	["neg"] = cmd_neg,
	["sq"] = cmd_sq,
	["sqrt"] = cmd_sqrt,
}


function parse(buffer)
	local maybe_more = true
	while #buffer > 0 and maybe_more do
		maybe_more = false
		local c = buffer[1]
		local op_func = op_funcs[c]
		if is_number_char(c) then
			buffer, maybe_more = parse_number(buffer)
		elseif is_space(c) then
			buffer, maybe_more = string.sub(buffer, 2), true
		elseif op_func then
			op_func()
			buffer, maybe_more = string.sub(buffer, 2), true
		elseif is_lowercase(c) then
			buffer, maybe_more = parse_identifier(buffer)
--		elseif is_uppercase(c) then
--			pick(string.byte(c) - string.byte("A") + 1)
--			buffer, maybe_more = string.sub(buffer, 2), true
		else
			show_error("unknown character: "..c)
			buffer, maybe_more = string.sub(buffer, 2), true
		end
	end
	if buffer == "" then
		buffer = nil
	end
	return buffer
end


function parse_number(buffer)
	local pos = 1
	while is_number_char(buffer[pos]) do
		pos += 1
	end
	if pos > 1 and (pos - 1 < #buffer) then
		local number = tonumber(string.sub(buffer, 1, pos - 1))
		push(number)
		return string.sub(buffer, pos), true
	end
	return buffer, false
end


function parse_identifier(buffer)
	local pos = 1
	while is_lowercase(buffer[pos]) do
		pos += 1
	end
	if pos > 1 and (pos - 1 < #buffer) then
		local identifier = string.sub(buffer, 1, pos - 1)
		if #identifier == 1 then
			pick(letter_to_index(identifier, "lowercase"), identifier)
		else
			local cmd_func = cmd_funcs[identifier]
			if cmd_func then
				cmd_func()
			else
				show_error([[unknown command: "]]..identifier..[["]])
			end
		end
		return string.sub(buffer, pos), true
	end
	return buffer, false
end


-------------------------------------------------------------------------------------------------


function is_space(char)
	if not char then return false end
	return char == " "
end


function is_number_char(char)
	if not char then return false end
	return (char >= "0" and char <= "9") or char == "."
end


function is_uppercase(char)
	if not char then return false end
	return char >= "A" and char <= "Z"
end


function is_lowercase(char)
	if not char then return false end
	return char >= "a" and char <= "z"
end

:: src/soft_wrap.lua
--[[pod_format="raw",created="2025-03-07 11:09:14",modified="2026-01-13 18:18:48",revision=1689]]
-- Soft-wraps a very tiny subset of markdown.
function soft_wrap(text, width, with_small_font)
	local function prefix(s) if with_small_font then return "\014"..s else return s end end
	local space_width <const> = print(prefix(" "), -1000, -1000) + 1000
	local lines = {}
	local context = "default" -- "default", "paragraph", "list" or "code"
	local x = 0
	
	local function add_line_break()
		if #lines == 0 then
			return
		end
		if lines[#lines] ~= "" then
			add(lines, "")
		end
		x = 0
	end
	
	local function add_paragraph_break()
		if #lines == 0 then
			return
		end
		if lines[#lines] ~= "" then
			add(lines, "")
			add(lines, "")
		elseif #lines > 1 and lines[#lines - 1] ~= "" then
			add(lines, "")
		end
		x = 0
	end
	
	local function add_line(line)
		if lines[#lines] == "" then
			lines[#lines] = line
		elseif context == "code" and line == "" then
			add(lines, " ")
		else
			add(lines, line)
		end
		x = 0
	end

	local function add_word(word)
		local dx = print(prefix(word), -1000, -1000) + 1000
		if lines[#lines] == "" then
			lines[#lines] = word
			x += dx
		elseif x + space_width + dx >= width then
			-- Start a new line
			add(lines, "")
			x = 0
			if context == "list" then
				lines[#lines] ..= "  "
				x += 2 * space_width
			end
			lines[#lines] ..= word
			x += dx
		else
			lines[#lines] ..= " " .. word
			x += space_width + dx
		end
	end
	
	for source_line in text:gmatch("([^\n]*)\n") do
		source_line = source_line:gsub("\\f", "\f")
		if context == "code" then
			if source_line:find("^```") then
				context = "default"
			else
				add_line(source_line)
			end
			goto next_line
		end
		if source_line:find("^```") then
			context = "code"
			goto next_line
		end
		if source_line:find("^#+") then
			add_paragraph_break()
			add_line(source_line)
			add_paragraph_break()
			context = "default"
			goto next_line
		end
		if source_line:find("^%s*$") then
			add_paragraph_break()
			context = "default"
			goto next_line
		end
		if source_line:find("^%s*-") then
			add_line_break()
			context = "list"
		end
		for word in source_line:gmatch("[^%s]+") do
			add_word(word)
		end
		::next_line::
	end
	
	return lines
end

:: src/stack.lua
--[[pod_format="raw",created="2026-01-10 18:50:54",modified="2026-01-13 18:18:48",revision=2748]]
local stack = { }


function get_stack_state()
	return stack
end


function set_stack_state(stack_state)
	stack = stack_state
end


function depth()
	return #stack
end


function index_to_letter(idx, uppercase)
	if (#stack - idx) >= 26 then return "?" end
	local base = (uppercase == "uppercase") and "A" or "a"
	return string.char((#stack - idx) + string.byte(base))
end


function letter_to_index(char, uppercase)
	local base = (uppercase == "uppercase") and "A" or "a"
	local result = #stack - (string.byte(char) - string.byte(base))
	if result < 1 then
		return nil -- TODO: something safer?
	end
	return result
end


function get_item(index)
	local item = stack[#stack - (index - 1)]
	return item
end


function get(index)
	local item = get_item(index)
	return item and item.value or nil
end


function push_item(item)
	if not item or type(item) ~= "table" then
		return
	end
	add(stack, item)
end


function push(number, source)
	if not number or type(number) ~= "number" then
		return
	end
	add(stack, { value = number, source = source or "" })
end


-----------------------------------------------------------------------------------
-- Interactive Stack Manipulation
-----------------------------------------------------------------------------------


function pick(index, letter)
	if (not index) or (index > #stack) then
		show_error("pick: nothing on "..string.lower(letter))
		return
	end
	local value = get(index)
	if value then
		push(value)
	end
end


-----------------------------------------------------------------------------------
-- Commands
-----------------------------------------------------------------------------------


function cmd_drop()
	if #stack < 1 then
		show_error("drop: nothing on the stack")
		return
	end
	_ = deli(stack)
end


function cmd_dropfirst()
	if #stack < 1 then
		show_error("dropfar: nothing on the stack")
		return
	end
	_ = deli(stack, 1)
end


function cmd_clear()
	if #stack < 1 then
		show_error("clear: nothing on the stack")
		return
	end
	stack = {}
end


function cmd_dup()
	if #stack < 1 then
		show_error("dup: nothing on the stack")
		return
	end
	pick(1)
end


function cmd_swap()
	if #stack < 2 then
		show_error("swap: need 2 values")
		return
	end
	stack[#stack - 0], stack[#stack - 1] =
		stack[#stack - 1], stack[#stack - 0]
end


function cmd_roll()
	if #stack < 1 then
		show_error("dup: nothing on the stack")
		return
	end
	local far_item = deli(stack, 1)
	add(stack, far_item)
end


function cmd_roll()
	if #stack < 1 then
		show_error("roll: nothing on the stack")
		return
	end
	local far_item = deli(stack, 1)
	add(stack, far_item)
end


function cmd_unroll()
	if #stack < 1 then
		show_error("unroll: nothing on the stack")
		return
	end
	local bottom_item = deli(stack)
	add(stack, bottom_item, 1)
end

:: src/state.lua
--[[pod_format="raw",created="2026-01-12 10:16:01",modified="2026-01-13 18:18:48",revision=1145]]
undo_stack = nil


function init_undo_stack()
	undo_stack = create_undo_stack(
		function()
			local state = {
				stack = get_stack_state()
			}
			return state
		end,
		function(state)
			if type(state) == "table" and state.stack then
				set_stack_state(state.stack)
			end
		end
	)
end

:: todo.txt
--[[pod_format="raw",created="2026-01-11 17:05:04",modified="2026-01-13 18:18:48",revision=1629]]
- add: interactive drop, swap, and roll
- add: right-click menu on stack rows
- add: left-click on stack rows to pick
- add: scrolling the stack
- add: help screen
- add: manual
- add: macros for keys `)` `]` `}`
- add: up/down to limit stack depth?
:: .info.pod
--[[pod,created="2025-11-13 21:07:43",modified="2026-01-13 18:18:48",runtime=24,workspaces={{location="main.lua",workspace_index=1},{location="gfx/0.gfx",workspace_index=2},{location="map/0.map",workspace_index=3},{location="sfx/0.sfx",workspace_index=4}}]]
:: doc/.info.pod
--[[pod,created="2026-01-10 13:20:37",modified="2026-01-13 18:18:48"]]
:: doc/rcalc.md
b64$LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNi0wMS0xMCAxMjo0MTo0OCIsbW9k
aWZpZWQ9IjIwMjYtMDEtMTMgMTg6MTg6NDgiLHJldmlzaW9uPTMyNDVdXQpSUE4gY2FsY3VsYXRv
cgoKRGVzaWduOiBzYW1lIGtleSBzZXF1ZW5jZSBmb3IgaW50ZXJhY3RpdmUgdXNlIGFuZCBleHBy
ZXNzaW9ucy4gSS5lLiB1c2UgZW50ZXIKYmV0d2VlbiBlbnRyaWVzIGZvciBzdGVwIGJ5IHN0ZXAg
ZGlzcGxheSwgb3Igc3BhY2UgZm9yIGNhbGN1bGF0aW5nIGFuIGV4cHJlc3Npb24KaW4gYSBzaW5n
bGUgZ28uCgpObyBvbi1zY3JlZW4ga2V5Ym9hcmQ6IHVzZSB0aGUgY29tcHV0ZXIncyBrZXlib2Fy
ZC4KCkRpc3BsYXkgdGhlIHN0YWNrLCBhcyB3ZWxsIGFzIGFueSB1c2VyLWRlZmluZWQgdmFyaWFi
bGVzIGFuZCBmdW5jdGlvbnMuCgpPbmUga2V5IG9wZXJhdGlvbnM6ICsgLSB_KG5lZ2F0aW9uKSAq
IC8gXiAlIFwgIQoKSW1tZWRpYXRlIHN0YWNrIG1hbmlwdWxhdGlvbjoKCi0gYGR1cGA6IFBnRG93
bgotIGBvdmVyYCwgYHBpY2tgOiBob2xkIFNoaWZ0ICsgaGl0IFBhZ2VEb3duIG11bHRpcGxlIHRp
bWVzCi0gYGRyb3BgOiBQZ1VwCi0gYGRyb3BuYDogaG9sZCBTaGlmdCArIGhpdCBQYWdlVXAgbXVs
dGlwbGUgdGltZXMKLSBgc3dhcGA6IFRhYgotIGByb3RgOiBTaGlmdCtUYWIKLSBlZGl0IEE6IElu
c2VydAotID8-PzogU2hpZnQrSW5zZXJ0CgpJbnRlcmFjdGl2ZSBwaWNrOiBzaGlmdCArIHN0YWNr
IGxldHRlcgoKQXNzaWduIHZhcmlhYmxlOiAiOiIgKyBsb3dlcmNhc2UgaWRlbnRpZmllcgoKRnVu
Y3Rpb24gY2FsbDogc3RhcnRzIHdpdGggYSBsb3dlcmNhc2UgbGV0dGVyLgoKVmFyaWFibGUgYW5k
IGZ1bmN0aW9uIGRlZmluaXRpb246IGxvd2VyY2FzZSB3b3JkLCB0aGVuICI9IiwgdGhlbiBleHBy
ZXNzaW9uLAp0aGVuIGVudGVyLiBFeHByZXNzaW9uIGlzIGEgc2VxdWVuY2Ugb2YgbnVtYmVycywg
b3BlcmF0aW9ucywgbG93ZXJjYXNlIHdvcmRzIGFuZAp1cHBlcmNhc2UgbGV0dGVycyBzZXBhcmF0
ZWQgYnkgc3BhY2Uu
:: gfx/.info.pod
--[[pod,created="2025-11-13 21:07:43",modified="2026-01-13 18:18:48"]]
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAxLTE3IDEwOjM1OjQ4Iixtb2RpZmllZD0iMjAyNi0w
MS0xMyAxNzo1MzoyMCIscmV2aXNpb249ODddXWx6NAAoCAAAsjwAAPEXe1swXT17Ym1wPXB4dQBD
IBEMBADvGAD_FhcOBy4nXgcuBy4HDgcIACMXbg4A8xBuFw4nDgcOB-4VDxLuDQDtACxmbGFncz0w
LHBhbl94CADLeT0wLHpvb209OH0sYQD-COIA8igHEieiNxIHkifSN-IaDxLiDgDuSAAh7yknEgeS
BxI30ifCN-IXSAAn9gYVLQIdEi1iDRINAg0SDXINEh0iDXIOAH8NAg0CLfIVYAAqZS0SHVINAgIA
EFJyAAAIACQNIhIAAgoAPx3yFmgAJ0cWHRIdTAAPCgABMh1yHRAADzABIl8QEATw8JkAHC-wvDEA
HAGDAoAVFx4nDgd_B2sCEi4IACYXHhAAAB4AHyeDAiZf7xQA-ok8AP8RD_8BV-8CCAfuF953foeO
d54X-gAH-grqACiBCgfuB_4H-gADABEBAwAfCE8AKBQIRQABUQABWwAPngAp8AYFBy4HrhcuB74H
HgfOBx4HDhcOF54UAL8HPgeuBx4XDhf_BF8AKOAMF-4BB_4HjhcOFw4nnrIAEN5TAA8BASk1GHeO
qgAAgQMEwAAAEAAv-gVXAoZP4gDyiUsFJPIB5gD2B08-9gAO9gAO5g7mDgoAX-YJDxLmRQEh9gHm
APYILz-GDiYOtg4mDsYuCgAv9ghTADMRPqkAL9YeowAmAOgBsQoXDhfeB34HHgc_BgAAjALPXgce
B94n-gAHzieuQwIosBUHDgc_R14HTgeeWQABxgUzTgcOCgDfDgeuFx4XvgcuB94XLlACdB8xUAIB
rxoH4ifCR6JnkmduCCbyA_YA9goPP_Ye1g4GDsYOFg7GTl8CDwkCKKEHTz_2DvYAPvYBSgBPAA62
Pk8AKUEJHz-W9AIfPqgCMLHvEwD_GAcuB84HDjsFjw4HzgcuB-4YTAIl3xMA-hoH-g9H-g8H-hor
AlFvJgwE8P_5fAQgrxdnkmeiR8In4gfiCiYAjQEELAIj9gADAE-WTvYHNQQuA9gEP_YO5k4ANE-W
HvYBLAIxERqyBiBH3gcADuEBD0kAGE86R-46IAJRDzEAEB83HwIB-hcERxIHggdCF4IHAgcSR2IH
AhcSFwIHYkcSBwIHghdCB4IHIjfyBTkCDx4GHr8WHrYOBg4GDrYeFqEBLX-mAPZdHz-mZgYnAtEC
AcUCENY2Ai-2D38CI7AmDAQA-xkUAP5BN48IsQ5HDjcON74HPhcepQ4QPqMIEidcBlAuBy4nHhwA
NQceFxwAATYAMS4HLggAr-5CDxL_FA0A-RSEACOxQicONy4nLicOR65eABEOBADAPgf_ABceNx5H
Dgc_QAcA8AYCGAAx7iceDABOHicOR3wAD5UEGA-YAkoMRwJUJg62TrYKAAD0Aw83BCgmBz9VAAVl
Bg_1BisFqAAFKAUP6gItQAcvP9agBwSfAAJNAwBVAB8JqwcuQg72AC4BAx4AgAUPTwAiIj7GCAA_
DvYLTwAPHgITD3IJTvEEAu8VAP4WFg4GLiZeBi4GLgYOBggAIxZuDgBAbhYOJqwELv4V9AQPXgAT
7ygGHiauNh4GnibeNv4aRgAl7ykmHgaeBh423ibONv4XRgAl9gYVLQ4dHi1uDR4NDg0eDX4NHh0u
DX4OAH8NDg0OLf4VXgAoZS0eHV4NDgIAEF5wAAAIACQNLhIAAgoAPx3_FmYAJUcWHR4dSgAPCgAB
Mh1_HRAADioBD3YCd3AVFh4mDgZ_CAciBi4IACYWHhAAAB4AHyaMAScfiTkA-wEP3QFY-wIIBu4W
3nZ_ho52nhb_AAb_CuQAJYEKBu4G7gb_AAMAEQEDAB8ITAAlFAhCAAFOAAFYAA_YACbwBgUGLgau
Fi4GvgYeBs4GHgYOFg4WnhQAvwY_Bq4GHhYOFv4EXAAl4AwW-gEG7gaOFg4WDiaerAAQ3lAAD-gA
JjUYdo6kAABgAwS6AAAQAC-_BUUChw8ZAyLyAeUA9QdPP-UADvUADuUO5Q4KAE-1CQDlTAAi1ggv
P8UOJQ61DiUOxS4KAC-1CFAAMBE_owAv1R6dACMAIgGxChYOFt4GfgYeBj4GAAB4Au9eBh4G3ib_
AAbOJq4A7lgAI5AVBg4GPkZeBk50ByEGHpQFM04GDgoA3w4GrhYeFr4GLgbeFi4-AoevGgbuJs5G
rmaeZjEII-ID5QD1Cg8-5R7VDgUOxQ4VDsVOTgIP_wEloQdPP7UO9QA_9QFHAE8ADrU_TAAmQQkf
P9XdAh8_lAItACoBcRgGLgbOBg4TBY4OBs4GLgb_GDIBD3YBFY-_D0b_Dwb_GhoCh54XZp5mrkbO
Ju6mAA_BARYEGgIj9QADAE-VTvUHFQQrA7IEP_UO5UsAMU-VHvUBGgIuERp_BiBG3gcADywBIwBG
AE86Rv46PAAgH7wOAlOQBEYeBo4GThaO4QQgRm6HClAWDgZuRu0Ejo4WTgaOBi42JwcP8AUdvxUe
tQ4FDgUOtR4VlgEqf_UA9V0fP_U1BiQCugIBrgIQ1SUCL-UPawIfAOoQPxf-FesRNj8A-hSAACEP
5xEuLwD_4hGBCjYCVCUOtU61CgAA2AMPGAQlJgc-UgAFNAYOgQYP2AIfBQAFD9MCKkAHLz-VYwcE
mQACMwMAUgAfCW4HK0IO9QAu6gIeAFUFD0wAHyI_xQgAPg71C0wADwwCDw9CG08PMQD--zYP7AQR
HzEyACwOlQAPMQD-----dw55Bw8tBTAfOJQAHR83MQC_DlgBDzEAbg-EABAfODEA7w5XAQ8xAP--
----------------A1BtPTh9fQ==
:: map/.info.pod
--[[pod,created="2025-11-13 21:07:43",modified="2026-01-13 18:18:48"]]
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAxLTE3IDEwOjM1OjQ4Iixtb2RpZmllZD0iMjAyNi0w
MS0xMCAxMjo0MTozMSIscmV2aXNpb249Ml1dbHo0AEwAAABQAAAA8Rx7e2JtcD1weHUATIAgIAD-
AAD---8DLGhpZGRlbj1mYWxzZSxwYW5feD0wCADSeT0wLHRpbGVfaD0xNgoAEHcKAIB6b29tPTF9
fQ==
:: sfx/.info.pod
--[[pod,created="2025-11-13 21:07:43",modified="2026-01-13 18:18:48"]]
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA3LTMxIDA4OjMwOjI4Iixtb2RpZmllZD0iMjAyNS0w
Ny0zMSAwODozMDoyOCIscmV2aXNpb249MF1dbHo0AKAAAAALCgAA-zBweHUAAygAAAQABA9AEAIO
AAGgASACoA4ADxAADfDKAQIDQA8PkAQFBgdADJAICQoLQAyQDwwPDQ8ODEAM8P8BAOv-J6oBEAYP
MBABIAEgAfAAAhACDhABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDjAA------_9
H-8BAKzPyA9AAA8QQP--sPD-AQD-6lD-----KQ==
:: src/.info.pod
--[[pod,created="2026-01-12 12:18:36",modified="2026-01-13 18:18:48"]]
:: [eoc]
