picotron cartridge // www.picotron.net
version 2

:: doc/
:: gfx/
:: map/
:: sfx/
:: src/
:: main.lua
--[[pod_format="raw",created="2026-01-10 13:14:25",modified="2026-01-21 18:05:53",revision=4386]]
include "src/config.lua"
include "src/state.lua"
include "src/stack.lua"
include "src/calc.lua"
include "src/parser.lua"
include "src/entry.lua"
include "src/error.lua"
include "src/soft_wrap.lua"
include "src/keyboard.lua"
include "src/help.lua"

local bg0 <const> = 19
local bg1 <const> = 3
local bg2 <const> = 27
local fg <const> = 7
local fg_alt <const> = 0


local width_kbd <const> = 130
local height_kbd <const> = 110


local blink_timer = 0
local blink_speed <const> = 20


function update_menu()
	menuitem {
		id="show_keyboard",
		label = config.keyboard_shown
			and "\^:0080c062361c0800 Show Keyboard"
			or  "\^:0000000000000000 Show Keyboard"
	}
	menuitem {
		id="keyboard_below",
		label = (not config.keyboard_below)
			and "\^:0080c062361c0800 Horizontal Layout"
			or  "\^:0000000000000000 Horizontal Layout"
	}
	menuitem {
		id="big_rows",
		label = config.big_rows
			and "\^:0080c062361c0800 Big Rows"
			or  "\^:0000000000000000 Big Rows"
	}
end


function _init()
	window {
		title = "Stack Calc",
		width = width_kbd, height = 2 * height_kbd,
		pauseable = false,
		fullscreen = false,
		workspace = "current",
		z = 10,
		icon = --[[pod_type="gfx"]]unpod("b64:bHo0ACIAAAAmAAAA8QBweHUAQyAICAQAVxAHMAcEAGNXEAcAFwAIAFAABxBXAA=="),
	}
	menuitem {
		id = "file_info",
	}
	menuitem {
		id = "show_keyboard",
		shortcut = "Ctrl-K",
		action = toggle_keyboard,
	}
	menuitem {
		id = "keyboard_below",
		action = toggle_keyboard_orientation,
	}
	menuitem {
		id = "big_rows",
		shortcut = "Ctrl-B",
		action = toggle_big_rows,
	}
	menuitem { divider = true }
	menuitem {
		id = "help",
		label = "\^:0000000000000000 Help",
		action = show_help,
	}
	update_menu()
	init_undo_stack()
	init_help()
	on_event("resize",
		function(msg)
			local width = max(msg.width, 68)
			local height = max(msg.height, 3 * 13)
			if config.keyboard_shown then
				if config.keyboard_below then
					width = max(msg.width, width_kbd)
					height = max(msg.height, height_kbd + 2 * 13 + 4)
				else
					width = max(msg.width, width_kbd + 68)
					height = max(msg.height, height_kbd)
				end
			end
			if width ~= msg.width or height ~= msg.height then
				send_message(pid(), { event = "resize", width = width, height = height })
			end
		end
	)
end


function toggle_keyboard()
	config.keyboard_shown = not config.keyboard_shown
	local width = get_display():width()
	local height = get_display():height()
	if config.keyboard_shown then
		if config.keyboard_below then
			height += height_kbd
		else
			width += width_kbd
		end
	else
		if config.keyboard_below then
			height -= height_kbd
		else
			width -= width_kbd
		end
	end
	update_menu()
	send_message(pid(), { event = "resize", width = width, height = height })
end


function toggle_keyboard_orientation()
	config.keyboard_below = not config.keyboard_below
	local width = get_display():width()
	local height = get_display():height()
	if config.keyboard_shown then
		if config.keyboard_below then
			width -= width_kbd
			height += height_kbd
		else
			width += width_kbd
			height -= height_kbd
		end
	end
	update_menu()
	send_message(pid(), { event = "resize", width = width, height = height })
end


function toggle_big_rows()
	config.big_rows = not config.big_rows
	update_menu()
end


function _update()
	blink_timer += 1
	blink_timer %= blink_speed * 2
	if is_help_shown() then
		update_help()
		return
	end
	update_entry()
	local width_win = get_display():width()
	local height_win = get_display():height()
	window { cursor = "default" }
	if config.keyboard_shown then
		local x_kbd = width_win - width_kbd
		local y_kbd = height_win - height_kbd
		if config.keyboard_below then
			x_kbd = x_kbd // 2
		else
			y_kbd = y_kbd // 2
		end
		update_keyboard(x_kbd, y_kbd, width_kbd, height_kbd)
	end
	if key("ctrl") then
		if key("shift") and keyp("z") then
			undo_stack:redo()
		elseif keyp("z") then
			undo_stack:undo()
		end
		if keyp("y") then
			undo_stack:redo()
		end
		if keyp("c") then
			if entry_shown() then
				set_clipboard(entry())
			elseif depth() >= 1 then
				set_clipboard(get(1))
			end
		end
		if keyp("v") then
			append(get_clipboard())
		end
	end
	local mx, my, mb, _, wheel_y = mouse()
--	if mb ~= 0 then
--		clear_error()
--	end
end


local function draw_stack_row(idx, x, y, width, no_entry)
	local h_row = height_row()
	local offset = no_entry and 0 or 1
	--local offset = depth() % 2
	if idx % 2 == offset then
		rrectfill(x, y, width, h_row, 0, bg1)
	else
		rrectfill(x, y, width, h_row, 0, bg2)
	end
	local item = get_item(idx)
	line(x + width - 9, y, x + width - 9, y + h_row - 1, 19)
	if item then
		local y_letter = y + h_row - 10
		print(index_to_letter(idx, "lowercase"), x + width - 6, y_letter, fg_alt)
		local text_value = str(item.value)
		local w_value = print(text_value, 0, -1000, 0)
		local big_rows = h_row > 20
		if item.source ~= "" then
			local text_source = "\014"..item.source..(big_rows and "=" or "")
			local w_source = print(text_source, 0, -1000, 0)
			local source_fits = w_source + 2 < width - 12 - w_value
			if source_fits or big_rows then
				print(text_source, x + 2, y + 4, 0)
			else
				print(".\-f.\-f.", x + 2, y + 4, 0)
			end
		end
		print(text_value, x + width - 14 - w_value, y + h_row - 10, fg)
	end
end


function draw_entry(x, y, width)
	local h_row = height_row()
	rrectfill(x, y, width, h_row, 0, 1)
	local text_entry = entry()
	local w = print(text_entry, 0, -1000)
	local x_end = print(text_entry, x + width - 14 - w, y + h_row - 10, fg)
	if (peek(0x547f) & 0x10) > 0 then
		if blink_timer <= blink_speed then
			rrectfill(x_end, y + h_row - 12, 6, 11, 0, 14)
		end
	else
		rrect(x_end, y + h_row - 12, 6, 11, 0, 14)
	end
end


function draw_stack(x_stack, y_stack, width, height)
	local idx = 1
	local h_row = height_row()
	local y_start = y_stack + height - h_row
	if entry_shown() then
		y_start -= h_row
	end
	for y = y_start, - h_row, - h_row do
		draw_stack_row(idx, x_stack, y, width, entry_shown())
		idx += 1
	end
	if entry_shown() then
		draw_entry(x_stack, y_stack + height - h_row, width)
	end
end


function _draw()
	cls(13)
	local width_win = get_display():width()
	local height_win = get_display():height()
	local width_stack, height_stack = width_win, height_win
	if config.keyboard_shown then
		if config.keyboard_below then
			height_stack -= height_kbd
		else
			width_stack -= width_kbd
		end
	end

	if is_help_shown() then
		draw_help()
		return
	end
	
	do
		local x, y = 2, 2
		local width = width_stack - 4
		local height = height_stack - 4
		clip(x, y, width, height)
		draw_stack(x, y, width, height)
		draw_error(x, y, width, height)
		clip()
		rrectfill(x, y, width, height, 4, 0x800000000 | 13)
		rrect(x - 1, y - 1, width + 2, height + 2, 6, 6)
		clip(x - 1, y - 1, width - 1, height - 1)
		rrect(x - 1, y - 1, width + 2, height + 2, 6, 5)
		clip()
	end
	
	if config.keyboard_shown then
		local x_kbd = width_win - width_kbd
		local y_kbd = height_win - height_kbd
		if config.keyboard_below then
			x_kbd = x_kbd // 2
		else
			y_kbd = y_kbd // 2
		end
		draw_keyboard(x_kbd, y_kbd, width_kbd, height_kbd)
	end
end


-----------------------------------------------------------------------------------------
-- Utils
-----------------------------------------------------------------------------------------


function str(v)
	if type(v) == "nil" then
		return "nil"
	elseif type(v) == "bool" then
		return v and "true" or "false"
	elseif type(v) == "number" then
		local s
		if v == 0 then
			s = "0"
		elseif abs(v) >= 0.001 and abs(v) <= 999999999999 then
			s = string.format("%f", v)
			if string.find(s, "%.") then
				s = string.gsub(s, "0*$", "")
				s = string.gsub(s, "%.$", "")
			end
		else
			s = string.format("%99e", v)
		end
--		local s = tostr(v)
--		s = string.gsub(s, "%.0$", "")
		return s
	elseif type(v) == "string" then
		return pod(v)
	elseif type(v) == "table" then
		local s = "{"
		for k, v in pairs(v) do
			s ..= stringify(k).."="..stringify(v)..","
		end
		return s.."}"
	else
		return "**unknown type**"
	end
end

:: manual.txt
--[[pod_format="raw",created="2026-01-12 12:42:40",icon=userdata("u8",16,16,"000001010101010101010101010000000001040404040404040404040401000001070104040404040404040404040100000101040404040f0f0f0404040401000001040404040f0f040f0f04040401000107010404040404040f0f040404010000010104040404040f0f040404040100000104040404040f0f0404040404010001070104040404040404040404040100000101040404040f0f04040404040100000104040404040404040404040401000107010404040404040404040401010000010101010101010101010101070100000101070707070707070707070401000000010404040404040404040401000000000001010101010101010101000000"),modified="2026-01-21 18:05:53",revision=2089]]
## Quick Ref

```
Stack manipulation:
  [Tab]: "swap"
  [Enter]: "dup"
  [Backspace]: "drop"
  [Ctrl-Del]: "clear"
  [PageUp]/[PageDown]: "roll"/"unroll"

Math operators:
  [+] [-] [*] [/]
  [~]: "neg"    [&]: "inv"
  [\]: "idiv"    [%]: "mod"
  [^]: "pow"
  [@]: "sq"    [$]: "sqrt"
  [!]: "fact"

Math functions:
  "sqrt" "root"
  "exp" "ln" "pow10" "log"
  "cos" "sin" "tan" "acos" "asin" "atan" "atan2"
  "pi" "deg" "rad"
```
Stack variables: each single-letter variable correspond to a
stack row; "a" is the oldest entry, "b" the second oldest,
and so on.

## Introduction

This calculator uses postfix notation (aka RPN): operators
follow their operands. For example, to add 2 and 3 together,
type [2] [enter] [3] [+].

- Push numbers on the stack using [space] or [enter].

- Operators (such as [+] or [*]) take the numbers they need
  from the stack and replace them with the result.

- As a shortcut, operators can also be used to validate the
  number currently edited, and perform a calculation in a
  single step.

- Functions ("sqrt", "cos") and commands (such as "dup",
  "swap") are executed with [space] or [enter].

- Some keys manipulate the stack; the most useful are [tab]
  to swap the two most-recent entries, [enter] to duplicate
  the last entry, and [backspace] to drop it.

- Macros start with an opening bracket [(] [[] [{].

- Run a macro by typing the corresponding closing bracket.

Note: there is an on-screen keyboard for convenience, but
the app is designed to be used with your physical keyboard.

## Operator keys

- [+] [-] [*] [/]: arithmetic operators. Note that [-] is
  only used for subtraction; use [~] for entering negative
  numbers.
- [~]: negates the most recent number.
- [\]: integer division.
- [%]: modulo.
- [^]: exponentiation.
- [@]: square.
- [$]: square root.
- [!]: factorial

## Stack Manipulation

- [Tab]: exchange the two most recent numbers. Spelled
  "swap" in macros.

- [Enter] (when no entry is being edited): duplicate the
  most recent number. Spelled "dup" in macros.

- [Ctrl-Enter]: duplicate the second most recent number.
  Spelled "over" in macros.

- [PageUp]: move all numbers in the stack upward (the oldest
  is replacing the most recent). Spelled "roll" in macros.

- [PageDown]: move all numbers in the stack downward (the
  most recent is replacing the oldest). Spelled "unroll" in
  macros.

- [Backspace] (when no entry is being editied): remove the
  most recent number. Spelled "drop" in macros.

- [Del]: remove the oldest number. Spelled "dropfirst" in
  macros.

- [Ctrl-Del]: clear the stack. Spelled "clear" in macros.

## Macros

It's possible to define three macros at the same time,
corresponding to the three kind of brackets: () [] {}.

To start writing a macro, type an open bracket (eg [(]),
then type numbers, operators and commands as usual. When the
macro is complete, type the closing bracket. The macro will
be stored and immediately executes.

To run a macro at anytime, simply type the closing bracket.

To edit a macro, type the opening bracket again; the
previous content will be loaded in the entry buffer.

:: src/calc.lua
--[[pod_format="raw",created="2026-01-10 20:00:00",modified="2026-01-21 18:05:53",revision=3774]]
function op_plus(ongoing_source)
	if depth() < 2 then
		show_error("+: need 2 numbers")
		return
	end
	local result = get(2) + get(1)
	local source = str(get(2)).."+"..str(get(1))
	cmd_drop()
	cmd_drop()
	push(result, ongoing_source or source)
end


function op_minus(ongoing_source)
	if depth() < 2 then
		show_error("-: need 2 numbers")
		return
	end
	local result = get(2) - get(1)
	local source = str(get(2)).."-"..str(get(1))
	cmd_drop()
	cmd_drop()
	push(result, ongoing_source or source)
end


function op_negated(ongoing_source)
	if depth() < 1 then
		show_error("~: need 1 number")
		return
	end
	local source = "neg("..str(get(1))..")"
	local result = - get(1)
	cmd_drop()
	push(result, ongoing_source or source)
end


function cmd_neg(ongoing_source)
	if depth() < 1 then
		show_error("neg: need 1 number")
		return
	end
	local result = - get(1)
	local source = "neg("..str(get(1))..")"
	cmd_drop()
	push(result, ongoing_source or source)
end


function op_times(ongoing_source)
	if depth() < 2 then
		show_error("*: need 2 numbers")
		return
	end
	local result = get(2) * get(1)
	local source = str(get(2)).."*"..str(get(1))
	cmd_drop()
	cmd_drop()
	push(result, ongoing_source or source)
end


function op_slash(ongoing_source)
	if depth() < 2 then
		show_error("/: need 2 numbers")
		return
	end
	local result = get(2) / get(1)
	local source = str(get(2)).."/"..str(get(1))
	cmd_drop()
	cmd_drop()
	push(result, ongoing_source or source)
end


function op_backslash(ongoing_source)
	if depth() < 2 then
		show_error("\\: need 2 numbers")
		return
	end
	local result = get(2) // get(1)
	local source = str(get(2)).."\\"..str(get(1))
	cmd_drop()
	cmd_drop()
	push(result, ongoing_source or source)
end


function op_mod(ongoing_source)
	if depth() < 2 then
		show_error("%: need 2 numbers")
		return
	end
	local result = get(2) % get(1)
	local source = str(get(2)).."%"..str(get(1))
	cmd_drop()
	cmd_drop()
	push(result, ongoing_source or source)
end


function cmd_inv(ongoing_source)
	if depth() < 1 then
		show_error("inv: need 1 number")
		return
	end
	local result = 1 / get(1)
	local source = "1/"..str(get(1))
	cmd_drop()
	push(result, ongoing_source or source)
end


function op_pow(ongoing_source)
	if depth() < 2 then
		show_error("^: need 2 numbers")
		return
	end
	local result = get(2) ^ get(1)
	local source = str(get(2)).."^"..str(get(1))
	cmd_drop()
	cmd_drop()
	push(result, ongoing_source or source)
end


function cmd_root(ongoing_source)
	if depth() < 2 then
		show_error("root: need 2 numbers")
		return
	end
	local result = get(2) ^ (1.0 / get(1))
	local source = "root("..str(get(2))..","..str(get(1))..")"
	cmd_drop()
	cmd_drop()
	push(result, ongoing_source or source)
end


function cmd_sq(ongoing_source)
	if depth() < 1 then
		show_error("sq: need 1 number")
		return
	end
	local result = get(1) ^ 2
	local source = str(get(1)).."^2"
	cmd_drop()
	push(result, ongoing_source or source)
end


function cmd_sqrt(ongoing_source)
	if depth() < 1 then
		show_error("sqrt: need 1 number")
		return
	end
	local result = sqrt(get(1))
	local source = "\|f\^:7010101418100000\|h"..str(get(1))
	cmd_drop()
	push(result, ongoing_source or source)
end


function cmd_exp(ongoing_source)
	if depth() < 1 then
		show_error("exp: need 1 number")
		return
	end
	local result = math.exp(get(1))
	local source = "exp("..str(get(1))..")"
	cmd_drop()
	push(result, ongoing_source or source)
end


function cmd_ln(ongoing_source)
	if depth() < 1 then
		show_error("ln: need 1 number")
		return
	end
	local result = math.log(get(1))
	local source = "ln("..str(get(1))..")"
	cmd_drop()
	push(result, ongoing_source or source)
end


function cmd_pow10(ongoing_source)
	if depth() < 1 then
		show_error("pow10: need 1 number")
		return
	end
	local result = 10 ^ get(1)
	local source = "pow10("..str(get(1))..")"
	cmd_drop()
	push(result, ongoing_source or source)
end


function cmd_log(ongoing_source)
	if depth() < 1 then
		show_error("log: need 1 number")
		return
	end
	local result = math.log(get(1), 10)
	local source = "log("..str(get(1))..")"
	cmd_drop()
	push(result, ongoing_source or source)
end


local function factorial(n)
	if n <= 0 then
		return 1
	end
	return n * factorial(n - 1)
end


local infinite = (1.0 / 0.0) * 10.0 -- weird...


function op_fact(ongoing_source)
	if depth() < 1 then
		show_error("!: need 1 number")
		return
	end
	local ok, result = pcall(factorial, 1.0 * get(1))
	if not ok then
		result = infinite
	end
	local source = str(get(1)).."!"
	cmd_drop()
	push(result, ongoing_source or source)
end


function cmd_pi(ongoing_source)
	local result = math.pi
	local source = "pi"
	push(result, ongoing_source or source)
end


function cmd_deg(ongoing_source)
	if depth() < 1 then
		show_error("deg: need 1 number")
		return
	end
	local result = math.deg(get(1))
	local source = "deg("..str(get(1))..")"
	cmd_drop()
	push(result, ongoing_source or source)
end


function cmd_rad(ongoing_source)
	if depth() < 1 then
		show_error("rad: need 1 number")
		return
	end
	local result = math.rad(get(1))
	local source = "rad("..str(get(1))..")"
	cmd_drop()
	push(result, ongoing_source or source)
end


function cmd_cos(ongoing_source)
	if depth() < 1 then
		show_error("cos: need 1 number")
		return
	end
	local result = math.cos(get(1))
	local source = "cos("..str(get(1))..")"
	cmd_drop()
	push(result, ongoing_source or source)
end


function cmd_sin(ongoing_source)
	if depth() < 1 then
		show_error("sin: need 1 number")
		return
	end
	local result = math.sin(get(1))
	local source = "sin("..str(get(1))..")"
	cmd_drop()
	push(result, ongoing_source or source)
end


function cmd_tan(ongoing_source)
	if depth() < 1 then
		show_error("tan: need 1 number")
		return
	end
	local result = math.tan(get(1))
	local source = "tan("..str(get(1))..")"
	cmd_drop()
	push(result, ongoing_source or source)
end


function cmd_acos(ongoing_source)
	if depth() < 1 then
		show_error("acos: need 1 number")
		return
	end
	local result = math.acos(get(1))
	local source = "acos("..str(get(1))..")"
	cmd_drop()
	push(result, ongoing_source or source)
end


function cmd_asin(ongoing_source)
	if depth() < 1 then
		show_error("asin: need 1 number")
		return
	end
	local result = math.asin(get(1))
	local source = "asin("..str(get(1))..")"
	cmd_drop()
	push(result, ongoing_source or source)
end


function cmd_atan(ongoing_source)
	if depth() < 1 then
		show_error("atan: need 1 number")
		return
	end
	local result = math.atan(get(1))
	local source = "atan("..str(get(1))..")"
	cmd_drop()
	push(result, ongoing_source or source)
end


function cmd_atan2(ongoing_source)
	if depth() < 2 then
		show_error("atan2: need 2 numbers")
		return
	end
	local result = math.atan(get(2), get(1))
	local source = "atan2("..str(get(2))..","..str(get(1))..")"
	cmd_drop()
	cmd_drop()
	push(result, ongoing_source or source)
end

:: src/config.lua
--[[pod_format="raw",created="2026-01-11 15:26:40",modified="2026-01-21 18:05:53",revision=2888]]
config = {
	big_rows = false,
	keyboard_shown = true,
	keyboard_below = true,
}


function height_row()
	return config.big_rows and 21 or 13
end

:: src/entry.lua
--[[pod_format="raw",created="2026-01-10 13:36:29",modified="2026-01-21 18:05:53",revision=4333]]
local buffer = nil
local macros = {"", "", ""}


function entry()
	return buffer
end


function entry_shown()
	return buffer ~= nil
end


function in_macro()
	return buffer and is_macro_opener(buffer[1])
end


function append(expr)
	buffer = eval((buffer or "")..expr)
	undo_stack:checkpoint()
end


function backspace()
	if buffer and #buffer > 0 then
		buffer = buffer:sub(1, #buffer - 1)
	end
end


function clear_entry()
	if in_macro() then
		buffer = buffer[1]
	elseif buffer then
		buffer = ""
	end
end


function load_macro(idx)
	if buffer and is_macro_opener(buffer[1]) then
		show_error("cannot nest macros")
		return
	end
	buffer = macro_opener(idx)..macros[idx]
end


function close_macro(idx)
	if buffer and is_macro_opener(buffer[1])
		and idx ~= macro_idx(buffer[1])
	then
		show_error("cannot nest macros")
		return
	end
	buffer = (buffer or "")..macro_closer(idx)
end


function store_macro(idx, source)
	macros[idx] = source
end


function run_macro(idx)
	eval(macros[idx].." ", true, macro_opener(idx)..macro_closer(idx))
end


function update_entry()
	local changed = false
	while peektext() do
		clear_error()
		local c = readtext()
		if is_uppercase(c) then
			pick(letter_to_index(c, "uppercase"), c)
		else
			if c == "?" then
				show_help()
			elseif is_macro_opener(c) then
				load_macro(macro_idx(c))
				changed = true
			elseif is_macro_closer(c) then
				close_macro(macro_idx(c))
				changed = true
			else
				buffer = (buffer or "") .. c
				changed = true
			end
		end
	end
	if changed then
		buffer = eval(buffer)
		undo_stack:checkpoint()
	end
		
	local plain = not key("shift") and not key("ctrl") and not key("alt")
	local shifted = key("shift") and not key("ctrl") and not key("alt")
	local ctrled = not key("shift") and key("ctrl") and not key("alt")
	local ctrl_shifted = key("shift") and key("ctrl") and not key("alt")
	
	if keyp("kp enter") then
		clear_error()
		buffer = eval((buffer or "") .. " ")
		undo_stack:checkpoint()
	end
	
	if keyp("enter") then
		clear_error()
		if plain and buffer then
			buffer = eval(buffer .. " ")
			undo_stack:checkpoint()
		elseif plain and not buffer then
			eval(" dup ")
			undo_stack:checkpoint()
		elseif shifted then
			cmd_dup()
			undo_stack:checkpoint()
		elseif ctrled then
			buffer = eval((buffer or "") .. " over ")
			undo_stack:checkpoint()
		elseif ctrl_shifted then
			cmd_over()
			undo_stack:checkpoint()
		end
	end
	
	if keyp("backspace") then
		clear_error()
		if plain and buffer then
			buffer = string.sub(buffer, 1, #buffer - 1)
		elseif ctrled and buffer then
			clear_entry()
			undo_stack:checkpoint()
		elseif plain and not buffer then
			eval(" drop ")
			undo_stack:checkpoint()
		elseif shifted then
			-- works when editing an entry
			cmd_drop()
			undo_stack:checkpoint()
		elseif ctrled and not buffer then
			eval(" dropfirst ")
			undo_stack:checkpoint()
		elseif ctrl_shifted then
			cmd_dropfirst()
			undo_stack:checkpoint()
		end
	end
	
	if keyp("del") then
		clear_error()
		if plain and buffer then
			clear_entry()
			undo_stack:checkpoint()
		elseif ctrled and buffer then
			clear_entry()
			undo_stack:checkpoint()
		elseif plain and not buffer then
			eval(" dropfirst ")
			undo_stack:checkpoint()
		elseif shifted then
			cmd_dropfirst()
			undo_stack:checkpoint()
		elseif ctrled and not buffer then
			buffer = eval((buffer or "") .. " clear ")
			undo_stack:checkpoint()
		elseif ctrl_shifted then
			cmd_clear()
			undo_stack:checkpoint()
		end
	end
	
	if keyp("tab") then
		clear_error()
		if plain then
			buffer = eval((buffer or "") .. " swap ")
			undo_stack:checkpoint()
		elseif shifted then
			cmd_swap()
			undo_stack:checkpoint()
		end
	end
	
	if keyp("pageup") then
		clear_error()
		if plain then
			buffer = eval((buffer or "") .. " roll ")
			undo_stack:checkpoint()
		elseif shifted then
			cmd_roll()
			undo_stack:checkpoint()
		end
	end
	
	if keyp("pagedown") then
		clear_error()
		if plain then
			buffer = eval((buffer or "") .. " unroll ")
			undo_stack:checkpoint()
		elseif shifted then
			cmd_roll()
			undo_stack:checkpoint()
		end
	end
end

:: src/error.lua
--[[pod_format="raw",created="2026-01-10 20:54:23",modified="2026-01-21 18:05:53",revision=3666]]
local error_msg = ""
local welcome_msg = "  stack calc\n\ntype ? for help"


function show_error(msg)
	error_msg = msg
end


function clear_error()
	error_msg = ""
	welcome_msg = ""
end


function draw_error(x0, y0, width, height)
	if welcome_msg ~= "" then
		local msg = "\014"..welcome_msg
		local w, h = print(msg, -1000, -1000)
		w += 1000; h += 1000
		w += 20; h += 14
		local x = x0 + (width - w) // 2
		local y = y0 + (height - h) // 2
		rrectfill(x + 2, y + 2, w - 1, h - 1, 0, 0)
		rrectfill(x, y, w - 1, h - 1, 0, 5)
		rrect(x + 2, y + 2, w - 5, h - 5, 0, 22)
		print(msg, x + 10, y + 7, 7)
		return
	end
	if error_msg == "" then
		return
	end
	local msg = "\014"..error_msg
	local w, h = print(msg, -1000, -1000)
	w, h = w + 1000, h + 1000
	rrectfill(x0, y0, width, h + 5, 0, 8)
	print(msg, x0 + (width - w) // 2, y0 + 3, 7)
end

:: src/help.lua
--[[pod_format="raw",created="2026-01-12 11:43:13",modified="2026-01-21 18:05:53",revision=2149]]
local help_shown = false
local help_text = ""
local help_lines = {}
local help_current_line = 1
local resize_timer = 0
local resize_needed = true
local small_font = true


function is_help_shown()
	return help_shown
end


function show_help()
	help_shown = true 
end


function hide_help()
	help_shown = false
end


local function resize_help()
	if resize_timer == 0 then
		resize_needed = true
	end
end


local function process_line(line)
	line = line:gsub("%[([^%]]+)%]", "\f6[\fg%1\f6]\fi")
--	line = line:gsub("%]", "\f6]\fi")
	line = line:gsub([["([%w-]+)"]], "\fr%1\fi")
	return line or ""
end


function init_help()
	help_text = fetch("manual.txt")
	on_event("resize", function() resize_help() end)
	resize_help()
end


function update_help()
	if resize_timer > 0 then
		resize_timer -= 1
	elseif resize_needed then
		local width = get_display():width() - 2
		small_font = width < 160
		help_lines = soft_wrap(help_text, width, small_font, process_line)
		resize_timer = 15
	end
	
	while peektext() do
		local c = readtext()
		if c == "?" then
			hide_help()
		end
	end
	
	local _mx, _my, _mb, _wheel_x, wheel_y = mouse()
	if wheel_y ~= 0 then
		local nb_lines = get_display():height() // (small_font and 6 or 11)
		help_current_line = mid(
			1,
			help_current_line - (wheel_y * 3),	
			#help_lines - nb_lines + 1
		)
	end
	
	local _mx, _my, mb, _, _ = mouse()
	if mb ~= 0 or keyp("?") or keyp("enter") or keyp("space") then
		hide_help()
	end
end


function draw_help(x, y, w, h)
	local h_window = get_display():height()
	local w_window = get_display():width()
	cls(7)
	cursor(2, 2)
	color(18)
	local l = help_current_line
	local y = 0
	while y < h_window and l <= #help_lines do
		if small_font then
			print("\014"..string.lower(help_lines[l]))
			y += 6
		else
			print(help_lines[l])
			y += 11
		end
		l += 1
	end
end

:: src/keyboard.lua
--[[pod_format="raw",created="2026-01-13 12:59:02",modified="2026-01-21 18:05:53",revision=1417]]
local kbd = {
	-- First row
	{
		{ sprite = 0, expr = function() if entry_shown() then clear_entry() else append(" clear ") end end, },
		{ sprite = 1, expr = function() undo_stack:undo() end, },
		{ sprite = 2, expr = function() undo_stack:redo() end, },
		{ sprite = 3, expr = "", },
		{ sprite = 4, expr = "", },
		{ sprite = 5, expr = "", },
	},
	-- Second row
	{
		{ sprite = 8, expr = function() if entry_shown() then backspace() else append(" drop ") end end, },
		{ sprite = 9, expr = "!", },
		{ sprite = 10, expr = " exp ", },
		{ sprite = 11, expr = " ln ", },
		{ sprite = 12, expr = " pow10 ", },
		{ sprite = 13, expr = " log ", },
	},
	-- Third row
	{
		{ sprite = 16, expr = "" },
		{ sprite = 17, expr = function() load_macro(1) end, },
		{ sprite = 18, expr = ")", },
		{ sprite = 19, expr = " inv ", },
		{ sprite = 20, expr = "^", },
		{ sprite = 21, expr = " root ", },
	},
	-- Fourth row
	{
		{ sprite = 24, expr = "", },
		{ sprite = 25, expr = "7", },
		{ sprite = 26, expr = "8", },
		{ sprite = 27, expr = "9", },
		{ sprite = 28, expr = " sq ", },
		{ sprite = 29, expr = " sqrt ", },
	},
	-- Fifth row
	{
		{ sprite = 32, expr = " roll ", },
		{ sprite = 33, expr = "4", },
		{ sprite = 34, expr = "5", },
		{ sprite = 35, expr = "6", },
		{ sprite = 36, expr = "*", },
		{ sprite = 37, expr = "/", },
	},
	-- Sixth row
	{
		{ sprite = 40, expr = " unroll ", },
		{ sprite = 41, expr = "1", },
		{ sprite = 42, expr = "2", },
		{ sprite = 43, expr = "3", },
		{ sprite = 44, expr = "+", },
		{ sprite = 45, expr = "-", },
	},
	-- Sixth row
	{
		{ sprite = 48, expr = " swap ", },
		{ sprite = 49, expr = "0", },
		{ sprite = 50, expr = ".", },
		{ sprite = 51, expr = " ~ ", },
		{ sprite = 52, expr = function() if entry_shown() then append(" ") else append(" dup ") end end, },
		nil,
	},
}


local kbd_state = {}
for j = 1, 7 do
	add(kbd_state, {})
	for i = 1, 6 do
		add(kbd_state[j], false)
	end
end


function update_keyboard(x, y, width, height)
	local mx, my, mb, wheel_x, wheel_y = mouse()
	mx -= x; my -= y
	if mx >= 0 and mx <= width and my >= 0 and my <= height then
		window { cursor = "pointer" }
	end
	if mb == 1 then
		local i, j = 1 + (mx // 21), 1 + (my // 15)
		if i == 6 and j == 7 then i = 5 end
		local key = kbd[j] and kbd[j][i]
		if key then
			if not kbd_state[j][i] then
				clear_error()
				kbd_state[j][i] = true
				if type(key.expr) == "string" then
					append(key.expr)
				elseif type(key.expr) == "function" then
					key.expr()
				end
			end
		end
	else
		for i = 1, 6 do
			for j = 1, 7 do
				kbd_state[j][i] = false
			end
		end
	end
end


function draw_keyboard(x, y, width, height)
	camera(-x, -y)
	rrectfill(0, 0, width, height, 0, 13)
	for i = 0, 5 do
		for j = 0, 6 do
			local x_key = 4 + i * 21--24
			local y_key = 4 + j * 15
			local key = kbd[j + 1][i + 1]
			if key ~= nil then
				local sprite = key.sprite
				if kbd_state[j + 1][i + 1] then
					sprite += 64
				end
				spr(sprite, x_key, y_key)
			end
--			rrectfill(x_key, y_key, 17, 11, 1, 6)
--			print("8", x_key + 6, y_key + 2, 0)
		end
	end
	camera()
end

:: src/parser.lua
--[[pod_format="raw",created="2026-01-10 14:19:08",modified="2026-01-21 18:05:53",revision=4285]]
local op_funcs = {
	["+"] = op_plus,
	["-"] = op_minus,
	["~"] = op_negated,
	["*"] = op_times,
	["/"] = op_slash,
	["\\"] = op_backslash,
	["%"] = op_mod,
	["^"] = op_pow,
	["&"] = cmd_inv,
	["@"] = cmd_sq,
	["$"] = cmd_sqrt,
	["!"] = op_fact,
}


local cmd_funcs = {
	["drop"] = cmd_drop,
	["dropfirst"] = cmd_dropfirst,
	["clear"] = cmd_clear,
	["dup"] = cmd_dup,
	["over"] = cmd_over,
	["swap"] = cmd_swap,
	["roll"] = cmd_roll,
	["unroll"] = cmd_unroll,
	["neg"] = cmd_neg,
	["inv"] = cmd_inv,
	["root"] = cmd_root,
	["sq"] = cmd_sq,
	["sqrt"] = cmd_sqrt,
	["exp"] = cmd_exp,
	["ln"] = cmd_ln,
	["pow10"] = cmd_pow10,
	["log"] = cmd_log,
	["fact"] = op_fact,
	["pi"] = cmd_pi,
	["deg"] = cmd_deg,
	["rad"] = cmd_rad,
	["cos"] = cmd_cos,
	["sin"] = cmd_sin,
	["tan"] = cmd_tan,
	["acos"] = cmd_acos,
	["asin"] = cmd_asin,
	["atan"] = cmd_atan,
	["atan2"] = cmd_atan2,
}


function eval(buffer, complete, ongoing_source)
	local maybe_more = true
	while #buffer > 0 and maybe_more do
		maybe_more = false
		local c = buffer[1]
		local op_func = op_funcs[c]
		if is_digit(c) then
			buffer, maybe_more = eval_number(buffer, complete, ongoing_source)
		elseif is_space(c) then
			buffer, maybe_more = string.sub(buffer, 2), true
		elseif op_func then
			op_func(ongoing_source)
			buffer, maybe_more = string.sub(buffer, 2), true
		elseif is_lowercase(c) then
			buffer, maybe_more = eval_identifier(buffer, complete, ongoing_source)
		elseif is_macro_opener(c) then
			buffer, maybe_more = eval_macro(buffer, complete, ongoing_source)
		elseif is_macro_closer(c) then
			run_macro(macro_idx(c))
			buffer, maybe_more = string.sub(buffer, 2), true
		else
			show_error("unknown character: "..c)
			buffer, maybe_more = string.sub(buffer, 2), true
		end
	end
	if buffer == "" then
		buffer = nil
	end
	return buffer
end


function eval_number(buffer, complete, ongoing_source)
	local pos = 1
	while is_lowalphanum(buffer[pos]) do
		pos += 1
	end
	if pos > 1 and (pos - 1 < #buffer) then
		local number = tonumber(string.sub(buffer, 1, pos - 1))
		if not number then
			show_error([[invalid number: "]]..string.sub(buffer, 1, pos - 1)..[["]])
			return buffer, false
		end
		push(number)
		return string.sub(buffer, pos), true
	end
	return buffer, false
end


function eval_identifier(buffer, complete, ongoing_source)
	local pos = 1
	while is_lowalphanum(buffer[pos]) do
		pos += 1
	end
	if pos > 1 and (pos - 1 < #buffer) then
		local identifier = string.sub(buffer, 1, pos - 1)
		if #identifier == 1 then
			pick(letter_to_index(identifier, "lowercase"), identifier)
		else
			local cmd_func = cmd_funcs[identifier]
			if cmd_func then
				cmd_func(ongoing_source)
			else
				show_error([[unknown command: "]]..identifier..[["]])
			end
		end
		return string.sub(buffer, pos), true
	end
	return buffer, false
end


function eval_macro(buffer, complete, ongoing_source)
	local idx = macro_idx(buffer[1])
	if buffer[#buffer] == macro_closer(idx) then
		local macro = string.sub(buffer, 2, #buffer - 1)
		store_macro(idx, macro)
		run_macro(idx)
		return "", false
	end
	return buffer, false
end


-------------------------------------------------------------------------------------------------


function is_space(char)
	if not char then return false end
	return char == " "
end


function is_digit(char)
	if not char then return false end
	return (char >= "0" and char <= "9") or char == "."
end


function is_uppercase(char)
	if not char then return false end
	return char >= "A" and char <= "Z"
end


function is_lowercase(char)
	if not char then return false end
	return char >= "a" and char <= "z"
end


function is_lowalphanum(char)
	return is_digit(char) or is_lowercase(char)
end


function is_macro_opener(char)
	return char == "(" or char == "[" or char == "{"
end


function is_macro_closer(char)
	return char == ")" or char == "]" or char == "}"
end


local _macro_idx = { ["("] = 1, [")"] = 1, ["["] = 2, ["]"] = 2, ["{"] = 3, ["}"] = 3 }
function macro_idx(char)
	return _macro_idx[char]
end


local _macro_openers = { "(", "[", "{" }
function macro_opener(idx)
	return _macro_openers[idx]
end


local _macro_closers = { ")", "]", "}" }
function macro_closer(idx)
	return _macro_closers[idx]
end

:: src/soft_wrap.lua
--[[pod_format="raw",created="2025-03-07 11:09:14",modified="2026-01-21 18:05:53",revision=2820]]
-- Soft-wraps a very tiny subset of markdown.
function soft_wrap(text, width, with_small_font, transform)
	local function prefix(s) if with_small_font then return "\014"..s else return s end end
	local space_width <const> = print(prefix(" "), -1000, -1000) + 1000
	local lines = {}
	local context = "default" -- "default", "paragraph", "list" or "code"
	local x = 0
	
	local function add_line_break()
		if #lines == 0 then
			return
		end
		if lines[#lines] ~= "" then
			add(lines, "")
		end
		x = 0
	end
	
	local function add_paragraph_break()
		if #lines == 0 then
			return
		end
		if lines[#lines] ~= "" then
			add(lines, "")
			add(lines, "")
		elseif #lines > 1 and lines[#lines - 1] ~= "" then
			add(lines, "")
		end
		x = 0
	end
	
	local function add_line(line)
		if lines[#lines] == "" then
			lines[#lines] = line
		elseif context == "code" and line == "" then
			add(lines, " ")
		else
			add(lines, line)
		end
		x = 0
	end

	local function add_word(word)
		local word = transform and transform(word) or word
		local dx = print(prefix(word), -1000, -1000) + 1000
		if lines[#lines] == "" then
			lines[#lines] = word
			x += dx
		elseif x + space_width + dx >= width then
			-- Start a new line
			add(lines, "")
			x = 0
			if context == "list" then
				lines[#lines] ..= "  "
				x += 2 * space_width
			end
			lines[#lines] ..= word
			x += dx
		else
			lines[#lines] ..= " " .. word
			x += space_width + dx
		end
	end
	
	for source_line in text:gmatch("([^\n]*)\n") do
		if context == "code" then
			if source_line:find("^```") then
				context = "default"
				indentation = 0
				add_paragraph_break()
			else
				source_line = transform and transform(source_line) or source_line
				add_line(source_line)
			end
			goto next_line
		end
		if source_line:find("^```") then
			context = "code"
			goto next_line
		end
		if source_line:find("^#+") then
			add_paragraph_break()
			add_line(source_line)
			add_paragraph_break()
			context = "default"
			goto next_line
		end
		if source_line:find("^%s*$") then
			add_paragraph_break()
			context = "default"
			goto next_line
		end
		if source_line:find("^%s*-") then
			add_line_break()
			context = "list"
		end
		for word in source_line:gmatch("[^%s]+") do
			add_word(word)
		end
		::next_line::
	end
	
	return lines
end

:: src/stack.lua
--[[pod_format="raw",created="2026-01-10 18:50:54",modified="2026-01-21 18:05:53",revision=3879]]
local stack = { }


function get_stack_state()
	return stack
end


function set_stack_state(stack_state)
	stack = stack_state
end


function depth()
	return #stack
end


function index_to_letter(idx, uppercase)
	if (#stack - idx) >= 26 then return "?" end
	local base = (uppercase == "uppercase") and "A" or "a"
	return string.char((#stack - idx) + string.byte(base))
end


function letter_to_index(char, uppercase)
	local base = (uppercase == "uppercase") and "A" or "a"
	local result = #stack - (string.byte(char) - string.byte(base))
	if result < 1 then
		return nil -- TODO: something safer?
	end
	return result
end


function get_item(index)
	local item = stack[#stack - (index - 1)]
	return item
end


function get(index)
	local item = get_item(index)
	return item and item.value or nil
end


function push_item(item)
	if not item or type(item) ~= "table" then
		return
	end
	add(stack, item)
end


function push(number, source)
	if not number or type(number) ~= "number" then
		return
	end
	add(stack, { value = number, source = source or "" })
end


-----------------------------------------------------------------------------------
-- Interactive Stack Manipulation
-----------------------------------------------------------------------------------


function pick(index, letter)
	if (not index) or (index > #stack) then
		show_error("pick: nothing on "..string.lower(letter))
		return
	end
	local value = get(index)
	if value then
		push(value)
	end
end


-----------------------------------------------------------------------------------
-- Commands
-----------------------------------------------------------------------------------


function cmd_drop(_ongoing_source)
	if #stack < 1 then
		show_error("drop: nothing on the stack")
		return
	end
	_ = deli(stack)
end


function cmd_dropfirst(_ongoing_source)
	if #stack < 1 then
		show_error("dropfirst: nothing on the stack")
		return
	end
	_ = deli(stack, 1)
end


function cmd_clear(_ongoing_source)
	if #stack < 1 then
		show_error("clear: nothing on the stack")
		return
	end
	stack = {}
end


function cmd_dup(ongoing_source)
	if #stack < 1 then
		show_error("dup: nothing on the stack")
		return
	end
	local value = get(1)
	if value then
		push(value, ongoing_source or "dup")
	end
end


function cmd_over(ongoing_source)
	if #stack < 2 then
		show_error("over: need 2 values")
		return
	end
	local value = get(2)
	if value then
		push(value, ongoing_source or "over")
	end
end


function cmd_swap(_ongoing_source)
	if #stack < 2 then
		show_error("swap: need 2 values")
		return
	end
	stack[#stack - 0], stack[#stack - 1] =
		stack[#stack - 1], stack[#stack - 0]
end


function cmd_roll(_ongoing_source)
	if #stack < 1 then
		show_error("roll: nothing on the stack")
		return
	end
	local far_item = deli(stack, 1)
	add(stack, far_item)
end


function cmd_unroll(_ongoing_source)
	if #stack < 1 then
		show_error("unroll: nothing on the stack")
		return
	end
	local bottom_item = deli(stack)
	add(stack, bottom_item, 1)
end

:: src/state.lua
--[[pod_format="raw",created="2026-01-12 10:16:01",modified="2026-01-21 18:05:53",revision=2276]]
undo_stack = nil


function init_undo_stack()
	undo_stack = create_undo_stack(
		function()
			local state = {
				stack = get_stack_state(),
			}
			return state
		end,
		function(state)
			if type(state) == "table" then
				if state.stack then
					set_stack_state(state.stack)
				end
			end
		end
	)
end

:: todo.txt
--[[pod_format="raw",created="2026-01-11 17:05:04",modified="2026-01-21 18:05:53",revision=2760]]
- add: interactive drop, swap, and roll
- add: right-click menu on stack rows
- add: left-click on stack rows to pick
- add: scrolling the stack
- add: help screen
- add: manual
- add: macros for keys `)` `]` `}`
- add: up/down to limit stack depth?
:: .info.pod
--[[pod,author="drakmaniso",created="2025-11-13 21:07:43",icon=userdata("u8",16,16,"000000010101010101010101010000000000010707070707070707070701000000010712121212121212121212070100010712121201010101010112121207010107121212011c1c1c1c01121212070101071212120101010101011212120701010712121201010101010112121207010107121212010d010d01011212120701010712121201010101010112121207010107121212010d01180101121212070101071212120101010101011212120701011d0712121212121212121212071d01011d1d070707070707070707071d1d0100011d1d1d1d1d1d1d1d1d1d1d1d01000000011d1d1d1d1d1d1d1d1d1d01000000000001010101010101010101000000"),modified="2026-01-21 18:05:53",notes="Calculator with postfix notation\n(aka RPN).",runtime=24,title="Stack-Calc",version="0.2",workspaces={{location="main.lua",workspace_index=1},{location="gfx/0.gfx#63",workspace_index=2},{location="map/0.map",workspace_index=3},{location="sfx/0.sfx",workspace_index=4}}]]
:: doc/.info.pod
--[[pod,created="2026-01-10 13:20:37",modified="2026-01-21 18:05:53"]]
:: doc/rcalc.md
b64$LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNi0wMS0xMCAxMjo0MTo0OCIsbW9k
aWZpZWQ9IjIwMjYtMDEtMjEgMTg6MDU6NTMiLHJldmlzaW9uPTQzNzZdXQpSUE4gY2FsY3VsYXRv
cgoKRGVzaWduOiBzYW1lIGtleSBzZXF1ZW5jZSBmb3IgaW50ZXJhY3RpdmUgdXNlIGFuZCBleHBy
ZXNzaW9ucy4gSS5lLiB1c2UgZW50ZXIKYmV0d2VlbiBlbnRyaWVzIGZvciBzdGVwIGJ5IHN0ZXAg
ZGlzcGxheSwgb3Igc3BhY2UgZm9yIGNhbGN1bGF0aW5nIGFuIGV4cHJlc3Npb24KaW4gYSBzaW5n
bGUgZ28uCgpObyBvbi1zY3JlZW4ga2V5Ym9hcmQ6IHVzZSB0aGUgY29tcHV0ZXIncyBrZXlib2Fy
ZC4KCkRpc3BsYXkgdGhlIHN0YWNrLCBhcyB3ZWxsIGFzIGFueSB1c2VyLWRlZmluZWQgdmFyaWFi
bGVzIGFuZCBmdW5jdGlvbnMuCgpPbmUga2V5IG9wZXJhdGlvbnM6ICsgLSB_KG5lZ2F0aW9uKSAq
IC8gXiAlIFwgIQoKSW1tZWRpYXRlIHN0YWNrIG1hbmlwdWxhdGlvbjoKCi0gYGR1cGA6IFBnRG93
bgotIGBvdmVyYCwgYHBpY2tgOiBob2xkIFNoaWZ0ICsgaGl0IFBhZ2VEb3duIG11bHRpcGxlIHRp
bWVzCi0gYGRyb3BgOiBQZ1VwCi0gYGRyb3BuYDogaG9sZCBTaGlmdCArIGhpdCBQYWdlVXAgbXVs
dGlwbGUgdGltZXMKLSBgc3dhcGA6IFRhYgotIGByb3RgOiBTaGlmdCtUYWIKLSBlZGl0IEE6IElu
c2VydAotID8-PzogU2hpZnQrSW5zZXJ0CgpJbnRlcmFjdGl2ZSBwaWNrOiBzaGlmdCArIHN0YWNr
IGxldHRlcgoKQXNzaWduIHZhcmlhYmxlOiAiOiIgKyBsb3dlcmNhc2UgaWRlbnRpZmllcgoKRnVu
Y3Rpb24gY2FsbDogc3RhcnRzIHdpdGggYSBsb3dlcmNhc2UgbGV0dGVyLgoKVmFyaWFibGUgYW5k
IGZ1bmN0aW9uIGRlZmluaXRpb246IGxvd2VyY2FzZSB3b3JkLCB0aGVuICI9IiwgdGhlbiBleHBy
ZXNzaW9uLAp0aGVuIGVudGVyLiBFeHByZXNzaW9uIGlzIGEgc2VxdWVuY2Ugb2YgbnVtYmVycywg
b3BlcmF0aW9ucywgbG93ZXJjYXNlIHdvcmRzIGFuZAp1cHBlcmNhc2UgbGV0dGVycyBzZXBhcmF0
ZWQgYnkgc3BhY2Uu
:: gfx/.info.pod
--[[pod,created="2025-11-13 21:07:43",modified="2026-01-21 18:05:53"]]
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAxLTE3IDEwOjM1OjQ4Iixtb2RpZmllZD0iMjAyNi0w
MS0xNCAxMzozOToxMCIscmV2aXNpb249MTQ3XV1sejQAZAoAAINAAADxF3tbMF09e2JtcD1weHUA
QyARDAQA7xgA-hYXDgcuJ14HLgcuBw4HCAAjF24OAPMQbhcOJw4HDgf_FQ8S7g0A7QAsZmxhZ3M9
MCxwYW5feAgAy3k9MCx6b29tPTd9LGEA-wjiAPIoBxInojcSB5In0jfyGg8S4g4A7kgAIe8pJxIH
kgcSN9InwjfyF0gAJx_JOwCd8ggWFwInAidSBzIHEgcCB1InEgcSJ3IHEg4AIRciCAAv8hVgACdx
FScCFxInYkgAlhIHcgcSFyIHcg4AXwcCBwInYAAmAGIC-wIIB_4X3nd_h453nhf_AAf_Ck0CJPEH
7xQA-gwH-gAHnhcOFw4HvgcuB74H3gwAL-4XVAAosAoXDhfeB44nPgd_9gLPFw4XXke_B-4BJ-4L
VgAoEBaqAJI_J44HPgceB34GAH83DgceB-4WrAAuUH4HDicungMiBw6wAAAIACQHvgYAHydjASpx
FQc_Fx4XXgEEOw4HfggAjw4HXicOFx4nEwQlL-C8QwIhQBUXHieEAACAABIuCAAmFx4QAAAeAA_S
ACaPAOEA8YkPEuHfAiKAFAD_CQfuB_7tAQADABEBAwAfCX8BKBQJRQABUQABWwAPTwApYAUHLgeu
FyoDUR4HzgceLwIQnhQAvwc_B64HHhcOF-4EkAIwMR4HPgYAER6OAq8eB94n-gAHzieuWwAosAQH
Dgc_R14HTgeeWQAB7AEzTgcOCgBCDgeuF_8CEB5VBD-eFy6QAlXxC_EA8RUnERcBJ1EHAQcBByEn
UScBByEHAQdRBgASAQoAECcIAC7xFVgCD5MCTfIB5gD2B08-9gAO9gAO5g7mDgoAX-YJDxLmigEh
9gHmAPYILz-GDiYOtg4mDsYuCgAv9ghTADMRPqkAL9YeowAmAC0CgAwX-gEH7geODgYxJ54HEgJP
Dhf_CIACKDUYd44yAwBqBARIAwAQAC-_BW4CVQEBCDASFwLtByAHIo0HDwoAATIXchcQAA8aCSmv
GgfiJ8JHomeSZ0YAJvID5gD2Cg8-5h7WDgYOxg4WDsZOgQIPKwIooQdPP7YO9gA_9gFKAE8ADrY_
TwApQQkfP9YWAx8_ygIwse8TAP4YBy4HzgcOqgWPDgfOBy4H-hh2AiXfEwD_Ggf_D0f_Dwf_GkUA
IF8QEATw8DEACxk4MQBvJgwE8P_5MgAZAywCrhdnkmeiR8In4gfUCw9GABQAjQEELAIj9gADAE7W
TvYHjQEPUAAVA1cEA-oEP_YO5k4ANE7WHvYBLAIPUQAbA90BUAAH3kfeBwAO4QEPSQAYTzpH-jo-
ABMOIAIPMQA8D0sEApAERxIHggdCF4JGDEFHYgcCwwQgYkdODK6CF0IHggciN-IFOQIPmwEc37YO
Fh62DgYOBg62HhahAS1_5gD2XR8-5ogGD9ECGwHFAhDWNgIv9g9-AiOwJgwEAP8ZFAD_QTd2BnAO
Rw43Dje_lgsBlw8QPooGEicGCVAuBy4nHhwANQceFxwAATYAMS4HLggAr-5CDxL_FA0A-RSEACOx
QicONy4nLicOR65eABEOBADAPgf_ABceNx5HDgc_6gkAmgkCGAAx7iceDABOHicOR3wAD5UEGA-Y
AkoOiwcPMQD-Ag9XAR6RCAgEAFcQBzAHBABnVxAHABcACAAPBgIMHTGuAPEEAu8VAP4WFg4GLiZe
Bi4GLgYOBggAIxZuDgBAbhYOJgAEL-4VSAQOLzEwXwAD7ygGHiauNh4GnibeNv4aRwAm7ykmHgae
Bh423ibONv4XRwAmH4k6AJEOGAIPSQI9BZwA-gIIBu4W3nZ_ho52nhb_AAb_CqwAD5AGDQJJAA85
EgYPUQAlDzYSCA9TACUPMxIID6YAKw8wEg0PVwEnDy0SFQ9gAA8PYgJiHj-_Ag85ABMAWwFxBu4G
7gb_AAMAEQEDAB8ITAAlFAhCAAFOAAFYAB8KTAAl8AYFBi4GrhYuBr4GHgbOBh4GDhYOFp4UAL8G
PgauBh4WDhb_BFwAJbEKFg4W3gZ_Bh4GPgYAAE4Az14GHgbeJv4ABs4mrlgAJZAVBg4GPkZeBk5E
BQC0AGMGDgZOBg4KAN4OBq4WHha_Bi4G3hYuYwAPGQJEYhUnHhcOJysDVS4nXicOIRkD2wIjBy4d
GQ7dAg97AkjyAeUA9QdPP-UADvUADuUO5Q4KAE-1CQDlTAAi1ggvP8UOJQ61DiUOxS4KAC-1CFAA
MBE_owAv1R6dACMAGALgDBb_AQbuBo4WDhYOJp4cAxDewAIPaAMmNRh2jhQDNX4GDioDABAALv4F
VgAPgQlsBbgArhoG7ibORq5mnmaxBg_ZARTyAAoPP_Ue1Q4FDsUOFQ7FTjkCD_YBJaEHTz_1DvUA
PvUBRwBPAA61PkwAJkEJHz-VyAIfPn8CLQHiAWEGLgbOBg5EBY4OBs4GLgb_GDIBD3YBFY-_D0b_
Dwb_GnUEIQ_mBFDOFQD_F2aeZq5GzibupgAPgQEWBBoCI-UAAwBP1U71BwAEKwOdBD-lDuVLADFP
1R71ARoCLhEaPwQgRt4HAA8sASMARgBPOkb_OigEIQ8OAlOQBEYeBo4GThaOPAewRm4GDhYeFg4G
bkZIB46OFk4GjgYuNugED9sFHb8VHrUOBQ4FDrUeFZYBKn-lAPVdHz-lIAYkAroCAa4CENUlAi-1
D2sCHwBrED8X-xVsETY-AP4UgAAhD2gRLi8A-mMRggk2AlQlDrVOtQoAANgDDxgEJSYHP1IABTQG
DoEGD9gCHwUABQ-TAipABy8-1WMHBJkAAjMDAFIAHwluBytCDvUALuoCHgBVBQ9MAB8iPsUIAD4O
9QtMAA8MAg8PPQJOH7zMIiNrJwIXYgcCICMWUhIAACIADzIjLLEDxzIHIgciBxIXMn0bYAIXAgcP
FKEjECcLACYOBxcAIg4HKwABCgBux-IDDxLiDxYP2wATYRcSJxIXUuYbAKEjAGIAAKEjAxAAAR4A
D9UALVISFyIXEr4AEAd1JAIKAEgSFwInFAADJgACzgAPbgAkEhVOAAObAQDCAAGbAUYXIgdiEAAF
JAAPrQEtBFIAFgLcAAEMABEisgEKFAAHLAAP4gAmL-C8MQBNAG0YQAcvP9ZkHQPIHAIEABAWAxkP
Sh8lBm8dQg72AC7FGB4AxRgPTwAiIj7GCAA-DvYL6B8oEBVQEiEXbpEHBWISBAoAAwgACQwAHxdv
JSofiTwAIy-wvDEAfgk2G0ImDrZOLwICBAAP4gEqFj9VAAVUHw_kHysFqAADMQIeANkbD80hHgEX
IgIUAgEIACQXrg4APxceB0EoLBAVliQFLBICAgASbqgkLBdulQICbwAOPicPKAJ14uEA8QPHMQch
FxEHIQcx0SQQJwoAMSEHAdUkEzEIAAQMAAL1JE8xx-EDsiQjL-C8MQB_AdYBUxkHHge_BAAT3gQA
L-4YJwIoFxhJAARZAC-_GQkCJQ8xAP9xDtcKD3cNMQ-FAB4PWAHhDzEAXQ-EABAfODEA7w5XAQ8x
AP------------------A1BtPTh9fQ==
:: label.qoi
b64$cW9pZgAAAeAAAAEOBAH_--Ho-f39-f39-f39-f39-f394f6iiHnEP-39-f39-c8SwT-AEsE-
yxLBP8gSxD-G-rkAPsY-yf6iiHk-Ej-NEsU--f39-f38EsE-wBLBP8YSwT-AEsE-xhLCPxLBP8gS
P8ISP8b_uQA_xj-K-qKIeT-SEj8SP-39-f39-BLAP8ISwD-GEsE-wBLBP8YSwj8SwT-IEj-CEj-G
-rkAPsY-xv6iiHnHP8oSwT8SwT-9-f39-fwSwD-CEsA-xhLGP8YSwj-MEj-CEj-G-rkAPsY-xv6i
iHnAP8MSwD-KEj8SP-39-f39-cISwD-CEsA-xhI-EsI-Ej-GEsU-yRI-wBLBP9YSwD-DEsA-yhLF
P-39-f39-BLAP8ISwD-GEj8Swj8SP8YSxT-HEsE-wBLBP8b_uQA_xj-G-qKIecA-wxLAP8sSxD-9
-f39-fwSwT-AEsE-xhLGP8YSxT-HEsE-y-65AD7AP8ISwD-G-qKIecc--f39-f39-f39-f39-f39
4-69mt-9-f39-f39-f39-f39-f39-f39-f39-f39-f39-f39-f39-f39-f39-f39-f39-f39-f39
-f39-f39-f39-f39-f39-f39-f39-f39-f39-f39-fL_RS0yxAf9-f3w-h0rU-39wgf97QP_-6zF
wT-BAwfpA8oH-f31KDH9-cIoB-3lA8UxwT-CAwfoAz-KAwf9-fMoMf39xCgH-eMDP8wDB_cDP8wD
B-398igx6wPAMcEDMcsDMcgDwDHFA8Ax6igH-eMDP8wDB_cDP8wDB8X_ZUaIxwf9-eIoMcT_fiVT
xTHdAzHAAzHAAzHLAzHHAzHAAzHFAzHjLcExwigH-eMDP8wDB_cDP8wDB8M6wQfFOsEH-f3gKDHq
AzHCA8IxwAPAMcEDwTEDMcADMcQDMcMDwDHBAzHBA8Ex3C0xwS0xwSgH-eMDP8wDB_cDP8wDB8E6
wQf9-ewoMcQtxTHeA8AxwQMxxAMxAzHCAzEDMcUDMcUDMcADMcADMd8tMcEtMcEoB-3jAz-MAwfn
Az-MAzrCB-397igx7QMxwAMxwgPBMQMxwgPAMcYDMcMDwTHAAzHAAzHfLTHBLTHBKAf94wM-w-7-
d6jBPx0-wgMH5wM-zAMH-f3yKDHELcUx3QMxwAMxwAMxwQMxwAMxAzHCAzEDMcUDMcADMQMxwAMx
wAMxwAMx4C3BMcIoB-3jAz-CHT-BHcA-wgMH5wM-zAMH-f3yKDHrA8AxwgPAMcADwTHAA8ExAzHA
AzHFA8AxwQPBMcADwDHAA8Ex5CgH-eMDP8UdwT-CAwfnAzE-yjEDB-398igx-f3EKAf94wM-zAMH
5wMxzAMH-f3yKDH9-cQoB-3jAz-MAwfnAzHAHcAxyAMH-f3yKP39xgf94wM-zAMH5jrAAzHKAwf9
-fMo-oN2nP39xCgH-eQDzAfnOgfAA8oH-f30KBDE-l9XT-32EMQoB-393DrAB-39-cQoEMIuwP4A
h1H98f4SU1kPwi7AEMIoB-392zrAB-39-cUoEMEuD-3zOQ-E-sLDxxDBKAf9-ds6B-39-cYoEMAu
-gCyUf30OSbFOxDAKAf9-do6wAf9-f3GKBDALib99DkmxTsQwCgH-dw-2wfdOgf9-f3HKBAuJv31
OSbGOxAoB-3bP90H3DoHwT-MB-399CgQLib99TkmxjsQKAf92z-dB9w6B8A-zgf9-fMoEC4m-fU5
JsY7ECgH-ds-3QfaOsEHwD-OB-398ygQLib99TkmxjsQKAf92z-FEMA-1AfZOsAHwj-OB-398ygQ
Lib99TkmxjsQKAf92z-EED-AED-TB9g6wAfDP84H-f3zKBAuJv31OSbGOxAoB-3bP8QQP8AQPxDB
P8AQwT-BEME-xAfWOsEHxD-OB-398ygQLib99TkmxjsQKAf92z-EEMI-ED-AED8QP8AQPxA-xwfV
OsAHxj-OB-398ygQLib99TkmxjsQKAf92z-EED-AED8QP8AQPxA-wBA-wBDAP8UH1DrAB8c-zgf9
-fMoEC4m-fU5JsY7ECgH-ds-xBA-wBA-EME-wBDBP8MQP8QH1DoHyD-OB-398ygQLib99TkmxjsQ
KAf92z-EED-AED8QP8IQP8IQwT-FB9Q6B8g-zgf9-fMoEC4m-fU5JsY7ECgH-ds-yRA-whA-zAfU
OgfIP84H-f3zKBAuD-31OQ-GOxAoB-3bP90H1DoHyD-OB-398ygQLg-99TkPxjsQKAf92z-dB9Q6
wAfHP84H-f3zKBAuD-31OQ-GOxAoB-3cP9sH1jrAB8Y-zgf9-fMoEC4P-fU5D8Y7ECgH-f3UOsAH
xj-MB-399CgQLg-99TkPxjsQKAf9-dQ6B-39-c0oEC4P-fU5D8Y7ECgH-f3UOsAH-f39zCgQLg-9
9TkPxjsQKAf9-dU6wgf9-f3JKBAuD-31OQ-GOxAoB-391ToH-f39zCgQLg-99TkPxjsQKAf9-cI6
xQfJOsAH-f39zCgQLg-99TkPxjsQKAf9-cA6wQfDOsAHyDoH-f39zSgQLg-99TkPxjsQKAf9_APE
OgfGOgfIOsAH-f39zCgQLg-99TkPxjsQKAf99wMdwTHBAwfGOsAHyDoH-f39zCgQLg-99TkPxjsQ
KAf98APFHcExwgMHxzoHyDoH-f39zCgQLib99TkmxjsQKAf97wMxzAMHxjrAB8c6wAf9-f3MKBAu
Jv31OSbGOxAoB-3vAzHMAwfHOsEHxToH-f39zSgQLib99TkmxjsQKAf97wMxzAMHyToHxToH-f39
zSgQLib99TkmxjsQKAf97wMxzAMHyTrAB8M6wAf9-f3NKBAuJv31OSbGOxAoB-3vAzHMAwfKOgfD
Ogf9-f3OKBAuJv31OSbGOxAoB-o6xQfAOsIH5AMxzAMHyjrAB8E6wAf9-f3OKBAuJv31OSbGOxAo
B-g6wQfBOgc6wgfAOgfkAzHMAwfLOsMH-f39zygQLib99TkmxjsQKAf3OsAHwzoHwDoHwjoH5AMx
zAMH-f394SgQLib99TkmxjsQKAf3OgfLOsEH4wMxzAMH-f394SgQLib99TkmxjsQKAf2OsAHyzoH
OgfjAzHMAwf9-f3hKBAuJv31OSbGOxAoB-Q6wQfOOsAH4gMxzAMH-f394SgQLib99TkmxjsQKAfz
OsAHOgfPOgfjA8wH-f394igQLib99TkmxjsQKAfzOgfSOgfrOgf9-f3nKBAuD-31OQ-GOxAoB-I6
wAfSOsAHwjrDB_E6B-39-ecoEC4P-fU5D8Y7ECgH8joH1DoHwDrBB8E6wAfeOsIH-f395igQLg-9
9TkPxjsQKAfyOgfUOsIHxDrAB9Y6wgfAOsAH6wPEB-399CgQLg-99TkPxjsQKAfyOgfTOsAHyDoH
xT-vB9IDMcE-wQMH-f3zKBAuD-31OQ-GOxAoB-I6wAfSOgfIOsAHxD-xB8oDxTHBP8IDB-398ygQ
Lg-99TkPxjsQKAfTOsUH1zoH3TrAB8Q-8QfJAz-MAwf9-fMoEC4P-fU5D8Y7ECgHzjrEB8E6wwfV
OgfeOgfEP-EHyQM-zAMH-f3zKBAuD-31OQ-GOxAoB8o6wwfHOsMHxzrDB8U6wAfeOsAHwz-EEME-
3hA-xwfJAz-MAwf9-fMoEC4P-fU5D8Y7ECgHxTrEB8s6xAfGOgfBOsMHwToH4DoHwz-EED-AED-d
ED-HB8kDP8wDB-398ygQLg-99TkPxjsQKAfAOsQHyTrMB8U6wQfDOsEHOgfgOgfDP8QQP8AQP8AQ
wD-BEME-wBDAP8EQwD-AED8QwD-AEME-EME-xQfJAz-MAwf9-fMoEC4P-fU5D8Y7ECg6wQfJOtIH
xToHxjrBB_A6B8M-xBDBP8AQP8AQPxA-whA-wBA-whA-EMA-wRA-whA-wBA-xAfJAz-DHcE-HT-C
Awf9-fMoEC4P-fU5D8Y7ECgHxzrYBzrAB8A6wAfFOsAH4joHwz-EED-AED8Qwj-AEMA-wBDCP8AQ
wT8QP8IQP8IQP8AQP8QHyQM-wh0-wR3AP8IDB-398ygQLg-99TkPxjsQKAfCOt0HwDrCB8Y6B_M6
wQfBP8QQP8AQPxA-xRA-ED-CED-AED8QP8IQP8IQP8AQP8QHyQM-xR3BP8IDB-398ygQLib99Tkm
xjsQKDriB9U6wQfZOsEHP8QQP8AQP8AQwT8QwT-BEME-wBDBPxA-wxDBPxA-wBA-xAfJAz-MAwf9
-fMoEC4m-fU5JsY7ECg64gfVOgc6wAfaOsA-8QfJAz-MAwf9-fMoEC4m-fU5JsY7ECg64gfSOsIH
wDrAB9s-8QfJAz-MAwf9-fMoEC4m-fU5JsY7ECg64gfNOsQHOgfCOgfbP-EHygPMB-399CgQLib9
9TkmxjsQKDriB8w6wAfBOsAHwzrAB9w-7wf9-f3RKBAuJv31OSbGOxAoOuIHzDoHwzoHwjrAB946
wgf9-f39KBAuJv31OSbGOxAoOuEHyjrCB8k6B8A6wQf9-f393igQLib99TkmxjsQKDrdB9E6wAfI
OsIHOgf9-f393igQLib99TkmxjsQKDrYB_c6wQf9xD-vB-394ygQLib99TkmxjsQKDrTB_46wQf9
wT-xB-394igQLib99TkmxjsQKDrOB8Y6B_o6B946B_A-8Qf9-eIoEC4m-fU5JsY7ECg6yAfMOgf0
OscHxDrHB_A-8Qf9-eIoEC4m-fU5JsY7ECg6wwfROsAH7jrEB8Q6xwfDOsAH4T-EEME-zRA-yhA-
ywf9-eIoEC4P-fU5D8Y7ECgH1zoH6zrCB9Y6wAfiP8QQP8AQP9kQP8sH-f3iKBAuD-31OQ-GOxAo
B9I6xAfpOsEH2DrAB_M-xBA-wBA-ED8QwD-AEMA-whDAP8AQwD-BEME-EMI-wBDBP8QH-f3iKBAu
D-31OQ-GOxAoB9I6B_06wAfXOsIH5D-EEME-wBDAP8EQP8AQP8IQPxA-wBA-ED-DED-BED-HB-39
4igQLg-94z8PwT-AD8E-wA-FOQ-GOxAoB9E6wAftOsUHzzrCB_c-xBA-whA-whA-wBA-whA-EMI-
ED-DED-CEMA-xQf9-eIoEC4P-eI-wA-APw-APw8-D8A-D8Q5D8Y7ECgH0DrAB-I6wAfGOskH6j-E
ED-CED-CED-AED-CED8QP8IQP8MQP8QQP8QH-f3iKBAuD-3hPw8-D8A-D8A-Dz8PP8APxDkPwf4A
AADAD8E7ECgH0DoH8TrBB8U6wQf0P8QQP8IQP8MQwD-AED-AED-AEME-wBDBP8EQwD8QwT-FB-39
4igQLg-94T8PPw-BP8APwD-ADz8PxDkPwzUPwDsQKAfQOgfvOsEHxTrBB-Y-1BDAP9kH-f3iKBAu
D-3hP8IPPw-APw8-D8A-D8Q5D8E1wQ-AOxAoB886wAftOsEHxDrCB-g-8Qf9-eIoEC4P-eM-D8A-
D8A-Dz8PwD8PxDkPwDUPwDUPwDsQKAfKOsQH7DrBB8M6wgf7P-EH-f3iKBAuD-3jPw-BP8APwT-A
D8U5D8E1wQ-AOxAoB8k6wAftOsMHwTrDB-3BP_8H-f3jKBAuD-31OQ-GOxAoB8k6B_s6wgfBOsMH
-f39-d0oEC4P-fU5D8Y7ECgHyToH6DrCB8A6wwf9-f394SgQLg-99TkPxjsQKAfFOsMH6DrFB-39
-f3lKBAuJv31OSbGOxAoB8U6B-39-f393CgQLib99TkmxjsQKAfFOgf9-f39-dwoEC4m-fU5JsY7
ECgHxToH-f39-f3cKBAuJv3iP8AmwD-CJsA-wCbFOSbANSbDOxAoB8U6B-39-f393CgQLib94T8m
wD8mwj8mPybAPybEOSbANSbDOxAoB8U6wQf9-f39-dooEC4m-eQ-JsI-Jj8mP8AmxDkmwDXBJsE7
ECgHxzrBB-39-f392CgQLib94z8mwj8mwD-AJj8mxDkmwDUmwDUmwDsQKAfJOsEH-f39-f3WKBAu
Jv3iPybCPybBPybAPybEOSbANSbANSbAOxAoB8s6wQf9-f39-dQoEC4m-eE-JsM-JsE-JsA-JsQ5
JsA1JsA1JsA7ECgHzToH-f39-f3UKBAuJv3hP8ImwD8mwj-AJsU5JsA1wSbBOxAoB8U6wgfCOsAH
-f39-f3TKBAuJv31OSbGOxAoB8Q6wAfAOgfDOgf9-f39-dMoEC4m-fU5JsY7ECg6wwc6B8E6wQfA
OsAH-f39-f3TKBAuJv31OSbGOxAoB8I6wQfDOsIH-f39-f3UKBAuD-31OQ-GOxAoB-39-f395CgQ
Lg-99TkPxjsQKAf9-f39-cs6wwfSKBAuD-31OQ-GOxAoB-39-f39yjrAB8E6wAfRKBAuD-3UPw-B
P8APwT-AD8E-wA-BP8APwT-AD8U5D8Y7ECgH-f39-f3IOsEHwzoH0SgQLg-ANQ81DzXBDzXBDzUP
NQ81wQ81wQ81wQ-0P8APwD8PwD8PPw-APw8-D8I-D8A-Dz8PwD8PxDkPxjsQKDoH-f39-f3FOsEH
xToH0SgQLg-ANQ81DzUPNQ81DzUPwDUPwjUPwTUPNQ81D-U-D8M-Dz8PwD8PPw-CPw8-wA8-Dz-A
D8Q5D8E1wQ-AOxAoOsAH-f39-f3COsEHxzoH0SgQLg-ANcEPNcEPNQ81DzXBDzXBD8E1DzUPNQ-1
Pw-CPw-BP8EPP8EPwD-ADz8PP8APPw-EOQ-ANQ-DOxAoOsEH-f3HOsEH-f3yOsAHyDrAB9EoEC4P
wjUPNQ81DzUPNQ-ANQ-ANQ-DNQ81DzUP9T8PwT8PxD8PPw-APw8-D8A-Dz8PwD8PxDkPwDUPwzsQ
KDrBB-39xjrABzrAB-397zrBB8g6wAfSKBAuD8I1DzXBDzXBDzUPNQ81wQ-BNQ81wQ-1Pw-APw-F
Pw8-D8A-Dz8PwD8PPw-APw-EOQ-ANQ-DOxAoOsAH-f3FOsEHwTrAB8A6wQf9-ek6B8s6wgfPKBDA
Lg-90j-BDz-CD8A-wA-BP8APwT-AD8E-wA-FOQ-BNcEPOxDAKAfZOsgH-dw6wwc6B8I6wgfqOsAH
-fI6xgc6B846wAfOKBDALg-99DkPxTsQwCgH0jrGB8Y6wQf91DrFB-c6wAf98jrAB8Q6wQfPOgfO
KBDBOw-98zkPxDsQwSgHyzrGB886wAf9zzrDB-s6wQf98TrBB9g6wQfNKBDCO8AP-fE5D8I7wBDC
KAfDOscHyzrIB8A6B-3NOsEHxTrDB-I6wAf98jrAB9o6BzrBB8soEMQ7-fYQxCg6xAfLOtQH3zrC
B_E6wwfGOsAH9joH-fI6wAffOsAHyigQ-f3EKAfIOt4H3DrBB8A6wAfLOsMHyjrDB8g6wQf2OsAH
-fE6wAfhOsEHyCgQ-f3EKAc65wfbOsAHwzoHxzrDB8E6zAfJOsIH9zrAB-3xOsAH5DoHyCgQ-f3E
KDroB9o6wAfEOgfFOsEH-d06B-3yOgflOgfIKBD9-cQoOucH2zoHxTrAB8E6wgfdOgf8OsAH-fI6
B_U6B8goEP39xCg65gfbOsAHxjrDB9s6xAf7OsAH-fM6wAfkOgfIKBDD-rkAPs0QxC3NEMQtzRDE
Lc0QxC3NEMQtzRDDKDrkB906B_M6BzrDB-3COgf99ToH2jrBB8Q6wAfIKBDCEs8Qwi3PEMItzxDC
Lc8Qwi3PEMItzxDCKDrcB_U6B_E6wQf9xzrAB-3zOsEH2DrBBzrGB8koEMISzxDCLc8Qwi3PEMIt
zxDCLc8Qwi3PEMIoOtAH8TrAB_E6B-3HOsAH-fM6wQfaOgfTKBDCEsI-wBI-EsE-wRLBEMItzxDC
Lc8Qwi3PEMItzxDCLc8Qwig6xAfzOsEHxTrAB986wQf9xzoH-fQ6B9w6B9MoEMISwT8SwT8SwT8S
PxLBEMItwz8twD-BLcQQwi3EP8EtwD8twxDCLc8Qwi3PEMItzxDCKAf3OsEHOgfBOsMH3DrDB-3I
OsAH-fM6wAfcOsEH0SgQwhLBPxLBPxLBP8ASwhDCLcM-wi3APy3DEMItwz8twD-CLcMQwi3PEMIt
zxDCLc8QwigH9zoHwTrDB986wAfpOsoH0jrAB-30OgffOgfRKBDCEsE-EsE-EsE-Ej8SwRDCLcM-
wS3HEMItxz-BLcMQwi3PEMItzxDCLc8QwigH9zrAB_M6wgfoOsEHyDrAB9A6wAf99DrAB986B9Eo
EMISwj-AEj-BEj8SPxLBEMItwz-CLcYQwi3GP8ItwxDCLc8Qwi3PEMItzxDCKAf4OgfQOsEHOsEH
xzrCB_o6wAfLOsEHzjoH-fQ6wAfgOgfRKBDCEs8Qwi3PEMItzxDCLc8Qwi3PEMItzxDCKAf3OsAH
1joHwTrAB-A6wQfOOsQHxzrBB_o6xAf9wjoH4DrAB9EoEMISzxDCLc8Qwi3PEMItzxDCLc8Qwi3P
EMIoB-U6wQfXOsMH7zrBB9U6xAfBOsAH6zrAB8I6wAf9OsEH4DoH0igQwjoSzToQwjotzToQwjot
zToQwjotzToQwjotzToQwjotzToQwigH9DrAB846xQf3OsAH3DrDB_w6B8Q6B-w6wAc6B_A6B9Io
EMM6zRDEOs0QxDrNEMQ6zRDEOs0QxDrNEMMoB-Q6B9U6B-Y6wAf90joHwzrFB-c6B_M6BzrGB8ko
EP39xCgH7jrFB9I6wgfuOscH-cQ6xQc6wwc6wAfDOgfDOgf3OgfjOsEHwToHwDoHySgQ-f3EKAfo
OsUH0jrFB_86wQf9yTrCB8M6wQfBOsEHyTrBB-Y6B_w6B8koEP39xCgH5DrDB8s6zAfzOsEH-cg6
wgfcOsEH9DoH6zrAB8M6wQfBKBDDEs0QxP5wMi7NEMQBzRDEAc0QxAHNEMQBzRDDKAfhOsIHyzrD
B-3BOsAH-ck6wAfhOsAH8zoH6zoHwzrABzoHwSgQwhLPEMIBzxDCAc8QwgHPEMIBzxDCAc8QwigH
3jrCB8o6wwf9xDrAB-3JOsAH4zrAB-I6wAfpOsAHwjrAB8A6B8EoEMISxT8SxxDCAck-AcMQwgHH
P8ABP8ABwRDCAc8QwgHHP8ABP8ABwRDCAc8QwigH2jrDB8c6xQf9xzrAB-3KOgflOgfzOgfoOsAH
wzoHwToHwSgQwhLEP8ASxxDCAck-AcMQwgHJPwHDEMIBwj8ByhDCAck-AcMQwgHBPwHCP8ABwD-A
AcEQwigH1zrCB8A6ygf9zDrAB-3KOsEH5DoH8zrAB_g6B8E6wQfBOgfBKBDCEsM-xhLCEMIBwz-A
AT-AAT8BwxDCAcI-wQHCPwHDEMIBwj8Bwj-BAcMQwgHBPwE-wQHBPwHDEMIBwT8BwT8BPwE-AcMQ
wigH1DrIB-3WOsAH-cY6wQc6wAfmOgf0OsEH5joHwDrAB8M6wAfAKBDCEsI-xxLCEMIBxT8BwT8B
wxDCAcE-AcE-AT-AAT-AAcEQwgHCPwHCPwHAPwHCEMIBwD-AAT8BPwE-wAE-wAHBEMIBwT8BwT8B
PwE-AcMQwigH-fY6B-3JOsEH4zrABzrCB-Q6wgfjOsIHxTrBKBDCEsM-xhLCEMIBxT8BxxDCAcE-
wwHHEMIBwj8Bwj8BwD8BwhDCAcE-AT8BPwHHEMIBwT8BwT8BPwE-AT8BwRDCKAf99TrAB-3yOsEH
wDrAB-U6B-IoEMISxD-AEscQwgHDP8ABP8ABPwHDEMIBwT8ByxDCAcI-wgE-AcA-AcIQwgHBPwE-
AT8BxxDCAcE-wQE-wAHAP8EBwRDCKAf99ToH-fk6B-U6B-IoEMISxT8SxxDCAc8QwgHCP8EByBDC
Ac8QwgHBPwE-wQHHEMIBzxDCKAf99ToH-fg6wQf0OgfyKBDCEs8QwgHPEMIBzxDCAc8QwgHPEMIB
zxDCKAf99TrAB-35OsMH8DoH8DrAKBDCOhLNOhDCOgHNOhDCOgHNOhDCOgHNOhDCOgHNOhDCOgHN
OhDCKAf99joH-f06wQfuOgfuOsEHKBDDOs0QxDrNEMQ6zRDEOs0QxDrNEMQ6zRDDKAf99joH-f3B
OsAH7ToH7TrAB8EoEP39xCgH-fU6wAf9-cI6B_w6wAfsOsAHwigQ-f3EKAf99ToH-f3DOsAH5zrD
B_w6wAfDKBD9-cQoB-30OsAH-f3EOgfmOsAH8DoHxCgQwyjNEMQBzRDEAc0QxAHNEMQBzRDEAc0Q
wygH-fQ6B-39xToH5TrAB-E6B8QoEMIozxDCAc8QwgHPEMIBzxDCAc8QwgHPEMIoB-30Ogf9-cU6
wAfkOgfuOsQHwygQwijPEMIBxj8BxhDCAcY-AcYQwgHCPwHBPwHGEMIBxz-AAT-AAcEQwgHBPwE-
AcI-wwHAEMIoB-30Ogf9-cY6B_Q6B_k6xAfCOsAHwigQwijPEMIBxT8BxxDCAcc-AcUQwgHBP8AB
wT8BxhDCAck-AcMQwgHCPwHDPwHEEMIoB-30Ogf9-cY6B_Q6B_g6wAfNKBDCKM8QwgHEPwHIEMIB
yD8BxBDCAcI-AcA-AccQwgHBPwHAPwHCPwHDEMIBwj8BwD8BwD8BPwE-AcAQwigH-fQ6B-39xjoH
5DoH5TrCB84oEMIozxDCAcQ-AcgQwgHIPwHEEMIBwj8BwD8BP8ABP8ABwRDCAcE-AcA-AcA-wAE-
wAHBEMIBwT8BPwHAPwE-AT8BPwHAEMIoB-30Ogf9-cY6B_Q6B_M6wQfRKBDCKM8QwgHEPwHIEMIB
yD8BxBDCAcU-AcE-AcMQwgHBPwHAPwHIEMIBxz-AAT8BPwHAEMIoB-3zOsAH-f3GOgfkOgfhOsEH
0ygQwijPEMIBxT8BxxDCAcc-AcUQwgHEPwHCPwHDEMIBwj-BAcgQwgHIPwHAP8ABwBDCKAf98jrA
B-3JOgf5OgfkOgfYOsIHwTrBB9UoEMIozxDCAcY-AcYQwgHGPwHGEMIBxD8BwD-AAT-AAcEQwgHE
PwHIEMIBzD8BwBDCKAf98TrAB-3JOsAH_DrAB_M6wAfXOsAHwDrDB9coEMIozxDCAc8QwgHPEMIB
zxDCAcE-wQHJEMIByj-AAcEQwigH-fA6wAf9yTrAB-g6wAfkOgfXOsAH3ygQwjoozToQwjoBzToQ
wjoBzToQwjoBzToQwjoBzToQwjoBzToQwigH-fA6B-3KOgf5OgfkOsAH1zoH4CgQwzrNEMQ6zRDE
Os0QxDrNEMQ6zRDEOs0QwygH-e86wAf9yTrAB-k6B_M6wAfYOgfgKBD9-cQoB-3vOgf9yDrBB-o6
B_A6wgfZOgfgKBD9-cQoB-3vOgf9xzrAB-w6wAfbOsMH3DoH4CgQ-f3EKAf97jrAB-s6wgfDOsAH
-cA6B9o6wAfbOsEHwDoH4CgQwyjNEMQ7zRDEO80QxDvNEMQBzRDEAc0QwygH-e06wAf1OsEHwDrB
B8A6wAc6wgf9wTrAB9k6B9w6BzrDB98oEMIozxDCO88QwjvPEMI7zxDCAc8QwgHPEMIoB-3tOgfv
OsMHOsAHOsIHwzrBB-3FOgfZOgfaOsEH5SgQwijPEMI7xDXDO8QQwjvFNcE7xRDCO8U1wTvFEMIB
yT-AAcIQwgHPEMIoB-3tOgftOsEHwTrBB-3SOsAH2ToH2joH5ygQwijPEMI7yDU7xBDCO8Q1O8E1
O8QQwjvENTvBNTvEEMIByz8BwRDCAcQ-xgHBEMIoB-3tOgfsOsAH-do6wQfGOsIHzDoH2joH5ygQ
wijPEMI7yDU7xBDCO8Q1O8E1O8QQwjvENTvBNTvEEMIByj8BwhDCAcQ-AcgQwigH-e06wAfqOsAH
-d06wAfFOgfAOsAHyzoH2TrAB_coEMIozxDCO8c1O8UQwjvFNcE7xRDCO8U1wjvEEMIBwz-AAT-A
AT-BAcEQwgHBPwHAPwE-wAE-wAHCEMIoB-3uOgfqOgf93zrAB8M6wAfBOsMHxjrAB9g6wAfoKBDC
KM8QwjvGNTvGEMI7xDU7wTU7xBDCO8g1O8QQwgHFPwHHEMIBwj8BPwHBPwHEEMIoB-3uOsAH6DrA
B-3gOgfDOgfGOsgH2ToH6SgQwijPEMI7xjU7xhDCO8Q1O8E1O8QQwjvHNTvFEMIBxT8BxxDCAcM-
wAHBPwHEEMIoB-3vOgfoOgf94ToHOsMH6zoH6SgQwijPEMI7xjU7xhDCO8U1wTvFEMI7xTXAO8YQ
wgHDP8ABP8ABxRDCAcQ-AT-AAT-AAcIQwigH-e86B_g6B-3hOgfxOgfpKBDCKM8QwjvPEMI7zxDC
O88QwgHPEMIBzxDCKAf97zrAB_c6wAf94DoH8TrAB_goEMI6KM06EMI6O806EMI6O806EMI6O806
EMI6Ac06EMI6Ac06EMIoB-3wOgfoOsAH-d46wAfyOgfoKBDDOs0QxDrNEMQ6zRDEOs0QxDrNEMQ6
zRDDKAf98DoH5zrAB-3eOsAH8zoH6CgQ-f3EKAf98DoH5zoH-eA6B-I6wAfoKBD9-cQoB-3wOsAH
5DrBB-3fOsAH7jrDB_koEP39xCgH-fE6xQfdOsAH-eE6B_06wQftKBDDLc0QxDvNEMQ7zRDEO80Q
xDnNEMQ5zRDDKAf99zrBB9s6B-3hOsUH4zrEBzrAB_woEMItzxDCO88QwjvPEMI7zxDCOc8QwjnP
EMIoB-35OgfZOsEH-eA6wAfDOsEH3zrBB8E6B-AoEMItzxDCO8c1O8UQwjvENcM7xBDCO8Y1wDvF
EMI5zxDCOc8QwigH-fk6B9k6B-3rOsAH3TrAB-YoEMItxj8txhDCO8Y1wDvFEMI7xDU7yBDCO8U1
O8cQwjnEPznBPznEEMI5xj85xhDCKAf95TrBB846wAfZOgf97DoH3ToH9ygQwi3FP8EtxRDCO8U1
OzU7xRDCO8Q1wjvFEMI7xDU7yBDCOcU-OT85xRDCOc8QwigH-eQ6wAc6wgc6ywfaOgf96zrAB906
B-coEMItxD-DLcQQwjvENTvANTvFEMI7yDU7xBDCO8Q1wjvFEMI5xj85xhDCOcQ-wznEEMIoB-3j
OsAHwzrBB_Y6wAf96zoH2zrCB-YoEMItwz-FLcMQwjvENcM7xBDCO8g1O8QQwjvENTvBNTvEEMI5
xT85PznFEMI5zxDCKAf94TrBB_46wAfjOsEH-cQ6B9o6wAf5KBDCLcM-xS3DEMI7xzU7xRDCO8g1
O8QQwjvENTvBNTvEEMI5xD85wT85xBDCOcY-OcYQwigH-eA6wAfvOsAH5DoH-cY6wAfZOgf6KBDC
Lc8QwjvHNTvFEMI7xDXCO8UQwjvFNcE7xRDCOc8QwjnPEMIoB-3gOgfvOsAH5ToH-cc6B9k6B-oo
EMItzxDCO88QwjvPEMI7zxDCOc8QwjnPEMIoB-3gOgfvOgfmOgf9xzoH2ToH_igQwjotzToQwjo7
zToQwjo7zToQwjo7zToQwjo5zToQwjo5zToQwigH-eA6B_86B_Y6B-3GOsAH2TrAB-koEMM6zRDE
Os0QxDrNEMQ6zRDEOs0QxDrNEMMoB-3gOgfvOgfmOgf9wzrCB9o6B-ooEP39xCgH-eA6B_86B9c6
xwfBOsIH-cI6wAfcOsAH_igQ-f3EKAfuOsQH5zrAB_86wAfVOsAHxTrABzrAB-3GOgfYOsMH_ygQ
-f3EKAftOsAHwjrAB8E6xQfcOgfxOgfSOsIHxzrBB-3GOsAH1DrDB-3BKBDDLc0QxDvNEMQ7zRDE
O80QxDnNEMQ5zRDDKAftOgfEOsMHwzrAB9s6B-E6B9E6wAfLOsAH-cY6B9E6wwfAOgf9wigQwi3P
EMI7zxDCO88QwjvPEMI5zxDCOc8QwigH7ToHzzrAB886wQfFOsEH8DoH0DrAB-3WOgfPOsEH-cko
EMItzxDCO8Y1O8YQwjvFNcE7xRDCO8U1wTvFEMI5zxDCOc8QwigH5DrFBzrAB9A6wAfNOsAHOsAH
xDoH8jrBB846B-3XOgfPOgf9yygQwi3DP8UtwxDCO8U1wDvGEMI7xDU7wTU7xBDCO8Q1O8E1O8QQ
wjnGPznGEMI5zxDCKAfhOsIHwzrBB9I6B8w6wAfBOsAHwjrAB-Q6wAfMOsAH-dc6B846wAf9yygQ
wi3DP8UtwxDCO8Q1OzU7xhDCO8g1O8QQwjvINTvEEMI5xj85xhDCOc8QwigH3DrEB8c6B9M6wAfL
OgfDOgfBOsAH8zrCB8w6B-3YOsAHzToH-cwoEMItxD-DLcQQwjvGNTvGEMI7xzU7xRDCO8Y1wDvF
EMI5xD-DOcQQwjnEP8M5xBDCKAfaOsEHwDoH4DrAB8g6wgfCOsMH8zrAB846wAf92TrABzrDB8Y6
B-3MKBDCLcU-wS3FEMI7xjU7xhDCO8Y1O8YQwjvINTvEEMI5xj85xhDCOc8QwigH2TrAB_Y6B8c6
wAfGOgf1OsAHzzoH-ds6wQfBOsAHxTrAB-3LKBDCLcY-LcYQwjvGNTvGEMI7xTU7xxDCO8Q1O8E1
O8QQwjnGPznGEMI5zxDCKAfYOsAH5zrCB8Q6B-s6wwfQOgf94joHxjrAB-3KKBDCLc8QwjvENcM7
xBDCO8Q1wzvEEMI7xTXBO8UQwjnPEMI5zxDCKAfYOgfoOgfAOsAHwjrAB-o6wAfUOgfDA8QH-dc6
wgc6wwf9yygQwi3PEMI7zxDCO88QwjvPEMI5zxDCOc8QwigH1zrAB_w6wgc6B-s6B9U6B8IDHcEx
wQMH-dc6BzrBB8A6B-3MKBDCOi3NOhDCOjvNOhDCOjvNOhDCOjvNOhDCOjnNOhDCOjnNOhDCKAfW
OsAH8DrBB-s6B9MDxR3BMcIDB-397SgQwzrNEMQ6zRDEOs0QxDrNEMQ6zRDEOs0QwygH1joH8joH
-DoH0gMxzAMH-f3tKBD9-cQoB9Y6B-3zOgfSAzHMAwf9-e0oEP39xCgH1TrAB-3zOgfSAzHMAwf9
-e0oEP39xCgH1DrAB-30OsAH0DoDMcwDB-397SgQwy3NEMQ7zRDEO80QxDvNEMT_4msT4hDDKAfU
Ogf99jrAB886AzHMAwf9-e0oEMItzxDCO88QwjvPEMI7zxDCN_QQwigH0zrAB-32OsEHzTrAAzHM
Awf9-e0oEMItwT-DLcA-LcQQwjvFNcE7xRDCO88QwjvGNTvGEMI35BDCKAfTOgf99zoHOgfNOgcD
McwDB-397SgQwi3BPy3DP8AtxBDCO8Q1O8E1O8QQwjvPEMI7xjU7xhDCN8M-wjc-N8E-Nz-DNz-C
Nz-CN8UQwigH0jrBB-32OgfNOsEHAzHMAwf9-e0oEMItwT8tPy3AP8MtwhDCO8Q1O8A1wDvEEMI7
zxDCO8Q1wzvEEMI3wz83wj-AN8A-N8E-N8E-N8I-N8E-N8QQwigH0joH-fc6wAfNOgc6BwMxzAMH
-f3tKBDCLcE-LT-ALcA-wC0-LcIQwjvENTs1OzU7xBDCO88QwjvGNTvGEMI3wz-BN8A-Nz83PzfB
PzfBP8E3wD-CN8UQwigH0joH-dw6xwfOOsEHzTrAB8EDMcwDB-397SgQwi3BP8MtwD8tPy3CEMI7
xDXAO8A1O8QQwjvPEMI7xjU7xhDCN8M-N8I-N8A-wDfBPzfBPzfCPzfBPzfEEMIoB9I6wAf92jrA
B8U6wgfKOsAHzzoHwgMxzAMH-f3tKBDCLcM-wC3DPy3CEMI7xDU7wTU7xBDCO8U1wDvGEMI7zxDC
N8M-wjc-N8E-N8E-N8E-wjc-N8E-N8QQwigH0zoH-dk6wAfJOsAHyDrAB9A6B8MDzAf9-e4oEMIt
wz8twT-CLcIQwjvFNcE7xRDCO8U1wDvGEMI7xDXDO8QQwjfkEMIoB9I6wAf92ToHyzrKB-39-dco
EMItzxDCO88QwjvPEMI7zxDCN_QQwigH0TrAB-3ZOsAH-f398CgQwjotzToQwjo7zToQwjo7zToQ
wjo7zToQwjo34joQwigH0DrAB-3aOgf9-f3xKBDDOs0QxDrNEMQ6zRDEOs0QxDriEMMoB886wAf9
2jrAB-39-fEoEP39xCgHzzoH-dg6wgfqP9sH-f3nKBD9-cQoB806wQf9yTrCB8g6wAfsP90H-f3m
KBD9-cQoB8s6wQf9yzoHwDrKB_0-3Qf9-ecoEP39wigHyjrBBzrAB-3JOsAH_z-dB-396Cj9-cIH
yjrAB8I6B-3HOsEH-D-EED-NED-GB-39-f32OsEH-cs6wQf9wD-EED-NED-GB-39-f30OsEH-cw6
wAf9wj-EEME-wRDAP8EQwT8Qwj-EB-39-f3zOsAH-c06wAf9wz-EED-AED8QP8AQPxA-wxA-xgf9
-f398zoH-c46B-3EP8QQP8AQPxA-wBA-wBDAP8EQP8YH-f39-fI6wAf9zTrAB-3EP8QQP8AQPxA-
wBA-whA-wBA-xgf9-f398TrAB-3OOgf9xT-EED-AED-AEMA-wBDBP8IQwD-EB-39-f3xOgf9zzoH
-cU-3Qf9-f398DrAB-3OOsAH-cU-3Qf9-f398DoH-c86B-3GP90H-f39-e86wAf9zzrAB-3GP9sH
-f39-e86wAf9zzrAB-39-f39-dc6B-3QOgf9-f39-f3YOgf9zzrAB-39-f39-dc6wAf9zzoH-e0A
AAAAAAAAAQ==
:: map/.info.pod
--[[pod,created="2025-11-13 21:07:43",modified="2026-01-21 18:05:53"]]
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAxLTE3IDEwOjM1OjQ4Iixtb2RpZmllZD0iMjAyNi0w
MS0xNCAwOTo0OTo1NyIscmV2aXNpb249M11dbHo0AFEAAABTAAAA8Rx7e2JtcD1weHUATIAgIAD-
AAD---8DLGhpZGRlbj1mYWxzZSxwYW5feD0wCADSeT0wLHRpbGVfaD0xMgoA8AF3PTE3LHpvb209
MC4yNX19
:: sfx/.info.pod
--[[pod,created="2025-11-13 21:07:43",modified="2026-01-21 18:05:53"]]
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA3LTMxIDA4OjMwOjI4Iixtb2RpZmllZD0iMjAyNS0w
Ny0zMSAwODozMDoyOCIscmV2aXNpb249MF1dbHo0AKAAAAALCgAA-zBweHUAAygAAAQABA9AEAIO
AAGgASACoA4ADxAADfDKAQIDQA8PkAQFBgdADJAICQoLQAyQDwwPDQ8ODEAM8P8BAOv-J6oBEAYP
MBABIAEgAfAAAhACDhABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDjAA------_9
H-8BAKzPyA9AAA8QQP--sPD-AQD-6lD-----KQ==
:: src/.info.pod
--[[pod,created="2026-01-12 12:18:36",modified="2026-01-21 18:05:53"]]
:: [eoc]
