picotron cartridge // www.picotron.net
version 2

:: gfx/
:: map/
:: sfx/
:: src/
:: pal/
:: drak.lua
--[[pod_format="raw",created="2024-04-07 07:42:45",modified="2024-04-11 14:23:20",revision=914]]

-- A 'require' function similar to standard Lua.
-- Idea from elgopher on the BBS
function require(name)
	if (_modules == nil) _modules = {}

	local cached = _modules[name]
	if (cached) return cached

	local filename = fullpath(name .. '.lua')
	local src = fetch(filename) 

	if (type(src) != "string") panic("could not include " .. filename)

	-- https://www.lua.org/manual/5.4/manual.html#pdf-load
	-- chunk name (for error reporting)
	-- mode ("t" for text only -- no binary chunk loading)
	-- _ENV upvalue
	-- @ is a special character that tells debugger the string is a filename
	local func, err = load(src, "@" .. filename, "t", _ENV)
	if (not func) panic("Syntax error:", tostr(err))

	local module = func()
	_modules[name] = module

	return module
end


function panic(...)
	local args = { ... }
	foreach(
		args,
		function(str)
			send_message(3, { event = "report_error", content = str })
		end
	)
	stop()
end


-- Table utility functions --------------------------------------------------------


function tostrrec(t)
	if type(t) != "table" then
		return tostr(t)
	end
	
	local s = nil
	for k, v in pairs(t) do
		if not(s) then
			s = "{ "
		else
			s ..= ", "
		end
		s ..= tostr(k) .. " = " .. tostrrec(v)
	end
	s ..= " }"

	return s
end


-- Char utilities -----------------------------------------------------------------


function keyp_num()
	if (keyp("9")) return 9
	if (keyp("8")) return 8
	if (keyp("7")) return 7
	if (keyp("6")) return 6
	if (keyp("5")) return 5
	if (keyp("4")) return 4
	if (keyp("3")) return 3
	if (keyp("2")) return 2
	if (keyp("1")) return 1
	if (keyp("0")) return 0
	return nil
end


function keyp_hex()
	if (keyp("f")) return 0xf
	if (keyp("e")) return 0xe
	if (keyp("d")) return 0xd
	if (keyp("c")) return 0xc
	if (keyp("b")) return 0xb
	if (keyp("a")) return 0xa
	if (keyp("9")) return 0x9
	if (keyp("8")) return 0x8
	if (keyp("7")) return 0x7
	if (keyp("6")) return 0x6
	if (keyp("5")) return 0x5
	if (keyp("4")) return 0x4
	if (keyp("3")) return 0x3
	if (keyp("2")) return 0x2
	if (keyp("1")) return 0x1
	if (keyp("0")) return 0x0
	return nil
end

function is_num_char(c)
	if (not c) return
	return ("0" <= c) and (c <= "9")
end


function is_hexa_char(c)
	if (not c) return
	local is_num = ("0" <= c) and (c <= "9")
	local is_hex_alpha = ("a" <= c) and (c <= "f")
	return is_num or is_hex_alpha
end


-- Drawing -------------------------------------------------------------------------


-- From Sophie on the discord
function get_drawspace()
    return {
        cam_x=peek4(0x5510),
        cam_y=peek4(0x5514),
        clip_l=peek2(0x5528),
        clip_t=peek2(0x552a),
        clip_r=peek2(0x552c),
        clip_b=peek2(0x552e),
    }
end


function set_drawspace(drawspace)
    poke4(0x5510,drawspace.cam_x)
    poke4(0x5514,drawspace.cam_y)
    poke2(0x5528,drawspace.clip_l)
    poke2(0x552a,drawspace.clip_t)
    poke2(0x552c,drawspace.clip_r)
    poke2(0x552e,drawspace.clip_b)
end

:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2Iixtb2RpZmllZD0iMjAyNC0w
NC0xMSAxNzoyNTowMSIscmV2aXNpb249MTk3N11dbHo0AKUCAAB8MwAA8yV7WzBdPXtibXA9cHh1
AEMgCAgEMAdgF1AHAAdABwAHICcwN0AXsCxmbGFncz0wLHBhbl94CADHeT0wLHpvb209OH0sQgBz
EBAE8CEXAAIAExAIAEMAF-ACCQAPFQAkHxGFAAsdOYUA1SsnkFdgVxAHYCdAB2ACAP8BQCdgBzA3
QCdAF0A3wBfwG1YAHfYHJBfABxAHsAcQB6AHMAeQBzAHgBcABwIAE4AWABOgJgBPwBfwFGQAHfIG
Iq8RMM4gTgduIE4XXiBOJ04gTjc_CAAhF14YAF-OMK7wE1cAHp2uMM4gziA_Rz4EAB-OUgAjH-Ax
AEr-BQsGBAAnYAcgB1AHkAeQByAHYCdgQAALHjdAABEglgFRIAcAV1AKAJ9AVyAHEAcABxBMAB4S
N4sABwQAHzdDAB4GjgAChgAJDAAPTwAeYEdQB5AncB0BL0dQOwAgQAeQN2AGAA87AB0TEEkBAVEB
IzcQWQEfkJsBHgTbASAQF04BP2A3UN0BLiQQF00BPxA3UJAAJEUgB1BH4gEPkgAoA9UBFUcKAA5Q
AA9zAhQvN2BxAiMOcQMPMQCfnxMdBP8Ym-D-bTUAHI-wm-8YT-D-DjcAHW-6-xh18Ig2AB1f-4D-
GIg5AR4PMQCsggcHBHJPOxJOAgAfcjsACy8xMTwAAXIOLxEOEg4tBAAPQwAPD_EAHg8xAO-wBQkJ
BMAHcBdgJyBnEAcQJyAHEBcwlggPRAAe-wIQBzAXEAcgJxAHEGcgJ2AXcEQAHjeQZxACAB_QawIc
-wEwDxZAHjAuID4wLkAeUA4QPwAc-wEQDxZQHkAuMD4gLjAeQA4wpgEeDzEA----------------
-------------------------------------2NQbT03fX0=
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2IixzdG9yZWQ9IjIwMjQtMDMt
MjQgMDA6NDg6MDYiXV1sejQABAAAAAMAAAAwbmls
:: label.png
b64$iVBORw0KGgoAAAANSUhEUgAAAeAAAAEOCAIAAADe_FMwAAAV60lEQVR4Ae2dX2gkx53He9oN
pweBQXDdDws67tbyQ8MsCCwYLRZkCJwZMMZ-sohhHCyjXUEwVkCIcCw_79gx_5AIBcsYg2SxAnsY
hBc7mIBIXsYgI0EmIFiBHrLRQRYEHgUEC-uweTB7D3X09nWPWt3V-7s-Hxqpuqe_9avfr6q_9Vp5
8vAHBQAAsoeWcLzvn72e2Vq8_PBz0fjis499Sn7_i1_yhwAgJipPHv5gf3d7U4QeFNSdhWP6VAXq
7DGIf3fGowHciBMkzoW97dHZ0d--sfLZ37_tnXf8L5zPF599-PNf-FL89e_HwrU80PyUIFAyURnW
iw8-F25rNfx0BoCMuLNofPHZx4Fsy6cjB7Uae_fzXDgMQd3Zp0c7DdqRhojqJ_eYOG-21ne3Lwdy
dgCASC4MiftDeJSHRzsN2gogRve_aob_GqFrnzd7h-OKDuJvfI7sfVcBQIRO5-9UZmHyjmlEaBRO
g7Y70YXJx12d89zWcm3RQbxanR2-RrgAeDRAHO5mP1b_T5nVzb8RXThyMo5vtyZhVgEMWuTgKJn-
bJPM0O7L9oQ9fpW_3nFngNwR9Mye1z9CWwtkSk6DDmRDsXrx989eF3eLlY-deSVSTXilAUqIMJAv
PvtYmIM4Nd5G4ThZsR40n5Zl7_ZnPoHm7PYxDypPHv6Q2OIl6adyvPjw86D7I9ZbCgDKjEoJAACy
SeX9iTeoAgBABlEpAQAABg0AAAHQip3eh_1XvDu83-6WTQAA2aTy-sQbpXXnODx6a2zAroJiMHdm
UIR00cqT6pOXX6r84Y_RD-vc-PN-2-wrOwmKTch9vjU2uNDurT7uzltjg3LeH--PoL-88UA03nxm
UrTffGbS-pP13f7TedqhbeuvXfvBXz4VjVsvvOOnnR2Pfm7__fN__vuf7orGv-3nz_xtd8_PXpsR
jfe_2RXt977ZHTqmu_d5naV7Wn_jHfO8KiWQ0YU9xU9Be3qvkdyYPnteuEZyY6br0UMtOEIiMZDk
Ue0vwjct97TsVViq-VeHww7VOn7yxl41qy0a7r9hePLySwm4s9uOh1qzhXU8Ljwn9p7enSV6Xoi9
p-ewEmMGmmckPR0-_ewZKLT-MaMt5oXD_h8z0J6-0KPTcudbL7wjHuHUIpGQ6QyP9fq1D16-FtVo
ms9_wqn9WK3V3_ostO7vQ_83RzsOnrz8UuUPf4zbnePmo9dm4ugctKefc_6-Z7oZsUZ_ej43--zf
Nv8q7chbY4O5M_O8PnE7taIot154Z_j3D9uvBBpnfG3D-moldevrryI0aNVPpzefmfRvzZbE8mW7
1v7dUTWrcOdVMCrCu7OiKP73aHy8982uT9fz3y3ynpFbc0wZsUYx7fy5M8PuyA53dnwRnd194uC5
_edTP8LBDFpYp9tAv-zx4MsfD4J6dDaJxJ197tS--_nu0Labj16bsTesV4_eou2np3c373CRjBl5
9KjGdFT7wmK6--oZ009PP0vpJynpMX1WLKg7e3ixn_9x8MFfPhWJhMwlIb96f_KNAtjuUD5sv2J-
ffLyS0Pd_f32tyHvYftKb40NilpPKBt233Tsc59sjQ3EIFbDT_ehP4W0deHLiqLceuGdkEldEOj1
a-8X6OuvMOgABn0eIQ3az04CyLtBQyoU2aD9eHS07gwAgEEDABQflRIAAGSTSqNai3C4Zqve7fTK
Uz7dNE6PBuRLvsWA85s1VO4oAIASGXSzVW_26v6-F_Ae1k3jvO9DfyLfYuRr-S0S4py6j2qxz697
HbOwn7U4Bu12ekMX8rzveef0aDB0FU_PBoU8wORbbLqdnrDj8pzfofs2C-s5FoMG6wYmZfLNHYV0
YYlFzMLiYtBJXM6lyrc8Hi0Wt5D5djs9zmkWzq8a3w1s3cOORvHuZ3FErYNqP7G6aRTvAJ_XbyGT
9V7fotJs1ctzfh1bN1Pnt9Ko1qJd11LdvbpppH7Hki-5cn6Lur5a0Hwi6VOwNSZf8iVf8k3foBVF
2ente-z600nz_vaPclN5Q-9z7la3UZ-2LkjBIN9i89NJk-XNFGqpbksAgByhxTTuiw8-t9rfP3s9
sXwG9_9ZbWPiirQ8qDZk3LTyjSR0SWolnW8e1zfFfQV2VPFPNw3xONrNVl08EkN--_x18Qiz-u5X
r4on7pSMiSviEZvs3bnb4vGzKd1a669EXP-aaPNNIG7ktfK5RjndG7lb3xTXCOxoVuv0aCBM2dHu
dnpyBu3mJ7-5faDzH1WSn2zdTKCUYh_LnS3nd-mKGy3_1yine6MA65vMGqEdbtAJ8N2vXvVp09G6
hrj2-Wwv6zA4tH6w5mxVXEIrQVpxw9QqzBrlem-kaH3TWiO0dtTE3Pknv-m9H2uOnE_2bvq-_Y2J
K_KR0IaJm1a_YShbrSLMNxfrm5G4JUezWrppDG03W3W5oV98_LlofP-sdUVRvvvVq8mkNLh-z341
iWs-_biJkVbcAqxRYnELsK9yUaviUWlUa-5766ax09v36LCyNP-v-3UoN5U39D-nrnyN_rR3QQoG
_RablaX55dVN1jc7aJGPmEefBQAohUELTn-3W_8Ob337tdWO8BILEzctLXVmzkVaX4gQNZvTWlma
L9UypJVvHuvMnIsdF60dzf4y9fiSu0d-5CT5BV5e3SyVQaeVbx7rzJyLHRetnUqjWrMb9NbYwP7z
3JlhN2jdNHZ6_963Qam8tVGf9i4I_ZJvjuD8Zg3N-enB4g3RGF-bKM9SAQDkwKAjYfD2mqIoxp3F
hPMJEzctLXVmzsSFoagxjZvW0oaJm5aWOjNn4sJQNPen8bUN6gIAkDmDnjszKAoAQBaoNKo1-711
09jp7Xt0WFmaX17dVBRl8Paa_GLcWZSYljVOUMLEldA26tOiIHnMVyJuJPnmqFZlW9-Uz2-CWmt9
MztnLSbjl1tXC_lsw8RNS5tWvnmsM3Mudly0DtSYDBoAAEKCQQMAYNAAAIBBAwBg0AAAkEODXlma
R4sWLVq00tpKo1rzP5ZuGju9fe9gy6ub5bnfGvVp74KQL-nmCM5v1lDLsxgAAPlCCyoYHR0N2aFg
kC-5ki-5xoTKHQUAkE20guVzfLBntS9PXk0ldJJx08qXuOxnSM6gddMQjdOjgb3dbNUVRel2ejlK
ydpPxwd7lyevvv2zm_L1zt3bse7mVOKmlS9xix03xf0MdlSrdXo0cLfDWLP98k9S6_DO3dv_txRx
iUvcdOOitaMlcPMnrHVjXf6xxnUU2n-QaPMtW9zE1rdsdU5rP6NNyKCzw527twNtr5CFtnb2nbu3
08q3bHETWN_y1Tk7_7nMPDVo3TTc7WarLv52O728pGTtJ7HDUjm6AhE67m3tyLdscRNb37LVOa39
DHYqjWrNf2-dNHb7hx4d2guz7fXt8pRvZqrqXRDyJd8cwfnNGip3FABANtEKls---PqWd4e3vv3a
akd4eRKXuMSFyFHjG7q9MJuKNq05E5e4xE337BdPq9lfph5fcvfoj5xIBl7flp90CG2ojUVc4hI3
1bhozzVoRVG2xgb217kzI5UFluY--vsD7w67xCUucbMaFy4waEVRHizeEI3xtQ0KBACQIYPONcfX
biuKcvmrm8QlLnFzFxccqAXLJ60tRVziEhciR3N-Gl-boC4AAJkz6Lkzg6IAAGQB1f7SHzlxP9JD
txdmk9ceX7tt-SUucYmbr7hoHVQa1Zr-sXTT2O0fegdrr2_X536bmap6F4R8yTdHcH6zhlqexQAA
yBcYNAAABg0AABg0AAAGDQAAOTTo9sIsWrRo0aKV1lYa1Zr-sXTT2O0fegdrr2_X536bmap6F4R8
yTdHcH6zhlqexQAAyBdaUMGjR49CdigY5Eu_5Eu_MaFyRwEAZBMtpnEH9_9ZbWPiSi60dnnCcVPB
Pueg005xjSJJOS97I4-7CiJEFf900xCPo91s1cUjMbQxcUU8YpO9O3fb_ptN7eD_PbdWPHHPOS2s
OYvDn-01CunO0usb_d4o9r6CqNCs1unRQJiyvd3t9IRNl60uwrA_2bqZzGEQ5z8VrZVsXgiTrwO5
9Q2-N8qwr9BGon1q0EOJ1prD7MgktXbbSiZuGMeJVpv9NQqTr1jZfO2NYuwrtHJa9UJ9t9Prdnrh
3fmTrZufbN3MhdZeslTmnBY5WiPpwyAe6fWNZG_UbV_BNJrV0k1jaLvZqgubDjr04P496eslFa0x
ccXSCt6du53MnNPCnm-Qaae1vhHif32j3RuF31cQFZVGtea-t24aO719jw4rS-PLq5vlKV_jPu1d
EPIl3xzB_c0aKncUAEA20WIa9-R3v-Xu8Na3X1ttxyVWNm1alK1W7CvIHSolyAIrS-OpaMtWK-YV
2nxpNfvL1ONL7h79kRM2etwsr26moi1brdhXaPOlrTSqNbtBb40N7D-PnRl2g9ZNY6e3730blOr8
NOrT3gUhX-LNEZzfrKG5Pz1YvCEa42sb5VkqAIAcGHQkDN5eUxTFuLOINrOUrVbsK8gdakzjhtlS
ZdOmRdlqxb6C3KG5P42vbVAXAIDMGfTcmUFRAACyQKVRrfnvrZvGTm-fo8PK0vzy6qaiKIO318QX
485i0DnlSNuoT4uChIlrr1uS2rTyTatWecw34VrZ_6eyJxPWWuub2TlrMRm-3H4qp1ZRFOnVDaMt
W63YV2hzp1VjMmgAAAgJBg0AgEEDAAAGDQCAQQMAQA4NemVpHi1atGjRSmsrjWrN-1i6aez09r2D
La9ulud_a9SnvQtCvuSbIzi-WUMtz2IAAOQLLahgdHQ0ZIeCQb7kS77kGxMqdxQAAAYNAADBDVo3
DfE42s1WXTxUCgAgHYNWFOX0aOBudzu9bqcnN-TxwZ70tNCiRYsW7VODPo9mqy4X_PLkVelJo0WL
Fi3aiw262_lJxwYAAGk0q6WbhrvdbNWpEQBAmgZ9ejSwPtnb3U6PGgEApIJKCQAAMGgAAMiGQbcX
ZtGiRYsWrbS20qjWrJepx5fcPfojJ1ZbN43d-qF3sPb6dnnut5mpqndByJd8cwTnN2tojvetsYH9
de7MKM9qAQBk2qAVRXmweEM0xtc2KBAAQFqolAAAAIMGAIAAaO5P42sb1AUAIHMGPXdmUBQAgCyg
2l-6IyfuR3ro9sIsWrRo0aKV1lYa1Zr-sXTT2O0fegdrr2_X536bmap6F4R8yTdHcH6zhlqexQAA
yBcYNAAABg0AABg0AAAGDQAAOTTo9sIsWrRo0aKV1lYa1Zr-sXTT2O0fegdrr2_X536bmap6F4R8
yTdHcH6zhlqexQAAyBdaUMGjR49CdigY5Eu_5Eu_MaFyRwEAYNAAUFL_5V9nKIK8QeumIR5Hu9mq
W38BAOTc_cHep3i0vEErinJ6NBjalmZw-x5atGjRCnx6NLUabtDn0WzV5QIbE1ekJ40WLdriaf14
NLUKYNDdTq-b6UnHBgAI6tFgoVkt3TSGtgEAImH86juKovzzH7uUIphBnx4NrE-2tqDb6VEpAJDj
n--YFdb8YO9T0YBgBg0AEKtHK4piTFyhFIFQKQEAQOkMemVpHi1atGjRSmsrjWrNepl6fMndoz9y
YrV109jp7XsHW17dLM-91qhPexeEfMk3R3B_s4bmeN8aG9hf586M8qwWAECmDVpRlAeLN0RjfG2D
AgEApIVKCQAAMGgAAAiA5v40vrZBXQAAMmfQc2cGRQEAyAKq-aU-cuJ_pIdeWZpHixYtWrTS2kqj
WvM-lm4aO71972DLq5vlud8a9WnvgpAv_eYIzm-WUMuzGAAA_QKDBgDAoAEAAIMGAMCgAQAghwa9
sjSPFi1atGiltZVGteZ-LN00dnr73sGWVzfLc7816tPeBSFf8s0RnN_soZZnMQAA8oUWVDA6Ohqy
Q8EgX-IlX-KNCZU7CgAAgwYAgOAGrZuGeBztZqsuHioFAJCOQSuKcno0GNrudnrdTk9i6OODPelp
oUWLFi3apwZ9Hs1WvdmqSwS_PHlVetJo0aJFi1bzFnc7PeHR0uEBAECOpwatm4a7jTUDAKRs0KdH
A_uTvd3t9KgRAEAqqJQAAACDBgCAbBh0e2EWLVq0aNFKayuNas16mXp8yd2jP3JitXXT2O0fegdr
r2_X536bmap6F4R8yTdHcH6zhuZ43xob2F-nzozyrBYAQKYNWlGUB4s3RGN8bYMCAQCkhUoJAAAw
aAAACIDm-jS_tkFdAAAyZ9BzZwZFAQDIAqr9pT9y4n6kh24vzKJFixYtWmltpVGt_R9LN43d-qF3
sPb6dnnut5mpqndByJd8cwTnN2uo5VkMAIB8gUEDAGDQAACAQQMAYNAAAJBDg24vzKJFixYtWmlt
pVGt_R9LN43d-qF3sPb6dnnut5mpqndByJd8cwTnN2uo5VkMAIB8oQUVPHr0KGSHgkG_5Eu_5BsT
KncUAAAGDQAAwQ1aNw3xONrNVp0aAQCkadCKopweDYa2pRncv4cWLVq0aKW1Tw36PJqterNVlwhs
TFyRnjRatGjRor3YoLudnnRsAACQ5qlB66YxtN1s1SkTAEDyaOLf6dHA_mRvdzs9agQAkAoqJQAA
wKABACAbBr2yNI8WLVq0aKW1lUa1Zr1MPb7k7tEfObHaumns9Pa9gy2vbpbnfmvUp70LQr7kmyM4
v1lDc7xvjQ3sr3NnRnlWCwAg0watKMqDxRuiMb62QYEAANJCpQQAABg0AAAEQHN-Gl-boC4AAJkz
6Lkzg6IAAGQB1f7SHzlxP9JDryzNo0WLFi1aaW2lUa35H0s3jZ3evnew5dXN8txvjfq0d0HIl3xz
BOc3a6jlWQwAgHyBQQMAYNAAAIBBAwBg0AAAkEODXlmaR4sWLVq00tpKo1rzP5ZuGju9fe9gy6ub
5bnfGvVp74KQL-nmCM5v1lDLsxgAAPlCCyoYHR0N2aFgkC-5ki-5xoTKHQUAgEEDAEBwg9ZNQzyO
drNVFw_VAgBIx6AVRTk9Grjb3U6v2_nJDX18sCc9LbRo0aJF_9SgI_fy5FW0aNGiRSutjdGgAQAg
DE8NWjeNoW0AAEgFTfw7PRpYn_xtQbfTo1IAAAmjUgIAAAwaAACyYdDthVm0aNGiRSutrTSqNetl
6vEld4-_yInV1k1jt3-oHay9vl2e_21mqupdEPIl3xzB_c0amuN9a2xgf507M8qzWgAAmTZoRVEe
LN4QjfG1DQoEAJAWKiUAAMCgAQAgAJr70-jaBnUBAMicQc_dGRQFACALqPaX-siJ_5Eeur0wixYt
WrRopbWVRrXmfyzdNHb7h97B2uvb5bnfZqaq3gUhX-LNEZzfrKGWZzEAAPKFRgkAAJLk_GBPNC5P
XnW0rb-io0qxAACS5PLkVcuCHW1HT41iAQAkzPHBnqNhvdptWqVSAAAJY3fhy5NXxavDneM16PbC
LFq0aNGidXB8sHd8sOfxarUrjWrN-7i6aez2D70n2l7fLs81ODNV9S4I_ZJvjuD8Zg21PIsBAAAA
AAAAAMXlfwEsAA7jlHGMXgAAABB0RVh0TG9kZVBORwAyMDExMDIyMeNZtsEAAAAASUVORK5CYII=
:: main.lua
--[[pod_format="raw",created="2024-03-24 00:48:06",modified="2024-04-11 17:25:01",revision=2440]]
include "drak.lua"
local settings = require "src/settings"
local file = require "src/file"
local tracker = require "src/tracker"
local tracker_grid = require "src/tracker_grid"
local piano_roll = require "src/piano_roll"
local synth = require "src/synth"


local gui
local refresh_gui = true
local current_view = "tracker" -- or "piano_roll" or "synth"


function _init()
	window {
		tabbed = true,
		icon = --[[pod_type="gfx"]]unpod("b64:bHo0AB4AAAAcAAAA8A1weHUAQyAICAQwB2AXUAcAB0AHAAcgJzA3QBew")
	}

	wrangle_working_file(
		file.save,
		file.load,
		file.default_filename
	)
	
	poke(0x4000, get(fetch("/system/fonts/p8.font")))
	
	poke4(0x5000, get(fetch("pal/0.pal")))
end


function _update()
	if keyp(settings.keys.play) then
		play_or_pause()
	end
	if refresh_gui then
		generate_gui()
		refresh_gui = false
	end
	gui:update_all()
end


function _draw()
	cls()
	gui:draw_all()
	print(string.format("\014% 3.0f", (stat(1) * 100.0)) .. "%", 462, 250, 7)
end


function generate_gui()
	local cell_width = 14
	local cell_height = 29
	gui = create_gui()
	local top_panel = attach_top_panel(gui, { x = 0, y = 0 })
	if current_view == "tracker" then
		tracker.attach_pattern_selector(top_panel, { x = 98, y = 0})
		tracker.attach_pattern_flow_toggles(top_panel, { x = 370, y = 0})
		tracker.attach_note_attributes(top_panel, { x = 410, y = 0})
		tracker.attach_channel_panel(gui, { x = 0, y = 16})
		tracker_grid.attach(gui, { x = 16, y = 16 })
	elseif current_view == "piano_roll" then
		piano_roll.attach_piano_roll(gui, { x = 0, y = 16 })
	elseif current_view == "synth" then
		synth.attach_synth(gui, { x = 0, y = 16 })
	end
end


function attach_top_panel(parent, el)
	el.width = 480
	el.height = 16
	parent:attach(el)

	attach_view_selector(el, { x = 2, y = 0 })
	attach_play_button(el, { x = 72, y = 0 })
	
	function el:draw()
		rectfill(0, 0, el.width, el.height, 2)
	end	

	return el
end


function attach_play_button(parent, el)
	el.width = 16
	el.height = 16
	el.cursor = "pointer"
	parent:attach(el)

	function el:draw()
		spr(stat(464) == 0 and 4 or 5, 0, 0)
	end
	
	function el:click()
		play_or_pause()
	end
	
	return el
end


function attach_view_selector(parent, el)
	el.width = 3 * 20
	el.height = 16
	el.cursor = "pointer"
	parent:attach(el)
	
	function el:draw()
		--[[
		if current_view == "synth" then pal(7, 17) else pal(7, 59) end
		spr(3, 0, 0)
		if current_view == "piano_roll" then pal(7, 17) else pal(7, 59) end
		spr(2, 16 + 4, 0)
		if current_view == "tracker" then pal(7, 17) else pal(7, 59) end
		spr(1, 2 * 16 + 2 * 4, 0)
		pal(7, 7)
		--]]
		print("\014inst", 2, 6, current_view == "synth" and 7 or 62)
		print("\014trak", 2 + 20, 6, current_view == "piano_roll" and 7 or 62)
		print("\014patt", 2 + 40, 6, current_view == "tracker" and 7 or 62)
	end
	
	function el:click(msg)
		if msg.mx < 20 then
			current_view = "synth"
		elseif msg.mx < 2 * 20 then
			current_view = "piano_roll"
		else
			current_view = "tracker"
		end
		refresh_gui = true
	end
	
	return el
end


function play_or_pause()
	-- is `stat(464)` enough?
	if stat(464) == 0 then
		music(0)
	else
		note()
	end
end

-- Copied from /system/apps/sfx.p64/track.lua in Picotron 0.0.1e
-- by sfx_index; could do by channel later esp
-- if playing same sfx on two diffrent channels
function playing_row(channel)
	if (stat(400 + channel, 12) == sfx_index) return stat(400 + channel, 9)
end
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2Iixtb2RpZmllZD0iMjAyNC0w
NC0xMSAxNzoyNTowMSIscmV2aXNpb249MTg3NF1dbHo0AGcAAABWEAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD--------------------78QgiKSxoaWRkZW49ZmFsc2UscGFuX3g9
MAgAwnk9MCx0aWxlX2g9OAkAwHc9OCx6b29tPTF9fQ==
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2IixzdG9yZWQ9IjIwMjQtMDMt
MjQgMDA6NDg6MDYiXV1sejQABAAAAAMAAAAwbmls
:: pal/0.pal
b64$LS1bW3BvZCxiZ19jb2xvcj0wLGJsYWNrZXN0X2NvbG9yPTAsY3JlYXRlZD0iMjAyNC0wNC0x
MCAwNDo1Mjo1MSIsaGlkZGVuPXtbMF09ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2V9LGhpZGRlbl90b2dnbGVzPXtbMF09ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2V9LGxv
Y2tlZD17WzBdPXRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRy
dWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVl
LHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSxm
YWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxz
ZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxm
YWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxz
ZSxmYWxzZSxmYWxzZSxmYWxzZX0sbW9kaWZpZWQ9IjIwMjQtMDQtMTAgMTY6NTY6NDUiLG9rcGFs
X3ZlcnNpb249IjAuMC40IixyZXZpc2lvbj0xODAsdGVzdF9jdWJlX2NvbG9ycz17WzBdPXsxNSwz
MSw0fSx7MzEsNCwyMH0sezQsMjAsMjF9LHsxMCw5LDI1fSx7OSwyNSwyNH0sezgsMjQsMn0sezI2
LDExLDI3fSx7MTEsMjcsM30sezI3LDMsMTl9LHsyOCwxNywxOX0sezI4LDEyLDE2fSx7MTIsMTYs
MX0sezYsMjksMTN9LHsyOSwxMywxOH0sezEzLDE4LDF9LHs3LDIzLDE0fSx7MjMsMTQsMTN9LHsx
NCwzMCwxOH0sezcsNiwyMn0sezYsMjIsNX0sezIyLDUsMjF9LHsxLDEsMX0sezEsMSwxfSx7MSwx
LDF9fSx3aGl0ZXN0X2NvbG9yPTddXWx6NAAnAQAAFQIAAPUFdXNlcmRhdGEoImkzMiIsNjQsIjAB
AMAxZDJiNTMwMDdlMjUIAPAXMDA4NzUxMDBhYjUyMzYwMDVmNTc0ZjAwYzJjM2M3MDBmZmYxZTgI
AEAwMDRkCAARYTYAYGZmZWMyNwoAIGU0OABAMjlhZCQAYDgzNzY5YyAAMTc3YTgAwGNjYWEwMDFj
NWVhYzAA8B1hNWExMDA3NTRlOTcwMDEyNTM1OTAwNzQyZjI5MDA0OTJkMzgwMGEyODg3OUAA8ANh
Y2M1MDBjMzAwNGMwMGViNmJGAGA5MGVjNDIKACBiMsAAoDY0ZGZmNjAwYmSJAACWAEAwZGFiQABf
ODU2ZDABAMawMWUzNzNjMDAzNzQnASEwMwEAMTAwMgEAoDAwMTYxNjE2Iik=
:: pal/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTEwIDA0OjUyOjUxIixzdG9yZWQ9IjIwMjQtMDQt
MTAgMDQ6NTI6NTEiXV1sejQABAAAAAMAAAAwbmls
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTExIDE3OjI1OjAxIixtb2RpZmllZD0iMjAyNC0w
NC0xMSAxNzoyNTowMSIscmV2aXNpb249MF1dbHo0ACUBAABQCAAA8CdweHUAAygAAAMABA9AEAIO
AAGgASACoA4ADxAADfDKAQIDBAUGBwAP-5AICQoLDwwPDQ8ODw8QAPAADQ8RDxIPEw8UDxUPFg8X
EwDxAQ8YDxkPGg8bDxwPHQ8eDx8UAPEAIA8hDyIPIw8kDyUPJg8nFADxACgPKQ8qDysPLA8tDy4P
LxQA8QAwDzEPMg8zDzQPNQ82DzcUAP8FOA85DzoPOw88Dz0PPg8-AA--8P8BAOv-J1oBEAYPIBAB
IAEgAfAAAhACDBABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDDAA--_6H-8BAMzx
COgPQAANQA8wDzIPNP--LSH_LSz_LfBwFgBf-rDwcAMIAP-cH-8BAJdQ-----x8=
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2IixzdG9yZWQ9IjIwMjQtMDMt
MjQgMDA6NDg6MDYiXV1sejQABAAAAAMAAAAwbmls
:: src/constants.lua
--[[pod_format="raw",created="2024-04-10 15:52:04",modified="2024-04-11 17:25:01",revision=689]]
local constants = {}


constants.piano_keys = {
	{
		offset = -12,
		[0] = "z", "s", "x", "d", "c", "v", "g", "b", "h", "n", "j", "m",
		",", "l", ".", ";", "/"
	},
	{
		offset = 0,
		[0] = "q", "2", "w", "3", "e", "r", "5", "t", "6", "y", "7", "u",
		"i", "9", "o", "0", "p", "[", "=", "]",
	}
}


constants.isomorphic_keys = {
	{
		offset = -5,
		[0] = "z", "x", "c", "v", "b", "n", "m", ",", ".", "/",
	},
	{
		offset = 0,
		[0] = "a", "s", "d", "f", "g", "h", "j", "k", "l", ";",
	},
	{
	offset = 5,
		[0] = "q", "w", "e", "r", "t", "y", "u", "i", "o", "p",
	}
}


return constants
:: src/file.lua
--[[pod_format="raw",created="2024-04-07 08:14:09",modified="2024-04-11 17:25:01",revision=1240]]
local M = {}


--M.default_filename = "/ram/cart/sfx/0.visitrak"
M.default_filename = "/ram/cart/sfx/0.sfx"


function M.save()
	local ud = userdata("u8", 0x30000)
	for i = 0, 0x2ffff do
		ud[i] = peek(0x30000 + i)
	end
	return ud
end


function M.load(ud)
	if type(ud) != "userdata" then
		init_data()
	else
		for i=0,0x2ffff do
			poke(0x30000+i, ud[i])
		end
	end
	tdat = {}
---			init_undo()
end


-- Initialisation ----------------------------------------------------------------


-- copied from "/system/apps/sfx.lua" in Picotron 0.0.1e
function init_data()
	
	-- index (0x30000)
	
	-- first 3 values are almost metadata only -- not currently
	-- acted on anywhere. perhaps useful in future for deciding
	-- scope of copy/paste, and gui cues, but can be calculated
	-- from content.
	
	poke2(0x30000,
		64,  -- num_instruments
		512, -- num_tracks (64 patterns * 8 channels for default indexing)
		64,  -- num_patterns
		-- flags: 0x1 use default track indexing (base+0x20000, increments of 328 bytes)
		0x1
	)
	poke4(0x30010,
		0x10000, -- insts_addr      (I32)    relative address of instruments
		0x20000, -- tracks_addr     (I32)    relative address of track index
		0,       -- patterns_addr   (I32)    relative address of pattern data
		0        -- unused          (I32)    should be 0
	)
	poke2(0x30020,
		0,  -- tick len (0 for default -- custom vals not supported yet)
		64, -- default track length
		16 -- default track spd
	)
	
	-- default track speed (+3 unused)
	poke(0x30026, 16, 0, 0, 0) 
	
	-- pattern data: first 8 patterns
	
	for pp = 0,7 do
		local addr = 0x30100 + pp * 20
		for i = 0, 7 do
			poke(addr+i, pp*8 + i)
		end
		poke(addr+8, 0x0)  -- flow flags
		poke(addr+9, 0xff) -- channel mask
		poke(addr+10, 0,0) -- length (I16)
		
	end
	
	
	----------------------------------------------------------------------------
	-- single instrument at 0x40000 (instrument 0)
	
	-- node 0: root
	poke(0x40000 + (0 * 32), -- instrument 10node 0
	
			0,    -- parent (0x7)  op (0xf0)
			1,    -- kind (0x0f): 1 root  kind_p (0xf0): 0  -- wavetable_index
			0,    -- flags
			0,    -- unused extra
				
			-- MVALs:  kind/flags,  val0, val1, envelope_index
			
			0x2|0x4,0x20,0,0,  -- volume: mult. 0x40 is max (-0x40 to invert, 0x7f to overamp)
			0x1,0,0,0,     -- pan:   add. center
			0x1,0,0,0,     -- tune: +0 -- 0,48,0,0 absolute for middle c (c4) 261.6 Hz
			0x1,0,0,0,     -- bend: none
			-- following shouldn't be in root
			0x0,0,0,0,     -- wave: use wave 0 
			0x0,0,0,0      -- phase 
	)
	
	
	-- node 1: sine
	poke(0x40000 + (1 * 32), -- instrument 0, node 1
	
			0,    -- parent (0x7)  op (0xf0)
			2,    -- kind (0x0f): 2 osc  kind_p (0xf0): 0  -- wavetable_index
			0,    -- flags
			0,    -- unused extra
				
			-- MVALs:  kind/flags,  val0, val1, envelope_index
			
			0x2,0x20,0,0,  -- volume: mult. 0x40 is max (-0x40 to invert, 0x7f to overamp)
			0x1,0,0,0,     -- pan:   add. center
			0x21,0,0,0,    -- tune: +0 -- 0,48,0,0 absolute for middle c (c4) 261.6 Hz
			               -- tune is quantized to semitones with 0x20
			0x1,0,0,0,     -- bend: none
			0x0,0x40,0,0,  -- wave: triangle
			0x0,0,0,0      -- phase 
	)
	
	

	-- wavetable
	for i=0,7 do
	poke(0x40000 + 0x1e0,
		0x00, -- address (low)  in 256 byte increments
		0xf8, -- address (high) in 64k increments
		0x0a, -- samples (1 << n) 1024
		0xff,  -- wt_height 256(0); wave mval points at one of the entries
		
		-- to do: update (is garbage now?)
		0x80,
		0xf7,
		0x0d, -- samples (1 << n) 8192
		0x01
	)
	end

	-- envelope 0 inst 1
	
	poke(0x40000 + 0x100,
		0,0,0,0, 0,0,0,0,
		0,40,255,0 -- adsr
	)
	
	-- copy default instrument to 1..15
	for i=1,15 do
		memcpy(0x40000 + 0x200*i, 0x40000, 0x200)
	end
	
	--------------------------------------------------
	-- Track Data  0x50000
	--------------------------------------------------
	
	-- Default track size is 5 * 64 rows + 8 = 328 bytes
	
	-- header (8)
	local addr = 0x50000
	poke2(addr, 64) -- len
	poke(addr+2,16) -- spd
	poke(addr+3,0)  -- loop0
	poke(addr+4,0)  -- loop1
	poke(addr+5,0)  -- delay
	poke(addr+6,0)  -- flags (0x1 mute)
	poke(addr+7,0)  -- unused
	
	-- pitch, inst, vol: not set (0xff)
	memset(addr+8, 0xff, 64*3)
	
	-- copy to other tracks
	for i=1,63 do
		memcpy(0x50000 + i*328, 0x50000, 328)
	end
end


return M
:: src/piano_roll.lua
--[[pod_format="raw",created="2024-04-10 15:48:56",modified="2024-04-10 16:19:15",revision=44]]
local M = {}


function M.attach_piano_roll(parent, el)
	el.width = 480
	el.height = 270 - 11 - 16 - 1
	parent:attach(el)

	function el:draw()
		rectfill(0, 0, self.width, self.height, 21)
	end	

	return el
end


return M
:: src/settings.lua
--[[pod_format="raw",created="2024-04-11 08:58:08",modified="2024-04-11 17:25:01",revision=416]]
local constants = require "src/constants"


local settings = {}

--[[
settings.keys = {
	pitched = constants.piano_keys,
	rest = constants.piano_rest,
	unspec = constants.piano_unspec,
}
--]]
---[[
settings.keys = {
	pitched = constants.piano_keys,
	play = "space",
	rest = "enter",
}
--]]


return settings
:: src/sfx.lua
--[[pod_format="raw",created="2024-04-07 08:22:05",modified="2024-04-11 17:25:01",revision=750]]
local sfx = {}


local sfx_index = 0x030000
local sfx_instr = 0x040000
local sfx_track = 0x050000
local sfx_wave = 0xf00000 -- maybe not? (search discord)


local num_instrument = 0
local num_tracks = 0
local num_patterns = 0
local header_flags = 0
local insts_addr = 0
local tracks_addr = 0
local patterns_addr = 0


function sfx.read_header()
	num_instruments = peek2(sfx_index)
	num_tracks = peek2(sfx_index + 2)
	num_patterns = peek2(sfx_index + 4)
	header_flags = peek2(sfx_index + 6)
	-- unused: peek2(sfx_index + 8)
	insts_addr = peek4(sfx_index + 10)
	tracks_addr = peek4(sfx_index + 14)
	patterns_addr = peek4(sfx_index + 18)
	?header_flags
	?string.format("%x", insts_addr)
	?string.format("%x", tracks_addr)
	?string.format("%x", patterns_addr)
end


function sfx.channel_is_muted(pattern, channel)
	local channel_mutes = peek(0x30100 + (pattern * 20) + 9)
	local muted = (channel_mutes & (1 << channel)) == 0
	return muted
end


function sfx.mute_channel(pattern, channel, mute)
	local channel_mutes = peek(0x30100 + (pattern * 20) + 9)
	channel_mutes &= ~(1 << channel)
	channel_mutes |= (mute and 0 or 1) << channel
	poke(0x30100 + (pattern * 20) + 9, channel_mutes)
end

return sfx
:: src/synth.lua
--[[pod_format="raw",created="2024-04-10 15:43:44",modified="2024-04-11 17:25:01",revision=442]]
local settings = require "src/settings"

local M = {}


function M.attach_synth(parent, el)
	el.width = 480
	el.height = 270 - 11 - 16 - 1
	parent:attach(el)

	function el:draw()
		rectfill(0, 0, self.width, self.height, 21)
	end	
	
	function el:update()
		local pitch_key = nil
		for i = 1, #settings.keys.pitched do
			local offset = settings.keys.pitched[i].offset
			for j = 0, #settings.keys.pitched[i] do
				local k = settings.keys.pitched[i][j]
				if key(k, true) then
					pitch_key = j + offset
				end
			end
		end
		if pitch_key then
			local pitch = pitch_key + 48
			if key("shift") then
				pitch += 12
			end
			pitch = mid(0, pitch, 0xfe)
			note(
				pitch, -- todo
				0, -- current_instrument
				50, -- current_volume
				ord(" "), 0x00, -- fx, fx param
				8, -- channel 8 so it can play with pattern
				false -- don't force retrigger
			)
		else
			note(0xff, 0xff, 0xff, 0xff, 0xff, 8)
		end
	end

	return el
end


return M
:: src/tracker.lua
--[[pod_format="raw",created="2024-04-10 10:06:40",modified="2024-04-11 17:25:01",revision=1704]]
local constants = require "src/constants"
local sfx = require "src/sfx"


local tracker = {}


-- (Also in tracker_grid.lua)
local ruler_height <const> = 9
local channel_panel_width <const> = 16
local cell_width <const> = 20
local cell_height <const> = 29


tracker.pattern = 0

tracker.base_note = 48
tracker.base_volume = 0x32
tracker.base_instrument = 01

tracker.input_buffer = ""


-- Channel panel -------------------------------------------------------------------


function tracker.attach_channel_panel(parent, el)
	el.width = channel_panel_width
	el.height = 270 - 11 - 16 - 2
	parent:attach(el)

	--[[
	el.fields = {}
	for channel = 0, 7 do
		local oy = ruler_height + channel * cell_height
		local track_id = peek(0x30100 + tracker.pattern * 20 + channel)
		el.fields[channel] = el:attach_text_editor {
			x = 1, y = oy,
			width = 14,
			height = 10,
			max_lines = 1,
			syntax_highlighting = false,
			show_line_numbers   = false,
			markup     = false,
			embed_pods = false,
			has_search = false,
			bgcol = 59,	
			fgcol = 22,
			key_callback = {
				enter = function() return true end
			},
			click = function() return true end,
			tap = function() return true end
		}
		el.fields[channel]:set_text(string.format("%d", track_id))
	end
	--]]
	
	function el:draw()
		rectfill(0, 0, self.width, self.height, 21)
		line(self.width - 1, ruler_height - 1, self.width - 1, self.height, 5)
		for channel = 0, 7 do
			local oy = ruler_height + channel * cell_height
			local track_id = peek(0x30100 + tracker.pattern * 20 + channel)
			local is_dragged = self.dragged and self.dragged.channel == channel
			if is_dragged then
				rectfill(0, oy + 1, 14, oy + 9, 17)
			end
			print(string.format("\014%03d", track_id), 2, oy + 3, 5)
			print(string.format("\014% 3d", track_id), 2, oy + 3, is_dragged and 7 or 22)
			spr(sfx.channel_is_muted(tracker.pattern, channel) and 32 or 33, 4, oy + 12)
		end
	end
	
	function el:hover(msg)
		local channel = (msg.my - ruler_height) \ cell_height
		local part = (msg.my - ruler_height) % cell_height
		if part < 10 then
			self.cursor = "pointer"
		else
			self.cursor = 1
		end
	end
	
	function el:click(msg)
		self:set_keyboard_focus(true)
		local channel = (msg.my - ruler_height) \ cell_height
		local part = (msg.my - ruler_height) % cell_height
		if part < 10 then
			local track_id = peek(0x30100 + tracker.pattern * 20 + channel)
			self.dragged = { channel = channel, y0 = msg.my, id0 =  track_id}
		elseif part < 20 then
			sfx.mute_channel(
				tracker.pattern,
				channel,
				not sfx.channel_is_muted(tracker.pattern, channel)
			)
		end
	end
	
	function el:drag(msg)
		if self.dragged then
			local delta = msg.my - self.dragged.y0
			local track_id = self.dragged.id0 - math.floor(0.5 + ((delta + 3) \ 6))
			track_id = mid(0, track_id, 0xff)
			poke(0x30100 + tracker.pattern * 20 + self.dragged.channel, track_id)
		end
	end
	
	function el:release(msg)
		self.dragged = nil
	end
		
	return el
end


function tracker.attach_pattern_flow_toggles(parent, el)
	el.width = 36 + 1
	el.height = 16
	el.cursor = "pointer"
	parent:attach(el)

	function el:draw()
		if (peek(0x30100 + (tracker.pattern * 20) + 8) & 0x01) == 0 then
			pal(7, 59)
		else
			pal(7, 17)
		end
		spr(40, 2, 4)
		if (peek(0x30100 + (tracker.pattern * 20) + 8) & 0x02) == 0 then
			pal(7, 59)
		else
			pal(7, 17)
		end
		spr(41, 2 + 12, 4)
		if (peek(0x30100 + (tracker.pattern * 20) + 8) & 0x04) == 0 then
			pal(7, 59)
		else
			pal(7, 17)
		end
		spr(42, 2 + 24, 4)
		pal(7, 7)
	end	

	return el
end


-- Default note attributes -------------------------------------------------------


function tracker.attach_note_attributes(parent, el)
	el.width = 54
	el.height = 16
	el.cursor = "pointer"
	parent:attach(el)
	
	el.drag_start = nil

	function el:draw()
--		rectfill(0, 0, self.width, self.height, 0)
		local note = tracker.base_note % 12
		local octave = tracker.base_note \ 12
		local is_sharp = (note == 1) or (note == 3) or (note == 6)
			or (note == 8) or (note == 10)
		pal(7, self.dragged_note and 7 or 7)
		if is_sharp then
			spr(8 + note, 2, 6)
		else
			spr(8 + note, 8, 6)
		end
		pal(7, 7)
		print(
			"\014" .. string.format("%1x", octave),
			2 + 12, 7,
			self.dragged_note and 7 or 22
		)
		local x = 20
		rectfill(x, 8, x + 20, 10, 59)
		rectfill(
			x, 8,
			x + min(20 * (tracker.base_volume / 64), 20), 10,
			self.dragged_volume and 7 or 17
		)
		if self.dragged_volume then
			print("\014" .. string.format("%2d", tracker.base_volume), 27, 2, 7)
		end
		print(
			"\014" .. string.format("%d", tracker.base_instrument),
			44, 7,
			self.dragged_instrument and 7 or 14 -- col 26
		)
	end	
	
	function el:click(msg)
		-- TODO: replace with pull-down menus
		if msg.mx < 18 then
			self.dragged_note = {
				y0 = msg.my,
				start = tracker.base_note
			}
		elseif msg.mx < 42 then
			self.dragged_volume = {
				y0 = msg.my,
				start = tracker.base_volume
			}
		else
			self.dragged_instrument = {
				y0 = msg.my,
				start = tracker.base_instrument
			}
		end
	end
	
	function el:drag(msg)
		if self.dragged_note then
			local delta = msg.my - self.dragged_note.y0
			if (delta == 0) return -- or else double click doesn't work
			local new_val = self.dragged_note.start - (((delta + 3) \ 6) * 12)
			tracker.base_note = mid(0, new_val, 120)
		elseif self.dragged_volume then
			local delta = msg.my - self.dragged_volume.y0
			if (delta == 0) return -- or else double click doesn't work
			local new_val = self.dragged_volume.start - (((delta + 1) \ 2) * 1)
			tracker.base_volume = mid(0, new_val, 0x40) -- TODO: handle vol > 64
		elseif self.dragged_instrument then
			local delta = msg.my - self.dragged_instrument.y0
			if (delta == 0) return -- or else double click doesn't work
			local new_val = self.dragged_instrument.start - (((delta + 3) \ 6) * 1)
			tracker.base_instrument = mid(0, new_val, 0xfe) -- TODO: handle vol > 64
		end
	end
	
	function el:release(msg)
		self.dragged_note = nil
		self.dragged_volume = nil
		self.dragged_instrument = nil
	end

	function el:doubleclick(msg)
		if msg.mx < 18 then
			notify("***")
			tracker.base_note = 48
		elseif msg.mx < 42 then
			tracker.base_volume = 0x32
		else
			tracker.base_instrument = 01
		end
	end
	
	return el
end


-- Pattern selector ----------------------------------------------------------------


function tracker.attach_pattern_selector(parent, el)
	el.width = 19 * 14
	el.height = 16
	el.cursor = "pointer"
	parent:attach(el)

	function el:draw()
		local playing_pattern = stat(466)
		for p = 0, 18 do
			if p == 0 then
				spr(43, 5, 5)
			elseif p < 18 then
				rectfill(
					p * 14, 4,
					14 + p * 14, 12, 
					(p - 1) == playing_pattern and 17 or 59
				)
				print(
					string.format("\014%02d", p - 1),
					3 + p * 14, 6,
					(p - 1) == tracker.pattern and 7 or 22
				)
			else
				spr(44, 3 + p * 14, 5)
			end
		end
	end	
	
	function el:click(msg)
		local p = msg.mx \ 14
		if p == 0 then
			-- TODO
		elseif p < 18 then
			tracker.pattern = p - 1
		else
			-- TODO
		end
	end

	return el
end


return tracker
:: src/tracker_grid.lua
--[[pod_format="raw",created="2024-04-11 06:36:17",modified="2024-04-11 17:25:01",revision=712]]
local settings = require "src/settings"
local sfx = require "src/sfx"
local tracker = require "src/tracker"


local tracker_grid = {}


-- (Also in tracker.lua)
local ruler_height <const> = 9
local channel_panel_width <const> = 16
local cell_width <const> = 20
local cell_height <const> = 29


function tracker_grid.attach(parent, el)
	el.width = 480 - channel_panel_width
	el.height = 270 - 11 - 16 - 1
	parent:attach(el)
	
	el.x_start = -(cell_width \ 2)
	el.drag_start = nil
	el.selection = { channel = 0, step = 0, part = 0 }
	
	el:set_keyboard_focus(true)
	tracker.input_buffer = ""
	
	-- Draw ------------------------------------------------------------------------

	function el:draw()
		local pattern_is_playing = (stat(464) != 0)  and (stat(466) == tracker.pattern)
		-- Ruler background
		rectfill(0, 0, self.width, ruler_height - 2, 21)
		line(0, ruler_height - 1, self.width, ruler_height - 1, 5)
		local step_start = self.x_start \ cell_width
		local delta_x = - (self.x_start % cell_width)
		if step_start < 0 then
			step_start = 0
			self.x_start = max(- (cell_width \ 2) , self.x_start)
			delta_x = - self.x_start
		end
		for channel = 0, 7 do
			local oy = ruler_height + channel * cell_height
			rectfill(
				0, oy, self.width,
				oy + cell_height - 1,
				((channel % 2) == 0) and 63 or 62
			)
			if sfx.channel_is_muted(tracker.pattern, channel) then
				goto continue
			end
			local track = peek(0x30100 + tracker.pattern * 20 + channel)
			for step = 0, 24 do
				if step_start + step > 63 then break end
				local ox = delta_x + step * cell_width + 1
				if pattern_is_playing and stat(400 + channel, 9) == step_start + step then
					rectfill(ox, oy, ox + cell_width - 2, oy + cell_height - 1, 19)
				end
				if self:has_keyboard_focus() and
					self.selection and self.selection.channel == channel
						and self.selection.step == step_start + step
				then
					spr(24 + self.selection.part, ox, oy)
				end
				-- TODO: support track length > 64
				local base_addr = 0x50000 + 8 + (track * 328) + step_start + step
				local freq = peek(base_addr)
				local inst = peek(base_addr + 64)
				local vol  = peek(base_addr + (2 * 64))
				local fx   = peek(base_addr + (3 * 64))
				local fxp  = peek(base_addr + (4 * 64))
				-- Note and octave
				if freq != 0xff then
					local note = freq % 12
					local is_sharp = (note == 1) or (note == 3) or (note == 6)
						or (note == 8) or (note == 10)
					local x = is_sharp and (ox + 2) or (ox + 2) -- 5
					spr(8 + note, x, oy + 2)
					local x_oct = is_sharp and (ox + 14) or (ox + 8) -- 11
					if (freq \ 12) <= 9 then
						print("\014" .. tostr(freq \ 12), x_oct, oy + 3, 13) 
					else
						print("\014?", ox + 14, oy + 3, 13) 
					end
				else
--					print("\014.", ox + 2, oy + 3, 7)
					print("\014.", ox + 2, oy, 7)
				end
				-- Volume
				if vol != 0xff then
					local w_vol = (vol / 64) * (cell_width - 6)
					w_vol = min(w_vol, cell_width - 6)
					if w_vol == 0 and vol != 0 then
						w_vol = 1
					end
					rectfill(ox + 2, oy + 10, ox + 2 + cell_width - 6, oy + 12, 5)
					if w_vol > 0 then
						rectfill(ox + 2, oy + 10, ox + 2 + w_vol, oy + 12, 17) -- col 22
					end
					-- TODO: support vol > 64
				else
--					print("\014.", ox + 2, oy + 7, 22)
					print("\014.", ox + 2, oy + 7, 22)
				end
				-- Instrument
				local x = 8
				if inst != 0xff then
					if inst > 99 then
						x -= 4
					elseif inst > 9 then
						x -= 2
					end
					x = 2
					print("\014" .. string.format("%d", inst), ox + x, oy + 15, 14) -- 26
				else
					print("\014.", ox + 2, oy + 15, 22)
				end
				-- Effect
				if false then
					print("\014" .. fx, ox + 2, oy + 22, 22)
				else
					print("\014.", ox + 2, oy + 22, 22)
				end
			end
			::continue::
		end
		-- Bar lines
		for step = 0, 24 do
			if step_start + step > 63 + 1 then break end
			local ox = delta_x + (step * cell_width)
			local bar = (step_start + step) \ (4 * 4) + 1
			local beat = ((step_start + step) \ 4) % 4 + 1
			if (step_start + step) % 4 == 0 then
				if ((step_start + step) \ 4) % 4 == 0 then
					line(ox, 0, ox, self.height - 2, 22)
					print("\014" .. bar .. "." .. beat, ox + 2, 2, 22)
				else
					line(ox, 0, ox, self.height - 2, 5)
					print("\014" .. bar .. "." .. beat, ox + 2, 2, 5)
				end
			else
				--[[
				poke(0x550b, 0x3f)
				fillp(0b0000000011111111)
				line(ox, ruler_height, ox, self.height - 2, 5)
				fillp()
				poke(0x550b, 0x00)
				--]]
			end
		end
	end
	
	-- Mouse --------------------------------------------------------------------
	

	function el:hover(msg)
		if msg.my <= ruler_height then
			self.cursor = "grab"
		else
			self.cursor = 1
		end
	end
	

	function el:click(msg)
		if msg.my < ruler_height or msg.mb == 4 then
			self.drag_start = self.x_start + msg.mx
			self.cursor = "grab"
		elseif msg.mb == 1 then
			self:kbd_focus()
			local step = (msg.mx + self.x_start) \ cell_width
			local channel = (msg.my - ruler_height) \ cell_height
			if
				(0 <= channel) and (channel <= 7)
					and (0 <= step) and (step <= 63) -- TODO: handle track length
			then
				self.selection = { part = 0 }
				local y = (msg.my - ruler_height) % cell_height
				if y > 20 then
					self.selection.part = 3
				elseif y > 14 then
					self.selection.part = 2
				elseif y > 8 then
					self.selection.part = 1
				end
				self:goto_channel(channel)
				self:goto_step(step)
			else
				self.selection = nil
			end
		end
	end
	

	function el:drag(msg)
		if self.drag_start then
			self.x_start = self.drag_start - msg.mx
		end
	end
	

	function el:release(msg)
		self.drag_start = nil
		self.cursor = 1
	end
	
	
	function el:mousewheel(msg)
		self.x_start -= msg.wheel_y * cell_width
	end
	
	-- Update -----------------------------------------------------------------
	

	function el:update()
		if not self:has_keyboard_focus() then
			self.selection = nil
		end	
		
		if self.note_playing then
			-- TODO: should be in main.lua (bug when switching view during note)
			if self.note_playing.tick > 10 then
				note(0xff, 0xff, 0xff, 0xff, 0xff, self.note_playing.channel)
				self.note_playing = nil
			else
				self.note_playing.tick += 1
			end
		end
		
		if (keyp("pageup")) self:kbd_focus(); self:goto_previous_channel()
		if (keyp("pagedown")) self:kbd_focus(); self:goto_next_channel()
		if (keyp("up")) self:kbd_focus(); self:goto_previous_part()
		if (keyp("down")) self:kbd_focus(); self:goto_next_part()
		if (keyp("left")) self:kbd_focus(); self:goto_previous_step()
		if (keyp("right")) self:kbd_focus(); self:goto_next_step()

		if self.selection then
			self:handle_positioned_key()
		end
	end


	function el:handle_positioned_key()
		local keys = settings.keys
		
		local track = peek(0x30100 + tracker.pattern * 20 + self.selection.channel)
		local base_addr = 0x50000 + 8 + (track * 328) + self.selection.step
		
		-- Pitched input
		local pitch_key = nil
		for i = 1, #settings.keys.pitched do
			local offset = settings.keys.pitched[i].offset
			for j = 0, #settings.keys.pitched[i] do
				local k = settings.keys.pitched[i][j]
				if keyp(k, true) then
					pitch_key = j + offset
				end
			end
		end
		
		local num_key = keyp_num()
		local hex_key = keyp_hex()
				
		-- Buffered hexadecimal input
		--[[
		local hexa_val = nil
		while peektext() do
			local k = readtext()
			if is_hexa_char(k) then
				tracker.input_buffer ..= k
			else
				tracker.input_buffer = ""
			end
		end
		if #tracker.input_buffer == 1 and keyp("enter") then
			tracker.input_buffer = "0" .. tracker.input_buffer
		end
		if #tracker.input_buffer >= 2 then
			local v = tonum("0x" .. sub(tracker.input_buffer, 1, 2))
			hexa_val = min(v, 0xff)
			tracker.input_buffer = sub(tracker.input_buffer, 3, -1)
		end
		]]
		
		-- Part-specific input
				
		if self.selection.part == 0 then
			local note = peek(base_addr) % 12
			if key("shift") and num_key then
				local pitch = note + num_key * 12
				pitch = mid(0, pitch, 0xfe)
				poke(base_addr, pitch)
				self:goto_next_step()
			elseif pitch_key then
				local pitch = pitch_key + tracker.base_note
				if key("shift") then
					pitch += 12
				end
				pitch = mid(0, pitch, 0xfe)
				poke(base_addr, pitch)
				poke(base_addr + (2 * 64), tracker.base_volume)
				poke(base_addr + (1 * 64), tracker.base_instrument)
				-- TODO fx and fxp
				self:play_selection()
				self:goto_next_step()
			elseif keyp(keys.rest) and key("shift") then
				poke(base_addr, 0xff)
				self:goto_next_step()
			elseif keyp(keys.rest) then
				poke(base_addr, 0xff)
				poke(base_addr + (2 * 64), 0xff)
				poke(base_addr + (1 * 64), 0xff)
				-- TODO fx and fxp
				self:goto_next_step()
			end
			
		elseif self.selection.part == 1 then
			if num_key then
				local vol = math.floor(((hex_key / 9) * 64) + 0.5)
				if key("shift") then
					vol += 64
				end
				notify("" .. vol)
				poke(base_addr + (2 * 64), vol)
				self:goto_next_step()
			elseif keyp(keys.rest) then
				poke(base_addr + (2 * 64), 0xff)
				self:goto_next_step()
			end
			
		elseif self.selection.part == 2 then
			if num_key then
				local inst = peek(base_addr + (1 * 64))
				if (inst == 0xff) inst = 0
				if key("shift") then
					inst = (hex_key * 10) + (inst % 10)
				else
					inst = ((inst \ 10) * 10) + num_key
				end
				poke(base_addr + (1 * 64), inst)
				self:goto_next_step()
			elseif keyp(keys.rest) then
				poke(base_addr + (1 * 64), 0xff)
				self:goto_next_step()
			end
		--[[
		elseif self.selection.part == 3 then
			if hexa_val then
				poke(base_addr + (4 * 64), hexa_val)
				self:goto_next_step()
			elseif keyp(keys.rest) then
				poke(base_addr + (4 * 64), 0xff)
				self:goto_next_step()
			end
		]]
		end
		
		-- Non part-specific input
		
		if keyp("backspace") then
			self:goto_previous_step()
			local base_addr = 0x50000 + 8 + (track * 328) + self.selection.step
			poke(base_addr, 0xff)
			poke(base_addr + (2 * 64), 0xff)
			poke(base_addr + (1 * 64), 0xff)
			-- TODO: fx and fxp
			-- poke(base_addr + (3 * 64), 0xff)
			-- poke(base_addr + (4 * 64), 0xff)
		end
	end


	function el:kbd_focus()
		self:set_keyboard_focus(true)
		tracker.input_buffer = ""
	end
	

	function el:goto_previous_part()
		if not self.selection then
			self:goto_start()
		elseif self.selection.part > 0 then
			self.selection.part -= 1
		elseif self.selection.channel > 0 then
			self.selection.part = 3
			self:goto_previous_channel()
		end
	end


	function el:goto_next_part()
		if not self.selection then
			self:goto_start()
		elseif self.selection.part < 3 then
			self.selection.part += 1
		elseif self.selection.channel < 7 then
			self.selection.part = 0
			self:goto_next_channel()
		end
	end
	
	
	function el:goto_previous_channel()
		-- TODO: skip muted
		if not self.selection then
			self:goto_start()
		elseif self.selection.channel > 0 then
			self:goto_channel(self.selection.channel - 1)
		end
	end
	
	
	function el:goto_next_channel()
		-- TODO: skip muted
		if not self.selection then
			self:goto_start()
		elseif self.selection.channel < 7 then
			self:goto_channel(self.selection.channel + 1)
		end
	end	

	

	function el:goto_previous_step()
		if not self.selection then
			self:goto_start()
		elseif self.selection.step > 0 then
			self:goto_step(self.selection.step - 1)
		end
	end
		

	function el:goto_next_step()
		if not self.selection then
			self:goto_start()
		elseif self.selection.step < 63 then -- TODO: handle track length
			self:goto_step(self.selection.step + 1)
		end
	end
	

	function el:goto_start()
		self.selection = { part = 0 }
		self:goto_channel(0)
		self:goto_step(0)
	end


	function el:goto_channel(c)
		-- TODO check if channel is muted
		self.selection.channel = c
	end
	

	function el:goto_step(s)
		local offset = 2 -- cell_width \ 2
		self.selection.step = s
		-- TODO: pagination by bars?
		if
			self.x_start > ((self.selection.step * cell_width) - offset)
		then
			self.x_start = self.selection.step * cell_width - offset
		elseif
			self.x_start + self.width < ((self.selection.step + 1) * cell_width) + offset
		then
			self.x_start = ((self.selection.step + 1) * cell_width) + offset - self.width
		end
	end
	

	function el:play_selection()
		if self.selection and stat(464) == 0 then
			local track = peek(0x30100 + tracker.pattern * 20 + self.selection.channel)
			local base_addr = 0x50000 + 8 + (track * 328) + self.selection.step
			local pitch = peek(base_addr)
			local inst = peek(base_addr + 64)
			local vol  = peek(base_addr + (2 * 64))
			local fx   = peek(base_addr + (3 * 64))
			local fxp  = peek(base_addr + (4 * 64))
			note(
				pitch,
				inst,
				vol,
				ord(" "), 0x00, -- fx, fx param
				self.selection.channel,
				false
			)
			self.note_playing = { channel = self.selection.channel, tick = 0 }
		end
	end
	

	return el
end


return tracker_grid
:: src/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTA3IDA4OjE0OjAwIixzdG9yZWQ9IjIwMjQtMDQt
MDcgMDg6MTQ6MDAiXV1sejQABAAAAAMAAAAwbmls
:: todo.txt
--[[pod_format="raw",created="2024-04-10 20:46:30",modified="2024-04-10 20:46:41",revision=1]]
- add 4/4 config

:: .info.pod
b64$LS1bW3BvZCxhdXRob3I9ImRyYWttYW5pc28iLGljb249dXNlcmRhdGEoInU4IiwxNiwxNiwi
MDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDcw
NzAxMDAwMDAwMDEwNzBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwMTAwMDEwNzBkMGQwZDBkMGQwZDA3
MGQwZDBkMGQwZDA3MDEwMTA3MGQwZDBkMGQwZDBkMDcwNzBkMGQwZDBkMDcwMTAxMDcwZDBkMGQw
ZDBkMGQwNzBkMDcwZDBkMGQwNzAxMDEwNzBkMGQwZDBkMGQwZDA3MGQwNzBkMGQwZDA3MDEwMTA3
MGQwZDBkMGQwNzA3MDcwZDBkMGQwZDBkMDcwMTAxMDcwZDBkMGQwNzA3MDcwNzBkMGQwZDBkMGQw
NzAxMDEwNzBkMGQwZDBkMDcwNzBkMGQwZDBkMGQwZDA3MDEwMTA3MGQwZDBkMGQwZDBkMGQwZDBk
MGQwZDBkMDcwMTAxMDYwNzBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwNjAxMDEwNjA2MDcwNzA3MDcw
NzA3MDcwNzA3MDcwNjA2MDEwMDAxMDYwNjA2MDYwNjA2MDYwNjA2MDYwNjA2MDEwMDAwMDAwMTA2
MDYwNjA2MDYwNjA2MDYwNjA2MDEwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAi
KSxub3Rlcz0iTXVzaWMgVHJhY2tlciIscnVudGltZT01LHN0b3JlZD0iMjAyNC0wNC0xMSAxNzoy
NTowMSIsdGl0bGU9IlZpc2lUcmFjayIsdmVyc2lvbj0iMC4wLjEiLHdvcmtzcGFjZXM9e3tsb2Nh
dGlvbj0ibWFpbi5sdWEjMTQzIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJzcmMvdHJh
Y2tlci5sdWEjOTciLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InNyYy90cmFja2VyX2dy
aWQubHVhIzE5MyIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ic3JjL2ZpbGUubHVhIzUi
LHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InNyYy9jb25zdGFudHMubHVhIzMzIix3b3Jr
c3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJzcmMvc2V0dGluZ3MubHVhIzE2Iix3b3Jrc3BhY2Vf
aW5kZXg9MX0se2xvY2F0aW9uPSJzcmMvc2Z4Lmx1YSM0NiIsd29ya3NwYWNlX2luZGV4PTF9LHts
b2NhdGlvbj0ic3JjL3N5bnRoLmx1YSM0MSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0i
Z2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn0se2xvY2F0aW9uPSJtYXAvMC5tYXAiLHdvcmtz
cGFjZV9pbmRleD0zfSx7bG9jYXRpb249InNmeC8wLnNmeCIsd29ya3NwYWNlX2luZGV4PTR9fV1d
bHo0AAQAAAADAAAAMG5pbA==
:: [eoc]
