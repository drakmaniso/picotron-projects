picotron cartridge // www.picotron.net
version 2

:: gfx/
:: map/
:: sfx/
:: src/
:: pal/
:: vgfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2Iixtb2RpZmllZD0iMjAyNC0w
NC0yMSAxNjoxNToxMyIscmV2aXNpb249ODI3M11dbHo0ADcGAACjNwAA8yV7WzBdPXtibXA9cHh1
AEMgCAgEQAdgF1AHAAdABwAHICcwN0AXoCxmbGFncz0wLHBhbl94CADHeT0wLHpvb209OH0sQgDx
DyIIBPATBzAHAPcDAAcQByAHIAdgB9AHAAcwBxAHAAQAYAAHIBcAFwQAEUAYAAAaAAFuAAAOACMX
ICQAQBAHICcUAABEABMwOgARECQAIBAXGAAv8BOXAAsZMZcA9QIQEATwKyeQV2BXEAdgJ0AHYAIA
-wFAJ2AHMDdAJ0AXQDfAF-AbVgALHTlWAPYHJBfABxAHsAcQB6AHMAeQBzAHgBcABwIAE4AWABOg
JgBPwBfwFGQAHfIGIq8RMM4gTgduIE4XXiBOJ04gTjc_CAAhF14YAF-OMK7wE1cAHp2uMM4gziA_
Rz4EAB-OUgAjH-AxAErgCwYEACdgByAHUAeQB5BaAi8nYEAACx43QAARIJYBUSAHAFdQCgAiQFdy
Ah8QTAAeEjeLAAcEAB83QwAeBo4AAoYACQwAD08AHmBHUAeQJ3AdAS9HUDsAIEAHkDdgBgAPOwAd
ExBJAQFRASM3EFkBH5CbAR4E2wEgEBdOAT9gN1DdAS4kEBdNAT8QN1CQACRFIAdQR_IBD5IAKAPV
ARVHCgAOUAAPcwIULzdgcQIjDnEDDzEAn58THQT-GJvw-201AByP8Jv-GE-w-w43AB1v_v8YdfCI
NgAdX-_A-xiIOQEeDzEArIIHBwRyTzsSTgIAH3I7AAsvMTE8AAFyDi8RDhIOLQQAD0MAHDAMBgQ_
CBFAWwNREAcQFxBnAwQIABMwGAAQQGIID1kADB4wWQD-CghwBwAIYBcACAdgFwgAB3AIBwAHYAgQ
F1BLABpTBQUEByD8AwQIAA9BAAwcNkEAIEBHVgQfYDcAHRBgUAkvR0A3AB0h8ASnAA83ABrwBAkJ
BMAHcBdgJyBnEAcQJyAHEBfkCR-ATQIZAUQAQBAHMBcICp8QBxBnICdgF3BEAB43kGcQAgAfkM8C
HP8BMA8WQB4wLiA_MC5AHlAOED8AHP8BEA8WUB5ALjA_IC4wHkAOMD8AGXEMDATwAidw6QUVQAIA
APUFz0AXACdAJ3AnkAfwBX0CDQ-RAx0vMTMyACzxGRcXBPD5AfAFAQcB8AQBFwHwAwEnAQAB8AAB
NwEHAeABFxEnAeARBxEfABIHHwAg8AMKAE8FAfAMaQwZCmoABEsAEAIFALABAUcB8AAhByHwAhkA
H1VXAB0TblcAAlIAVREHEfADZgBFBCHwBA0AEAMcAAFzAATDAB9ubAAZkBkZBPD-KgHwBz0AcAYB
BxEAARArAQAQAAAjAfAD0BFHAScBsAEHAUcRBxHAAVcRQwFgN0HwADEAQgEQBX8AMwQBJ68APwcB
MH4ADA-dAR4fMDIAkPwsHx8E8B4H8EMH8AEH8AIPPE87DzzwBg6POw7wA83wAe3g-QFwBzAO-QEO
MAdg-QMPOpAO-QMOkP0FDIAEAAAZAKAMQAcw-QMcEAdgMwD-Fwyw-QEcwO0c4M0cwAcgDo0OHAAH
oAdADA5NDiwgB4AHcGxQB-BwsAALHDavAGDgDz3wDg4DAFYkDvABDrUA8AkNjzsN8APM8AHs4PwB
cA4wDfwBDTAOYPy1AJwN-AMNkPwFC4AEAAAZAKALQA4w-AMbEA5gMwD-Dwuw-AEbwOwb4Mwb8AEN
jA0b8AMLDUwNK8AOcGtQDq8AGwCkAsAVDz3wAg6gDvAZTzutAPMPbzsPPOCvO4AOIM0gDmAPPM0M
kO0POnD9AXD9AQtgBAD-HDAOEP0BCwAOUO0bcAzNDAuQzRugrRvADG0MG6AOIAtNKwAOgA5QSzAO
8D8YBRmhGRkEsAfwCAfwAhEFDJMA8wcHIM4gB2APPM4NkO4POnD_AXD_AQxgBAD-GTAHEP4BDAAH
UO4ccA3ODQyQzhygrhzADW4NHKAHIAxOLAAH8ABM8ESQABn-AQkHBPAFTzogbhBuEG4gTgC7AhrQ
CQcEoE87IG4QDk8PDj8AH6AsAz4MlAb-AFcAZzAHADcANwAHMGcAV9gHDQ_cAx8PMgD---------
----------------------------------------XVA9MTB9fQ==
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2Iixtb2RpZmllZD0iMjAyNC0w
NC0yMSAxNjoxNToxMyIsc3RvcmVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2Il1dbHo0AAQAAAADAAAA
MG5pbA==
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2Iixtb2RpZmllZD0iMjAyNC0w
NC0yMSAxNjoxNToxMyIscmV2aXNpb249Nzk1N11dbHo0AGcAAABWEAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD--------------------78QgiKSxoaWRkZW49ZmFsc2UscGFuX3g9
MAgAwnk9MCx0aWxlX2g9OAkAwHc9OCx6b29tPTF9fQ==
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2Iixtb2RpZmllZD0iMjAyNC0w
NC0yMSAxNjoxNToxMyIsc3RvcmVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2Il1dbHo0AAQAAAADAAAA
MG5pbA==
:: pal/0.pal
b64$LS1bW3BvZCxiZ19jb2xvcj0wLGJsYWNrZXN0X2NvbG9yPTAsY3JlYXRlZD0iMjAyNC0wNC0x
MCAwNDo1Mjo1MSIsaGlkZGVuPXtbMF09dHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1
ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUs
dHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRy
dWUsdHJ1ZSx0cnVlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlfSxoaWRkZW5fdG9nZ2xlcz17WzBdPXRy
dWUsdHJ1ZSxmYWxzZSxmYWxzZX0sbG9ja2VkPXtbMF09dHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVl
LHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0
cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1
ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlfSxtb2RpZmllZD0iMjAy
NC0wNC0yMSAxMToyNjoxOCIsb2twYWxfdmVyc2lvbj0iMC4wLjQiLHJldmlzaW9uPTExNjcsdGVz
dF9jdWJlX2NvbG9ycz17WzBdPXsxNSwzMSw0fSx7MzEsNCwyMH0sezQsMjAsMjF9LHsxMCw5LDI1
fSx7OSwyNSwyNH0sezgsMjQsMn0sezI2LDExLDI3fSx7MTEsMjcsM30sezI3LDMsMTl9LHsyOCwx
NywxOX0sezI4LDEyLDE2fSx7MTIsMTYsMX0sezYsMjksMTN9LHsyOSwxMywxOH0sezEzLDE4LDF9
LHs3LDIzLDE0fSx7MjMsMTQsMTN9LHsxNCwzMCwxOH0sezcsNiwyMn0sezYsMjIsNX0sezIyLDUs
MjF9LHsxLDEsMX0sezEsMSwxfSx7MSwxLDF9fSx3aGl0ZXN0X2NvbG9yPTddXWx6NAAwAQAAFQIA
APUFdXNlcmRhdGEoImkzMiIsNjQsIjABAMAxZDJiNTMwMDdlMjUIAPAXMDA4NzUxMDBhYjUyMzYw
MDVmNTc0ZjAwYzJjM2M3MDBmZmYxZTgIAEAwMDRkCAARYTYAYGZmZWMyNwoAIGU0OABAMjlhZCQA
YDgzNzY5YyAAMTc3YTgAwGNjYWEwMDFjNWVhYzAA8B1hNWExMDA3NTRlOTcwMDEyNTM1OTAwNzQy
ZjI5MDA0OTJkMzgwMGEyODg3OUAA8ANhY2M1MDBjMzAwNGMwMGViNmJGAGA5MGVjNDIKACBiMsAA
oDY0ZGZmNjAwYmSJAACWAEAwZGFiQABfODU2ZDABAL7wBDlmYTBhNjAwMWUzNzNjMDAzNzQnASEw
MwEAMTAwMgEAoDAwMTYxNjE2Iik=
:: pal/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTEwIDA0OjUyOjUxIixtb2RpZmllZD0iMjAyNC0w
NC0yMSAxNjoxNToxMyIsc3RvcmVkPSIyMDI0LTA0LTEwIDA0OjUyOjUxIl1dbHo0AAQAAAADAAAA
MG5pbA==
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTE3IDA4OjMyOjI4Iixtb2RpZmllZD0iMjAyNC0w
NC0yMSAxNjoxNToxMyIscmV2aXNpb249MjQyNl1dbHo0AN4BAAC4CAAA8CdweHUAAygAAAMABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDBAUGBwAP-5AICQoLDwwPDQ8ODw8QAPAADQ8RDxIPEw8UDxUP
Fg8XEwDxAQ8YDxkPGg8bDxwPHQ8eDx8UAPEAIA8hDyIPIw8kDyUPJg8nFADxACgPKQ8qDysPLA8t
Dy4PLxQA8QAwDzEPMg8zDzQPNQ82DzcUAP8FOA85DzoPOw88Dz0PPg8-AA--8P8BAOvwI1oBEAYP
IBABIAEgAfAAAhACDBABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJMQAYGjEAMA8VADMA
-i4QETAPgZABCiAPdiAPhCAPbPClDzoPZDAPHw--wAEQDxQPHQYQAQkADzUfOgAuUAEACgAPDGAP
SQAPePCSYwAXQGMAFQOUAP0ZgPC7DQ8EAA8SMA8U0AINCw8DCSAP9A_0D4oPag9PDzUPJQ8aCgXw
p1AAGwzjAGIfJQARMAPiAP8PwAIQBgkgD_kPzw_qD48Pfw9vD1oPTw4PJQ8PCvClSwAOAZoAHgMt
AQ8vAP-2H-8BAMz-FegDAA0ADwQgDyQPJg8o--8tDwwCDwP--y0s9C3wcAMADUD0sAgA-98f-wEA
l1D-----Hw==
:: sfx/1.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTIxIDE2OjE1OjEzIixtb2RpZmllZD0iMjAyNC0w
NC0yMSAxNjoxNToxMyIscmV2aXNpb249MV1dbHo0AEcBAAD1CAAA8CdweHUAAygAAAMABA9AEAIO
AAGgASACoA4ADxAADfDKAQIDBAUGBwAP-5AICQoLDwwPDQ8ODw8QAPAADQ8RDxIPEw8UDxUPFg8X
EwDxAQ8YDxkPGg8bDxwPHQ8eDx8UAPEAIA8hDyIPIw8kDyUPJg8nFADxACgPKQ8qDysPLA8tDy4P
LxQA8QAwDzEPMg8zDzQPNQ82DzcUAP8FOA85DzoPOw88Dz0PPg8-AA--8P8BAOv2JloBEAYPIBAB
IAEgAfAAAhACDBABIA8hIAUABAMAD0CQDxECIAxQAgEQAeACCCAPtmAPmfADJwBAAeAPJCEA-hQB
IAHgBQrwDwnwFw8oD--wxg-4Cg--D4AP9w8NAfAJARAGDGQAbwEwD0DwwzAA--_iH-8BAMy-6A9A
AA1A--_w8HAKAP--ZB--AQCXUP----8f
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2Iixtb2RpZmllZD0iMjAyNC0w
NC0yMSAxNjoxNToxMyIsc3RvcmVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2Il1dbHo0AAQAAAADAAAA
MG5pbA==
:: src/app.lua
--[[pod_format="raw",created="2024-04-12 08:11:00",modified="2024-04-21 16:15:13",revision=6015]]
local app = {}


-- Global state

app.pattern = 0 -- opened in pattern editor
app.track = 0 -- opened in track editor
app.instrument = 0 -- opened in instrument editor

app.node = nil -- selected in instrument editor

app.base_note = 48
app.base_volume = 0x32
app.base_instrument = 00

-- Colors -----------------------------------------------------------------

app.editor_bg = 62


-- Layout -------------------------------------------------------------------

app.ruler_height = 9
app.channels_width = 16
app.detail_width = 56
app.cell_width = 20
app.cell_height = 29

app.synth_width = 84
app.synth_height = 72
app.synth_gap = 4
app.mod_width = 58
app.mod_height = app.synth_height

-- GUI -------------------------------------------------------------------------

app.refresh_gui = true
app.gui = nil

app.view = "inst" -- "patt" or "trak" or "inst" or "song"
app.detail = false
app.env_advanced = { [0] = false, false, false, false }

local modal = nil


function app.attach_menu_button(parent, el)
	local label = el.get_label()
	el.width = (4 * #label) + 12
	el.height = 9
	el.cursor = "pointer"
	parent:attach(el)
	el.opened = false
	function el:draw()
		local label = self:get_label()
		print(label, 2, 2, self.fg or 7)
		pal(7, self.fg or 7)
		spr(self.opened and 38 or 37, self.width - 7, 2)
		pal(7, 7)
	end
	function el:tap()
		self.opened = true
		app.open_menu {
			x = self.sx, y = self.sy + 9,
			highlight = self.highlight,
			onclose = function()
				self.opened = false
				local label = el.get_label()
				self.width = (4 * #label) + 12
			end,
			items = self.items,
		}
	end
	return el
end


function app.open_menu(menu)
	for i = 1, #menu.items do
		if menu.items[i].get_label then
			menu.items[i].label = menu.items[i].get_label()
		end
		if (not menu.items[i].label) menu.items[i].label = "---"
	end
	local entry_height = 9
	-- Calculate popup size
	if not menu.width then
		menu.width = 0
		for i = 1, #menu.items do
			menu.width = max(menu.width, #menu.items[i].label or 0)
		end
		menu.width = 8 + (4 * menu.width)
	end
	if not menu.height then
		menu.height = max(12, 4 + (#menu.items * entry_height))
	end
	if menu.y + menu.height > app.gui.height then
		menu.y = menu.y - 7 - menu.height
	end

	-- Modal layer	
	modal = app.gui:attach {
		x = 0, y = 0,
		width = app.gui.width, height = app.gui.height,
		draw = function(self)
			local ox, oy = menu.x, menu.y
			rectfill(ox, oy, ox + menu.width - 1, oy + menu.height - 1, menu.bg or 7)
			rect(ox, oy, ox + menu.width - 1, oy + menu.height - 1, menu.border or 5)
			for i = 1, #menu.items do
				local y = oy + 2 + (entry_height * (i - 1))
				if self.highlighted == i then
					rectfill(
						ox + 1, y,
						ox + menu.width - 2, y + entry_height - 1,
						menu.highlight or 15
					) 
				end
				print(
					menu.items[i].label,
					ox + 4, y + 2,
					menu.items[i].fg or menu.fg or 62
				)
			end
		end,
		hover = function(self)
			local ox, oy = menu.x, menu.y
			local mx, my, mb = mouse()
			if
				ox <= mx and mx < ox + menu.width
				and oy <= my and my < oy + menu.height
			then
				self.cursor = "pointer"
				self.highlighted = 1 + ((my - oy - 4) \ entry_height)
			else
				self.cursor = "pointer"
				self.highlighted = nil
			end
		end,
		click = function(self)
			if modal then
				modal:detach()
			end
			modal = nil
			if self.highlighted
				and menu.items[self.highlighted].action
			then
				menu.items[self.highlighted].action()
			end
			if (menu.onclose) menu.onclose()
		end
	}
end


function app.has_modal()
	return modal != nil
end


-- Checkbox -------------------------------------------------------------------

function app.attach_checkbox(parent, el)
	el.width = 9 + (4 * #el.label or "")
	el.height = 7
	el.cursor = "pointer"
	parent:attach(el)
	if (not el.visible) el.visible = function() return true end
	function el:draw()
		if (not self:visible()) return
		rect(0, 0, 6, 6,  el.ckeck_border or 59)
--		rectfill(1, 1, 5, 5, el.check_bg or 61)
		if self.get() then
			rectfill(2, 2, 4, 4, el.check_fg or 17)
		end
		print(el.label, 10, 1, el.fg or 5)
	end
	function el:tap()
		if (not self:visible()) return
		self.set(not self.get())
	end
	return el
end

-- Numeric field ---------------------------------------------------------------


function app.attach_num_field(parent, el)
	el.width = parent.width - el.x
	el.height = 12
	parent:attach(el)
	if (not el.visible) el.visible = function() return true end
	el.dragged = nil
	function el:draw()
		local label_fg = self.label_fg or 5
		local field_fg = self.field_fg or 22
		local dragged_fg = self.dragged_fg or 7
		local field_bg = self.field_bg or 59
		local dragged_bg = self.dragged_bg or 59
		if (not self.visible()) return
		local val = self.get()
		rectfill(self.width - 24, 0, self.width - 10, 6, self.dragged and dragged_bg or field_bg)
		print(el.label, 3, 1, label_fg)
		if val then
			print(string.format("%3d", val), self.width - 22, 1, self.dragged and dragged_fg or field_fg)
		else
			print("-", self.width - 4, 1, self.dragged and dragged_fg or field_fg)
		end
	end
	function el:hover(msg)
		if msg.mx >= self.width - 21 then
			--- self.cursor = "pointer"
			self.cursor = get_spr(50)
		else
			self.cursor = 1
		end
	end
	function el:click(msg)
		if (not self.visible()) return
		if (self.onclick) self.onclick(msg)
		if msg.mx >= self.width - 21 then
			self.dragged = true
			self.cursor = 0 -- TODO: capture mouse
		end
	end
	function el:drag(msg)
		if (not el.visible()) return
		if self.dragged then
			local _, delta = mouselock(true, key("shift") and 0.025 or 0.125, 0)
			new = mid(0, self.get() - delta, 0xff)
			self.set(new)
		end
	end
	function el:release(msg)
		self.dragged = nil
		mouselock(false)
		if (self.onrelease) self.onrelease(msg)
	end
	return el
end


return app
:: src/detail.lua
--[[pod_format="raw",created="2024-04-12 07:24:11",modified="2024-04-17 17:04:34",revision=1110]]
local app = require "src/app"
local note_grid = require "src/note_grid"
local sfx = require "src/sfx"


local detail = {}


function detail.track()
	if app.view == "patt" then
		if note_grid.selection then
			return sfx.pattern_track(app.pattern, note_grid.selection.channel)
		else
			return nil
		end
	else
		return app.track
	end
end


function detail.attach_panel(parent, el)
	el.width = 64
	el.height = 270 - 11 - 16
	parent:attach(el)
	if app.view == "patt" or app.view == "trak" then
		detail.attach_section_pattern(el, { x = 1, y = app.ruler_height })
		detail.attach_section_track(el, { x = 1, y = app.ruler_height + 30 })
		detail.attach_section_note(el, { x = 1, y = app.ruler_height + 80 })
	end

	function el:draw()
		rectfill(0, 0, self.width, self.height, 21)
		pal(7, 5)
		spr(1, 2, self.height - 8)
		pal(7, 7)
	end	
	

	return el
end


-- Pattern section -------------------------------------------------------


function detail.attach_section_pattern(parent, el)
	el.width = parent.width - el.x
	el.height = 24 -- TODO
	parent:attach(el)
	detail.attach_pattern_flow_toggles(el, { x = 4, y = 10 })
	function el:draw()
		--- rectfill(0, 0, self.width, self.height, 2)
		print(string.format("pattern %d", app.pattern), 3, 0, 22)
		line(3, 7, self.width - 3, 7, 5)
	end
end


function detail.attach_pattern_flow_toggles(parent, el)
	el.width = 36 + 1
	el.height = 11
	el.cursor = "pointer"
	parent:attach(el)

	function el:draw()
		local is_start = sfx.pattern_loop_start(app.pattern)
		local is_stop = sfx.pattern_loop_stop(app.pattern)
		local is_end = sfx.pattern_loop_end(app.pattern)
		pal(7, is_start and 17 or 63)
		spr(40, 2, 1)
		pal(7, is_end and 17 or 63)
		spr(41, 2 + 12, 1)
		pal(7, is_stop and 17 or 63)
		spr(42, 2 + 24, 1)
		pal(7, 7)
	end	
	
	function el:tap(msg)
		if msg.mx > 25 then
			sfx.set_pattern_loop_stop(
				app.pattern,
				not sfx.pattern_loop_stop(app.pattern)
			)
		elseif msg.mx > 13 then
			sfx.set_pattern_loop_end(
				app.pattern,
				not sfx.pattern_loop_end(app.pattern)
			)
		else
			sfx.set_pattern_loop_start(
				app.pattern,
				not sfx.pattern_loop_start(app.pattern)
			)
		end
	end

	return el
end


-- Track section ------------------------------------------------------------------


function detail.attach_section_track(parent, el)
	el.width = parent.width - el.x
	el.height = 48 -- TODO
	parent:attach(el)
	app.attach_num_field(
		el,
		{
			x = 0, y = 12,
			label = "speed:",
			label_fg = 22, field_fg = 22, field_bg = 62,
			visible = function() return note_grid.selection != nil end,
			get = function() return sfx.track_speed(detail.track()) end,
			set = function(v) sfx.set_track_speed(detail.track(), v) end,
		}
	)
	el.loop0_field = app.attach_num_field(
		el,
		{
			x = 0, y = 22,
			label = "length:",
			label_fg = 22, field_fg = 22, field_bg = 62,
			visible = function() return note_grid.selection != nil end,
			get = function() return sfx.track_loop0(detail.track()) end,
			set = function(v) sfx.set_track_loop0(detail.track(), v) end,
		}
	)
	app.attach_num_field(
		el,
		{
			x = 0, y = 32,
			label = "loop end:",
			label_fg = 22, field_fg = 22, field_bg = 62,
			visible = function() return note_grid.selection != nil end,
			get = function() return sfx.track_loop1(detail.track()) end,
			set = function(v) sfx.set_track_loop1(detail.track(), v) end,
		}
	)
	
	function el:draw()
		local track = detail.track()
		if (not track) return
		--- rectfill(0, 0, self.width, self.height, 2)
		print(string.format("track %d", track), 3, 0, 22)
		line(3, 7, self.width - 3, 7, 5)
	end
	
	function el:update()
		local track = detail.track()
		if (not track) return
		if sfx.track_loop1(track) > 0 then
			self.loop0_field.label = "l. start:"
		else
			self.loop0_field.label = "length:"
		end
	end
end


-- Note section ------------------------------------------------------------------


function detail.attach_section_note(parent, el)
	el.width = parent.width - el.x
	el.height = 70 -- TODO
	parent:attach(el)
	app.attach_num_field(
		el,
		{
			x = 0, y = 12,
			label = "pitch:",
			label_fg = 22, field_fg = 22, field_bg = 62,
			visible = function() return note_grid.selection != nil end,
			get = function() return sfx.track_pitch(detail.track(), note_grid.selection.step) end,
			set = function(v) sfx.set_track_pitch(detail.track(), note_grid.selection.step, v) end,
		}
	)
	app.attach_num_field(
		el,
		{
			x = 0, y = 22,
			label = "volume:",
			label_fg = 22, field_fg = 22, field_bg = 62,
			visible = function() return note_grid.selection != nil end,
			get = function() return sfx.track_volume(detail.track(), note_grid.selection.step) end,
			set = function(v) sfx.set_track_volume(detail.track(), note_grid.selection.step, v) end,
		}
	)
	app.attach_num_field(
		el,
		{
			x = 0, y = 32,
			label = "inst:",
			label_fg = 22, field_fg = 22, field_bg = 62,
			visible = function() return note_grid.selection != nil end,
			get = function() return sfx.track_instrument(detail.track(), note_grid.selection.step) end,
			set = function(v) sfx.set_track_instrument(detail.track(), note_grid.selection.step, v) end,
		}
	)
	app.attach_num_field(
		el,
		{
			x = 0, y = 42,
			label = "fx:",
			label_fg = 22, field_fg = 22, field_bg = 62,
			visible = function() return note_grid.selection != nil end,
			get = function() return sfx.track_fx(detail.track(), note_grid.selection.step) end,
			set = function(v) sfx.set_track_fx(detail.track(), note_grid.selection.step, v) end,
		}
	)
	app.attach_num_field(
		el,
		{
			x = 0, y = 52,
			label = "param1:",
			label_fg = 22, field_fg = 22, field_bg = 62,
			visible = function() return note_grid.selection != nil end,
			get = function() return sfx.track_fx_param0(detail.track(), note_grid.selection.step) end,
			set = function(v) sfx.set_track_fx_param0(detail.track(), note_grid.selection.step, v) end,
		}
	)
	app.attach_num_field(
		el,
		{
			x = 0, y = 62,
			label = "param2:",
			label_fg = 22, field_fg = 22, field_bg = 62,
			visible = function() return note_grid.selection != nil end,
			get = function() return sfx.track_fx_param1(detail.track(), note_grid.selection.step) end,
			set = function(v) sfx.set_track_fx_param1(detail.track(), note_grid.selection.step, v) end,
		}
	)
		
	function el:draw()
		local track = app.track
		local step = 0
		if app.view == "patt" then
			if note_grid.selection then
				track = sfx.pattern_track(app.pattern, note_grid.selection.channel)
			else
				return
			end
		end
		--- rectfill(0, 0, self.width, self.height, 2)
		print("note", 3, 0, 22)
		line(3, 7, self.width - 3, 7, 5)
	end
end


return detail
:: src/ed_inst.lua
--[[pod_format="raw",created="2024-04-10 15:43:44",modified="2024-04-20 20:31:31",revision=3973]]
local app = require "src/app"
local envelopes = require "src/envelopes"
local settings = require "src/settings"
local routing = require "src/routing"
local sfx = require "src/sfx"
local synth = require "src/synth"


local ed_inst = {}


function ed_inst.attach(parent, el)
	el.width = 480 - (app.detail and app.detail_width or 0)
	el.height = 270 - 11 - 16
	parent:attach(el)

	sfx.refresh_nodes(app.instrument)	

	ed_inst.attach_instr_chooser(el, { x = 4, y = 4 })
	app.routing_widget = routing.attach(el, { x = 480 - 311, y = 0 })
	routing.attach_node_chooser(el, { x = 360, y = 46 })

	local dx = app.synth_width + app.synth_gap
	local dy = app.synth_height + app.synth_gap
	local ox = (480 - (4 * dx) + app.synth_gap) \ 2
	local oy = 270 - 11 - 16 - (2 * app.synth_height) - app.synth_gap - 2
			
	if app.node then
		synth.attach_node_panel(
			el,
			{
				x = ox + app.mod_width + app.synth_gap, y = oy , 
				node_id = app.node,
				large = true,
			}
		)
		for row = 0, 1 do
			envelopes.attach_panel(
				el,
				{
					x = 4, y = oy + row * dy, 
					env_id = row, large = true,
				}
			)
			envelopes.attach_panel(
				el,
				{
					x = 480 - 2 * app.mod_width - 2 * app.synth_gap, y = oy + row * dy,
					env_id = 2 + row, large = true,
				}
			)
		end
	else
		local id = 0
		for row = 0, 1 do
			envelopes.attach_panel(
				el,
				{
					x = 4, y = oy + row * dy, 
					env_id = row,
				}
			)
			for column = 0, 3 do
				synth.attach_node_panel(
					el,
					{
						x = ox + column * dx, y = oy + row * dy, 
						node_id = id
					}
				)
				id += 1
			end
			envelopes.attach_panel(
				el,
				{
					x = 480 - app.mod_width - 4, y = oy + row * dy,
					env_id = 2 + row,
				}
			)
		end
	end

	function el:draw()
		---rectfill(0, 0, self.width, 106, app.editor_bg)
		fillp(0b0000111100001111)
		fillp(0b0101010101010101)
		fillp(0b0011011011001001)
		fillp(0b0001001001001000)
		rectfill(0, 0, self.width, self.height, 62 | (61 << 8))-- app.editor_bg | (61 << 8))
		fillp()
	end	
	
	function el:update()
		local pitch_key = nil
		for i = 1, #settings.keys.pitched do
			local offset = settings.keys.pitched[i].offset
			for j = 0, #settings.keys.pitched[i] do
				local k = settings.keys.pitched[i][j]
				if key(k, true) then
					pitch_key = j + offset
				end
			end
		end
		if pitch_key then
			local pitch = pitch_key + app.base_note
			if key("shift") then
				pitch += 12
			end
			pitch = mid(0, pitch, 0xfe)
			note(
				pitch, -- todo
				app.instrument, -- current_instrument
				app.base_volume, -- current_volume
				ord(" "), 0x00, -- fx, fx param
				8, -- channel 8 so it can play with pattern
				false -- don't force retrigger
			)
		else
			note(0xff, 0xff, 0xff, 0xff, 0xff, 8)
		end
	end
	
	function el:click(msg)
		if not routing.clear_placement_buttons() then
			app.node = nil
		end
		app.refresh_gui = true
	end

	return el
end


-- Instrument chooser --------------------------------------------------------------


function ed_inst.attach_instr_chooser(parent, el)
	el.width = 80
	el.height = 83
	local container = parent:attach(el)
	function container:draw()
		clip()
		rect(-1, -1, self.width, self.height, 5)
		clip(self.sx, self.sy, self.width, self.height)
	end
	local contents = container:attach {
		x = 0, y = 0, width = el.width, height = 128 * 8 + 2,
		cursor = "pointer",
		draw = function(self)
			rectfill(0, 0, self.width, self.height, 63)
			for i = 0, 127 do -- TODO: dynamic number of instruments?
				if i == app.instrument then
					rectfill(0, i * 8 - 1, self.width, (i * 8) + 7, 17)
				end
				print("" .. i .. ": ---", 4, 1 + i * 8, (i == app.instrument) and 7 or 6)
			end
		end,
		click = function(self, msg)
			app.instrument = msg.my \ 8
			app.base_instrument = app.instrument -- TODO: temporary, remove
			app.node = nil
			app.refresh_gui = true
		end
	}
	container:attach_scrollbars()
	return el
end


return ed_inst
:: src/ed_patt.lua
--[[pod_format="raw",created="2024-04-10 10:06:40",modified="2024-04-17 10:30:04",revision=2602]]
local app = require "src/app"
local sfx = require "src/sfx"


local ed_patt = {}


-- Channel panel -------------------------------------------------------------------


function ed_patt.attach_channel_panel(parent, el)
	el.width = app.channels_width
	el.height = 270 - 11 - 16
	parent:attach(el)

	function el:draw()
		rectfill(0, 0, self.width, self.height, 21)
		for channel = 0, 7 do
			local oy = app.ruler_height + channel * app.cell_height
			local track_id = sfx.pattern_track(app.pattern, channel)
			local is_dragged = self.dragged and self.dragged.channel == channel
			if is_dragged then
				rectfill(0, oy + 1, 14, oy + 9, 17)
			end
			
			p8_centered_print(
				string.format("%d", track_id),
				8, oy + 3,
				is_dragged and 7 or 22
			)			
			spr(sfx.channel_is_muted(app.pattern, channel) and 32 or 33, 4, oy + 12)
		end
	end
	
	function el:hover(msg)
		local channel = (msg.my - app.ruler_height) \ app.cell_height
		if (channel > 7) return
		local part = (msg.my - app.ruler_height) % app.cell_height
		if part < 10 then
			--- self.cursor = "pointer"
			self.cursor = get_spr(50)
		else
			self.cursor = 1
		end
	end
	
	function el:click(msg)
		self:set_keyboard_focus(true) -- TODO
		local channel = (msg.my - app.ruler_height) \ app.cell_height
		if (channel > 7) return
		local part = (msg.my - app.ruler_height) % app.cell_height
		if part < 10 then
			local track_id = sfx.pattern_track(app.pattern, channel)
			self.dragged = { channel = channel }
			self.cursor = 0 -- TODO: capture mouse
		elseif part < 20 then
			sfx.mute_channel(
				app.pattern,
				channel,
				not sfx.channel_is_muted(app.pattern, channel)
			)
		end
	end
	
	function el:drag(msg)
		if self.dragged then
			local _, delta = mouselock(true, key("shift") and 0.025 or 0.125, 0)
			local track_id = peek(0x30100 + app.pattern * 20 + self.dragged.channel)
			track_id = mid(0, track_id - delta, 0xff)
			-- TODO: move to sfx
			poke(0x30100 + app.pattern * 20 + self.dragged.channel, track_id)
		end
	end
	
	function el:release(msg)
		self.dragged = nil
		mouselock(false)
	end
		
	return el
end


-- Pattern selector ----------------------------------------------------------------


function ed_patt.attach_pattern_selector(parent, el)
	if (not el.pattern_count) el.pattern_count = 12
	if (not el.pattern_start) el.pattern_start = 0
	el.width = (el.pattern_count + 2) * 14
	el.height = 16
	el.cursor = "pointer"
	parent:attach(el)

	function el:draw()
		local playing_pattern = stat(466)
		for p = 0, self.pattern_count + 1 do
			if p == 0 then
				spr(43, 5, 5)
			elseif p <= self.pattern_count then
				rectfill(
					p * 14, 4,
					14 + p * 14, 12, 
					self.pattern_start + (p - 1) == playing_pattern and 17 or 59
				)
				p8_centered_print(
					string.format("%d", self.pattern_start + (p - 1)),
					8 + p * 14, 6,
					self.pattern_start + (p - 1) == app.pattern and 7 or 22
				)
			else
				spr(44, 3 + p * 14, 5)
			end
		end
	end	
	
	function el:click(msg)
		local p = msg.mx \ 14
		if p == 0 then
			self.pattern_start = max(0, self.pattern_start - 1)
		elseif p <= self.pattern_count then
			app.pattern = self.pattern_start + (p - 1)
		else
			self.pattern_start = min(255, self.pattern_start + 1)
		end
	end

	return el
end


return ed_patt
:: src/ed_song.lua
--[[pod_format="raw",created="2024-04-17 10:12:11",modified="2024-04-17 10:30:04",revision=11]]
local app = require "src/app"


local ed_song = {}


function ed_song.attach(parent, el)
	el.width = 480 - (app.detail and app.detail_width or 0)
	el.height = 270 - 11 - 16 - 1
	parent:attach(el)

	function el:draw()
		rectfill(0, 0, self.width, self.height, 62)
		local str = "(the song editor is not yet implemented)"
		print(str, (480 \ 2) - (2 * #str), 110, 6)
	end	

	return el
end


return ed_song
:: src/ed_trak.lua
--[[pod_format="raw",created="2024-04-10 15:48:56",modified="2024-04-17 10:12:07",revision=92]]
local app = require "src/app"


local ed_trak = {}


function ed_trak.attach(parent, el)
	el.width = 480 - (app.detail and app.detail_width or 0)
	el.height = 270 - 11 - 16 - 1
	parent:attach(el)

	function el:draw()
		rectfill(0, 0, self.width, self.height, 62)
		local str = "(the track editor is not yet implemented)"
		print(str, (480 \ 2) - (2 * #str), 110, 6)
	end	

	return el
end


return ed_trak
:: src/envelopes.lua
--[[pod_format="raw",created="2024-04-14 20:24:26",modified="2024-04-21 16:15:13",revision=1985]]
local app = require "src/app"
local sfx = require "src/sfx"
local visual = require "src/visual"


local envelopes = {}

					

-- Envelope panel -----------------------------------------------------------


local env_type_names = { [0] = "adsr", "lfo", "custom" }
local lfo_shape_names = { [0] = "sine", "tri", "saw", "isaw", "square", "pulse" }


function envelopes.make_label(env_id)
	local env_type = sfx.env_type(app.instrument, env_id)
	return env_type_names[env_type] .. " " .. env_id
end


function envelopes.attach_panel(parent, el)
	el.width = el.large and (2 * app.mod_width + app.synth_gap) or app.mod_width
	el.height = app.mod_height
	parent:attach(el)

	app.attach_menu_button(el, {
		x = 2, y = 0, 
		env_id = el.env_id,
		get_label = function()
			return envelopes.make_label(el.env_id)
		end,
		fg = 7,
		highlight = 29,
		items = {
			{ label = "adsr", action = function() sfx.set_env_type(app.instrument, el.env_id, 0); app.refresh_gui = true end },
			{ label = "lfo", action = function() sfx.set_env_type(app.instrument, el.env_id, 1); app.refresh_gui = true end },
			{ label = "custom", action = function() sfx.set_env_type(app.instrument, el.env_id, 2); app.refresh_gui = true end },
		}
	})
	
	if not el.large then
		envelopes.attach_advanced_button(el, { x = el.width - 12, y = 0 })
	end

	if not app.env_advanced[el.env_id] then 

		local env_type = sfx.env_type(app.instrument, el.env_id)	
		if env_type == 0 then
			-- ADSR ----------------------------------------------
			local labels = { [0] = "a", "d", "s", "r" }
			for i = 0, 3 do
				envelopes.attach_slider(el, { x = 3 + 13 * i, y = 12, slider_height = 40, env_id = el.env_id, param = i, label = labels[i] })
			end
			
		elseif env_type == 1 then
			-- LFO -----------------------------------------------
			local items = {}
			for i = 0, #lfo_shape_names do
				add(items, { label = lfo_shape_names[i], action = function() sfx.set_env_param(app.instrument, el.env_id, 5, i) end })
			end
			--[[ not yet implemented?
			envelopes.attach_menu_button(el, {
				x = 14, y = 12, 
				env_id = el.env_id,
				get_label = function()
					local shape = sfx.env_param(app.instrument, el.env_id, 5)
					return lfo_shape_names[shape] or "???"
				end,
				fg = 5,
				highlight = 29,
				items = items,
			})
			]]--
			envelopes.attach_slider(el, { x = 8, y = 12, slider_height = 40, env_id = el.env_id, param = 4, label = "freq" })
			envelopes.attach_slider(el, { x = 34, y = 12, slider_height = 40, env_id = el.env_id, param = 6, label = "phase" })

		else
			-- Custom -------------------------------------
			app.attach_checkbox(
				el,
				{
					x = 4, y = 12,
					label = "lerp",
					check_fg = 18,
					get = function() return
						(sfx.env_flags(app.instrument, el.env_id) & 0x01) > 0
					end,
					set = function(v)
						local flags = sfx.env_flags(app.instrument, el.env_id)
						sfx.set_env_flags(app.instrument, el.env_id, (flags & ~0x01) | (v and 0x01 or 0x00))
					end,
				}
			)
			envelopes.attach_custom_editor(el, { x = 4, y = 20 })
			app.attach_num_field(
				el,
				{
					x = 4, y = 63,
					label = "speed:",
					field_fg = 29,
					visible = function() return true end,
					get = function() return sfx.env_speed(app.instrument, el.env_id) end,
					set = function(v) sfx.set_env_speed(app.instrument, el.env_id, v) end,
				}
			)
		end
	end
	
	if el.large or app.env_advanced[el.env_id] then
		app.attach_checkbox(
			el,
			{
				x = el.width - app.mod_width + 4, y = 12,
				label = "loop",
				check_fg = 18,
				visible = function() return sfx.env_type(app.instrument, el.env_id) != 2 end,
				get = function() return
					(sfx.env_flags(app.instrument, el.env_id) & 0x10) > 0
				end,
				set = function(v)
					local flags = sfx.env_flags(app.instrument, el.env_id)
					sfx.set_env_flags(app.instrument, el.env_id, (flags & ~0x10) | (v and 0x10 or 0x00))
				end,
			}
		)
		app.attach_num_field(
			el,
			{
				x = el.width - app.mod_width + 0, y = 22,
				label = "speed:",
				field_fg = 29,
				visible = function() return (sfx.env_flags(app.instrument, el.env_id) & 0x10 > 0) or (sfx.env_type(app.instrument, el.env_id) == 2) end,
				get = function() return sfx.env_speed(app.instrument, el.env_id) end,
				set = function(v) sfx.set_env_speed(app.instrument, el.env_id, v) end,
			}
		)
		app.attach_num_field(
			el,
			{
				x = el.width - app.mod_width + 0, y = 32,
				label = "start:",
				field_fg = 28,
				onclick = function() if (not el.large) visual.open_custom_envelope(el.env_id) end,
				onrelease = function() if (not el.large) visual.close() end,
				visible = function() return (sfx.env_flags(app.instrument, el.env_id) & 0x10 > 0) or (sfx.env_type(app.instrument, el.env_id) == 2) end,
				get = function() return sfx.env_start(app.instrument, el.env_id) end,
				set = function(v) sfx.set_env_start(app.instrument, el.env_id, v) end,
			}
		)
		app.attach_checkbox(
			el,
			{
				x = el.width - app.mod_width + 4, y = 42,
				label = "rnd start",
				check_fg = 18,
				visible = function() return (sfx.env_flags(app.instrument, el.env_id) & 0x10 > 0) or (sfx.env_type(app.instrument, el.env_id) == 2) end,
				get = function() return
					(sfx.env_flags(app.instrument, el.env_id) & 0x08) > 0
				end,
				set = function(v)
					local flags = sfx.env_flags(app.instrument, el.env_id)
					sfx.set_env_flags(app.instrument, el.env_id, (flags & ~0x08) | (v and 0x08 or 0x00))
				end,
			}
		)
		app.attach_num_field(
			el,
			{
				x = el.width - app.mod_width + 0, y = 52,
				label = "loop0:",
				field_fg = 26,
				onclick = function() if (not el.large) visual.open_custom_envelope(el.env_id) end,
				onrelease = function() if (not el.large) visual.close() end,
				visible = function() return (sfx.env_flags(app.instrument, el.env_id) & 0x10 > 0) or (sfx.env_type(app.instrument, el.env_id) == 2) end,
				get = function() return sfx.env_loop0(app.instrument, el.env_id) end,
				set = function(v) sfx.set_env_loop0(app.instrument, el.env_id, v) end,
			}
		)
		app.attach_num_field(
			el,
			{
				x = el.width - app.mod_width + 0, y = 62,
				label = "loop1:",
				field_fg = 10,
				onclick = function() if (not el.large) visual.open_custom_envelope(el.env_id) end,
				onrelease = function() if (not el.large) visual.close() end,
				visible = function() return (sfx.env_flags(app.instrument, el.env_id) & 0x10 > 0) or (sfx.env_type(app.instrument, el.env_id) == 2) end,
				get = function() return sfx.env_loop1(app.instrument, el.env_id) end,
				set = function(v) sfx.set_env_loop1(app.instrument, el.env_id, v) end,
			}
		)
	end
	
	function el:draw()
		rectfill(0, 0, self.width, self.height, 18)
		rectfill(0, 9, self.width, self.height, 6)
		envelopes.draw_corners(self)
	end
	
	function el:click()
		return true
	end
		
	return el
end

	
function envelopes.draw_corners(el)
	local col = app.editor_bg
	pset(0, 0, col)
	pset(el.width - 1, 0, col)
	pset(0, el.height - 1, col)
	pset(el.width - 1, el.height - 1, col)
end


function envelopes.attach_slider(parent, el)
	el.width = 13
	el.height = el.slider_height + 20
	el.cursor = get_spr(50)
	parent:attach(el)
	function el:draw()
		---rectfill(0, 0, self.width - 1, self.height - 1, 7)
		local oy = 9
		for i = 0, 8, 1 do
			local h = math.floor(0.5 + (i / 8) * (el.slider_height - 1))
			if i % 8 == 0 then
				line(0, oy + el.slider_height - 1 - h, 12, oy + el.slider_height - 1 - h, 7)
			elseif i % 4 == 0 then
				line(2, oy + el.slider_height - 1 - h, 10, oy + el.slider_height - 1 - h, 7)
			else
				line(4, oy + el.slider_height - 1 - h, 8, oy + el.slider_height - 1 - h, 7)
			end
		end
		local val = sfx.env_param(app.instrument, self.env_id, self.param)
		local h = math.floor(0.5 + (val / 255) * (el.slider_height - 1))
		spr(60, 2, oy + el.slider_height - 1 - h - 3)
		line(6, oy, 6, oy + el.slider_height - 1, 59)
		if (self.dragged) pal(15, 7)
		spr(61, 2, oy + el.slider_height - 1 - h - 3)
		pal(15, 15)
		clip()
		p8_centered_print(self.label, 4 + 3, 0, 5)
		p8_centered_print(tostr(val), 4 + 3, self.height - 7, self.dragged and 59 or 58)
	end
	--[[function el:update(msg)
		if (app.has_modal()) return
		local mx, my, mb = mouse()
		if mb != 0 then
			self.hovered = self.dragged != nil
		else
			self.hovered = self.sx <= mx and mx < self.sx + self.width
				and self.sy <= my and my < self.sy + self.height
		end
	end]]
	function el:click(msg)
		self.cursor = 0
		self.dragged = true
	end
	function el:drag(msg)
		if self.dragged then
			local _, delta = mouselock(true, key("shift") and 0.1 or 0.5, 0)
			local old = sfx.env_param(app.instrument, self.env_id, self.param)
			local new = old - delta
			new = mid(0, new, 255)
			sfx.set_env_param(app.instrument, self.env_id, self.param, new)
		end
	end
	function el:release(msg)
		mouselock(false)
		self.cursor = get_spr(50)
		self.dragged = nil
	end
	return el
end


function envelopes.attach_advanced_button(parent, el)
	el.width = 10
	el.height = 10
	el.cursor = "pointer"
	parent:attach(el)
	function el:draw()
		spr(39, 1, 1)
	end
	function el:tap()
		app.env_advanced[parent.env_id] = not app.env_advanced[parent.env_id]
		app.refresh_gui = true
	end
	return el
end


-- Custrom envelopes ------------------------------------------------------------


function envelopes.attach_custom_editor(parent, el)
	el.width = 50
	el.height = 42
	el.cursor = "crosshair"
	parent:attach(el)
	el.env_id = parent.env_id
	el.draw = visual.draw_custom_envelope
	function el:drag(msg)
		local param = mid(0, (msg.mx - 1) \ 3, 15)
		local val = ((self.height - 1 - msg.my) * 255) / (self.height - 2)
		local val = mid(0, math.floor(0.5 + val), 255)
		sfx.set_env_param(app.instrument, parent.env_id, param, val)
	end
	function el:update()
		local mx, my, mb = mouse()
		if
			self.sx <= mx and mx < self.sx + self.width
			and self.sy <= my and my < self.sy + self.height
		then
			local param = mid(0, (mx - self.sx - 1) \ 3, 15)
			self.selected = param
		else
			self.selected = nil
		end
	end
	return el
end


return envelopes
:: src/file.lua
--[[pod_format="raw",created="2024-04-07 08:14:09",modified="2024-04-13 13:11:11",revision=1293]]
local app = require "src/app"


local file = {}


--M.default_filename = "/ram/cart/sfx/0.visitrak"
file.default_filename = "/ram/cart/sfx/1.sfx"


function file.save()
	local ud = userdata("u8", 0x30000)
	for i = 0, 0x2ffff do
		ud[i] = peek(0x30000 + i)
	end
	return ud
end


function file.load(ud)
	if type(ud) != "userdata" then
		init_data()
	else
		for i=0,0x2ffff do
			poke(0x30000+i, ud[i])
		end
	end
	app.refresh_gui = true
---			init_undo()
end


function file.handle_drop_items(msg)
	for i = 1, #msg.items do
		local item = msg.items[i]
		if item.pod_type == "file_reference" and item.attrib == "file" then
			local ext = item.fullpath:ext()
			if ext == "sfx" then
				local metadata = fetch_metadata(item.fullpath) or {} -- TODO
				send_message(pid(), {event = "open_file", filename = item.fullpath})
			else
				notify("wrong file extension")
				-- TODO: dialog for unknown file extensions?
				--current_filename = item.fullpath
				--send_message(pid(), {event = "open_file", filename = item.fullpath})
			end
		end
	end
end


-- Initialisation ----------------------------------------------------------------


-- copied from "/system/apps/sfx.lua" in Picotron 0.0.1e
function init_data()
	
	-- index (0x30000)
	
	-- first 3 values are almost metadata only -- not currently
	-- acted on anywhere. perhaps useful in future for deciding
	-- scope of copy/paste, and gui cues, but can be calculated
	-- from content.
	
	poke2(0x30000,
		64,  -- num_instruments
		512, -- num_tracks (64 patterns * 8 channels for default indexing)
		64,  -- num_patterns
		-- flags: 0x1 use default track indexing (base+0x20000, increments of 328 bytes)
		0x1
	)
	poke4(0x30010,
		0x10000, -- insts_addr      (I32)    relative address of instruments
		0x20000, -- tracks_addr     (I32)    relative address of track index
		0,       -- patterns_addr   (I32)    relative address of pattern data
		0        -- unused          (I32)    should be 0
	)
	poke2(0x30020,
		0,  -- tick len (0 for default -- custom vals not supported yet)
		64, -- default track length
		16 -- default track spd
	)
	
	-- default track speed (+3 unused)
	poke(0x30026, 16, 0, 0, 0) 
	
	-- pattern data: first 8 patterns
	
	for pp = 0,7 do
		local addr = 0x30100 + pp * 20
		for i = 0, 7 do
			poke(addr+i, pp*8 + i)
		end
		poke(addr+8, 0x0)  -- flow flags
		poke(addr+9, 0xff) -- channel mask
		poke(addr+10, 0,0) -- length (I16)
		
	end
	
	
	----------------------------------------------------------------------------
	-- single instrument at 0x40000 (instrument 0)
	
	-- node 0: root
	poke(0x40000 + (0 * 32), -- instrument 10node 0
	
			0,    -- parent (0x7)  op (0xf0)
			1,    -- kind (0x0f): 1 root  kind_p (0xf0): 0  -- wavetable_index
			0,    -- flags
			0,    -- unused extra
				
			-- MVALs:  kind/flags,  val0, val1, envelope_index
			
			0x2|0x4,0x20,0,0,  -- volume: mult. 0x40 is max (-0x40 to invert, 0x7f to overamp)
			0x1,0,0,0,     -- pan:   add. center
			0x1,0,0,0,     -- tune: +0 -- 0,48,0,0 absolute for middle c (c4) 261.6 Hz
			0x1,0,0,0,     -- bend: none
			-- following shouldn't be in root
			0x0,0,0,0,     -- wave: use wave 0 
			0x0,0,0,0      -- phase 
	)
	
	
	-- node 1: sine
	poke(0x40000 + (1 * 32), -- instrument 0, node 1
	
			0,    -- parent (0x7)  op (0xf0)
			2,    -- kind (0x0f): 2 osc  kind_p (0xf0): 0  -- wavetable_index
			0,    -- flags
			0,    -- unused extra
				
			-- MVALs:  kind/flags,  val0, val1, envelope_index
			
			0x2,0x20,0,0,  -- volume: mult. 0x40 is max (-0x40 to invert, 0x7f to overamp)
			0x1,0,0,0,     -- pan:   add. center
			0x21,0,0,0,    -- tune: +0 -- 0,48,0,0 absolute for middle c (c4) 261.6 Hz
			               -- tune is quantized to semitones with 0x20
			0x1,0,0,0,     -- bend: none
			0x0,0x40,0,0,  -- wave: triangle
			0x0,0,0,0      -- phase 
	)
	
	

	-- wavetable
	for i=0,7 do
	poke(0x40000 + 0x1e0,
		0x00, -- address (low)  in 256 byte increments
		0xf8, -- address (high) in 64k increments
		0x0a, -- samples (1 << n) 1024
		0xff,  -- wt_height 256(0); wave mval points at one of the entries
		
		-- to do: update (is garbage now?)
		0x80,
		0xf7,
		0x0d, -- samples (1 << n) 8192
		0x01
	)
	end

	-- envelope 0 inst 1
	
	poke(0x40000 + 0x100,
		0,0,0,0, 0,0,0,0,
		0,40,255,0 -- adsr
	)
	
	-- copy default instrument to 1..15
	for i=1,15 do
		memcpy(0x40000 + 0x200*i, 0x40000, 0x200)
	end
	
	--------------------------------------------------
	-- Track Data  0x50000
	--------------------------------------------------
	
	-- Default track size is 5 * 64 rows + 8 = 328 bytes
	
	-- header (8)
	local addr = 0x50000
	poke2(addr, 64) -- len
	poke(addr+2,16) -- spd
	poke(addr+3,0)  -- loop0
	poke(addr+4,0)  -- loop1
	poke(addr+5,0)  -- delay
	poke(addr+6,0)  -- flags (0x1 mute)
	poke(addr+7,0)  -- unused
	
	-- pitch, inst, vol: not set (0xff)
	memset(addr+8, 0xff, 64*3)
	
	-- copy to other tracks
	for i=1,63 do
		memcpy(0x50000 + i*328, 0x50000, 328)
	end
end


return file
:: src/knob.lua
--[[pod_format="raw",created="2024-04-20 11:45:24",modified="2024-04-21 16:15:13",revision=2124]]
local app = require "src/app"
local sfx = require "src/sfx"
local synth_menus = require "src/synth_menus"


local knob = {}


local function attach_knob(parent, el)
	if el.small then
		el.x += 3
		el.y += 5
		el.width, el.height = 25, 25
		el.cx, el.cy, el.r = 12, 12, 7
		el.sprite = 58
	else
		el.width, el.height = 31, 31
		el.cx, el.cy, el.r = 15, 15, 9
		el.sprite = 56
	end
	if el.min_val < 0 then
		el.sprite += 1
	end
	el.cursor = get_spr(50)
	parent:attach(el)
	

	function el:draw()
		spr(self.sprite, 0, 0)	
		local range = self.max_val - self.min_val
		-- primary value
		local val = self:get()
		local a = ((val - self.min_val) / range) * 0.75
		local x = self.cx + flr(0.5 + self.r * cos(0.625 - a))
		local y = self.cy + flr(0.5 + self.r * sin(0.625 - a))
		-- secondary value: arc and needle
		if self:has_secondary() then
			local val2 = self:get_secondary()
			local a2 = ((val2 - self.min_val) / range) * 0.75
			local r = self.small and 6 or 7.75
			local incr = self.small and 0.01 or 0.01
			local function line_to(aa, col)
				local xx = self.cx + flr(0.5 + r * cos(0.625 - aa))
				local yy = self.cy + flr(0.5 + r * sin(0.625 - aa))
				line(self.cx, self.cy, xx, yy, 18)
			end
			local in_between =
				(a < a2) 
					and function(ai) return a < ai and ai < a2 end
					or function(ai) return a2 < ai and ai < a end
			line()
			line_to((a < a2) and a or a2)
			for ai = 0.0, 0.75, incr do
				if in_between(ai) then
					line_to(ai)
				end
			end
			line_to((a < a2) and a2 or a)
			local x2 = self.cx + flr(0.5 + (self.r - 1) * cos(0.625 - a2))
			local y2 = self.cy + flr(0.5 + (self.r - 1) * sin(0.625 - a2))
			line(self.cx, self.cy, x2, y2, self.dragged_secondary and 7 or 29)
		end	
		-- primary needle
		line(self.cx, self.cy, x, y, self.dragged and 7 or 15)
	end
	

	function el:click(msg)
		self.cursor = 0
		self.dragged = msg.mb == 1
		self.dragged_secondary = msg.mb == 2
		local sensitivity = key("shift") and 0.1 or 0.5
		sensitivity *= self.sensitivity or 1
		mouselock(0x4|0x8, sensitivity, 0.0)
		return true
	end
	

	function el:doubleclick(msg)
		if msg.mb == 1 then
			self:set(self.init_val)
		elseif msg.mb == 2 then
			self:set_secondary(self.init_val)
		end
		return true
	end
	

	function el:drag(msg)
		local sensitivity = key("shift") and 0.1 or 0.5
		sensitivity *= self.sensitivity or 1
		local _, delta = mouselock(0x4|0x8, sensitivity, 0.0)

		local old = self:get()
		local new = old - delta
		local old2, new2 = 0, 0
		if self:has_secondary() and msg.mb == 2 then
			old2 = self:get_secondary()
			new2 = old2 - delta
		end

		if delta < 0 then
			self.down_barrier = nil
			if self.up_barrier then
				self.up_barrier += delta
				if self.up_barrier <= 0 then
					self.up_barrier = nil
				else
					return
				end
			end
		elseif delta > 0 then
			self.up_barrier = nil
			if self.down_barrier then
				self.down_barrier -= delta
				if self.down_barrier <= 0 then
					self.down_barrier = nil
				else
					return
				end
			end
		end
		if old > 0 and new <= 0 then
			new = 0
			self.down_barrier = 24
		end
		if old < 0 and new >= 0 then
			new = 0
			self.up_barrier = 24
		end
		if old2 > 0 and new2 <= 0 then
			new2 = 0
			self.down_barrier = 24
		end
		if old2 < 0 and new2 >= 0 then
			new2 = 0
			self.up_barrier = 24
		end
		
		if msg.mb == 1 then
			self:set(new)
		elseif msg.mb == 2 then
			self:set_secondary(new2)
		end
	end
	

	function el:release(msg)
		self.cursor = get_spr(50)
		self.dragged = false
		self.dragged_secondary = false
		mouselock(false)
		self.up_barrier = nil
		self.down_barrier = nil
	end
	

	return el
end


-- Field ----------------------------------------------------------------------


local function attach_field(parent, el)
	el.width = 4 * 4 + 3
	el.height = 7
	el.cursor = get_spr(50)
	parent:attach(el)
	

	function el:draw()
		rectfill(0, 0, self.width - 1, self.height - 1, 58)
		if (not self.visible) or self.visible(self) then
			local val = self:get()
			local fg = self.fg or 59
			local str
			if self.to_str then
				str = self:to_str(val)
			else
				str = tostr(val)
			end
			if #str > 4 then
				print(str, 0, 1, self.dragged and 7 or fg)
			elseif self.centered then
				p8_centered_print(str, 10, 1, self.dragged and 7 or fg)
			else
				print(str, 2 + 4*4 - 4*#str, 1, self.dragged and 7 or fg)
			end
		end
	end
	

	function el:hover()
		if (not self.visible) or self.visible(self) then
			self.cursor = get_spr(50)
		else
			self.cursor = 1
		end
	end
	

	function el:click(msg)
		if self.visible and (not self.visible(self)) then
			return true
		end
		self.cursor = 0
		self.dragged = true
		local sensitivity = key("shift") and 0.1 or 0.5
		sensitivity *= self.sensitivity or 1
		mouselock(0x4|0x8, sensitivity, 0.0)
		return true
	end
	
	function el:doubleclick()
		return true
	end
	

	function el:drag(msg)
		local sensitivity = key("shift") and 0.1 or 0.5
		sensitivity *= self.sensitivity or 1
		local _, delta = mouselock(0x4|0x8, sensitivity, 0.0)
		local old = self:get()
		local new = old - delta
		self:set(new)
	end

	
	function el:release()
		self.cursor = get_spr(50)
		self.dragged = false
		mouselock(false)
		self.up_barrier = nil
		self.down_barrier = nil
	end
	

	return el
end


local function attach_relationship(parent, el)
	el.width, el.height = 7, 7
	el.cursor = "pointer"
	parent:attach(el)
	function el:draw()
		local flags, _, _, _ = sfx.node_param(app.instrument, self.node_id, self.param)
		---rectfill(0, 0, self.width - 1, self.height - 1, 58)
		if flags & 0x03 == 0x01 then
			print("\^:2070200000000000", -1, 2, 60)
		elseif flags & 0x03 == 0x02 then
			print("\^:5020500000000000", -1, 2, 60)
		elseif flags & 0x03 > 0 then
			print("?", 3, 1, 60)
		else
			pset(4, 3, 58)
		end
	end
	function el:tap()
		synth_menus.open_relationship(self)
	end
	return el
end


local function attach_multiplier(parent, el)
	el.width, el.height = 7, 7
	el.cursor = "pointer"
	parent:attach(el)
	function el:draw()
		local flags, _, _, env = sfx.node_param(app.instrument, self.node_id, self.param)
		--rectfill(0, 0, self.width - 1, self.height - 1, 58)
		if self.mini then
			if (env & 0xc0 > 0) then
				print("!", 0, 1, 24)
			else
				pset(1, 3, 58)
			end
			return
		end
		if (env & 0xc0 > 0) then
			str2 = (env & 0x20 == 0) and 
				"\^:5020500000000000" or  -- *
				"\^:4020100000000000"     -- /
			if (env & 0xc0 == 0x40) str2 = str2 .. "\-c\^:5070400000000000" -- 4
			if (env & 0xc0 == 0x80) str2 = str2 .. "\^:1372770000000000" -- 16
			if (env & 0xc0 == 0xc0) str2 = str2 .. "\^:5177470000000000" -- 64
			clip()
			print(str2, -4, 2, 24)
		else
			pset(2, 3, 58)
		end
	end
	function el:tap()
		synth_menus.open_multiplier(self)
	end
	return el
end


local function attach_envelope(parent, el)
	el.width, el.height = 7, 7
	el.cursor = "pointer"
	parent:attach(el)
	function el:draw()
		---rectfill(0, 0, self.width - 1, self.height - 1, 7)
		local flags, _, _, env = sfx.node_param(app.instrument, self.node_id, self.param)
		if flags & 0x04 > 0 then
			line(1, 0, self.width - 1 - 1, 0, 18)
			rectfill(0, 1, self.width - 1 - 0, self.height - 1 - 1, 18)
			line(1, self.height - 1 - 0, self.width - 1 - 1, self.height - 1 - 0, 18)
			print(string.format("%x", env & 0x0f), 2, 1, 7)
		elseif flags & 0x10 > 0 then
			line(1, 0, self.width - 1 - 1, 0, 30)
			rectfill(0, 1, self.width - 1 - 0, self.height - 1 - 1, 30)
			line(1, self.height - 1 - 0, self.width - 1 - 1, self.height - 1 - 0, 30)
			print("r", 2, 1, 7)
		else
			line(2, 1, self.width - 1 - 2, 1, 58)
			rectfill(1, 2, self.width - 1 - 1, self.height - 1 - 2, 58)
			line(2, self.height - 1 - 1, self.width - 1 - 2, self.height - 1 - 1, 58)
		end
	end
	function el:tap()
		synth_menus.open_envelope(self)
	end
	return el
end


-- Getters and setters ------------------------------------------------------


local function get_val1(self)
	local _, val1, _, _ = sfx.node_param(app.instrument, self.node_id, self.param)
	if (self.max_val < 128) then
		if (val1 >= 128) val1 -= 256
	end
	return val1
end


local function set_val1(self, val)
	val = mid(self.min_val, val, self.max_val)
	sfx.set_node_param_val1(app.instrument, self.node_id, self.param, val)
end


local function get_val0(self)
	local _, _, val0, _ = sfx.node_param(app.instrument, self.node_id, self.param)
	if (self.max_val < 128) then
		if (val0 >= 128) val0 -= 256
	end
	return val0
end


local function set_val0(self, val)
	val = mid(self.min_val, val, self.max_val)
	sfx.set_node_param_val0(app.instrument, self.node_id, self.param, val)
end


local function has_env(self)
	local flags, _, _, _ = sfx.node_param(app.instrument, self.node_id, self.param)
	return flags & (0x4 | 0x10) > 0
end


local function smart_str(self, val)
	local flags, _, _, _ = sfx.node_param(app.instrument, self.node_id, self.param)
	local node_type = sfx.node_type(app.instrument, self.node_id)
	if node_type == 0x02 and self.param == 0x02 and (flags & 0x03 == 0x02) then
		local num = 1 + val % 16
		local den = 1 + val \ 16
		return num .. "/" .. den
	end
	return tostr(val)
end


-- The widget -----------------------------------------------------------------


function knob.attach(parent, x, y, el, style)
	el.x, el.y = x, y
	el.small = small
	el.width, el.height = 35, 58
	el.small = style.small
	el.emphasis = style.emphasis
	parent:attach(el)
	attach_knob(
		el, 
		{
			x = 2, y = 10,
			small = style.small,
			node_id = el.node_id, param = el.param,
			min_val = el.min_val, max_val = el.max_val, init_val = el.init_val,
			sensitivity = el.sensitivity,
			get = get_val1,
			set = set_val1,
			has_secondary = has_env,
			get_secondary = get_val0,
			set_secondary = set_val0,
		}
	)
	attach_relationship(
		el,
		{
			x = 0, y = 41,
			node_id = el.node_id, param = el.param,
		}
	)
	attach_field(
		el,
		{
			x = 8, y = 41,
			centered = true,
			node_id = el.node_id, param = el.param,
			min_val = el.min_val, max_val = el.max_val, init_val = el.init_val,
			sensitivity = 0.125,
			get = get_val1,
			set = set_val1,
			to_str = smart_str,
		}
	)
	attach_multiplier(
		el,
		{
			x = 28, y = 41,
			node_id = el.node_id, param = el.param,
		}
	)
	attach_field(
		el,
		{
			x = 8, y = 51,
			fg = 18, centered = true,
			node_id = el.node_id, param = el.param,
			min_val = el.min_val, max_val = el.max_val, init_val = el.init_val,
			visible = has_env,
			sensitivity = 0.125,
			get = get_val0,
			set = set_val0,
			to_str = smart_str,
		}
	)
	attach_envelope(
		el,
		{
			x = 28, y = 51,
			node_id = el.node_id, param = el.param,
		}
	)
	
	function el:draw()
		---rectfill(0, 0, self.width - 1, self.height - 1, 7)
		if self.emphasis then
			rectfill(0, 0, self.width - 1, 8, 5)
		else
			rectfill(0, 0, self.width - 1, 8, 5)
		end
		p8_centered_print(
			el.long_label or el.label,
			(self.width \ 2) + 1, 2,
			self.emphasis and 6 or 6
		)
	end	
	
	function el:click() return true end
	function el:doubleclick() return true end
	
	return el
end


-- Mini widget ---------------------------------------------------------------------


function knob.attach_mini(parent, el)
	el.x = el.x or 0
	el.y = el.y or (12 + 10 * el.param)
	el.width = parent.width
	el.height = 10
	parent:attach(el)
	attach_relationship(
		el,
		{
			x = 24, y = 0,
			node_id = el.node_id, param = el.param,
		}
	)
	attach_field(
		el,
		{
			x = 24 + 7, y = 0,
			node_id = el.node_id, param = el.param,
			min_val = el.min_val, max_val = el.max_val, init_val = el.init_val,
			sensitivity = 0.125,
			get = get_val1,
			set = set_val1,
			to_str = smart_str,
		}
	)
	attach_multiplier(
		el,
		{
			x = 24 + 7 + 20, y = 0,
			mini = true,
			node_id = el.node_id, param = el.param,
		}
	)
	attach_field(
		el,
		{
			x = 24 + 7 + 20 + 4, y = 0,
			fg = 18,
			node_id = el.node_id, param = el.param,
			min_val = el.min_val, max_val = el.max_val, init_val = el.init_val,
			visible = has_env,
			sensitivity = 0.125,
			get = get_val0,
			set = set_val0,
			to_str = smart_str,
		}
	)
	attach_envelope(
		el,
		{
			x = 24 + 7 + 20 + 4 + 20, y = 0,
			node_id = el.node_id, param = el.param,
		}
	)
	function el:draw()
		print(self.label, 24 - (4 * #self.label), 1, 5)
		---print(self.label, 2, 1, 5)
	end
	
	function el:click() return true end
	function el:doubleclick() return true end
end


return knob
:: src/note_grid.lua
--[[pod_format="raw",created="2024-04-11 06:36:17",modified="2024-04-17 20:26:17",revision=1697]]
local app = require "src/app"
local settings = require "src/settings"
local sfx = require "src/sfx"


local note_grid = {}


note_grid.origin = { x = -4 }
note_grid.selection = { channel = 0, step = 0, part = 0 }


function note_grid.attach(parent, el)
	el.width = 480 - app.channels_width - (app.detail and app.detail_width or 0)
	el.height = 270 - 11 - 16
	parent:attach(el)
	
	el.panned = nil
	el.dragged = nil
	
	el:set_keyboard_focus(true)
	
	-- Draw ------------------------------------------------------------------------

	function el:draw()
		local pattern_is_playing = (stat(464) != 0)  and (stat(466) == app.pattern)
		-- Ruler background
		rectfill(0, 0, self.width, app.ruler_height - 2, 61)
		line(0, app.ruler_height - 1, self.width, app.ruler_height - 1, 5)
		local step_start = note_grid.origin.x \ app.cell_width
		local delta_x = - (note_grid.origin.x % app.cell_width)
		if step_start < 0 then
			step_start = 0
			note_grid.origin.x = max(- 4 , note_grid.origin.x)
			delta_x = - note_grid.origin.x
		end
		for channel = 0, 7 do
			local oy = app.ruler_height + channel * app.cell_height
			rectfill(
				0, oy, self.width,
				oy + app.cell_height - 1,
				((channel % 2) == 0) and 63 or 62
			)
			if sfx.channel_is_muted(app.pattern, channel) then
				goto continue
			end
			local track = peek(0x30100 + app.pattern * 20 + channel)
			for step_i = 0, 24 do
				if step_start + step_i > 63 then break end
				local ox = delta_x + step_i * app.cell_width + 1
				if pattern_is_playing and stat(400 + channel, 9) == step_start + step_i then
					rectfill(ox, oy, ox + app.cell_width - 2, oy + app.cell_height - 1, 19)
				end
				if
					note_grid.selection and note_grid.selection.channel == channel
						and note_grid.selection.step == step_start + step_i
				then
					-- TODO: replace with rectfill
					-- TODO: replace with rect when no keyboard focus
					spr(24 + note_grid.selection.part, ox, oy)
				end
				-- TODO: support track length > 64
				local freq = sfx.track_pitch(track, step_start + step_i)
				local inst = sfx.track_instrument(track, step_start + step_i)
				local vol  = sfx.track_volume(track, step_start + step_i)
				local fx   = sfx.track_fx(track, step_start + step_i)
				local fxp0  = sfx.track_fx_param0(track, step_start + step_i)
				local fxp1  = sfx.track_fx_param1(track, step_start + step_i)
				-- Note and octave
				if freq != 0xff then
					local dragged = self.dragged_pitch and note_grid.selection
						and note_grid.selection.step == step_start + step_i
						and note_grid.selection.channel == channel
					local note = freq % 12
					local is_sharp = (note == 1) or (note == 3) or (note == 6)
						or (note == 8) or (note == 10)
					local x = is_sharp and (ox + 2) or (ox + 2) -- 5
					spr(8 + note, x, oy + 2)
					local x_oct = is_sharp and (ox + 14) or (ox + 8) -- 11
					if (freq \ 12) <= 9 then
						print("\014" .. tostr(freq \ 12), x_oct, oy + 3, dragged and 7 or 13) 
					else
						print("\014?", ox + 14, oy + 3, dragged and 7 or 13) 
					end
				else
					print("\014.", ox + 2, oy, 7)
				end
				-- Volume
				if vol != 0xff then
					local w_vol = (vol / 64) * (app.cell_width - 6)
					w_vol = min(w_vol, app.cell_width - 6)
					if w_vol == 0 and vol != 0 then
						w_vol = 1
					end
					rectfill(ox + 2, oy + 10, ox + 2 + app.cell_width - 6, oy + 12, 60)
					if w_vol > 0 then
						local dragged = self.dragged_volume and note_grid.selection
							and note_grid.selection.step == step_start + step_i
							and note_grid.selection.channel == channel
						rectfill(ox + 2, oy + 10, ox + 2 + w_vol, oy + 12, dragged and 7 or 17)
					end
					-- TODO: support vol > 64
				else
					print("\014.", ox + 2, oy + 7, 5)
				end
				-- Instrument
				if inst != 0xff then
					local dragged = self.dragged_instrument and note_grid.selection
						and note_grid.selection.step == step_start + step_i
						and note_grid.selection.channel == channel
					print("\014" .. string.format("%d", inst), ox + 2, oy + 15, dragged and 7 or 14)
				else
					print("\014.", ox + 2, oy + 15 - 1, 5)
				end
				-- Effect
				if fx != 0 then
					local str = (fx > 32 and fx < 128) and chr(fx) or "?"
					print(str .. fxp0 .. fxp1, ox + 2, oy + 22, 31)
				else
					print(".", ox + 2, oy + 22 - 1, 5)
				end
			end
			::continue::
		end
		if self.height > app.ruler_height + 8 * app.cell_height then
			rectfill(0, app.ruler_height + 8 * app.cell_height, self.width, self.height, 62)
		end
		-- Bar lines
		for step_i = 0, 24 do
			if step_start + step_i > 63 + 1 then break end
			local ox = delta_x + (step_i * app.cell_width)
			local bar = (step_start + step_i) \ (4 * 4) + 1
			local beat = ((step_start + step_i) \ 4) % 4 + 1
			if (step_start + step_i) % 4 == 0 then
				if ((step_start + step_i) \ 4) % 4 == 0 then
					line(ox, 0, ox, self.height, 22)
					print("\014" .. bar .. "." .. beat, ox + 2, 2, 22)
				else
					line(ox, 0, ox, self.height, 5)
					print("\014" .. bar .. "." .. beat, ox + 2, 2, 5)
				end
			else
				--[[
				poke(0x550b, 0x3f)
				fillp(0b0000000011111111)
				line(ox, app.ruler_height, ox, self.height - 1, 5)
				fillp()
				poke(0x550b, 0x00)
				--]]
			end
		end
	end
	
	-- Mouse --------------------------------------------------------------------
	

	function el:hover(msg)
		if msg.my <= app.ruler_height then
			self.cursor = "grab"
		else
			self.cursor = 1
		end
	end
	

	function el:click(msg)
		if msg.my < app.ruler_height or msg.mb == 4 then
			self.panned = true
			self.cursor = "grab"
			mouselock(true, 1, 1)
		elseif msg.mb == 1 then
			self:set_keyboard_focus(true)
			local step = (msg.mx + note_grid.origin.x) \ app.cell_width
			local channel = (msg.my - app.ruler_height) \ app.cell_height
			if
				(0 <= channel) and (channel <= 7)
					and (0 <= step) and (step <= 63) -- TODO: handle track length
			then
				note_grid.selection = { part = 0, step = step, channel = channel }
				local y = (msg.my - app.ruler_height) % app.cell_height
				if y > 20 then
					note_grid.selection.part = 3
				elseif y > 14 then
					note_grid.selection.part = 2
				elseif y > 8 then
					note_grid.selection.part = 1
				end
				self:show_selection()
			else
				note_grid.selection = nil
			end
		end
	end
	

	function el:drag(msg)
		if (msg.dx == 0 and msg.dy == 0) return
		if self.panned then
			local delta, _ = mouselock(true, 0.25, 0.25)
			note_grid.origin.x -= delta
		elseif not note_grid.selection then
			-- nothing
		elseif note_grid.selection.part == 0 then
			self.dragged_pitch = true
			self.cursor = 0
			local _, delta = mouselock(true, 0.25 / 2, 0)
			local track = sfx.pattern_track(app.pattern, note_grid.selection.channel)
			local pitch = sfx.track_pitch(track, note_grid.selection.step)
			if pitch == 0xff then
				pitch = app.base_note
			else
				pitch = mid(0, pitch - delta, 0xfe)
			end
			sfx.set_track_pitch(track, note_grid.selection.step, pitch)
		elseif note_grid.selection.part == 1 then
			self.dragged_volume = true
			self.cursor = 0
			local _, delta = mouselock(true, 0.25, 0)
			local track = sfx.pattern_track(app.pattern, note_grid.selection.channel)
			local vol = sfx.track_volume(track, note_grid.selection.step)
			if vol == 0xff then
				vol = app.base_volume
			else
				vol = mid(0, vol - delta, 0xfe)
			end
			sfx.set_track_volume(track, note_grid.selection.step, vol)
		elseif note_grid.selection.part == 2 then
			self.dragged_instrument = true
			self.cursor = 0
			local _, delta = mouselock(true, 0.25 / 2, 0)
			local track = sfx.pattern_track(app.pattern, note_grid.selection.channel)
			local instr = sfx.track_instrument(track, note_grid.selection.step)
			if instr == 0xff then
				instr = app.base_instrument
			else
				instr = mid(0, instr - delta, 0xfe)
			end
			sfx.set_track_instrument(track, note_grid.selection.step, instr)
		end
	end
	

	function el:release(msg)
		self.panned = false
		self.dragged_pitch = false
		self.dragged_volume = false
		self.dragged_instrument = false
		self.cursor = 1
		mouselock(false)
	end
	
	
	function el:mousewheel(msg)
		note_grid.origin.x -= msg.wheel_y * app.cell_width
	end
	
	-- Update -----------------------------------------------------------------
	

	function el:update()
		if self.note_playing then
			-- TODO: should be in main.lua (bug when switching view during note)
			if self.note_playing.tick > 10 then
				note(0xff, 0xff, 0xff, 0xff, 0xff, self.note_playing.channel)
				self.note_playing = nil
			else
				self.note_playing.tick += 1
			end
		end
		
		-- TODO: separate: take focus *xor* move
		if (keyp("pageup")) self:set_keyboard_focus(true); self:goto_previous_channel()
		if (keyp("pagedown")) self:set_keyboard_focus(true); self:goto_next_channel()
		if (keyp("up")) self:set_keyboard_focus(true); self:goto_previous_part()
		if (keyp("down")) self:set_keyboard_focus(true); self:goto_next_part()
		if (keyp("left")) self:set_keyboard_focus(true); self:goto_previous_step()
		if (keyp("right")) self:set_keyboard_focus(true); self:goto_next_step()

		if note_grid.selection then
			self:handle_positioned_key()
		end
	end


	function el:handle_positioned_key()
		local keys = settings.keys
		
		local track = peek(0x30100 + app.pattern * 20 + note_grid.selection.channel)
		local base_addr = 0x50000 + 8 + (track * 328) + note_grid.selection.step
		
		-- Pitched input
		local pitch_key = nil
		for i = 1, #settings.keys.pitched do
			local offset = settings.keys.pitched[i].offset
			for j = 0, #settings.keys.pitched[i] do
				local k = settings.keys.pitched[i][j]
				if keyp(k, true) then
					pitch_key = j + offset
				end
			end
		end
		
		local num_key = keyp_num()
		local hex_key = keyp_hex()
						
		-- Part-specific input
				
		if note_grid.selection.part == 0 then
			local note = peek(base_addr) % 12
			if key("shift") and num_key then
				local pitch = note + num_key * 12
				pitch = mid(0, pitch, 0xfe)
				poke(base_addr, pitch)
				self:goto_next_step()
			elseif pitch_key then
				local pitch = pitch_key + app.base_note
				if key("shift") then
					pitch += 12
				end
				pitch = mid(0, pitch, 0xfe)
				poke(base_addr, pitch)
				poke(base_addr + (2 * 64), app.base_volume)
				poke(base_addr + (1 * 64), app.base_instrument)
				-- TODO fx and fxp
				self:play_selection()
				self:goto_next_step()
			elseif keyp(keys.rest) and key("shift") then
				poke(base_addr, 0xff)
				self:goto_next_step()
			elseif keyp(keys.rest) then
				poke(base_addr, 0xff)
				poke(base_addr + (2 * 64), 0xff)
				poke(base_addr + (1 * 64), 0xff)
				-- TODO fx and fxp
				self:goto_next_step()
			end
			
		elseif note_grid.selection.part == 1 then
			if num_key then
				local vol = math.floor(((hex_key / 9) * 64) + 0.5)
				if key("shift") then
					vol += 64
				end
				notify("" .. vol)
				poke(base_addr + (2 * 64), vol)
				self:goto_next_step()
			elseif keyp(keys.rest) then
				poke(base_addr + (2 * 64), 0xff)
				self:goto_next_step()
			elseif pitch_key then
				local pitch = pitch_key + app.base_note
				if key("shift") then
					pitch += 12
				end
				pitch = mid(0, pitch, 0xfe)
				self:play_selection { pitch = pitch }
			end
			
		elseif note_grid.selection.part == 2 then
			if num_key then
				local inst = peek(base_addr + (1 * 64))
				if (inst == 0xff) inst = 0
				if key("shift") then
					inst = (hex_key * 10) + (inst % 10)
				else
					inst = ((inst \ 10) * 10) + num_key
				end
				poke(base_addr + (1 * 64), inst)
				self:goto_next_step()
			elseif keyp(keys.rest) then
				poke(base_addr + (1 * 64), 0xff)
				self:goto_next_step()
			elseif pitch_key then
				local pitch = pitch_key + app.base_note
				if key("shift") then
					pitch += 12
				end
				pitch = mid(0, pitch, 0xfe)
				self:play_selection { pitch = pitch }
			end
		--[[
		elseif note_grid.selection.part == 3 then
			if hexa_val then
				poke(base_addr + (4 * 64), hexa_val)
				self:goto_next_step()
			elseif keyp(keys.rest) then
				poke(base_addr + (4 * 64), 0xff)
				self:goto_next_step()
			end
		--]]
		end
		
		-- Non part-specific input
		
		if keyp("backspace") then
			self:goto_previous_step()
			local base_addr = 0x50000 + 8 + (track * 328) + note_grid.selection.step
			poke(base_addr, 0xff)
			poke(base_addr + (2 * 64), 0xff)
			poke(base_addr + (1 * 64), 0xff)
			-- TODO: fx and fxp
			-- poke(base_addr + (3 * 64), 0xff)
			-- poke(base_addr + (4 * 64), 0xff)
		end
	end
	

	function el:goto_previous_part()
		if not note_grid.selection then
			self:goto_start()
		elseif note_grid.selection.part > 0 then
			note_grid.selection.part -= 1
		elseif note_grid.selection.channel > 0 then
			note_grid.selection.part = 3
			self:goto_previous_channel()
		end
		self:show_selection()
	end


	function el:goto_next_part()
		if not note_grid.selection then
			self:goto_start()
		elseif note_grid.selection.part < 3 then
			note_grid.selection.part += 1
		elseif note_grid.selection.channel < 7 then
			note_grid.selection.part = 0
			self:goto_next_channel()
		end
		self:show_selection()
	end
	
	
	function el:goto_previous_channel()
		-- TODO: skip muted
		if not note_grid.selection then
			self:goto_start()
		elseif note_grid.selection.channel > 0 then
			self:goto_channel(note_grid.selection.channel - 1)
		end
	end
	
	
	function el:goto_next_channel()
		-- TODO: skip muted
		if not note_grid.selection then
			self:goto_start()
		elseif note_grid.selection.channel < 7 then
			self:goto_channel(note_grid.selection.channel + 1)
		end
	end	

	

	function el:goto_previous_step()
		if not note_grid.selection then
			self:goto_start()
		elseif note_grid.selection.step > 0 then
			self:goto_step(note_grid.selection.step - 1)
		end
	end
		

	function el:goto_next_step()
		if not note_grid.selection then
			self:goto_start()
		elseif note_grid.selection.step < 63 then -- TODO: handle track length
			self:goto_step(note_grid.selection.step + 1)
		end
	end
	

	function el:goto_start()
		note_grid.selection = { part = 0, step = 0, channel = 0 }
		self:show_selection()
	end


	function el:goto_channel(c)
		-- TODO check if channel is muted
		note_grid.selection.channel = c
		self:show_selection()
	end
	

	function el:goto_step(s)
		note_grid.selection.step = s
		self:show_selection()
	end
	

	function el:show_selection()
		if (not note_grid.selection) return
		-- TODO: pagination by bars?
		local offset = 4 -- TODO
		if
			note_grid.origin.x > ((note_grid.selection.step * app.cell_width) - offset)
		then
			note_grid.origin.x = note_grid.selection.step * app.cell_width - offset
		elseif
			note_grid.origin.x + self.width < ((note_grid.selection.step + 1) * app.cell_width) + offset
		then
			note_grid.origin.x = ((note_grid.selection.step + 1) * app.cell_width) + offset - self.width
		end
	end
	

	function el:play_selection(override)
		if (not override) override = {}
		if note_grid.selection and stat(464) == 0 then
			local track = peek(0x30100 + app.pattern * 20 + note_grid.selection.channel)
			local base_addr = 0x50000 + 8 + (track * 328) + note_grid.selection.step
			local pitch = override.pitch or peek(base_addr)
			local inst = peek(base_addr + 64)
			local vol  = peek(base_addr + (2 * 64))
			local fx   = peek(base_addr + (3 * 64))
			local fxp  = peek(base_addr + (4 * 64))
			note(
				pitch,
				inst,
				vol,
				ord(" "), 0x00, -- fx, fx param
				note_grid.selection.channel,
				false
			)
			self.note_playing = { channel = note_grid.selection.channel, tick = 0 }
		end
	end
	
	el:show_selection()
		
	return el
end


return note_grid
:: src/routing.lua
--[[pod_format="raw",created="2024-04-13 06:33:13",modified="2024-04-20 20:39:59",revision=2146]]
local app = require "src/app"
local sfx = require "src/sfx"


local routing = {}


-- Locals ------------------------------------------------------------------------


local node_width = 26
local node_height = 16
local node_gap = 14


local placement_buttons = {}


local function attach_placement_button(el)
	el.x -= 3
	el.y -= 3
	el.width = 7 -- TODO
	el.height = 7
	el.cursor = "pointer"
	app.routing_widget:attach(el)
	add(placement_buttons, el)
	function el:draw()
		local x, y = 3, 3
		rectfill(
			x - 2, y - 3, 
			x + 2, y + 3,
			24
		)
		rectfill(
			x - 3, y - 2,
			x + 3, y + 2,
			24
		)
		print("+", x - 1, y - 2, 7)
	end
	function el:click()
		return true -- (ed_inst click() refreshes gui)
	end
	function el:tap()
		routing.clear_placement_buttons()
		app.node = sfx.add_node(app.instrument, self.parent_id,
			self.new_node_type, self.new_node_op, self.target_id)
		app.refresh_gui = true
	end
	return el
end
	

local function start_new_node(new_node_type, new_node_op)
--	app.node = nil
--	app.refresh_gui = true
	for n = 0, 7 do
		local node = sfx.nodes[n]
		local pos = node.position
		if (not pos) break -- TODO: when does this occur?
		-- Coordinates from logical position
		pos.x = 4 + pos.column * (node_width + node_gap)
		pos.y = 4 + pos.row * node_height
		local ppos = node.parent.position
		ppos.x = 4 + ppos.column * (node_width + node_gap)
		ppos.y = 4 + ppos.row * node_height
		
		if new_node_type == 2 and new_node_op > 0 then
			if 
				node.type == 2 and node.op == 0
				and (#node.children == 0 or node.children[1].type != 2
						or node.children[1].op == 0)
			then
				attach_placement_button {
					parent_id = node.id, target_id = node.id + 1,
					new_node_type = new_node_type, new_node_op = new_node_op,
					x = pos.x + node_width + 2, y = pos.y + 4,
				}
			end
		elseif new_node_type == 2 then
			if node != sfx.root then
				attach_placement_button {
					parent_id = node.parent.id, target_id = node:last_child().id + 1,
					new_node_type = new_node_type, new_node_op = new_node_op,
					x = pos.x + node_width \ 2, y = pos.y + 9
				}
			end
			if 
				(node.type == 2 or node == sfx.root)
				and (#node.children == 0 or node.children[1].type != 2
					or node.children[1].op == 0)
			then
				attach_placement_button {
					parent_id = node.id, target_id = node.id + 1,
					new_node_type = new_node_type, new_node_op = new_node_op,
					x = pos.x + node_width + 2, y = pos.y + 4
				}
			end
		else -- effects
			if node != sfx.root then
				attach_placement_button {
					parent_id = node.parent.id, target_id = node:last_child().id + 1,
					new_node_type = new_node_type, new_node_op = new_node_op,
					x = pos.x + node_width \ 2, y = pos.y + 9
				}
			end
			if 	node.type == 2 then
				attach_placement_button {
					parent_id = node.id, target_id = node.id + 1,
					new_node_type = new_node_type, new_node_op = new_node_op,
					x = pos.x + node_width + 2, y = pos.y + 4
				}
			end
		end
	end
end


function routing.clear_placement_buttons()
	local cleared_something = #placement_buttons > 0
	for i = 1, #placement_buttons do
		placement_buttons[i]:detach()
	end
	placement_buttons = {}
	return cleared_something
end


-- Routing display -------------------------------------------------------------


function routing.attach(parent, el)
	el.width = 311
	el.height = 90
	parent:attach(el)
	
	function el:draw()
		--- rectfill(0, 0, self.width, self.height, 62)
		for n = 0, 7 do
			local node = sfx.nodes[n]
			local pos = node.position
			if (not pos) break -- TODO: when does this occur?
			-- Coordinates from logical position
			pos.x = 4 + pos.column * (node_width + node_gap)
			pos.y = 4 + pos.row * node_height
			local ppos = node.parent.position
			ppos.x = 4 + ppos.column * (node_width + node_gap)
			ppos.y = 4 + ppos.row * node_height

			if app.node == n then
				rect(pos.x - 2, pos.y - 2, pos.x + node_width + 2, pos.y + 8 + 2, 24)
				rect(pos.x - 1, pos.y - 1, pos.x + node_width + 1, pos.y + 8 + 1, 0)
			end
			
			if node.type >= 8 and node.older_sibling then
				-- Horizontal bracket
				local col = 6
				local x = pos.x + node_width \ 2
				local orig = node.older_sibling
				local depth = 0
				while #orig.children > 0 and depth < 8 do
					orig = orig.children[#orig.children]
					depth += 1
				end
				local orig_x = orig.position.x + node_width
				line(x - (node_width \ 2) - 3, pos.y - 4, x - (node_width \ 2) - 3 - 2, pos.y - 6, col)
				line(x - 3, pos.y - 4, x - (node_width \ 2) - 3, pos.y - 4, col)
				line(x, pos.y - 2, x - 2, pos.y - 4, col)
				line(x, pos.y - 2, x + 2, pos.y - 4, col)
				line(x + 3, pos.y - 4, orig_x + 3, pos.y - 4, col)
				line(orig_x + 3, pos.y - 4, orig_x + 3 + 2, pos.y - 6, col)
			elseif node != sfx.root then
				-- Arrow
				line(
					ppos.x + node_width + 7, ppos.y + 4,
					ppos.x + node_width + 1, ppos.y + 4,
					7
				)
				line(
					pos.x - 7, pos.y + 4,
					ppos.x + node_width + 7, ppos.y + 4,
					7
				)
				line(
					pos.x - 1, pos.y + 4,
					pos.x - 7, pos.y + 4,
					7
				)
				line(pos.x - 2, pos.y + 3, pos.x - 2, pos.y + 5, 7)
				line(pos.x - 3, pos.y + 2, pos.x - 3, pos.y + 6, 7)
			end
			
			-- Node boxes
			local str = "??? "
			local fg = 63
			local bg = 30
			if node == sfx.root then str = "synth"; fg = 22; bg = 7
			elseif node.type == 2 then
				if node.op == 0 then str = "osc " .. n; bg = 17
				elseif node.op == 1 then str = "fm " .. n; bg = 27
				elseif node.op == 2 then str = "ring " .. n; bg = 22
				end
			elseif node.type == 8 then str = "filt " .. n; bg = 14
			elseif node.type == 9 then str = "echo " .. n; bg = 31
			elseif node.type == 10 then str = "shap " .. n; bg = 9
			end
			rectfill(pos.x, pos.y, pos.x + node_width, pos.y + 8, bg)
			p8_centered_print(str, pos.x + (node_width \ 2) + 1, pos.y + 2, fg)
		end
	end
	
	function el:hover(msg)
		self.cursor = 1
		if (#placement_buttons != 0) return
		for n = 0, 7 do
			local node = sfx.nodes[n]
			local pos = node.position
			if
				pos and pos.x and pos.x <= msg.mx and msg.mx <= pos.x + node_width
				and pos.y <= msg.my and msg.my <= pos.y + 10
			then
				self.cursor = "pointer"
			end
		end
	end

	function el:click(msg)
		if (#placement_buttons != 0) return
		app.node = nil
		for n = 0, 7 do
			local node = sfx.nodes[n]
			local pos = node.position
			if
				pos and pos.x and pos.x <= msg.mx and msg.mx <= pos.x + node_width
				and pos.y <= msg.my and msg.my <= pos.y + 10
			then
				app.node = n
				app.refresh_gui = true
				return true
			end
		end
	end
	
	return el
end


-- Node chooser ----------------------------------------------------------------


local node_choice = {
	[0] = {
		[0] = { label = "osc", color = 17, node_type = 0x2, node_op = 0x0 },
		{ label = "fm", color = 27, node_type = 0x2, node_op = 0x1 },
		{ label = "ring", color = 22, node_type = 0x2, node_op = 0x2 },
	},
	{
		[0] = { label = "filt", color = 14, node_type = 0x8, node_op = 0x0 },
		{ label = "echo", color = 31, node_type = 0x9, node_op = 0x0 },
		{ label = "shap", color = 9, node_type = 0x0a, node_op = 0x0 },
	},
}


function routing.attach_node_chooser(parent, el)
	el.width = 118
	el.height = 50
	parent:attach(el)
	
	for i = 1, #placement_buttons do
		app.routing_widget:attach(placement_buttons[i])
	end

	function el:draw()
		--- rectfill(0, 0, self.width - 1, self.height - 1, 0)
		if #placement_buttons > 0 then
			print("select new node position", 4, 12, 22)
			return
		end
		if sfx.root.free_nodes == 0 then
			print("(all nodes are used)", 4, 12, 22)
			return
		end
		print("add node:", 4, 2, 22)
		local ox, oy = 4, 12
		for row = 0, #node_choice do
			for column = 0, #(node_choice[row]) do
				local x = ox + column * node_width
				local y = oy + row * (8 + 4)
				local col = node_choice[row][column].color
				rectfill(x, y, x + (node_width - 6), y + 8, col)
				p8_centered_print(
					node_choice[row][column].label,
					x + ((node_width - 6) \ 2) + 1,
					y + 2,
					63
				)
			end
		end
	end
	
	function el:hover(msg)
		self.cursor = 1
		if (#placement_buttons > 0) return
		if (sfx.root.free_nodes == 0) return
		local ox, oy = 4, 12
		for row = 0, #node_choice do
			for column = 0, #(node_choice[row]) do
				local x = ox + column * node_width
				local y = oy + row * (8 + 4)
				if
					x <= msg.mx and msg.mx <= x + (node_width - 6)
					and y <= msg.my and msg.my <= y + 8
				then
					self.cursor = "pointer"
				end
			end
		end
	end

	function el:click(msg)
		return true -- don't want to deselect the node!
	end
	
	function el:tap(msg)
		if #placement_buttons > 0 then
			routing.clear_placement_buttons()
			return
		end
		if (sfx.root.free_nodes == 0) return
		local ox, oy = 4, 12
		for row = 0, #node_choice do
			for column = 0, #(node_choice[row]) do
				local x = ox + column * node_width
				local y = oy + row * (8 + 4)
				if
					x <= msg.mx and msg.mx <= x + (node_width - 6)
					and y <= msg.my and msg.my <= y + 8
				then
					start_new_node(
						node_choice[row][column].node_type,
						node_choice[row][column].node_op
					)
				end
			end
		end
	end
	

	return el
end


return routing
:: src/settings.lua
--[[pod_format="raw",created="2024-04-11 08:58:08",modified="2024-04-20 11:45:00",revision=1831]]
local settings = {}

local settings_filepath = "/appdata/drakmaniso/visitrack/settings.pod"
local keys_filepath = "/appdata/drakmaniso/visitrack/keys.pod"


settings.piano_keys = { pitched = {
	{
		offset = -12,
		[0] = "z", "s", "x", "d", "c", "v", "g", "b", "h", "n", "j", "m",
		",", "l", ".", ";", "/"
	},
	{
		offset = 0,
		[0] = "q", "2", "w", "3", "e", "r", "5", "t", "6", "y", "7", "u",
		"i", "9", "o", "0", "p", "[", "=", "]",
	}
}}


settings.isomorphic_keys = { pitched = {
	{
		offset = -12,
		[0] = "z", "x", "c", "v", "b", "n", "m", ",", ".", "/",
	},
	{
		offset = -6,
		[0] = "a", "s", "d", "f", "g", "h", "j", "k", "l", ";", "'",
	},
	{
	offset = 0,
		[0] = "q", "w", "e", "r", "t", "y", "u", "i", "o", "p", "[", "]", "\\",
	},
	{
	offset = 6,
		[0] = "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "-", "=",
	}
}}


settings.keys = {
	pitched = settings.piano_keys.pitched,
	play = "space",
	rest = "del",
}


function settings.load()
	mkdir("/appdata/drakmaniso/")
	mkdir("/appdata/drakmaniso/visitrack/")
	--local user_settings = fetch "/appdata/drakmaniso/settings.pod"
	local user_keys = fetch(keys_filepath)
	if user_keys then
		for k, v in pairs(settings.keys) do
			if user_keys[k] then
				settings.keys[k] = user_keys[k]
			end
		end
	end
end


function settings.change_keys(t)
	for k, v in pairs(t) do
		settings.keys[k] = v
	end
	store(keys_filepath, settings.keys)
end


return settings
:: src/sfx.lua
--[[pod_format="raw",created="2024-04-07 08:22:05",modified="2024-04-21 14:25:47",revision=6243]]
local sfx = {}


local sfx_index = 0x030000
local sfx_instr = 0x040000
local sfx_track = 0x050000
local sfx_wave = 0xf00000 -- maybe not? (search discord)


local num_instrument = 0
local num_tracks = 0
local num_patterns = 0
local header_flags = 0
local insts_addr = 0
local tracks_addr = 0
local patterns_addr = 0


function sfx.read_header()
	num_instruments = peek2(sfx_index)
	num_tracks = peek2(sfx_index + 2)
	num_patterns = peek2(sfx_index + 4)
	header_flags = peek2(sfx_index + 6)
	-- unused: peek2(sfx_index + 8)
	insts_addr = peek4(sfx_index + 10)
	tracks_addr = peek4(sfx_index + 14)
	patterns_addr = peek4(sfx_index + 18)
	?header_flags
	?string.format("%x", insts_addr)
	?string.format("%x", tracks_addr)
	?string.format("%x", patterns_addr)
end


function sfx.play_or_pause()
	-- is `stat(464)` enough?
	if stat(464) == 0 then
		music(0)
	else
		note()
	end
end


function sfx.channel_is_muted(pattern, channel)
	local channel_mutes = peek(0x30100 + (pattern * 20) + 9)
	local muted = (channel_mutes & (1 << channel)) == 0
	return muted
end


function sfx.mute_channel(pattern, channel, mute)
	local channel_mutes = peek(0x30100 + (pattern * 20) + 9)
	channel_mutes &= ~(1 << channel)
	channel_mutes |= (mute and 0 or 1) << channel
	poke(0x30100 + (pattern * 20) + 9, channel_mutes)
end


function sfx.pattern_track(pattern, channel)
	return peek(0x30100 + pattern * 20 + channel)
end


function sfx.track_speed(track)
	return peek(0x50000 + (track * 328) + 2)
end


function sfx.set_track_speed(track, val)
	return poke(0x50000 + (track * 328) + 2, val)
end


function sfx.track_loop0(track)
	return peek(0x50000 + (track * 328) + 3)
end


function sfx.set_track_loop0(track, val)
	return poke(0x50000 + (track * 328) + 3, val)
end


function sfx.track_loop1(track)
	return peek(0x50000 + (track * 328) + 4)
end


function sfx.set_track_loop1(track, val)
	return poke(0x50000 + (track * 328) + 4, val)
end


-- Track notes -------------------------------------------------------------


function sfx.track_pitch(track, step)
	return peek(0x50000 + 8 + (track * 328) + step)
end
function sfx.set_track_pitch(track, step, v)
	return poke(0x50000 + 8 + (track * 328) + step, v)
end


function sfx.track_instrument(track, step)
	return peek(0x50000 + 8 + (track * 328) + step + 64)
end
function sfx.set_track_instrument(track, step, v)
	return poke(0x50000 + 8 + (track * 328) + step + 64, v)
end


function sfx.track_volume(track, step)
	return peek(0x50000 + 8 + (track * 328) + step + (2 * 64))
end
function sfx.set_track_volume(track, step, v)
	return poke(0x50000 + 8 + (track * 328) + step + (2 * 64), v)
end


function sfx.track_fx(track, step)
	return peek(0x50000 + 8 + (track * 328) + step + (3 * 64))
end
function sfx.set_track_fx(track, step, v)
	return poke(0x50000 + 8 + (track * 328) + step + (3 * 64), v)
end


function sfx.track_fx_params(track, step)
	return peek(0x50000 + 8 + (track * 328) + step + (4 * 64))
end
function sfx.track_fx_param0(track, step)
	return peek(0x50000 + 8 + (track * 328) + step + (4 * 64)) >> 4
end
function sfx.track_fx_param1(track, step)
	return peek(0x50000 + 8 + (track * 328) + step + (4 * 64)) & 0xf
end
function sfx.set_track_fx_params(track, step, v)
	return poke(0x50000 + 8 + (track * 328) + step + (4 * 64), v)
end
function sfx.set_track_fx_param0(track, step, v)
	local previous = peek(0x50000 + 8 + (track * 328) + step + (4 * 64))
	return poke(0x50000 + 8 + (track * 328) + step + (4 * 64), (previous & 0x0f) | (v << 4))
end
function sfx.set_track_fx_param1(track, step, v)
	local previous = peek(0x50000 + 8 + (track * 328) + step + (4 * 64))
	return poke(0x50000 + 8 + (track * 328) + step + (4 * 64), (previous & 0xf0) | (v & 0x0f))
end
-- Pattern flow flags ------------------------------------------------------


function sfx.pattern_loop_start(pattern)
	return (peek(0x30100 + (pattern * 20) + 8) & 0x01) != 0
end


function sfx.set_pattern_loop_start(pattern, bool)
	local old = peek(0x30100 + (pattern * 20) + 8)
	if bool then
		poke(0x30100 + (pattern * 20) + 8, old | 0x01)
	else
		poke(0x30100 + (pattern * 20) + 8, old & (~ 0x01))
	end
end


function sfx.pattern_loop_end(pattern)
	return (peek(0x30100 + (pattern * 20) + 8) & 0x02) != 0
end


function sfx.set_pattern_loop_end(pattern, bool)
	local old = peek(0x30100 + (pattern * 20) + 8)
	if bool then
		poke(0x30100 + (pattern * 20) + 8, old | 0x02)
	else
		poke(0x30100 + (pattern * 20) + 8, old & (~ 0x02))
	end
end


function sfx.pattern_loop_stop(pattern)
	return (peek(0x30100 + (pattern * 20) + 8) & 0x04) != 0
end


function sfx.set_pattern_loop_stop(pattern, bool)
	local old = peek(0x30100 + (pattern * 20) + 8)
	if bool then
		poke(0x30100 + (pattern * 20) + 8, old | 0x04)
	else
		poke(0x30100 + (pattern * 20) + 8, old & (~ 0x04))
	end
end

------------------------------------------------------------------------------
-- The Synth -----------------------------------------------------------------
------------------------------------------------------------------------------


-- Node tree -----------------------------------------------------------------


sfx.nodes = {}
for n = 0, 7 do
	sfx.nodes[n] = {
		parent = nil, -- id of the parent
		children = {}, -- list of direct references to the children
		type = nil,
	}
end
	

local function depth_walk(root, pre_fun, post_fun, depth)
	if (not depth) depth = 0
	if depth > 8 then
		-- TODO: remove notification
		notify("*** Deep recursion: cycle in synth nodes? ***")
		return
	end
	if (pre_fun) pre_fun(root)
	for i = 1, #root.children do
		local child = root.children[i]
		if child.type != 0 then
			depth_walk(child, pre_fun, post_fun, depth + 1)
		end
	end
	if (post_fun) post_fun(root)
end


function sfx.refresh_nodes(instrument)
	for n = 0, 7 do
		sfx.nodes[n].id = n
		sfx.nodes[n].children = {}
		sfx.nodes[n].older_sibling = nil
		sfx.nodes[n].height = nil -- TODO: or 0?
		sfx.nodes[n].position = nil
	end
	sfx.root = sfx.nodes[0]
	sfx.root.free_nodes = 7
	--- printh("* refresh *")
	for n = 0, 7 do
		local type = sfx.node_type(instrument, n)
		local op = sfx.node_op(instrument, n)
		local parent_id = sfx.node_parent(instrument, n)
		--- printh("" .. parent_id .. " -> " .. n .. " type=" .. type .. " op=" .. op)
		sfx.nodes[n].parent = sfx.nodes[parent_id]
		sfx.nodes[n].type = type
		sfx.nodes[n].op = op
		sfx.nodes[n].last_child = function(self)
			if (#self.children == 0) return self
			return self.children[#self.children]:last_child()
		end
		if type != 0 and n != 0 then
			add(sfx.nodes[n].parent.children, sfx.nodes[n])
			sfx.root.free_nodes -= 1
		end
	end
	
	depth_walk(
		sfx.root,
		nil,
		function(node)
			if #node.children == 0 then
				node.height = 1
			else
				local h = 0
				for i = 1, #node.children do
					local child = node.children[i]
					if i > 1 then
						child.older_sibling = node.children[i - 1]
					end
					h += child.height
				end
				node.height = h
			end
		end
	)

	sfx.root.position = { row = 0, column = 0 }
	depth_walk(
		sfx.root,
		function(node)
			local row = node.position.row
			for i = 1, #node.children do
				node.children[i].position = {
					column = node.position.column + 1,
					row = row,
				}
				row += node.children[i].height
			end
		end,
		nil
	)
end


function sfx.add_node(instrument, parent_id, node_type, node_op, target_id)
	local parent = sfx.nodes[parent_id]
	
	if (not parent) notify("invalid parent (nil)"); return
	if (parent.type >= 8) notify("invalid parent (filter)"); return
--[[
	local target = parent
	local depth = 0

	while #target.children != 0 and depth < 10 do
		target = target.children[#target.children]
		depth += 1
	end
	local target_id = target.id + 1
	
	if node_type == 2 and node_op != 0 then
		-- modulating oscillators are always the first child
		target_id = parent.id + 1 
		local first_child_op = sfx.node_op(instrument, target_id)
		if first_child_op > 0 then
			-- already a node with a modulating operator: refuse to create
			return
		end
	end
]]--
	if target_id >= 8 then
		-- no room!
		return
	end	

	sfx.insert_node(instrument, target_id, parent_id)
	
	if node_type == 0x2 and node_op == 1 then
		-- FM mod osc
		sfx.set_node_type(instrument, target_id, node_type)
		sfx.set_node_op(instrument, target_id, node_op)
		sfx.set_node_param_val1(instrument, target_id, 0, 0x20) -- volume
		sfx.set_node_param_flags(instrument, target_id, 2, 0x02) -- not quantized, and relation + for tune
		sfx.set_node_param_flags(instrument, target_id, 3, 0x01) -- relation + for bend
	elseif node_type == 0x2 and node_op == 2 then
		-- Ring mod osc
		sfx.set_node_type(instrument, target_id, node_type)
		sfx.set_node_op(instrument, target_id, node_op)
		sfx.set_node_param_val1(instrument, target_id, 0, 0x20) -- volume
		sfx.set_node_param_flags(instrument, target_id, 2, 0x01) -- not quantized, and relation + for tune
		sfx.set_node_param_flags(instrument, target_id, 3, 0x01) -- relation + for bend
	elseif node_type == 0x2 then
		-- Osc
		sfx.set_node_type(instrument, target_id, node_type)
		sfx.set_node_op(instrument, target_id, node_op)
		sfx.set_node_param_val1(instrument, target_id, 0, 0x20) -- volume
		sfx.set_node_param_flags(instrument, target_id, 0, 0x02) -- relation * for volume
		sfx.set_node_param_flags(instrument, target_id, 1, 0x01) -- relation + for pan
		sfx.set_node_param_flags(instrument, target_id, 2, 0x21) -- quantized, and relation + for tune
		sfx.set_node_param_flags(instrument, target_id, 3, 0x01) -- relation + for bend
	else
		sfx.set_node_type(instrument, target_id, node_type)
	end
	return target_id
end


-- Node configuration ------------------------------------------------------------


function sfx.delete_node(instrument, node_id)
	local deleted_node_parent = sfx.node_parent(instrument, node_id)
	local inst_addr = 0x40000 + instrument * 0x200
	-- move everything up
	for j = node_id, 7 do
		memcpy(inst_addr + j * 0x20, inst_addr + (j + 1) * 0x20, 0x20)
	end
	memset(inst_addr + 7 * 0x20, 0, 0x20)
	-- fix parents
	for j = 0, 6 do
		local parent = sfx.node_parent(instrument, j)
		if parent == node_id then
			sfx._set_node_parent(instrument, j, deleted_node_parent)
		elseif parent > node_id then
			sfx._set_node_parent(instrument, j, parent - 1)
		end
	end
end


function sfx.insert_node(instrument, node_id, parent_id)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node_id * 0x20
	-- move everything down
	for j = 7, node_id + 1, -1 do
		memcpy(inst_addr + j * 0x20, inst_addr + ( j - 1) * 0x20, 0x20)
	end
	memset(node_addr, 0, 0x20)
	-- fix parents
	poke(node_addr, parent_id)
	for j = 0, 7 do
		local parent = sfx.node_parent(instrument, j)
		if parent >= node_id then
			sfx._set_node_parent(instrument, j, parent + 1)
		end
	end
end


function sfx.node_parent(instrument, node)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr + 0) & 0x7	
end

function sfx._set_node_parent(instrument, node, parent)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	local previous = peek(node_addr + 0)
	poke(node_addr + 0, (previous & ~0x7) | (parent & 0x7))
end

function sfx.node_op(instrument, node)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr) >> 4
end

function sfx.set_node_op(instrument, node, op)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	local previous = peek(node_addr)
	poke(node_addr, (previous & 0x0f) | (op << 4))
end

function sfx.node_type(instrument, node)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr + 1) & 0xf
end

function sfx.set_node_type(instrument, node, type)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	local previous = peek(node_addr + 1)
	poke(node_addr + 1, (previous & 0xf0) | (type & 0x0f))
end

function sfx.node_osc_wavetable(instrument, node)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr + 1) >> 4
end

function sfx.set_node_osc_wavetable(instrument, node, wt)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	local previous = peek(node_addr + 1)
	poke(node_addr + 1, (previous & 0x0f) | (wt << 4))
end

function sfx.node_flags(instrument, node)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr + 2)
end

function sfx.set_node_flags(instrument, node, flags)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 2, flags)
end

-- node_addr + 3 is unused

-- 0 <= p <= 7
function sfx.node_param(instrument, node, p)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	local flags,val1,val0,env = peek(node_addr + 4 + (4 * p), 4)
	return flags, val1, val0, env
end

function sfx.set_node_param_flags(instrument, node, p, flags)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 4 + (4 * p), flags)
end

function sfx.set_node_param_val1(instrument, node, p, val1)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 4 + (4 * p) + 1, val1)
end

function sfx.set_node_param_val0(instrument, node, p, val0)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 4 + (4 * p) + 2, val0)
end

function sfx.set_node_param_env(instrument, node, p, env)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 4 + (4 * p) + 3, env)
end

function sfx.node_wavetable_info(instrument, node)
	local inst_addr = 0x40000 + instrument * 0x200
	local wt_4defs_addr = inst_addr + 0x1e0 -- start of the 4 wt definitions
	local node_addr = inst_addr + node * 0x20
	local wt_index = (peek(node_addr+1)>>4)
	local wt_def_addr = wt_4defs_addr + wt_index * 4
	local addr0, addr1, width_bits, wt_height = peek(wt_def_addr,4)
	local dat_addr = (addr0 << 8) | (addr1 << 16)
	local wt_width = 1 << width_bits
	return dat_addr, wt_width, wt_height
end

-- Envelopes -------------------------------------------------------------------

function sfx.env_type(instrument, env)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr)
end

function sfx.set_env_type(instrument, env, type)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr, type)
end

function sfx.env_flags(instrument, env)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 1)
end

function sfx.set_env_flags(instrument, env, flags)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 1, flags)
end

function sfx.env_speed(instrument, env)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 2)
end

function sfx.set_env_speed(instrument, env, val)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 2, val)
end

function sfx.env_loop0(instrument, env)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 3)
end

function sfx.set_env_loop0(instrument, env, val)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 3, val)
end

function sfx.env_loop1(instrument, env)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 4)
end

function sfx.set_env_loop1(instrument, env, val)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 4, val)
end

function sfx.env_start(instrument, env)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 5)
end

function sfx.set_env_start(instrument, env, val)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 5, val)
end

function sfx.env_param(instrument, env, param)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 8 + param)
end

function sfx.set_env_param(instrument, env, param, val)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 8 + param, val)
end

return sfx
:: src/slider.lua
--[[pod_format="raw",created="2024-04-19 14:52:31",modified="2024-04-21 16:15:13",revision=1707]]
local app = require "src/app"
local envelopes = require "src/envelopes"
local sfx = require "src/sfx"
local synth_menus = require "src/synth_menus"
local visual = require "src/visual"


local slider = {}


function slider.attach(parent, el)
	el.x = el.x or 0
	el.y = el.y or (12 + 10 * el.param)
	el.width = parent.large and 110 or parent.width
	el.height = 10
	parent:attach(el)
	el.large = parent.large
	el.dragged = nil

	local node_type = sfx.node_type(app.instrument, el.node_id)


	if (not el.min_val) el.min_val = -128	
	if (not el.max_val) el.max_val = 127
--[[
	if (el.label == "vol") el.min_val, el.max_val = 0, 64
	-- This is disabled in sfx.p64
	--if (el.label == "tune") el.min_val, el.max_val = -120, 120 -- el.ac = 20 el.a0 = 0.5
	if (el.label == "wave") el.min_val, el.max_val = 0, 255
	
	-- fx parameters are all 0..255 (flag 0x8 is not set)
	if (node_type >= 8) el.min_val, el.max_val = 0, 255
		
	-- gain mix; can use *8 if want to over mix!
	if (el.label == "mix") el.min_val, el.max_val = 0, 64
]]

	function el:draw()
		local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
		local node_type = sfx.node_type(app.instrument, self.node_id)

		if self.max_val < 128 then -- signed int8's
			if (val1 >= 128) val1 -= 256
			if (val0 >= 128) val0 -= 256
		end
		
		-- Label --
		print(self.label, 24 - (4 * #self.label), 1, 5)
		
		-- Relationship --
		if node_type < 8 then	-- (only oscillators have relationships)
			if flags & 0x3 > 0 then
				local letter = "\-h\|f?"
				if (flags & 0x3 == 0x1) letter = "\-d\^:2070200000000000" -- +
				if (flags & 0x3 == 0x2) letter = "\-d\^:5020500000000000" -- *
				print(letter, 26, 2, 59)
			else
				print("\-d\^:0020000000000000", 26, 2, 22) -- .
			end
		end
		
		-- Slider --
		local full_x = self.width - 53
		local range = self.max_val - self.min_val
		rectfill(32, 0, 32 + full_x, 6, 59)
		local x_zero = mid(0, ((- self.min_val) * full_x) \ range, full_x)
		local x0 = mid(0, ((val0 - self.min_val) * full_x) \ range, full_x)
		local x1 = mid(0, ((val1 - self.min_val) * full_x) \ range, full_x)
		-- ensure that small values are visible
		if self.min_val < 0 then
			if (val1 > 0 and x1 == full_x \ 2) x1 = (full_x \ 2) + 1
			if (val1 < 0 and x1 == full_x \ 2) x1 = (full_x \ 2) - 1
		else
			if (val1 > 0 and x1 == 0) x1 = 1
		end
		if val0 != val1 and x0 == x1 then
			if (val0 < val1) x0 = max(0, x1 - 1)
			if (val0 > val1) x0 = min(x1 + 1, 31)
		end
		if flags & (0x4 | 0x10) == 0 then
			rectfill(32 + x_zero, 0, 32 + x1, 6, 2)
		end
		if (flags & 0x4) > 0 or (flags & 0x10) > 0 or self.show_val0 then
			rectfill(32 + x0, 0, 32 + x1, 6, (self.dragged and self.show_val0) and 18 or 18)
			line(32 + x0, 0, 32 + x0, 6, (self.dragged and self.show_val0) and 29 or 18)
		end
		if self.min_val < 0 or true then
			line(32 + x_zero, 6, 32 + x1, 6, self.dragged and 7 or 15)
		end
		line(32 + x1, 0, 32 + x1, 6, self.dragged and 7 or 15)
		
		-- Numerical value --
		local str = ""
		local col = 0
		if self.show_val0 then
			if el.label == "tune" and flags & 0x3 == 2 then
				local num0 = 1 + val0 % 16
				local den0 = 1 + val0 \ 16
				str = num0 .. "/" .. den0
			else
				str = tostr(val0)
			end
			col = 7
		else
			if el.label == "tune" and flags & 0x3 == 2 then
				local num1 = 1 + val1 % 16
				local den1 = 1 + val1 \ 16
				str = num1 .. "/" .. den1
			else
				str = tostr(val1)
			end
			col = self.dragged and 7 or 6
		end
		local x = 32 + full_x - 4 * #str
		if x1 > full_x - 4 * #str - 2 then
			x = 32 + 2
		end
		print(str, x, 1, col)

		-- Multiplier --
		local mx = self.width - 22
		if (env & 0xc0 > 0) then
			str2 = (env & 0x20 == 0) and 
				"\^:5020500000000000" or  -- *
				"\^:4020100000000000"     -- /
			if (env & 0xc0 == 0x40) str2 = str2 .. "\-c\^:5070400000000000" -- 4
			if (env & 0xc0 == 0x80) str2 = "\-e" .. str2 .. "\^:1372770000000000" -- 16
			if (env & 0xc0 == 0xc0) str2 = "\-e" .. str2 .. "\^:5177470000000000" -- 64
			print(str2, mx, 2, 24)
		else
			print("\^:0020000000000000", mx, 2, 22) -- .
		end
		
		-- Envelope --
		local mx = self.width - 6
		if flags & 0x4 > 0 then
			rectfill(mx - 1, 0, mx + 3, 6, 18)
			rectfill(mx - 2, 1, mx + 4, 5, 18)
			if flags & 0x8 > 0 then
				-- Free running envelope.
				print(env & 0xf, mx, 0, 7)
				print("\^:1500000000000000", mx - 1, 6, 7) -- 3 dots
			else
				print(env & 0xf, mx, 1, 7)
			end
		elseif flags & 0x10 > 0 then
			rectfill(mx - 1, 0, mx + 3, 6, 30)
			rectfill(mx - 2, 1, mx + 4, 5, 30)
			print("r", mx, 1, 7)
		else
			rectfill(mx, 1, mx + 2, 5, 58)
			rectfill(mx - 1, 2, mx + 3, 4, 58)
		end
	end
	
	function el:hover(msg)
		if msg.mx <= 24 then
			-- on label
			self.cursor = 1
		elseif msg.mx <= 32 then
			-- on relationship
			self.cursor = "pointer"
		elseif msg.mx <= self.width - 20 then
			-- on slider
			self.cursor = get_spr(50)
		elseif msg.mx <= self.width - 12 then
			-- on multiplier
			self.cursor = "pointer"
		else
			-- on modulator
			self.cursor = "pointer"
		end
	end
	
	function el:click(msg)
		if 32 <= msg.mx and msg.mx <= self.width - 20 then
			local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
			local node_type = sfx.node_type(app.instrument, self.node_id)
			self.dragged = true
			self.show_val0 = msg.mb == 2
			self.cursor = 0
			local sensitivity = key("shift") and 0.1 or 0.5
			sensitivity *= self.sensitivity or 1
			mouselock(0x4|0x8, sensitivity, 0.0)
			if node_type == 2 and (self.param == 4 or self.param == 5) and (not self.large) then
				visual.open_wavetable(self.node_id, self.show_val0)
			end
		elseif msg.mx <= 24 and msg.mb == 2 then
			self.show_val0 = true
		end
		return true -- don't pass to parent to avoid selection
	end
	
	function el:tap(msg)
		if msg.mx <= 24 then
			-- on label
		elseif msg.mx <= 32 then
			synth_menus.open_relationship(self)
		elseif msg.mx <= self.width - 20 then
			-- on slider
		elseif msg.mx <= self.width - 12 then
			synth_menus.open_multiplier(self)
		else
			synth_menus.open_envelope(self)
		end
	end

	function el:doubleclick(msg)
		if 32 <= msg.mx and msg.mx <= self.width - 20 then
			local init = self.init_val or 0
			if msg.mb == 1 then
				sfx.set_node_param_val1(app.instrument, self.node_id, self.param, init)
			else
				sfx.set_node_param_val0(app.instrument, self.node_id, self.param, 0)
			end
			self.dragged = nil
		end
	end
	
	function el:drag(msg)
		if (not self.dragged) return

		local sensitivity = key("shift") and 0.1 or 0.5
		sensitivity *= self.sensitivity or 1
		local _, delta = mouselock(0x04|0x08, sensitivity, 0)
		if delta < 0 then
			self.down_barrier = nil
			if self.up_barrier then
				self.up_barrier += delta
				if self.up_barrier <= 0 then
					self.up_barrier = nil
				else
					return
				end
			end
		elseif delta > 0 then
			self.up_barrier = nil
			if self.down_barrier then
				self.down_barrier -= delta
				if self.down_barrier <= 0 then
					self.down_barrier = nil
				else
					return
				end
			end
		end
				
		local flags, val1, val0, _env = sfx.node_param(app.instrument, self.node_id, self.param)
		-- Handle signed i8s
		if (el.max_val < 128) then
			if (val0 >= 128) val0 -= 256
			if (val1 >= 128) val1 -= 256
		end
		if msg.mb == 1 then
			local new = val1 - delta
			if val1 > 0 and new <= 0 then
				new = 0
				self.down_barrier = 24
			end
			if val1 < 0 and new >= 0 then
				new = 0
				self.up_barrier = 24
			end
			new = mid(self.min_val, new, self.max_val)
			sfx.set_node_param_val1(app.instrument, self.node_id, self.param, new)
		else
			local new = val0 - delta
			new = mid(self.min_val, new, self.max_val)
			sfx.set_node_param_val0(app.instrument, self.node_id, self.param, new)
		end
	end
	
	function el:release(msg)
		mouselock(false)
		self.dragged = nil
		self.up_barrier = nil
		self.down_barrier = nil
		self.show_val0 = false
		visual.close()
	end

	return el
end


return slider
:: src/synth.lua
--[[pod_format="raw",created="2024-04-12 16:30:23",modified="2024-04-21 16:15:13",revision=7186]]
local app = require "src/app"
local envelopes = require "src/envelopes"
local knob = require "src/knob"
local sfx = require "src/sfx"
local slider = require "src/slider"
local visual = require "src/visual"


local synth = {}


-- Node panels --------------------------------------------------------------------


function synth.attach_node_panel(parent, el)
	if app.node and app.node == el.node_id then
		el.width = 480 - 4 * app.mod_width - 6 * app.synth_gap
		el.height = 2 * app.synth_height + app.synth_gap
	else
		el.width = app.synth_width
		el.height = app.synth_height
	end
	parent:attach(el)
	
	local type = sfx.node_type(app.instrument, el.node_id)
	if el.node_id == 0 then return synth.populate_root(parent, el)
	elseif type == 0 then return synth.populate_unused(parent, el)
	elseif type == 2 then
		local op = sfx.node_op(app.instrument, el.node_id)
		if op == 0 then return synth.populate_osc(parent, el)
		elseif op == 1 then return synth.populate_fm(parent, el)
		elseif op == 2 then return synth.populate_ring(parent, el)
		end
	elseif type == 8 then return synth.populate_filt(parent, el)
	elseif type == 9 then return synth.populate_echo(parent, el)
	elseif type == 10 then return synth.populate_shap(parent, el)
	end
	return synth.populate_unknown(parent, el)
end


function synth.populate_unused(parent, el)
	function el:draw()
		rectfill(0, 0, self.width, self.height, 62)
		synth.draw_corners(self)
		local x, y = 19, 14
		pal(7, 61)
		sspr(63, 0, 0, 7, 7, x, y, x + (7 * 4), y + (7 * 4))
		pal(7, 7)
		if self.node_id == 7 then
			print("pfx6416", 52, 63, 5)
		end
	end
	return el
end


function synth.populate_root(parent, el)
	local params = {
		[0] = { label = "vol", long_label = "volume", param = 0,
			min_val = 0, max_val = 64, init_val = 32, sensitivity = 0.25 },
		{ label = "pan", param = 1, min_val = -128, max_val = 127, },
		{ label = "tune", param = 2, min_val = -128, max_val = 127, },
		{ label = "bend", param = 3, min_val = -128, max_val = 127, },
	}
	for i = 0, #params do params[i].node_id = el.node_id end

	if el.large then
		knob.attach(el, 20, 16, params[0], { emphasis = true})
		knob.attach(el, 60, 16, params[1], { small = true })
		knob.attach(el, 20, 84, params[2], { small = true })
		knob.attach(el, 60, 84, params[3], { small = true })
	else
		knob.attach_mini(el, params[0] )
		knob.attach_mini(el, params[1] )
		knob.attach_mini(el, params[2] )
		knob.attach_mini(el, params[3] )
		--- slider.attach(el, { label = "p0", param = 4, node_id = el.node_id } )
		--- slider.attach(el, { label = "p1", param = 5, node_id = el.node_id } )
	end
	function el:draw()
		rectfill(0, 0, self.width, 9, 7)
		rectfill(0, 9, self.width, self.height, 6)
		synth.draw_corners(self)
		print("synthesizer", 4, 2, 22)
	end
	function el:click() return true end
	function el:doubleclick() app.node = self.node_id; app.refresh_gui = true end
	return el
end


-- Oscillator -------------------------------------------------------------------


local wt_labels = { [0] = "wt0", "wt1", "wt2", "wt3" }
local wt_long_labels = { [0] = "wavetable 0", "wavetable 1", "wavetable 2", "wavetable 3" }
local osc_params = {
	[0] = { label = "vol", long_label = "volume", param = 0,
		min_val = 0, max_val = 64, init_val = 32, sensitivity = 0.25 },
	{ label = "pan", param = 1, min_val = -128, max_val = 127, },
	{ label = "tune", param = 2, min_val = -128, max_val = 127, },
	{ label = "bend", param = 3, min_val = -128, max_val = 127, },
	{ label = "", long_label = "wave", param = 4, min_val = 0, max_val = 255, },
	{ label = "phase", param = 5, min_val = -128, max_val = 127, },
}

function synth.populate_osc(parent, el)
	local params = unpod(pod(osc_params))
	for i = 0, #params do params[i].node_id = el.node_id end
	local flags, _, _, _ = sfx.node_param(app.instrument, el.node_id, 2)
	if flags & 0x03 == 0x02 then
		-- tune param in "multiply" relationship:
		-- change the min and max values
		params[2].min_val = 0
		params[2].max_val = 255
	end

	synth.attach_mute_toggle(el, { label = "osc", node_id = el.node_id })
	synth.attach_close_button(el, { node_id = el.node_id })
	if el.large then
		visual.attach_wavetable(el, el.node_id, false, { x = 114, y = 14, width = 104, height = 58 })
		knob.attach(el, 20, 16, params[0], { emphasis = true})
		knob.attach(el, 60, 16, params[1], { small = true })
		knob.attach(el, 20, 84, params[2], { small = true })
		knob.attach(el, 60, 84, params[3], { small = true })
		knob.attach(el, 130, 84, params[4], { emphasis = true })
		knob.attach(el, 170, 84, params[5], { small = true })
		app.attach_menu_button(el, {
			x = 142, y = 72,
			get_label = function()
				local wt = sfx.node_osc_wavetable(app.instrument, el.node_id)
				return wt_long_labels[wt] or "wt?"
			end,
			fg = 5,
			highlight = 15,
			items = {
				{ label = "wavetable 0", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 0) end },
				{ label = "wavetable 1", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 1) end },
				{ label = "wavetable 2", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 2) end },
				{ label = "wavetable 3", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 3) end },
			}
		})
	else
		knob.attach_mini(el, params[0])
		knob.attach_mini(el, params[1])
		knob.attach_mini(el, params[2])
		knob.attach_mini(el, params[3])
		knob.attach_mini(el, params[4])
		knob.attach_mini(el, params[5])
		app.attach_menu_button(el, {
			x = 2, y = 51,
			get_label = function()
				local wt = sfx.node_osc_wavetable(app.instrument, el.node_id)
				return wt_labels[wt] or "wt?"
			end,
			fg = 5,
			highlight = 15,
			items = {
				{ label = "wt 0", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 0) end },
				{ label = "wt 1", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 1) end },
				{ label = "wt 2", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 2) end },
				{ label = "wt 3", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 3) end },
			}
		})
	end
	
	function el:click() return true end
	function el:doubleclick() app.node = self.node_id; app.refresh_gui = true end
		
	function el:draw()
		rectfill(0, 0, self.width, 9, 17)
		rectfill(0, 9, self.width, self.height, 6)
		synth.draw_corners(self)
		line(113, 90, 113, 138, 5)
	end
	
	return el
end


-- FM modulator -------------------------------------------------------------------


function synth.populate_fm(parent, el)
	local params = unpod(pod(osc_params))
	for i = 0, #params do params[i].node_id = el.node_id end
	local flags, _, _, _ = sfx.node_param(app.instrument, el.node_id, 2)
	if flags & 0x03 == 0x02 then
		-- tune param in "multiply" relationship:
		-- change the min and max values
		params[2].min_val = 0
		params[2].max_val = 255
	end

	synth.attach_mute_toggle(el, { label = "fm", node_id = el.node_id })
	synth.attach_close_button(el, { node_id = el.node_id })
	if el.large then
		visual.attach_wavetable(el, el.node_id, false, { x = 114, y = 14, width = 104, height = 58 })
		knob.attach(el, 20, 16, params[0], { emphasis = true})
		knob.attach(el, 60, 16, params[1], { small = true })
		knob.attach(el, 20, 84, params[2], { small = true })
		knob.attach(el, 60, 84, params[3], { small = true })
		knob.attach(el, 130, 84, params[4], { emphasis = true })
		knob.attach(el, 170, 84, params[5], { small = true })
		app.attach_menu_button(el, {
			x = 142, y = 72,
			get_label = function()
				local wt = sfx.node_osc_wavetable(app.instrument, el.node_id)
				return wt_long_labels[wt] or "wt?"
			end,
			fg = 5,
			highlight = 15,
			items = {
				{ label = "wavetable 0", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 0) end },
				{ label = "wavetable 1", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 1) end },
				{ label = "wavetable 2", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 2) end },
				{ label = "wavetable 3", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 3) end },
			}
		})
	else
		knob.attach_mini(el, params[0])
		knob.attach_mini(el, params[1])
		knob.attach_mini(el, params[2])
		knob.attach_mini(el, params[3])
		knob.attach_mini(el, params[4])
		knob.attach_mini(el, params[5])
		app.attach_menu_button(el, {
			x = 2, y = 51,
			get_label = function()
				local wt = sfx.node_osc_wavetable(app.instrument, el.node_id)
				return wt_labels[wt] or "wt?"
			end,
			fg = 5,
			highlight = 15,
			items = {
				{ label = "wt 0", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 0) end },
				{ label = "wt 1", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 1) end },
				{ label = "wt 2", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 2) end },
				{ label = "wt 3", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 3) end },
			}
		})
	end
	
	function el:click() return true end
	function el:doubleclick() app.node = self.node_id; app.refresh_gui = true end
		
	function el:draw()
		rectfill(0, 0, self.width, 9, 27)
		rectfill(0, 9, self.width, self.height, 6)
		synth.draw_corners(self)
		line(113, 90, 113, 138, 5)
	end
	
	return el
end


-- Ring mod -------------------------------------------------------------------


function synth.populate_ring(parent, el)
	local params = unpod(pod(osc_params))
	for i = 0, #params do params[i].node_id = el.node_id end
	local flags, _, _, _ = sfx.node_param(app.instrument, el.node_id, 2)
	if flags & 0x03 == 0x02 then
		-- tune param in "multiply" relationship:
		-- change the min and max values
		params[2].min_val = 0
		params[2].max_val = 255
	end

	synth.attach_mute_toggle(el, { label = "ring", node_id = el.node_id })
	synth.attach_close_button(el, { node_id = el.node_id })
	if el.large then
		visual.attach_wavetable(el, el.node_id, false, { x = 114, y = 14, width = 104, height = 58 })
		knob.attach(el, 20, 16, params[0], { emphasis = true})
		knob.attach(el, 60, 16, params[1], { small = true })
		knob.attach(el, 20, 84, params[2], { small = true })
		knob.attach(el, 60, 84, params[3], { small = true })
		knob.attach(el, 130, 84, params[4], { emphasis = true })
		knob.attach(el, 170, 84, params[5], { small = true })
		app.attach_menu_button(el, {
			x = 142, y = 72,
			get_label = function()
				local wt = sfx.node_osc_wavetable(app.instrument, el.node_id)
				return wt_long_labels[wt] or "wt?"
			end,
			fg = 5,
			highlight = 15,
			items = {
				{ label = "wavetable 0", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 0) end },
				{ label = "wavetable 1", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 1) end },
				{ label = "wavetable 2", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 2) end },
				{ label = "wavetable 3", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 3) end },
			}
		})
	else
		knob.attach_mini(el, params[0])
		knob.attach_mini(el, params[1])
		knob.attach_mini(el, params[2])
		knob.attach_mini(el, params[3])
		knob.attach_mini(el, params[4])
		knob.attach_mini(el, params[5])
		app.attach_menu_button(el, {
			x = 2, y = 51,
			get_label = function()
				local wt = sfx.node_osc_wavetable(app.instrument, el.node_id)
				return wt_labels[wt] or "wt?"
			end,
			fg = 5,
			highlight = 15,
			items = {
				{ label = "wt 0", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 0) end },
				{ label = "wt 1", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 1) end },
				{ label = "wt 2", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 2) end },
				{ label = "wt 3", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 3) end },
			}
		})
	end
	
	function el:click() return true end
	function el:doubleclick() app.node = self.node_id; app.refresh_gui = true end
		
	function el:draw()
		rectfill(0, 0, self.width, 9, 22)
		rectfill(0, 9, self.width, self.height, 6)
		synth.draw_corners(self)
		line(113, 90, 113, 138, 5)
	end
	
	return el
end


-- Filter ----------------------------------------------------------------------


function synth.populate_filt(parent, el)
	local params = {
		[0] =
		{ label = "low", param = 0, min_val = 0, max_val = 255, },
		{ label = "high", param = 1, min_val = 0, max_val = 255, },
		{ label = "res", param = 2, min_val = 0, max_val = 255, },
	}
	for i = 0, #params do params[i].node_id = el.node_id end
	
	synth.attach_mute_toggle(el, { label = "filt", node_id = el.node_id })
	synth.attach_close_button(el, { node_id = el.node_id })
	if el.large then
		knob.attach(el, 34, 50, params[0], {})
		knob.attach(el, 94, 50, params[2], {})
		knob.attach(el, 154, 50, params[1], {})
	else
		knob.attach_mini(el, params[0])
		knob.attach_mini(el, params[2])
		knob.attach_mini(el, params[1])
	end
	function el:draw()
		rectfill(0, 0, self.width, 9, 14)
		rectfill(0, 9, self.width, self.height, 6)
		synth.draw_corners(self)
	end
	function el:click() return true end
	function el:doubleclick() app.node = self.node_id; app.refresh_gui = true end
	return el
end


-- Delay --------------------------------------------------------------------------


function synth.populate_echo(parent, el)
	local params = {
		[0] =
		{ label = "delay", param = 0, min_val = 0, max_val = 255, },
		{ label = "vol", param = 1, min_val = 0, max_val = 255, },
	}
	for i = 0, #params do params[i].node_id = el.node_id end
	
	synth.attach_mute_toggle(el, { label = "echo", node_id = el.node_id })
	synth.attach_close_button(el, { node_id = el.node_id })
	if el.large then
		knob.attach(el, 59, 84, params[0], {})
		knob.attach(el, 130, 84, params[1], {})
	else
		knob.attach_mini(el, params[0])
		knob.attach_mini(el, params[1])
	end
	function el:draw()
		rectfill(0, 0, self.width, 9, 31)
		rectfill(0, 9, self.width, self.height, 6)
		synth.draw_corners(self)
	end
	function el:click() return true end
	function el:doubleclick() app.node = self.node_id; app.refresh_gui = true end
	return el
end


-- Waveshaper ------------------------------------------------------------------


function synth.populate_shap(parent, el)
	local params = {
		[0] =
		{ label = "gain", param = 0, min_val = 0, max_val = 255, },
		{ label = "elbow", param = 1, min_val = 0, max_val = 255, },
		{ label = "cut", param = 2, min_val = 0, max_val = 255, },
		{ label = "mix", param = 3, min_val = 0, max_val = 255, },
	}
	for i = 0, #params do params[i].node_id = el.node_id end
	
	synth.attach_mute_toggle(el, { label = "shap", node_id = el.node_id })
	synth.attach_close_button(el, { node_id = el.node_id })
	if el.large then
		knob.attach(el, 20, 16, params[0], {})
		knob.attach(el, 20, 84, params[3], { small = true })
		knob.attach(el, 130, 84, params[2], {})
		knob.attach(el, 170, 84, params[1], {})
	else
		knob.attach_mini(el, params[0])
		knob.attach_mini(el, params[1])
		knob.attach_mini(el, params[2])
		knob.attach_mini(el, params[3])
	end
	function el:draw()
		rectfill(0, 0, self.width, 9, 9)
		rectfill(0, 9, self.width, self.height, 6)
		synth.draw_corners(self)
	end
	function el:click() return true end
	function el:doubleclick() app.node = self.node_id; app.refresh_gui = true end
	return el
end

function synth.populate_unknown(parent, el)
	local params = {
		[0] =
		{ label = "p0", param = 0, min_val = 0, max_val = 255, },
		{ label = "p1", param = 1, min_val = 0, max_val = 255, },
		{ label = "p2", param = 2, min_val = 0, max_val = 255, },
		{ label = "p3", param = 3, min_val = 0, max_val = 255, },
		{ label = "p4", param = 4, min_val = 0, max_val = 255, },
		{ label = "p5", param = 5, min_val = 0, max_val = 255, },
	}
	for i = 0, #params do params[i].node_id = el.node_id end
	
	synth.attach_mute_toggle(el, { label = "???", node_id = el.node_id })
	synth.attach_close_button(el, { node_id = el.node_id })
	knob.attach_mini(el, params[0])
	knob.attach_mini(el, params[1])
	knob.attach_mini(el, params[2])
	knob.attach_mini(el, params[3])
	knob.attach_mini(el, params[4])
	knob.attach_mini(el, params[5])
	function el:draw()
		rectfill(0, 0, self.width, self.height, 30)
		rectfill(0, 9, self.width, self.height, 6)
		synth.draw_corners(self)
	end
	function el:click() return true end
	function el:doubleclick() app.node = self.node_id; app.refresh_gui = true end
	return el
end
	
function synth.draw_corners(el)
	local col = app.editor_bg
--[[
	if app.node and app.node == el.node_id then 
		clip()
		rect(-1, -1, el.width, el.height, 24)
		pset(-1, -1, app.editor_bg)
		pset(el.width, -1, app.editor_bg)
		pset(-1, el.height, app.editor_bg)
		pset(el.width, el.height, app.editor_bg)
		col = 24
	end
--]]
	pset(0, 0, col)
	pset(el.width - 1, 0, col)
	pset(0, el.height - 1, col)
	pset(el.width - 1, el.height - 1, col)
end


-- Title bar widgets -------------------------------------------------------------


function synth.attach_mute_toggle(parent, el)
	el.x = 1
	el.y = 1
	el.width = 3 + 4 * #(el.label .. " " .. el.node_id) + 3
	el.height = 9
	el.cursor = "pointer"
	parent:attach(el)
	el.muted = (sfx.node_flags(app.instrument, el.node_id) & 0x2) > 0
	function el:draw()
		local label = self.label .. " " .. self.node_id
		print(label, 3, 1, 63)
		if self.muted then
			line(1, 3, 3 + 4 * #label, 3, 24)
		end
	end
	function el:click()
		return true -- don't pass to panel to avoid selection
	end
	function el:tap()
		self.muted = not self.muted
		local flags = sfx.node_flags(app.instrument, self.node_id)
		if self.muted then
			flags |= 0x2
		else
			flags &= ~0x2
		end
		sfx.set_node_flags(app.instrument, self.node_id, flags)
	end
	return el
end




function synth.attach_close_button(parent, el)
	el.x = parent.width - 10
	el.y = 2
	el.width = 12
	el.height = 9
	el.cursor = "pointer"
	parent:attach(el)
	function el:draw()
		pal(7, 60)
		spr(36, 0, 0)
		pal(7, 7)
	end
	function el:click()
		return true -- don't pass to panel to avoid selection
	end
	function el:tap()
		if app.node and app.node >= self.node_id then
			app.node = nil
		end
		sfx.delete_node(app.instrument, self.node_id)
		app.refresh_gui = true
	end
	return el
end

return synth
:: src/synth_menus.lua
--[[pod_format="raw",created="2024-04-20 10:41:15",modified="2024-04-21 16:15:13",revision=1344]]
local app = require "src/app"
local envelopes = require "src/envelopes"
local sfx = require "src/sfx"


local synth_menus = {}


-- Relationship menu -----------------------------------------------------


function synth_menus.open_relationship(self)
	local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
	local node_type = sfx.node_type(app.instrument, self.node_id)
	
	if node_type == 0x2 and self.param == 2 then
		app.open_menu {
			x = self.sx - 10, y = self.sy + 7,
			width = 55,
			items = {
				{
					label = (flags & 0x03 == 0x00)
						and "\|f\^:1c225d5d5d221c00\|h set"
						or "\|f\^:1c22414141221c00\|h set",
					action = function()
						self.min_val, self.max_val = -128, 127
						local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
						-- set bit: replace parent
						sfx.set_node_param_flags(app.instrument, self.node_id, self.param, flags & ~0x3)
					 end,
				},
				{
					label = (flags & 0x03 == 0x01)
						and "\|f\^:1c225d5d5d221c00\|h add"
						or "\|f\^:1c22414141221c00\|h add",
					action = function()
						self.min_val, self.max_val = -128, 127
						local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
						-- set bit: add parent
						sfx.set_node_param_flags(app.instrument, self.node_id, self.param, (flags & ~0x3) | 0x1)
					 end,
				},
				{
					label = (flags & 0x03 == 0x02)
						and "\|f\^:1c225d5d5d221c00\|h multiply"
						or "\|f\^:1c22414141221c00\|h multiply",
					action = function()
						self.min_val, self.max_val = 0, 255
						local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
						-- set bit: mul parent
						sfx.set_node_param_flags(app.instrument, self.node_id, self.param, (flags & ~0x3) | 0x2)
					 end,
				},
				{ divider = true },
				{
					label = 
						(flags & 0x20 > 0)
							and "\|f\^:7f415d5d5d417f00\|h quantized"
							or "\|f\^:7f41414141417f00\|h quantized",
					action = function()
						local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
						sfx.set_node_param_flags(app.instrument, self.node_id, self.param, flags ^^ 0x20)
					 end,
				},
			}
		}
	elseif
		(node_type == 0x02 and self.param == 0)
		or (node_type == 10 and self.param == 3)
	then
		app.open_menu {
			x = self.sx - 10, y = self.sy + 7,
			width = 52,
			items = {
				{
					label = (flags & 0x03 == 0x00)
						and "\|f\^:1c225d5d5d221c00\|h set"
						or "\|f\^:1c22414141221c00\|h set",
					action = function()
						local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
						-- set bit: replace parent
						sfx.set_node_param_flags(app.instrument, self.node_id, self.param, flags & ~0x3)
					 end,
				},
				{
					label = (flags & 0x03 == 0x02)
						and "\|f\^:1c225d5d5d221c00\|h multiply"
						or "\|f\^:1c22414141221c00\|h multiply",
					action = function()
						local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
						-- set bit: mul parent
						sfx.set_node_param_flags(app.instrument, self.node_id, self.param, (flags & ~0x3) | 0x2)
					 end,
				},
			}
		}
	else
		app.open_menu {
			x = self.sx - 10, y = self.sy + 7,
			width = 40,
			items = {
				{
					label = (flags & 0x03 == 0x00)
						and "\|f\^:1c225d5d5d221c00\|h set"
						or "\|f\^:1c22414141221c00\|h set",
					action = function()
						local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
						-- set bit: replace parent
						sfx.set_node_param_flags(app.instrument, self.node_id, self.param, flags & ~0x3)
					 end,
				},
				{
					label = (flags & 0x03 == 0x01)
						and "\|f\^:1c225d5d5d221c00\|h add"
						or "\|f\^:1c22414141221c00\|h add",
					action = function()
						local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
						-- set bit: add parent
						sfx.set_node_param_flags(app.instrument, self.node_id, self.param, (flags & ~0x3) | 0x1)
					 end,
				},
			}
		}
	end
end


-- Multiplier menu -------------------------------------------------------------


function synth_menus.open_multiplier(self)
	local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
	
	local mult_options = { 
		[0] = 
		{ label = "none", val = 0x00 | 0x00 },
		{ label = "*4", val = 0x00 | 0x40 },
		{ label = "/4", val = 0x20 | 0x40 },
		{ label = "*16", val = 0x00 | 0x80 },
		{ label = "/16", val = 0x20 | 0x80 },
		{ label = "*64", val = 0x00 | 0xc0 },
		{ label = "/64", val = 0x20 | 0xc0 },
	}
	local mult_menu_items = {}
	for i = 0, #mult_options do
		add(mult_menu_items, 
			{
				label = (env & 0xe0 == mult_options[i].val)
					and ("\|f\^:1c225d5d5d221c00\|h " .. mult_options[i].label)
					or ("\|f\^:1c22414141221c00\|h " .. mult_options[i].label),
				fg = i == 0 and 5 or 24,
				action = function()
					local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
					sfx.set_node_param_env(app.instrument, self.node_id, self.param, (env & ~0xe0) | mult_options[i].val)
				 end,
			}
		)
	end

	app.open_menu {
		x = self.sx - 10, y = self.sy + 7,
		width = 36,
		items = mult_menu_items,
	}
end


-- Envelope menu ------------------------------------------------------------------


function synth_menus.open_envelope(self)
	local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
	local has_env = flags & 0x04 > 0
	local has_free_run = flags & 0x08 > 0
	local has_random = flags & 0x10 > 0
	local env_id = env & 0x0f
	app.open_menu {
		x = self.sx - 10, y = self.sy + 7,
		width = 51,
		items = {
			{
				label = (not has_env and not has_random)
					and "\|f\^:1c225d5d5d221c00\|h none"
					or "\|f\^:1c22414141221c00\|h none",
				fg = 5,
				action = function()
					local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
					sfx.set_node_param_flags(app.instrument, self.node_id, self.param, flags & ~(0x4 | 0x8 | 0x10))
				 end,
			},
			{
				label = (has_env and env_id == 0)
					and ("\|f\^:1c225d5d5d221c00\|h " .. envelopes.make_label(0))
					or ("\|f\^:1c22414141221c00\|h " .. envelopes.make_label(0)),
				fg = 18,
				action = function()
					local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
					sfx.set_node_param_flags(app.instrument, self.node_id, self.param, (flags & ~0x10) | 0x4)
					sfx.set_node_param_env(app.instrument, self.node_id, self.param, (env & 0xf0) | 0)
				 end,
			},
			{
				label = (has_env and env_id == 1)
					and ("\|f\^:1c225d5d5d221c00\|h " .. envelopes.make_label(1))
					or ("\|f\^:1c22414141221c00\|h " .. envelopes.make_label(1)),
				fg = 18,
				action = function()
					local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
					sfx.set_node_param_flags(app.instrument, self.node_id, self.param, (flags & ~0x10) | 0x4)
					sfx.set_node_param_env(app.instrument, self.node_id, self.param, (env & 0xf0) | 1)
				 end,
			},
			{
				label = (has_env and env_id == 2)
					and ("\|f\^:1c225d5d5d221c00\|h " .. envelopes.make_label(2))
					or ("\|f\^:1c22414141221c00\|h " .. envelopes.make_label(2)),
				fg = 18,
				action = function()
					local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
					sfx.set_node_param_flags(app.instrument, self.node_id, self.param, (flags & ~0x10) | 0x4)
					sfx.set_node_param_env(app.instrument, self.node_id, self.param, (env & 0xf0) | 2)
				end,
			},
			{
				label = (has_env and env_id == 3)
					and ("\|f\^:1c225d5d5d221c00\|h " .. envelopes.make_label(3))
					or ("\|f\^:1c22414141221c00\|h " .. envelopes.make_label(3)),
				fg = 18,
				action = function()
					local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
					sfx.set_node_param_flags(app.instrument, self.node_id, self.param, (flags & ~0x10) | 0x4)
					sfx.set_node_param_env(app.instrument, self.node_id, self.param, (env & 0xf0) | 3)
				end,
			},
			{
				label = has_random
						and "\|f\^:1c225d5d5d221c00\|h random"
						or "\|f\^:1c22414141221c00\|h random",
				fg = 30,
				action = function()
					local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
					sfx.set_node_param_flags(app.instrument, self.node_id, self.param, (flags & ~0x4) | 0x10)
				 end,
			},
			{
				divider = true,
			},
			{
				label = has_free_run
							and "\|f\^:7f415d5d5d417f00\|h free run"
							or "\|f\^:7f41414141417f00\|h free run",
				fg = 5,
				action = function()
					local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
					sfx.set_node_param_flags(app.instrument, self.node_id, self.param, flags ^^ 0x08)
				 end,
			},
		}
	}
end


return synth_menus
:: src/visual.lua
--[[pod_format="raw",created="2024-04-16 18:22:58",modified="2024-04-20 06:16:18",revision=851]]
local app = require "src/app"
local sfx = require "src/sfx"


local visual = {}


local overlay = nil


function visual.close()
	if overlay then
		overlay:detach()
		overlay = nil
	end
end


-- Wavetables ----------------------------------------------------------------


function visual.open_wavetable(node, show_wave0)
	if (overlay) visual.close()
	
	overlay = visual.attach_wavetable(app.gui, node, show_wave0, {
		x = (480 \ 2) - (200 \ 2), y = 10,
		width = 200, height = 90,
	})
end


function visual.attach_wavetable(parent, node, show_wave0, el)
	parent:attach(el)
	function el:draw()
		rectfill(0, 0, self.width - 1, self.height - 1, 59)
		local wt_addr, wt_width, wt_height = sfx.node_wavetable_info(app.instrument, node)
		local _, wave1, wave0, _ = sfx.node_param(app.instrument, node, 4)
		local _, phase, _, _ = sfx.node_param(app.instrument, node, 5)
		local wave = show_wave0 and wave0 or wave1
		local pos_addr = wt_addr + (wave * wt_height >> 8) * wt_width * 2
		local oy = self.height \ 2
		---[[
		local last_h = nil
		line()
		for i = 0, (self.width - 1) do
			local sample = i / self.width
			sample += (phase / 256.0) % 1.0
			sample = flr(0.5 + sample * wt_width)
			local val = peek2(pos_addr + sample * 2)
			local h = flr(0.5 + ((val * self.height) / 72000))
			if last_h then
				line(i, oy - last_h, i, oy - h, 19)
			end
 			pset(i, oy - h, 17)
 			last_h = h
		end
		--]]
		
		--[[
		local last_sample = 0
		for i = 0, (self.width - 1) do
			local sample = i / self.width
			sample += (phase / 256.0) % 1.0
			sample = flr(0.5 + sample * wt_width)
			local min_val = peek2(pos_addr + last_sample * 2)
			local max_val = min_val
			for s = last_sample, sample do
				min_val = min(min_val, peek2(pos_addr + s * 2))
				max_val = max(max_val, peek2(pos_addr + s * 2))
			end
			local min_h = flr(0.5 + ((min_val * self.height) / 72000))
			local max_h = flr(0.5 + ((max_val * self.height) / 72000))
			line(i, oy - min_h, i, oy - max_h, 17)
 			last_sample = sample
		end
		--]]

		-- Border
		clip()
		color(22)
		line()
		line(1, -1)
		line(self.width - 2, -1)
		line(self.width, 1)
		line(self.width, self.height - 2)
		line(self.width - 2, self.height)
		line(1, self.height)
		line(-1, self.height - 2)
		line(-1, 1)
		line(1, -1)
	end
	return el
end


-- Custom envelopes ----------------------------------------------------




function visual.open_custom_envelope(env_id)
	if (overlay) visual.close()
	
	local env_type = sfx.env_type(app.instrument, env_id)
	if (env_type != 2) return
	
	overlay = app.gui:attach {
		x = (480 \ 2) - (128 \ 2), y = 10,
		width = 128, height = 90,
		env_id = env_id,
	}
	
	function overlay:draw()
		visual.draw_custom_envelope(overlay)
		rect(0, 0, self.width - 1, self.height - 1, 22)
	end
end


function visual.draw_custom_envelope(self)
	local bar_width = self.width \ 16
	rectfill(1, 1, self.width - 2, self.height - 2, 59)
	local start = sfx.env_start(app.instrument, self.env_id)
	local loop0 = sfx.env_loop0(app.instrument, self.env_id)
	local loop1 = sfx.env_loop1(app.instrument, self.env_id)
	for i = 0, 15 do
		local val = sfx.env_param(app.instrument, self.env_id, i)
		local h = (val * (self.height - 2)) \ 255
		local col = (i % 2 == 0) and 29 or 18
		if loop0 <= i and i < loop1 then
			col = (i % 2 == 0) and 23 or 14
		end
		rectfill(
			1 + (bar_width * i), self.height - 1,
			bar_width + (bar_width * i), self.height - h - 1,
			col
		)
	end
	fillp(0b1111000011110000)
	poke(0x550b,0x3f)
	if start > 0 then
		local x = 1 + (bar_width * start)
		line(x, 1, x, self.height - 2, 28)
	end
	if loop0 > 0 then
		local x = 1 + (bar_width * loop0)
		line(x, 1, x, self.height - 2, 26)
	end
	if loop1 > 0 then
		local x = bar_width + (bar_width * (loop1 - 1))
		line(x, 1, x, self.height - 2, 10)
	end
	fillp()
	poke(0x550b,0x0)
	if self.selected then
		local val = sfx.env_param(app.instrument, self.env_id, self.selected)
		local str = tostr(val)
		print(str, self.width - 3 - (4 * #str), 3, 7)
	end
	rect(0, 0, self.width - 1, self.height - 1, 5)
end


return visual
:: src/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTA3IDA4OjE0OjAwIixtb2RpZmllZD0iMjAyNC0w
NC0yMSAxNjoxNToxMyIsc3RvcmVkPSIyMDI0LTA0LTA3IDA4OjE0OjAwIl1dbHo0AAQAAAADAAAA
MG5pbA==
:: vgfx/0.vgfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTE3IDA4OjQ4OjQ1Iixtb2RpZmllZD0iMjAyNC0w
NC0xNyAwODo0ODo0NSIscmV2aXNpb249MF1dbHo0AI4AAADRAAAAsHt7e2NvbF9hPTEsCADwK2I9
MTYsZmlsbD00MzY5MCxuYW1lPSIiLG91dGxpbmU9LTEscG9pbnRzPXt7NDAsLTQwfSx7LTEwLDEJ
APMOMCw0MH19LHNob3c9dHJ1ZSx0eXBlPSJlYXIifSxoABM4aAASMmcATzM3NzRnAAsVLWgAPzEz
LGYAClByIn19fQ==
:: vgfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTE3IDA4OjQ4OjQ1Iixtb2RpZmllZD0iMjAyNC0w
NC0yMSAxNjoxNToxMyJdXWx6NAAEAAAAAwAAADBuaWw=
:: drak.lua
--[[pod_format="raw",created="2024-04-07 07:42:45",modified="2024-04-19 11:56:33",revision=1102]]

-- A 'require' function similar to standard Lua.
-- Idea from elgopher on the BBS
function require(name)
	if (_modules == nil) _modules = {}

	local cached = _modules[name]
	if (cached) return cached

	local filename = fullpath(name .. '.lua')
	local src = fetch(filename) 

	if (type(src) != "string") panic("could not include " .. filename)

	-- https://www.lua.org/manual/5.4/manual.html#pdf-load
	-- chunk name (for error reporting)
	-- mode ("t" for text only -- no binary chunk loading)
	-- _ENV upvalue
	-- @ is a special character that tells debugger the string is a filename
	local func, err = load(src, "@" .. filename, "t", _ENV)
	if (not func) panic("Syntax error:", tostr(err))

	local module = func()
	_modules[name] = module

	return module
end


function panic(...)
	local args = { ... }
	foreach(
		args,
		function(str)
			send_message(3, { event = "report_error", content = str })
		end
	)
	stop()
end


-- Table utility functions --------------------------------------------------------


function table_deep_copy(t, already)
	if (not already) already = {}
	if type(t) == "table" then
		if already and already[t] then
			return already[t]
		end
		local new = {}
		already[t] = new
		for k, v in pairs(t) do
			new[k] = table_deep_copy(v, already)
		end
		return new
	else
		return t
	end
end


function tostrrec(t)
	if type(t) != "table" then
		return tostr(t)
	end
	
	local s = nil
	for k, v in pairs(t) do
		if not(s) then
			s = "{ "
		else
			s ..= ", "
		end
		s ..= tostr(k) .. " = " .. tostrrec(v)
	end
	s ..= " }"

	return s
end


-- Char utilities -----------------------------------------------------------------


function keyp_num()
	if (keyp("9")) return 9
	if (keyp("8")) return 8
	if (keyp("7")) return 7
	if (keyp("6")) return 6
	if (keyp("5")) return 5
	if (keyp("4")) return 4
	if (keyp("3")) return 3
	if (keyp("2")) return 2
	if (keyp("1")) return 1
	if (keyp("0")) return 0
	return nil
end


function keyp_hex()
	if (keyp("f")) return 0xf
	if (keyp("e")) return 0xe
	if (keyp("d")) return 0xd
	if (keyp("c")) return 0xc
	if (keyp("b")) return 0xb
	if (keyp("a")) return 0xa
	if (keyp("9")) return 0x9
	if (keyp("8")) return 0x8
	if (keyp("7")) return 0x7
	if (keyp("6")) return 0x6
	if (keyp("5")) return 0x5
	if (keyp("4")) return 0x4
	if (keyp("3")) return 0x3
	if (keyp("2")) return 0x2
	if (keyp("1")) return 0x1
	if (keyp("0")) return 0x0
	return nil
end

function is_num_char(c)
	if (not c) return
	return ("0" <= c) and (c <= "9")
end


function is_hexa_char(c)
	if (not c) return
	local is_num = ("0" <= c) and (c <= "9")
	local is_hex_alpha = ("a" <= c) and (c <= "f")
	return is_num or is_hex_alpha
end


function p8_centered_print(s, x, y, col)
	local count = #s
	print(s, x - ((count * 4) \ 2), y, col)
end



-- Drawing -------------------------------------------------------------------------


-- From Sophie on the discord
function get_drawspace()
    return {
        cam_x=peek4(0x5510),
        cam_y=peek4(0x5514),
        clip_l=peek2(0x5528),
        clip_t=peek2(0x552a),
        clip_r=peek2(0x552c),
        clip_b=peek2(0x552e),
    }
end


function set_drawspace(drawspace)
    poke4(0x5510,drawspace.cam_x)
    poke4(0x5514,drawspace.cam_y)
    poke2(0x5528,drawspace.clip_l)
    poke2(0x552a,drawspace.clip_t)
    poke2(0x552c,drawspace.clip_r)
    poke2(0x552e,drawspace.clip_b)
end

:: label.png
b64$iVBORw0KGgoAAAANSUhEUgAAAeAAAAEOCAIAAADe_FMwAAAtV0lEQVR4Ae2db2wcx5nmi7Md
I-60GBw8PCGxqbQcA_fEQYSxkUAKEZ1PWH_QLEaRBd5B5FHyCAEMcqlI4jB0dmWJVmLwMpRlCiQM
_EQrMikogi37zJhY52B4HU5k7iIKfHASB1hEiph8OIlCQugTgQQL3gFFv65Ud9dUT-_Zqu7nRaHx
TE11-Xn6rd-7tW3tzk2GQCAQCPPCSXm9n-3tQWO9_Nqds1zMvDih_UrvU4eQQwgEIqFoW7tzU-zt
ZVOMDGqCzl_7c1bzLY7XiAXga3fO6tMZjEYgvMFvEL8XolYMlsbrXyvN8fpYC7r_Dfcz8_JE71OH
_FOfh5xainB0LAh1mBiB1XD3TXAcgUCkQ2cuZl6cCIUtTSKHRY04OIjCUSIsnTUZLQNaOgZfVefM
SYRi99Tv5TLBGtRGIBApFKSm6wdnlILRMqBpAT67utT4-ps0tb3k5cfjz_SIrK5VCAQiRtLp30oT
Ni9tI0ZQyIAWSdTw8K1yh2oOxzH-SWiW-o3xA4DRCEQSdBOvlf4to2H6IGo4czpME9HEYRUC0PwM
kmX6p03zhCKXxQMr-m26vIPOCIR1EfbOBo2PEWuhoCQDOhSGkmYxry1e4FLNiYu-SXxpBCKHwQEy
8_IEhwO-NWpQSDcr0YumiSxxmM5_Qu3ZyzFFtK3duZnax0uTp02XhLD5kXSVQiAQuY0CLEAgEAgz
o_2Zz__BCwgEAmFgFGABAoFAANAIBAKBCBEOqWdP7FIPfebEHPxCIBCI1KLtmc-v0aEzGI1AIBBJ
xOy-f8BFz99slv5yfF9Y2-lY21s-gXEIBAKRNJ2Jy6JWAboJRo9eneLi_MP9XB9-uF-8i-rFv7wF
RKHpqag-Otr3dd5PWuyUxiAQiIQiCBF5oLMIOuopKF5e2-mY-krcULKVcDx6der4w-3iv17r_YZo
W9KOdVb3fUWcVlpCMojo7DVLGoNAIJKjM2cF0eP_ygP0jHmtb_7ljbT0lzQm6N2kw1H-vbbzsba3
fhJLVdQviSIoOSJ9q430iq-WXE6-EiAQiBQiCBfPntgVap77zvxP8ef_P7Wvz--6q6Pf3Hv89Vel
n76dPtt7-dV0AF1Q-x2dzrwehnql5282E2RFbor93ldoZCjUii-qcByBQKQZ91ceSHnF0W-uTQe_
XqbN-vsHEo6cuOg8enWKPyUc8-6wjE4tuDtkitcg0BmBSD84SX47-W8pM-r4669yRqcJH8KLFz5t
z3x_D2Ps2RO7xN61nY-50vmZE3NIHQQCkRyX10H5cD913l95gJM6zoU_RvDx118d-eZe8UmY5sNI
_74bkc6_UG4M6KAAoBEIBCJiaNKZMVbQJy-ojEAgENGDc7khnRljbc98fg-8QiAQCAOjAAsQCATC
0HA-jnK5DA0NDQ1tjl4HNByBhoaGNk0zuAANDQ1tpnaKxeLKygpjrPORh9h6fPZjkX1d--kvuSAf
oDOvz19-kDHG2AYhH2LQfe5H8BY6Xs2I2X3dXezC_Uy2k8NnfVtfdxdqNddrd27G2zTXjf1b66xb
ZzvZ3O54W53tRC5Bx64dYvY6sD_OtZ2PcdH21k_kvyyNrz-_BdI--fGvSaNWJ_e5qetuaOF5oaFD
aGJ2X3cXu3Ce2tqdm-QUhY3t5PDZhfqi1E4On_3r7kKt5rF256bYXhl7_pWxp7kQn1yQ9o6hpl6X
D3BdV-pSpVKpVCqpte9gajrr1tlONrdbany2Uqkk6aAxUquzncgl6Ng1I6UGtG_j26jQhgMaGUDk
EuksaV8QS0ICtHpdGiMBV3qK-b7N_5fOukGA1gGxNFIENHIJOnbtrKysMI1Y2-lY21s-kTrFniBt
Tvz0x78m-fXHvyD_VSwWyYc8a4qZFycYY71PHSKtDu_Yq_-ON3zr6rvzilQpHa4yxpZP10J9ZZ11
v3bnLPvpUz4rHryyfHYr18tnt5YOXvEOaDg5cgk6Rl0g5Qtlw5kbKr7__Beo4UYp6Nz71CGOZkkr
wjtm0_YtmzZvefjRHVxs2ryFOrnmP4MmXD5dC4vmoHWlPTDGfva3B-0X-ZjOilg_u1UxDLkEHbN2
XbdcLruu29fdxS6cz2Q7OXx2ob54cvgsNf6zr7uLn51HnvXanZvUXhl7_pWxp0XNf4pPr6CfvHnX
4p2SFj9TqVQqlUpe7f0pdkr96vPydetsJ5vbLbVSqSRpsYf611f0vF5nO5FL0LFrRirzgJYaBzQy
gMgVb-Ou5Uvt2L_1znl9AR2x1dlO5BJ07NpZWVlhH0fpcJV0pmL-c_r-i8Ui_ZBnHWOYvG6iuYZc
go5RM2J2X3dXSYiF_uJCfVHssTdODp89OXyWn4g33tPX3YVanZpeu3PTkP3U2c4kGr41dOyakZIA
zRntqy0FtLf1dXchA1LTBGh4Ag2tqRkpNaB9Y6G_yJtCGw5oZEBqmgMaPkBD62tGSg1oc2ibBKCR
DSnotTs34QM0dCi9DuhyuSwBeqG_yJu9XNYENLIhHb125yZ8gIYOpRkpCdBZCgWgkQGpaQI0PIGG
1tSMVD4BjQxITXNAwwdoaH3trKyssNxHsVgkH6DT1NdPHo-3U7rHRnXWPfGt7njXPfHSJZ11r41e
j3fdTcdd5FKGtUNK_vCvXX6Tiyf2dIHO0NE1YyyovyXfNG-rQtuoC0HZ88SeLhHNxGvQGbo5LXp_
9d15389ROlwtHa6qtTTY26-Yg7Tu0PPTvPlqaZi0Co1sYl3GWPvRUvvREhfiU_wn7X1R7EeOZVg7
QbVdIrIIa__YJ-Z0BWnDAY0MaJW_9sH7Dz_6QwLu8ukaBy7XYr-32-FOCdBh1x0-UuGQ5WL8SEXs
lzqjVHpx3fajpVunln3nuXVqmeAramkM6JwT7fjS2YvX1y6-6aWt2BOkrQhkQzr62gfvi7ZffXe_
7a2fBH0UTl5fNEtjpDkbfu6r787PvDjBtSZ-fYOTPdS6bO4-EqMJtSKFg7QY4rvIq2zrAilvHrx2
_c3XLr9pKXNBZ9P0w4-u2LR5C2_8h4Q3lk-X1GimYVIPn19cS73u_JGKyFkdFtOLItlDrXvr1DLH
K-0M0uJPRSdyLKu6IPVSPLGni7eschkZ0EIdROfS4SpnbulwlfTy6Rr-6R3s7WxuXUKwL6x1CB5q
3fajpfajJS9ndYK-ixzOiW4rl8tcdT7y0D-982ImKfz3_5-z7f-t0o-rP-8lsqGF_hdHBuP91uXn
z_ise2jv38W77sSr-1tn3avf-kW86z78wvr9RS5lUhdI5TmQDa3VMQbWhc6SZq7ruq5bLpf7urtK
QizUF3kTOy2Nk8NnfVtfdxc-OzcBOgW9UF_ED-AWWlMzUhKgCdOSyBigkQHpa84R_AA6QzfUTrFY
XFlZYX7x2uU3ST_xp0sx4Ik9XUHad2Zzgs4u_gCdqN7ft__H5y9ofqDD3x4Q3z39wqThGdWq2N_3
DzmWPc2I2X3dXSVPLNQXJWFjnBw_69v6urtQqw3XC-VFXw1-oPOg1wFdLpclQC-UF3mzl8uagEY2
GK4X6ougM3Q_NSMlATpLoQA0MsAKDTpD51MzUvkENDIAGhraWO2srKyw3EexWCQfoNPU1-Y_F__n
3PTqd_EtdGZ0gZSU6K9dfpOeoDN0chrfFBo6ULuuWy6XXdft6_4qCbFQX6SnKGyMk8NnfVtfdxc-
Ow-o9PXad3609p0f0Zfyaj5A6heb1ANvobOkGSkvoHlTgE8cE6QNBzQyoLXaF7L0M6hf0QlvobOk
GSkJ0IRgSdgYDQGNbGiVJsiKnA0LaPF1eAudJb0O6HK5rAa01aEGNLKhhVoNYk1Ai3-BW_gsaUbK
F9DZCAWgkQGt1V7y0leTtALQ4hh4C50lzUjlE9DIgNZqL3AjNngLnSVdWFlZYbmPYrFIPkCnr2MM
_AmdJc2I2X3dXSUhFuqLvImdlsbJ4bO_ra_7C7UaGhraWM1IeQGt_JkZQCMDoKGhjdWMlBfQvCnA
J44J0oYDGhkADQ1trGakJEATgiVhYzQENLIBGrpp-crY07yRFvt93xXH85-eeaT5g9b1nVPaA__3
0dt1QJfLZQnQC-VF3uzlsiagcdOgoaNogqzi6R3vfZdIrR4Tal2J7NaRmpGSAJ2lUAAatwsaOqJ_
Zexp3oiAXh1ESfFdX1I3nEe9rji5jd4yUvkENG4XNHRETShUPL3jve_KFFaMCbWuRGcv5Q3XjFSe
AY2bBg3dtCYUcs2bpKV3xTEN3w2ax-su9evswQq9DuhyuSwBeqG_mBNA46ZBQ0ObqRkpNaCt5rUC
0MgAaGhoYzUj5QU0bwrwiWOCtOGARgZAQ0MbqxkpL6DpKQoboyGgkQ3Q0NAG6nVAl8tlL6B5s5fL
moBGNkBDQ5upGSkJ0FkKBaCRAdDQETW7cD5Kk_Zkc7ujNGlvr4w9HaW13ltS_QQ0bhc0dEQdEdDS
nNEBLe4tIqBb7y2pPAMaNw0aumntZS6-d2otAZrm9MUu3WVJe5u0N0ItveWrpWESoFvpLSkJ0Av1
Rd4yD2jcNGjoKNpLZ_kp9nubNGcQoH1h7W3S3kTy0tMrpH9FQLfYW1ISoAnTksgYoHG7oKEjajWg
12EaDGhpziBAE5G5UAOa5hQBLfJXE9Ct95aUGtC_sVBf5E2hDQc0bhc0dEStAHRQj9ikOYMALWkF
oMW9SUSWuOwLaBHTrfeWlBrQ5tA2CUDjpkFDN629gCYWi9r7UwQ0zRkR0NLefAFNZFD0i4Bupbek
1IC2OtSAxk2Dho6iJeCGbdKcvtjVb9LeCLXNtdZ7S8oX0NkIBaBxu6ChI_qIgJbmjAXQNGdEQLfe
W1L5BDRuFzQ0tLGakcozoJEN0NDQBup1QJfLZQnQC-VF3jIPaGQDNDS0mdphjBWLxZWVFcY_y-46
ntjT9drlN7l_7fKbT_zpkgZkID4_OzQ0dJP62t7notzBh9_piXNe-eaWKLNtmp7-q72NXo_0txfK
rfXWEXulIDpzWCsGiCiXtOGAxu2Cho6ok7iDUSLpvaWpC4qTiHgVYS0O4E2hrQjcNGjopjXdo-Zz
g7x5te8YNVXbJy7xJv7kgp5iv3pvjLH2o6X2oyUuxKfYT9oQPji_J-FC2SLags7Q0OlrHrcOnCHR
fm6QfooDvP3eedYHH_omCpOWIH7rULcI6KC9tR8t3Tq17EuAW6eWCcqiNsHbQpA7T_zp4i2rXMaN
goaOl86MsfZzgxHvoMRf31eC_tXEbz9aIviKFA7SJnjrBNWunARuFzR0XHRmjN06cCaWO7g_26Fu
31duHepWMNp3b7dOLYv8vXVqOUgbxYdCnulsTp2EhrZX_96p9nOD9OSCtD5V2ycucRBzIvtCuX3i
ksjxoL21Hy21Hy1J-DWfD22u63L1xfs-_0--vEh7eu3ym1w8safLdv7_-f7nfPt-u-Tj_s9-iZsG
DR1FX9vrf780Y9Or3xXnvFbZEWm26fm-2tvo9UizHXdb620hqHZJaCZeZyxwu6Cho_sY72Ds99pu
PpTLZdd1Xdft6_4qCbFQX_RN7JRCHBOkTYiTw2d9W193Fz_767rkAzQ0NLQhmpGSAE0IloSN0RDQ
yAZoaGgD9Tqgy_WyGtBWhxrQyAZoaGgzNSPlC_hshALQyABoaGhjNSOVT0AjA6ChoY3VjFSeAY1s
gIaGNlCvA7pcLkuAXqgvLtQXRU0-MwZoZAM0NLSZmpGSAM25LArpZzYAjQyAhoY2VjNSfd1dOWzI
AGhoaGM1gwvQ0NDQZup1QMMRaGhoaNM0gwvQ0NDQZmoGF6ChoaHN1G2u6zLGGGPFYnFlZQUaOgP6
-PUHeU8Oo8-9CDmQGb0OaOrd88WqFVl4_Vc18SSMsWsfvJ-D27hp8xbJh_snj_fQB-fYqETnzrlP
5dCH_q6-cEYjH6R7YRHZRFK3ua5rHZ29J7n67nwOs5AYTT784shgbn1wj41ycf76g-mkMzGaAxr5
QPfi0c8ctItsxOSCVGcofjCzmzfS0l-SmKB3kw7f-c_8ODHz4gQX4pML0kFjpGHe8Q11_uHrQ_lw
tXR4vegGad-BxsZXLr7hq0Uf5HMdvMKbpIPGWBFfeWnNV8eeD4anhE4_eH0QCUZPBdlSJp64Z4eU
N7OHe9_gJbmmp__YoHfpDNKA5Ojc_9Qh3-G9Tx3i-5LwHeOdRxzPnwRicRI_zBw6L5_u8QvGtdjv
nYQGmxz-_t92f_XiG-QM8GGDfLSzW9XT8gEWAfpfv9X2lZfW6JlQPvB-7c8HGaa_8BH7RdAR9xTb
oJGxEE9kckF9Et-3pdqiubCE9YSoRGwlUOoQUxwjad-XRXZL44NqQ8p09kbpcNV8-oa6k-o_iOT1
hXXp4BWL6CwxWnHDI_aDFQnTRD4EhUg2HY6pX4xIPL7-guIkvpMO974hLdzwSNKEmnvl04pPRZ0R
_3ufOkSUFLUixDEN35UoLGmdehBvBPkgxvLp2vLpWgbozBjjt-ErF_UsUtxGXyh7x_gMM8iHl9Y4
oxU3PGI_WJEzDfNB4YOCbGHD93Vf4jUkm8jkgmadoYl4rWh4kqCF9S0Qz6Z4y7v-mRcniKFchzKa
XpHmoac0bRNLJBG_37F0uMrvWOlwlfTy6Rr-6R1MT8NvI2PM907q30ZvlA5eKR28YhedGWNBjI4l
HwxPBs18kHwY7n2DQ4x0Q7JpEs8Xempq_04r7rnNdV3qffQzB21JUMbY5V-V6CTXPnjfop3HG5s2
byEfrp88nlsf3GOj3Ifz1x-snPtUbn2o7-rLt8v-F-lA_cAY2-NF0yuNRDZickFRbw0PG-cMH_BD
CgEfMpAPfP_OeJLHq1_2qc70rbtfLBbrH-4Ot7FYLC7c90Bufdgv3MaF4nCO0fR95IOYD8Vi0Tay
fcLkQjbqTI5vI3yQfYAJyAerfRD3XCBlY2YjC_EDfIAPGfNBZLKTjTqTdLzz5Lj_4NGL3R39Z0LN
Pzte0xnWM1T1vmWsD03YoumDsfnQxKeP3QfxhufkXoTKB_kSxWJ4cnxzslFndMZPT45VBkb4k-9k
jIk9hgdPrHOVGf7zwHRvz1B1dryWNx_ka0ZXK2wOZ9UH8YYjH3x9kLwSkS2emltBbvjqROnMGCtY
SueGdVInKRt_b-py91ceMOfIB6Z7W_WDabfRuzdNKoX1wXAq_fqAfFD48OPa-_FNPXNlYIQMEZ1J
NFvEPTuKOpNVOuvE7HitZ6gqVtp0GH3jytzGrbtM9iGdiObDBnO2hHyw2gexYkk6ucOKTHYankSq
SEHfRnNY591-EH-WV_9terYm3Ne3lWehmIu-nf433WW2b27626SThVF8SCdM86G5LbXEB-GGIx8i
rktE5poYLfYnFHz-hUTrrTeGn-2j2OKqM-peB9VDKUd5-jVD5_TjXGWmVT4YEuJ_SIfN4VA_mBm_
Pog3HPkQ5MPj1S-z5luu6NStygRispMmnRM9Sah6KBVGK046O17rGaoemO71zcv8_BDEo1BUyoMP
yIcgH3qGqg2t8NVSMUuBaY66zmSJzlFi_8tD_oPrq4HpYsJtTM2H1Gzx_LChVT6kcEbci4g_mPCB
1CEy2Un5i9qYhfABPtgV8EGRD9OTYwbutjIw4rt-x97MFusMbiN8AJW8Nxz54OvDf-8vL3BxYLrX
hK3_543-Iai6OJbSuWGdjDd6hqr6g5emBjv6z4Saf3a8Bh-i8iGFrEM_ZN6HI-N3Pb-jz6rjzN-u
2HFP0kxzFHUmY3SenhzjojIw4tWVgRErjkxXQsxd_PDXPmyAD8iHiFVKTWfGWEJ0ZoyJTC6kWW9b
SGdKuyBNqen95AZmoajhQzo_mEwlSSMfojPtyPxd6gFL87dT4FvBUjpLdUbzFTHb1DeQf_b0c-HG
lTn4ENEH-dD3obkttcQH8YYjH9Q_dLfv48371-M7-qyev2PHPUnTmTFWsJTO3pPoRGVgpDIwQlox
cna8Rs80Y_PWXfAhog-6g-V9iLIl5IMtPohxZP4u9YCl_dspMK2gU2eyQeewkX4WhtqSqOFDCj4Y
GMiH5Hx4fsef1QM6dtyT0HFEJjv2ZnbYPVcGRiTtfdp1J_EDfPDFJXyIzrQj83epGb00fzs5RtP_
HUvpLNWZllyDoKivhhsPH_L1oVVYNMQH8YYjH5r2QU1nxlgKdGaMOZbSOa46mZmAD6lRCfmQPR-O
VWa4ODDdy8WR_bvUjF6av50Qo8U9FyLWGWQhfIAP8CF7PqjpzBhLiM6MMZHJjr1fNM099wxV9Qcv
TQ129J8JNf-seA0_WOTDO0_Oj17sDnu6dHwQbzjyoenXj8zfpWb00vzt5BhN_3fsrbdinQkaMz05
xkVlYGR6ckx88k5pjPmnpitBuQsf9KmUBx-EG458UPugCDWdGWMp0JkxVrCUzpp1kueWb4ZROnLt
HUOf3MAs9G4PPujcxqZ94KuYZgXyIaIPijgyf5d6wNL87RSYVohYZ0yms35QRrb8Qt64MgcfDPRh
drzWM1SdHa8hH3KSD8-v_LN6QMeOexI6rMjkQrxf1EY6M8YqAyPeC0nPNGPj1l3wwUAfOJ3TB1MT
Pog3HPnQ9IpH5u9SD1iav50C3xxL6SzVGc1sm54c8-2L90vpmH4WNgyREbQ9_NAclUL50CowNeGD
eMORD-o_8Ohu38fF8zsuqEd27LgnaTozxhxL6axfJ8X0Is2F_LQlgq4HfNC8jcgH_KATR_bven7H
nxUDluZvJ8Rocc9Oc3XGFjon-fl9o74abjx8iNuHDUkvtP3lofRPh3xI0wc1nRljCdGZMSYy2Un5
i9qYhfABPtgV8CF6PhyZv_vQeycZYx217-gOWJq-nRyjaf8FezNbrDO4jfABVPLecORD0z5wOisi
BTozxhxL6RxXndSMnqGq-uClqcGO-jOh5p8dr2XPh-1-aic9erFbxxNNH6RtiG_lQyXkQ_Z9mNh2
TM3opfnbCTFa3LMTsc4YTufpyTEuKgMjXl0ZGKExXJsfdCUkKuXHB_7AucoMY_zAdC-v4W587MMG
5APuRcQqRXRe2jbARcd7k_KAhOjMGBOZXEiz3qZMZ0o7UdNP39T0-eQGZqGoDfHhe7s707SCoxn5
4KvhQ3SmTWw7ph6wNH87Bb4VLKWzVGcUw6Ynxyj5vNmm-uTp5_KNK3P2_vC93Z1iu7-yALU0fVBH
5vNBvOG4Fw19CIpD752UiVz9H7zxnx077kmazowxx1I6e08SFJWBEcpFysiGMTte6xmqzo7XUj7O
xq277PXhH9_oiz-3-6n9kx-bN6fmg3oA8gE_6MTEtmNeRv8Vr_dvJ8Rocc_FiHXGcDozxqYnx0Qt
-vQdI_aiaecVtyRqE3yQ6Jx0nKvM0BP5YGA_2OJDUKjpzBhLiM6MMZHJTvSTmEznysCIQotPW8J7
PfLmw_x4rWeoemC6V-IE_eC94bgXTU84se1YEKOXtg38-xVZ9fi7r7-Ne8RsjJdvTlx0XpoaFH-W
VxP-JGKdack1CIr6arjxWfUhOU_ao1JO8kG84bgXTfsQROdPojbKNiX47fj_nVjozBgbfvaP4s-H
q-emloVp3kxjAz6kRiXkQx58mNh2rAGjq8fZ628nvWcnYp1BFsIH83zYAB_QDxF9aEBnxlhtlG1a
l93t_7i4dOtC9G2LTHbs-aLIwvR9eOfJcf3Boxe7O-rPhJp-drxmhQ_dd-8h7NFS80G84UblQxOp
0sJ8mNh2rAGjq8fZ628nfa8de0kn1pk8AzrIh_nJscrACD15p6TtPXXPUFW6w-ms1l4fxBuOfGia
Dw3ozBirjbJNct_5ygwXB6Z7o9OZMVawlM5x1cnMhNoHfvfoBnqv4vTkmNhsuY2Szlu1VvuAfIjC
h4ltxxqMqB5X-Nndvo_3iHfZaVhnlqYGxZ-11TQc11wUdI7Lh8rACN1D6breuDK3ceuulE-U3KIf
_7DBnC211AfkQ-M_HHrvZIMRtVG2KZHDikx2Gp6kvnqvzqSPV78c4zCdRUHnhj7QHdO-k9JtZIyl
fxubWzTpfLDFB-GGIx_aXnFi27EGjK4eZ6_-3XCec5UZLt5_a33wpVsX9PdfsJd0Yp3JM6Cb8CHo
onpvo5kxO17z6hxWa18fxBuOfGiaDw3ozBirjTa323OVGd50qotjKZ3jqpOZCa8P0u2in7bcOv07
2RyVssdo5EOMfJjYdqwBo6vH2etvJ32XnYh1BnTOlQ-bXx7SH1xfDbw2CfuwIemF6qv3pny0DORD
_qkSxYcGdGaM1UbZpkRcFZlcsJd0oDN8gA-qG458aPr1iW3HGoyoHk9h-22u69JJfnj_gu-Q6ckx
LioDI4oZ_TD1GP2RDRfd37ePTnL6hcncJiJ8kHw4f-3Btfo-5NaHts7v97kfIR_C7gWBxagQKbe-
bx8x2dGsM5WBEZ2D8WENyasDcc1FI9bJzEQ6PvQMVfUHL00NdvSfCTX-7Hgtug8puG2ID9I2xLeQ
D0E_aMLHkLvskFJndrxlh8-W0KmGKAedFT7QJ6OqSU8xU_lbSP2GB6HBj0ob8uADd2Bp2wD-2fHe
ZM9QlbuBfGgJH0KVK0XtEZlc0DxJjB_pMjCiOZuYJaBzEz4E_Uz9-IrST-1PY8htFHULffje7s4W
utHx3mTQDUc_qF_cnhzjhOFCRze9yXOVGd5C3WsnXtLpHIBKdMS1xDqTZ0ArfBA-h1rzz8HvpzTJ
jStzG7fuSvlQTSyqyOEUfEiI0To_LG0b8DIa_dCQD9LpKgMj5IPUL41RmKOOA9O9moAmJjs6dOb7
aLgbze2GGtZwcIzVxerw9UGRf9I9VHya9G9jlEV9b2MKPvzjG-Wgv3q3b07Uh473Jr2MRj7o8MH3
1BJ8g0Acls7N7dlpWGesoxLorB9ignp-Ghuz47WeoSppjw8bUvZBQWfkgwH54B_KahSkJa8SckZk
smMv6UBntQ-eJAt6qhPR2DuZcx84lTrem2SM8Sd5gnzQ4YOi-Ih-eXXT-pyrzIS9122u69JJfnj_
gkWfZH-fPjrJ6Rcmcwto_CD5cP76g2v1f8itD22d3_9zP0I_pH8veoaqUSqKuHNistOwzhgetu8f
PsTuA0xAPrTEBwVzm95zgVSxWKSaY0t5pJNYtHP4kIIPbZ3fz6cP-ODIB3vvxf6_fSKTHYnZ_-v2
ify2SNM3sHT-8CEu3ed_dP76g7lldJ-7EVu3BPlg372g77je77puuVx2Pw5oaGhoaEM0gwvQ0NDQ
ZmoGF6ChoaHN1G2u6zLGisXiysoKY2zPF6vMhrj8qxrtmceJb3VbsfN448RLlyQfro1ez6EPm467
sg97n8ujD69_V-IhtyH5YBHZxP23ue4nmW3LGbwnObT373KbiCdeukQ_XP32L3Lrw6bj7ic_bLcp
k2NntC_h8kzqRz9z0C6y0bcrBH3FH8zsFjVv4k-veG9n_nWSMTb0-DRvvloaJs1GI037ZlM-_42v
VvjAGGs-Wmo-WuJCfIr9pL0vevtbHl_99A1frfCh-dwgb17tO0Z618w7-NVf-8hXq-Mhn3SWfGiO
bGnCTdyzQ6pYLCreGe59g7Y73PuGd7u_nVIPTZKc_zzGj1Q4ZLkYP1IR_6VOK6L-a-9p6me-oacm
nW_dWvad7dapZYKvqKUxBvrwL93-66uXvkFPzXy4deAMifZzg-RTHODbb2z8yxf_61d--SN6gs6h
_BCWbF6UJUo2kckFzZM0V0DEfadGZ8ZYFP5yspvMaH0f2o_WCL4ihYN00LtmMjqED_cGm16u-dxg
lNdTYDTo3DSdNckWRO2EyCbuvxC2zjTH6CZe56aIT0Wdkf4aP1LR4ax3zPiRStNkTzo4nad_9htN
H26dWr51aln8GaTFn4pOQ4LT_auXvqGfD7cOnGl6uSjvJuvDr3-EGa3vQ65C0wcdNPmOSY5sIpML
Cjr-YGa37-s-mNnt3ZZivebgLp5fMYO6unAE_8Jah_Cm0Zkx5stoXx-aj5baj5aa4yx-11g6M8Z8
Gd0wH9rPDdKTC9LqV8ykM2PMl9ENfchP_PoQlmxBGE2IbOKe21zXpd5HP3PQIusv-6pGJznxre7c
puCJly6RD9dGr_fWh03H3U982Ptcfn149bugs0S6PV_s2kU22n-B3nqLLIQP8AE_ZNUHvv8213Xp
JD88f8GiA_zv20cnOf3CZG4TET7AhyAfQGob82F-3z76doVs1BlkIXyAD-AhGz6Iey6QKhaLcB9Z
CB-gA3xobYhMdrJRZ5KOd54c1x88erG7o-9MqPlnx2vZ86EJWzLgQxNf314fwIek91-IRp3RGT89
OUZPLqQeK6JnqMpbWB-E8yp05n2Q8sHXH4uyIroPWQ2rfSAmF7JRZ8K_NT05VhkYse6w4j0UdUMf
_HnpyJIQf1oBpqZ9QD7oX6uWhCF8MIdphWzUmSTixpW59E-U3KJhfTCfwun4YH7Ah7zRmTEmMtkJ
exKpUM_O16JsJcpsTbgfCkwbt_5K-9s0sai_D9OTY5WBEcZYZWDEcEYn6oNFBay1PuSKzuaQTdx-
IRt1Rmc8sUmiFdeGA8v7mUlr_uB7QN5pxdnj8kE6Pp1dzIe8_ZDJsNoHYrJje70NtX_6geJVtOta
BpVitQ-e80rlyrcnez6oPclPPuQnbPRB3LOTjTqTdGx-eUh-cH018Nrkyof0bTHBh-S-PuicMR9E
JheyUWeQhfABPmTAh6Jf5DMf_P4L2agzeb6Q8AE_wIeM_UBMdrJRZ5JepWeoqj94aWqwo-9MqPln
x2tW_PDOk_PxTjh6sVv0yhYfOu-_Q9hPnMl8AB_S3rOTjTqjE9OTY1xUBka8ujIwYsWRqVSId9jX
B_mMdECxn37SGHFkNnyQPBFPmlsfQGeTQ2RyIRt1RjPEKydpuq5W3EZRK3yoDIz4UkaEtS2VKYoP
imQgOgd5lXkfQGeT91-IRp3RfEWkcEMi37gyl-6hmlhU4UPQGc3ncrw_6HgSdoztPmQ_rPaBmOxk
o85oDhapVBkYUd-DjVt3pX_cphf19SGIwvzs3n-NAVO8PnjPrq5bDXMjAz5o0i3Ge6qzSuwwtZFv
4p4L2agzOYnZ8ZqvDvJhenKMQCNpL5Uy7EMQjkUrzClOKfuQ4bDUB5HJTjbqjE6IGOLa_7TrTqp9
8J5XX2fJB68n3i8elBtZ9QF0tmX-TjbqTPrXQBH11XDjLfJh_8tD8U4Yo1dp_lBfvTfNT9y0D3km
dZr5kFx1KWSjzuQ2C_EDfIAPGfNB3HMhG3UGWQgf4AN8yIYPIpOdbNSZpKNnqKo-eGlqsKP-TKj5
Z8drVvjwzpPjocaPXuwOZYW9PoQ9qeE_FIvF6HxJdJXMVym_fycbdSZozPTkGBeVgZHpyTHxyTul
MeafmkoF3WEdH3xt8fUkPz5IuSGeXUwPq32wmlAp8MFwOjPGCtmoM0H-8jvme9Oka_kdQ6lv4G30
bk--O3Ice8_r8CqTPkiHJU_C-MmwDxkOG30Q91zIRp2JGERqKd3TZ-SNK3M5yUITfOAs9ubA9OSY
NyUy7APobFSITC5ko85EDLqlFLPjNXqmGRu37sJtTM2HysAIgZhyoDIw4s2HbPsAOhu7-0I26kzY
2yjF9OSY96-06dwwxC2Rbs4Hfl6FJyZHLD4E5QAX5jA6ZR8yE1b7QEx2slFn1Dzyai7Ep41sCuVD
Q0-ssiK6D0E5kMN8CIs8cZWm3zWED4YzzclGnWnVNfCN_mq48Rb5sP3loVDjU7aihT6k-9EtpdJf
7t78qdUP4INOMSsWi0426kyeAz7AB4vo-Pv3p_7b0p8Co23PB77-QjbqTJ4vJHyAD3b58Pv3p-5y
92b4oFNdnGzUmaRX6Rmq6g9emhrs6D8Tav7Z8ZoVPrzz5LjOsNGL3WEdsMsH3IvojL5vS-_nVj-I
uQ8N9_xko84ExfTkGBeVgRGvrgyM0BiuzQ8qFSLLQmWhwhN65sEH0DnzjLY0H0QmF7JRZxQh4qYy
MEI-fZHtiwADqSTqKN_Ou2FLcUrOB9BZc2YpNId5x9_3pf__Lf2lT99QDFavklU6S-svZKPOKIZN
T44RgLwUViMgfUbfuDKXkA9BRUvsFL1qbaTjQybDZB9Kn77B0fz796fy7IN_dSlko86oYURc1qfP
7HiNnmnGxq27EvKhYXA669ewrPqQjTDWh9Knb5Q_fePhR3eUPn0jzz5o7rmQjTqj5o6ofQHk25k_
nTXLhlc3nYX84IZAuYU_gM7wwZwQmeyEPcnS1KD4s75qtPuVgRGFFp82sqm5LAw6u11uRPcBVIIP
5u-fCXuS4Wf-KP58vHqvCXUmfRwoor4abrxFPmx-echAB9L3weQQfcgzqa3OB-p2TjbqTJ4vJHyA
D7H74Puu1aSzdM9ONuoMbiN8gA-wIYoPS1OD4s-6asu2LTLZyUadSTo67-5DR-_Z5OafHa-hNoJK
8KGFPgw-_0fx5_PVe03Yf8HeLyrWmfykXc9Qlbec_4B8gA8Z9oGYXLC93tq_-7B09tV58wH5AB8y
7IO4Z6e1dWZpalD8WV81yP0bV_Y2bt2VsiHNLYrbCB-gg1E_RCGbyGQn7Eker345xmPUV_811v30
6dzcoriN8CEdH_yyN6wP5pBN3H-B3swW60xO7t7seM2rc_gD8gE_ZNsHYrJjKZ2brpNZYnSefUA_
wIes_iDu2clGnUk66qv3BpERWQgf4AN8iDFEJheyUWeQhfABPsCHLPnA9_80PMn05BgXlYGRIM2H
caE5j-iU5vGdX11n8pyI8AE_BPmQZ1I3zAdjySZ_O0fnK4oT_S4gbks9D73r2y-NoJ4tzSzsGarq
D16aGuzoPxNq-tnxWiz1Ns9ggg-wIawPZpJN3HOhYZ0RS4S0ku_edEqNWtPPhvP7us9nIF-EpzS5
b7-h0TNU5Q23EVSy2ofORx7izaulJ40Xn-SXOCasD2aSTWRyIZY64y0RQfPQGN96Ig4IVWcUG-bt
57sNWtdkOns1qAQfLPWh-vNfilr8qf9iFB-MJJu4-0KUL0o1ga8XtuwETShiVDGnWGeSKGg3rsyl
n7JNLKrwIVcBH6zzofORh7y6-vNfdj7yECG485GH6C9xvDSP968oPrSWbCKTnYZ09oJffOrXBPU8
3jl1ikxQdVEURl-ffdfauHVX_inb9KJNV9mMBXywyAeisKg5nYnRXNMAX0bTmFA_GEs2cc8Fi_pt
jFkYtqAZErPjNV8NKsGHrPrgS17eSX81QWeTQ2Rym_u6dJIfnr9g0TEOf3uATpL0znuGqvqDl6YG
O-rPNE1ek31APtjlA6qUyfnQ_aXPcVH-8HeS3rR5y7UP3t_0eUub67p0ErvSen-fPvoSp1_YzG0i
wgf4EOQDSG1yPnR_6XP1D3-n7dnft69YLF59d37T5i0F278ishA_wAf4YKkPnV-6XOeXPufdM6cz
Y6xAuy8Wi1R7zQ__VXLfop3DB-iQmg_gs8n5UP-wd-UPf_f9gkTnYrHIXNd1XbdcLnMBDQ0NDZ2C
Xrtzkzfq51p8MjgFDQ0Nbab_f9FYN1d06tYoAAAAEHRFWHRMb2RlUE5HADIwMTEwMjIx41m2wQAA
AABJRU5ErkJggg==
:: main.lua
--[[pod_format="raw",created="2024-03-24 00:48:06",modified="2024-04-21 16:15:13",revision=8769]]
include "drak.lua"
local app = require "src/app"
local settings = require "src/settings"
local sfx = require "src/sfx"
local file = require "src/file"
local detail = require "src/detail"
local ed_inst = require "src/ed_inst"
local ed_trak = require "src/ed_trak"
local ed_patt = require "src/ed_patt"
local ed_song = require "src/ed_song"
local note_grid = require "src/note_grid"
local synth = require "src/synth" -- TODO: temporary, remove


function _init()
	window {
		tabbed = true,
		icon = --[[pod_type="gfx"]]unpod("b64:bHo0AB4AAAAcAAAA8A1weHUAQyAICAQwB2AXUAcAB0AHAAcgJzA3QBew")
	}

	wrangle_working_file(
		file.save,
		file.load,
		file.default_filename
	)
		
	on_event("drop_items", file.handle_drop_items)
	
	menuitem { divider = true, id = "keys_divider", label = "" }
	menuitem {
		id = "piano_keys",
		label = "\^:0000000000000000 Piano keys",
		action = function() settings.change_keys(settings.piano_keys) end,
	}
	menuitem {
		id = "isomorphic_keys",
		label = "\^:0000000000000000 Isomorphic keys",
		action = function() settings.change_keys(settings.isomorphic_keys) end,
	}
		
	settings.load()
	
	poke(0x4000, get(fetch("/system/fonts/p8.font")))
	
	poke4(0x5000, get(fetch("pal/0.pal")))
end


function _update()
	if keyp(settings.keys.play) then
		sfx.play_or_pause()
	end
	if app.refresh_gui then
		generate_gui()
		app.refresh_gui = false
	end
	app.gui:update_all()
end


function _draw()
	cls()
	app.gui:draw_all()
	print(string.format("\014% 3.0f", (stat(1) * 100.0)) .. "%", 464, 253, 7)
end


function generate_gui()
	local cell_width = 14
	local cell_height = 29
	app.gui = create_gui()
	local top_panel = attach_top_panel(app.gui, { x = 0, y = 0 })
	if app.view == "patt" then
		ed_patt.attach_pattern_selector(top_panel, { x = 118, y = 0})
		detail.attach_pattern_flow_toggles(top_panel, { x = 322, y = 3 })
		ed_patt.attach_channel_panel(app.gui, { x = 0, y = 16})
		note_grid.attach(app.gui, { x = app.channels_width, y = 16 })
	elseif app.view == "trak" then
		ed_trak.attach(app.gui, { x = 0, y = 16 })
	elseif app.view == "inst" then
		ed_inst.attach(app.gui, { x = 0, y = 16 })
	elseif app.view == "song" then
		ed_song.attach(app.gui, { x = 0, y = 16 })
	end
	if app.detail then
		detail.attach_panel(app.gui, { x = 480 - app.detail_width, y = 16})
	end
end


function attach_top_panel(parent, el)
	el.width = 480
	el.height = 16
	parent:attach(el)

	attach_view_selector(el, { x = 22, y = 0 })
	attach_play_button(el, { x = 1, y = 0 })
	attach_detail_button(el, { x = 480 - 16, y = 0})
	attach_note_attributes(el, { x = 380, y = 0})
		
	function el:draw()
		rectfill(0, 0, el.width, el.height, 2)
	end	

	return el
end


function attach_play_button(parent, el)
	el.width = 16
	el.height = 16
	el.cursor = "pointer"
	parent:attach(el)

	function el:draw()
		spr(stat(464) == 0 and 4 or 5, 0, 0)
	end
	
	function el:click()
		sfx.play_or_pause()
	end
	
	return el
end


function attach_view_selector(parent, el)
	el.width = 4 * 20
	el.height = 16
	el.cursor = "pointer"
	parent:attach(el)
	
	function el:draw()
		print("inst", 2, 6, app.view == "inst" and 7 or 62)
		print("trak", 2 + 20, 6, app.view == "trak" and 7 or 62)
		print("patt", 2 + 40 + 1, 6, app.view == "patt" and 7 or 62)
		print("song", 2 + 60 + 1, 6, app.view == "song" and 7 or 62)
	end
	
	function el:click(msg)
		if msg.mx < 20 then
			app.view = "inst"
		elseif msg.mx < 2 * 20 then
			app.view = "trak"
		elseif msg.mx < 3 * 20 then
			app.view = "patt"
		else
			app.view = "song"
		end
		app.refresh_gui = true
	end
	
	return el
end

-- Default note attributes -------------------------------------------------------


function attach_note_attributes(parent, el)
	el.width = 78
	el.height = 16
	--- el.cursor = "pointer"
	el.cursor = get_spr(50)
	parent:attach(el)
	
	el.drag_start = nil

	function el:draw()
		---rectfill(0, 0, self.width, self.height, 0)
		local note = app.base_note % 12
		local octave = app.base_note \ 12
		local is_sharp = (note == 1) or (note == 3) or (note == 6)
			or (note == 8) or (note == 10)
		pal(7, self.dragged_note and 7 or 7)
		if is_sharp then
			spr(8 + note, 2, 6)
		else
			spr(8 + note, 8, 6)
		end
		pal(7, 7)
		print(
			"\014" .. string.format("%1x", octave),
			2 + 12, 7,
			self.dragged_note and 7 or 22
		)
		local x = 20
		rectfill(x, 8, x + 20, 10, 59)
		rectfill(
			x, 8,
			x + min(20 * (app.base_volume / 64), 20), 10,
			self.dragged_volume and 7 or 17
		)
		if self.dragged_volume then
			print("\014" .. string.format("%2d", app.base_volume), 27, 2, 7)
		end
		print(
			"\014inst " .. string.format("%d", app.base_instrument),
			44, 7,
			self.dragged_instrument and 7 or 14 -- col 26
		)
	end	
	
	function el:click(msg)
		-- TODO: replace with pull-down menus
		if msg.mx < 18 then
			self.dragged_note = true
		elseif msg.mx < 42 then
			self.dragged_volume = true
		else
			self.dragged_instrument = true
		end
		self.cursor = 0
	end
	
	function el:drag(msg)
		if self.dragged_note then
			local _, delta = mouselock(true, key("shift") and 0.025 or 0.125, 0)
			app.base_note = mid(0, app.base_note - (12 * delta), 120)
		elseif self.dragged_volume then
			local _, delta = mouselock(true, key("shift") and 0.025 or 0.125, 0)
			app.base_volume = mid(0, app.base_volume - delta, 0x40) -- TODO: handle vol > 64
		elseif self.dragged_instrument then
			local _, delta = mouselock(true, key("shift") and 0.025 or 0.125, 0)
			app.base_instrument = mid(0, app.base_instrument - delta, 0xfe)
			-- TODO: temporary, remove
			app.instrument = app.base_instrument
			app.node = 0
		end
	end
	
	function el:release(msg)
		mouselock(false)
		self.cursor = get_spr(50)
		self.dragged_note = nil
		self.dragged_volume = nil
		if self.dragged_instrument and app.view == "inst" then
			app.refresh_gui = true
		end
		self.dragged_instrument = nil
	end

	function el:doubleclick(msg)
		if msg.mx < 18 then
			app.base_note = 48
		elseif msg.mx < 42 then
			app.base_volume = 0x32
		else
			app.base_instrument = 01
		end
	end
	
	return el
end


function attach_detail_button(parent, el)
	el.width = 16
	el.height = 16
	el.cursor = "pointer"
	parent:attach(el)
	
	function el:draw()
		pal(7, app.detail and 7 or 62)
		spr(45, 1, 3)
		pal(7, 7)		
	end	
	
	function el:tap()
		app.detail = not app.detail
		app.refresh_gui = true
	end
	
	return el
end

:: manual.txt
--[[pod_format="raw",created="2024-04-14 09:49:39",modified="2024-04-14 09:49:39",revision=0]]

:: todo.txt
--[[pod_format="raw",created="2024-04-10 20:46:30",modified="2024-04-10 20:46:41",revision=1]]
- add 4/4 config

:: .info.pod
b64$LS1bW3BvZCxhdXRob3I9ImRyYWttYW5pc28iLGNyZWF0ZWQ9IjIwMjQtMDQtMTYgMTM6MzU6
MTMiLGljb249dXNlcmRhdGEoInU4IiwxNiwxNiwiMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEw
MDAwMDAwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDcwNzAxMDAwMDAwMDEwNzBkMGQwZDBkMGQwZDBk
MGQwZDBkMDcwMTAwMDEwNzBkMGQwZDBkMGQwZDA3MGQwZDBkMGQwZDA3MDEwMTA3MGQwZDBkMGQw
ZDBkMDcwNzBkMGQwZDBkMDcwMTAxMDcwZDBkMGQwZDBkMGQwNzBkMDcwZDBkMGQwNzAxMDEwNzBk
MGQwZDBkMGQwZDA3MGQwNzBkMGQwZDA3MDEwMTA3MGQwZDBkMGQwNzA3MDcwZDBkMGQwZDBkMDcw
MTAxMDcwZDBkMGQwNzA3MDcwNzBkMGQwZDBkMGQwNzAxMDEwNzBkMGQwZDBkMDcwNzBkMGQwZDBk
MGQwZDA3MDEwMTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwMTAxMDYwNzBkMGQwZDBkMGQw
ZDBkMGQwZDBkMDcwNjAxMDEwNjA2MDcwNzA3MDcwNzA3MDcwNzA3MDcwNjA2MDEwMDAxMDYwNjA2
MDYwNjA2MDYwNjA2MDYwNjA2MDEwMDAwMDAwMTA2MDYwNjA2MDYwNjA2MDYwNjA2MDEwMDAwMDAw
MDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAiKSxtb2RpZmllZD0iMjAyNC0wNC0yMSAxNjox
NToxMyIsbm90ZXM9Ik11c2ljIFRyYWNrZXIiLHJ1bnRpbWU9NixzdG9yZWQ9IjIwMjQtMDQtMTYg
MTE6Mzc6NTEiLHRpdGxlPSJWaXNpVHJhY2siLHZlcnNpb249IjAuMC4yIix3b3Jrc3BhY2VzPXt7
bG9jYXRpb249Im1haW4ubHVhIzE0OCIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ic3Jj
L3N5bnRoLmx1YSM3NyIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ic3JjL2tub2IubHVh
IzU0MSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ic3JjL3NsaWRlci5sdWEjMTAwIix3
b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJzcmMvc3ludGhfbWVudXMubHVhIzk5Iix3b3Jr
c3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJzcmMvYXBwLmx1YSMxMCIsd29ya3NwYWNlX2luZGV4
PTF9LHtsb2NhdGlvbj0ic3JjL2VudmVsb3Blcy5sdWEjMjQzIix3b3Jrc3BhY2VfaW5kZXg9MX0s
e2xvY2F0aW9uPSJnZngvMC5nZngiLHdvcmtzcGFjZV9pbmRleD0yfSx7bG9jYXRpb249Im1hcC8w
Lm1hcCIsd29ya3NwYWNlX2luZGV4PTN9LHtsb2NhdGlvbj0ic2Z4LzAuc2Z4Iix3b3Jrc3BhY2Vf
aW5kZXg9NH0se2xvY2F0aW9uPSJzZngvMS5zZngiLHdvcmtzcGFjZV9pbmRleD00fX1dXWx6NAAE
AAAAAwAAADBuaWw=
:: [eoc]
