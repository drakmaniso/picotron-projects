picotron cartridge // www.picotron.net
version 2

:: gfx/
:: map/
:: sfx/
:: src/
:: pal/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2Iixtb2RpZmllZD0iMjAyNC0w
NC0xNiAxNTowOTozNCIscmV2aXNpb249NTQ5Nl1dbHo0AGQEAADUNQAA8yV7WzBdPXtibXA9cHh1
AEMgCAgEMAdgF1AHAAdABwAHICcwN0AXsCxmbGFncz0wLHBhbl94CADHeT0wLHpvb209OH0sQgDx
DyIIBPATBzAHAPcDAAcQByAHIAdgB9AHAAcwBxAHAAQAYAAHIBcAFwQAEUAYAAAaAAFuAAAOACMX
ICQAQBAHICcUAABEABMwOgARECQAIBAXGAAv8BOXAAsZMZcA9QIQEATwKyeQV2BXEAdgJ0AHYAIA
-wFAJ2AHMDdAJ0AXQDfAF-AbVgALHTlWAPYHJBfABxAHsAcQB6AHMAeQBzAHgBcABwIAE4AWABOg
JgBPwBfwFGQAHfIGIq8RMM4gTgduIE4XXiBOJ04gTjc_CAAhF14YAF-OMK7wE1cAHp2uMM4gziA_
Rz4EAB-OUgAjH-AxAErgCwYEACdgByAHUAeQB5BaAi8nYEAACx43QAARIJYBUSAHAFdQCgAiQFdy
Ah8QTAAeEjeLAAcEAB83QwAeBo4AAoYACQwAD08AHmBHUAeQJ3AdAS9HUDsAIEAHkDdgBgAPOwAd
ExBJAQFRASM3EFkBH5CbAR4E2wEgEBdOAT9gN1DdAS4kEBdNAT8QN1CQACRFIAdQR_IBD5IAKAPV
ARVHCgAOUAAPcwIULzdgcQIjDnEDDzEAn58THQT-GJvw-201AByP8Jv-GE-w-w43AB1v_v8YdfCI
NgAdX-_A-xiIOQEeDzEArIIHBwRyTzsSTgIAH3I7AAsvMTE8AAFyDi8RDhIOLQQAD0MAHDAMBgQ_
CBFAWwNREAcQFxBnAwQIABMwGAAQQGIID1kADB4wWQD-CghwBwAIYBcACAdgFwgAB3AIBwAHYAgQ
F1BLABpTBQUEByD8AwQIAA9BAAwcNkEAIEBHVgQfYDcAHRBgUAkvR0A3AB0h8ASnAA83ABrwBAkJ
BMAHcBdgJyBnEAcQJyAHEBfkCR-ATQIZAUQAQBAHMBcICp8QBxBnICdgF3BEAB43kGcQAgAfkM8C
HP8BMA8WQB4wLiA_MC5AHlAOED8AHP8BEA8WUB5ALjA_IC4wHkAOMD8AGXEMDATwAidw6QUVQAIA
APUFz0AXACdAJ3AnkAfwBX0CDQ8CBFzxGRcXBPD5AfAFAQcB8AQBFwHwAwEnAQAB8AABNwEHAeAB
FxEnAeARBxEfABIHHwAg8AMKAE8FAfAMZwwZCmoABEsAEAIFALABAUcB8AAhByHwAhkAH1VXAB0T
blcAAlIAVREHEfADZgBFBCHwBA0AEAMcAAFzAATDAB9ubAAZkBkZBPD-KgHwBz0AcAYBBxEAARAr
AQAQAAAjAfAD0BFHAScBsAEHAUcRBxHAAVcRQwFgN0HwADEAQgEQBX8AMwQBJ68APwcBMH4ADA-c
AR0vMTAyAP-v-wMHBwRXAGcwBwA3ADcABzBnAFcJBg0PowAfDzIA------------------------
-------------------------11QPTEwfX0=
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2Iixtb2RpZmllZD0iMjAyNC0w
NC0xNiAxNTowOTozNCIsc3RvcmVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2Il1dbHo0AAQAAAADAAAA
MG5pbA==
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2Iixtb2RpZmllZD0iMjAyNC0w
NC0xNiAxNTowOTozNCIscmV2aXNpb249NTI4N11dbHo0AGcAAABWEAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD--------------------78QgiKSxoaWRkZW49ZmFsc2UscGFuX3g9
MAgAwnk9MCx0aWxlX2g9OAkAwHc9OCx6b29tPTF9fQ==
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2Iixtb2RpZmllZD0iMjAyNC0w
NC0xNiAxNTowOTozNCIsc3RvcmVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2Il1dbHo0AAQAAAADAAAA
MG5pbA==
:: pal/0.pal
b64$LS1bW3BvZCxiZ19jb2xvcj0wLGJsYWNrZXN0X2NvbG9yPTAsY3JlYXRlZD0iMjAyNC0wNC0x
MCAwNDo1Mjo1MSIsaGlkZGVuPXtbMF09ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2V9LGhpZGRlbl90b2dnbGVzPXtbMF09ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2V9LGxv
Y2tlZD17WzBdPXRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRy
dWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVl
LHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSxm
YWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxz
ZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxm
YWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxz
ZSxmYWxzZSxmYWxzZSxmYWxzZX0sbW9kaWZpZWQ9IjIwMjQtMDQtMTQgMTI6NTc6NDkiLG9rcGFs
X3ZlcnNpb249IjAuMC40IixyZXZpc2lvbj0xODYsdGVzdF9jdWJlX2NvbG9ycz17WzBdPXsxNSwz
MSw0fSx7MzEsNCwyMH0sezQsMjAsMjF9LHsxMCw5LDI1fSx7OSwyNSwyNH0sezgsMjQsMn0sezI2
LDExLDI3fSx7MTEsMjcsM30sezI3LDMsMTl9LHsyOCwxNywxOX0sezI4LDEyLDE2fSx7MTIsMTYs
MX0sezYsMjksMTN9LHsyOSwxMywxOH0sezEzLDE4LDF9LHs3LDIzLDE0fSx7MjMsMTQsMTN9LHsx
NCwzMCwxOH0sezcsNiwyMn0sezYsMjIsNX0sezIyLDUsMjF9LHsxLDEsMX0sezEsMSwxfSx7MSwx
LDF9fSx3aGl0ZXN0X2NvbG9yPTddXWx6NAAwAQAAFQIAAPUFdXNlcmRhdGEoImkzMiIsNjQsIjAB
AMAxZDJiNTMwMDdlMjUIAPAXMDA4NzUxMDBhYjUyMzYwMDVmNTc0ZjAwYzJjM2M3MDBmZmYxZTgI
AEAwMDRkCAARYTYAYGZmZWMyNwoAIGU0OABAMjlhZCQAYDgzNzY5YyAAMTc3YTgAwGNjYWEwMDFj
NWVhYzAA8B1hNWExMDA3NTRlOTcwMDEyNTM1OTAwNzQyZjI5MDA0OTJkMzgwMGEyODg3OUAA8ANh
Y2M1MDBjMzAwNGMwMGViNmJGAGA5MGVjNDIKACBiMsAAoDY0ZGZmNjAwYmSJAACWAEAwZGFiQABf
ODU2ZDABAK4gNjICAB0wAQCwMWUzNzNjMDAzNzQnASEwMwEAMTAwMgEAoDAwMTYxNjE2Iik=
:: pal/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTEwIDA0OjUyOjUxIixtb2RpZmllZD0iMjAyNC0w
NC0xNiAxNTowOTozNCIsc3RvcmVkPSIyMDI0LTA0LTEwIDA0OjUyOjUxIl1dbHo0AAQAAAADAAAA
MG5pbA==
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTE0IDE4OjEzOjQ2Iixtb2RpZmllZD0iMjAyNC0w
NC0xNiAxNTowOTozNCIscmV2aXNpb249ODQ4XV1sejQAfgEAAG4IAADwJ3B4dQADKAAAAwAED0AQ
Ag4AAaABIAKgDgAPEAAN8MoBAgMEBQYHAA--kAgJCgsPDA8NDw4PDxAA8AANDxEPEg8TDxQPFQ8W
DxcTAPEBDxgPGQ8aDxsPHA8dDx4PHxQA8QAgDyEPIg8jDyQPJQ8mDycUAPEAKA8pDyoPKw8sDy0P
Lg8vFADxADAPMQ8yDzMPNA81DzYPNxQA-wU4DzkPOg87DzwPPQ8_Dz8AD--w-wEA6-AjWgEQBg8g
EAEgASAB8AACEAIMEAEgDyEgATAPQPDDDygP--DGD-gKD-8PgA-3Dw0B8AkxABw3MQD_JSUPIgAR
MA_A8L0POg9kMA8fD--AARAPFA8dBhABCQAPNR86AC5QAQAKAA8MYA9JAA948JJXABdAVwAVA4gA
7YDwuw0PBAAPEjAPFPDHNgAfDL0AAR4DvAAPLwD--yYf-wEAzPAH6AMADUAPJA8mDyj--y0h9C0s
9C3wcBUAL-SwCAD-3x--AQCXUP----8f
:: sfx/1.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTE1IDE1OjE0OjQxIixtb2RpZmllZD0iMjAyNC0w
NC0xNiAxNTowOTozNCIscmV2aXNpb249NTQ5XV1sejQAzAEAALAIAADwJ3B4dQADKAAAAwAED0AQ
Ag4AAaABIAKgDgAPEAAN8MoBAgMEBQYHAA--kAgJCgsPDA8NDw4PDxAA8AANDxEPEg8TDxQPFQ8W
DxcTAPEBDxgPGQ8aDxsPHA8dDx4PHxQA8QAgDyEPIg8jDyQPJQ8mDycUAPEAKA8pDyoPKw8sDy0P
Lg8vFADxADAPMQ8yDzMPNA81DzYPNxQA-wU4DzkPOg87DzwPPQ8_Dz8AD--w-wEA6-IYWgEQBg4A
AgEgASAB8AACEAIPIBABIA8hIAEwD4CQAQ8SEAYPIAACEwAKIQDwReAPEgIgDyBQAg8XEAHwYw8T
DxEgD0sPJMABoA8qYA9qIAIBDw5AD-8P2Q_5D58Pkw95D2YPUw4PLQ8gDxMWEAGgDxTwfA-4Cg--
D4AP9w8NAfAJAW4AFxCNABAvbAD-KiUPLwACATAPwPDDDygP-8ACYAwP5A-PD7kPlA9-D2oPWg9K
Dz8PNR8vDyoPJQ8VAaAPRvCUD-gKDFgABhMDwwAgMA5TADwM8MYuAB8DLQD--zMf-wEAzFDoDgAN
QIYF8AUMDzIPLvwrEAwQ-CsfMgwU-CvwcBwAL-ywCAD-3x--AQCXUP----8f
:: sfx/2.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTEyIDA2OjQzOjAwIixtb2RpZmllZD0iMjAyNC0w
NC0xNSAxMToyMzo0NSIscmV2aXNpb249MTBdXWx6NAA1AQAA0QgAAPAncHh1AAMoAAADAAQPQBAC
DgABoAEgAqAOAA8QAA3wygECAwQFBgcAD-_QCAkKCw8MDw0PDg8PEADwAA0PEQ8SDxMPFA8VDxYP
FxMA8QEPGA8ZDxoPGw8cDx0PHg8fFADxACAPIQ8iDyMPJA8lDyYPJxQA8QAoDykPKg8rDywPLQ8u
Dy8UAPEAMA8xDzIPMw80DzUPNg83FAD-BTgPOQ86DzsPPA89Dz4PPwAP--D-AQDr-ydaARAGDyAQ
ASABIAHwAAIQAgwQASAPISABMA9A8MMPKA--8MYP_AoP-w_AD-cPDQHwCQEQBgwwAAP_CZAPEQIg
DFABIAHgAQjwlw80D0zwFQHwoEAAD3AACw8wAP--bB--AQDMv_gPQAANQP--sPBwCgD--2Qf-wEA
l1D-----Hw==
:: sfx/old-1.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTE0IDE3OjU3OjU3Iixtb2RpZmllZD0iMjAyNC0w
NC0xNCAxNzo1Nzo1NyIscmV2aXNpb249MF1dbHo0AF0DAABZCwAA8U9weHUAAygAAAMABA9AEAIO
AAGgASACoA4ADxAADfDJAgEAAwQFBgcCDz_QCAkKCw8MDw0PDg8PBA--kA0PEQ8SDxMPFA8VDxYP
FwAP-5APGA8ZDxoPGw8cDx0PHg8fFADxACAPIQ8iDyMPJA8lDyYPJxQA8QAoDykPKg8rDywPLQ8u
Dy8UAPEAMA8xDzIPMw80DzUPNg83FAD-BTgPOQ86DzsPPA89Dz4PPwAP--D-AQDr8DxaAQQABg8g
EAEgASAB8AACEAIPIgAPHwEPvgAPHw8uBQABBRACBBADAA8aD39ADxECIA8jDxMQD08QAg9yDgAB
kA9gMAEIYA808Ac8AABJAPopDyEgAeAPJAIgDyBQASAB4AUKIA9dAA6ADyTgCSAPWCAPp-APDyjw
xw-4Cg--D4AP9w8NAfAJARCHABMMSgBXMA9-kAEQAHgJIA_AEA1gEwAhD-cUAE-wgA8UVgAAHwxV
AAEVDlQAVgcgAeASCwAXAxcAFwQMABcFDAAWBgwAj-AIDygP--DGdgAOEAd1ABegOQAfAAwAKA91
ABoP6gAFBwsAHwHpAAQfBXQAIy-wyIkBDlMPMAAPgH0A-wcIIA_S8AoBCiAPsyAPMyAPVyAPL-CH
bwAEJw8iRgASDnAAQDAPD5A-AKCsIA-BAA5ADw3QVAA-lPCTRAAFExdEAB-oSAEmAGEAN_DwChMA
XzAPv-BjUAAXGeA7ACmzkA8AIJiQYAAbo2AA-wOfkAUJIA9eIA_E8AcIIA-I8BNvADQRXW8AG5Zv
ABGXbwB-ayAPnvAGAXAAFhcOcAAkDzZMAKKFkAIJIA_dIA_3TAA-3-BzTAAEHg5MAEcwAZABWgD3
AQIKIA9cIA--AA4AD0UgDuAbABcEDAB-BQggD_TwM7MAEBQM4gEv8MMuAC4f-wEAzPMA6A4ADQAN
IA8cD-8PHA8aCAAeGBAAYv--HwELIQIAv-sfDzILDyQPDg85BwACQPsf8HBYAPIBDCAPNA8rDyQL
DzQLDysPKAcAUCYPKAsDEwAYCQIA_gD7EQgRCwgLEQgLIQsBCwgCAFD7EQ4POUgAIDILCAAiDz0H
AJE5Cw8rCw4LBAt6AAEeABAcDgAxFfsRgQA-QPuwCAD-1x--AQCXUP----8f
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2Iixtb2RpZmllZD0iMjAyNC0w
NC0xNiAxNTowOTozNCIsc3RvcmVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2Il1dbHo0AAQAAAADAAAA
MG5pbA==
:: src/app.lua
--[[pod_format="raw",created="2024-04-12 08:11:00",modified="2024-04-16 15:09:34",revision=3472]]
local app = {}


-- Global state

app.pattern = 0 -- opened in pattern editor
app.track = 0 -- opened in track editor
app.instrument = 0 -- opened in instrument editor

app.node = nil -- selected in instrument editor

app.base_note = 48
app.base_volume = 0x32
app.base_instrument = 00

-- Colors -----------------------------------------------------------------

app.editor_bg = 62


-- Layout -------------------------------------------------------------------

app.ruler_height = 9
app.channels_width = 16
app.detail_width = 56
app.cell_width = 20
app.cell_height = 29

app.synth_width = 84
app.synth_height = 72
app.synth_gap = 4
app.mod_width = 58
app.mod_height = app.synth_height

-- GUI -------------------------------------------------------------------------

app.refresh_gui = true
app.gui = nil

app.view = "inst" -- "patt" or "trk" or "inst"
app.detail = false
app.env_advanced = { [0] = false, false, false, false }

local modal = nil


function app.attach_menu_button(parent, el)
	local label = el.get_label()
	el.width = (4 * #label) + 12
	el.height = 9
	el.cursor = "pointer"
	parent:attach(el)
	el.opened = false
	function el:draw()
		local label = self:get_label()
		print(label, 2, 2, self.fg or 7)
		pal(7, self.fg or 7)
		spr(self.opened and 38 or 37, self.width - 7, 2)
		pal(7, 7)
	end
	function el:tap()
		self.opened = true
		app.open_menu {
			x = self.sx, y = self.sy + 9,
			highlight = self.highlight,
			onclose = function()
				self.opened = false
				local label = el.get_label()
				self.width = (4 * #label) + 12
			end,
			items = self.items,
		}
	end
	return el
end


function app.open_menu(menu)
	local entry_height = 9
	-- Calculate popup size
	if not menu.width then
		menu.width = 0
		for i = 1, #menu.items do
			menu.width = max(menu.width, menu.items[i].label and #menu.items[i].label or 0)
		end
		menu.width = 8 + (4 * menu.width)
	end
	if not menu.height then
		menu.height = max(12, 4 + (#menu.items * entry_height))
	end
	if menu.y + menu.height > app.gui.height then
		menu.y = menu.y - 7 - menu.height
	end

	-- Modal layer	
	modal = app.gui:attach {
		x = 0, y = 0,
		width = app.gui.width, height = app.gui.height,
		draw = function(self)
			local ox, oy = menu.x, menu.y
			rectfill(ox, oy, ox + menu.width - 1, oy + menu.height - 1, menu.bg or 7)
			rect(ox, oy, ox + menu.width - 1, oy + menu.height - 1, menu.border or 5)
			for i = 1, #menu.items do
				local y = oy + 2 + (entry_height * (i - 1))
				if self.highlighted == i then
					rectfill(
						ox + 1, y,
						ox + menu.width - 2, y + entry_height - 1,
						menu.highlight or 15
					) 
				end
				print(
					menu.items[i].label or "---",
					ox + 4, y + 2,
					menu.items[i].fg or menu.fg or 62
				)
			end
		end,
		hover = function(self)
			local ox, oy = menu.x, menu.y
			local mx, my, mb = mouse()
			if
				ox <= mx and mx < ox + menu.width
				and oy <= my and my < oy + menu.height
			then
				self.cursor = "pointer"
				self.highlighted = 1 + ((my - oy - 4) \ entry_height)
			else
				self.cursor = "pointer"
				self.highlighted = nil
			end
		end,
		click = function(self)
			if modal then
				modal:detach()
			end
			modal = nil
			if self.highlighted
				and menu.items[self.highlighted].action
			then
				menu.items[self.highlighted].action()
			end
			if (menu.onclose) menu.onclose()
		end
	}
end


function app.has_modal()
	return modal != nil
end


-- Checkbox -------------------------------------------------------------------

function app.attach_checkbox(parent, el)
	el.width = 9 + (4 * #el.label or "")
	el.height = 7
	el.cursor = "pointer"
	parent:attach(el)
	if (not el.visible) el.visible = function() return true end
	function el:draw()
		if (not self:visible()) return
		rect(0, 0, 6, 6,  el.ckeck_border or 59)
--		rectfill(1, 1, 5, 5, el.check_bg or 61)
		if self.get() then
			rectfill(2, 2, 4, 4, el.check_fg or 17)
		end
		print(el.label, 10, 1, el.fg or 5)
	end
	function el:tap()
		if (not self:visible()) return
		self.set(not self.get())
	end
	return el
end

-- Numeric field ---------------------------------------------------------------


function app.attach_num_field(parent, el)
	el.width = parent.width - el.x
	el.height = 12
	parent:attach(el)
	if (not el.visible) el.visible = function() return true end
	el.dragged = nil
	function el:draw()
		local label_fg = self.label_fg or 5
		local field_fg = self.field_fg or 22
		local dragged_fg = self.dragged_fg or 7
		local field_bg = self.field_bg or 59
		if (not self.visible()) return
		local val = self.get()
		rectfill(self.width - 24, 0, self.width - 10, 6, field_bg)
		print(el.label, 3, 1, label_fg)
		if val then
			print(string.format("%3d", val), self.width - 22, 1, self.dragged and dragged_fg or field_fg)
		else
			print("-", self.width - 4, 1, self.dragged and dragged_fg or field_fg)
		end
	end
	function el:hover(msg)
		if msg.mx >= self.width - 21 then
			--- self.cursor = "pointer"
			self.cursor = get_spr(50)
		else
			self.cursor = 1
		end
	end
	function el:click(msg)
		if (not self.visible()) return
		if msg.mx >= self.width - 21 then
			self.dragged = true
			self.cursor = 0 -- TODO: capture mouse
		end
	end
	function el:drag(msg)
		if (not el.visible()) return
		if self.dragged then
			local _, delta = mouselock(true, key("shift") and 0.025 or 0.125, 0)
			new = mid(0, self.get() - delta, 0xff)
			self.set(new)
		end
	end
	function el:release(msg)
		self.dragged = nil
		mouselock(false)
	end
	return el
end


return app
:: src/constants.lua
--[[pod_format="raw",created="2024-04-10 15:52:04",modified="2024-04-13 03:08:09",revision=702]]
local constants = {}


constants.piano_keys = {
	{
		offset = -12,
		[0] = "z", "s", "x", "d", "c", "v", "g", "b", "h", "n", "j", "m",
		",", "l", ".", ";", "/"
	},
	{
		offset = 0,
		[0] = "q", "2", "w", "3", "e", "r", "5", "t", "6", "y", "7", "u",
		"i", "9", "o", "0", "p", "[", "=", "]",
	}
}


constants.isomorphic_keys = {
	{
		offset = -12,
		[0] = "z", "x", "c", "v", "b", "n", "m", ",", ".", "/",
	},
	{
		offset = -6,
		[0] = "a", "s", "d", "f", "g", "h", "j", "k", "l", ";", "'",
	},
	{
	offset = 0,
		[0] = "q", "w", "e", "r", "t", "y", "u", "i", "o", "p", "[", "]", "\\",
	},
	{
	offset = 6,
		[0] = "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "-", "=",
	}
}


return constants
:: src/detail.lua
--[[pod_format="raw",created="2024-04-12 07:24:11",modified="2024-04-16 08:26:12",revision=1012]]
local app = require "src/app"
local note_grid = require "src/note_grid"
local sfx = require "src/sfx"


local detail = {}


function detail.track()
	if app.view == "patt" then
		if note_grid.selection then
			return sfx.pattern_track(app.pattern, note_grid.selection.channel)
		else
			return nil
		end
	else
		return app.track
	end
end


function detail.attach_panel(parent, el)
	el.width = 64
	el.height = 270 - 11 - 16
	parent:attach(el)
	if app.view == "patt" or app.view == "trak" then
		detail.attach_section_pattern(el, { x = 1, y = app.ruler_height })
		detail.attach_section_track(el, { x = 1, y = app.ruler_height + 30 })
		detail.attach_section_note(el, { x = 1, y = app.ruler_height + 80 })
	end

	function el:draw()
		rectfill(0, 0, self.width, self.height, 21)
		pal(7, 5)
		spr(1, 2, self.height - 8)
		pal(7, 7)
	end	
	

	return el
end


-- Pattern section -------------------------------------------------------


function detail.attach_section_pattern(parent, el)
	el.width = parent.width - el.x
	el.height = 24 -- TODO
	parent:attach(el)
	detail.attach_pattern_flow_toggles(el, { x = 4, y = 10 })
	function el:draw()
		--- rectfill(0, 0, self.width, self.height, 2)
		print(string.format("pattern %d", app.pattern), 3, 0, 22)
		line(3, 7, self.width - 3, 7, 5)
	end
end


function detail.attach_pattern_flow_toggles(parent, el)
	el.width = 36 + 1
	el.height = 11
	el.cursor = "pointer"
	parent:attach(el)

	function el:draw()
		local is_start = sfx.pattern_loop_start(app.pattern)
		local is_stop = sfx.pattern_loop_stop(app.pattern)
		local is_end = sfx.pattern_loop_end(app.pattern)
		pal(7, is_start and 17 or 63)
		spr(40, 2, 1)
		pal(7, is_end and 17 or 63)
		spr(41, 2 + 12, 1)
		pal(7, is_stop and 17 or 63)
		spr(42, 2 + 24, 1)
		pal(7, 7)
	end	
	
	function el:tap(msg)
		if msg.mx > 25 then
			sfx.set_pattern_loop_stop(
				app.pattern,
				not sfx.pattern_loop_stop(app.pattern)
			)
		elseif msg.mx > 13 then
			sfx.set_pattern_loop_end(
				app.pattern,
				not sfx.pattern_loop_end(app.pattern)
			)
		else
			sfx.set_pattern_loop_start(
				app.pattern,
				not sfx.pattern_loop_start(app.pattern)
			)
		end
	end

	return el
end


-- Track section ------------------------------------------------------------------


function detail.attach_section_track(parent, el)
	el.width = parent.width - el.x
	el.height = 48 -- TODO
	parent:attach(el)
	app.attach_num_field(
		el,
		{
			x = 0, y = 12,
			label = "speed:",
			label_fg = 22, field_fg = 22, field_bg = 62,
			visible = function() return note_grid.selection != nil end,
			get = function() return sfx.track_speed(detail.track()) end,
			set = function(v) sfx.set_track_speed(detail.track(), v) end,
		}
	)
	el.loop0_field = app.attach_num_field(
		el,
		{
			x = 0, y = 22,
			label = "length:",
			label_fg = 22, field_fg = 22, field_bg = 62,
			visible = function() return note_grid.selection != nil end,
			get = function() return sfx.track_loop0(detail.track()) end,
			set = function(v) sfx.set_track_loop0(detail.track(), v) end,
		}
	)
	app.attach_num_field(
		el,
		{
			x = 0, y = 32,
			label = "loop end:",
			label_fg = 22, field_fg = 22, field_bg = 62,
			visible = function() return note_grid.selection != nil end,
			get = function() return sfx.track_loop1(detail.track()) end,
			set = function(v) sfx.set_track_loop1(detail.track(), v) end,
		}
	)
	
	function el:draw()
		local track = detail.track()
		if (not track) return
		--- rectfill(0, 0, self.width, self.height, 2)
		print(string.format("track %d", track), 3, 0, 22)
		line(3, 7, self.width - 3, 7, 5)
	end
	
	function el:update()
		local track = detail.track()
		if (not track) return
		if sfx.track_loop1(track) > 0 then
			self.loop0_field.label = "l. start:"
		else
			self.loop0_field.label = "length:"
		end
	end
end


-- Note section ------------------------------------------------------------------


function detail.attach_section_note(parent, el)
	el.width = parent.width - el.x
	el.height = 70 -- TODO
	parent:attach(el)
	app.attach_num_field(
		el,
		{
			x = 0, y = 12,
			label = "pitch:",
			label_fg = 22, field_fg = 22, field_bg = 62,
			visible = function() return note_grid.selection != nil end,
			get = function() return sfx.track_pitch(detail.track(), note_grid.selection.step) end,
			set = function(v) sfx.set_track_pitch(detail.track(), note_grid.selection.step, v) end,
		}
	)
	app.attach_num_field(
		el,
		{
			x = 0, y = 22,
			label = "volume:",
			label_fg = 22, field_fg = 22, field_bg = 62,
			visible = function() return note_grid.selection != nil end,
			get = function() return sfx.track_volume(detail.track(), note_grid.selection.step) end,
			set = function(v) sfx.set_track_volume(detail.track(), note_grid.selection.step, v) end,
		}
	)
	app.attach_num_field(
		el,
		{
			x = 0, y = 32,
			label = "inst:",
			label_fg = 22, field_fg = 22, field_bg = 62,
			visible = function() return note_grid.selection != nil end,
			get = function() return sfx.track_instrument(detail.track(), note_grid.selection.step) end,
			set = function(v) sfx.set_track_instrument(detail.track(), note_grid.selection.step, v) end,
		}
	)
	app.attach_num_field(
		el,
		{
			x = 0, y = 42,
			label = "fx:",
			label_fg = 22, field_fg = 22, field_bg = 62,
			visible = function() return note_grid.selection != nil end,
			get = function() return sfx.track_fx(detail.track(), note_grid.selection.step) end,
			set = function(v) end,
		}
	)
	app.attach_num_field(
		el,
		{
			x = 0, y = 52,
			label = "param1:",
			label_fg = 22, field_fg = 22, field_bg = 62,
			visible = function() return note_grid.selection != nil end,
			get = function() return (sfx.track_fx_params(detail.track(), note_grid.selection.step) & 0xf0) >> 4 end,
			set = function(v) end,
		}
	)
	app.attach_num_field(
		el,
		{
			x = 0, y = 62,
			label = "param2:",
			label_fg = 22, field_fg = 22, field_bg = 62,
			visible = function() return note_grid.selection != nil end,
			get = function() return (sfx.track_fx_params(detail.track(), note_grid.selection.step) & 0xf0) end,
			set = function(v) end,
		}
	)
		
	function el:draw()
		local track = app.track
		local step = 0
		if app.view == "patt" then
			if note_grid.selection then
				track = sfx.pattern_track(app.pattern, note_grid.selection.channel)
			else
				return
			end
		end
		--- rectfill(0, 0, self.width, self.height, 2)
		print("note", 3, 0, 22)
		line(3, 7, self.width - 3, 7, 5)
	end
end


return detail
:: src/ed_inst.lua
--[[pod_format="raw",created="2024-04-10 15:43:44",modified="2024-04-16 15:09:34",revision=3405]]
local app = require "src/app"
local envelopes = require "src/envelopes"
local settings = require "src/settings"
local routing = require "src/routing"
local sfx = require "src/sfx"
local synth = require "src/synth"


local ed_inst = {}


function ed_inst.attach(parent, el)
	el.width = 480 - (app.detail and app.detail_width or 0)
	el.height = 270 - 11 - 16
	parent:attach(el)

	sfx.refresh_nodes(app.instrument)	

	ed_inst.attach_instr_chooser(el, { x = 4, y = 4 })
	routing.attach(el, { x = 480 - 311, y = 0 })
	routing.attach_node_chooser(el, { x = 360, y = 46 })

	local dx = app.synth_width + app.synth_gap
	local dy = app.synth_height + app.synth_gap
	local ox = (480 - (4 * dx) + app.synth_gap) \ 2
	local oy = 270 - 11 - 16 - (2 * app.synth_height) - app.synth_gap - 2
	local id = 0
	for row = 0, 1 do
		envelopes.attach_panel(
			el,
			{
				x = 4, y = oy + row * dy, 
				env_id = row,
			}
		)
		for column = 0, 3 do
			synth.attach_node_panel(
				el,
				{
					x = ox + column * dx, y = oy + row * dy, 
					node_id = id
				}
			)
			id += 1
		end
		envelopes.attach_panel(
			el,
			{
				x = 480 - app.mod_width - 4, y = oy + row * dy,
				env_id = 2 + row,
			}
		)
	end

	function el:draw()
		---rectfill(0, 0, self.width, 106, app.editor_bg)
		fillp(0b0000111100001111)
		fillp(0b0101010101010101)
		fillp(0b0011011011001001)
		fillp(0b0001001001001000)
		rectfill(0, 0, self.width, self.height, 62 | (61 << 8))-- app.editor_bg | (61 << 8))
		fillp()
	end	
	
	function el:update()
		local pitch_key = nil
		for i = 1, #settings.keys.pitched do
			local offset = settings.keys.pitched[i].offset
			for j = 0, #settings.keys.pitched[i] do
				local k = settings.keys.pitched[i][j]
				if key(k, true) then
					pitch_key = j + offset
				end
			end
		end
		if pitch_key then
			local pitch = pitch_key + app.base_note
			if key("shift") then
				pitch += 12
			end
			pitch = mid(0, pitch, 0xfe)
			note(
				pitch, -- todo
				app.instrument, -- current_instrument
				app.base_volume, -- current_volume
				ord(" "), 0x00, -- fx, fx param
				8, -- channel 8 so it can play with pattern
				false -- don't force retrigger
			)
		else
			note(0xff, 0xff, 0xff, 0xff, 0xff, 8)
		end
	end
	
	function el:click(msg)
		app.node = nil
	end

	return el
end


-- Instrument chooser --------------------------------------------------------------


function ed_inst.attach_instr_chooser(parent, el)
	el.width = 80
	el.height = 83
	local container = parent:attach(el)
	function container:draw()
		clip()
		rect(-1, -1, self.width, self.height, 5)
		clip(self.sx, self.sy, self.width, self.height)
	end
	local contents = container:attach {
		x = 0, y = 0, width = el.width, height = 128 * 8 + 2,
		cursor = "pointer",
		draw = function(self)
			rectfill(0, 0, self.width, self.height, 63)
			for i = 0, 127 do -- TODO: dynamic number of instruments?
				if i == app.instrument then
					rectfill(0, i * 8 - 1, self.width, (i * 8) + 7, 17)
				end
				print("" .. i .. ": ---", 4, 1 + i * 8, (i == app.instrument) and 7 or 6)
			end
		end,
		click = function(self, msg)
			app.instrument = msg.my \ 8
			app.base_instrument = app.instrument -- TODO: temporary, remove
			app.node = nil
			app.refresh_gui = true
		end
	}
	container:attach_scrollbars()
	return el
end


return ed_inst
:: src/ed_patt.lua
--[[pod_format="raw",created="2024-04-10 10:06:40",modified="2024-04-16 15:09:34",revision=2526]]
local app = require "src/app"
local constants = require "src/constants"
local sfx = require "src/sfx"


local ed_patt = {}


-- Channel panel -------------------------------------------------------------------


function ed_patt.attach_channel_panel(parent, el)
	el.width = app.channels_width
	el.height = 270 - 11 - 16
	parent:attach(el)

	function el:draw()
		rectfill(0, 0, self.width, self.height, 21)
		for channel = 0, 7 do
			local oy = app.ruler_height + channel * app.cell_height
			local track_id = sfx.pattern_track(app.pattern, channel)
			local is_dragged = self.dragged and self.dragged.channel == channel
			if is_dragged then
				rectfill(0, oy + 1, 14, oy + 9, 17)
			end
			
			p8_centered_print(
				string.format("%d", track_id),
				8, oy + 3,
				is_dragged and 7 or 22
			)			
			spr(sfx.channel_is_muted(app.pattern, channel) and 32 or 33, 4, oy + 12)
		end
	end
	
	function el:hover(msg)
		local channel = (msg.my - app.ruler_height) \ app.cell_height
		if (channel > 7) return
		local part = (msg.my - app.ruler_height) % app.cell_height
		if part < 10 then
			--- self.cursor = "pointer"
			self.cursor = get_spr(50)
		else
			self.cursor = 1
		end
	end
	
	function el:click(msg)
		self:set_keyboard_focus(true) -- TODO
		local channel = (msg.my - app.ruler_height) \ app.cell_height
		if (channel > 7) return
		local part = (msg.my - app.ruler_height) % app.cell_height
		if part < 10 then
			local track_id = sfx.pattern_track(app.pattern, channel)
			self.dragged = { channel = channel }
			self.cursor = 0 -- TODO: capture mouse
		elseif part < 20 then
			sfx.mute_channel(
				app.pattern,
				channel,
				not sfx.channel_is_muted(app.pattern, channel)
			)
		end
	end
	
	function el:drag(msg)
		if self.dragged then
			local _, delta = mouselock(true, key("shift") and 0.025 or 0.125, 0)
			local track_id = peek(0x30100 + app.pattern * 20 + self.dragged.channel)
			track_id = mid(0, track_id - delta, 0xff)
			-- TODO: move to sfx
			poke(0x30100 + app.pattern * 20 + self.dragged.channel, track_id)
		end
	end
	
	function el:release(msg)
		self.dragged = nil
		mouselock(false)
	end
		
	return el
end


-- Pattern selector ----------------------------------------------------------------


function ed_patt.attach_pattern_selector(parent, el)
	el.width = 19 * 14
	el.height = 16
	el.cursor = "pointer"
	parent:attach(el)

	function el:draw()
		local playing_pattern = stat(466)
		for p = 0, 18 do
			if p == 0 then
				spr(43, 5, 5)
			elseif p < 18 then
				rectfill(
					p * 14, 4,
					14 + p * 14, 12, 
					(p - 1) == playing_pattern and 17 or 59
				)
				p8_centered_print(
					string.format("%d", p - 1),
					8 + p * 14, 6,
					(p - 1) == app.pattern and 7 or 22
				)
			else
				spr(44, 3 + p * 14, 5)
			end
		end
	end	
	
	function el:click(msg)
		local p = msg.mx \ 14
		if p == 0 then
			-- TODO
		elseif p < 18 then
			app.pattern = p - 1
		else
			-- TODO
		end
	end

	return el
end


return ed_patt
:: src/ed_trak.lua
--[[pod_format="raw",created="2024-04-10 15:48:56",modified="2024-04-12 16:25:37",revision=71]]
local app = require "src/app"


local ed_trak = {}


function ed_trak.attach(parent, el)
	el.width = 480 - (app.detail and app.detail_width or 0)
	el.height = 270 - 11 - 16 - 1
	parent:attach(el)

	function el:draw()
		rectfill(0, 0, self.width, self.height, 62)
	end	

	return el
end


return ed_trak
:: src/envelopes.lua
--[[pod_format="raw",created="2024-04-14 20:24:26",modified="2024-04-16 15:09:34",revision=1159]]
local app = require "src/app"
local sfx = require "src/sfx"


local envelopes = {}

					

-- Envelope panel -----------------------------------------------------------


local env_type_names = { [0] = "adsr", "lfo", "custom" }
local lfo_shape_names = { [0] = "sine", "tri", "saw", "isaw", "square", "pulse" }


function envelopes.make_label(env_id)
	local env_type = sfx.env_type(app.instrument, env_id)
	return env_type_names[env_type] .. " " .. env_id
end


function envelopes.attach_panel(parent, el)
	el.width = app.mod_width
	el.height = app.mod_height
	parent:attach(el)

	app.attach_menu_button(el, {
		x = 2, y = 0, 
		env_id = el.env_id,
		get_label = function()
			return envelopes.make_label(el.env_id)
		end,
		fg = 7,
		highlight = 29,
		items = {
			{ label = "adsr", action = function() sfx.set_env_type(app.instrument, el.env_id, 0); app.refresh_gui = true end },
			{ label = "lfo", action = function() sfx.set_env_type(app.instrument, el.env_id, 1); app.refresh_gui = true end },
			{ label = "custom", action = function() sfx.set_env_type(app.instrument, el.env_id, 2); app.refresh_gui = true end },
		}
	})
	
	envelopes.attach_advanced_button(el, { x = el.width - 12, y = 0 })

	if not app.env_advanced[el.env_id] then 

		local env_type = sfx.env_type(app.instrument, el.env_id)	
		if env_type == 0 then
			-- ADSR ----------------------------------------------
			local labels = { [0] = "a", "d", "s", "r" }
			for i = 0, 3 do
				envelopes.attach_slider(el, { x = 3 + 13 * i, y = 16, slider_height = 40, env_id = el.env_id, param = i, label = labels[i] })
			end
			
		elseif env_type == 1 then
			-- LFO -----------------------------------------------
			local items = {}
			for i = 0, #lfo_shape_names do
				add(items, { label = lfo_shape_names[i], action = function() sfx.set_env_param(app.instrument, el.env_id, 5, i) end })
			end
			--[[ not yet implemented?
			envelopes.attach_menu_button(el, {
				x = 14, y = 12, 
				env_id = el.env_id,
				get_label = function()
					local shape = sfx.env_param(app.instrument, el.env_id, 5)
					return lfo_shape_names[shape] or "???"
				end,
				fg = 5,
				highlight = 29,
				items = items,
			})
			]]--
			envelopes.attach_slider(el, { x = 8, y = 16, slider_height = 40, env_id = el.env_id, param = 4, label = "freq" })
			envelopes.attach_slider(el, { x = 34, y = 16, slider_height = 40, env_id = el.env_id, param = 6, label = "phase" })

		else
			-- Custom -------------------------------------
			app.attach_checkbox(
				el,
				{
					x = 4, y = 12,
					label = "lerp",
					check_fg = 18,
					get = function() return
						(sfx.env_flags(app.instrument, el.env_id) & 0x01) > 0
					end,
					set = function(v)
						local flags = sfx.env_flags(app.instrument, el.env_id)
						sfx.set_env_flags(app.instrument, el.env_id, (flags & ~0x01) | (v and 0x01 or 0x00))
					end,
				}
			)
			envelopes.attach_custom_editor(el, { x = 4, y = 20 })
			app.attach_num_field(
				el,
				{
					x = 4, y = 63,
					label = "speed:",
					field_fg = 29,
					visible = function() return true end,
					get = function() return sfx.env_speed(app.instrument, el.env_id) end,
					set = function(v) sfx.set_env_speed(app.instrument, el.env_id, v) end,
				}
			)
		end
	
	else -- in advanced view
		app.attach_checkbox(
			el,
			{
				x = 4, y = 12,
				label = "loop",
				check_fg = 18,
				visible = function() return sfx.env_type(app.instrument, el.env_id) != 2 end,
				get = function() return
					(sfx.env_flags(app.instrument, el.env_id) & 0x10) > 0
				end,
				set = function(v)
					local flags = sfx.env_flags(app.instrument, el.env_id)
					sfx.set_env_flags(app.instrument, el.env_id, (flags & ~0x10) | (v and 0x10 or 0x00))
				end,
			}
		)
		app.attach_num_field(
			el,
			{
				x = 0, y = 22,
				label = "speed:",
				field_fg = 29,
				visible = function() return (sfx.env_flags(app.instrument, el.env_id) & 0x10 > 0) or (sfx.env_type(app.instrument, el.env_id) == 2) end,
				get = function() return sfx.env_speed(app.instrument, el.env_id) end,
				set = function(v) sfx.set_env_speed(app.instrument, el.env_id, v) end,
			}
		)
		app.attach_num_field(
			el,
			{
				x = 0, y = 32,
				label = "start:",
				field_fg = 29,
				visible = function() return (sfx.env_flags(app.instrument, el.env_id) & 0x10 > 0) or (sfx.env_type(app.instrument, el.env_id) == 2) end,
				get = function() return sfx.env_start(app.instrument, el.env_id) end,
				set = function(v) sfx.set_env_start(app.instrument, el.env_id, v) end,
			}
		)
		app.attach_checkbox(
			el,
			{
				x = 4, y = 42,
				label = "rnd start",
				visible = function() return (sfx.env_flags(app.instrument, el.env_id) & 0x10 > 0) or (sfx.env_type(app.instrument, el.env_id) == 2) end,
				get = function() return
					(sfx.env_flags(app.instrument, el.env_id) & 0x08) > 0
				end,
				set = function(v)
					local flags = sfx.env_flags(app.instrument, el.env_id)
					sfx.set_env_flags(app.instrument, el.env_id, (flags & ~0x08) | (v and 0x08 or 0x00))
				end,
			}
		)
		app.attach_num_field(
			el,
			{
				x = 0, y = 52,
				label = "loop0:",
				field_fg = 29,
				visible = function() return (sfx.env_flags(app.instrument, el.env_id) & 0x10 > 0) or (sfx.env_type(app.instrument, el.env_id) == 2) end,
				get = function() return sfx.env_loop0(app.instrument, el.env_id) end,
				set = function(v) sfx.set_env_loop0(app.instrument, el.env_id, v) end,
			}
		)
		app.attach_num_field(
			el,
			{
				x = 0, y = 62,
				label = "loop1:",
				field_fg = 29,
				visible = function() return (sfx.env_flags(app.instrument, el.env_id) & 0x10 > 0) or (sfx.env_type(app.instrument, el.env_id) == 2) end,
				get = function() return sfx.env_loop1(app.instrument, el.env_id) end,
				set = function(v) sfx.set_env_loop1(app.instrument, el.env_id, v) end,
			}
		)
	end
	
	function el:draw()
		rectfill(0, 0, self.width, self.height, 18)
		rectfill(0, 9, self.width, self.height, 6)
		envelopes.draw_corners(self)
	end
		
	return el
end

	
function envelopes.draw_corners(el)
	local col = app.editor_bg
	pset(0, 0, col)
	pset(el.width - 1, 0, col)
	pset(0, el.height - 1, col)
	pset(el.width - 1, el.height - 1, col)
end


function envelopes.attach_slider(parent, el)
	el.width = 13
	el.height = el.slider_height + 12
	el.cursor = get_spr(50)
	parent:attach(el)
	function el:draw()
		---rectfill(0, 0, self.width - 1, self.height - 1, 7)
		rectfill(4, 0, 4 + 5 - 1, el.slider_height - 1, 59)
		local val = sfx.env_param(app.instrument, self.env_id, self.param)
		local h = math.floor(0.5 + (val / 255) * (el.slider_height - 1))
		rectfill(4, (el.slider_height - 1) - h, 4 + 5 - 1, el.slider_height - 1, 18)
		line(
			4, (el.slider_height - 1) - h,
			4 + 5 - 1, (el.slider_height - 1) - h,
			self.dragged and 7 or 15
		)
		clip()
		if self.hovered then
			p8_centered_print(tostr(val), 4 + 3, self.height - 7, 59)
		else
			p8_centered_print(self.label, 4 + 3, self.height - 7, 5)
		end
	end
	function el:update(msg)
		if (app.has_modal()) return
		local mx, my, mb = mouse()
		if mb != 0 then
			self.hovered = self.dragged != nil
		else
			self.hovered = self.sx <= mx and mx < self.sx + self.width
				and self.sy <= my and my < self.sy + self.height
		end
	end
	function el:click(msg)
		self.cursor = 0
		local val = sfx.env_param(app.instrument, self.env_id, self.param)
		self.dragged = true
	end
	function el:drag(msg)
		if self.dragged then
			local _, delta = mouselock(true, key("shift") and 0.1 or 0.5, 0)
			local old = sfx.env_param(app.instrument, self.env_id, self.param)
			local new = old - delta
			new = mid(0, new, 255)
			sfx.set_env_param(app.instrument, self.env_id, self.param, new)
		end
	end
	function el:release(msg)
		mouselock(false)
		self.cursor = get_spr(50)
		self.dragged = nil
	end
	return el
end


function envelopes.attach_advanced_button(parent, el)
	el.width = 10
	el.height = 10
	el.cursor = "pointer"
	parent:attach(el)
	function el:draw()
		spr(39, 1, 1)
	end
	function el:tap()
		app.env_advanced[parent.env_id] = not app.env_advanced[parent.env_id]
		app.refresh_gui = true
	end
	return el
end


-- Custrom envelopes ------------------------------------------------------------


function envelopes.attach_custom_editor(parent, el)
	el.width = 50
	el.height = 42
	el.cursor = "crosshair"
	parent:attach(el)
	function el:draw()
		rectfill(1, 1, self.width - 2, self.height - 2, 59)
		for i = 0, 15 do
			local val = sfx.env_param(app.instrument, parent.env_id, i)
			local h = (val * (self.height - 2)) \ 255
			rectfill(
				1 + (3 * i), self.height - 1,
				3 + (3 * i), self.height - h - 1,
				(i % 2 == 0) and 29 or 18
			)
		rect(0, 0, self.width - 1, self.height - 1, 5)
		end
		if self.selected then
			local val = sfx.env_param(app.instrument, parent.env_id, self.selected)
			local str = tostr(val)
			print(str, self.width - 3 - (4 * #str), 3, 7)
		end
	end
	function el:drag(msg)
		local param = mid(0, (msg.mx - 1) \ 3, 15)
		local val = ((self.height - 1 - msg.my) * 255) / (self.height - 2)
		local val = mid(0, math.floor(0.5 + val), 255)
		sfx.set_env_param(app.instrument, parent.env_id, param, val)
	end
	function el:update()
		local mx, my, mb = mouse()
		if
			self.sx <= mx and mx < self.sx + self.width
			and self.sy <= my and my < self.sy + self.height
		then
			local param = mid(0, (mx - self.sx - 1) \ 3, 15)
			self.selected = param
		else
			self.selected = nil
		end
	end
	return el
end


return envelopes
:: src/file.lua
--[[pod_format="raw",created="2024-04-07 08:14:09",modified="2024-04-13 13:11:11",revision=1293]]
local app = require "src/app"


local file = {}


--M.default_filename = "/ram/cart/sfx/0.visitrak"
file.default_filename = "/ram/cart/sfx/1.sfx"


function file.save()
	local ud = userdata("u8", 0x30000)
	for i = 0, 0x2ffff do
		ud[i] = peek(0x30000 + i)
	end
	return ud
end


function file.load(ud)
	if type(ud) != "userdata" then
		init_data()
	else
		for i=0,0x2ffff do
			poke(0x30000+i, ud[i])
		end
	end
	app.refresh_gui = true
---			init_undo()
end


function file.handle_drop_items(msg)
	for i = 1, #msg.items do
		local item = msg.items[i]
		if item.pod_type == "file_reference" and item.attrib == "file" then
			local ext = item.fullpath:ext()
			if ext == "sfx" then
				local metadata = fetch_metadata(item.fullpath) or {} -- TODO
				send_message(pid(), {event = "open_file", filename = item.fullpath})
			else
				notify("wrong file extension")
				-- TODO: dialog for unknown file extensions?
				--current_filename = item.fullpath
				--send_message(pid(), {event = "open_file", filename = item.fullpath})
			end
		end
	end
end


-- Initialisation ----------------------------------------------------------------


-- copied from "/system/apps/sfx.lua" in Picotron 0.0.1e
function init_data()
	
	-- index (0x30000)
	
	-- first 3 values are almost metadata only -- not currently
	-- acted on anywhere. perhaps useful in future for deciding
	-- scope of copy/paste, and gui cues, but can be calculated
	-- from content.
	
	poke2(0x30000,
		64,  -- num_instruments
		512, -- num_tracks (64 patterns * 8 channels for default indexing)
		64,  -- num_patterns
		-- flags: 0x1 use default track indexing (base+0x20000, increments of 328 bytes)
		0x1
	)
	poke4(0x30010,
		0x10000, -- insts_addr      (I32)    relative address of instruments
		0x20000, -- tracks_addr     (I32)    relative address of track index
		0,       -- patterns_addr   (I32)    relative address of pattern data
		0        -- unused          (I32)    should be 0
	)
	poke2(0x30020,
		0,  -- tick len (0 for default -- custom vals not supported yet)
		64, -- default track length
		16 -- default track spd
	)
	
	-- default track speed (+3 unused)
	poke(0x30026, 16, 0, 0, 0) 
	
	-- pattern data: first 8 patterns
	
	for pp = 0,7 do
		local addr = 0x30100 + pp * 20
		for i = 0, 7 do
			poke(addr+i, pp*8 + i)
		end
		poke(addr+8, 0x0)  -- flow flags
		poke(addr+9, 0xff) -- channel mask
		poke(addr+10, 0,0) -- length (I16)
		
	end
	
	
	----------------------------------------------------------------------------
	-- single instrument at 0x40000 (instrument 0)
	
	-- node 0: root
	poke(0x40000 + (0 * 32), -- instrument 10node 0
	
			0,    -- parent (0x7)  op (0xf0)
			1,    -- kind (0x0f): 1 root  kind_p (0xf0): 0  -- wavetable_index
			0,    -- flags
			0,    -- unused extra
				
			-- MVALs:  kind/flags,  val0, val1, envelope_index
			
			0x2|0x4,0x20,0,0,  -- volume: mult. 0x40 is max (-0x40 to invert, 0x7f to overamp)
			0x1,0,0,0,     -- pan:   add. center
			0x1,0,0,0,     -- tune: +0 -- 0,48,0,0 absolute for middle c (c4) 261.6 Hz
			0x1,0,0,0,     -- bend: none
			-- following shouldn't be in root
			0x0,0,0,0,     -- wave: use wave 0 
			0x0,0,0,0      -- phase 
	)
	
	
	-- node 1: sine
	poke(0x40000 + (1 * 32), -- instrument 0, node 1
	
			0,    -- parent (0x7)  op (0xf0)
			2,    -- kind (0x0f): 2 osc  kind_p (0xf0): 0  -- wavetable_index
			0,    -- flags
			0,    -- unused extra
				
			-- MVALs:  kind/flags,  val0, val1, envelope_index
			
			0x2,0x20,0,0,  -- volume: mult. 0x40 is max (-0x40 to invert, 0x7f to overamp)
			0x1,0,0,0,     -- pan:   add. center
			0x21,0,0,0,    -- tune: +0 -- 0,48,0,0 absolute for middle c (c4) 261.6 Hz
			               -- tune is quantized to semitones with 0x20
			0x1,0,0,0,     -- bend: none
			0x0,0x40,0,0,  -- wave: triangle
			0x0,0,0,0      -- phase 
	)
	
	

	-- wavetable
	for i=0,7 do
	poke(0x40000 + 0x1e0,
		0x00, -- address (low)  in 256 byte increments
		0xf8, -- address (high) in 64k increments
		0x0a, -- samples (1 << n) 1024
		0xff,  -- wt_height 256(0); wave mval points at one of the entries
		
		-- to do: update (is garbage now?)
		0x80,
		0xf7,
		0x0d, -- samples (1 << n) 8192
		0x01
	)
	end

	-- envelope 0 inst 1
	
	poke(0x40000 + 0x100,
		0,0,0,0, 0,0,0,0,
		0,40,255,0 -- adsr
	)
	
	-- copy default instrument to 1..15
	for i=1,15 do
		memcpy(0x40000 + 0x200*i, 0x40000, 0x200)
	end
	
	--------------------------------------------------
	-- Track Data  0x50000
	--------------------------------------------------
	
	-- Default track size is 5 * 64 rows + 8 = 328 bytes
	
	-- header (8)
	local addr = 0x50000
	poke2(addr, 64) -- len
	poke(addr+2,16) -- spd
	poke(addr+3,0)  -- loop0
	poke(addr+4,0)  -- loop1
	poke(addr+5,0)  -- delay
	poke(addr+6,0)  -- flags (0x1 mute)
	poke(addr+7,0)  -- unused
	
	-- pitch, inst, vol: not set (0xff)
	memset(addr+8, 0xff, 64*3)
	
	-- copy to other tracks
	for i=1,63 do
		memcpy(0x50000 + i*328, 0x50000, 328)
	end
end


return file
:: src/note_grid.lua
--[[pod_format="raw",created="2024-04-11 06:36:17",modified="2024-04-13 06:47:08",revision=1566]]
local app = require "src/app"
local settings = require "src/settings"
local sfx = require "src/sfx"


local note_grid = {}


note_grid.origin = { x = -4 }
note_grid.selection = { channel = 0, step = 0, part = 0 }


function note_grid.attach(parent, el)
	el.width = 480 - app.channels_width - (app.detail and app.detail_width or 0)
	el.height = 270 - 11 - 16
	parent:attach(el)
	
	el.dragged = nil
	
	el:set_keyboard_focus(true)
	
	-- Draw ------------------------------------------------------------------------

	function el:draw()
		local pattern_is_playing = (stat(464) != 0)  and (stat(466) == app.pattern)
		-- Ruler background
		rectfill(0, 0, self.width, app.ruler_height - 2, 61)
		line(0, app.ruler_height - 1, self.width, app.ruler_height - 1, 5)
		local step_start = note_grid.origin.x \ app.cell_width
		local delta_x = - (note_grid.origin.x % app.cell_width)
		if step_start < 0 then
			step_start = 0
			note_grid.origin.x = max(- 4 , note_grid.origin.x)
			delta_x = - note_grid.origin.x
		end
		for channel = 0, 7 do
			local oy = app.ruler_height + channel * app.cell_height
			rectfill(
				0, oy, self.width,
				oy + app.cell_height - 1,
				((channel % 2) == 0) and 63 or 62
			)
			if sfx.channel_is_muted(app.pattern, channel) then
				goto continue
			end
			local track = peek(0x30100 + app.pattern * 20 + channel)
			for step_i = 0, 24 do
				if step_start + step_i > 63 then break end
				local ox = delta_x + step_i * app.cell_width + 1
				if pattern_is_playing and stat(400 + channel, 9) == step_start + step_i then
					rectfill(ox, oy, ox + app.cell_width - 2, oy + app.cell_height - 1, 19)
				end
				if
					note_grid.selection and note_grid.selection.channel == channel
						and note_grid.selection.step == step_start + step_i
				then
					-- TODO: replace with rectfill
					-- TODO: replace with rect when no keyboard focus
					spr(24 + note_grid.selection.part, ox, oy)
				end
				-- TODO: support track length > 64
				local freq = sfx.track_pitch(track, step_start + step_i)
				local inst = sfx.track_instrument(track, step_start + step_i)
				local vol  = sfx.track_volume(track, step_start + step_i)
				local fx   = sfx.track_fx(track, step_start + step_i)
				local fxp  = sfx.track_fx_params(track, step_start + step_i)
				-- Note and octave
				if freq != 0xff then
					local note = freq % 12
					local is_sharp = (note == 1) or (note == 3) or (note == 6)
						or (note == 8) or (note == 10)
					local x = is_sharp and (ox + 2) or (ox + 2) -- 5
					spr(8 + note, x, oy + 2)
					local x_oct = is_sharp and (ox + 14) or (ox + 8) -- 11
					if (freq \ 12) <= 9 then
						print("\014" .. tostr(freq \ 12), x_oct, oy + 3, 13) 
					else
						print("\014?", ox + 14, oy + 3, 13) 
					end
				else
					print("\014.", ox + 2, oy, 7)
				end
				-- Volume
				if vol != 0xff then
					local w_vol = (vol / 64) * (app.cell_width - 6)
					w_vol = min(w_vol, app.cell_width - 6)
					if w_vol == 0 and vol != 0 then
						w_vol = 1
					end
					rectfill(ox + 2, oy + 10, ox + 2 + app.cell_width - 6, oy + 12, 60)
					if w_vol > 0 then
						rectfill(ox + 2, oy + 10, ox + 2 + w_vol, oy + 12, 17) -- col 22
					end
					-- TODO: support vol > 64
				else
					print("\014.", ox + 2, oy + 7, 5)
				end
				-- Instrument
				local x = 8
				if inst != 0xff then
					if inst > 99 then
						x -= 4
					elseif inst > 9 then
						x -= 2
					end
					x = 2
					print("\014" .. string.format("%d", inst), ox + x, oy + 15, 14) -- 26
				else
					print("\014.", ox + 2, oy + 15 - 1, 5)
				end
				-- Effect
				if false then
					print("\014" .. fx, ox + 2, oy + 22, 22)
				else
					print("\014.", ox + 2, oy + 22 - 1, 5)
				end
			end
			::continue::
		end
		if self.height > app.ruler_height + 8 * app.cell_height then
			rectfill(0, app.ruler_height + 8 * app.cell_height, self.width, self.height, 62)
		end
		-- Bar lines
		for step_i = 0, 24 do
			if step_start + step_i > 63 + 1 then break end
			local ox = delta_x + (step_i * app.cell_width)
			local bar = (step_start + step_i) \ (4 * 4) + 1
			local beat = ((step_start + step_i) \ 4) % 4 + 1
			if (step_start + step_i) % 4 == 0 then
				if ((step_start + step_i) \ 4) % 4 == 0 then
					line(ox, 0, ox, self.height, 22)
					print("\014" .. bar .. "." .. beat, ox + 2, 2, 22)
				else
					line(ox, 0, ox, self.height, 5)
					print("\014" .. bar .. "." .. beat, ox + 2, 2, 5)
				end
			else
				--[[
				poke(0x550b, 0x3f)
				fillp(0b0000000011111111)
				line(ox, app.ruler_height, ox, self.height - 1, 5)
				fillp()
				poke(0x550b, 0x00)
				--]]
			end
		end
	end
	
	-- Mouse --------------------------------------------------------------------
	

	function el:hover(msg)
		if msg.my <= app.ruler_height then
			self.cursor = "grab"
		else
			self.cursor = 1
		end
	end
	

	function el:click(msg)
		if msg.my < app.ruler_height or msg.mb == 4 then
			self.dragged = { x = note_grid.origin.x + msg.mx, pan = true }
			self.cursor = "grab"
		elseif msg.mb == 1 then
			self:set_keyboard_focus(true)
			local step = (msg.mx + note_grid.origin.x) \ app.cell_width
			local channel = (msg.my - app.ruler_height) \ app.cell_height
			if
				(0 <= channel) and (channel <= 7)
					and (0 <= step) and (step <= 63) -- TODO: handle track length
			then
				note_grid.selection = { part = 0, step = step, channel = channel }
				local y = (msg.my - app.ruler_height) % app.cell_height
				if y > 20 then
					note_grid.selection.part = 3
				elseif y > 14 then
					note_grid.selection.part = 2
				elseif y > 8 then
					note_grid.selection.part = 1
				end
				self:show_selection()
			else
				note_grid.selection = nil
			end
		end
	end
	

	function el:drag(msg)
		if self.dragged then
			note_grid.origin.x = self.dragged.x - msg.mx
		end
	end
	

	function el:release(msg)
		self.dragged = nil
		self.cursor = 1
	end
	
	
	function el:mousewheel(msg)
		note_grid.origin.x -= msg.wheel_y * app.cell_width
	end
	
	-- Update -----------------------------------------------------------------
	

	function el:update()
		if self.note_playing then
			-- TODO: should be in main.lua (bug when switching view during note)
			if self.note_playing.tick > 10 then
				note(0xff, 0xff, 0xff, 0xff, 0xff, self.note_playing.channel)
				self.note_playing = nil
			else
				self.note_playing.tick += 1
			end
		end
		
		-- TODO: separate: take focus *xor* move
		if (keyp("pageup")) self:set_keyboard_focus(true); self:goto_previous_channel()
		if (keyp("pagedown")) self:set_keyboard_focus(true); self:goto_next_channel()
		if (keyp("up")) self:set_keyboard_focus(true); self:goto_previous_part()
		if (keyp("down")) self:set_keyboard_focus(true); self:goto_next_part()
		if (keyp("left")) self:set_keyboard_focus(true); self:goto_previous_step()
		if (keyp("right")) self:set_keyboard_focus(true); self:goto_next_step()

		if note_grid.selection then
			self:handle_positioned_key()
		end
	end


	function el:handle_positioned_key()
		local keys = settings.keys
		
		local track = peek(0x30100 + app.pattern * 20 + note_grid.selection.channel)
		local base_addr = 0x50000 + 8 + (track * 328) + note_grid.selection.step
		
		-- Pitched input
		local pitch_key = nil
		for i = 1, #settings.keys.pitched do
			local offset = settings.keys.pitched[i].offset
			for j = 0, #settings.keys.pitched[i] do
				local k = settings.keys.pitched[i][j]
				if keyp(k, true) then
					pitch_key = j + offset
				end
			end
		end
		
		local num_key = keyp_num()
		local hex_key = keyp_hex()
						
		-- Part-specific input
				
		if note_grid.selection.part == 0 then
			local note = peek(base_addr) % 12
			if key("shift") and num_key then
				local pitch = note + num_key * 12
				pitch = mid(0, pitch, 0xfe)
				poke(base_addr, pitch)
				self:goto_next_step()
			elseif pitch_key then
				local pitch = pitch_key + app.base_note
				if key("shift") then
					pitch += 12
				end
				pitch = mid(0, pitch, 0xfe)
				poke(base_addr, pitch)
				poke(base_addr + (2 * 64), app.base_volume)
				poke(base_addr + (1 * 64), app.base_instrument)
				-- TODO fx and fxp
				self:play_selection()
				self:goto_next_step()
			elseif keyp(keys.rest) and key("shift") then
				poke(base_addr, 0xff)
				self:goto_next_step()
			elseif keyp(keys.rest) then
				poke(base_addr, 0xff)
				poke(base_addr + (2 * 64), 0xff)
				poke(base_addr + (1 * 64), 0xff)
				-- TODO fx and fxp
				self:goto_next_step()
			end
			
		elseif note_grid.selection.part == 1 then
			if num_key then
				local vol = math.floor(((hex_key / 9) * 64) + 0.5)
				if key("shift") then
					vol += 64
				end
				notify("" .. vol)
				poke(base_addr + (2 * 64), vol)
				self:goto_next_step()
			elseif keyp(keys.rest) then
				poke(base_addr + (2 * 64), 0xff)
				self:goto_next_step()
			end
			
		elseif note_grid.selection.part == 2 then
			if num_key then
				local inst = peek(base_addr + (1 * 64))
				if (inst == 0xff) inst = 0
				if key("shift") then
					inst = (hex_key * 10) + (inst % 10)
				else
					inst = ((inst \ 10) * 10) + num_key
				end
				poke(base_addr + (1 * 64), inst)
				self:goto_next_step()
			elseif keyp(keys.rest) then
				poke(base_addr + (1 * 64), 0xff)
				self:goto_next_step()
			end
		--[[
		elseif note_grid.selection.part == 3 then
			if hexa_val then
				poke(base_addr + (4 * 64), hexa_val)
				self:goto_next_step()
			elseif keyp(keys.rest) then
				poke(base_addr + (4 * 64), 0xff)
				self:goto_next_step()
			end
		]]
		end
		
		-- Non part-specific input
		
		if keyp("backspace") then
			self:goto_previous_step()
			local base_addr = 0x50000 + 8 + (track * 328) + note_grid.selection.step
			poke(base_addr, 0xff)
			poke(base_addr + (2 * 64), 0xff)
			poke(base_addr + (1 * 64), 0xff)
			-- TODO: fx and fxp
			-- poke(base_addr + (3 * 64), 0xff)
			-- poke(base_addr + (4 * 64), 0xff)
		end
	end
	

	function el:goto_previous_part()
		if not note_grid.selection then
			self:goto_start()
		elseif note_grid.selection.part > 0 then
			note_grid.selection.part -= 1
		elseif note_grid.selection.channel > 0 then
			note_grid.selection.part = 3
			self:goto_previous_channel()
		end
		self:show_selection()
	end


	function el:goto_next_part()
		if not note_grid.selection then
			self:goto_start()
		elseif note_grid.selection.part < 3 then
			note_grid.selection.part += 1
		elseif note_grid.selection.channel < 7 then
			note_grid.selection.part = 0
			self:goto_next_channel()
		end
		self:show_selection()
	end
	
	
	function el:goto_previous_channel()
		-- TODO: skip muted
		if not note_grid.selection then
			self:goto_start()
		elseif note_grid.selection.channel > 0 then
			self:goto_channel(note_grid.selection.channel - 1)
		end
	end
	
	
	function el:goto_next_channel()
		-- TODO: skip muted
		if not note_grid.selection then
			self:goto_start()
		elseif note_grid.selection.channel < 7 then
			self:goto_channel(note_grid.selection.channel + 1)
		end
	end	

	

	function el:goto_previous_step()
		if not note_grid.selection then
			self:goto_start()
		elseif note_grid.selection.step > 0 then
			self:goto_step(note_grid.selection.step - 1)
		end
	end
		

	function el:goto_next_step()
		if not note_grid.selection then
			self:goto_start()
		elseif note_grid.selection.step < 63 then -- TODO: handle track length
			self:goto_step(note_grid.selection.step + 1)
		end
	end
	

	function el:goto_start()
		note_grid.selection = { part = 0, step = 0, channel = 0 }
		self:show_selection()
	end


	function el:goto_channel(c)
		-- TODO check if channel is muted
		note_grid.selection.channel = c
		self:show_selection()
	end
	

	function el:goto_step(s)
		note_grid.selection.step = s
		self:show_selection()
	end
	

	function el:show_selection()
		if (not note_grid.selection) return
		-- TODO: pagination by bars?
		local offset = 4 -- TODO
		if
			note_grid.origin.x > ((note_grid.selection.step * app.cell_width) - offset)
		then
			note_grid.origin.x = note_grid.selection.step * app.cell_width - offset
		elseif
			note_grid.origin.x + self.width < ((note_grid.selection.step + 1) * app.cell_width) + offset
		then
			note_grid.origin.x = ((note_grid.selection.step + 1) * app.cell_width) + offset - self.width
		end
	end
	

	function el:play_selection()
		if note_grid.selection and stat(464) == 0 then
			local track = peek(0x30100 + app.pattern * 20 + note_grid.selection.channel)
			local base_addr = 0x50000 + 8 + (track * 328) + note_grid.selection.step
			local pitch = peek(base_addr)
			local inst = peek(base_addr + 64)
			local vol  = peek(base_addr + (2 * 64))
			local fx   = peek(base_addr + (3 * 64))
			local fxp  = peek(base_addr + (4 * 64))
			note(
				pitch,
				inst,
				vol,
				ord(" "), 0x00, -- fx, fx param
				note_grid.selection.channel,
				false
			)
			self.note_playing = { channel = note_grid.selection.channel, tick = 0 }
		end
	end
	
	el:show_selection()
		
	return el
end


return note_grid
:: src/routing.lua
--[[pod_format="raw",created="2024-04-13 06:33:13",modified="2024-04-15 08:22:31",revision=1560]]
local app = require "src/app"
local sfx = require "src/sfx"


local routing = {}


-- Routing display -------------------------------------------------------------


local node_width = 26
local node_height = 16
local node_gap = 14

function routing.attach(parent, el)
	el.width = 311
	el.height = 90
	parent:attach(el)
	
	function el:draw()
		--- rectfill(0, 0, self.width, self.height, 62)
		for n = 0, 7 do
			local node = sfx.nodes[n]
			local pos = node.position
			if pos then
				-- Coordinates from logical position
				pos.x = 4 + pos.column * (node_width + node_gap)
				pos.y = 4 + pos.row * node_height
				local ppos = node.parent.position
				ppos.x = 4 + ppos.column * (node_width + node_gap)
				ppos.y = 4 + ppos.row * node_height

				if app.node == n then
					rect(pos.x - 1, pos.y - 1, pos.x + node_width + 1, pos.y + 8 + 1, 24)
				end
				
				if node.type >= 8 and node.older_sibling then
					-- Horizontal bracket
					local col = 6
					local x = pos.x + node_width \ 2
					local orig = node.older_sibling
					local depth = 0
					while #orig.children > 0 and depth < 8 do
						orig = orig.children[#orig.children]
						depth += 1
					end
					local orig_x = orig.position.x + node_width
					line(x, pos.y - 2, x - 3, pos.y - 5, col)
					line(x - 3, pos.y - 5, x - (node_width \ 2) - 3, pos.y - 5, col)
					line(x - (node_width \ 2) - 3, pos.y - 5, x - (node_width \ 2) - 3 - 2, pos.y - 7, col)
					line(x, pos.y - 2, x + 3, pos.y - 5, col)
					line(x + 3, pos.y - 5, orig_x + 3, pos.y - 5, col)
					line(orig_x + 3, pos.y - 5, orig_x + 3 + 2, pos.y - 7, col)
				elseif node != sfx.root then
					-- Arrow
					line(
						ppos.x + node_width + 7, ppos.y + 4,
						ppos.x + node_width + 1, ppos.y + 4,
						7
					)
					line(
						pos.x - 7, pos.y + 4,
						ppos.x + node_width + 7, ppos.y + 4,
						7
					)
					line(
						pos.x - 1, pos.y + 4,
						pos.x - 7, pos.y + 4,
						7
					)
					line(pos.x - 2, pos.y + 3, pos.x - 2, pos.y + 5, 7)
					line(pos.x - 3, pos.y + 2, pos.x - 3, pos.y + 6, 7)
				end
				
				-- Node boxes
				local str = "??? "
				local fg = 63
				local bg = 30
				if node == sfx.root then str = "synth"; fg = 22; bg = 7
				elseif node.type == 2 then
					if node.op == 0 then str = "osc " .. n; bg = 17
					elseif node.op == 1 then str = "fm " .. n; bg = 27
					elseif node.op == 2 then str = "ring " .. n; bg = 22
					end
				elseif node.type == 8 then str = "filt " .. n; bg = 14
				elseif node.type == 9 then str = "echo " .. n; bg = 31
				elseif node.type == 10 then str = "shap " .. n; bg = 9
				end
				rectfill(pos.x, pos.y, pos.x + node_width, pos.y + 8, bg)
				p8_centered_print(str, pos.x + (node_width \ 2) + 1, pos.y + 2, fg)
			end
		end
	end
	
	function el:hover(msg)
		self.cursor = 1
		for n = 0, 7 do
			local node = sfx.nodes[n]
			local pos = node.position
			if
				pos and pos.x and pos.x <= msg.mx and msg.mx <= pos.x + node_width
				and pos.y <= msg.my and msg.my <= pos.y + 10
			then
				self.cursor = "pointer"
			end
		end
	end

	function el:tap(msg)
		app.node = nil
		for n = 0, 7 do
			local node = sfx.nodes[n]
			local pos = node.position
			if
				pos and pos.x and pos.x <= msg.mx and msg.mx <= pos.x + node_width
				and pos.y <= msg.my and msg.my <= pos.y + 10
			then
				app.node = n
			end
		end
	end
	
	return el
end


-- Node chooser ----------------------------------------------------------------


local node_choice = {
	[0] = {
		[0] = { label = "osc", color = 17, node_type = 0x2, node_op = 0x0 },
		{ label = "fm", color = 27, node_type = 0x2, node_op = 0x1 },
		{ label = "ring", color = 22, node_type = 0x2, node_op = 0x2 },
	},
	{
		[0] = { label = "filt", color = 14, node_type = 0x8, node_op = 0x0 },
		{ label = "echo", color = 31, node_type = 0x9, node_op = 0x0 },
		{ label = "shap", color = 9, node_type = 0x0a, node_op = 0x0 },
	},
}


function routing.attach_node_chooser(parent, el)
	el.width = 118
	el.height = 50
	parent:attach(el)
	
	function el:update()
		self.hidden = true
		if app.node and sfx.node_type(app.instrument, app.node) < 8 then
			self.hidden = false
		end
	end

	function el:draw()
		--- rectfill(0, 0, self.width - 1, self.height - 1, 0)
		print("add child node:", 4, 2, 22)
		local ox, oy = 4, 12
		for row = 0, #node_choice do
			for column = 0, #(node_choice[row]) do
				local x = ox + column * node_width
				local y = oy + row * (8 + 4)
				local col = node_choice[row][column].color
				rectfill(x, y, x + (node_width - 6), y + 8, col)
				p8_centered_print(
					node_choice[row][column].label,
					x + ((node_width - 6) \ 2) + 1,
					y + 2,
					63
				)
			end
		end
	end
	
	function el:hover(msg)
		self.cursor = 1
		local ox, oy = 4, 12
		for row = 0, #node_choice do
			for column = 0, #(node_choice[row]) do
				local x = ox + column * node_width
				local y = oy + row * (8 + 4)
				if
					x <= msg.mx and msg.mx <= x + (node_width - 6)
					and y <= msg.my and msg.my <= y + 8
				then
					self.cursor = "pointer"
				end
			end
		end
	end

	function el:click(msg)
		return true -- don't want to deselect the node!
	end
	
	function el:tap(msg)
		if (not app.node) return
		local ox, oy = 4, 12
		for row = 0, #node_choice do
			for column = 0, #(node_choice[row]) do
				local x = ox + column * node_width
				local y = oy + row * (8 + 4)
				if
					x <= msg.mx and msg.mx <= x + (node_width - 6)
					and y <= msg.my and msg.my <= y + 8
				then
					sfx.add_node(
						app.instrument,
						app.node,
						node_choice[row][column].node_type,
						node_choice[row][column].node_op
					)
					app.refresh_gui = true
				end
			end
		end
	end
	

	return el
end


return routing
:: src/settings.lua
--[[pod_format="raw",created="2024-04-11 08:58:08",modified="2024-04-13 03:08:09",revision=735]]
local constants = require "src/constants"


local settings = {}

---[[
settings.keys = {
	pitched = constants.isomorphic_keys,
	play = "space",
	rest = "del",
}
--]]
--[[
settings.keys = {
	pitched = constants.piano_keys,
	play = "space",
	rest = "del",
}
--]]


return settings
:: src/sfx.lua
--[[pod_format="raw",created="2024-04-07 08:22:05",modified="2024-04-16 15:09:34",revision=4090]]
local sfx = {}


local sfx_index = 0x030000
local sfx_instr = 0x040000
local sfx_track = 0x050000
local sfx_wave = 0xf00000 -- maybe not? (search discord)


local num_instrument = 0
local num_tracks = 0
local num_patterns = 0
local header_flags = 0
local insts_addr = 0
local tracks_addr = 0
local patterns_addr = 0


function sfx.read_header()
	num_instruments = peek2(sfx_index)
	num_tracks = peek2(sfx_index + 2)
	num_patterns = peek2(sfx_index + 4)
	header_flags = peek2(sfx_index + 6)
	-- unused: peek2(sfx_index + 8)
	insts_addr = peek4(sfx_index + 10)
	tracks_addr = peek4(sfx_index + 14)
	patterns_addr = peek4(sfx_index + 18)
	?header_flags
	?string.format("%x", insts_addr)
	?string.format("%x", tracks_addr)
	?string.format("%x", patterns_addr)
end


function sfx.play_or_pause()
	-- is `stat(464)` enough?
	if stat(464) == 0 then
		music(0)
	else
		note()
	end
end


function sfx.channel_is_muted(pattern, channel)
	local channel_mutes = peek(0x30100 + (pattern * 20) + 9)
	local muted = (channel_mutes & (1 << channel)) == 0
	return muted
end


function sfx.mute_channel(pattern, channel, mute)
	local channel_mutes = peek(0x30100 + (pattern * 20) + 9)
	channel_mutes &= ~(1 << channel)
	channel_mutes |= (mute and 0 or 1) << channel
	poke(0x30100 + (pattern * 20) + 9, channel_mutes)
end


function sfx.pattern_track(pattern, channel)
	return peek(0x30100 + pattern * 20 + channel)
end


function sfx.track_speed(track)
	return peek(0x50000 + (track * 328) + 2)
end


function sfx.set_track_speed(track, val)
	return poke(0x50000 + (track * 328) + 2, val)
end


function sfx.track_loop0(track)
	return peek(0x50000 + (track * 328) + 3)
end


function sfx.set_track_loop0(track, val)
	return poke(0x50000 + (track * 328) + 3, val)
end


function sfx.track_loop1(track)
	return peek(0x50000 + (track * 328) + 4)
end


function sfx.set_track_loop1(track, val)
	return poke(0x50000 + (track * 328) + 4, val)
end


-- Track notes -------------------------------------------------------------


function sfx.track_pitch(track, step)
	return peek(0x50000 + 8 + (track * 328) + step)
end
function sfx.set_track_pitch(track, step, v)
	return poke(0x50000 + 8 + (track * 328) + step, v)
end


function sfx.track_instrument(track, step)
	return peek(0x50000 + 8 + (track * 328) + step + 64)
end
function sfx.set_track_instrument(track, step, v)
	return poke(0x50000 + 8 + (track * 328) + step + 64, v)
end


function sfx.track_volume(track, step)
	return peek(0x50000 + 8 + (track * 328) + step + (2 * 64))
end
function sfx.set_track_volume(track, step, v)
	return poke(0x50000 + 8 + (track * 328) + step + (2 * 64), v)
end


function sfx.track_fx(track, step)
	return peek(0x50000 + 8 + (track * 328) + step + (3 * 64))
end
function sfx.set_track_fx(track, step, v)
	return poke(0x50000 + 8 + (track * 328) + step + (3 * 64), v)
end


function sfx.track_fx_params(track, step)
	return peek(0x50000 + 8 + (track * 328) + step + (3 * 64))
end
function sfx.set_track_fx_params(track, step, v)
	return poke(0x50000 + 8 + (track * 328) + step + (3 * 64), v)
end


-- Pattern flow flags ------------------------------------------------------


function sfx.pattern_loop_start(pattern)
	return (peek(0x30100 + (pattern * 20) + 8) & 0x01) != 0
end


function sfx.set_pattern_loop_start(pattern, bool)
	local old = peek(0x30100 + (pattern * 20) + 8)
	if bool then
		poke(0x30100 + (pattern * 20) + 8, old | 0x01)
	else
		poke(0x30100 + (pattern * 20) + 8, old & (~ 0x01))
	end
end


function sfx.pattern_loop_end(pattern)
	return (peek(0x30100 + (pattern * 20) + 8) & 0x02) != 0
end


function sfx.set_pattern_loop_end(pattern, bool)
	local old = peek(0x30100 + (pattern * 20) + 8)
	if bool then
		poke(0x30100 + (pattern * 20) + 8, old | 0x02)
	else
		poke(0x30100 + (pattern * 20) + 8, old & (~ 0x02))
	end
end


function sfx.pattern_loop_stop(pattern)
	return (peek(0x30100 + (pattern * 20) + 8) & 0x04) != 0
end


function sfx.set_pattern_loop_stop(pattern, bool)
	local old = peek(0x30100 + (pattern * 20) + 8)
	if bool then
		poke(0x30100 + (pattern * 20) + 8, old | 0x04)
	else
		poke(0x30100 + (pattern * 20) + 8, old & (~ 0x04))
	end
end

------------------------------------------------------------------------------
-- The Synth -----------------------------------------------------------------
------------------------------------------------------------------------------


-- Node tree -----------------------------------------------------------------


sfx.nodes = {}
for n = 0, 7 do
	sfx.nodes[n] = {
		parent = nil, -- id of the parent
		children = {}, -- list of direct references to the children
		type = nil,
	}
end
	

local function depth_walk(root, pre_fun, post_fun, depth)
	if (not depth) depth = 0
	if depth > 8 then
		notify("*** Deep recursion: cycle in synth nodes? ***")
		return
	end
	if (pre_fun) pre_fun(root)
	for i = 1, #root.children do
		local child = root.children[i]
		if child.type != 0 then
			depth_walk(child, pre_fun, post_fun, depth + 1)
		end
	end
	if (post_fun) post_fun(root)
end


function sfx.refresh_nodes(instrument)
	for n = 0, 7 do
		sfx.nodes[n].id = n
		sfx.nodes[n].children = {}
		sfx.nodes[n].older_sibling = nil
		sfx.nodes[n].height = nil -- TODO: or 0?
		sfx.nodes[n].position = nil
	end
	sfx.root = sfx.nodes[0]
	--- printh("* refresh *")
	for n = 0, 7 do
		local type = sfx.node_type(instrument, n)
		local op = sfx.node_op(instrument, n)
		local parent_id = sfx.node_parent(instrument, n)
		--- printh("" .. parent_id .. " -> " .. n .. " type=" .. type .. " op=" .. op)
		sfx.nodes[n].parent = sfx.nodes[parent_id]
		sfx.nodes[n].type = type
		sfx.nodes[n].op = op
		if type != 0 and n != 0 then
			add(sfx.nodes[n].parent.children, sfx.nodes[n])
		end
	end
	
	depth_walk(
		sfx.root,
		nil,
		function(node)
			if #node.children == 0 then
				node.height = 1
			else
				local h = 0
				for i = 1, #node.children do
					local child = node.children[i]
					if i > 1 then
						child.older_sibling = node.children[i - 1]
					end
					h += child.height
				end
				node.height = h
			end
		end
	)

	sfx.root.position = { row = 0, column = 0 }
	depth_walk(
		sfx.root,
		function(node)
			local row = node.position.row
			for i = 1, #node.children do
				node.children[i].position = {
					column = node.position.column + 1,
					row = row,
				}
				row += node.children[i].height
			end
		end,
		nil
	)
end


function sfx.add_node(instrument, parent_id, node_type, node_op)
	local parent = sfx.nodes[parent_id]
	
	if parent.type >= 8 then
		return
	end

	local target = parent
	local depth = 0

	while #target.children != 0 and depth < 10 do
		target = target.children[#target.children]
		depth += 1
	end
	local target_id = target.id + 1
	
	if node_type == 2 and node_op != 0 then
		-- modulating oscillators are always the first child
		target_id = parent.id + 1 
		local first_child_op = sfx.node_op(instrument, target_id)
		if first_child_op > 0 then
			-- already a node with a modulating operator: refuse to create
			return
		end
	end
	
	if target_id >= 8 then
		-- no room!
		return
	end	

	sfx.insert_node(instrument, target_id, parent_id)
	
	if node_type == 0x2 and node_op == 1 then
		-- FM mod osc
		sfx.set_node_type(instrument, target_id, node_type)
		sfx.set_node_op(instrument, target_id, node_op)
		sfx.set_node_param_val1(instrument, target_id, 0, 0x20) -- volume
		sfx.set_node_param_flags(instrument, target_id, 2, 0x02) -- not quantized, and relation + for tune
		sfx.set_node_param_flags(instrument, target_id, 3, 0x01) -- relation + for bend
	elseif node_type == 0x2 and node_op == 2 then
		-- Ring mod osc
		sfx.set_node_type(instrument, target_id, node_type)
		sfx.set_node_op(instrument, target_id, node_op)
		sfx.set_node_param_val1(instrument, target_id, 0, 0x20) -- volume
		sfx.set_node_param_flags(instrument, target_id, 2, 0x01) -- not quantized, and relation + for tune
		sfx.set_node_param_flags(instrument, target_id, 3, 0x01) -- relation + for bend
	elseif node_type == 0x2 then
		-- Osc
		sfx.set_node_type(instrument, target_id, node_type)
		sfx.set_node_op(instrument, target_id, node_op)
		sfx.set_node_param_val1(instrument, target_id, 0, 0x20) -- volume
		sfx.set_node_param_flags(instrument, target_id, 0, 0x02) -- relation * for volume
		sfx.set_node_param_flags(instrument, target_id, 1, 0x01) -- relation + for pan
		sfx.set_node_param_flags(instrument, target_id, 2, 0x21) -- quantized, and relation + for tune
		sfx.set_node_param_flags(instrument, target_id, 3, 0x01) -- relation + for bend
	else
		sfx.set_node_type(instrument, target_id, node_type)
	end
end


-- Node configuration ------------------------------------------------------------


function sfx.delete_node(instrument, node_id)
	local inst_addr = 0x40000 + instrument * 0x200
	-- move everything up
	for j = node_id, 7 do
		memcpy(inst_addr + j * 0x20, inst_addr + (j + 1) * 0x20, 0x20)
	end
	memset(inst_addr + 7 * 0x20, 0, 0x20)
end


function sfx.insert_node(instrument, node_id, parent_id)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node_id * 0x20
	-- move everything down
	for j = 7, node_id + 1, -1 do
		memcpy(inst_addr + j * 0x20, inst_addr + ( j - 1) * 0x20, 0x20)
	end
	memset(node_addr, 0, 0x20)
	poke(node_addr, parent_id)
end


function sfx.node_parent(instrument, node)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr + 0) & 0x7	
end

function sfx.node_op(instrument, node)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr) >> 4
end

function sfx.set_node_op(instrument, node, op)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	local previous = peek(node_addr)
	poke(node_addr, (previous & 0x0f) | (op << 4))
end

function sfx.node_type(instrument, node)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr + 1) & 0xf
end

function sfx.set_node_type(instrument, node, type)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	local previous = peek(node_addr + 1)
	poke(node_addr + 1, (previous & 0xf0) | (type & 0x0f))
end

function sfx.node_osc_wavetable(instrument, node)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr + 1) >> 4
end

function sfx.set_node_osc_wavetable(instrument, node, wt)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	local previous = peek(node_addr + 1)
	poke(node_addr + 1, (previous & 0x0f) | (wt << 4))
end

function sfx.node_flags(instrument, node)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr + 2)
end

function sfx.set_node_flags(instrument, node, flags)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 2, flags)
end

-- node_addr + 3 is unused

-- 0 <= p <= 7
function sfx.node_param(instrument, node, p)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	local flags,val1,val0,env = peek(node_addr + 4 + (4 * p), 4)
	return flags, val1, val0, env
end

function sfx.set_node_param_flags(instrument, node, p, flags)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 4 + (4 * p), flags)
end

function sfx.set_node_param_val1(instrument, node, p, val1)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 4 + (4 * p) + 1, val1)
end

function sfx.set_node_param_val0(instrument, node, p, val0)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 4 + (4 * p) + 2, val0)
end

function sfx.set_node_param_env(instrument, node, p, env)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 4 + (4 * p) + 3, env)
end

-- Envelopes -------------------------------------------------------------------

function sfx.env_type(instrument, env)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr)
end

function sfx.set_env_type(instrument, env, type)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr, type)
end

function sfx.env_flags(instrument, env)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 1)
end

function sfx.set_env_flags(instrument, env, flags)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 1, flags)
end

function sfx.env_speed(instrument, env)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 2)
end

function sfx.set_env_speed(instrument, env, val)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 2, val)
end

function sfx.env_loop0(instrument, env)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 3)
end

function sfx.set_env_loop0(instrument, env, val)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 3, val)
end

function sfx.env_loop1(instrument, env)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 4)
end

function sfx.set_env_loop1(instrument, env, val)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 4, val)
end

function sfx.env_start(instrument, env)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 5)
end

function sfx.set_env_start(instrument, env, val)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 5, val)
end

function sfx.env_param(instrument, env, param)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 8 + param)
end

function sfx.set_env_param(instrument, env, param, val)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 8 + param, val)
end

return sfx
:: src/synth.lua
--[[pod_format="raw",created="2024-04-12 16:30:23",modified="2024-04-16 15:09:34",revision=3996]]
local app = require "src/app"
local envelopes = require "src/envelopes"
local sfx = require "src/sfx"


local synth = {}


-- Node panels --------------------------------------------------------------------


function synth.attach_node_panel(parent, el)
	local type = sfx.node_type(app.instrument, el.node_id)
	if el.node_id == 0 then return synth.attach_root(parent, el)
	elseif type == 0 then return synth.attach_unused(parent, el)
	elseif type == 2 then
		local op = sfx.node_op(app.instrument, el.node_id)
		if op == 0 then return synth.attach_osc(parent, el)
		elseif op == 1 then return synth.attach_fm(parent, el)
		elseif op == 2 then return synth.attach_ring(parent, el)
		end
	elseif type == 8 then return synth.attach_filt(parent, el)
	elseif type == 9 then return synth.attach_echo(parent, el)
	elseif type == 10 then return synth.attach_shap(parent, el)
	end
	return synth.attach_unknown(parent, el)
end


function synth.attach_root(parent, el)
	el.width = app.synth_width
	el.height = app.synth_height
	parent:attach(el)
	synth.attach_knob(el, { label = "vol", param = 0, node_id = el.node_id } )
	synth.attach_knob(el, { label = "pan", param = 1, node_id = el.node_id } )
	synth.attach_knob(el, { label = "tune", param = 2, node_id = el.node_id } )
	synth.attach_knob(el, { label = "bend", param = 3, node_id = el.node_id } )
	--- synth.attach_knob(el, { label = "p0", param = 4, node_id = el.node_id } )
	--- synth.attach_knob(el, { label = "p1", param = 5, node_id = el.node_id } )
	function el:draw()
		rectfill(0, 0, self.width, 9, 7)
		rectfill(0, 9, self.width, self.height, 6)
		synth.draw_corners(self)
		print("synthesizer", 4, 2, 22)
	end
	function el:click()
		app.node = self.node_id
		return true
	end
	return el
end

function synth.attach_unused(parent, el)
	el.width = app.synth_width
	el.height = app.synth_height
	parent:attach(el)
	function el:draw()
		rectfill(0, 0, self.width, self.height, 62)
		synth.draw_corners(self)
		local x, y = 19, 14
		pal(7, 61)
		sspr(63, 0, 0, 7, 7, x, y, x + (7 * 4), y + (7 * 4))
		pal(7, 7)
		if self.node_id == 7 then
			print("pfx6416", 52, 63, 5)
		end
	end
	return el
end

function synth.attach_osc(parent, el)
	el.width = app.synth_width
	el.height = app.synth_height
	parent:attach(el)
	synth.attach_mute_toggle(el, { label = "osc", node_id = el.node_id })
	synth.attach_close_button(el, { node_id = el.node_id })
	synth.attach_knob(el, { label = "vol", param = 0, node_id = el.node_id } )
	synth.attach_knob(el, { label = "pan", param = 1, node_id = el.node_id } )
	synth.attach_knob(el, { label = "tune", param = 2, node_id = el.node_id } )
	synth.attach_knob(el, { label = "bend", param = 3, node_id = el.node_id } )
	synth.attach_knob(el, { label = "wave", param = 4, node_id = el.node_id } )
	local wt_labels = { [0] = "wt0", "wt1", "wt2", "wt3" }
	app.attach_menu_button(el, {
		x = 2, y = 11 + 4 * 10, 
		get_label = function()
			local wt = sfx.node_osc_wavetable(app.instrument, el.node_id)
			return wt_labels[wt] or "wt?"
		end,
		fg = 5,
		highlight = 15,
		items = {
			{ label = "wt 0", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 0) end },
			{ label = "wt 1", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 1) end },
			{ label = "wt 2", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 2) end },
			{ label = "wt 3", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 3) end },
		}
	})
	synth.attach_knob(el, { label = "phase", param = 5, node_id = el.node_id } )
	function el:click()
		app.node = self.node_id
		return true
	end
	function el:draw()
		rectfill(0, 0, self.width, 9, 17)
		rectfill(0, 9, self.width, self.height, app.node == self.node_id and 6 or 6)
		synth.draw_corners(self)
	end
	return el
end

function synth.attach_fm(parent, el)
	el.width = app.synth_width
	el.height = app.synth_height
	parent:attach(el)
	synth.attach_mute_toggle(el, { label = "fm", node_id = el.node_id })
	synth.attach_close_button(el, { node_id = el.node_id })
	synth.attach_knob(el, { label = "vol", param = 0, node_id = el.node_id } )
	synth.attach_knob(el, { label = "pan", param = 1, node_id = el.node_id } )
	synth.attach_knob(el, { label = "tune", param = 2, node_id = el.node_id } )
	synth.attach_knob(el, { label = "bend", param = 3, node_id = el.node_id } )
	synth.attach_knob(el, { label = "wave", param = 4, node_id = el.node_id } )
	synth.attach_knob(el, { label = "phase", param = 5, node_id = el.node_id } )
	function el:click()
		app.node = self.node_id
		return true
	end
	function el:draw()
		rectfill(0, 0, self.width, 9, 27)
		rectfill(0, 9, self.width, self.height, 6)
		synth.draw_corners(self)
	end
	return el
end

function synth.attach_ring(parent, el)
	el.width = app.synth_width
	el.height = app.synth_height
	parent:attach(el)
	synth.attach_mute_toggle(el, { label = "ring", node_id = el.node_id })
	synth.attach_close_button(el, { node_id = el.node_id })
	synth.attach_knob(el, { label = "vol", param = 0, node_id = el.node_id } )
	synth.attach_knob(el, { label = "pan", param = 1, node_id = el.node_id } )
	synth.attach_knob(el, { label = "tune", param = 2, node_id = el.node_id } )
	synth.attach_knob(el, { label = "bend", param = 3, node_id = el.node_id } )
	synth.attach_knob(el, { label = "wave", param = 4, node_id = el.node_id } )
	synth.attach_knob(el, { label = "phase", param = 5, node_id = el.node_id } )
	function el:click()
		app.node = self.node_id
		return true
	end
	function el:draw()
		rectfill(0, 0, self.width, 9, 22)
		rectfill(0, 9, self.width, self.height, 6)
		synth.draw_corners(self)
	end
	return el
end

function synth.attach_filt(parent, el)
	el.width = app.synth_width
	el.height = app.synth_height
	parent:attach(el)
	synth.attach_mute_toggle(el, { label = "filt", node_id = el.node_id })
	synth.attach_close_button(el, { node_id = el.node_id })
	synth.attach_knob(el, { label = "low", param = 0, node_id = el.node_id } )
	synth.attach_knob(el, { label = "high", param = 1, node_id = el.node_id } )
	synth.attach_knob(el, { label = "res", param = 2, node_id = el.node_id } )
	function el:click()
		app.node = self.node_id
		return true
	end
	function el:draw()
		rectfill(0, 0, self.width, 9, 14)
		rectfill(0, 9, self.width, self.height, 6)
		synth.draw_corners(self)
	end
	return el
end

function synth.attach_echo(parent, el)
	el.width = app.synth_width
	el.height = app.synth_height
	parent:attach(el)
	synth.attach_mute_toggle(el, { label = "echo", node_id = el.node_id })
	synth.attach_close_button(el, { node_id = el.node_id })
	synth.attach_knob(el, { label = "delay", param = 0, node_id = el.node_id } )
	synth.attach_knob(el, { label = "vol", param = 1, node_id = el.node_id } )
	function el:click()
		app.node = self.node_id
		return true
	end
	function el:draw()
		rectfill(0, 0, self.width, 9, 31)
		rectfill(0, 9, self.width, self.height, 6)
		synth.draw_corners(self)
	end
	return el
end

function synth.attach_shap(parent, el)
	el.width = app.synth_width
	el.height = app.synth_height
	parent:attach(el)
	synth.attach_mute_toggle(el, { label = "shap", node_id = el.node_id })
	synth.attach_close_button(el, { node_id = el.node_id })
	synth.attach_knob(el, { label = "gain", param = 0, node_id = el.node_id } )
	synth.attach_knob(el, { label = "elbow", param = 1, node_id = el.node_id } )
	synth.attach_knob(el, { label = "cut", param = 2, node_id = el.node_id } )
	synth.attach_knob(el, { label = "mix", param = 3, node_id = el.node_id } )
	function el:click()
		app.node = self.node_id
		return true
	end
	function el:draw()
		rectfill(0, 0, self.width, 9, 9)
		rectfill(0, 9, self.width, self.height, 6)
		synth.draw_corners(self)
	end
	return el
end

function synth.attach_unknown(parent, el)
	el.width = app.synth_width
	el.height = app.synth_height
	parent:attach(el)
	synth.attach_mute_toggle(el, { label = "???", node_id = el.node_id })
	synth.attach_close_button(el, { node_id = el.node_id })
	synth.attach_knob(el, { label = "p0", param = 0, node_id = el.node_id } )
	synth.attach_knob(el, { label = "p1", param = 1, node_id = el.node_id } )
	synth.attach_knob(el, { label = "p2", param = 2, node_id = el.node_id } )
	synth.attach_knob(el, { label = "p3", param = 3, node_id = el.node_id } )
	synth.attach_knob(el, { label = "p4", param = 4, node_id = el.node_id } )
	synth.attach_knob(el, { label = "p5", param = 5, node_id = el.node_id } )
	function el:draw()
		rectfill(0, 0, self.width, self.height, 30)
		rectfill(0, 9, self.width, self.height, 6)
		synth.draw_corners(self)
	end
	return el
end
	
function synth.draw_corners(el)
	local col = app.editor_bg
	if app.node and app.node == el.node_id then 
		clip()
		rect(-1, -1, el.width, el.height, 24)
		pset(-1, -1, app.editor_bg)
		pset(el.width, -1, app.editor_bg)
		pset(-1, el.height, app.editor_bg)
		pset(el.width, el.height, app.editor_bg)
		col = 24
	end
	pset(0, 0, col)
	pset(el.width - 1, 0, col)
	pset(0, el.height - 1, col)
	pset(el.width - 1, el.height - 1, col)
end


-- The slider --------------------------------------------------------------------


function synth.attach_knob(parent, el)
	el.x = 0
	el.y = 12 + 10 * el.param
	el.width = parent.width
	el.height = 10
	parent:attach(el)
	el.dragged = nil

	local node_type = sfx.node_type(app.instrument, el.node_id)

	if (not el.min_val) el.min_val = -128	
	if (not el.max_val) el.max_val = 127

	if (el.label == "vol") el.min_val, el.max_val = 0, 64
	-- This is disabled in sfx.p64
	--if (el.label == "tune") el.min_val, el.max_val = -120, 120 -- el.ac = 20 el.a0 = 0.5
	if (el.label == "wave") el.min_val, el.max_val = 0, 255
	
	-- fx parameters are all 0..255 (flag 0x8 is not set)
	if (node_type >= 8) el.min_val, el.max_val = 0, 255
		
	-- gain mix; can use *8 if want to over mix!
	if (el.label == "mix") el.min_val, el.max_val = 0, 64


	function el:draw()
		local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
		local node_type = sfx.node_type(app.instrument, self.node_id)
		if el.label == "tune" and flags & 0x3 == 2 then
			self.min_val = 0
			self.max_val = 255
		end
		if self.max_val < 128 then -- signed int8's
			if (val1 >= 128) val1 -= 256
			if (val0 >= 128) val0 -= 256
		end
		-- Label
		if self.label != "wave" then
			print(self.label, 24 - (4 * #self.label), 1, 5)
		end
		-- Relationship to parent
		if node_type < 8 then	-- (only oscillators have relationships)
			if flags & 0x3 > 0 then
				local letter = "\-h\|f?"
				if (flags & 0x3 == 0x1) letter = "\-d\^:2070200000000000" -- +
				if (flags & 0x3 == 0x2) letter = "\-d\^:5020500000000000" -- *
				print(letter, 26, 2, 59)
			else
				print("\-d\^:0020000000000000", 26, 2, 22) -- .
			end
		end
		-- Slider
		local range = self.max_val - self.min_val
		rectfill(32, 0, 32 + 31, 6, 59)
		local x_zero = mid(0, ((- self.min_val) * 31) \ range, 31)
		local x0 = mid(0, ((val0 - self.min_val) * 31) \ range, 31)
		local x1 = mid(0, ((val1 - self.min_val) * 31) \ range, 31)
		-- Ensure that small values are visible
		if self.min_val < 0 then
			if (val1 > 0 and x1 == 15) x1 = 16
			if (val1 < 0 and x1 == 15) x1 = 14
		else
			if (val1 > 0 and x1 == 0) x1 = 1
		end
		if val0 != val1 and x0 == x1 then
			if (val0 < val1) x0 = max(0, x1 - 1)
			if (val0 > val1) x0 = min(x1 + 1, 31)
		end
		rectfill(32 + x_zero, 0, 32 + x1, 6, 2)
		-- Notches for val1 and val0
		if (flags & 0x4) > 0 or (flags & 0x10) > 0 or self.show_val0 then
			line(32 + x0, 3, 32 + x1, 3, (self.dragged and self.show_val0) and 22 or 22)
			line(32 + x0, 2, 32 + x0, 4, (self.dragged and self.show_val0) and 7 or 22)
		end
		line(32 + x1, 0, 32 + x1, 6, (self.dragged and self.show_val1) and 7 or 15)
		-- Numerical value
		local str = ""
		local col = 0
		if self.show_val0 then
			if el.label == "tune" and flags & 0x3 == 2 then
				local num0 = 1 + val0 % 16
				local den0 = 1 + val0 \ 16
				str = num0 .. "/" .. den0
			else
				str = tostr(val0)
			end
			col = 29
		elseif self.show_val1 or key("shift") then
			if el.label == "tune" and flags & 0x3 == 2 then
				local num1 = 1 + val1 % 16
				local den1 = 1 + val1 \ 16
				str = num1 .. "/" .. den1
			else
				str = tostr(val1)
			end
			col = self.dragged and 7 or 6
		end
		local x = 63 - 4 * #str
		if x1 > 16 then
			x = 32 + 2
		end
		print(str, x, 1, col)
		-- Multiplier
		if (env & 0xc0 > 0) then
			str2 = (env & 0x20 == 0) and 
				"\^:5020500000000000" or  -- *
				"\^:4020100000000000"     -- /
			if (env & 0xc0 == 0x40) str2 = str2 .. "\-c\^:5070400000000000" -- 4
			if (env & 0xc0 == 0x80) str2 = "\-e" .. str2 .. "\^:1372770000000000" -- 16
			if (env & 0xc0 == 0xc0) str2 = "\-e" .. str2 .. "\^:5177470000000000" -- 64
			print(str2, 62, 2, 24)
		else
			print("\^:0020000000000000", 62, 2, 22) -- .
		end
		-- Modulator assignment
		local mx = 78
		if flags & 0x4 > 0 then
			rectfill(mx - 1, 0, mx + 3, 6, 59)
			rectfill(mx - 2, 1, mx + 4, 5, 59)
			if flags & 0x8 > 0 then
				-- continuation
				print(env & 0xf, mx, 0, 29)
				print("\^:1500000000000000", mx - 1, 6, 29) -- 3 dots
			else
				print(env & 0xf, mx, 1, 29)
			end
		elseif flags & 0x10 > 0 then
			rectfill(mx - 1, 0, mx + 3, 6, 59)
			rectfill(mx - 2, 1, mx + 4, 5, 59)
			print("r", mx, 1, 14)
		else
			rectfill(mx, 1, mx + 2, 5, 59)
			rectfill(mx - 1, 2, mx + 3, 4, 59)
		end
	end
	
	function el:hover(msg)
		if msg.mx <= 24 then
			-- on label
			self.cursor = 1
		elseif msg.mx <= 32 then
			-- on relationship
			self.cursor = "pointer"
		elseif msg.mx <= 64 then
			-- on slider
			self.cursor = get_spr(50)
		elseif msg.mx <= 72 then
			-- on multiplier
			self.cursor = "pointer"
		else
			-- on modulator
			self.cursor = "pointer"
		end
	end
	
	function el:click(msg)
		app.node = self.node_id
		if 32 <= msg.mx and msg.mx <= 64 then
			local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
			self.dragged = true
			self.show_val1 = msg.mb == 1
			self.show_val0 = msg.mb != 1
			self.cursor = 0 -- TODO: capture mouse
		elseif msg.mx <= 24 and msg.mb == 2 then
			self.show_val0 = true
		end
		return true -- don't pass to parent to avoid selection
	end
	
	function el:tap(msg)
		local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
		local node_type = sfx.node_type(app.instrument, self.node_id)
		if msg.mx <= 24 then
			-- Tap on label
			
		elseif msg.mx <= 32 then
			-- Tap on relationship symbol -----------------
			if node_type == 0x2 and self.label == "tune" then
				app.open_menu {
					x = self.sx + 20, y = self.sy + 7,
					items = {
						{
							label = "set",
							action = function()
								self.min_val, self.max_val = -128, 127
								local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
								-- set bit: replace parent
								sfx.set_node_param_flags(app.instrument, self.node_id, self.param, flags & ~0x3)
							 end,
						},
						{
							label = "add",
							action = function()
								self.min_val, self.max_val = -128, 127
								local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
								-- set bit: add parent
								sfx.set_node_param_flags(app.instrument, self.node_id, self.param, flags | 0x1)
							 end,
						},
						{
							label = "mult",
							action = function()
								self.min_val, self.max_val = 0, 255
								local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
								-- set bit: mul parent
								sfx.set_node_param_flags(app.instrument, self.node_id, self.param, (flags & ~0x3) | 0x2)
							 end,
						},
					}
				}
			elseif self.label == "vol" or self.label == "mix" then
				app.open_menu {
					x = self.sx + 20, y = self.sy + 7,
					items = {
						{
							label = "set",
							action = function()
								local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
								-- set bit: replace parent
								sfx.set_node_param_flags(app.instrument, self.node_id, self.param, flags & ~0x3)
							 end,
						},
						{
							label = "mult",
							action = function()
								local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
								-- set bit: mul parent
								sfx.set_node_param_flags(app.instrument, self.node_id, self.param, (flags & ~0x3) | 0x2)
							 end,
						},
					}
				}
			else
				app.open_menu {
					x = self.sx + 20, y = self.sy + 7,
					items = {
						{
							label = "set",
							action = function()
								local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
								-- set bit: replace parent
								sfx.set_node_param_flags(app.instrument, self.node_id, self.param, flags & ~0x3)
							 end,
						},
						{
							label = "add",
							action = function()
								local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
								-- set bit: add parent
								sfx.set_node_param_flags(app.instrument, self.node_id, self.param, flags | 0x1)
							 end,
						},
					}
				}
			end
									
		elseif msg.mx <= 64 then
			-- Tap on slider ----------------------------
		
		elseif msg.mx <= 72 then
			-- Tap on multiplier ----------------------------------
			local mult_options = { 
				[0] = 
				{ label = "none", val = 0x00 | 0x00 },
				{ label = "x4", val = 0x00 | 0x40 },
				{ label = "/4", val = 0x20 | 0x40 },
				{ label = "x16", val = 0x00 | 0x80 },
				{ label = "/16", val = 0x20 | 0x80 },
				{ label = "x64", val = 0x00 | 0xc0 },
				{ label = "/64", val = 0x20 | 0xc0 },
			}
			local mult_menu_items = {}
			for i = 0, #mult_options do
				add(mult_menu_items, 
					{
						label = mult_options[i].label,
						fg = i == 0 and 6 or 24,
						action = function()
							local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
							sfx.set_node_param_env(app.instrument, self.node_id, self.param, (env & ~0xe0) | mult_options[i].val)
						 end,
					}
				)
			end

			app.open_menu {
				x = self.sx + 56, y = self.sy + 7,
				items = mult_menu_items,
			}

		else
			-- Tap on modulator -------------------------------
			app.open_menu {
				x = self.sx + 60, y = self.sy + 7,
				items = {
					{
						label = "none",
						fg = 6,
						action = function()
							local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
							sfx.set_node_param_flags(app.instrument, self.node_id, self.param, flags & ~(0x4 | 0x8 | 0x10))
						 end,
					},
					{
						label = envelopes.make_label(0),
						fg = 18,
						action = function()
							local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
							sfx.set_node_param_flags(app.instrument, self.node_id, self.param, (flags & ~0x10) | 0x4)
							sfx.set_node_param_env(app.instrument, self.node_id, self.param, (env & 0xf0) | 0)
						 end,
					},
					{
						label = envelopes.make_label(1),
						fg = 18,
						action = function()
							local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
							sfx.set_node_param_flags(app.instrument, self.node_id, self.param, (flags & ~0x10) | 0x4)
							sfx.set_node_param_env(app.instrument, self.node_id, self.param, (env & 0xf0) | 1)						 end,
					},
					{
						label = envelopes.make_label(2),
						fg = 18,
						action = function()
							local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
							sfx.set_node_param_flags(app.instrument, self.node_id, self.param, (flags & ~0x10) | 0x4)
							sfx.set_node_param_env(app.instrument, self.node_id, self.param, (env & 0xf0) | 2)						 end,
					},
					{
						label = envelopes.make_label(3),
						fg = 18,
						action = function()
							local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
							sfx.set_node_param_flags(app.instrument, self.node_id, self.param, (flags & ~0x10) | 0x4)
							sfx.set_node_param_env(app.instrument, self.node_id, self.param, (env & 0xf0) | 3)						 end,
					},
					{
						label = "random",
						fg = 30,
						action = function()
							local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
							sfx.set_node_param_flags(app.instrument, self.node_id, self.param, (flags & ~0x4) | 0x10)
						 end,
					},
					{
						divider = true,
					},
					{
						label = "free run",
						fg = 5,
						action = function()
							local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
							sfx.set_node_param_flags(app.instrument, self.node_id, self.param, flags ^^ 0x08)
						 end,
					},
				}
			}
		end
	end

	function el:doubleclick(msg)
		if 32 <= msg.mx and msg.mx <= 64 then
			local init = 0
			if (self.label == "vol") init = 32
			if msg.mb == 1 then
				sfx.set_node_param_val1(app.instrument, self.node_id, self.param, init)
			else
				sfx.set_node_param_val0(app.instrument, self.node_id, self.param, 0)
			end
			self.dragged = nil
		end
	end
	
	function el:drag(msg)
		if self.dragged then
			local flags, val1, val0, _env = sfx.node_param(app.instrument, self.node_id, self.param)
			-- Handle signed i8s
			if (el.max_val < 128) then
				if (val0 >= 128) val0 -= 256
				if (val1 >= 128) val1 -= 256
			end
			local sensitivity = key("shift") and 0.1 or 0.5
			if self.label == "vol" then
				sensitivity = key("shift") and 0.025 or 0.125
			end
			local _, delta = mouselock(true, sensitivity, 0)
			if msg.mb == 1 then
				local new = val1 - delta
				new = mid(self.min_val, new, self.max_val)
				sfx.set_node_param_val1(app.instrument, self.node_id, self.param, new)
			else
				local new = val0 - delta
				new = mid(self.min_val, new, self.max_val)
				sfx.set_node_param_val0(app.instrument, self.node_id, self.param, new)
			end
		end
	end
	
	function el:release(msg)
		mouselock(false)
		self.dragged = nil
		self.show_val0 = false
		self.show_val1 = false
	end
	
	function el:update()
		---[[ show values on hover?
		if (app.has_modal()) return
		local mx, my, mb = mouse()
		if mb == 0 then
			if self.sx <= mx and mx < self.sx + self.width
				and self.sy <= my and my < self.sy + self.height
			then
				self.show_val1 = true
			else
				self.show_val1 = false
			end
		end
		--]]
	end
	return el
end


-- Other widgets -------------------------------------------------------------------


function synth.attach_mute_toggle(parent, el)
	el.x = 1
	el.y = 1
	el.width = 3 + 4 * #(el.label .. " " .. el.node_id) + 3
	el.height = 9
	el.cursor = "pointer"
	parent:attach(el)
	el.muted = (sfx.node_flags(app.instrument, el.node_id) & 0x2) > 0
	function el:draw()
		local label = self.label .. " " .. self.node_id
		print(label, 3, 1, 63)
		if self.muted then
			line(1, 3, 3 + 4 * #label, 3, 24)
		end
	end
	function el:click()
		return true -- don't pass to panel to avoid selection
	end
	function el:tap()
		self.muted = not self.muted
		local flags = sfx.node_flags(app.instrument, self.node_id)
		if self.muted then
			flags |= 0x2
		else
			flags &= ~0x2
		end
		sfx.set_node_flags(app.instrument, self.node_id, flags)
	end
	return el
end




function synth.attach_close_button(parent, el)
	el.x = 75
	el.y = 2
	el.width = 12
	el.height = 9
	el.cursor = "pointer"
	parent:attach(el)
	function el:draw()
		pal(7, 60)
		spr(36, 0, 0)
		pal(7, 7)
	end
	function el:click()
		return true -- don't pass to panel to avoid selection
	end
	function el:tap()
		if app.node and app.node >= self.node_id then
			app.node = nil
		end
		sfx.delete_node(app.instrument, self.node_id)
		app.refresh_gui = true
	end
	return el
end

return synth
:: src/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTA3IDA4OjE0OjAwIixtb2RpZmllZD0iMjAyNC0w
NC0xNiAxNTowOTozNCIsc3RvcmVkPSIyMDI0LTA0LTA3IDA4OjE0OjAwIl1dbHo0AAQAAAADAAAA
MG5pbA==
:: drak.lua
--[[pod_format="raw",created="2024-04-07 07:42:45",modified="2024-04-13 06:43:38",revision=982]]

-- A 'require' function similar to standard Lua.
-- Idea from elgopher on the BBS
function require(name)
	if (_modules == nil) _modules = {}

	local cached = _modules[name]
	if (cached) return cached

	local filename = fullpath(name .. '.lua')
	local src = fetch(filename) 

	if (type(src) != "string") panic("could not include " .. filename)

	-- https://www.lua.org/manual/5.4/manual.html#pdf-load
	-- chunk name (for error reporting)
	-- mode ("t" for text only -- no binary chunk loading)
	-- _ENV upvalue
	-- @ is a special character that tells debugger the string is a filename
	local func, err = load(src, "@" .. filename, "t", _ENV)
	if (not func) panic("Syntax error:", tostr(err))

	local module = func()
	_modules[name] = module

	return module
end


function panic(...)
	local args = { ... }
	foreach(
		args,
		function(str)
			send_message(3, { event = "report_error", content = str })
		end
	)
	stop()
end


-- Table utility functions --------------------------------------------------------


function tostrrec(t)
	if type(t) != "table" then
		return tostr(t)
	end
	
	local s = nil
	for k, v in pairs(t) do
		if not(s) then
			s = "{ "
		else
			s ..= ", "
		end
		s ..= tostr(k) .. " = " .. tostrrec(v)
	end
	s ..= " }"

	return s
end


-- Char utilities -----------------------------------------------------------------


function keyp_num()
	if (keyp("9")) return 9
	if (keyp("8")) return 8
	if (keyp("7")) return 7
	if (keyp("6")) return 6
	if (keyp("5")) return 5
	if (keyp("4")) return 4
	if (keyp("3")) return 3
	if (keyp("2")) return 2
	if (keyp("1")) return 1
	if (keyp("0")) return 0
	return nil
end


function keyp_hex()
	if (keyp("f")) return 0xf
	if (keyp("e")) return 0xe
	if (keyp("d")) return 0xd
	if (keyp("c")) return 0xc
	if (keyp("b")) return 0xb
	if (keyp("a")) return 0xa
	if (keyp("9")) return 0x9
	if (keyp("8")) return 0x8
	if (keyp("7")) return 0x7
	if (keyp("6")) return 0x6
	if (keyp("5")) return 0x5
	if (keyp("4")) return 0x4
	if (keyp("3")) return 0x3
	if (keyp("2")) return 0x2
	if (keyp("1")) return 0x1
	if (keyp("0")) return 0x0
	return nil
end

function is_num_char(c)
	if (not c) return
	return ("0" <= c) and (c <= "9")
end


function is_hexa_char(c)
	if (not c) return
	local is_num = ("0" <= c) and (c <= "9")
	local is_hex_alpha = ("a" <= c) and (c <= "f")
	return is_num or is_hex_alpha
end


function p8_centered_print(s, x, y, col)
	local count = #s
	print(s, x - ((count * 4) \ 2), y, col)
end



-- Drawing -------------------------------------------------------------------------


-- From Sophie on the discord
function get_drawspace()
    return {
        cam_x=peek4(0x5510),
        cam_y=peek4(0x5514),
        clip_l=peek2(0x5528),
        clip_t=peek2(0x552a),
        clip_r=peek2(0x552c),
        clip_b=peek2(0x552e),
    }
end


function set_drawspace(drawspace)
    poke4(0x5510,drawspace.cam_x)
    poke4(0x5514,drawspace.cam_y)
    poke2(0x5528,drawspace.clip_l)
    poke2(0x552a,drawspace.clip_t)
    poke2(0x552c,drawspace.clip_r)
    poke2(0x552e,drawspace.clip_b)
end

:: label.png
b64$iVBORw0KGgoAAAANSUhEUgAAAeAAAAEOCAIAAADe_FMwAAAV60lEQVR4Ae2dX2gkx53He9oN
pweBQXDdDws67tbyQ8MsCCwYLRZkCJwZMMZ-sohhHCyjXUEwVkCIcCw_79gx_5AIBcsYg2SxAnsY
hBc7mIBIXsYgI0EmIFiBHrLRQRYEHgUEC-uweTB7D3X09nWPWt3V-7s-Hxqpuqe_9avfr6q_9Vp5
8vAHBQAAsoeWcLzvn72e2Vq8_PBz0fjis499Sn7_i1_yhwAgJipPHv5gf3d7U4QeFNSdhWP6VAXq
7DGIf3fGowHciBMkzoW97dHZ0d--sfLZ37_tnXf8L5zPF599-PNf-FL89e_HwrU80PyUIFAyURnW
iw8-F25rNfx0BoCMuLNofPHZx4Fsy6cjB7Uae_fzXDgMQd3Zp0c7DdqRhojqJ_eYOG-21ne3Lwdy
dgCASC4MiftDeJSHRzsN2gogRve_aob_GqFrnzd7h-OKDuJvfI7sfVcBQIRO5-9UZmHyjmlEaBRO
g7Y70YXJx12d89zWcm3RQbxanR2-RrgAeDRAHO5mP1b_T5nVzb8RXThyMo5vtyZhVgEMWuTgKJn-
bJPM0O7L9oQ9fpW_3nFngNwR9Mye1z9CWwtkSk6DDmRDsXrx989eF3eLlY-deSVSTXilAUqIMJAv
PvtYmIM4Nd5G4ThZsR40n5Zl7_ZnPoHm7PYxDypPHv6Q2OIl6adyvPjw86D7I9ZbCgDKjEoJAACy
SeX9iTeoAgBABlEpAQAABg0AAAHQip3eh_1XvDu83-6WTQAA2aTy-sQbpXXnODx6a2zAroJiMHdm
UIR00cqT6pOXX6r84Y_RD-vc-PN-2-wrOwmKTch9vjU2uNDurT7uzltjg3LeH--PoL-88UA03nxm
UrTffGbS-pP13f7TedqhbeuvXfvBXz4VjVsvvOOnnR2Pfm7__fN__vuf7orGv-3nz_xtd8_PXpsR
jfe_2RXt977ZHTqmu_d5naV7Wn_jHfO8KiWQ0YU9xU9Be3qvkdyYPnteuEZyY6br0UMtOEIiMZDk
Ue0vwjct97TsVViq-VeHww7VOn7yxl41qy0a7r9hePLySwm4s9uOh1qzhXU8Ljwn9p7enSV6Xoi9
p-ewEmMGmmckPR0-_ewZKLT-MaMt5oXD_h8z0J6-0KPTcudbL7wjHuHUIpGQ6QyP9fq1D16-FtVo
ms9_wqn9WK3V3_ostO7vQ_83RzsOnrz8UuUPf4zbnePmo9dm4ugctKefc_6-Z7oZsUZ_ej43--zf
Nv8q7chbY4O5M_O8PnE7taIot154Z_j3D9uvBBpnfG3D-moldevrryI0aNVPpzefmfRvzZbE8mW7
1v7dUTWrcOdVMCrCu7OiKP73aHy8982uT9fz3y3ynpFbc0wZsUYx7fy5M8PuyA53dnwRnd194uC5
_edTP8LBDFpYp9tAv-zx4MsfD4J6dDaJxJ197tS--_nu0Labj16bsTesV4_eou2np3c373CRjBl5
9KjGdFT7wmK6--oZ009PP0vpJynpMX1WLKg7e3ixn_9x8MFfPhWJhMwlIb96f_KNAtjuUD5sv2J-
ffLyS0Pd_f32tyHvYftKb40NilpPKBt233Tsc59sjQ3EIFbDT_ehP4W0deHLiqLceuGdkEldEOj1
a-8X6OuvMOgABn0eIQ3az04CyLtBQyoU2aD9eHS07gwAgEEDABQflRIAAGSTSqNai3C4Zqve7fTK
Uz7dNE6PBuRLvsWA85s1VO4oAIASGXSzVW_26v6-F_Ae1k3jvO9DfyLfYuRr-S0S4py6j2qxz697
HbOwn7U4Bu12ekMX8rzveef0aDB0FU_PBoU8wORbbLqdnrDj8pzfofs2C-s5FoMG6wYmZfLNHYV0
YYlFzMLiYtBJXM6lyrc8Hi0Wt5D5djs9zmkWzq8a3w1s3cOORvHuZ3FErYNqP7G6aRTvAJ_XbyGT
9V7fotJs1ctzfh1bN1Pnt9Ko1qJd11LdvbpppH7Hki-5cn6Lur5a0Hwi6VOwNSZf8iVf8k3foBVF
2ente-z600nz_vaPclN5Q-9z7la3UZ-2LkjBIN9i89NJk-XNFGqpbksAgByhxTTuiw8-t9rfP3s9
sXwG9_9ZbWPiirQ8qDZk3LTyjSR0SWolnW8e1zfFfQV2VPFPNw3xONrNVl08EkN--_x18Qiz-u5X
r4on7pSMiSviEZvs3bnb4vGzKd1a669EXP-aaPNNIG7ktfK5RjndG7lb3xTXCOxoVuv0aCBM2dHu
dnpyBu3mJ7-5faDzH1WSn2zdTKCUYh_LnS3nd-mKGy3_1yine6MA65vMGqEdbtAJ8N2vXvVp09G6
hrj2-Wwv6zA4tH6w5mxVXEIrQVpxw9QqzBrlem-kaH3TWiO0dtTE3Pknv-m9H2uOnE_2bvq-_Y2J
K_KR0IaJm1a_YShbrSLMNxfrm5G4JUezWrppDG03W3W5oV98_LlofP-sdUVRvvvVq8mkNLh-z341
iWs-_biJkVbcAqxRYnELsK9yUaviUWlUa-5766ax09v36LCyNP-v-3UoN5U39D-nrnyN_rR3QQoG
_RablaX55dVN1jc7aJGPmEefBQAohUELTn-3W_8Ob337tdWO8BILEzctLXVmzkVaX4gQNZvTWlma
L9UypJVvHuvMnIsdF60dzf4y9fiSu0d-5CT5BV5e3SyVQaeVbx7rzJyLHRetnUqjWrMb9NbYwP7z
3JlhN2jdNHZ6_963Qam8tVGf9i4I_ZJvjuD8Zg3N-enB4g3RGF-bKM9SAQDkwKAjYfD2mqIoxp3F
hPMJEzctLXVmzsSFoagxjZvW0oaJm5aWOjNn4sJQNPen8bUN6gIAkDmDnjszKAoAQBaoNKo1-711
09jp7Xt0WFmaX17dVBRl8Paa_GLcWZSYljVOUMLEldA26tOiIHnMVyJuJPnmqFZlW9-Uz2-CWmt9
MztnLSbjl1tXC_lsw8RNS5tWvnmsM3Mudly0DtSYDBoAAEKCQQMAYNAAAIBBAwBg0AAAkEODXlma
R4sWLVq00tpKo1rzP5ZuGju9fe9gy6ub5bnfGvVp74KQL-nmCM5v1lDLsxgAAPlCCyoYHR0N2aFg
kC-5ki-5xoTKHQUAkE20guVzfLBntS9PXk0ldJJx08qXuOxnSM6gddMQjdOjgb3dbNUVRel2ejlK
ydpPxwd7lyevvv2zm_L1zt3bse7mVOKmlS9xix03xf0MdlSrdXo0cLfDWLP98k9S6_DO3dv_txRx
iUvcdOOitaMlcPMnrHVjXf6xxnUU2n-QaPMtW9zE1rdsdU5rP6NNyKCzw527twNtr5CFtnb2nbu3
08q3bHETWN_y1Tk7_7nMPDVo3TTc7WarLv52O728pGTtJ7HDUjm6AhE67m3tyLdscRNb37LVOa39
DHYqjWrNf2-dNHb7hx4d2guz7fXt8pRvZqrqXRDyJd8cwfnNGip3FABANtEKls---PqWd4e3vv3a
akd4eRKXuMSFyFHjG7q9MJuKNq05E5e4xE337BdPq9lfph5fcvfoj5xIBl7flp90CG2ojUVc4hI3
1bhozzVoRVG2xgb217kzI5UFluY--vsD7w67xCUucbMaFy4waEVRHizeEI3xtQ0KBACQIYPONcfX
biuKcvmrm8QlLnFzFxccqAXLJ60tRVziEhciR3N-Gl-boC4AAJkz6Lkzg6IAAGQB1f7SHzlxP9JD
txdmk9ceX7tt-SUucYmbr7hoHVQa1Zr-sXTT2O0fegdrr2_X536bmap6F4R8yTdHcH6zhlqexQAA
yBcYNAAABg0AABg0AAAGDQAAOTTo9sIsWrRo0aKV1lYa1Zr-sXTT2O0fegdrr2_X536bmap6F4R8
yTdHcH6zhlqexQAAyBdaUMGjR49CdigY5Eu_5Eu_MaFyRwEAZBMtpnEH9_9ZbWPiSi60dnnCcVPB
Pueg005xjSJJOS97I4-7CiJEFf900xCPo91s1cUjMbQxcUU8YpO9O3fb_ptN7eD_PbdWPHHPOS2s
OYvDn-01CunO0usb_d4o9r6CqNCs1unRQJiyvd3t9IRNl60uwrA_2bqZzGEQ5z8VrZVsXgiTrwO5
9Q2-N8qwr9BGon1q0EOJ1prD7MgktXbbSiZuGMeJVpv9NQqTr1jZfO2NYuwrtHJa9UJ9t9Prdnrh
3fmTrZufbN3MhdZeslTmnBY5WiPpwyAe6fWNZG_UbV_BNJrV0k1jaLvZqgubDjr04P496eslFa0x
ccXSCt6du53MnNPCnm-Qaae1vhHif32j3RuF31cQFZVGtea-t24aO719jw4rS-PLq5vlKV_jPu1d
EPIl3xzB_c0aKncUAEA20WIa9-R3v-Xu8Na3X1ttxyVWNm1alK1W7CvIHSolyAIrS-OpaMtWK-YV
2nxpNfvL1ONL7h79kRM2etwsr26moi1brdhXaPOlrTSqNbtBb40N7D-PnRl2g9ZNY6e3730blOr8
NOrT3gUhX-LNEZzfrKG5Pz1YvCEa42sb5VkqAIAcGHQkDN5eUxTFuLOINrOUrVbsK8gdakzjhtlS
ZdOmRdlqxb6C3KG5P42vbVAXAIDMGfTcmUFRAACyQKVRrfnvrZvGTm-fo8PK0vzy6qaiKIO318QX
485i0DnlSNuoT4uChIlrr1uS2rTyTatWecw34VrZ_6eyJxPWWuub2TlrMRm-3H4qp1ZRFOnVDaMt
W63YV2hzp1VjMmgAAAgJBg0AgEEDAAAGDQCAQQMAQA4NemVpHi1atGjRSmsrjWrN-1i6aez09r2D
La9ulud_a9SnvQtCvuSbIzi-WUMtz2IAAOQLLahgdHQ0ZIeCQb7kS77kGxMqdxQAAAYNAADBDVo3
DfE42s1WXTxUCgAgHYNWFOX0aOBudzu9bqcnN-TxwZ70tNCiRYsW7VODPo9mqy4X_PLkVelJo0WL
Fi3aiw262_lJxwYAAGk0q6WbhrvdbNWpEQBAmgZ9ejSwPtnb3U6PGgEApIJKCQAAMGgAAMiGQbcX
ZtGiRYsWrbS20qjWrJepx5fcPfojJ1ZbN43d-qF3sPb6dnnut5mpqndByJd8cwTnN2tojvetsYH9
de7MKM9qAQBk2qAVRXmweEM0xtc2KBAAQFqolAAAAIMGAIAAaO5P42sb1AUAIHMGPXdmUBQAgCyg
2l-6IyfuR3ro9sIsWrRo0aKV1lYa1Zr-sXTT2O0fegdrr2_X536bmap6F4R8yTdHcH6zhlqexQAA
yBcYNAAABg0AABg0AAAGDQAAOTTo9sIsWrRo0aKV1lYa1Zr-sXTT2O0fegdrr2_X536bmap6F4R8
yTdHcH6zhlqexQAAyBdaUMGjR49CdigY5Eu_5Eu_MaFyRwEAYNAAUFL_5V9nKIK8QeumIR5Hu9mq
W38BAOTc_cHep3i0vEErinJ6NBjalmZw-x5atGjRCnx6NLUabtDn0WzV5QIbE1ekJ40WLdriaf14
NLUKYNDdTq-b6UnHBgAI6tFgoVkt3TSGtgEAImH86juKovzzH7uUIphBnx4NrE-2tqDb6VEpAJDj
n--YFdb8YO9T0YBgBg0AEKtHK4piTFyhFIFQKQEAQOkMemVpHi1atGjRSmsrjWrNepl6fMndoz9y
YrV109jp7XsHW17dLM-91qhPexeEfMk3R3B_s4bmeN8aG9hf586M8qwWAECmDVpRlAeLN0RjfG2D
AgEApIVKCQAAMGgAAAiA5v40vrZBXQAAMmfQc2cGRQEAyAKq-aU-cuJ_pIdeWZpHixYtWrTS2kqj
WvM-lm4aO71972DLq5vlud8a9WnvgpAv_eYIzm-WUMuzGAAA_QKDBgDAoAEAAIMGAMCgAQAghwa9
sjSPFi1atGiltZVGteZ-LN00dnr73sGWVzfLc7816tPeBSFf8s0RnN_soZZnMQAA8oUWVDA6Ohqy
Q8EgX-IlX-KNCZU7CgAAgwYAgOAGrZuGeBztZqsuHioFAJCOQSuKcno0GNrudnrdTk9i6OODPelp
oUWLFi3apwZ9Hs1WvdmqSwS_PHlVetJo0aJFi1bzFnc7PeHR0uEBAECOpwatm4a7jTUDAKRs0KdH
A_uTvd3t9KgRAEAqqJQAAACDBgCAbBh0e2EWLVq0aNFKayuNas16mXp8yd2jP3JitXXT2O0fegdr
r2_X536bmap6F4R8yTdHcH6zhuZ43xob2F-nzozyrBYAQKYNWlGUB4s3RGN8bYMCAQCkhUoJAAAw
aAAACIDm-jS_tkFdAAAyZ9BzZwZFAQDIAqr9pT9y4n6kh24vzKJFixYtWmltpVGt_R9LN43d-qF3
sPb6dnnut5mpqndByJd8cwTnN2uo5VkMAIB8gUEDAGDQAACAQQMAYNAAAJBDg24vzKJFixYtWmlt
pVGt_R9LN43d-qF3sPb6dnnut5mpqndByJd8cwTnN2uo5VkMAIB8oQUVPHr0KGSHgkG_5Eu_5BsT
KncUAAAGDQAAwQ1aNw3xONrNVp0aAQCkadCKopweDYa2pRncv4cWLVq0aKW1Tw36PJqterNVlwhs
TFyRnjRatGjRor3YoLudnnRsAACQ5qlB66YxtN1s1SkTAEDyaOLf6dHA_mRvdzs9agQAkAoqJQAA
wKABACAbBr2yNI8WLVq0aKW1lUa1Zr1MPb7k7tEfObHaumns9Pa9gy2vbpbnfmvUp70LQr7kmyM4
v1lDc7xvjQ3sr3NnRnlWCwAg0watKMqDxRuiMb62QYEAANJCpQQAABg0AAAEQHN-Gl-boC4AAJkz
6Lkzg6IAAGQB1f7SHzlxP9JDryzNo0WLFi1aaW2lUa35H0s3jZ3evnew5dXN8txvjfq0d0HIl3xz
BOc3a6jlWQwAgHyBQQMAYNAAAIBBAwBg0AAAkEODXlmaR4sWLVq00tpKo1rzP5ZuGju9fe9gy6ub
5bnfGvVp74KQL-nmCM5v1lDLsxgAAPlCCyoYHR0N2aFgkC-5ki-5xoTKHQUAgEEDAEBwg9ZNQzyO
drNVFw_VAgBIx6AVRTk9Grjb3U6v2_nJDX18sCc9LbRo0aJF_9SgI_fy5FW0aNGiRSutjdGgAQAg
DE8NWjeNoW0AAEgFTfw7PRpYn_xtQbfTo1IAAAmjUgIAAAwaAACyYdDthVm0aNGiRSutrTSqNetl
6vEld4-_yInV1k1jt3-oHay9vl2e_21mqupdEPIl3xzB_c0amuN9a2xgf507M8qzWgAAmTZoRVEe
LN4QjfG1DQoEAJAWKiUAAMCgAQAgAJr70-jaBnUBAMicQc_dGRQFACALqPaX-siJ_5Eeur0wixYt
WrRopbWVRrXmfyzdNHb7h97B2uvb5bnfZqaq3gUhX-LNEZzfrKGWZzEAAPKFRgkAAJLk_GBPNC5P
XnW0rb-io0qxAACS5PLkVcuCHW1HT41iAQAkzPHBnqNhvdptWqVSAAAJY3fhy5NXxavDneM16PbC
LFq0aNGidXB8sHd8sOfxarUrjWrN-7i6aez2D70n2l7fLs81ODNV9S4I_ZJvjuD8Zg21PIsBAAAA
AAAAAMXlfwEsAA7jlHGMXgAAABB0RVh0TG9kZVBORwAyMDExMDIyMeNZtsEAAAAASUVORK5CYII=
:: main.lua
--[[pod_format="raw",created="2024-03-24 00:48:06",modified="2024-04-16 15:09:34",revision=6037]]
include "drak.lua"
local app = require "src/app"
local settings = require "src/settings"
local sfx = require "src/sfx"
local file = require "src/file"
local detail = require "src/detail"
local ed_inst = require "src/ed_inst"
local ed_trak = require "src/ed_trak"
local ed_patt = require "src/ed_patt"
local note_grid = require "src/note_grid"
local synth = require "src/synth" -- TODO: temporary, remove


function _init()
	window {
		tabbed = true,
		icon = --[[pod_type="gfx"]]unpod("b64:bHo0AB4AAAAcAAAA8A1weHUAQyAICAQwB2AXUAcAB0AHAAcgJzA3QBew")
	}

	wrangle_working_file(
		file.save,
		file.load,
		file.default_filename
	)
	
	on_event("drop_items", file.handle_drop_items)
	
	poke(0x4000, get(fetch("/system/fonts/p8.font")))
	
	poke4(0x5000, get(fetch("pal/0.pal")))
end


function _update()
	if keyp(settings.keys.play) then
		sfx.play_or_pause()
	end
	if app.refresh_gui then
		generate_gui()
		app.refresh_gui = false
	end
	app.gui:update_all()
end


function _draw()
	cls()
	app.gui:draw_all()
	print(string.format("\014% 3.0f", (stat(1) * 100.0)) .. "%", 464, 253, 7)
end


function generate_gui()
	local cell_width = 14
	local cell_height = 29
	app.gui = create_gui()
	local top_panel = attach_top_panel(app.gui, { x = 0, y = 0 })
	if app.view == "patt" then
		ed_patt.attach_pattern_selector(top_panel, { x = 98, y = 0})
		ed_patt.attach_channel_panel(app.gui, { x = 0, y = 16})
		note_grid.attach(app.gui, { x = app.channels_width, y = 16 })
	elseif app.view == "trak" then
		ed_trak.attach(app.gui, { x = 0, y = 16 })
	elseif app.view == "inst" then
		ed_inst.attach(app.gui, { x = 0, y = 16 })
	end
	if app.detail then
		detail.attach_panel(app.gui, { x = 480 - app.detail_width, y = 16})
	end
end


function attach_top_panel(parent, el)
	el.width = 480
	el.height = 16
	parent:attach(el)

	attach_view_selector(el, { x = 22, y = 0 })
	attach_play_button(el, { x = 1, y = 0 })
	attach_detail_button(el, { x = 480 - 16, y = 0})
	attach_note_attributes(el, { x = 380, y = 0})
		
	function el:draw()
		rectfill(0, 0, el.width, el.height, 2)
	end	

	return el
end


function attach_play_button(parent, el)
	el.width = 16
	el.height = 16
	el.cursor = "pointer"
	parent:attach(el)

	function el:draw()
		spr(stat(464) == 0 and 4 or 5, 0, 0)
	end
	
	function el:click()
		sfx.play_or_pause()
	end
	
	return el
end


function attach_view_selector(parent, el)
	el.width = 3 * 20
	el.height = 16
	el.cursor = "pointer"
	parent:attach(el)
	
	function el:draw()
		--[[
		if app.view == "inst" then pal(7, 17) else pal(7, 59) end
		spr(3, 0, 0)
		if app.view == "trak" then pal(7, 17) else pal(7, 59) end
		spr(2, 16 + 4, 0)
		if app.view == "patt" then pal(7, 17) else pal(7, 59) end
		spr(1, 2 * 16 + 2 * 4, 0)
		pal(7, 7)
		--]]
		print("inst", 2, 6, app.view == "inst" and 7 or 62)
		print("trak", 2 + 20, 6, app.view == "trak" and 7 or 62)
		print("patt", 2 + 40 + 1, 6, app.view == "patt" and 7 or 62)
	end
	
	function el:click(msg)
		if msg.mx < 20 then
			app.view = "inst"
		elseif msg.mx < 2 * 20 then
			app.view = "trak"
		else
			app.view = "patt"
		end
		app.refresh_gui = true
	end
	
	return el
end

-- Default note attributes -------------------------------------------------------


function attach_note_attributes(parent, el)
	el.width = 78
	el.height = 16
	--- el.cursor = "pointer"
	el.cursor = get_spr(50)
	parent:attach(el)
	
	el.drag_start = nil

	function el:draw()
		---rectfill(0, 0, self.width, self.height, 0)
		local note = app.base_note % 12
		local octave = app.base_note \ 12
		local is_sharp = (note == 1) or (note == 3) or (note == 6)
			or (note == 8) or (note == 10)
		pal(7, self.dragged_note and 7 or 7)
		if is_sharp then
			spr(8 + note, 2, 6)
		else
			spr(8 + note, 8, 6)
		end
		pal(7, 7)
		print(
			"\014" .. string.format("%1x", octave),
			2 + 12, 7,
			self.dragged_note and 7 or 22
		)
		local x = 20
		rectfill(x, 8, x + 20, 10, 59)
		rectfill(
			x, 8,
			x + min(20 * (app.base_volume / 64), 20), 10,
			self.dragged_volume and 7 or 17
		)
		if self.dragged_volume then
			print("\014" .. string.format("%2d", app.base_volume), 27, 2, 7)
		end
		print(
			"\014inst " .. string.format("%d", app.base_instrument),
			44, 7,
			self.dragged_instrument and 7 or 14 -- col 26
		)
	end	
	
	function el:click(msg)
		-- TODO: replace with pull-down menus
		if msg.mx < 18 then
			self.dragged_note = true
		elseif msg.mx < 42 then
			self.dragged_volume = true
		else
			self.dragged_instrument = true
		end
		self.cursor = 0
	end
	
	function el:drag(msg)
		if self.dragged_note then
			local _, delta = mouselock(true, key("shift") and 0.025 or 0.125, 0)
			app.base_note = mid(0, app.base_note - (12 * delta), 120)
		elseif self.dragged_volume then
			local _, delta = mouselock(true, key("shift") and 0.025 or 0.125, 0)
			app.base_volume = mid(0, app.base_volume - delta, 0x40) -- TODO: handle vol > 64
		elseif self.dragged_instrument then
			local _, delta = mouselock(true, key("shift") and 0.025 or 0.125, 0)
			app.base_instrument = mid(0, app.base_instrument - delta, 0xfe)
			-- TODO: temporary, remove
			app.instrument = app.base_instrument
			app.node = 0
		end
	end
	
	function el:release(msg)
		mouselock(false)
		self.cursor = get_spr(50)
		self.dragged_note = nil
		self.dragged_volume = nil
		if self.dragged_instrument and app.view == "inst" then
			app.refresh_gui = true
		end
		self.dragged_instrument = nil
	end

	function el:doubleclick(msg)
		if msg.mx < 18 then
			app.base_note = 48
		elseif msg.mx < 42 then
			app.base_volume = 0x32
		else
			app.base_instrument = 01
		end
	end
	
	return el
end


function attach_detail_button(parent, el)
	el.width = 16
	el.height = 16
	el.cursor = "pointer"
	parent:attach(el)
	
	function el:draw()
		pal(7, app.detail and 7 or 62)
		spr(45, 1, 3)
		pal(7, 7)		
	end	
	
	function el:tap()
		app.detail = not app.detail
		app.refresh_gui = true
	end
	
	return el
end

:: manual.txt
--[[pod_format="raw",created="2024-04-14 09:49:39",modified="2024-04-14 09:49:39",revision=0]]

:: todo.txt
--[[pod_format="raw",created="2024-04-10 20:46:30",modified="2024-04-10 20:46:41",revision=1]]
- add 4/4 config

:: .info.pod
b64$LS1bW3BvZCxhdXRob3I9ImRyYWttYW5pc28iLGNyZWF0ZWQ9IjIwMjQtMDQtMTYgMTM6MzU6
MTMiLGljb249dXNlcmRhdGEoInU4IiwxNiwxNiwiMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEw
MDAwMDAwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDcwNzAxMDAwMDAwMDEwNzBkMGQwZDBkMGQwZDBk
MGQwZDBkMDcwMTAwMDEwNzBkMGQwZDBkMGQwZDA3MGQwZDBkMGQwZDA3MDEwMTA3MGQwZDBkMGQw
ZDBkMDcwNzBkMGQwZDBkMDcwMTAxMDcwZDBkMGQwZDBkMGQwNzBkMDcwZDBkMGQwNzAxMDEwNzBk
MGQwZDBkMGQwZDA3MGQwNzBkMGQwZDA3MDEwMTA3MGQwZDBkMGQwNzA3MDcwZDBkMGQwZDBkMDcw
MTAxMDcwZDBkMGQwNzA3MDcwNzBkMGQwZDBkMGQwNzAxMDEwNzBkMGQwZDBkMDcwNzBkMGQwZDBk
MGQwZDA3MDEwMTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwMTAxMDYwNzBkMGQwZDBkMGQw
ZDBkMGQwZDBkMDcwNjAxMDEwNjA2MDcwNzA3MDcwNzA3MDcwNzA3MDcwNjA2MDEwMDAxMDYwNjA2
MDYwNjA2MDYwNjA2MDYwNjA2MDEwMDAwMDAwMTA2MDYwNjA2MDYwNjA2MDYwNjA2MDEwMDAwMDAw
MDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAiKSxtb2RpZmllZD0iMjAyNC0wNC0xNiAxNTow
OTozNCIsbm90ZXM9Ik11c2ljIFRyYWNrZXIiLHJ1bnRpbWU9NixzdG9yZWQ9IjIwMjQtMDQtMTYg
MTE6Mzc6NTEiLHRpdGxlPSJWaXNpVHJhY2siLHZlcnNpb249IjAuMC4yIix3b3Jrc3BhY2VzPXt7
bG9jYXRpb249Im1haW4ubHVhIzE5OSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ic3Jj
L2VkX2luc3QubHVhIzUwIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJzcmMvc3ludGgu
bHVhIzY0NCIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ic3JjL3NmeC5sdWEjNDEwIix3
b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJzcmMvYXBwLmx1YSMyMjAiLHdvcmtzcGFjZV9p
bmRleD0xfSx7bG9jYXRpb249InNyYy9lbnZlbG9wZXMubHVhIzI0NCIsd29ya3NwYWNlX2luZGV4
PTF9LHtsb2NhdGlvbj0ic3JjL2VkX3BhdHQubHVhIzcwIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xv
Y2F0aW9uPSJnZngvMC5nZngiLHdvcmtzcGFjZV9pbmRleD0yfSx7bG9jYXRpb249Im1hcC8wLm1h
cCIsd29ya3NwYWNlX2luZGV4PTN9LHtsb2NhdGlvbj0ic2Z4LzAuc2Z4Iix3b3Jrc3BhY2VfaW5k
ZXg9NH0se2xvY2F0aW9uPSJzZngvMS5zZngiLHdvcmtzcGFjZV9pbmRleD03fX1dXWx6NAAEAAAA
AwAAADBuaWw=
:: [eoc]
