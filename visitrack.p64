picotron cartridge // www.picotron.net
version 2

:: gfx/
:: map/
:: sfx/
:: src/
:: pal/
:: drak.lua
--[[pod_format="raw",created="2024-04-07 07:42:45",modified="2024-04-13 06:43:38",revision=982]]

-- A 'require' function similar to standard Lua.
-- Idea from elgopher on the BBS
function require(name)
	if (_modules == nil) _modules = {}

	local cached = _modules[name]
	if (cached) return cached

	local filename = fullpath(name .. '.lua')
	local src = fetch(filename) 

	if (type(src) != "string") panic("could not include " .. filename)

	-- https://www.lua.org/manual/5.4/manual.html#pdf-load
	-- chunk name (for error reporting)
	-- mode ("t" for text only -- no binary chunk loading)
	-- _ENV upvalue
	-- @ is a special character that tells debugger the string is a filename
	local func, err = load(src, "@" .. filename, "t", _ENV)
	if (not func) panic("Syntax error:", tostr(err))

	local module = func()
	_modules[name] = module

	return module
end


function panic(...)
	local args = { ... }
	foreach(
		args,
		function(str)
			send_message(3, { event = "report_error", content = str })
		end
	)
	stop()
end


-- Table utility functions --------------------------------------------------------


function tostrrec(t)
	if type(t) != "table" then
		return tostr(t)
	end
	
	local s = nil
	for k, v in pairs(t) do
		if not(s) then
			s = "{ "
		else
			s ..= ", "
		end
		s ..= tostr(k) .. " = " .. tostrrec(v)
	end
	s ..= " }"

	return s
end


-- Char utilities -----------------------------------------------------------------


function keyp_num()
	if (keyp("9")) return 9
	if (keyp("8")) return 8
	if (keyp("7")) return 7
	if (keyp("6")) return 6
	if (keyp("5")) return 5
	if (keyp("4")) return 4
	if (keyp("3")) return 3
	if (keyp("2")) return 2
	if (keyp("1")) return 1
	if (keyp("0")) return 0
	return nil
end


function keyp_hex()
	if (keyp("f")) return 0xf
	if (keyp("e")) return 0xe
	if (keyp("d")) return 0xd
	if (keyp("c")) return 0xc
	if (keyp("b")) return 0xb
	if (keyp("a")) return 0xa
	if (keyp("9")) return 0x9
	if (keyp("8")) return 0x8
	if (keyp("7")) return 0x7
	if (keyp("6")) return 0x6
	if (keyp("5")) return 0x5
	if (keyp("4")) return 0x4
	if (keyp("3")) return 0x3
	if (keyp("2")) return 0x2
	if (keyp("1")) return 0x1
	if (keyp("0")) return 0x0
	return nil
end

function is_num_char(c)
	if (not c) return
	return ("0" <= c) and (c <= "9")
end


function is_hexa_char(c)
	if (not c) return
	local is_num = ("0" <= c) and (c <= "9")
	local is_hex_alpha = ("a" <= c) and (c <= "f")
	return is_num or is_hex_alpha
end


function p8_centered_print(s, x, y, col)
	local count = #s
	print(s, x - ((count * 4) \ 2), y, col)
end



-- Drawing -------------------------------------------------------------------------


-- From Sophie on the discord
function get_drawspace()
    return {
        cam_x=peek4(0x5510),
        cam_y=peek4(0x5514),
        clip_l=peek2(0x5528),
        clip_t=peek2(0x552a),
        clip_r=peek2(0x552c),
        clip_b=peek2(0x552e),
    }
end


function set_drawspace(drawspace)
    poke4(0x5510,drawspace.cam_x)
    poke4(0x5514,drawspace.cam_y)
    poke2(0x5528,drawspace.clip_l)
    poke2(0x552a,drawspace.clip_t)
    poke2(0x552c,drawspace.clip_r)
    poke2(0x552e,drawspace.clip_b)
end

:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2Iixtb2RpZmllZD0iMjAyNC0w
NC0xNCAxMzoxNjozMCIscmV2aXNpb249NDQzOF1dbHo0AFQEAADFNQAA8yV7WzBdPXtibXA9cHh1
AEMgCAgEMAdgF1AHAAdABwAHICcwN0AXsCxmbGFncz0wLHBhbl94CADHeT0wLHpvb209OH0sQgDx
DyIIBPATBzAHAPcDAAcQByAHIAdgB9AHAAcwBxAHAAQAYAAHIBcAFwQAEUAYAAAaAAFuAAAOACMX
ICQAQBAHICcUAABEABMwOgARECQAIBAXGAAv8BOXAAsZMZcA9QIQEATwKyeQV2BXEAdgJ0AHYAIA
-wFAJ2AHMDdAJ0AXQDfAF-AbVgALHTlWAPYHJBfABxAHsAcQB6AHMAeQBzAHgBcABwIAE4AWABOg
JgBPwBfwFGQAHfIGIq8RMM4gTgduIE4XXiBOJ04gTjc_CAAhF14YAF-OMK7wE1cAHp2uMM4gziA_
Rz4EAB-OUgAjH-AxAErgCwYEACdgByAHUAeQB5BaAi8nYEAACx43QAARIJYBUSAHAFdQCgAiQFdy
Ah8QTAAeEjeLAAcEAB83QwAeBo4AAoYACQwAD08AHmBHUAeQJ3AdAS9HUDsAIEAHkDdgBgAPOwAd
ExBJAQFRASM3EFkBH5CbAR4E2wEgEBdOAT9gN1DdAS4kEBdNAT8QN1CQACRFIAdQR_IBD5IAKAPV
ARVHCgAOUAAPcwIULzdgcQIjDnEDDzEAn58THQT-GJvw-201AByP8Jv-GE-w-w43AB1v_v8YdfCI
NgAdX-_A-xiIOQEeDzEArIIHBwRyTzsSTgIAH3I7AAsvMTE8AAFyDi8RDhIOLQQAD0MAHDAMBgQ_
CBFAWwNREAcQFxBnAwQIABMwGAAQQGIID1kADB4wWQD-CghwBwAIYBcACAdgFwgAB3AIBwAHYAgQ
F1BLABpTBQUEByD8AwQIAA9eCQwPlAEdLzEzMgBe8AQJCQTAB3AXYCcgZxAHECcgBxAX1AkfwD0C
GQFEAEAQBzAX_AmfEAcQZyAnYBdwRAAeN5BnEAIAH5C-Ahz-ATAPFkAeMC4gPjAuQB5QDhA-ABz-
ARAPFlAeQC4wPiAuMB5ADjA-ABn-BwoMBNAH8AIXgAeAB3An8ApHUCdwB0BCACh-DAdwJ1BHIEIA
DA-6AR4K0ALxGRcXBPD5AfAFAQcB8AQBFwHwAwEnAQAB8AABNwEHAeABFxEnAeARBxEfABIHHwAg
8AMKAE8FAfAM_gIZCmoABEsAEAIFALABAUcB8AAhByHwAhkAH1VXAB0TblcAAlIAVREHEfADZgBF
BCHwBA0AEAMcAAFzAATDAB9ubAAZkBkZBPD-KgHwBz0AcAYBBxEAARArAQAQAAAjAfAD0BFHAScB
sAEHAUcRBxHAAVcRQwFgN0HwADEAQgEQBX8AMwQBJ68APwcBMH4ADA-dAR8PMgD-7-8DBwcEVwBn
MAcANwA3AAcwZwBXPwAMHzZxAB8PMgD---------------------------------------------
----XVA9MTB9fQ==
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2IixzdG9yZWQ9IjIwMjQtMDMt
MjQgMDA6NDg6MDYiXV1sejQABAAAAAMAAAAwbmls
:: label.png
b64$iVBORw0KGgoAAAANSUhEUgAAAeAAAAEOCAIAAADe_FMwAAAV60lEQVR4Ae2dX2gkx53He9oN
pweBQXDdDws67tbyQ8MsCCwYLRZkCJwZMMZ-sohhHCyjXUEwVkCIcCw_79gx_5AIBcsYg2SxAnsY
hBc7mIBIXsYgI0EmIFiBHrLRQRYEHgUEC-uweTB7D3X09nWPWt3V-7s-Hxqpuqe_9avfr6q_9Vp5
8vAHBQAAsoeWcLzvn72e2Vq8_PBz0fjis499Sn7_i1_yhwAgJipPHv5gf3d7U4QeFNSdhWP6VAXq
7DGIf3fGowHciBMkzoW97dHZ0d--sfLZ37_tnXf8L5zPF599-PNf-FL89e_HwrU80PyUIFAyURnW
iw8-F25rNfx0BoCMuLNofPHZx4Fsy6cjB7Uae_fzXDgMQd3Zp0c7DdqRhojqJ_eYOG-21ne3Lwdy
dgCASC4MiftDeJSHRzsN2gogRve_aob_GqFrnzd7h-OKDuJvfI7sfVcBQIRO5-9UZmHyjmlEaBRO
g7Y70YXJx12d89zWcm3RQbxanR2-RrgAeDRAHO5mP1b_T5nVzb8RXThyMo5vtyZhVgEMWuTgKJn-
bJPM0O7L9oQ9fpW_3nFngNwR9Mye1z9CWwtkSk6DDmRDsXrx989eF3eLlY-deSVSTXilAUqIMJAv
PvtYmIM4Nd5G4ThZsR40n5Zl7_ZnPoHm7PYxDypPHv6Q2OIl6adyvPjw86D7I9ZbCgDKjEoJAACy
SeX9iTeoAgBABlEpAQAABg0AAAHQip3eh_1XvDu83-6WTQAA2aTy-sQbpXXnODx6a2zAroJiMHdm
UIR00cqT6pOXX6r84Y_RD-vc-PN-2-wrOwmKTch9vjU2uNDurT7uzltjg3LeH--PoL-88UA03nxm
UrTffGbS-pP13f7TedqhbeuvXfvBXz4VjVsvvOOnnR2Pfm7__fN__vuf7orGv-3nz_xtd8_PXpsR
jfe_2RXt977ZHTqmu_d5naV7Wn_jHfO8KiWQ0YU9xU9Be3qvkdyYPnteuEZyY6br0UMtOEIiMZDk
Ue0vwjct97TsVViq-VeHww7VOn7yxl41qy0a7r9hePLySwm4s9uOh1qzhXU8Ljwn9p7enSV6Xoi9
p-ewEmMGmmckPR0-_ewZKLT-MaMt5oXD_h8z0J6-0KPTcudbL7wjHuHUIpGQ6QyP9fq1D16-FtVo
ms9_wqn9WK3V3_ostO7vQ_83RzsOnrz8UuUPf4zbnePmo9dm4ugctKefc_6-Z7oZsUZ_ej43--zf
Nv8q7chbY4O5M_O8PnE7taIot154Z_j3D9uvBBpnfG3D-moldevrryI0aNVPpzefmfRvzZbE8mW7
1v7dUTWrcOdVMCrCu7OiKP73aHy8982uT9fz3y3ynpFbc0wZsUYx7fy5M8PuyA53dnwRnd194uC5
_edTP8LBDFpYp9tAv-zx4MsfD4J6dDaJxJ197tS--_nu0Labj16bsTesV4_eou2np3c373CRjBl5
9KjGdFT7wmK6--oZ009PP0vpJynpMX1WLKg7e3ixn_9x8MFfPhWJhMwlIb96f_KNAtjuUD5sv2J-
ffLyS0Pd_f32tyHvYftKb40NilpPKBt233Tsc59sjQ3EIFbDT_ehP4W0deHLiqLceuGdkEldEOj1
a-8X6OuvMOgABn0eIQ3az04CyLtBQyoU2aD9eHS07gwAgEEDABQflRIAAGSTSqNai3C4Zqve7fTK
Uz7dNE6PBuRLvsWA85s1VO4oAIASGXSzVW_26v6-F_Ae1k3jvO9DfyLfYuRr-S0S4py6j2qxz697
HbOwn7U4Bu12ekMX8rzveef0aDB0FU_PBoU8wORbbLqdnrDj8pzfofs2C-s5FoMG6wYmZfLNHYV0
YYlFzMLiYtBJXM6lyrc8Hi0Wt5D5djs9zmkWzq8a3w1s3cOORvHuZ3FErYNqP7G6aRTvAJ_XbyGT
9V7fotJs1ctzfh1bN1Pnt9Ko1qJd11LdvbpppH7Hki-5cn6Lur5a0Hwi6VOwNSZf8iVf8k3foBVF
2ente-z600nz_vaPclN5Q-9z7la3UZ-2LkjBIN9i89NJk-XNFGqpbksAgByhxTTuiw8-t9rfP3s9
sXwG9_9ZbWPiirQ8qDZk3LTyjSR0SWolnW8e1zfFfQV2VPFPNw3xONrNVl08EkN--_x18Qiz-u5X
r4on7pSMiSviEZvs3bnb4vGzKd1a669EXP-aaPNNIG7ktfK5RjndG7lb3xTXCOxoVuv0aCBM2dHu
dnpyBu3mJ7-5faDzH1WSn2zdTKCUYh_LnS3nd-mKGy3_1yine6MA65vMGqEdbtAJ8N2vXvVp09G6
hrj2-Wwv6zA4tH6w5mxVXEIrQVpxw9QqzBrlem-kaH3TWiO0dtTE3Pknv-m9H2uOnE_2bvq-_Y2J
K_KR0IaJm1a_YShbrSLMNxfrm5G4JUezWrppDG03W3W5oV98_LlofP-sdUVRvvvVq8mkNLh-z341
iWs-_biJkVbcAqxRYnELsK9yUaviUWlUa-5766ax09v36LCyNP-v-3UoN5U39D-nrnyN_rR3QQoG
_RablaX55dVN1jc7aJGPmEefBQAohUELTn-3W_8Ob337tdWO8BILEzctLXVmzkVaX4gQNZvTWlma
L9UypJVvHuvMnIsdF60dzf4y9fiSu0d-5CT5BV5e3SyVQaeVbx7rzJyLHRetnUqjWrMb9NbYwP7z
3JlhN2jdNHZ6_963Qam8tVGf9i4I_ZJvjuD8Zg3N-enB4g3RGF-bKM9SAQDkwKAjYfD2mqIoxp3F
hPMJEzctLXVmzsSFoagxjZvW0oaJm5aWOjNn4sJQNPen8bUN6gIAkDmDnjszKAoAQBaoNKo1-711
09jp7Xt0WFmaX17dVBRl8Paa_GLcWZSYljVOUMLEldA26tOiIHnMVyJuJPnmqFZlW9-Uz2-CWmt9
MztnLSbjl1tXC_lsw8RNS5tWvnmsM3Mudly0DtSYDBoAAEKCQQMAYNAAAIBBAwBg0AAAkEODXlma
R4sWLVq00tpKo1rzP5ZuGju9fe9gy6ub5bnfGvVp74KQL-nmCM5v1lDLsxgAAPlCCyoYHR0N2aFg
kC-5ki-5xoTKHQUAkE20guVzfLBntS9PXk0ldJJx08qXuOxnSM6gddMQjdOjgb3dbNUVRel2ejlK
ydpPxwd7lyevvv2zm_L1zt3bse7mVOKmlS9xix03xf0MdlSrdXo0cLfDWLP98k9S6_DO3dv_txRx
iUvcdOOitaMlcPMnrHVjXf6xxnUU2n-QaPMtW9zE1rdsdU5rP6NNyKCzw527twNtr5CFtnb2nbu3
08q3bHETWN_y1Tk7_7nMPDVo3TTc7WarLv52O728pGTtJ7HDUjm6AhE67m3tyLdscRNb37LVOa39
DHYqjWrNf2-dNHb7hx4d2guz7fXt8pRvZqrqXRDyJd8cwfnNGip3FABANtEKls---PqWd4e3vv3a
akd4eRKXuMSFyFHjG7q9MJuKNq05E5e4xE337BdPq9lfph5fcvfoj5xIBl7flp90CG2ojUVc4hI3
1bhozzVoRVG2xgb217kzI5UFluY--vsD7w67xCUucbMaFy4waEVRHizeEI3xtQ0KBACQIYPONcfX
biuKcvmrm8QlLnFzFxccqAXLJ60tRVziEhciR3N-Gl-boC4AAJkz6Lkzg6IAAGQB1f7SHzlxP9JD
txdmk9ceX7tt-SUucYmbr7hoHVQa1Zr-sXTT2O0fegdrr2_X536bmap6F4R8yTdHcH6zhlqexQAA
yBcYNAAABg0AABg0AAAGDQAAOTTo9sIsWrRo0aKV1lYa1Zr-sXTT2O0fegdrr2_X536bmap6F4R8
yTdHcH6zhlqexQAAyBdaUMGjR49CdigY5Eu_5Eu_MaFyRwEAZBMtpnEH9_9ZbWPiSi60dnnCcVPB
Pueg005xjSJJOS97I4-7CiJEFf900xCPo91s1cUjMbQxcUU8YpO9O3fb_ptN7eD_PbdWPHHPOS2s
OYvDn-01CunO0usb_d4o9r6CqNCs1unRQJiyvd3t9IRNl60uwrA_2bqZzGEQ5z8VrZVsXgiTrwO5
9Q2-N8qwr9BGon1q0EOJ1prD7MgktXbbSiZuGMeJVpv9NQqTr1jZfO2NYuwrtHJa9UJ9t9Prdnrh
3fmTrZufbN3MhdZeslTmnBY5WiPpwyAe6fWNZG_UbV_BNJrV0k1jaLvZqgubDjr04P496eslFa0x
ccXSCt6du53MnNPCnm-Qaae1vhHif32j3RuF31cQFZVGtea-t24aO719jw4rS-PLq5vlKV_jPu1d
EPIl3xzB_c0aKncUAEA20WIa9-R3v-Xu8Na3X1ttxyVWNm1alK1W7CvIHSolyAIrS-OpaMtWK-YV
2nxpNfvL1ONL7h79kRM2etwsr26moi1brdhXaPOlrTSqNbtBb40N7D-PnRl2g9ZNY6e3730blOr8
NOrT3gUhX-LNEZzfrKG5Pz1YvCEa42sb5VkqAIAcGHQkDN5eUxTFuLOINrOUrVbsK8gdakzjhtlS
ZdOmRdlqxb6C3KG5P42vbVAXAIDMGfTcmUFRAACyQKVRrfnvrZvGTm-fo8PK0vzy6qaiKIO318QX
485i0DnlSNuoT4uChIlrr1uS2rTyTatWecw34VrZ_6eyJxPWWuub2TlrMRm-3H4qp1ZRFOnVDaMt
W63YV2hzp1VjMmgAAAgJBg0AgEEDAAAGDQCAQQMAQA4NemVpHi1atGjRSmsrjWrN-1i6aez09r2D
La9ulud_a9SnvQtCvuSbIzi-WUMtz2IAAOQLLahgdHQ0ZIeCQb7kS77kGxMqdxQAAAYNAADBDVo3
DfE42s1WXTxUCgAgHYNWFOX0aOBudzu9bqcnN-TxwZ70tNCiRYsW7VODPo9mqy4X_PLkVelJo0WL
Fi3aiw262_lJxwYAAGk0q6WbhrvdbNWpEQBAmgZ9ejSwPtnb3U6PGgEApIJKCQAAMGgAAMiGQbcX
ZtGiRYsWrbS20qjWrJepx5fcPfojJ1ZbN43d-qF3sPb6dnnut5mpqndByJd8cwTnN2tojvetsYH9
de7MKM9qAQBk2qAVRXmweEM0xtc2KBAAQFqolAAAAIMGAIAAaO5P42sb1AUAIHMGPXdmUBQAgCyg
2l-6IyfuR3ro9sIsWrRo0aKV1lYa1Zr-sXTT2O0fegdrr2_X536bmap6F4R8yTdHcH6zhlqexQAA
yBcYNAAABg0AABg0AAAGDQAAOTTo9sIsWrRo0aKV1lYa1Zr-sXTT2O0fegdrr2_X536bmap6F4R8
yTdHcH6zhlqexQAAyBdaUMGjR49CdigY5Eu_5Eu_MaFyRwEAYNAAUFL_5V9nKIK8QeumIR5Hu9mq
W38BAOTc_cHep3i0vEErinJ6NBjalmZw-x5atGjRCnx6NLUabtDn0WzV5QIbE1ekJ40WLdriaf14
NLUKYNDdTq-b6UnHBgAI6tFgoVkt3TSGtgEAImH86juKovzzH7uUIphBnx4NrE-2tqDb6VEpAJDj
n--YFdb8YO9T0YBgBg0AEKtHK4piTFyhFIFQKQEAQOkMemVpHi1atGjRSmsrjWrNepl6fMndoz9y
YrV109jp7XsHW17dLM-91qhPexeEfMk3R3B_s4bmeN8aG9hf586M8qwWAECmDVpRlAeLN0RjfG2D
AgEApIVKCQAAMGgAAAiA5v40vrZBXQAAMmfQc2cGRQEAyAKq-aU-cuJ_pIdeWZpHixYtWrTS2kqj
WvM-lm4aO71972DLq5vlud8a9WnvgpAv_eYIzm-WUMuzGAAA_QKDBgDAoAEAAIMGAMCgAQAghwa9
sjSPFi1atGiltZVGteZ-LN00dnr73sGWVzfLc7816tPeBSFf8s0RnN_soZZnMQAA8oUWVDA6Ohqy
Q8EgX-IlX-KNCZU7CgAAgwYAgOAGrZuGeBztZqsuHioFAJCOQSuKcno0GNrudnrdTk9i6OODPelp
oUWLFi3apwZ9Hs1WvdmqSwS_PHlVetJo0aJFi1bzFnc7PeHR0uEBAECOpwatm4a7jTUDAKRs0KdH
A_uTvd3t9KgRAEAqqJQAAACDBgCAbBh0e2EWLVq0aNFKayuNas16mXp8yd2jP3JitXXT2O0fegdr
r2_X536bmap6F4R8yTdHcH6zhuZ43xob2F-nzozyrBYAQKYNWlGUB4s3RGN8bYMCAQCkhUoJAAAw
aAAACIDm-jS_tkFdAAAyZ9BzZwZFAQDIAqr9pT9y4n6kh24vzKJFixYtWmltpVGt_R9LN43d-qF3
sPb6dnnut5mpqndByJd8cwTnN2uo5VkMAIB8gUEDAGDQAACAQQMAYNAAAJBDg24vzKJFixYtWmlt
pVGt_R9LN43d-qF3sPb6dnnut5mpqndByJd8cwTnN2uo5VkMAIB8oQUVPHr0KGSHgkG_5Eu_5BsT
KncUAAAGDQAAwQ1aNw3xONrNVp0aAQCkadCKopweDYa2pRncv4cWLVq0aKW1Tw36PJqterNVlwhs
TFyRnjRatGjRor3YoLudnnRsAACQ5qlB66YxtN1s1SkTAEDyaOLf6dHA_mRvdzs9agQAkAoqJQAA
wKABACAbBr2yNI8WLVq0aKW1lUa1Zr1MPb7k7tEfObHaumns9Pa9gy2vbpbnfmvUp70LQr7kmyM4
v1lDc7xvjQ3sr3NnRnlWCwAg0watKMqDxRuiMb62QYEAANJCpQQAABg0AAAEQHN-Gl-boC4AAJkz
6Lkzg6IAAGQB1f7SHzlxP9JDryzNo0WLFi1aaW2lUa35H0s3jZ3evnew5dXN8txvjfq0d0HIl3xz
BOc3a6jlWQwAgHyBQQMAYNAAAIBBAwBg0AAAkEODXlmaR4sWLVq00tpKo1rzP5ZuGju9fe9gy6ub
5bnfGvVp74KQL-nmCM5v1lDLsxgAAPlCCyoYHR0N2aFgkC-5ki-5xoTKHQUAgEEDAEBwg9ZNQzyO
drNVFw_VAgBIx6AVRTk9Grjb3U6v2_nJDX18sCc9LbRo0aJF_9SgI_fy5FW0aNGiRSutjdGgAQAg
DE8NWjeNoW0AAEgFTfw7PRpYn_xtQbfTo1IAAAmjUgIAAAwaAACyYdDthVm0aNGiRSutrTSqNetl
6vEld4-_yInV1k1jt3-oHay9vl2e_21mqupdEPIl3xzB_c0amuN9a2xgf507M8qzWgAAmTZoRVEe
LN4QjfG1DQoEAJAWKiUAAMCgAQAgAJr70-jaBnUBAMicQc_dGRQFACALqPaX-siJ_5Eeur0wixYt
WrRopbWVRrXmfyzdNHb7h97B2uvb5bnfZqaq3gUhX-LNEZzfrKGWZzEAAPKFRgkAAJLk_GBPNC5P
XnW0rb-io0qxAACS5PLkVcuCHW1HT41iAQAkzPHBnqNhvdptWqVSAAAJY3fhy5NXxavDneM16PbC
LFq0aNGidXB8sHd8sOfxarUrjWrN-7i6aez2D70n2l7fLs81ODNV9S4I_ZJvjuD8Zg21PIsBAAAA
AAAAAMXlfwEsAA7jlHGMXgAAABB0RVh0TG9kZVBORwAyMDExMDIyMeNZtsEAAAAASUVORK5CYII=
:: main.lua
--[[pod_format="raw",created="2024-03-24 00:48:06",modified="2024-04-14 13:16:30",revision=4948]]
include "drak.lua"
local app = require "src/app"
local settings = require "src/settings"
local sfx = require "src/sfx"
local file = require "src/file"
local detail = require "src/detail"
local ed_inst = require "src/ed_inst"
local ed_trak = require "src/ed_trak"
local ed_patt = require "src/ed_patt"
local note_grid = require "src/note_grid"
local synth = require "src/synth" -- TODO: temporary, remove


function _init()
	window {
		tabbed = true,
		icon = --[[pod_type="gfx"]]unpod("b64:bHo0AB4AAAAcAAAA8A1weHUAQyAICAQwB2AXUAcAB0AHAAcgJzA3QBew")
	}

	wrangle_working_file(
		file.save,
		file.load,
		file.default_filename
	)
	
	on_event("drop_items", file.handle_drop_items)
	
	poke(0x4000, get(fetch("/system/fonts/p8.font")))
	
	poke4(0x5000, get(fetch("pal/0.pal")))
end


function _update()
	if keyp(settings.keys.play) then
		sfx.play_or_pause()
	end
	if app.refresh_gui then
		generate_gui()
		app.refresh_gui = false
	end
	app.gui:update_all()
end


function _draw()
	cls()
	app.gui:draw_all()
	print(string.format("\014% 3.0f", (stat(1) * 100.0)) .. "%", 464, 253, 7)
end


function generate_gui()
	local cell_width = 14
	local cell_height = 29
	app.gui = create_gui()
	local top_panel = attach_top_panel(app.gui, { x = 0, y = 0 })
	if app.view == "patt" then
		ed_patt.attach_pattern_selector(top_panel, { x = 98, y = 0})
		ed_patt.attach_channel_panel(app.gui, { x = 0, y = 16})
		note_grid.attach(app.gui, { x = app.channels_width, y = 16 })
	elseif app.view == "trak" then
		ed_trak.attach(app.gui, { x = 0, y = 16 })
	elseif app.view == "inst" then
		ed_inst.attach(app.gui, { x = 0, y = 16 })
	end
	if app.detail then
		detail.attach_panel(app.gui, { x = 480 - app.detail_width, y = 16})
	end
end


function attach_top_panel(parent, el)
	el.width = 480
	el.height = 16
	parent:attach(el)

	attach_view_selector(el, { x = 22, y = 0 })
	attach_play_button(el, { x = 1, y = 0 })
	attach_detail_button(el, { x = 480 - 16, y = 0})
	attach_note_attributes(el, { x = 380, y = 0})
		
	function el:draw()
		rectfill(0, 0, el.width, el.height, 2)
	end	

	return el
end


function attach_play_button(parent, el)
	el.width = 16
	el.height = 16
	el.cursor = "pointer"
	parent:attach(el)

	function el:draw()
		spr(stat(464) == 0 and 4 or 5, 0, 0)
	end
	
	function el:click()
		sfx.play_or_pause()
	end
	
	return el
end


function attach_view_selector(parent, el)
	el.width = 3 * 20
	el.height = 16
	el.cursor = "pointer"
	parent:attach(el)
	
	function el:draw()
		--[[
		if app.view == "inst" then pal(7, 17) else pal(7, 59) end
		spr(3, 0, 0)
		if app.view == "trak" then pal(7, 17) else pal(7, 59) end
		spr(2, 16 + 4, 0)
		if app.view == "patt" then pal(7, 17) else pal(7, 59) end
		spr(1, 2 * 16 + 2 * 4, 0)
		pal(7, 7)
		--]]
		print("inst", 2, 6, app.view == "inst" and 7 or 62)
		print("trak", 2 + 20, 6, app.view == "trak" and 7 or 62)
		print("patt", 2 + 40 + 1, 6, app.view == "patt" and 7 or 62)
	end
	
	function el:click(msg)
		if msg.mx < 20 then
			app.view = "inst"
		elseif msg.mx < 2 * 20 then
			app.view = "trak"
		else
			app.view = "patt"
		end
		app.refresh_gui = true
	end
	
	return el
end

-- Default note attributes -------------------------------------------------------


function attach_note_attributes(parent, el)
	el.width = 78
	el.height = 16
	--- el.cursor = "pointer"
	el.cursor = get_spr(50)
	parent:attach(el)
	
	el.drag_start = nil

	function el:draw()
		---rectfill(0, 0, self.width, self.height, 0)
		local note = app.base_note % 12
		local octave = app.base_note \ 12
		local is_sharp = (note == 1) or (note == 3) or (note == 6)
			or (note == 8) or (note == 10)
		pal(7, self.dragged_note and 7 or 7)
		if is_sharp then
			spr(8 + note, 2, 6)
		else
			spr(8 + note, 8, 6)
		end
		pal(7, 7)
		print(
			"\014" .. string.format("%1x", octave),
			2 + 12, 7,
			self.dragged_note and 7 or 22
		)
		local x = 20
		rectfill(x, 8, x + 20, 10, 59)
		rectfill(
			x, 8,
			x + min(20 * (app.base_volume / 64), 20), 10,
			self.dragged_volume and 7 or 17
		)
		if self.dragged_volume then
			print("\014" .. string.format("%2d", app.base_volume), 27, 2, 7)
		end
		print(
			"\014inst " .. string.format("%d", app.base_instrument),
			44, 7,
			self.dragged_instrument and 7 or 14 -- col 26
		)
	end	
	
	function el:click(msg)
		-- TODO: replace with pull-down menus
		if msg.mx < 18 then
			self.dragged_note = {
				y0 = msg.my,
				start = app.base_note
			}
		elseif msg.mx < 42 then
			self.dragged_volume = {
				y0 = msg.my,
				start = app.base_volume
			}
		else
			self.dragged_instrument = {
				y0 = msg.my,
				start = app.base_instrument
			}
		end
		self.cursor = 0
	end
	
	function el:drag(msg)
		if self.dragged_note then
			local delta = msg.my - self.dragged_note.y0
			if (delta == 0) return -- or else double click doesn't work
			local new_val = self.dragged_note.start - (((delta + 3) \ 6) * 12)
			app.base_note = mid(0, new_val, 120)
		elseif self.dragged_volume then
			local delta = msg.my - self.dragged_volume.y0
			if (delta == 0) return -- or else double click doesn't work
			local new_val = self.dragged_volume.start - (((delta + 1) \ 2) * 1)
			app.base_volume = mid(0, new_val, 0x40) -- TODO: handle vol > 64
		elseif self.dragged_instrument then
			local delta = msg.my - self.dragged_instrument.y0
			if (delta == 0) return -- or else double click doesn't work
			local new_val = self.dragged_instrument.start - (((delta + 3) \ 6) * 1)
			app.base_instrument = mid(0, new_val, 0xfe) -- TODO: handle vol > 64
			-- TODO: temporary, remove
			app.instrument = app.base_instrument
		end
	end
	
	function el:release(msg)
		self.dragged_note = nil
		self.dragged_volume = nil
		if self.dragged_instrument and app.view == "inst" then
			app.refresh_gui = true
		end
		self.dragged_instrument = nil
		self.cursor = get_spr(50)
	end

	function el:doubleclick(msg)
		if msg.mx < 18 then
			notify("***")
			app.base_note = 48
		elseif msg.mx < 42 then
			app.base_volume = 0x32
		else
			app.base_instrument = 01
		end
	end
	
	return el
end


function attach_detail_button(parent, el)
	el.width = 16
	el.height = 16
	el.cursor = "pointer"
	parent:attach(el)
	
	function el:draw()
		pal(7, app.detail and 7 or 62)
		spr(app.detail and 45 or 46, 3, 2)
		pal(7, 7)		
	end	
	
	function el:tap()
		app.detail = not app.detail
		app.refresh_gui = true
	end
	
	return el
end


:: manual.txt
--[[pod_format="raw",created="2024-04-14 09:49:39",modified="2024-04-14 09:49:39",revision=0]]

:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2Iixtb2RpZmllZD0iMjAyNC0w
NC0xNCAxMzoxNjozMCIscmV2aXNpb249NDI0N11dbHo0AGcAAABWEAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD--------------------78QgiKSxoaWRkZW49ZmFsc2UscGFuX3g9
MAgAwnk9MCx0aWxlX2g9OAkAwHc9OCx6b29tPTF9fQ==
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2IixzdG9yZWQ9IjIwMjQtMDMt
MjQgMDA6NDg6MDYiXV1sejQABAAAAAMAAAAwbmls
:: pal/0.pal
b64$LS1bW3BvZCxiZ19jb2xvcj0wLGJsYWNrZXN0X2NvbG9yPTAsY3JlYXRlZD0iMjAyNC0wNC0x
MCAwNDo1Mjo1MSIsaGlkZGVuPXtbMF09ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2V9LGhpZGRlbl90b2dnbGVzPXtbMF09ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2V9LGxv
Y2tlZD17WzBdPXRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRy
dWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVl
LHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSxm
YWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxz
ZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxm
YWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxz
ZSxmYWxzZSxmYWxzZSxmYWxzZX0sbW9kaWZpZWQ9IjIwMjQtMDQtMTQgMTI6NTc6NDkiLG9rcGFs
X3ZlcnNpb249IjAuMC40IixyZXZpc2lvbj0xODYsdGVzdF9jdWJlX2NvbG9ycz17WzBdPXsxNSwz
MSw0fSx7MzEsNCwyMH0sezQsMjAsMjF9LHsxMCw5LDI1fSx7OSwyNSwyNH0sezgsMjQsMn0sezI2
LDExLDI3fSx7MTEsMjcsM30sezI3LDMsMTl9LHsyOCwxNywxOX0sezI4LDEyLDE2fSx7MTIsMTYs
MX0sezYsMjksMTN9LHsyOSwxMywxOH0sezEzLDE4LDF9LHs3LDIzLDE0fSx7MjMsMTQsMTN9LHsx
NCwzMCwxOH0sezcsNiwyMn0sezYsMjIsNX0sezIyLDUsMjF9LHsxLDEsMX0sezEsMSwxfSx7MSwx
LDF9fSx3aGl0ZXN0X2NvbG9yPTddXWx6NAAwAQAAFQIAAPUFdXNlcmRhdGEoImkzMiIsNjQsIjAB
AMAxZDJiNTMwMDdlMjUIAPAXMDA4NzUxMDBhYjUyMzYwMDVmNTc0ZjAwYzJjM2M3MDBmZmYxZTgI
AEAwMDRkCAARYTYAYGZmZWMyNwoAIGU0OABAMjlhZCQAYDgzNzY5YyAAMTc3YTgAwGNjYWEwMDFj
NWVhYzAA8B1hNWExMDA3NTRlOTcwMDEyNTM1OTAwNzQyZjI5MDA0OTJkMzgwMGEyODg3OUAA8ANh
Y2M1MDBjMzAwNGMwMGViNmJGAGA5MGVjNDIKACBiMsAAoDY0ZGZmNjAwYmSJAACWAEAwZGFiQABf
ODU2ZDABAK4gNjICAB0wAQCwMWUzNzNjMDAzNzQnASEwMwEAMTAwMgEAoDAwMTYxNjE2Iik=
:: pal/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTEwIDA0OjUyOjUxIixzdG9yZWQ9IjIwMjQtMDQt
MTAgMDQ6NTI6NTEiXV1sejQABAAAAAMAAAAwbmls
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTExIDE3OjI1OjAxIixtb2RpZmllZD0iMjAyNC0w
NC0xNCAxMzoxNjozMCIscmV2aXNpb249MjQ3Nl1dbHo0AIYCAACsCQAA8CdweHUAAygAAAMABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDBAUGBwAP-5AICQoLDwwPDQ8ODw8QAPAADQ8RDxIPEw8UDxUP
Fg8XEwDxAQ8YDxkPGg8bDxwPHQ8eDx8UAPEAIA8hDyIPIw8kDyUPJg8nFADxACgPKQ8qDysPLA8t
Dy4PLxQA8QAwDzEPMg8zDzQPNQ82DzcUAP8FOA85DzoPOw88Dz0PPg8-AA--8P8BAOvxHFoBEAYP
IBABIAEgAfAAAhACDBABIA8hIAEwD2aQDxECIAyQAeAPIgIgDFAiAP8QCPAPCfAPCvA3Dyjwxw-4
Cg--D4AP9w8NAfAJARAGDEkAAjd-kAEQAHQJIA_AEA1gEwBjDAIQAQ-3FAD-AghQBPAHAQnwDgEK
8C4CcA8UZAAMIw9AVQD-D_ABCCAPlfAKAQogD7MgD-gAD0BADy3whw8oD--wxkQAEzAwAZA-AECy
IA--PwAgDtBUAD_U8JNEABAYDocAR_3wCgEUAF8wD8Lwg0QAAzUEDzdFADUgDy5FAACWABUjPwA-
T-CjgwAQFAwwABUObgETA5EAN_DwChMAXzAPv-BjUQAUAC8APw7wwy4AYBsOXgESA6ABBg4AYOAC
CiAPXKwBdw4AD0UgDuAbABcEDACPDwUIIA-k8DPEAEcCJwOPUAIPvhAB8KhoABsPLgBcH-8BAMzT
6A4ADUAPHA--DxwPGggAHhgQAGL--x8BBSECAJ-1Hw85BQ8kDw4HAARA9R-wcFYA8BEFDysPJCUP
Kw8oFQ8rDyYPKAUH9SIRJREVIQUB9SIPOR0AQDkPJBUFAGIPOQUL9SE4AC-1sAgA-9cf-wEAl1D-
----Hw==
:: sfx/1.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTEyIDA2OjQyOjE4Iixtb2RpZmllZD0iMjAyNC0w
NC0xNCAxMzoxNjozMCIscmV2aXNpb249MjU2MV1dbHo0AFwDAAB9CwAA8U9weHUAAygAAAMABA9A
EAIOAAGgASACoA4ADxAADfDJAgEAAwQFBgcCDz_QCAkKCw8MDw0PDg8PBA--kA0PEQ8SDxMPFA8V
DxYPFwAP-5APGA8ZDxoPGw8cDx0PHg8fFADxACAPIQ8iDyMPJA8lDyYPJxQA8QAoDykPKg8rDywP
LQ8uDy8UAPEAMA8xDzIPMw80DzUPNg83FAD-BTgPOQ86DzsPPA89Dz4PPwAP--D-AQDr8DhaAQQA
Bg8gEAEgASAB8AACEAIPJAAPHwEP0AAPHw8uEAEFEAIEEAMADxoPf0APEQIgDygPExAPSBACD3YO
AAGQD2AwAQjwDzgAAEUA_ikPISAB4A8kAiAPIFABIAHgBQogD1cADoAPJOAJIA9jIA_n8A8PKPDH
D-gKD-8PgA-3Dw0B8AkBEIMAEwxKAFcwD3_QARAAeAkgD4AQDWATACEP9xQAT-CADxRWAAAfDFUA
ARUOVABWByAB4BILABcDFwAXBAwAFwUMABYGDACP8AgPKA--8MZ2AA4QB3UAF6A5AB8ADAAoD3UA
Gg-qAAUHCwAfAekABB8FdAAkB7MBHQeyAR8HsQEZUw8wAA_ApQD-BwggD5LwCgEKIA_zIA8zIA9X
IA8v8IeXAAQnDyJGABQOmAAgD5A-AKCsIA-BAA5ADw3QVAA-lPCTRAAFExdEAB-ocAEmAGEASODw
CgEdAT_-8GNQABcZ4DsAKbOQDwAgmJBgABujYAD-A5_QBQkgD14gD4TwBwggD8jwE28ANBFdbwAb
lm8AEZdvAH9rIA_e8AYBcAAWFw5wACQPNkwAooWQAgkgD50gD7dMAD-f8HNMAAQeDkwARzABkAFa
APcBAgogD1wgD-8ADgAPRSAO4BsAFwQMAH8FCCAP5PAzswAQFAziAS-wwy4ALh--AQDM8wDoDgAN
AA0gDxwP-w8cDxoIAB4YEABi--8fAQshAgC-_x8PMgsPJA8ODzkHAAJA_x-wcFgA8gEMIA80DysP
JAsPNAsPKw8oBwBQJg8oCwMTABgJAgD6APsRCBELCAsRCAshCwELCAIAUPsRDg85SAAgMgsIACIP
PQcAkTkLDysLDgsEC3oAAR4AEBwOADEV_xGBAD9A_7AIAP-XH-8BAJdQ-----x8=
:: sfx/2.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTEyIDA2OjQzOjAwIixtb2RpZmllZD0iMjAyNC0w
NC0xMyAwODowMToyOCIscmV2aXNpb249Nl1dbHo0AJ0BAADpCAAA8CdweHUAAygAAAMABA9AEAIO
AAGgASACoA4ADxAADfDKAQIDBAUGBwAP-5AICQoLDwwPDQ8ODw8QAPAADQ8RDxIPEw8UDxUPFg8X
EwDxAQ8YDxkPGg8bDxwPHQ8eDx8UAPEAIA8hDyIPIw8kDyUPJg8nFADxACgPKQ8qDysPLA8tDy4P
LxQA8QAwDzEPMg8zDzQPNQ82DzcUAP8FOA85DzoPOw88Dz0PPg8-AA--8P8BAOv-JVoBEAYPIBAB
IAEgAfAAAhACDBABIA8hIAEwD2bwww8o8McP_AoP-w_AD-cPDQHwCQEQBgwuAAI3f5ABEAB4CSAP
gBANYBMAIQ-3FABP8IAPFFUAFhBAgwBPD--wxjAA--9sH-8BAMzzAegPQAANAA0gDxwP-w8cDxoI
AB4YEABi--8fAQ4hAgCf-h8POQ4PJA8OBwAEQf4f8HBZAPATDCAODysPJC4PKw8oHg8rDyYPKA4D
-iIRLhEeIQ4B-iIPOR0AQDkPJB4FAGIPOQ4E-iE7AG9A-rDwcAUIAP-UH-8BAJdQ-----x8=
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2IixzdG9yZWQ9IjIwMjQtMDMt
MjQgMDA6NDg6MDYiXV1sejQABAAAAAMAAAAwbmls
:: src/app.lua
--[[pod_format="raw",created="2024-04-12 08:11:00",modified="2024-04-14 13:16:30",revision=2307]]
local app = {}


-- Global state

app.pattern = 0 -- opened in pattern editor
app.track = 0 -- opened in track editor
app.instrument = 0 -- opened in instrument editor

app.base_note = 48
app.base_volume = 0x32
app.base_instrument = 00


-- GUI

app.refresh_gui = true
app.gui = nil

app.view = "inst" -- "patt" or "trk" or "inst"
app.detail = false


-- Layout constants

app.ruler_height = 9
app.channels_width = 16
app.detail_width = 56
app.cell_width = 20
app.cell_height = 29

app.node_width = 26
app.node_gap = 14

app.synth_width = 84
app.synth_height = 72
app.synth_gap = 4
app.env_width = 58
app.env_height = app.synth_height

-- Colors -----------------------------------------------------------------

app.editor_bg = 62

return app
:: src/constants.lua
--[[pod_format="raw",created="2024-04-10 15:52:04",modified="2024-04-13 03:08:09",revision=702]]
local constants = {}


constants.piano_keys = {
	{
		offset = -12,
		[0] = "z", "s", "x", "d", "c", "v", "g", "b", "h", "n", "j", "m",
		",", "l", ".", ";", "/"
	},
	{
		offset = 0,
		[0] = "q", "2", "w", "3", "e", "r", "5", "t", "6", "y", "7", "u",
		"i", "9", "o", "0", "p", "[", "=", "]",
	}
}


constants.isomorphic_keys = {
	{
		offset = -12,
		[0] = "z", "x", "c", "v", "b", "n", "m", ",", ".", "/",
	},
	{
		offset = -6,
		[0] = "a", "s", "d", "f", "g", "h", "j", "k", "l", ";", "'",
	},
	{
	offset = 0,
		[0] = "q", "w", "e", "r", "t", "y", "u", "i", "o", "p", "[", "]", "\\",
	},
	{
	offset = 6,
		[0] = "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "-", "=",
	}
}


return constants
:: src/detail.lua
--[[pod_format="raw",created="2024-04-12 07:24:11",modified="2024-04-14 07:57:29",revision=887]]
local app = require "src/app"
local note_grid = require "src/note_grid"
local sfx = require "src/sfx"


local detail = {}


function detail.track()
	if app.view == "patt" then
		if note_grid.selection then
			return sfx.pattern_track(app.pattern, note_grid.selection.channel)
		else
			return nil
		end
	else
		return app.track
	end
end


function detail.attach_panel(parent, el)
	el.width = 64
	el.height = 270 - 11 - 16
	parent:attach(el)
	if app.view == "patt" or app.view == "trak" then
		detail.attach_section_pattern(el, { x = 1, y = app.ruler_height })
		detail.attach_section_track(el, { x = 1, y = app.ruler_height + 30 })
		detail.attach_section_note(el, { x = 1, y = app.ruler_height + 80 })
	end

	function el:draw()
		rectfill(0, 0, self.width, self.height, 21)
		pal(7, 5)
		spr(1, 2, self.height - 8)
		pal(7, 7)
	end	
	

	return el
end


-- Pattern section -------------------------------------------------------


function detail.attach_section_pattern(parent, el)
	el.width = parent.width - el.x
	el.height = 24 -- TODO
	parent:attach(el)
	detail.attach_pattern_flow_toggles(el, { x = 4, y = 10 })
	function el:draw()
		--- rectfill(0, 0, self.width, self.height, 2)
		print(string.format("pattern %d", app.pattern), 3, 0, 22)
		line(3, 7, self.width - 3, 7, 5)
	end
end


function detail.attach_pattern_flow_toggles(parent, el)
	el.width = 36 + 1
	el.height = 11
	el.cursor = "pointer"
	parent:attach(el)

	function el:draw()
		local is_start = sfx.pattern_loop_start(app.pattern)
		local is_stop = sfx.pattern_loop_stop(app.pattern)
		local is_end = sfx.pattern_loop_end(app.pattern)
		pal(7, is_start and 17 or 63)
		spr(40, 2, 1)
		pal(7, is_end and 17 or 63)
		spr(41, 2 + 12, 1)
		pal(7, is_stop and 17 or 63)
		spr(42, 2 + 24, 1)
		pal(7, 7)
	end	
	
	function el:tap(msg)
		if msg.mx > 25 then
			sfx.set_pattern_loop_stop(
				app.pattern,
				not sfx.pattern_loop_stop(app.pattern)
			)
		elseif msg.mx > 13 then
			sfx.set_pattern_loop_end(
				app.pattern,
				not sfx.pattern_loop_end(app.pattern)
			)
		else
			sfx.set_pattern_loop_start(
				app.pattern,
				not sfx.pattern_loop_start(app.pattern)
			)
		end
	end

	return el
end


-- Track section ------------------------------------------------------------------


function detail.attach_section_track(parent, el)
	el.width = parent.width - el.x
	el.height = 48 -- TODO
	parent:attach(el)
	detail.attach_num_field(
		el,
		{
			x = 0, y = 12,
			label = "speed:",
			visible = function() return note_grid.selection != nil end,
			get = function() return sfx.track_speed(detail.track()) end,
			set = function(v) sfx.set_track_speed(detail.track(), v) end,
		}
	)
	el.loop0_field = detail.attach_num_field(
		el,
		{
			x = 0, y = 22,
			label = "length:",
			visible = function() return note_grid.selection != nil end,
			get = function() return sfx.track_loop0(detail.track()) end,
			set = function(v) sfx.set_track_loop0(detail.track(), v) end,
		}
	)
	detail.attach_num_field(
		el,
		{
			x = 0, y = 32,
			label = "loop end:",
			visible = function() return note_grid.selection != nil end,
			get = function() return sfx.track_loop1(detail.track()) end,
			set = function(v) sfx.set_track_loop1(detail.track(), v) end,
		}
	)
	
	function el:draw()
		local track = detail.track()
		if (not track) return
		--- rectfill(0, 0, self.width, self.height, 2)
		print(string.format("track %d", track), 3, 0, 22)
		line(3, 7, self.width - 3, 7, 5)
	end
	
	function el:update()
		local track = detail.track()
		if (not track) return
		if sfx.track_loop1(track) > 0 then
			self.loop0_field.label = "l. start:"
		else
			self.loop0_field.label = "length:"
		end
	end
end


-- Note section ------------------------------------------------------------------


function detail.attach_section_note(parent, el)
	el.width = parent.width - el.x
	el.height = 70 -- TODO
	parent:attach(el)
	detail.attach_num_field(
		el,
		{
			x = 0, y = 12,
			label = "pitch:",
			visible = function() return note_grid.selection != nil end,
			get = function() return sfx.track_pitch(detail.track(), note_grid.selection.step) end,
			set = function(v) sfx.set_track_pitch(detail.track(), note_grid.selection.step, v) end,
		}
	)
	detail.attach_num_field(
		el,
		{
			x = 0, y = 22,
			label = "volume:",
			visible = function() return note_grid.selection != nil end,
			get = function() return sfx.track_volume(detail.track(), note_grid.selection.step) end,
			set = function(v) sfx.set_track_volume(detail.track(), note_grid.selection.step, v) end,
		}
	)
	detail.attach_num_field(
		el,
		{
			x = 0, y = 32,
			label = "inst:",
			visible = function() return note_grid.selection != nil end,
			get = function() return sfx.track_instrument(detail.track(), note_grid.selection.step) end,
			set = function(v) sfx.set_track_instrument(detail.track(), note_grid.selection.step, v) end,
		}
	)
	detail.attach_num_field(
		el,
		{
			x = 0, y = 42,
			label = "fx:",
			visible = function() return note_grid.selection != nil end,
			get = function() return sfx.track_fx(detail.track(), note_grid.selection.step) end,
			set = function(v) end,
		}
	)
	detail.attach_num_field(
		el,
		{
			x = 0, y = 52,
			label = "param1:",
			visible = function() return note_grid.selection != nil end,
			get = function() return (sfx.track_fx_params(detail.track(), note_grid.selection.step) & 0xf0) >> 4 end,
			set = function(v) end,
		}
	)
	detail.attach_num_field(
		el,
		{
			x = 0, y = 62,
			label = "param2:",
			visible = function() return note_grid.selection != nil end,
			get = function() return (sfx.track_fx_params(detail.track(), note_grid.selection.step) & 0xf0) end,
			set = function(v) end,
		}
	)
		
	function el:draw()
		local track = app.track
		local step = 0
		if app.view == "patt" then
			if note_grid.selection then
				track = sfx.pattern_track(app.pattern, note_grid.selection.channel)
			else
				return
			end
		end
		--- rectfill(0, 0, self.width, self.height, 2)
		print("note", 3, 0, 22)
		line(3, 7, self.width - 3, 7, 5)
	end
end


-- Widgets ------------------------------------------------------------------------


function detail.attach_num_field(parent, el)
	el.width = parent.width - el.x
	el.height = 12
	parent:attach(el)
	if (not el.visible) el.visible = function() return true end
	el.dragged = nil
	function el:draw()
		if (not el.visible()) return
		local val = self.get()
		rectfill(self.width - 24, 0, self.width - 10, 6, self.dragged and 17 or 62)
		print(el.label, 3, 1, 22)
		if val then
			print(string.format("%3d", val), self.width - 22, 1, self.dragged and 7 or 22)
		else
			print("-", self.width - 4, 1, self.dragged and 7 or 17)
		end
	end
	function el:hover(msg)
		if msg.mx >= self.width - 21 then
			--- self.cursor = "pointer"
			self.cursor = get_spr(50)
		else
			self.cursor = 1
		end
	end
	function el:click(msg)
		if (not el.visible()) return
		if msg.mx >= self.width - 21 then
			self.dragged = { y0 = msg.my, val0 = self.get() }
			self.cursor = 0 -- TODO: capture mouse
		end
	end
	function el:drag(msg)
		if (not el.visible()) return
		if self.dragged then
			local delta = msg.my - self.dragged.y0
			local new = self.dragged.val0 - ((delta - 3) / 6)
			new = mid(0, new, 0xff)
			self.set(new)
		end
	end
	function el:release(msg)
		self.dragged = nil
	end
	return el
end


return detail
:: src/ed_inst.lua
--[[pod_format="raw",created="2024-04-10 15:43:44",modified="2024-04-14 13:16:30",revision=2310]]
local app = require "src/app"
local settings = require "src/settings"
local routing = require "src/routing"
local synth = require "src/synth"


local ed_inst = {}


function ed_inst.attach(parent, el)
	el.width = 480 - (app.detail and app.detail_width or 0)
	el.height = 270 - 11 - 16
	parent:attach(el)

	synth.refresh_nodes()	

	ed_inst.attach_instr_chooser(el, { x = 4, y = 4 })
	routing.attach(el, { x = 480 - 311, y = 0 })

	local dx = app.synth_width + app.synth_gap
	local dy = app.synth_height + app.synth_gap
	local ox = (480 - (4 * dx) + app.synth_gap) \ 2
	local oy = 270 - 11 - 16 - (2 * app.synth_height) - app.synth_gap - 2
	local id = 0
	for row = 0, 1 do
		synth.attach_env_panel(el, { x = 4, y = oy + row * dy })
		for column = 0, 3 do
			synth.attach_node_panel(
				el,
				{
					x = ox + column * dx, y = oy + row * dy, 
					node_id = id
				}
			)
			id += 1
		end
		synth.attach_env_panel(el, { x = 480 - app.env_width - 4, y = oy + row * dy })
	end
	
	function el:draw()
		---rectfill(0, 0, self.width, 106, app.editor_bg)
		fillp(0b0000111100001111)
		fillp(0b0101010101010101)
		fillp(0b0011011011001001)
		fillp(0b0001001001001000)
		rectfill(0, 0, self.width, self.height, 62 | (61 << 8))-- app.editor_bg | (61 << 8))
		fillp()
	end	
	
	function el:update()
		local pitch_key = nil
		for i = 1, #settings.keys.pitched do
			local offset = settings.keys.pitched[i].offset
			for j = 0, #settings.keys.pitched[i] do
				local k = settings.keys.pitched[i][j]
				if key(k, true) then
					pitch_key = j + offset
				end
			end
		end
		if pitch_key then
			local pitch = pitch_key + app.base_note
			if key("shift") then
				pitch += 12
			end
			pitch = mid(0, pitch, 0xfe)
			note(
				pitch, -- todo
				app.instrument, -- current_instrument
				app.base_volume, -- current_volume
				ord(" "), 0x00, -- fx, fx param
				8, -- channel 8 so it can play with pattern
				false -- don't force retrigger
			)
		else
			note(0xff, 0xff, 0xff, 0xff, 0xff, 8)
		end
	end

	return el
end


-- Instrument chooser --------------------------------------------------------------


function ed_inst.attach_instr_chooser(parent, el)
	el.width = 80
	el.height = 83
	local container = parent:attach(el)
	function container:draw()
		clip()
		rect(-1, -1, self.width, self.height, 5)
		clip(self.sx, self.sy, self.width, self.height)
	end
	local contents = container:attach {
		x = 0, y = 0, width = el.width, height = 128 * 8 + 2,
		cursor = "pointer",
		draw = function(self)
			rectfill(0, 0, self.width, self.height, 63)
			for i = 0, 127 do -- TODO: dynamic number of instruments?
				if i == app.instrument then
					rectfill(0, i * 8 - 1, self.width, (i * 8) + 7, 17)
				end
				print("" .. i .. ": ---", 4, 1 + i * 8, (i == app.instrument) and 7 or 6)
			end
		end,
		click = function(self, msg)
			app.instrument = msg.my \ 8
			app.base_instrument = app.instrument -- TODO: temporary, remove
			app.refresh_gui = true
		end
	}
	container:attach_scrollbars()
	return el
end


return ed_inst
:: src/ed_patt.lua
--[[pod_format="raw",created="2024-04-10 10:06:40",modified="2024-04-14 07:57:29",revision=2517]]
local app = require "src/app"
local constants = require "src/constants"
local sfx = require "src/sfx"


local ed_patt = {}


-- Channel panel -------------------------------------------------------------------


function ed_patt.attach_channel_panel(parent, el)
	el.width = app.channels_width
	el.height = 270 - 11 - 16
	parent:attach(el)

	function el:draw()
		rectfill(0, 0, self.width, self.height, 21)
		for channel = 0, 7 do
			local oy = app.ruler_height + channel * app.cell_height
			local track_id = sfx.pattern_track(app.pattern, channel)
			local is_dragged = self.dragged and self.dragged.channel == channel
			if is_dragged then
				rectfill(0, oy + 1, 14, oy + 9, 17)
			end
			
			p8_centered_print(
				string.format("%d", track_id),
				8, oy + 3,
				is_dragged and 7 or 22
			)			
			spr(sfx.channel_is_muted(app.pattern, channel) and 32 or 33, 4, oy + 12)
		end
	end
	
	function el:hover(msg)
		local channel = (msg.my - app.ruler_height) \ app.cell_height
		if (channel > 7) return
		local part = (msg.my - app.ruler_height) % app.cell_height
		if part < 10 then
			--- self.cursor = "pointer"
			self.cursor = get_spr(50)
		else
			self.cursor = 1
		end
	end
	
	function el:click(msg)
		self:set_keyboard_focus(true) -- TODO
		local channel = (msg.my - app.ruler_height) \ app.cell_height
		if (channel > 7) return
		local part = (msg.my - app.ruler_height) % app.cell_height
		if part < 10 then
			local track_id = sfx.pattern_track(app.pattern, channel)
			self.dragged = { channel = channel, y0 = msg.my, id0 =  track_id}
			self.cursor = 0 -- TODO: capture mouse
		elseif part < 20 then
			sfx.mute_channel(
				app.pattern,
				channel,
				not sfx.channel_is_muted(app.pattern, channel)
			)
		end
	end
	
	function el:drag(msg)
		if self.dragged then
			local delta = msg.my - self.dragged.y0
			local track_id = self.dragged.id0 - math.floor(0.5 + ((delta + 3) \ 6))
			track_id = mid(0, track_id, 0xff)
			-- TODO: move to sfx
			poke(0x30100 + app.pattern * 20 + self.dragged.channel, track_id)
		end
	end
	
	function el:release(msg)
		self.dragged = nil
	end
		
	return el
end


-- Pattern selector ----------------------------------------------------------------


function ed_patt.attach_pattern_selector(parent, el)
	el.width = 19 * 14
	el.height = 16
	el.cursor = "pointer"
	parent:attach(el)

	function el:draw()
		local playing_pattern = stat(466)
		for p = 0, 18 do
			if p == 0 then
				spr(43, 5, 5)
			elseif p < 18 then
				rectfill(
					p * 14, 4,
					14 + p * 14, 12, 
					(p - 1) == playing_pattern and 17 or 59
				)
				p8_centered_print(
					string.format("%d", p - 1),
					8 + p * 14, 6,
					(p - 1) == app.pattern and 7 or 22
				)
			else
				spr(44, 3 + p * 14, 5)
			end
		end
	end	
	
	function el:click(msg)
		local p = msg.mx \ 14
		if p == 0 then
			-- TODO
		elseif p < 18 then
			app.pattern = p - 1
		else
			-- TODO
		end
	end

	return el
end


return ed_patt
:: src/ed_trak.lua
--[[pod_format="raw",created="2024-04-10 15:48:56",modified="2024-04-12 16:25:37",revision=71]]
local app = require "src/app"


local ed_trak = {}


function ed_trak.attach(parent, el)
	el.width = 480 - (app.detail and app.detail_width or 0)
	el.height = 270 - 11 - 16 - 1
	parent:attach(el)

	function el:draw()
		rectfill(0, 0, self.width, self.height, 62)
	end	

	return el
end


return ed_trak
:: src/file.lua
--[[pod_format="raw",created="2024-04-07 08:14:09",modified="2024-04-13 13:11:11",revision=1293]]
local app = require "src/app"


local file = {}


--M.default_filename = "/ram/cart/sfx/0.visitrak"
file.default_filename = "/ram/cart/sfx/1.sfx"


function file.save()
	local ud = userdata("u8", 0x30000)
	for i = 0, 0x2ffff do
		ud[i] = peek(0x30000 + i)
	end
	return ud
end


function file.load(ud)
	if type(ud) != "userdata" then
		init_data()
	else
		for i=0,0x2ffff do
			poke(0x30000+i, ud[i])
		end
	end
	app.refresh_gui = true
---			init_undo()
end


function file.handle_drop_items(msg)
	for i = 1, #msg.items do
		local item = msg.items[i]
		if item.pod_type == "file_reference" and item.attrib == "file" then
			local ext = item.fullpath:ext()
			if ext == "sfx" then
				local metadata = fetch_metadata(item.fullpath) or {} -- TODO
				send_message(pid(), {event = "open_file", filename = item.fullpath})
			else
				notify("wrong file extension")
				-- TODO: dialog for unknown file extensions?
				--current_filename = item.fullpath
				--send_message(pid(), {event = "open_file", filename = item.fullpath})
			end
		end
	end
end


-- Initialisation ----------------------------------------------------------------


-- copied from "/system/apps/sfx.lua" in Picotron 0.0.1e
function init_data()
	
	-- index (0x30000)
	
	-- first 3 values are almost metadata only -- not currently
	-- acted on anywhere. perhaps useful in future for deciding
	-- scope of copy/paste, and gui cues, but can be calculated
	-- from content.
	
	poke2(0x30000,
		64,  -- num_instruments
		512, -- num_tracks (64 patterns * 8 channels for default indexing)
		64,  -- num_patterns
		-- flags: 0x1 use default track indexing (base+0x20000, increments of 328 bytes)
		0x1
	)
	poke4(0x30010,
		0x10000, -- insts_addr      (I32)    relative address of instruments
		0x20000, -- tracks_addr     (I32)    relative address of track index
		0,       -- patterns_addr   (I32)    relative address of pattern data
		0        -- unused          (I32)    should be 0
	)
	poke2(0x30020,
		0,  -- tick len (0 for default -- custom vals not supported yet)
		64, -- default track length
		16 -- default track spd
	)
	
	-- default track speed (+3 unused)
	poke(0x30026, 16, 0, 0, 0) 
	
	-- pattern data: first 8 patterns
	
	for pp = 0,7 do
		local addr = 0x30100 + pp * 20
		for i = 0, 7 do
			poke(addr+i, pp*8 + i)
		end
		poke(addr+8, 0x0)  -- flow flags
		poke(addr+9, 0xff) -- channel mask
		poke(addr+10, 0,0) -- length (I16)
		
	end
	
	
	----------------------------------------------------------------------------
	-- single instrument at 0x40000 (instrument 0)
	
	-- node 0: root
	poke(0x40000 + (0 * 32), -- instrument 10node 0
	
			0,    -- parent (0x7)  op (0xf0)
			1,    -- kind (0x0f): 1 root  kind_p (0xf0): 0  -- wavetable_index
			0,    -- flags
			0,    -- unused extra
				
			-- MVALs:  kind/flags,  val0, val1, envelope_index
			
			0x2|0x4,0x20,0,0,  -- volume: mult. 0x40 is max (-0x40 to invert, 0x7f to overamp)
			0x1,0,0,0,     -- pan:   add. center
			0x1,0,0,0,     -- tune: +0 -- 0,48,0,0 absolute for middle c (c4) 261.6 Hz
			0x1,0,0,0,     -- bend: none
			-- following shouldn't be in root
			0x0,0,0,0,     -- wave: use wave 0 
			0x0,0,0,0      -- phase 
	)
	
	
	-- node 1: sine
	poke(0x40000 + (1 * 32), -- instrument 0, node 1
	
			0,    -- parent (0x7)  op (0xf0)
			2,    -- kind (0x0f): 2 osc  kind_p (0xf0): 0  -- wavetable_index
			0,    -- flags
			0,    -- unused extra
				
			-- MVALs:  kind/flags,  val0, val1, envelope_index
			
			0x2,0x20,0,0,  -- volume: mult. 0x40 is max (-0x40 to invert, 0x7f to overamp)
			0x1,0,0,0,     -- pan:   add. center
			0x21,0,0,0,    -- tune: +0 -- 0,48,0,0 absolute for middle c (c4) 261.6 Hz
			               -- tune is quantized to semitones with 0x20
			0x1,0,0,0,     -- bend: none
			0x0,0x40,0,0,  -- wave: triangle
			0x0,0,0,0      -- phase 
	)
	
	

	-- wavetable
	for i=0,7 do
	poke(0x40000 + 0x1e0,
		0x00, -- address (low)  in 256 byte increments
		0xf8, -- address (high) in 64k increments
		0x0a, -- samples (1 << n) 1024
		0xff,  -- wt_height 256(0); wave mval points at one of the entries
		
		-- to do: update (is garbage now?)
		0x80,
		0xf7,
		0x0d, -- samples (1 << n) 8192
		0x01
	)
	end

	-- envelope 0 inst 1
	
	poke(0x40000 + 0x100,
		0,0,0,0, 0,0,0,0,
		0,40,255,0 -- adsr
	)
	
	-- copy default instrument to 1..15
	for i=1,15 do
		memcpy(0x40000 + 0x200*i, 0x40000, 0x200)
	end
	
	--------------------------------------------------
	-- Track Data  0x50000
	--------------------------------------------------
	
	-- Default track size is 5 * 64 rows + 8 = 328 bytes
	
	-- header (8)
	local addr = 0x50000
	poke2(addr, 64) -- len
	poke(addr+2,16) -- spd
	poke(addr+3,0)  -- loop0
	poke(addr+4,0)  -- loop1
	poke(addr+5,0)  -- delay
	poke(addr+6,0)  -- flags (0x1 mute)
	poke(addr+7,0)  -- unused
	
	-- pitch, inst, vol: not set (0xff)
	memset(addr+8, 0xff, 64*3)
	
	-- copy to other tracks
	for i=1,63 do
		memcpy(0x50000 + i*328, 0x50000, 328)
	end
end


return file
:: src/note_grid.lua
--[[pod_format="raw",created="2024-04-11 06:36:17",modified="2024-04-13 06:47:08",revision=1566]]
local app = require "src/app"
local settings = require "src/settings"
local sfx = require "src/sfx"


local note_grid = {}


note_grid.origin = { x = -4 }
note_grid.selection = { channel = 0, step = 0, part = 0 }


function note_grid.attach(parent, el)
	el.width = 480 - app.channels_width - (app.detail and app.detail_width or 0)
	el.height = 270 - 11 - 16
	parent:attach(el)
	
	el.dragged = nil
	
	el:set_keyboard_focus(true)
	
	-- Draw ------------------------------------------------------------------------

	function el:draw()
		local pattern_is_playing = (stat(464) != 0)  and (stat(466) == app.pattern)
		-- Ruler background
		rectfill(0, 0, self.width, app.ruler_height - 2, 61)
		line(0, app.ruler_height - 1, self.width, app.ruler_height - 1, 5)
		local step_start = note_grid.origin.x \ app.cell_width
		local delta_x = - (note_grid.origin.x % app.cell_width)
		if step_start < 0 then
			step_start = 0
			note_grid.origin.x = max(- 4 , note_grid.origin.x)
			delta_x = - note_grid.origin.x
		end
		for channel = 0, 7 do
			local oy = app.ruler_height + channel * app.cell_height
			rectfill(
				0, oy, self.width,
				oy + app.cell_height - 1,
				((channel % 2) == 0) and 63 or 62
			)
			if sfx.channel_is_muted(app.pattern, channel) then
				goto continue
			end
			local track = peek(0x30100 + app.pattern * 20 + channel)
			for step_i = 0, 24 do
				if step_start + step_i > 63 then break end
				local ox = delta_x + step_i * app.cell_width + 1
				if pattern_is_playing and stat(400 + channel, 9) == step_start + step_i then
					rectfill(ox, oy, ox + app.cell_width - 2, oy + app.cell_height - 1, 19)
				end
				if
					note_grid.selection and note_grid.selection.channel == channel
						and note_grid.selection.step == step_start + step_i
				then
					-- TODO: replace with rectfill
					-- TODO: replace with rect when no keyboard focus
					spr(24 + note_grid.selection.part, ox, oy)
				end
				-- TODO: support track length > 64
				local freq = sfx.track_pitch(track, step_start + step_i)
				local inst = sfx.track_instrument(track, step_start + step_i)
				local vol  = sfx.track_volume(track, step_start + step_i)
				local fx   = sfx.track_fx(track, step_start + step_i)
				local fxp  = sfx.track_fx_params(track, step_start + step_i)
				-- Note and octave
				if freq != 0xff then
					local note = freq % 12
					local is_sharp = (note == 1) or (note == 3) or (note == 6)
						or (note == 8) or (note == 10)
					local x = is_sharp and (ox + 2) or (ox + 2) -- 5
					spr(8 + note, x, oy + 2)
					local x_oct = is_sharp and (ox + 14) or (ox + 8) -- 11
					if (freq \ 12) <= 9 then
						print("\014" .. tostr(freq \ 12), x_oct, oy + 3, 13) 
					else
						print("\014?", ox + 14, oy + 3, 13) 
					end
				else
					print("\014.", ox + 2, oy, 7)
				end
				-- Volume
				if vol != 0xff then
					local w_vol = (vol / 64) * (app.cell_width - 6)
					w_vol = min(w_vol, app.cell_width - 6)
					if w_vol == 0 and vol != 0 then
						w_vol = 1
					end
					rectfill(ox + 2, oy + 10, ox + 2 + app.cell_width - 6, oy + 12, 60)
					if w_vol > 0 then
						rectfill(ox + 2, oy + 10, ox + 2 + w_vol, oy + 12, 17) -- col 22
					end
					-- TODO: support vol > 64
				else
					print("\014.", ox + 2, oy + 7, 5)
				end
				-- Instrument
				local x = 8
				if inst != 0xff then
					if inst > 99 then
						x -= 4
					elseif inst > 9 then
						x -= 2
					end
					x = 2
					print("\014" .. string.format("%d", inst), ox + x, oy + 15, 14) -- 26
				else
					print("\014.", ox + 2, oy + 15 - 1, 5)
				end
				-- Effect
				if false then
					print("\014" .. fx, ox + 2, oy + 22, 22)
				else
					print("\014.", ox + 2, oy + 22 - 1, 5)
				end
			end
			::continue::
		end
		if self.height > app.ruler_height + 8 * app.cell_height then
			rectfill(0, app.ruler_height + 8 * app.cell_height, self.width, self.height, 62)
		end
		-- Bar lines
		for step_i = 0, 24 do
			if step_start + step_i > 63 + 1 then break end
			local ox = delta_x + (step_i * app.cell_width)
			local bar = (step_start + step_i) \ (4 * 4) + 1
			local beat = ((step_start + step_i) \ 4) % 4 + 1
			if (step_start + step_i) % 4 == 0 then
				if ((step_start + step_i) \ 4) % 4 == 0 then
					line(ox, 0, ox, self.height, 22)
					print("\014" .. bar .. "." .. beat, ox + 2, 2, 22)
				else
					line(ox, 0, ox, self.height, 5)
					print("\014" .. bar .. "." .. beat, ox + 2, 2, 5)
				end
			else
				--[[
				poke(0x550b, 0x3f)
				fillp(0b0000000011111111)
				line(ox, app.ruler_height, ox, self.height - 1, 5)
				fillp()
				poke(0x550b, 0x00)
				--]]
			end
		end
	end
	
	-- Mouse --------------------------------------------------------------------
	

	function el:hover(msg)
		if msg.my <= app.ruler_height then
			self.cursor = "grab"
		else
			self.cursor = 1
		end
	end
	

	function el:click(msg)
		if msg.my < app.ruler_height or msg.mb == 4 then
			self.dragged = { x = note_grid.origin.x + msg.mx, pan = true }
			self.cursor = "grab"
		elseif msg.mb == 1 then
			self:set_keyboard_focus(true)
			local step = (msg.mx + note_grid.origin.x) \ app.cell_width
			local channel = (msg.my - app.ruler_height) \ app.cell_height
			if
				(0 <= channel) and (channel <= 7)
					and (0 <= step) and (step <= 63) -- TODO: handle track length
			then
				note_grid.selection = { part = 0, step = step, channel = channel }
				local y = (msg.my - app.ruler_height) % app.cell_height
				if y > 20 then
					note_grid.selection.part = 3
				elseif y > 14 then
					note_grid.selection.part = 2
				elseif y > 8 then
					note_grid.selection.part = 1
				end
				self:show_selection()
			else
				note_grid.selection = nil
			end
		end
	end
	

	function el:drag(msg)
		if self.dragged then
			note_grid.origin.x = self.dragged.x - msg.mx
		end
	end
	

	function el:release(msg)
		self.dragged = nil
		self.cursor = 1
	end
	
	
	function el:mousewheel(msg)
		note_grid.origin.x -= msg.wheel_y * app.cell_width
	end
	
	-- Update -----------------------------------------------------------------
	

	function el:update()
		if self.note_playing then
			-- TODO: should be in main.lua (bug when switching view during note)
			if self.note_playing.tick > 10 then
				note(0xff, 0xff, 0xff, 0xff, 0xff, self.note_playing.channel)
				self.note_playing = nil
			else
				self.note_playing.tick += 1
			end
		end
		
		-- TODO: separate: take focus *xor* move
		if (keyp("pageup")) self:set_keyboard_focus(true); self:goto_previous_channel()
		if (keyp("pagedown")) self:set_keyboard_focus(true); self:goto_next_channel()
		if (keyp("up")) self:set_keyboard_focus(true); self:goto_previous_part()
		if (keyp("down")) self:set_keyboard_focus(true); self:goto_next_part()
		if (keyp("left")) self:set_keyboard_focus(true); self:goto_previous_step()
		if (keyp("right")) self:set_keyboard_focus(true); self:goto_next_step()

		if note_grid.selection then
			self:handle_positioned_key()
		end
	end


	function el:handle_positioned_key()
		local keys = settings.keys
		
		local track = peek(0x30100 + app.pattern * 20 + note_grid.selection.channel)
		local base_addr = 0x50000 + 8 + (track * 328) + note_grid.selection.step
		
		-- Pitched input
		local pitch_key = nil
		for i = 1, #settings.keys.pitched do
			local offset = settings.keys.pitched[i].offset
			for j = 0, #settings.keys.pitched[i] do
				local k = settings.keys.pitched[i][j]
				if keyp(k, true) then
					pitch_key = j + offset
				end
			end
		end
		
		local num_key = keyp_num()
		local hex_key = keyp_hex()
						
		-- Part-specific input
				
		if note_grid.selection.part == 0 then
			local note = peek(base_addr) % 12
			if key("shift") and num_key then
				local pitch = note + num_key * 12
				pitch = mid(0, pitch, 0xfe)
				poke(base_addr, pitch)
				self:goto_next_step()
			elseif pitch_key then
				local pitch = pitch_key + app.base_note
				if key("shift") then
					pitch += 12
				end
				pitch = mid(0, pitch, 0xfe)
				poke(base_addr, pitch)
				poke(base_addr + (2 * 64), app.base_volume)
				poke(base_addr + (1 * 64), app.base_instrument)
				-- TODO fx and fxp
				self:play_selection()
				self:goto_next_step()
			elseif keyp(keys.rest) and key("shift") then
				poke(base_addr, 0xff)
				self:goto_next_step()
			elseif keyp(keys.rest) then
				poke(base_addr, 0xff)
				poke(base_addr + (2 * 64), 0xff)
				poke(base_addr + (1 * 64), 0xff)
				-- TODO fx and fxp
				self:goto_next_step()
			end
			
		elseif note_grid.selection.part == 1 then
			if num_key then
				local vol = math.floor(((hex_key / 9) * 64) + 0.5)
				if key("shift") then
					vol += 64
				end
				notify("" .. vol)
				poke(base_addr + (2 * 64), vol)
				self:goto_next_step()
			elseif keyp(keys.rest) then
				poke(base_addr + (2 * 64), 0xff)
				self:goto_next_step()
			end
			
		elseif note_grid.selection.part == 2 then
			if num_key then
				local inst = peek(base_addr + (1 * 64))
				if (inst == 0xff) inst = 0
				if key("shift") then
					inst = (hex_key * 10) + (inst % 10)
				else
					inst = ((inst \ 10) * 10) + num_key
				end
				poke(base_addr + (1 * 64), inst)
				self:goto_next_step()
			elseif keyp(keys.rest) then
				poke(base_addr + (1 * 64), 0xff)
				self:goto_next_step()
			end
		--[[
		elseif note_grid.selection.part == 3 then
			if hexa_val then
				poke(base_addr + (4 * 64), hexa_val)
				self:goto_next_step()
			elseif keyp(keys.rest) then
				poke(base_addr + (4 * 64), 0xff)
				self:goto_next_step()
			end
		]]
		end
		
		-- Non part-specific input
		
		if keyp("backspace") then
			self:goto_previous_step()
			local base_addr = 0x50000 + 8 + (track * 328) + note_grid.selection.step
			poke(base_addr, 0xff)
			poke(base_addr + (2 * 64), 0xff)
			poke(base_addr + (1 * 64), 0xff)
			-- TODO: fx and fxp
			-- poke(base_addr + (3 * 64), 0xff)
			-- poke(base_addr + (4 * 64), 0xff)
		end
	end
	

	function el:goto_previous_part()
		if not note_grid.selection then
			self:goto_start()
		elseif note_grid.selection.part > 0 then
			note_grid.selection.part -= 1
		elseif note_grid.selection.channel > 0 then
			note_grid.selection.part = 3
			self:goto_previous_channel()
		end
		self:show_selection()
	end


	function el:goto_next_part()
		if not note_grid.selection then
			self:goto_start()
		elseif note_grid.selection.part < 3 then
			note_grid.selection.part += 1
		elseif note_grid.selection.channel < 7 then
			note_grid.selection.part = 0
			self:goto_next_channel()
		end
		self:show_selection()
	end
	
	
	function el:goto_previous_channel()
		-- TODO: skip muted
		if not note_grid.selection then
			self:goto_start()
		elseif note_grid.selection.channel > 0 then
			self:goto_channel(note_grid.selection.channel - 1)
		end
	end
	
	
	function el:goto_next_channel()
		-- TODO: skip muted
		if not note_grid.selection then
			self:goto_start()
		elseif note_grid.selection.channel < 7 then
			self:goto_channel(note_grid.selection.channel + 1)
		end
	end	

	

	function el:goto_previous_step()
		if not note_grid.selection then
			self:goto_start()
		elseif note_grid.selection.step > 0 then
			self:goto_step(note_grid.selection.step - 1)
		end
	end
		

	function el:goto_next_step()
		if not note_grid.selection then
			self:goto_start()
		elseif note_grid.selection.step < 63 then -- TODO: handle track length
			self:goto_step(note_grid.selection.step + 1)
		end
	end
	

	function el:goto_start()
		note_grid.selection = { part = 0, step = 0, channel = 0 }
		self:show_selection()
	end


	function el:goto_channel(c)
		-- TODO check if channel is muted
		note_grid.selection.channel = c
		self:show_selection()
	end
	

	function el:goto_step(s)
		note_grid.selection.step = s
		self:show_selection()
	end
	

	function el:show_selection()
		if (not note_grid.selection) return
		-- TODO: pagination by bars?
		local offset = 4 -- TODO
		if
			note_grid.origin.x > ((note_grid.selection.step * app.cell_width) - offset)
		then
			note_grid.origin.x = note_grid.selection.step * app.cell_width - offset
		elseif
			note_grid.origin.x + self.width < ((note_grid.selection.step + 1) * app.cell_width) + offset
		then
			note_grid.origin.x = ((note_grid.selection.step + 1) * app.cell_width) + offset - self.width
		end
	end
	

	function el:play_selection()
		if note_grid.selection and stat(464) == 0 then
			local track = peek(0x30100 + app.pattern * 20 + note_grid.selection.channel)
			local base_addr = 0x50000 + 8 + (track * 328) + note_grid.selection.step
			local pitch = peek(base_addr)
			local inst = peek(base_addr + 64)
			local vol  = peek(base_addr + (2 * 64))
			local fx   = peek(base_addr + (3 * 64))
			local fxp  = peek(base_addr + (4 * 64))
			note(
				pitch,
				inst,
				vol,
				ord(" "), 0x00, -- fx, fx param
				note_grid.selection.channel,
				false
			)
			self.note_playing = { channel = note_grid.selection.channel, tick = 0 }
		end
	end
	
	el:show_selection()
		
	return el
end


return note_grid
:: src/routing.lua
--[[pod_format="raw",created="2024-04-13 06:33:13",modified="2024-04-14 13:16:30",revision=1110]]
local app = require "src/app"
local synth = require "src/synth"


local routing = {}


function routing.attach(parent, el)
	el.width = 311
	el.height = 90
	parent:attach(el)
	
	function el:draw()
		---rectfill(0, 0, self.width, self.height, 62)
		-- Routing arrows
		for n = 0, 7 do
			local node = synth.nodes[n]
			local pos = node.position
			if pos and node != synth.root then
				local ppos = node.parent.position
				if node.type == 2 or not node.older_sibling then
					line(
						ppos.x + app.node_width + 7, ppos.y + 4,
						ppos.x + app.node_width + 1, ppos.y + 4,
						7
					)
					line(
						pos.x - 7, pos.y + 4,
						ppos.x + app.node_width + 7, ppos.y + 4,
						7
					)
					line(
						pos.x - 1, pos.y + 4,
						pos.x - 7, pos.y + 4,
						7
					)
					-- Arrow head
					line(pos.x - 2, pos.y + 3, pos.x - 2, pos.y + 5, 7)
					line(pos.x - 3, pos.y + 2, pos.x - 3, pos.y + 6, 7)
				else
					local col = 6
					local x = pos.x + app.node_width \ 2
					local orig = node.older_sibling
					local depth = 0
					while #orig.children > 0 and depth < 8 do
						orig = orig.children[#orig.children]
						depth += 1
					end
					local orig_x = orig.position.x + app.node_width
					line(x, pos.y - 2, x - 3, pos.y - 5, col)
					line(x - 3, pos.y - 5, x - (app.node_width \ 2) - 3, pos.y - 5, col)
					line(x - (app.node_width \ 2) - 3, pos.y - 5, x - (app.node_width \ 2) - 3 - 2, pos.y - 7, col)
					line(x, pos.y - 2, x + 3, pos.y - 5, col)
					line(x + 3, pos.y - 5, orig_x + 3, pos.y - 5, col)
					line(orig_x + 3, pos.y - 5, orig_x + 3 + 2, pos.y - 7, col)
				end
			end
		end
		-- Node boxes
		for n = 0, 7 do
			local node = synth.nodes[n]
			local pos = node.position
			if pos then
				local str = "??? "
				local fg = 63
				local bg = 30
				if node == synth.root then str = "synth"; fg = 22; bg = 7
				elseif node.type == 2 then
					if node.op == 0 then str = "osc " .. n; bg = 17
					elseif node.op == 1 then str = "fm " .. n; bg = 27
					elseif node.op == 2 then str = "ring " .. n; bg = 22
					end
				elseif node.type == 8 then str = "filt " .. n; bg = 14
				elseif node.type == 9 then str = "echo " .. n; bg = 31
				elseif node.type == 10 then str = "shap " .. n; bg = 9
				end
				rectfill(pos.x, pos.y, pos.x + app.node_width, pos.y + 8, bg)
				p8_centered_print(str, pos.x + (app.node_width \ 2) + 1, pos.y + 2, fg)
			end
		end
	end
	
	return el
end


return routing
:: src/settings.lua
--[[pod_format="raw",created="2024-04-11 08:58:08",modified="2024-04-13 03:08:09",revision=735]]
local constants = require "src/constants"


local settings = {}

---[[
settings.keys = {
	pitched = constants.isomorphic_keys,
	play = "space",
	rest = "del",
}
--]]
--[[
settings.keys = {
	pitched = constants.piano_keys,
	play = "space",
	rest = "del",
}
--]]


return settings
:: src/sfx.lua
--[[pod_format="raw",created="2024-04-07 08:22:05",modified="2024-04-14 13:16:30",revision=2981]]
local sfx = {}


local sfx_index = 0x030000
local sfx_instr = 0x040000
local sfx_track = 0x050000
local sfx_wave = 0xf00000 -- maybe not? (search discord)


local num_instrument = 0
local num_tracks = 0
local num_patterns = 0
local header_flags = 0
local insts_addr = 0
local tracks_addr = 0
local patterns_addr = 0


function sfx.read_header()
	num_instruments = peek2(sfx_index)
	num_tracks = peek2(sfx_index + 2)
	num_patterns = peek2(sfx_index + 4)
	header_flags = peek2(sfx_index + 6)
	-- unused: peek2(sfx_index + 8)
	insts_addr = peek4(sfx_index + 10)
	tracks_addr = peek4(sfx_index + 14)
	patterns_addr = peek4(sfx_index + 18)
	?header_flags
	?string.format("%x", insts_addr)
	?string.format("%x", tracks_addr)
	?string.format("%x", patterns_addr)
end


function sfx.play_or_pause()
	-- is `stat(464)` enough?
	if stat(464) == 0 then
		music(0)
	else
		note()
	end
end


function sfx.channel_is_muted(pattern, channel)
	local channel_mutes = peek(0x30100 + (pattern * 20) + 9)
	local muted = (channel_mutes & (1 << channel)) == 0
	return muted
end


function sfx.mute_channel(pattern, channel, mute)
	local channel_mutes = peek(0x30100 + (pattern * 20) + 9)
	channel_mutes &= ~(1 << channel)
	channel_mutes |= (mute and 0 or 1) << channel
	poke(0x30100 + (pattern * 20) + 9, channel_mutes)
end


function sfx.pattern_track(pattern, channel)
	return peek(0x30100 + pattern * 20 + channel)
end


function sfx.track_speed(track)
	return peek(0x50000 + (track * 328) + 2)
end


function sfx.set_track_speed(track, val)
	return poke(0x50000 + (track * 328) + 2, val)
end


function sfx.track_loop0(track)
	return peek(0x50000 + (track * 328) + 3)
end


function sfx.set_track_loop0(track, val)
	return poke(0x50000 + (track * 328) + 3, val)
end


function sfx.track_loop1(track)
	return peek(0x50000 + (track * 328) + 4)
end


function sfx.set_track_loop1(track, val)
	return poke(0x50000 + (track * 328) + 4, val)
end


-- Track notes -------------------------------------------------------------


function sfx.track_pitch(track, step)
	return peek(0x50000 + 8 + (track * 328) + step)
end
function sfx.set_track_pitch(track, step, v)
	return poke(0x50000 + 8 + (track * 328) + step, v)
end


function sfx.track_instrument(track, step)
	return peek(0x50000 + 8 + (track * 328) + step + 64)
end
function sfx.set_track_instrument(track, step, v)
	return poke(0x50000 + 8 + (track * 328) + step + 64, v)
end


function sfx.track_volume(track, step)
	return peek(0x50000 + 8 + (track * 328) + step + (2 * 64))
end
function sfx.set_track_volume(track, step, v)
	return poke(0x50000 + 8 + (track * 328) + step + (2 * 64), v)
end


function sfx.track_fx(track, step)
	return peek(0x50000 + 8 + (track * 328) + step + (3 * 64))
end
function sfx.set_track_fx(track, step, v)
	return poke(0x50000 + 8 + (track * 328) + step + (3 * 64), v)
end


function sfx.track_fx_params(track, step)
	return peek(0x50000 + 8 + (track * 328) + step + (3 * 64))
end
function sfx.set_track_fx_params(track, step, v)
	return poke(0x50000 + 8 + (track * 328) + step + (3 * 64), v)
end


-- Pattern flow flags ------------------------------------------------------


function sfx.pattern_loop_start(pattern)
	return (peek(0x30100 + (pattern * 20) + 8) & 0x01) != 0
end


function sfx.set_pattern_loop_start(pattern, bool)
	local old = peek(0x30100 + (pattern * 20) + 8)
	if bool then
		poke(0x30100 + (pattern * 20) + 8, old | 0x01)
	else
		poke(0x30100 + (pattern * 20) + 8, old & (~ 0x01))
	end
end


function sfx.pattern_loop_end(pattern)
	return (peek(0x30100 + (pattern * 20) + 8) & 0x02) != 0
end


function sfx.set_pattern_loop_end(pattern, bool)
	local old = peek(0x30100 + (pattern * 20) + 8)
	if bool then
		poke(0x30100 + (pattern * 20) + 8, old | 0x02)
	else
		poke(0x30100 + (pattern * 20) + 8, old & (~ 0x02))
	end
end


function sfx.pattern_loop_stop(pattern)
	return (peek(0x30100 + (pattern * 20) + 8) & 0x04) != 0
end


function sfx.set_pattern_loop_stop(pattern, bool)
	local old = peek(0x30100 + (pattern * 20) + 8)
	if bool then
		poke(0x30100 + (pattern * 20) + 8, old | 0x04)
	else
		poke(0x30100 + (pattern * 20) + 8, old & (~ 0x04))
	end
end


-- Synth nodes ---------------------------------------------------------------


function sfx.delete_node(instrument, node_id)
	local inst_addr = 0x40000 + instrument * 0x200
	-- move everything up
	for j = node_id, 7 do
		memcpy(inst_addr + j * 0x20, inst_addr + (j + 1) * 0x20, 0x20)
	end
	memset(inst_addr + 7 * 0x20, 0, 0x20)
end


function sfx.node_parent(instrument, node)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr + 0) & 0x7	
end

function sfx.node_op(instrument, node)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr) >> 4
end

function sfx.node_type(instrument, node)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr + 1) & 0xf
end

function sfx.node_osc_wavetable(instrument, node)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr + 1) >> 4
end

function sfx.node_flags(instrument, node)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr + 2)
end

function sfx.set_node_flags(instrument, node, flags)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 2, flags)
end

-- node_addr + 3 is unused

-- 0 <= p <= 7
function sfx.node_param(instrument, node, p)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	local flags,val1,val0,env = peek(node_addr + 4 + (4 * p), 4)
	return flags, val1, val0, env
end

function sfx.set_node_param_flags(instrument, node, p, flags)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 4 + (4 * p), flags)
end

function sfx.set_node_param_val1(instrument, node, p, val1)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 4 + (4 * p) + 1, val1)
end

function sfx.set_node_param_val0(instrument, node, p, val0)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 4 + (4 * p) + 2, val0)
end

function sfx.set_node_param_env(instrument, node, p, env)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 4 + (4 * p) + 3, env)
end

return sfx
:: src/synth.lua
--[[pod_format="raw",created="2024-04-12 16:30:23",modified="2024-04-14 13:16:30",revision=2700]]
local app = require "src/app"
local sfx = require "src/sfx"


local synth = {}


-- Node tree -------------------------------------------------------------------------


synth.nodes = {}
for n = 0, 7 do
	synth.nodes[n] = {
		parent = nil, -- id of the parent
		children = {}, -- list of direct references to the children
		type = nil,
	}
end
	

local function depth_walk(root, pre_fun, post_fun, depth)
	if (not depth) depth = 0
	if depth > 8 then
		notify("*** Deep recursion: cycle in synth nodes? ***")
		return
	end
	if (pre_fun) pre_fun(root)
	for i = 1, #root.children do
		local child = root.children[i]
		if child.type != 0 then
			depth_walk(child, pre_fun, post_fun, depth + 1)
		end
	end
	if (post_fun) post_fun(root)
end


function synth.refresh_nodes()
	for n = 0, 7 do
		synth.nodes[n].id = n
		synth.nodes[n].children = {}
		synth.nodes[n].older_sibling = nil
		synth.nodes[n].height = nil -- TODO: or 0?
		synth.nodes[n].position = nil
	end
	synth.root = synth.nodes[0]
	for n = 0, 7 do
		local type = sfx.node_type(app.instrument, n)
		local op = sfx.node_op(app.instrument, n)
		local parent_id = sfx.node_parent(app.instrument, n)
		synth.nodes[n].parent = synth.nodes[parent_id]
		synth.nodes[n].type = type
		synth.nodes[n].op = op
		if type != 0 and n != 0 then
			add(synth.nodes[n].parent.children, synth.nodes[n])
		end
	end
	
	depth_walk(
		synth.root,
		nil,
		function(node)
			if #node.children == 0 then
				node.height = 1
			else
				local h = 0
				for i = 1, #node.children do
					local child = node.children[i]
					if i > 1 then
						child.older_sibling = node.children[i - 1]
					end
					h += child.height
				end
				node.height = h
			end
		end
	)

	synth.root.position = { x = 2, y = 2 }
	depth_walk(
		synth.root,
		function(node)
			local y = node.position.y
			for i = 1, #node.children do
				node.children[i].position = {
					x = node.position.x + app.node_width + app.node_gap,
					y = y,
				}
				y += node.children[i].height * 16
			end
		end,
		nil
	)
end


-- Node panels --------------------------------------------------------------------


function synth.attach_node_panel(parent, el)
	local type = sfx.node_type(app.instrument, el.node_id)
	if el.node_id == 0 then return synth.attach_root(parent, el)
	elseif type == 0 then return synth.attach_unused(parent, el)
	elseif type == 2 then
		local op = sfx.node_op(app.instrument, el.node_id)
		if op == 0 then return synth.attach_osc(parent, el)
		elseif op == 1 then return synth.attach_fm(parent, el)
		elseif op == 2 then return synth.attach_ring(parent, el)
		end
	elseif type == 8 then return synth.attach_filt(parent, el)
	elseif type == 9 then return synth.attach_echo(parent, el)
	elseif type == 10 then return synth.attach_shap(parent, el)
	end
	return synth.attach_unknown(parent, el)
end


function synth.attach_root(parent, el)
	el.width = app.synth_width
	el.height = app.synth_height
	parent:attach(el)
	synth.attach_knob(el, { label = "vol", param = 0, node_id = el.node_id } )
	synth.attach_knob(el, { label = "pan", param = 1, node_id = el.node_id } )
	synth.attach_knob(el, { label = "tune", param = 2, node_id = el.node_id } )
	synth.attach_knob(el, { label = "bend", param = 3, node_id = el.node_id } )
	--- synth.attach_knob(el, { label = "p0", param = 4, node_id = el.node_id } )
	--- synth.attach_knob(el, { label = "p1", param = 5, node_id = el.node_id } )
	function el:draw()
		rectfill(0, 0, self.width, 9, 7)
		rectfill(0, 9, self.width, self.height, 6)
		synth.draw_corners(self)
		print("synthesizer", 2, 2, 22)
	end
	return el
end

function synth.attach_unused(parent, el)
	el.width = app.synth_width
	el.height = app.synth_height
	parent:attach(el)
	function el:draw()
		rectfill(0, 0, self.width, self.height, 62)
		synth.draw_corners(self)
		local x, y = 19, 14
		pal(7, 61)
		sspr(63, 0, 0, 7, 7, x, y, x + (7 * 4), y + (7 * 4))
		pal(7, 7)
		if self.node_id == 7 then
			print("pfx6416", 52, 63, 5)
		end
	end
	return el
end

function synth.attach_osc(parent, el)
	el.width = app.synth_width
	el.height = app.synth_height
	parent:attach(el)
	synth.attach_mute_toggle(el, { label = "osc", node_id = el.node_id })
	synth.attach_close_button(el, { node_id = el.node_id })
	synth.attach_knob(el, { label = "vol", param = 0, node_id = el.node_id } )
	synth.attach_knob(el, { label = "pan", param = 1, node_id = el.node_id } )
	synth.attach_knob(el, { label = "tune", param = 2, node_id = el.node_id } )
	synth.attach_knob(el, { label = "bend", param = 3, node_id = el.node_id } )
	synth.attach_knob(el, { label = "wave", param = 4, node_id = el.node_id } )
	synth.attach_knob(el, { label = "phase", param = 5, node_id = el.node_id } )
	function el:draw()
		rectfill(0, 0, self.width, 9, 17)
		rectfill(0, 9, self.width, self.height, 6)
		synth.draw_corners(self)
	end
	return el
end

function synth.attach_fm(parent, el)
	el.width = app.synth_width
	el.height = app.synth_height
	parent:attach(el)
	synth.attach_mute_toggle(el, { label = "fm", node_id = el.node_id })
	synth.attach_close_button(el, { node_id = el.node_id })
	synth.attach_knob(el, { label = "vol", param = 0, node_id = el.node_id } )
	synth.attach_knob(el, { label = "pan", param = 1, node_id = el.node_id } )
	synth.attach_knob(el, { label = "tune", param = 2, node_id = el.node_id } )
	synth.attach_knob(el, { label = "bend", param = 3, node_id = el.node_id } )
	synth.attach_knob(el, { label = "wave", param = 4, node_id = el.node_id } )
	synth.attach_knob(el, { label = "phase", param = 5, node_id = el.node_id } )
	function el:draw()
		rectfill(0, 0, self.width, 9, 27)
		rectfill(0, 9, self.width, self.height, 6)
		synth.draw_corners(self)
	end
	return el
end

function synth.attach_ring(parent, el)
	el.width = app.synth_width
	el.height = app.synth_height
	parent:attach(el)
	synth.attach_mute_toggle(el, { label = "ring", node_id = el.node_id })
	synth.attach_close_button(el, { node_id = el.node_id })
	synth.attach_knob(el, { label = "vol", param = 0, node_id = el.node_id } )
	synth.attach_knob(el, { label = "pan", param = 1, node_id = el.node_id } )
	synth.attach_knob(el, { label = "tune", param = 2, node_id = el.node_id } )
	synth.attach_knob(el, { label = "bend", param = 3, node_id = el.node_id } )
	synth.attach_knob(el, { label = "wave", param = 4, node_id = el.node_id } )
	synth.attach_knob(el, { label = "phase", param = 5, node_id = el.node_id } )
	function el:draw()
		rectfill(0, 0, self.width, 9, 22)
		rectfill(0, 9, self.width, self.height, 6)
		synth.draw_corners(self)
	end
	return el
end

function synth.attach_filt(parent, el)
	el.width = app.synth_width
	el.height = app.synth_height
	parent:attach(el)
	synth.attach_mute_toggle(el, { label = "filt", node_id = el.node_id })
	synth.attach_close_button(el, { node_id = el.node_id })
	synth.attach_knob(el, { label = "low", param = 0, node_id = el.node_id } )
	synth.attach_knob(el, { label = "high", param = 1, node_id = el.node_id } )
	synth.attach_knob(el, { label = "res", param = 2, node_id = el.node_id } )
	function el:draw()
		rectfill(0, 0, self.width, 9, 14)
		rectfill(0, 9, self.width, self.height, 6)
		synth.draw_corners(self)
	end
	return el
end

function synth.attach_echo(parent, el)
	el.width = app.synth_width
	el.height = app.synth_height
	parent:attach(el)
	synth.attach_mute_toggle(el, { label = "echo", node_id = el.node_id })
	synth.attach_close_button(el, { node_id = el.node_id })
	synth.attach_knob(el, { label = "delay", param = 0, node_id = el.node_id } )
	synth.attach_knob(el, { label = "vol", param = 1, node_id = el.node_id } )
	function el:draw()
		rectfill(0, 0, self.width, 9, 31)
		rectfill(0, 9, self.width, self.height, 6)
		synth.draw_corners(self)
	end
	return el
end

function synth.attach_shap(parent, el)
	el.width = app.synth_width
	el.height = app.synth_height
	parent:attach(el)
	synth.attach_mute_toggle(el, { label = "shap", node_id = el.node_id })
	synth.attach_close_button(el, { node_id = el.node_id })
	synth.attach_knob(el, { label = "gain", param = 0, node_id = el.node_id } )
	synth.attach_knob(el, { label = "elbow", param = 1, node_id = el.node_id } )
	synth.attach_knob(el, { label = "cut", param = 2, node_id = el.node_id } )
	synth.attach_knob(el, { label = "mix", param = 3, node_id = el.node_id } )
	function el:draw()
		rectfill(0, 0, self.width, 9, 9)
		rectfill(0, 9, self.width, self.height, 6)
		synth.draw_corners(self)
	end
	return el
end

function synth.attach_unknown(parent, el)
	el.width = app.synth_width
	el.height = app.synth_height
	parent:attach(el)
	function el:draw()
		rectfill(0, 0, self.width, self.height, 30)
		rectfill(0, 9, self.width, self.height, 6)
		synth.draw_corners(self)
		print("node " .. self.node_id, 2, 2, 63)
	end
	return el
end
	
function synth.draw_corners(el)
	pset(0, 0, app.editor_bg)
	pset(el.width - 1, 0, app.editor_bg)
	pset(0, el.height - 1, app.editor_bg)
	pset(el.width - 1, el.height - 1, app.editor_bg)
end
						

-- Envelope panel ------------------------------------------------------------------


function synth.attach_env_panel(parent, el)
	el.width = app.env_width
	el.height = app.env_height
	parent:attach(el)
	
	function el:draw()
		rectfill(0, 0, self.width, self.height, 18)
		rectfill(0, 9, self.width, self.height, 6)
		synth.draw_corners(self)
	end
		
	return el
end


-- The slider --------------------------------------------------------------------


function synth.attach_knob(parent, el)
	el.x = 0
	el.y = 12 + 10 * el.param
	el.width = parent.width
	el.height = 10
	parent:attach(el)
	el.dragged = nil

	local node_type = sfx.node_type(app.instrument, el.node_id)

	if (not el.min_val) el.min_val = -128	
	if (not el.max_val) el.max_val = 127

	if (el.label == "vol") el.min_val, el.max_val = 0, 64
	-- This is disabled in sfx.p64
	--if (el.label == "tune") el.min_val, el.max_val = -120, 120 -- el.ac = 20 el.a0 = 0.5
	if (el.label == "wave") el.min_val, el.max_val = 0, 255
	
	-- fx parameters are all 0..255 (flag 0x8 is not set)
	if (node_type >= 8) el.min_val, el.max_val = 0, 255
		
	-- gain mix; can use *8 if want to over mix!
	if (el.label == "mix") el.min_val, el.max_val = 0, 64


	function el:draw()
		local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
		local node_type = sfx.node_type(app.instrument, self.node_id)
		if el.label == "tune" and flags & 0x3 == 2 then
			self.min_val = 0
			self.max_val = 255
		end
		if self.max_val < 128 then -- signed int8's
			if (val1 >= 128) val1 -= 256
			if (val0 >= 128) val0 -= 256
		end
		print(self.label, 24 - (4 * #self.label), 1, 5)
		-- Relationship to parent
		if node_type < 8 then	-- (only oscillators have relationships)
			if flags & 0x3 > 0 then
				local letter = "\-h\|f?"
				if (flags & 0x3 == 0x1) letter = "\-d\^:2070200000000000" -- +
				if (flags & 0x3 == 0x2) letter = "\-d\^:5020500000000000" -- *
				print(letter, 26, 2, 59)
			else
				print("\-d\^:0020000000000000", 26, 2, 22) -- .
			end
		end
		-- Slider
		local range = self.max_val - self.min_val
		rectfill(32, 0, 32 + 32, 6, 59)
		local x_zero = mid(0, ((- self.min_val) * 32) \ range, 32)
		local x0 = mid(0, ((val0 - self.min_val) * 32) \ range, 32)
		local x1 = mid(0, ((val1 - self.min_val) * 32) \ range, 32)
		-- Ensure that small values are visible
		if self.min_val < 0 then
			if (val1 > 0 and x1 == 16) x1 = 17
			if (val1 < 0 and x1 == 16) x1 = 15
		else
			if (val1 > 0 and x1 == 0) x1 = 1
		end
		if val0 != val1 and x0 == x1 then
			if (val0 < val1) x0 = max(0, x1 - 1)
			if (val0 > val1) x0 = min(x1 + 1, 32)
		end
		rectfill(32 + x_zero, 0, 32 + x1, 6, 2)
		-- Notches for val1 and val0
		if (flags & 0x4) > 0 or (flags & 0x10) > 0 or self.show_val0 then
			line(32 + x0, 3, 32 + x1, 3, (self.dragged and self.show_val0) and 22 or 22)
			line(32 + x0, 2, 32 + x0, 4, (self.dragged and self.show_val0) and 7 or 22)
		end
		line(32 + x1, 0, 32 + x1, 6, (self.dragged and self.show_val1) and 7 or 15)
		-- Numerical value
		local str = ""
		local col = 0
		if self.show_val0 then
			if el.label == "tune" and flags & 0x3 == 2 then
				local num0 = 1 + val0 % 16
				local den0 = 1 + val0 \ 16
				str = num0 .. "/" .. den0
			else
				str = tostr(val0)
			end
			col = 29
		elseif self.show_val1 or key("shift") then
			if el.label == "tune" and flags & 0x3 == 2 then
				local num1 = 1 + val1 % 16
				local den1 = 1 + val1 \ 16
				str = num1 .. "/" .. den1
			else
				str = tostr(val1)
			end
			col = self.dragged and 7 or 6
		end
		local x = 64 - 4 * #str
		if x1 > 16 then
			x = 32 + 2
		end
		print(str, x, 1, col)
		-- Multiplier
		if (env & 0xc0 > 0) then
			str2 = (env & 0x20 == 0) and 
				"\^:5020500000000000" or  -- *
				"\^:4020100000000000"     -- /
			if (env & 0xc0 == 0x40) str2 = str2 .. "\-c\^:5070400000000000" -- 4
			if (env & 0xc0 == 0x80) str2 = "\-e" .. str2 .. "\^:1372770000000000" -- 16
			if (env & 0xc0 == 0xc0) str2 = "\-e" .. str2 .. "\^:5177470000000000" -- 64
			print(str2, 63, 2, 24)
		else
			print("\^:0020000000000000", 63, 2, 22) -- .
		end
		-- Modulator assignment
		local mx = 78
		if flags & 0x4 > 0 then
			rectfill(mx - 1, 0, mx + 3, 6, 59)
			rectfill(mx - 2, 1, mx + 4, 5, 59)
			if flags & 0x8 > 0 then
				-- continuation
				print(env & 0xf, mx, 0, 29)
				print("\^:1500000000000000", mx - 1, 6, 29) -- 3 dots
			else
				print(env & 0xf, mx, 1, 29)
			end
		elseif flags & 0x10 > 0 then
			rectfill(mx - 1, 0, mx + 3, 6, 59)
			rectfill(mx - 2, 1, mx + 4, 5, 59)
			print("r", mx, 1, 14)
		else
			rectfill(mx, 1, mx + 2, 5, 59)
			rectfill(mx - 1, 2, mx + 3, 4, 59)
		end
	end
	
	function el:hover(msg)
		if msg.mx <= 24 then
			-- on label
			self.cursor = 1
		elseif msg.mx <= 32 then
			-- on relationship
			self.cursor = "pointer"
		elseif msg.mx <= 64 then
			-- on slider
			self.cursor = get_spr(50)
		elseif msg.mx <= 72 then
			-- on multiplier
			self.cursor = "pointer"
		else
			-- on modulator
			self.cursor = "pointer"
		end
	end
	
	function el:click(msg)
		if 32 <= msg.mx and msg.mx <= 64 then
			local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
			self.dragged = {
				y0 = msg.my,
				val10 = val1,
				val00 = val0,
			}
			self.show_val1 = msg.mb == 1
			self.show_val0 = msg.mb != 1
			self.cursor = 0 -- TODO: capture mouse
		elseif msg.mx <= 24 and msg.mb == 2 then
			self.show_val0 = true
		end
	end
	
	function el:tap(msg)
		local flags, val1, val0, env = sfx.node_param(app.instrument, self.node_id, self.param)
		local node_type = sfx.node_type(app.instrument, self.node_id)
		if msg.mx <= 24 then
			-- Tap on label
			
		elseif msg.mx <= 32 then
			-- Tap on relationship symbol -----------------
			if node_type >= 8 then
				-- effects don't have relationships
				sfx.set_node_param_flags(app.instrument, self.node_id, self.param, flags & ~0x3)
			elseif self.label == "tune" then
				if flags & 0x3 == 0x0 then
					self.min_val, self.max_val = -128, 127
					-- set bit: add parent
					sfx.set_node_param_flags(app.instrument, self.node_id, self.param, flags | 0x1)
				elseif flags & 0x3 == 0x1 then
					self.min_val, self.max_val = 0, 255
					-- set bit: mul parent
					sfx.set_node_param_flags(app.instrument, self.node_id, self.param, (flags & ~0x3) | 0x2)
				else
					-- either `flags & 0x3 == 0x2` or inconsistent state
					self.min_val, self.max_val = -128, 127
					-- set bit: replace parent
					sfx.set_node_param_flags(app.instrument, self.node_id, self.param, flags & ~0x3)
				end
			elseif flags & 0x3 > 0 then
				-- set bit: replace parent
				sfx.set_node_param_flags(app.instrument, self.node_id, self.param, flags & ~0x3)
			elseif self.label == "vol" or self.label == "mix" then
				-- set bit: mul parent
				sfx.set_node_param_flags(app.instrument, self.node_id, self.param, flags | 0x2)
			else
				-- set bit: add parent
				sfx.set_node_param_flags(app.instrument, self.node_id, self.param, flags | 0x1)
			end
									
		elseif msg.mx <= 64 then
			-- Tap on slider ----------------------------
		
		elseif msg.mx <= 72 then
			-- Tap on multiplier ----------------------------------
			local mult = env & 0xe0
			if msg.last_mb == 1 then
				if     mult == 0x00 | 0x00 then mult = 0x00 | 0x40 -- *4
				elseif mult == 0x00 | 0x40 then mult = 0x00 | 0x80 -- *16
				elseif mult == 0x00 | 0x80 then mult = 0x00 | 0xc0 -- *64
				elseif mult == 0x00 | 0xc0 then mult = 0x20 | 0xc0 -- /64
				elseif mult == 0x20 | 0xc0 then mult = 0x20 | 0x80 -- /16
				elseif mult == 0x20 | 0x80 then mult = 0x20 | 0x40 -- / 4
				elseif mult == 0x20 | 0x40 then mult = 0x00 | 0x00 -- .
				else -- mult == 0x20 | 0x00
					mult = 0x00 | 0x40
				end
			else
				if     mult == 0x00 | 0x00 then mult = 0x20 | 0x40 -- /4
				elseif mult == 0x20 | 0x40 then mult = 0x20 | 0x80 -- /16
				elseif mult == 0x20 | 0x80 then mult = 0x20 | 0xc0 -- /64
				elseif mult == 0x20 | 0xc0 then mult = 0x00 | 0xc0 -- *64
				elseif mult == 0x00 | 0xc0 then mult = 0x00 | 0x80 -- *16
				elseif mult == 0x00 | 0x80 then mult = 0x00 | 0x40 -- * 4
				elseif mult == 0x00 | 0x40 then mult = 0x00 | 0x00 -- .
				else -- mult == 0x20 | 0x00
					mult = 0x00 | 0x00
				end
			end
			sfx.set_node_param_env(app.instrument, self.node_id, self.param, (env & ~0xe0) | mult)
			
			--[[
			local ctrl_held = key("ctrl")
			local val = env & 0xe0
			if (val == 0)        then val = 0x00 | 0x40 -- *4
			elseif (val == 0x40) then val = 0x20 | 0x40 -- /4
			elseif (val == 0x60 and ctrl_held) then val = 0x00 | 0x80 -- *16
			elseif (val == 0x80 and ctrl_held) then val = 0x20 | 0x80 -- /16
			elseif (val == 0xa0 and ctrl_held) then val = 0x00 | 0xc0 -- *64
			elseif (val == 0xc0 and ctrl_held) then val = 0x20 | 0xc0 -- /64
			else val = 0 end
			sfx.set_node_param_env(app.instrument, self.node_id, self.param, (env & ~0xe0) | val)
			]]
		else
			-- Tap on modulator -------------------------------
			if flags & 0x4 > 1 or msg.last_mb == 1 then
				sfx.set_node_param_flags(app.instrument, self.node_id, self.param, flags ^^ (msg.last_mb == 1 and 0x4 or 0x8))
			else
				-- toggle rng
				sfx.set_node_param_flags(app.instrument, self.node_id, self.param, flags ^^ 0x10)
			end
			
		end
	end

	function el:doubleclick(msg)
		if 32 <= msg.mx and msg.mx <= 64 then
			if msg.mb == 1 then
				sfx.set_node_param_val1(app.instrument, self.node_id, self.param, 0)
			else
				sfx.set_node_param_val0(app.instrument, self.node_id, self.param, 0)
			end
			self.dragged = nil
		end
	end
	
	function el:drag(msg)
		if self.dragged then
			local flags, _val1, _val0, _env = sfx.node_param(app.instrument, self.node_id, self.param)
			local delta = msg.my - self.dragged.y0
			if key("shift") then
				delta = (delta - 3) / 6
			end
			local val0 = self.dragged.val00
			local val1 = self.dragged.val10
			-- Handle signed i8s
			if (el.max_val < 128) then
				if (val0 >= 128) val0 -= 256
				if (val1 >= 128) val1 -= 256
			end
			if msg.mb == 1 then
				local new = val1 - delta
				new = mid(self.min_val, new, self.max_val)
				sfx.set_node_param_val1(app.instrument, self.node_id, self.param, new)
			else
				local new = val0 - delta
				new = mid(self.min_val, new, self.max_val)
				sfx.set_node_param_val0(app.instrument, self.node_id, self.param, new)
			end
		end
	end
	
	function el:release(msg)
		self.dragged = nil
		self.show_val0 = false
		self.show_val1 = false
	end
	
	function el:update()
		---[[ show values on hover?
		local mx, my, mb = mouse()
		if mb == 0 then
			if self.sx <= mx and mx < self.sx + self.width
				and self.sy <= my and my < self.sy + self.height
			then
				self.show_val1 = true
			else
				self.show_val1 = false
			end
		end
		--]]
	end
	return el
end


-- Other widgets -------------------------------------------------------------------


function synth.attach_mute_toggle(parent, el)
	el.x = 1
	el.y = 1
	el.width = 3 + 4 * #(el.label .. " " .. el.node_id) + 3
	el.height = 9
	el.cursor = "pointer"
	parent:attach(el)
	el.muted = (sfx.node_flags(app.instrument, el.node_id) & 0x2) > 0
	function el:draw()
		local label = self.label .. " " .. self.node_id
		print(label, 3, 1, 63)
		if self.muted then
			line(1, 3, 3 + 4 * #label, 3, 24)
		end
	end
	function el:tap()
		self.muted = not self.muted
		local flags = sfx.node_flags(app.instrument, self.node_id)
		if self.muted then
			flags |= 0x2
		else
			flags &= ~0x2
		end
		sfx.set_node_flags(app.instrument, self.node_id, flags)
	end
	return el
end




function synth.attach_close_button(parent, el)
	el.x = 75
	el.y = 2
	el.width = 12
	el.height = 9
	parent:attach(el)
	function el:draw()
		pal(7, 60)
		spr(36, 0, 0)
		pal(7, 7)
	end
	function el:tap()
		sfx.delete_node(app.instrument, self.node_id)
		app.refresh_gui = true
	end
	return el
end

return synth
:: src/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTA3IDA4OjE0OjAwIixzdG9yZWQ9IjIwMjQtMDQt
MDcgMDg6MTQ6MDAiXV1sejQABAAAAAMAAAAwbmls
:: todo.txt
--[[pod_format="raw",created="2024-04-10 20:46:30",modified="2024-04-10 20:46:41",revision=1]]
- add 4/4 config

:: .info.pod
b64$LS1bW3BvZCxhdXRob3I9ImRyYWttYW5pc28iLGljb249dXNlcmRhdGEoInU4IiwxNiwxNiwi
MDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDcw
NzAxMDAwMDAwMDEwNzBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwMTAwMDEwNzBkMGQwZDBkMGQwZDA3
MGQwZDBkMGQwZDA3MDEwMTA3MGQwZDBkMGQwZDBkMDcwNzBkMGQwZDBkMDcwMTAxMDcwZDBkMGQw
ZDBkMGQwNzBkMDcwZDBkMGQwNzAxMDEwNzBkMGQwZDBkMGQwZDA3MGQwNzBkMGQwZDA3MDEwMTA3
MGQwZDBkMGQwNzA3MDcwZDBkMGQwZDBkMDcwMTAxMDcwZDBkMGQwNzA3MDcwNzBkMGQwZDBkMGQw
NzAxMDEwNzBkMGQwZDBkMDcwNzBkMGQwZDBkMGQwZDA3MDEwMTA3MGQwZDBkMGQwZDBkMGQwZDBk
MGQwZDBkMDcwMTAxMDYwNzBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwNjAxMDEwNjA2MDcwNzA3MDcw
NzA3MDcwNzA3MDcwNjA2MDEwMDAxMDYwNjA2MDYwNjA2MDYwNjA2MDYwNjA2MDEwMDAwMDAwMTA2
MDYwNjA2MDYwNjA2MDYwNjA2MDEwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAi
KSxub3Rlcz0iTXVzaWMgVHJhY2tlciIscnVudGltZT01LHN0b3JlZD0iMjAyNC0wNC0xNCAxMzox
NjozMCIsdGl0bGU9IlZpc2lUcmFjayIsdmVyc2lvbj0iMC4wLjIiLHdvcmtzcGFjZXM9e3tsb2Nh
dGlvbj0ibWFpbi5sdWEjMjQwIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJzcmMvYXBw
Lmx1YSMzNiIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ic3JjL2VkX2luc3QubHVhIzEw
MSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ic3JjL3N5bnRoLmx1YSM2MzkiLHdvcmtz
cGFjZV9pbmRleD0xfSx7bG9jYXRpb249InNyYy9zZngubHVhIzE4OSIsd29ya3NwYWNlX2luZGV4
PTF9LHtsb2NhdGlvbj0ic3JjL3JvdXRpbmcubHVhIzY3Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xv
Y2F0aW9uPSJnZngvMC5nZngiLHdvcmtzcGFjZV9pbmRleD0yfSx7bG9jYXRpb249Im1hcC8wLm1h
cCIsd29ya3NwYWNlX2luZGV4PTN9LHtsb2NhdGlvbj0ic2Z4LzAuc2Z4Iix3b3Jrc3BhY2VfaW5k
ZXg9NH0se2xvY2F0aW9uPSJzZngvMS5zZngiLHdvcmtzcGFjZV9pbmRleD03fX1dXWx6NAAEAAAA
AwAAADBuaWw=
:: [eoc]
