picotron cartridge // www.picotron.net
version 2

:: gfx/
:: map/
:: sfx/
:: src/
:: pal/
:: drak.lua
--[[pod_format="raw",created="2024-04-07 07:42:45",modified="2024-04-12 11:41:04",revision=975]]

-- A 'require' function similar to standard Lua.
-- Idea from elgopher on the BBS
function require(name)
	if (_modules == nil) _modules = {}

	local cached = _modules[name]
	if (cached) return cached

	local filename = fullpath(name .. '.lua')
	local src = fetch(filename) 

	if (type(src) != "string") panic("could not include " .. filename)

	-- https://www.lua.org/manual/5.4/manual.html#pdf-load
	-- chunk name (for error reporting)
	-- mode ("t" for text only -- no binary chunk loading)
	-- _ENV upvalue
	-- @ is a special character that tells debugger the string is a filename
	local func, err = load(src, "@" .. filename, "t", _ENV)
	if (not func) panic("Syntax error:", tostr(err))

	local module = func()
	_modules[name] = module

	return module
end


function panic(...)
	local args = { ... }
	foreach(
		args,
		function(str)
			send_message(3, { event = "report_error", content = str })
		end
	)
	stop()
end


-- Table utility functions --------------------------------------------------------


function tostrrec(t)
	if type(t) != "table" then
		return tostr(t)
	end
	
	local s = nil
	for k, v in pairs(t) do
		if not(s) then
			s = "{ "
		else
			s ..= ", "
		end
		s ..= tostr(k) .. " = " .. tostrrec(v)
	end
	s ..= " }"

	return s
end


-- Char utilities -----------------------------------------------------------------


function keyp_num()
	if (keyp("9")) return 9
	if (keyp("8")) return 8
	if (keyp("7")) return 7
	if (keyp("6")) return 6
	if (keyp("5")) return 5
	if (keyp("4")) return 4
	if (keyp("3")) return 3
	if (keyp("2")) return 2
	if (keyp("1")) return 1
	if (keyp("0")) return 0
	return nil
end


function keyp_hex()
	if (keyp("f")) return 0xf
	if (keyp("e")) return 0xe
	if (keyp("d")) return 0xd
	if (keyp("c")) return 0xc
	if (keyp("b")) return 0xb
	if (keyp("a")) return 0xa
	if (keyp("9")) return 0x9
	if (keyp("8")) return 0x8
	if (keyp("7")) return 0x7
	if (keyp("6")) return 0x6
	if (keyp("5")) return 0x5
	if (keyp("4")) return 0x4
	if (keyp("3")) return 0x3
	if (keyp("2")) return 0x2
	if (keyp("1")) return 0x1
	if (keyp("0")) return 0x0
	return nil
end

function is_num_char(c)
	if (not c) return
	return ("0" <= c) and (c <= "9")
end


function is_hexa_char(c)
	if (not c) return
	local is_num = ("0" <= c) and (c <= "9")
	local is_hex_alpha = ("a" <= c) and (c <= "f")
	return is_num or is_hex_alpha
end


function p8_centered_print(s, x, y, col)
	local count = #s
	print(s, x - ((count * 4) \ 2), y, col)
end



-- Drawing -------------------------------------------------------------------------


-- From Sophie on the discord
function get_drawspace()
    return {
        cam_x=peek4(0x5510),
        cam_y=peek4(0x5514),
        clip_l=peek2(0x5528),
        clip_t=peek2(0x552a),
        clip_r=peek2(0x552c),
        clip_b=peek2(0x552e),
    }
end


function set_drawspace(drawspace)
    poke4(0x5510,drawspace.cam_x)
    poke4(0x5514,drawspace.cam_y)
    poke2(0x5528,drawspace.clip_l)
    poke2(0x552a,drawspace.clip_t)
    poke2(0x552c,drawspace.clip_r)
    poke2(0x552e,drawspace.clip_b)
end

:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2Iixtb2RpZmllZD0iMjAyNC0w
NC0xMiAyMToxNDoyOCIscmV2aXNpb249Mjk5OF1dbHo0AMsCAACeMwAA8yV7WzBdPXtibXA9cHh1
AEMgCAgEMAdgF1AHAAdABwAHICcwN0AXsCxmbGFncz0wLHBhbl94CADHeT0wLHpvb209OH0sQgBz
EBAE8CEXAAIAExAIAEMAF-ACCQAPFQAkHxGFAAsdOYUA1SsnkFdgVxAHYCdAB2ACAP8BQCdgBzA3
QCdAF0A3wBfwG1YAHfYHJBfABxAHsAcQB6AHMAeQBzAHgBcABwIAE4AWABOgJgBPwBfwFGQAHfIG
Iq8RMM4gTgduIE4XXiBOJ04gTjc_CAAhF14YAF-OMK7wE1cAHp2uMM4gziA_Rz4EAB-OUgAjH-Ax
AEr-BQsGBAAnYAcgB1AHkAeQByAHYCdgQAALHjdAABEglgFRIAcAV1AKAJ9AVyAHEAcABxBMAB4S
N4sABwQAHzdDAB4GjgAChgAJDAAPTwAeYEdQB5AncB0BL0dQOwAgQAeQN2AGAA87AB0TEEkBAVEB
IzcQWQEfkJsBHgTbASAQF04BP2A3UN0BLiQQF00BPxA3UJAAJEUgB1BH4gEPkgAoA9UBFUcKAA5Q
AA9zAhQvN2BxAiMOcQMPMQCfnxMdBP8Ym-D-bTUAHI-wm-8YT-D-DjcAHW-6-xh18Ig2AB1f-4D-
GIg5AR4PMQCsggcHBHJPOxJOAgAfcjsACy8xMTwAAXIOLxEOEg4tBAAPQwAPD_EAHg8xAO-wBQkJ
BMAHcBdgJyBnEAcQJyAHEBcwlggPRAAe-wIQBzAXEAcgJxAHEGcgJ2AXcEQAHjeQZxACAB_QawIc
-wEwDxZAHjAuID4wLkAeUA4QPwAc-wEQDxZQHkAuMD4gLjAeQA4wPwAZ-wcKDATQB-ACF4AHgAdw
J-AKR1AncAdAQgAofwwHcCdQRyAqAh4PMQD-----------------------------------------
------------AVBtPTd9fQ==
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2IixzdG9yZWQ9IjIwMjQtMDMt
MjQgMDA6NDg6MDYiXV1sejQABAAAAAMAAAAwbmls
:: label.png
b64$iVBORw0KGgoAAAANSUhEUgAAAeAAAAEOCAIAAADe_FMwAAAV60lEQVR4Ae2dX2gkx53He9oN
pweBQXDdDws67tbyQ8MsCCwYLRZkCJwZMMZ-sohhHCyjXUEwVkCIcCw_79gx_5AIBcsYg2SxAnsY
hBc7mIBIXsYgI0EmIFiBHrLRQRYEHgUEC-uweTB7D3X09nWPWt3V-7s-Hxqpuqe_9avfr6q_9Vp5
8vAHBQAAsoeWcLzvn72e2Vq8_PBz0fjis499Sn7_i1_yhwAgJipPHv5gf3d7U4QeFNSdhWP6VAXq
7DGIf3fGowHciBMkzoW97dHZ0d--sfLZ37_tnXf8L5zPF599-PNf-FL89e_HwrU80PyUIFAyURnW
iw8-F25rNfx0BoCMuLNofPHZx4Fsy6cjB7Uae_fzXDgMQd3Zp0c7DdqRhojqJ_eYOG-21ne3Lwdy
dgCASC4MiftDeJSHRzsN2gogRve_aob_GqFrnzd7h-OKDuJvfI7sfVcBQIRO5-9UZmHyjmlEaBRO
g7Y70YXJx12d89zWcm3RQbxanR2-RrgAeDRAHO5mP1b_T5nVzb8RXThyMo5vtyZhVgEMWuTgKJn-
bJPM0O7L9oQ9fpW_3nFngNwR9Mye1z9CWwtkSk6DDmRDsXrx989eF3eLlY-deSVSTXilAUqIMJAv
PvtYmIM4Nd5G4ThZsR40n5Zl7_ZnPoHm7PYxDypPHv6Q2OIl6adyvPjw86D7I9ZbCgDKjEoJAACy
SeX9iTeoAgBABlEpAQAABg0AAAHQip3eh_1XvDu83-6WTQAA2aTy-sQbpXXnODx6a2zAroJiMHdm
UIR00cqT6pOXX6r84Y_RD-vc-PN-2-wrOwmKTch9vjU2uNDurT7uzltjg3LeH--PoL-88UA03nxm
UrTffGbS-pP13f7TedqhbeuvXfvBXz4VjVsvvOOnnR2Pfm7__fN__vuf7orGv-3nz_xtd8_PXpsR
jfe_2RXt977ZHTqmu_d5naV7Wn_jHfO8KiWQ0YU9xU9Be3qvkdyYPnteuEZyY6br0UMtOEIiMZDk
Ue0vwjct97TsVViq-VeHww7VOn7yxl41qy0a7r9hePLySwm4s9uOh1qzhXU8Ljwn9p7enSV6Xoi9
p-ewEmMGmmckPR0-_ewZKLT-MaMt5oXD_h8z0J6-0KPTcudbL7wjHuHUIpGQ6QyP9fq1D16-FtVo
ms9_wqn9WK3V3_ostO7vQ_83RzsOnrz8UuUPf4zbnePmo9dm4ugctKefc_6-Z7oZsUZ_ej43--zf
Nv8q7chbY4O5M_O8PnE7taIot154Z_j3D9uvBBpnfG3D-moldevrryI0aNVPpzefmfRvzZbE8mW7
1v7dUTWrcOdVMCrCu7OiKP73aHy8982uT9fz3y3ynpFbc0wZsUYx7fy5M8PuyA53dnwRnd194uC5
_edTP8LBDFpYp9tAv-zx4MsfD4J6dDaJxJ197tS--_nu0Labj16bsTesV4_eou2np3c373CRjBl5
9KjGdFT7wmK6--oZ009PP0vpJynpMX1WLKg7e3ixn_9x8MFfPhWJhMwlIb96f_KNAtjuUD5sv2J-
ffLyS0Pd_f32tyHvYftKb40NilpPKBt233Tsc59sjQ3EIFbDT_ehP4W0deHLiqLceuGdkEldEOj1
a-8X6OuvMOgABn0eIQ3az04CyLtBQyoU2aD9eHS07gwAgEEDABQflRIAAGSTSqNai3C4Zqve7fTK
Uz7dNE6PBuRLvsWA85s1VO4oAIASGXSzVW_26v6-F_Ae1k3jvO9DfyLfYuRr-S0S4py6j2qxz697
HbOwn7U4Bu12ekMX8rzveef0aDB0FU_PBoU8wORbbLqdnrDj8pzfofs2C-s5FoMG6wYmZfLNHYV0
YYlFzMLiYtBJXM6lyrc8Hi0Wt5D5djs9zmkWzq8a3w1s3cOORvHuZ3FErYNqP7G6aRTvAJ_XbyGT
9V7fotJs1ctzfh1bN1Pnt9Ko1qJd11LdvbpppH7Hki-5cn6Lur5a0Hwi6VOwNSZf8iVf8k3foBVF
2ente-z600nz_vaPclN5Q-9z7la3UZ-2LkjBIN9i89NJk-XNFGqpbksAgByhxTTuiw8-t9rfP3s9
sXwG9_9ZbWPiirQ8qDZk3LTyjSR0SWolnW8e1zfFfQV2VPFPNw3xONrNVl08EkN--_x18Qiz-u5X
r4on7pSMiSviEZvs3bnb4vGzKd1a669EXP-aaPNNIG7ktfK5RjndG7lb3xTXCOxoVuv0aCBM2dHu
dnpyBu3mJ7-5faDzH1WSn2zdTKCUYh_LnS3nd-mKGy3_1yine6MA65vMGqEdbtAJ8N2vXvVp09G6
hrj2-Wwv6zA4tH6w5mxVXEIrQVpxw9QqzBrlem-kaH3TWiO0dtTE3Pknv-m9H2uOnE_2bvq-_Y2J
K_KR0IaJm1a_YShbrSLMNxfrm5G4JUezWrppDG03W3W5oV98_LlofP-sdUVRvvvVq8mkNLh-z341
iWs-_biJkVbcAqxRYnELsK9yUaviUWlUa-5766ax09v36LCyNP-v-3UoN5U39D-nrnyN_rR3QQoG
_RablaX55dVN1jc7aJGPmEefBQAohUELTn-3W_8Ob337tdWO8BILEzctLXVmzkVaX4gQNZvTWlma
L9UypJVvHuvMnIsdF60dzf4y9fiSu0d-5CT5BV5e3SyVQaeVbx7rzJyLHRetnUqjWrMb9NbYwP7z
3JlhN2jdNHZ6_963Qam8tVGf9i4I_ZJvjuD8Zg3N-enB4g3RGF-bKM9SAQDkwKAjYfD2mqIoxp3F
hPMJEzctLXVmzsSFoagxjZvW0oaJm5aWOjNn4sJQNPen8bUN6gIAkDmDnjszKAoAQBaoNKo1-711
09jp7Xt0WFmaX17dVBRl8Paa_GLcWZSYljVOUMLEldA26tOiIHnMVyJuJPnmqFZlW9-Uz2-CWmt9
MztnLSbjl1tXC_lsw8RNS5tWvnmsM3Mudly0DtSYDBoAAEKCQQMAYNAAAIBBAwBg0AAAkEODXlma
R4sWLVq00tpKo1rzP5ZuGju9fe9gy6ub5bnfGvVp74KQL-nmCM5v1lDLsxgAAPlCCyoYHR0N2aFg
kC-5ki-5xoTKHQUAkE20guVzfLBntS9PXk0ldJJx08qXuOxnSM6gddMQjdOjgb3dbNUVRel2ejlK
ydpPxwd7lyevvv2zm_L1zt3bse7mVOKmlS9xix03xf0MdlSrdXo0cLfDWLP98k9S6_DO3dv_txRx
iUvcdOOitaMlcPMnrHVjXf6xxnUU2n-QaPMtW9zE1rdsdU5rP6NNyKCzw527twNtr5CFtnb2nbu3
08q3bHETWN_y1Tk7_7nMPDVo3TTc7WarLv52O728pGTtJ7HDUjm6AhE67m3tyLdscRNb37LVOa39
DHYqjWrNf2-dNHb7hx4d2guz7fXt8pRvZqrqXRDyJd8cwfnNGip3FABANtEKls---PqWd4e3vv3a
akd4eRKXuMSFyFHjG7q9MJuKNq05E5e4xE337BdPq9lfph5fcvfoj5xIBl7flp90CG2ojUVc4hI3
1bhozzVoRVG2xgb217kzI5UFluY--vsD7w67xCUucbMaFy4waEVRHizeEI3xtQ0KBACQIYPONcfX
biuKcvmrm8QlLnFzFxccqAXLJ60tRVziEhciR3N-Gl-boC4AAJkz6Lkzg6IAAGQB1f7SHzlxP9JD
txdmk9ceX7tt-SUucYmbr7hoHVQa1Zr-sXTT2O0fegdrr2_X536bmap6F4R8yTdHcH6zhlqexQAA
yBcYNAAABg0AABg0AAAGDQAAOTTo9sIsWrRo0aKV1lYa1Zr-sXTT2O0fegdrr2_X536bmap6F4R8
yTdHcH6zhlqexQAAyBdaUMGjR49CdigY5Eu_5Eu_MaFyRwEAZBMtpnEH9_9ZbWPiSi60dnnCcVPB
Pueg005xjSJJOS97I4-7CiJEFf900xCPo91s1cUjMbQxcUU8YpO9O3fb_ptN7eD_PbdWPHHPOS2s
OYvDn-01CunO0usb_d4o9r6CqNCs1unRQJiyvd3t9IRNl60uwrA_2bqZzGEQ5z8VrZVsXgiTrwO5
9Q2-N8qwr9BGon1q0EOJ1prD7MgktXbbSiZuGMeJVpv9NQqTr1jZfO2NYuwrtHJa9UJ9t9Prdnrh
3fmTrZufbN3MhdZeslTmnBY5WiPpwyAe6fWNZG_UbV_BNJrV0k1jaLvZqgubDjr04P496eslFa0x
ccXSCt6du53MnNPCnm-Qaae1vhHif32j3RuF31cQFZVGtea-t24aO719jw4rS-PLq5vlKV_jPu1d
EPIl3xzB_c0aKncUAEA20WIa9-R3v-Xu8Na3X1ttxyVWNm1alK1W7CvIHSolyAIrS-OpaMtWK-YV
2nxpNfvL1ONL7h79kRM2etwsr26moi1brdhXaPOlrTSqNbtBb40N7D-PnRl2g9ZNY6e3730blOr8
NOrT3gUhX-LNEZzfrKG5Pz1YvCEa42sb5VkqAIAcGHQkDN5eUxTFuLOINrOUrVbsK8gdakzjhtlS
ZdOmRdlqxb6C3KG5P42vbVAXAIDMGfTcmUFRAACyQKVRrfnvrZvGTm-fo8PK0vzy6qaiKIO318QX
485i0DnlSNuoT4uChIlrr1uS2rTyTatWecw34VrZ_6eyJxPWWuub2TlrMRm-3H4qp1ZRFOnVDaMt
W63YV2hzp1VjMmgAAAgJBg0AgEEDAAAGDQCAQQMAQA4NemVpHi1atGjRSmsrjWrN-1i6aez09r2D
La9ulud_a9SnvQtCvuSbIzi-WUMtz2IAAOQLLahgdHQ0ZIeCQb7kS77kGxMqdxQAAAYNAADBDVo3
DfE42s1WXTxUCgAgHYNWFOX0aOBudzu9bqcnN-TxwZ70tNCiRYsW7VODPo9mqy4X_PLkVelJo0WL
Fi3aiw262_lJxwYAAGk0q6WbhrvdbNWpEQBAmgZ9ejSwPtnb3U6PGgEApIJKCQAAMGgAAMiGQbcX
ZtGiRYsWrbS20qjWrJepx5fcPfojJ1ZbN43d-qF3sPb6dnnut5mpqndByJd8cwTnN2tojvetsYH9
de7MKM9qAQBk2qAVRXmweEM0xtc2KBAAQFqolAAAAIMGAIAAaO5P42sb1AUAIHMGPXdmUBQAgCyg
2l-6IyfuR3ro9sIsWrRo0aKV1lYa1Zr-sXTT2O0fegdrr2_X536bmap6F4R8yTdHcH6zhlqexQAA
yBcYNAAABg0AABg0AAAGDQAAOTTo9sIsWrRo0aKV1lYa1Zr-sXTT2O0fegdrr2_X536bmap6F4R8
yTdHcH6zhlqexQAAyBdaUMGjR49CdigY5Eu_5Eu_MaFyRwEAYNAAUFL_5V9nKIK8QeumIR5Hu9mq
W38BAOTc_cHep3i0vEErinJ6NBjalmZw-x5atGjRCnx6NLUabtDn0WzV5QIbE1ekJ40WLdriaf14
NLUKYNDdTq-b6UnHBgAI6tFgoVkt3TSGtgEAImH86juKovzzH7uUIphBnx4NrE-2tqDb6VEpAJDj
n--YFdb8YO9T0YBgBg0AEKtHK4piTFyhFIFQKQEAQOkMemVpHi1atGjRSmsrjWrNepl6fMndoz9y
YrV109jp7XsHW17dLM-91qhPexeEfMk3R3B_s4bmeN8aG9hf586M8qwWAECmDVpRlAeLN0RjfG2D
AgEApIVKCQAAMGgAAAiA5v40vrZBXQAAMmfQc2cGRQEAyAKq-aU-cuJ_pIdeWZpHixYtWrTS2kqj
WvM-lm4aO71972DLq5vlud8a9WnvgpAv_eYIzm-WUMuzGAAA_QKDBgDAoAEAAIMGAMCgAQAghwa9
sjSPFi1atGiltZVGteZ-LN00dnr73sGWVzfLc7816tPeBSFf8s0RnN_soZZnMQAA8oUWVDA6Ohqy
Q8EgX-IlX-KNCZU7CgAAgwYAgOAGrZuGeBztZqsuHioFAJCOQSuKcno0GNrudnrdTk9i6OODPelp
oUWLFi3apwZ9Hs1WvdmqSwS_PHlVetJo0aJFi1bzFnc7PeHR0uEBAECOpwatm4a7jTUDAKRs0KdH
A_uTvd3t9KgRAEAqqJQAAACDBgCAbBh0e2EWLVq0aNFKayuNas16mXp8yd2jP3JitXXT2O0fegdr
r2_X536bmap6F4R8yTdHcH6zhuZ43xob2F-nzozyrBYAQKYNWlGUB4s3RGN8bYMCAQCkhUoJAAAw
aAAACIDm-jS_tkFdAAAyZ9BzZwZFAQDIAqr9pT9y4n6kh24vzKJFixYtWmltpVGt_R9LN43d-qF3
sPb6dnnut5mpqndByJd8cwTnN2uo5VkMAIB8gUEDAGDQAACAQQMAYNAAAJBDg24vzKJFixYtWmlt
pVGt_R9LN43d-qF3sPb6dnnut5mpqndByJd8cwTnN2uo5VkMAIB8oQUVPHr0KGSHgkG_5Eu_5BsT
KncUAAAGDQAAwQ1aNw3xONrNVp0aAQCkadCKopweDYa2pRncv4cWLVq0aKW1Tw36PJqterNVlwhs
TFyRnjRatGjRor3YoLudnnRsAACQ5qlB66YxtN1s1SkTAEDyaOLf6dHA_mRvdzs9agQAkAoqJQAA
wKABACAbBr2yNI8WLVq0aKW1lUa1Zr1MPb7k7tEfObHaumns9Pa9gy2vbpbnfmvUp70LQr7kmyM4
v1lDc7xvjQ3sr3NnRnlWCwAg0watKMqDxRuiMb62QYEAANJCpQQAABg0AAAEQHN-Gl-boC4AAJkz
6Lkzg6IAAGQB1f7SHzlxP9JDryzNo0WLFi1aaW2lUa35H0s3jZ3evnew5dXN8txvjfq0d0HIl3xz
BOc3a6jlWQwAgHyBQQMAYNAAAIBBAwBg0AAAkEODXlmaR4sWLVq00tpKo1rzP5ZuGju9fe9gy6ub
5bnfGvVp74KQL-nmCM5v1lDLsxgAAPlCCyoYHR0N2aFgkC-5ki-5xoTKHQUAgEEDAEBwg9ZNQzyO
drNVFw_VAgBIx6AVRTk9Grjb3U6v2_nJDX18sCc9LbRo0aJF_9SgI_fy5FW0aNGiRSutjdGgAQAg
DE8NWjeNoW0AAEgFTfw7PRpYn_xtQbfTo1IAAAmjUgIAAAwaAACyYdDthVm0aNGiRSutrTSqNetl
6vEld4-_yInV1k1jt3-oHay9vl2e_21mqupdEPIl3xzB_c0amuN9a2xgf507M8qzWgAAmTZoRVEe
LN4QjfG1DQoEAJAWKiUAAMCgAQAgAJr70-jaBnUBAMicQc_dGRQFACALqPaX-siJ_5Eeur0wixYt
WrRopbWVRrXmfyzdNHb7h97B2uvb5bnfZqaq3gUhX-LNEZzfrKGWZzEAAPKFRgkAAJLk_GBPNC5P
XnW0rb-io0qxAACS5PLkVcuCHW1HT41iAQAkzPHBnqNhvdptWqVSAAAJY3fhy5NXxavDneM16PbC
LFq0aNGidXB8sHd8sOfxarUrjWrN-7i6aez2D70n2l7fLs81ODNV9S4I_ZJvjuD8Zg21PIsBAAAA
AAAAAMXlfwEsAA7jlHGMXgAAABB0RVh0TG9kZVBORwAyMDExMDIyMeNZtsEAAAAASUVORK5CYII=
:: main.lua
--[[pod_format="raw",created="2024-03-24 00:48:06",modified="2024-04-12 21:14:28",revision=3553]]
include "drak.lua"
local app = require "src/app"
local settings = require "src/settings"
local sfx = require "src/sfx"
local file = require "src/file"
local detail = require "src/detail"
local ed_inst = require "src/ed_inst"
local ed_trak = require "src/ed_trak"
local ed_patt = require "src/ed_patt"
local note_grid = require "src/note_grid"
local synth = require "src/synth" -- TODO: temporary, remove


function _init()
	window {
		tabbed = true,
		icon = --[[pod_type="gfx"]]unpod("b64:bHo0AB4AAAAcAAAA8A1weHUAQyAICAQwB2AXUAcAB0AHAAcgJzA3QBew")
	}

	wrangle_working_file(
		file.save,
		file.load,
		file.default_filename
	)
	
	poke(0x4000, get(fetch("/system/fonts/p8.font")))
	
	poke4(0x5000, get(fetch("pal/0.pal")))
end


function _update()
	if keyp(settings.keys.play) then
		sfx.play_or_pause()
	end
	if app.refresh_gui then
		generate_gui()
		app.refresh_gui = false
	end
	app.gui:update_all()
end


function _draw()
	cls()
	app.gui:draw_all()
	print(string.format("\014% 3.0f", (stat(1) * 100.0)) .. "%", 462, 250, 7)
end


function generate_gui()
	local cell_width = 14
	local cell_height = 29
	app.gui = create_gui()
	local top_panel = attach_top_panel(app.gui, { x = 0, y = 0 })
	if app.view == "patt" then
		ed_patt.attach_pattern_selector(top_panel, { x = 98, y = 0})
		ed_patt.attach_channel_panel(app.gui, { x = 0, y = 16})
		note_grid.attach(app.gui, { x = app.channels_width, y = 16 })
	elseif app.view == "trak" then
		ed_trak.attach(app.gui, { x = 0, y = 16 })
	elseif app.view == "inst" then
		ed_inst.attach(app.gui, { x = 0, y = 16 })
	end
	if app.detail then
		detail.attach_panel(app.gui, { x = 480 - app.detail_width, y = 16})
	end
end


function attach_top_panel(parent, el)
	el.width = 480
	el.height = 16
	parent:attach(el)

	attach_view_selector(el, { x = 22, y = 0 })
	attach_play_button(el, { x = 1, y = 0 })
	attach_detail_button(el, { x = 480 - 16, y = 0})
	attach_note_attributes(el, { x = 380, y = 0})
		
	function el:draw()
		rectfill(0, 0, el.width, el.height, 2)
	end	

	return el
end


function attach_play_button(parent, el)
	el.width = 16
	el.height = 16
	el.cursor = "pointer"
	parent:attach(el)

	function el:draw()
		spr(stat(464) == 0 and 4 or 5, 0, 0)
	end
	
	function el:click()
		sfx.play_or_pause()
	end
	
	return el
end


function attach_view_selector(parent, el)
	el.width = 3 * 20
	el.height = 16
	el.cursor = "pointer"
	parent:attach(el)
	
	function el:draw()
		--[[
		if app.view == "inst" then pal(7, 17) else pal(7, 59) end
		spr(3, 0, 0)
		if app.view == "trak" then pal(7, 17) else pal(7, 59) end
		spr(2, 16 + 4, 0)
		if app.view == "patt" then pal(7, 17) else pal(7, 59) end
		spr(1, 2 * 16 + 2 * 4, 0)
		pal(7, 7)
		--]]
		print("inst", 2, 6, app.view == "inst" and 7 or 62)
		print("trak", 2 + 20, 6, app.view == "trak" and 7 or 62)
		print("patt", 2 + 40 + 1, 6, app.view == "patt" and 7 or 62)
	end
	
	function el:click(msg)
		if msg.mx < 20 then
			app.view = "inst"
		elseif msg.mx < 2 * 20 then
			app.view = "trak"
		else
			app.view = "patt"
		end
		app.refresh_gui = true
	end
	
	return el
end

-- Default note attributes -------------------------------------------------------


function attach_note_attributes(parent, el)
	el.width = 78
	el.height = 16
	el.cursor = "pointer"
	parent:attach(el)
	
	el.drag_start = nil

	function el:draw()
		---rectfill(0, 0, self.width, self.height, 0)
		local note = app.base_note % 12
		local octave = app.base_note \ 12
		local is_sharp = (note == 1) or (note == 3) or (note == 6)
			or (note == 8) or (note == 10)
		pal(7, self.dragged_note and 7 or 7)
		if is_sharp then
			spr(8 + note, 2, 6)
		else
			spr(8 + note, 8, 6)
		end
		pal(7, 7)
		print(
			"\014" .. string.format("%1x", octave),
			2 + 12, 7,
			self.dragged_note and 7 or 22
		)
		local x = 20
		rectfill(x, 8, x + 20, 10, 59)
		rectfill(
			x, 8,
			x + min(20 * (app.base_volume / 64), 20), 10,
			self.dragged_volume and 7 or 17
		)
		if self.dragged_volume then
			print("\014" .. string.format("%2d", app.base_volume), 27, 2, 7)
		end
		print(
			"\014inst " .. string.format("%d", app.base_instrument),
			44, 7,
			self.dragged_instrument and 7 or 14 -- col 26
		)
	end	
	
	function el:click(msg)
		-- TODO: replace with pull-down menus
		if msg.mx < 18 then
			self.dragged_note = {
				y0 = msg.my,
				start = app.base_note
			}
		elseif msg.mx < 42 then
			self.dragged_volume = {
				y0 = msg.my,
				start = app.base_volume
			}
		else
			self.dragged_instrument = {
				y0 = msg.my,
				start = app.base_instrument
			}
		end
	end
	
	function el:drag(msg)
		if self.dragged_note then
			local delta = msg.my - self.dragged_note.y0
			if (delta == 0) return -- or else double click doesn't work
			local new_val = self.dragged_note.start - (((delta + 3) \ 6) * 12)
			app.base_note = mid(0, new_val, 120)
		elseif self.dragged_volume then
			local delta = msg.my - self.dragged_volume.y0
			if (delta == 0) return -- or else double click doesn't work
			local new_val = self.dragged_volume.start - (((delta + 1) \ 2) * 1)
			app.base_volume = mid(0, new_val, 0x40) -- TODO: handle vol > 64
		elseif self.dragged_instrument then
			local delta = msg.my - self.dragged_instrument.y0
			if (delta == 0) return -- or else double click doesn't work
			local new_val = self.dragged_instrument.start - (((delta + 3) \ 6) * 1)
			app.base_instrument = mid(0, new_val, 0xfe) -- TODO: handle vol > 64
			-- TODO: temporary, remove
			app.instrument = app.base_instrument
			synth.refresh_nodes()
		end
	end
	
	function el:release(msg)
		self.dragged_note = nil
		self.dragged_volume = nil
		self.dragged_instrument = nil
	end

	function el:doubleclick(msg)
		if msg.mx < 18 then
			notify("***")
			app.base_note = 48
		elseif msg.mx < 42 then
			app.base_volume = 0x32
		else
			app.base_instrument = 01
		end
	end
	
	return el
end


function attach_detail_button(parent, el)
	el.width = 16
	el.height = 16
	el.cursor = "pointer"
	parent:attach(el)
	
	function el:draw()
		pal(7, app.detail and 7 or 62)
		spr(app.detail and 45 or 46, 3, 2)
		pal(7, 7)		
	end	
	
	function el:tap()
		app.detail = not app.detail
		app.refresh_gui = true
	end
	
	return el
end


:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2Iixtb2RpZmllZD0iMjAyNC0w
NC0xMiAyMToxNDoyOCIscmV2aXNpb249Mjg3OV1dbHo0AGcAAABWEAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD--------------------78QgiKSxoaWRkZW49ZmFsc2UscGFuX3g9
MAgAwnk9MCx0aWxlX2g9OAkAwHc9OCx6b29tPTF9fQ==
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2IixzdG9yZWQ9IjIwMjQtMDMt
MjQgMDA6NDg6MDYiXV1sejQABAAAAAMAAAAwbmls
:: pal/0.pal
b64$LS1bW3BvZCxiZ19jb2xvcj0wLGJsYWNrZXN0X2NvbG9yPTAsY3JlYXRlZD0iMjAyNC0wNC0x
MCAwNDo1Mjo1MSIsaGlkZGVuPXtbMF09ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2V9LGhpZGRlbl90b2dnbGVzPXtbMF09ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2V9LGxv
Y2tlZD17WzBdPXRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRy
dWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVl
LHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSxm
YWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxz
ZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxm
YWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxz
ZSxmYWxzZSxmYWxzZSxmYWxzZX0sbW9kaWZpZWQ9IjIwMjQtMDQtMTAgMTY6NTY6NDUiLG9rcGFs
X3ZlcnNpb249IjAuMC40IixyZXZpc2lvbj0xODAsdGVzdF9jdWJlX2NvbG9ycz17WzBdPXsxNSwz
MSw0fSx7MzEsNCwyMH0sezQsMjAsMjF9LHsxMCw5LDI1fSx7OSwyNSwyNH0sezgsMjQsMn0sezI2
LDExLDI3fSx7MTEsMjcsM30sezI3LDMsMTl9LHsyOCwxNywxOX0sezI4LDEyLDE2fSx7MTIsMTYs
MX0sezYsMjksMTN9LHsyOSwxMywxOH0sezEzLDE4LDF9LHs3LDIzLDE0fSx7MjMsMTQsMTN9LHsx
NCwzMCwxOH0sezcsNiwyMn0sezYsMjIsNX0sezIyLDUsMjF9LHsxLDEsMX0sezEsMSwxfSx7MSwx
LDF9fSx3aGl0ZXN0X2NvbG9yPTddXWx6NAAnAQAAFQIAAPUFdXNlcmRhdGEoImkzMiIsNjQsIjAB
AMAxZDJiNTMwMDdlMjUIAPAXMDA4NzUxMDBhYjUyMzYwMDVmNTc0ZjAwYzJjM2M3MDBmZmYxZTgI
AEAwMDRkCAARYTYAYGZmZWMyNwoAIGU0OABAMjlhZCQAYDgzNzY5YyAAMTc3YTgAwGNjYWEwMDFj
NWVhYzAA8B1hNWExMDA3NTRlOTcwMDEyNTM1OTAwNzQyZjI5MDA0OTJkMzgwMGEyODg3OUAA8ANh
Y2M1MDBjMzAwNGMwMGViNmJGAGA5MGVjNDIKACBiMsAAoDY0ZGZmNjAwYmSJAACWAEAwZGFiQABf
ODU2ZDABAMawMWUzNzNjMDAzNzQnASEwMwEAMTAwMgEAoDAwMTYxNjE2Iik=
:: pal/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTEwIDA0OjUyOjUxIixzdG9yZWQ9IjIwMjQtMDQt
MTAgMDQ6NTI6NTEiXV1sejQABAAAAAMAAAAwbmls
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTExIDE3OjI1OjAxIixtb2RpZmllZD0iMjAyNC0w
NC0xMiAyMToxNDoyOSIscmV2aXNpb249MTA1Ml1dbHo0ABoCAAA8CQAA8CdweHUAAygAAAMABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDBAUGBwAP-5AICQoLDwwPDQ8ODw8QAPAADQ8RDxIPEw8UDxUP
Fg8XEwDxAQ8YDxkPGg8bDxwPHQ8eDx8UAPEAIA8hDyIPIw8kDyUPJg8nFADxACgPKQ8qDysPLA8t
Dy4PLxQA8QAwDzEPMg8zDzQPNQ82DzcUAP8FOA85DzoPOw88Dz0PPg8-AA--8P8BAOv-JVoBEAYP
IBABIAEgAfAAAhACDBABIA8hIAEwD2bwww8o8McP_AoP-w_AD-cPDQHwCQEQBgwuAAI3f5ABEAB4
CSAPgBANYBMAIQ-3FABP8IAPFFUADCMPQDMA-w-gAQggD5XwCgEKIA_zIA-4AA9AQA8t8IcPKA--
8MZEABMwMAGQPwBAsiAP-z8AIA7QVAA-lPCTRAAQGA6HAEft8AoBFABfMA-C8INEAAM1BA83RQA1
IA8uRQAAlgAVIz8AP0-wo4MAEBQMMAAVDl8BEwORADfg8AoTAF8wD7-wY1EAFAAvAD8O8MMuAP9x
H-8BAMzT6A4ADUAPHA--DxwPGggAHhgQAGL--x8BBSECAJ-1Hw85BQ8kDw4HAARA9R-wcFYA8BEF
DysPJCUPKw8oFQ8rDyYPKAUH9SIRJREVIQUB9SIPOR0AQDkPJBUFAGIPOQUL9SE4AC-1sAgA-9cf
-wEAl1D-----Hw==
:: sfx/1.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTEyIDA2OjQyOjE4Iixtb2RpZmllZD0iMjAyNC0w
NC0xMiAyMToxNDoyOSIscmV2aXNpb249MTA2Ml1dbHo0AJ4CAACZCgAA8U9weHUAAygAAAMABA9A
EAIOAAGgASACoA4ADxAADfDJAgEAAwQFBgcCDz_QCAkKCw8MDw0PDg8PBA--kA0PEQ8SDxMPFA8V
DxYPFwAP-5APGA8ZDxoPGw8cDx0PHg8fFADxACAPIQ8iDyMPJA8lDyYPJxQA8QAoDykPKg8rDywP
LQ8uDy8UAPEAMA8xDzIPMw80DzUPNg83FAD-BTgPOQ86DzsPPA89Dz4PPwAP--D-AQDr9xxaARAG
DyAQASABIAHwAAIQAgwQASAPISABMA9mkA8RAiAMUAEgAeABCPAPHQA04A8kGgD-DgUK8A8J8BcP
KPDHD-gKD-8PgA-3Dw0B8AkBEAYMWAACN3_QARAAeAkgD4AQDWATACEP9xQAT-CADxRVABYZQFUA
IuASDABmDiAB4AMCDAAXBAwAFwUMABYGDACP8AgPKA--8MZ4AA4RDncAF6A6AB8ADAAoD3YAGwXt
ABoO7AAHCwAfAesABB8FdQAlBrcBHQ62AR8OtQEZJA9AowD_BwggD5XwCgEKIA_zIA-4AA9AQA8t
8IeVAA9DAAYwMAGQPgBAsiAP-z4AIAfQUwA-lPCTQwAQFweFAEbt8AoBEwBfMA-C8INCABATDC8A
GQeOAQBQABLgUAAFOwE-v-BjUAAZL-DDLgDmH-8BAMzzAOgHAA0ADSAPHA--DxwPGggAHhgQAGL-
-x8BCyECAL-7Hw8yCw8kDw4POQcAAkD7H-BwWADyAQwgDzQPKw8kCw80Cw8rDygHAFAmDygLAxMA
GAQCAPoA_xEAEQsACxEACyELAQsAAgBQ_xEHDzlIACAyCwgAIg89BwCROQsPKwsHCwULegABHgAQ
HA4AMRX7EYEAP0D7sAgA-9cf-wEAl1D-----Hw==
:: sfx/2.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTEyIDA2OjQzOjAwIixtb2RpZmllZD0iMjAyNC0w
NC0xMiAwNjo0NDo0OCIscmV2aXNpb249NV1dbHo0AJ0BAADpCAAA8CdweHUAAygAAAMABA9AEAIO
AAGgASACoA4ADxAADfDKAQIDBAUGBwAP-5AICQoLDwwPDQ8ODw8QAPAADQ8RDxIPEw8UDxUPFg8X
EwDxAQ8YDxkPGg8bDxwPHQ8eDx8UAPEAIA8hDyIPIw8kDyUPJg8nFADxACgPKQ8qDysPLA8tDy4P
LxQA8QAwDzEPMg8zDzQPNQ82DzcUAP8FOA85DzoPOw88Dz0PPg8-AA--8P8BAOv-JVoBEAYPIBAB
IAEgAfAAAhACDBABIA8hIAEwD2bwww8o8McP_AoP-w_AD-cPDQHwCQEQBgwuAAI3f5ABEAB4CSAP
gBANYBMAIQ-3FABP8IAPFFUAFhBAgwBPD--wxjAA--9sH-8BAMzzAegPQAANAA0gDxwP-w8cDxoI
AB4YEABi--8fAQ4hAgCf-h8POQ4PJA8OBwAEQf4f8HBZAPATDCAODysPJC4PKw8oHg8rDyYPKA4D
-iIRLhEeIQ4B-iIPOR0AQDkPJB4FAGIPOQ4E-iE7AG9A-rDwcAUIAP-UH-8BAJdQ-----x8=
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2IixzdG9yZWQ9IjIwMjQtMDMt
MjQgMDA6NDg6MDYiXV1sejQABAAAAAMAAAAwbmls
:: src/app.lua
--[[pod_format="raw",created="2024-04-12 08:11:00",modified="2024-04-12 21:14:28",revision=907]]
local app = {}


-- Global state

app.pattern = 0 -- opened in pattern editor
app.track = 0 -- opened in track editor
app.instrument = 1 -- opened in instrument editor

app.base_note = 48
app.base_volume = 0x32
app.base_instrument = 01


-- GUI

app.refresh_gui = true
app.gui = nil

app.view = "inst" -- "patt" or "trk" or "inst"
app.detail = true


-- Layout constants

app.ruler_height = 9
app.channels_width = 16
app.detail_width = 56
app.cell_width = 20
app.cell_height = 29


return app
:: src/constants.lua
--[[pod_format="raw",created="2024-04-10 15:52:04",modified="2024-04-12 05:56:04",revision=691]]
local constants = {}


constants.piano_keys = {
	{
		offset = -12,
		[0] = "z", "s", "x", "d", "c", "v", "g", "b", "h", "n", "j", "m",
		",", "l", ".", ";", "/"
	},
	{
		offset = 0,
		[0] = "q", "2", "w", "3", "e", "r", "5", "t", "6", "y", "7", "u",
		"i", "9", "o", "0", "p", "[", "=", "]",
	}
}


constants.isomorphic_keys = {
	{
		offset = -5,
		[0] = "z", "x", "c", "v", "b", "n", "m", ",", ".", "/",
	},
	{
		offset = 0,
		[0] = "a", "s", "d", "f", "g", "h", "j", "k", "l", ";",
	},
	{
	offset = 5,
		[0] = "q", "w", "e", "r", "t", "y", "u", "i", "o", "p",
	}
}


return constants
:: src/detail.lua
--[[pod_format="raw",created="2024-04-12 07:24:11",modified="2024-04-12 16:43:28",revision=801]]
local app = require "src/app"
local note_grid = require "src/note_grid"
local sfx = require "src/sfx"


local detail = {}


function detail.track()
	if app.view == "patt" then
		if note_grid.selection then
			return sfx.pattern_track(app.pattern, note_grid.selection.channel)
		else
			return nil
		end
	else
		return app.track
	end
end


function detail.attach_panel(parent, el)
	el.width = 64
	el.height = 270 - 11 - 16
	parent:attach(el)
	if app.view == "patt" or app.view == "trak" then
		detail.attach_section_pattern(el, { x = 1, y = app.ruler_height })
		detail.attach_section_track(el, { x = 1, y = app.ruler_height + 30 })
		detail.attach_section_note(el, { x = 1, y = app.ruler_height + 80 })
	end

	function el:draw()
		rectfill(0, 0, self.width, self.height, 21)
	end	
	

	return el
end


-- Pattern section -------------------------------------------------------


function detail.attach_section_pattern(parent, el)
	el.width = parent.width - el.x
	el.height = 24 -- TODO
	parent:attach(el)
	detail.attach_pattern_flow_toggles(el, { x = 4, y = 10 })
	function el:draw()
		--- rectfill(0, 0, self.width, self.height, 2)
		print(string.format("pattern %d", app.pattern), 3, 0, 22)
		line(3, 7, self.width - 3, 7, 5)
	end
end


function detail.attach_pattern_flow_toggles(parent, el)
	el.width = 36 + 1
	el.height = 11
	el.cursor = "pointer"
	parent:attach(el)

	function el:draw()
		local is_start = sfx.pattern_loop_start(app.pattern)
		local is_stop = sfx.pattern_loop_stop(app.pattern)
		local is_end = sfx.pattern_loop_end(app.pattern)
		pal(7, is_start and 17 or 63)
		spr(40, 2, 1)
		pal(7, is_end and 17 or 63)
		spr(41, 2 + 12, 1)
		pal(7, is_stop and 17 or 63)
		spr(42, 2 + 24, 1)
		pal(7, 7)
	end	
	
	function el:tap(msg)
		if msg.mx > 25 then
			sfx.set_pattern_loop_stop(
				app.pattern,
				not sfx.pattern_loop_stop(app.pattern)
			)
		elseif msg.mx > 13 then
			sfx.set_pattern_loop_end(
				app.pattern,
				not sfx.pattern_loop_end(app.pattern)
			)
		else
			sfx.set_pattern_loop_start(
				app.pattern,
				not sfx.pattern_loop_start(app.pattern)
			)
		end
	end

	return el
end


-- Track section ------------------------------------------------------------------


function detail.attach_section_track(parent, el)
	el.width = parent.width - el.x
	el.height = 48 -- TODO
	parent:attach(el)
	detail.attach_num_field(
		el,
		{
			x = 0, y = 12,
			label = "speed:",
			visible = function() return note_grid.selection != nil end,
			get = function() return sfx.track_speed(detail.track()) end,
			set = function(v) sfx.set_track_speed(detail.track(), v) end,
		}
	)
	el.loop0_field = detail.attach_num_field(
		el,
		{
			x = 0, y = 22,
			label = "length:",
			visible = function() return note_grid.selection != nil end,
			get = function() return sfx.track_loop0(detail.track()) end,
			set = function(v) sfx.set_track_loop0(detail.track(), v) end,
		}
	)
	detail.attach_num_field(
		el,
		{
			x = 0, y = 32,
			label = "loop end:",
			visible = function() return note_grid.selection != nil end,
			get = function() return sfx.track_loop1(detail.track()) end,
			set = function(v) sfx.set_track_loop1(detail.track(), v) end,
		}
	)
	
	function el:draw()
		local track = detail.track()
		if (not track) return
		--- rectfill(0, 0, self.width, self.height, 2)
		print(string.format("track %d", track), 3, 0, 22)
		line(3, 7, self.width - 3, 7, 5)
	end
	
	function el:update()
		local track = detail.track()
		if (not track) return
		if sfx.track_loop1(track) > 0 then
			self.loop0_field.label = "l. start:"
		else
			self.loop0_field.label = "length:"
		end
	end
end


-- Note section ------------------------------------------------------------------


function detail.attach_section_note(parent, el)
	el.width = parent.width - el.x
	el.height = 70 -- TODO
	parent:attach(el)
	detail.attach_num_field(
		el,
		{
			x = 0, y = 12,
			label = "pitch:",
			visible = function() return note_grid.selection != nil end,
			get = function() return sfx.track_pitch(detail.track(), note_grid.selection.step) end,
			set = function(v) sfx.set_track_pitch(detail.track(), note_grid.selection.step, v) end,
		}
	)
	detail.attach_num_field(
		el,
		{
			x = 0, y = 22,
			label = "volume:",
			visible = function() return note_grid.selection != nil end,
			get = function() return sfx.track_volume(detail.track(), note_grid.selection.step) end,
			set = function(v) sfx.set_track_volume(detail.track(), note_grid.selection.step, v) end,
		}
	)
	detail.attach_num_field(
		el,
		{
			x = 0, y = 32,
			label = "inst:",
			visible = function() return note_grid.selection != nil end,
			get = function() return sfx.track_instrument(detail.track(), note_grid.selection.step) end,
			set = function(v) sfx.set_track_instrument(detail.track(), note_grid.selection.step, v) end,
		}
	)
	detail.attach_num_field(
		el,
		{
			x = 0, y = 42,
			label = "fx:",
			visible = function() return note_grid.selection != nil end,
			get = function() return sfx.track_fx(detail.track(), note_grid.selection.step) end,
			set = function(v) end,
		}
	)
	detail.attach_num_field(
		el,
		{
			x = 0, y = 52,
			label = "param1:",
			visible = function() return note_grid.selection != nil end,
			get = function() return (sfx.track_fx_params(detail.track(), note_grid.selection.step) & 0xf0) >> 4 end,
			set = function(v) end,
		}
	)
	detail.attach_num_field(
		el,
		{
			x = 0, y = 62,
			label = "param2:",
			visible = function() return note_grid.selection != nil end,
			get = function() return (sfx.track_fx_params(detail.track(), note_grid.selection.step) & 0xf0) end,
			set = function(v) end,
		}
	)
		
	function el:draw()
		local track = app.track
		local step = 0
		if app.view == "patt" then
			if note_grid.selection then
				track = sfx.pattern_track(app.pattern, note_grid.selection.channel)
			else
				return
			end
		end
		--- rectfill(0, 0, self.width, self.height, 2)
		print("note", 3, 0, 22)
		line(3, 7, self.width - 3, 7, 5)
	end
end


-- Widgets ------------------------------------------------------------------------


function detail.attach_num_field(parent, el)
	el.width = parent.width - el.x
	el.height = 12
	parent:attach(el)
	if (not el.visible) el.visible = function() return true end
	el.dragged = nil
	function el:draw()
		if (not el.visible()) return
		local val = self.get()
		rectfill(self.width - 24, 0, self.width - 10, 6, self.dragged and 17 or 62)
		print(el.label, 3, 1, 22)
		if val then
			print(string.format("%3d", val), self.width - 22, 1, self.dragged and 7 or 22)
		else
			print("-", self.width - 4, 1, self.dragged and 7 or 17)
		end
	end
	function el:hover(msg)
		if msg.mx >= self.width - 21 then
			self.cursor = "pointer"
		else
			self.cursor = 1
		end
	end
	function el:click(msg)
		if (not el.visible()) return
		if msg.mx >= self.width - 21 then
			self.dragged = { y0 = msg.my, val0 = self.get() }
		end
	end
	function el:drag(msg)
		if (not el.visible()) return
		if self.dragged then
			local delta = msg.my - self.dragged.y0
			local new = self.dragged.val0 - ((delta - 3) / 6)
			new = mid(0, new, 0xff)
			self.set(new)
		end
	end
	function el:release(msg)
		self.dragged = nil
	end
	return el
end


return detail
:: src/ed_inst.lua
--[[pod_format="raw",created="2024-04-10 15:43:44",modified="2024-04-12 21:14:28",revision=786]]
local app = require "src/app"
local settings = require "src/settings"
local synth = require "src/synth"


local ed_inst = {}


function ed_inst.attach(parent, el)
	el.width = 480 - (app.detail and app.detail_width or 0)
	el.height = 270 - 11 - 16
	parent:attach(el)
	synth.attach(el, { x = 0, y = 0 })

	function el:draw()
--		rectfill(0, 0, self.width, self.height, 62)
	end	
	
	function el:update()
		local pitch_key = nil
		for i = 1, #settings.keys.pitched do
			local offset = settings.keys.pitched[i].offset
			for j = 0, #settings.keys.pitched[i] do
				local k = settings.keys.pitched[i][j]
				if key(k, true) then
					pitch_key = j + offset
				end
			end
		end
		if pitch_key then
			local pitch = pitch_key + 48
			if key("shift") then
				pitch += 12
			end
			pitch = mid(0, pitch, 0xfe)
			note(
				pitch, -- todo
				0, -- current_instrument
				50, -- current_volume
				ord(" "), 0x00, -- fx, fx param
				8, -- channel 8 so it can play with pattern
				false -- don't force retrigger
			)
		else
			note(0xff, 0xff, 0xff, 0xff, 0xff, 8)
		end
	end

	return el
end


return ed_inst
:: src/ed_patt.lua
--[[pod_format="raw",created="2024-04-10 10:06:40",modified="2024-04-12 17:09:46",revision=2507]]
local app = require "src/app"
local constants = require "src/constants"
local sfx = require "src/sfx"


local ed_patt = {}


-- Channel panel -------------------------------------------------------------------


function ed_patt.attach_channel_panel(parent, el)
	el.width = app.channels_width
	el.height = 270 - 11 - 16
	parent:attach(el)

	--[[
	el.fields = {}
	for channel = 0, 7 do
		local oy = app.ruler_height + channel * app.cell_height
		local track_id = peek(0x30100 + app.pattern * 20 + channel)
		el.fields[channel] = el:attach_text_editor {
			x = 1, y = oy,
			width = 14,
			height = 10,
			max_lines = 1,
			syntax_highlighting = false,
			show_line_numbers   = false,
			markup     = false,
			embed_pods = false,
			has_search = false,
			bgcol = 59,	
			fgcol = 22,
			key_callback = {
				enter = function() return true end
			},
			click = function() return true end,
			tap = function() return true end
		}
		el.fields[channel]:set_text(string.format("%d", track_id))
	end
	--]]
	
	function el:draw()
		rectfill(0, 0, self.width, self.height, 21)
		for channel = 0, 7 do
			local oy = app.ruler_height + channel * app.cell_height
			local track_id = sfx.pattern_track(app.pattern, channel)
			local is_dragged = self.dragged and self.dragged.channel == channel
			if is_dragged then
				rectfill(0, oy + 1, 14, oy + 9, 17)
			end
			
			p8_centered_print(
				string.format("%d", track_id),
				8, oy + 3,
				is_dragged and 7 or 22
			)			
			spr(sfx.channel_is_muted(app.pattern, channel) and 32 or 33, 4, oy + 12)
		end
	end
	
	function el:hover(msg)
		local channel = (msg.my - app.ruler_height) \ app.cell_height
		if (channel > 7) return
		local part = (msg.my - app.ruler_height) % app.cell_height
		if part < 10 then
			self.cursor = "pointer"
		else
			self.cursor = 1
		end
	end
	
	function el:click(msg)
		self:set_keyboard_focus(true) -- TODO
		local channel = (msg.my - app.ruler_height) \ app.cell_height
		if (channel > 7) return
		local part = (msg.my - app.ruler_height) % app.cell_height
		if part < 10 then
			local track_id = sfx.pattern_track(app.pattern, channel)
			self.dragged = { channel = channel, y0 = msg.my, id0 =  track_id}
		elseif part < 20 then
			sfx.mute_channel(
				app.pattern,
				channel,
				not sfx.channel_is_muted(app.pattern, channel)
			)
		end
	end
	
	function el:drag(msg)
		if self.dragged then
			local delta = msg.my - self.dragged.y0
			local track_id = self.dragged.id0 - math.floor(0.5 + ((delta + 3) \ 6))
			track_id = mid(0, track_id, 0xff)
			-- TODO: move to sfx
			poke(0x30100 + app.pattern * 20 + self.dragged.channel, track_id)
		end
	end
	
	function el:release(msg)
		self.dragged = nil
	end
		
	return el
end


-- Pattern selector ----------------------------------------------------------------


function ed_patt.attach_pattern_selector(parent, el)
	el.width = 19 * 14
	el.height = 16
	el.cursor = "pointer"
	parent:attach(el)

	function el:draw()
		local playing_pattern = stat(466)
		for p = 0, 18 do
			if p == 0 then
				spr(43, 5, 5)
			elseif p < 18 then
				rectfill(
					p * 14, 4,
					14 + p * 14, 12, 
					(p - 1) == playing_pattern and 17 or 59
				)
				p8_centered_print(
					string.format("%d", p - 1),
					8 + p * 14, 6,
					(p - 1) == app.pattern and 7 or 22
				)
			else
				spr(44, 3 + p * 14, 5)
			end
		end
	end	
	
	function el:click(msg)
		local p = msg.mx \ 14
		if p == 0 then
			-- TODO
		elseif p < 18 then
			app.pattern = p - 1
		else
			-- TODO
		end
	end

	return el
end


return ed_patt
:: src/ed_trak.lua
--[[pod_format="raw",created="2024-04-10 15:48:56",modified="2024-04-12 16:25:37",revision=71]]
local app = require "src/app"


local ed_trak = {}


function ed_trak.attach(parent, el)
	el.width = 480 - (app.detail and app.detail_width or 0)
	el.height = 270 - 11 - 16 - 1
	parent:attach(el)

	function el:draw()
		rectfill(0, 0, self.width, self.height, 62)
	end	

	return el
end


return ed_trak
:: src/file.lua
--[[pod_format="raw",created="2024-04-07 08:14:09",modified="2024-04-12 06:46:43",revision=1266]]
local M = {}


--M.default_filename = "/ram/cart/sfx/0.visitrak"
M.default_filename = "/ram/cart/sfx/1.sfx"


function M.save()
	local ud = userdata("u8", 0x30000)
	for i = 0, 0x2ffff do
		ud[i] = peek(0x30000 + i)
	end
	return ud
end


function M.load(ud)
	if type(ud) != "userdata" then
		init_data()
	else
		for i=0,0x2ffff do
			poke(0x30000+i, ud[i])
		end
	end
	tdat = {}
---			init_undo()
end


-- Initialisation ----------------------------------------------------------------


-- copied from "/system/apps/sfx.lua" in Picotron 0.0.1e
function init_data()
	
	-- index (0x30000)
	
	-- first 3 values are almost metadata only -- not currently
	-- acted on anywhere. perhaps useful in future for deciding
	-- scope of copy/paste, and gui cues, but can be calculated
	-- from content.
	
	poke2(0x30000,
		64,  -- num_instruments
		512, -- num_tracks (64 patterns * 8 channels for default indexing)
		64,  -- num_patterns
		-- flags: 0x1 use default track indexing (base+0x20000, increments of 328 bytes)
		0x1
	)
	poke4(0x30010,
		0x10000, -- insts_addr      (I32)    relative address of instruments
		0x20000, -- tracks_addr     (I32)    relative address of track index
		0,       -- patterns_addr   (I32)    relative address of pattern data
		0        -- unused          (I32)    should be 0
	)
	poke2(0x30020,
		0,  -- tick len (0 for default -- custom vals not supported yet)
		64, -- default track length
		16 -- default track spd
	)
	
	-- default track speed (+3 unused)
	poke(0x30026, 16, 0, 0, 0) 
	
	-- pattern data: first 8 patterns
	
	for pp = 0,7 do
		local addr = 0x30100 + pp * 20
		for i = 0, 7 do
			poke(addr+i, pp*8 + i)
		end
		poke(addr+8, 0x0)  -- flow flags
		poke(addr+9, 0xff) -- channel mask
		poke(addr+10, 0,0) -- length (I16)
		
	end
	
	
	----------------------------------------------------------------------------
	-- single instrument at 0x40000 (instrument 0)
	
	-- node 0: root
	poke(0x40000 + (0 * 32), -- instrument 10node 0
	
			0,    -- parent (0x7)  op (0xf0)
			1,    -- kind (0x0f): 1 root  kind_p (0xf0): 0  -- wavetable_index
			0,    -- flags
			0,    -- unused extra
				
			-- MVALs:  kind/flags,  val0, val1, envelope_index
			
			0x2|0x4,0x20,0,0,  -- volume: mult. 0x40 is max (-0x40 to invert, 0x7f to overamp)
			0x1,0,0,0,     -- pan:   add. center
			0x1,0,0,0,     -- tune: +0 -- 0,48,0,0 absolute for middle c (c4) 261.6 Hz
			0x1,0,0,0,     -- bend: none
			-- following shouldn't be in root
			0x0,0,0,0,     -- wave: use wave 0 
			0x0,0,0,0      -- phase 
	)
	
	
	-- node 1: sine
	poke(0x40000 + (1 * 32), -- instrument 0, node 1
	
			0,    -- parent (0x7)  op (0xf0)
			2,    -- kind (0x0f): 2 osc  kind_p (0xf0): 0  -- wavetable_index
			0,    -- flags
			0,    -- unused extra
				
			-- MVALs:  kind/flags,  val0, val1, envelope_index
			
			0x2,0x20,0,0,  -- volume: mult. 0x40 is max (-0x40 to invert, 0x7f to overamp)
			0x1,0,0,0,     -- pan:   add. center
			0x21,0,0,0,    -- tune: +0 -- 0,48,0,0 absolute for middle c (c4) 261.6 Hz
			               -- tune is quantized to semitones with 0x20
			0x1,0,0,0,     -- bend: none
			0x0,0x40,0,0,  -- wave: triangle
			0x0,0,0,0      -- phase 
	)
	
	

	-- wavetable
	for i=0,7 do
	poke(0x40000 + 0x1e0,
		0x00, -- address (low)  in 256 byte increments
		0xf8, -- address (high) in 64k increments
		0x0a, -- samples (1 << n) 1024
		0xff,  -- wt_height 256(0); wave mval points at one of the entries
		
		-- to do: update (is garbage now?)
		0x80,
		0xf7,
		0x0d, -- samples (1 << n) 8192
		0x01
	)
	end

	-- envelope 0 inst 1
	
	poke(0x40000 + 0x100,
		0,0,0,0, 0,0,0,0,
		0,40,255,0 -- adsr
	)
	
	-- copy default instrument to 1..15
	for i=1,15 do
		memcpy(0x40000 + 0x200*i, 0x40000, 0x200)
	end
	
	--------------------------------------------------
	-- Track Data  0x50000
	--------------------------------------------------
	
	-- Default track size is 5 * 64 rows + 8 = 328 bytes
	
	-- header (8)
	local addr = 0x50000
	poke2(addr, 64) -- len
	poke(addr+2,16) -- spd
	poke(addr+3,0)  -- loop0
	poke(addr+4,0)  -- loop1
	poke(addr+5,0)  -- delay
	poke(addr+6,0)  -- flags (0x1 mute)
	poke(addr+7,0)  -- unused
	
	-- pitch, inst, vol: not set (0xff)
	memset(addr+8, 0xff, 64*3)
	
	-- copy to other tracks
	for i=1,63 do
		memcpy(0x50000 + i*328, 0x50000, 328)
	end
end


return M
:: src/note_grid.lua
--[[pod_format="raw",created="2024-04-11 06:36:17",modified="2024-04-12 17:20:20",revision=1564]]
local app = require "src/app"
local settings = require "src/settings"
local sfx = require "src/sfx"


local note_grid = {}


note_grid.origin = { x = -4 }
note_grid.selection = { channel = 0, step = 0, part = 0 }


function note_grid.attach(parent, el)
	el.width = 480 - app.channels_width - (app.detail and app.detail_width or 0)
	el.height = 270 - 11 - 16
	parent:attach(el)
	
	el.dragged = nil
	
	el:set_keyboard_focus(true)
	
	-- Draw ------------------------------------------------------------------------

	function el:draw()
		local pattern_is_playing = (stat(464) != 0)  and (stat(466) == app.pattern)
		-- Ruler background
		rectfill(0, 0, self.width, app.ruler_height - 2, 61)
		line(0, app.ruler_height - 1, self.width, app.ruler_height - 1, 5)
		local step_start = note_grid.origin.x \ app.cell_width
		local delta_x = - (note_grid.origin.x % app.cell_width)
		if step_start < 0 then
			step_start = 0
			note_grid.origin.x = max(- 4 , note_grid.origin.x)
			delta_x = - note_grid.origin.x
		end
		for channel = 0, 7 do
			local oy = app.ruler_height + channel * app.cell_height
			rectfill(
				0, oy, self.width,
				oy + app.cell_height - 1,
				((channel % 2) == 0) and 63 or 62
			)
			if sfx.channel_is_muted(app.pattern, channel) then
				goto continue
			end
			local track = peek(0x30100 + app.pattern * 20 + channel)
			for step_i = 0, 24 do
				if step_start + step_i > 63 then break end
				local ox = delta_x + step_i * app.cell_width + 1
				if pattern_is_playing and stat(400 + channel, 9) == step_start + step_i then
					rectfill(ox, oy, ox + app.cell_width - 2, oy + app.cell_height - 1, 19)
				end
				if
					note_grid.selection and note_grid.selection.channel == channel
						and note_grid.selection.step == step_start + step_i
				then
					-- TODO: replace with rectfill
					-- TODO: replace with rect when no keyboard focus
					spr(24 + note_grid.selection.part, ox, oy)
				end
				-- TODO: support track length > 64
				local freq = sfx.track_pitch(track, step_start + step_i)
				local inst = sfx.track_instrument(track, step_start + step_i)
				local vol  = sfx.track_volume(track, step_start + step_i)
				local fx   = sfx.track_fx(track, step_start + step_i)
				local fxp  = sfx.track_fx_params(track, step_start + step_i)
				-- Note and octave
				if freq != 0xff then
					local note = freq % 12
					local is_sharp = (note == 1) or (note == 3) or (note == 6)
						or (note == 8) or (note == 10)
					local x = is_sharp and (ox + 2) or (ox + 2) -- 5
					spr(8 + note, x, oy + 2)
					local x_oct = is_sharp and (ox + 14) or (ox + 8) -- 11
					if (freq \ 12) <= 9 then
						print("\014" .. tostr(freq \ 12), x_oct, oy + 3, 13) 
					else
						print("\014?", ox + 14, oy + 3, 13) 
					end
				else
					print("\014.", ox + 2, oy, 7)
				end
				-- Volume
				if vol != 0xff then
					local w_vol = (vol / 64) * (app.cell_width - 6)
					w_vol = min(w_vol, app.cell_width - 6)
					if w_vol == 0 and vol != 0 then
						w_vol = 1
					end
					rectfill(ox + 2, oy + 10, ox + 2 + app.cell_width - 6, oy + 12, 60)
					if w_vol > 0 then
						rectfill(ox + 2, oy + 10, ox + 2 + w_vol, oy + 12, 17) -- col 22
					end
					-- TODO: support vol > 64
				else
					print("\014.", ox + 2, oy + 7, 5)
				end
				-- Instrument
				local x = 8
				if inst != 0xff then
					if inst > 99 then
						x -= 4
					elseif inst > 9 then
						x -= 2
					end
					x = 2
					print("\014" .. string.format("%d", inst), ox + x, oy + 15, 14) -- 26
				else
					print("\014.", ox + 2, oy + 15 - 1, 5)
				end
				-- Effect
				if false then
					print("\014" .. fx, ox + 2, oy + 22, 22)
				else
					print("\014.", ox + 2, oy + 22 - 1, 5)
				end
			end
			::continue::
		end
		if self.height > app.ruler_height + 8 * app.cell_height then
			rectfill(0, app.ruler_height + 8 * app.cell_height, self.width, self.height, 62)
		end
		-- Bar lines
		for step_i = 0, 24 do
			if step_start + step_i > 63 + 1 then break end
			local ox = delta_x + (step_i * app.cell_width)
			local bar = (step_start + step_i) \ (4 * 4) + 1
			local beat = ((step_start + step_i) \ 4) % 4 + 1
			if (step_start + step_i) % 4 == 0 then
				if ((step_start + step_i) \ 4) % 4 == 0 then
					line(ox, 0, ox, self.height, 22)
					print("\014" .. bar .. "." .. beat, ox + 2, 2, 22)
				else
					line(ox, 0, ox, self.height, 5)
					print("\014" .. bar .. "." .. beat, ox + 2, 2, 5)
				end
			else
				--[[
				poke(0x550b, 0x3f)
				fillp(0b0000000011111111)
				line(ox, app.ruler_height, ox, self.height - 1, 5)
				fillp()
				poke(0x550b, 0x00)
				--]]
			end
		end
	end
	
	-- Mouse --------------------------------------------------------------------
	

	function el:hover(msg)
		if msg.my <= app.ruler_height then
			self.cursor = "grab"
		else
			self.cursor = 1
		end
	end
	

	function el:click(msg)
		if msg.my < app.ruler_height or msg.mb == 4 then
			self.dragged = { x = note_grid.origin.x + msg.mx, pan = true }
			self.cursor = "grab"
		elseif msg.mb == 1 then
			self:set_keyboard_focus(true)
			local step = (msg.mx + note_grid.origin.x) \ app.cell_width
			local channel = (msg.my - app.ruler_height) \ app.cell_height
			if
				(0 <= channel) and (channel <= 7)
					and (0 <= step) and (step <= 63) -- TODO: handle track length
			then
				note_grid.selection = { part = 0, step = step, channel = channel }
				local y = (msg.my - app.ruler_height) % app.cell_height
				if y > 20 then
					note_grid.selection.part = 3
				elseif y > 14 then
					note_grid.selection.part = 2
				elseif y > 8 then
					note_grid.selection.part = 1
				end
				self:show_selection()
			else
				note_grid.selection = nil
			end
		end
	end
	

	function el:drag(msg)
		if self.dragged then
			note_grid.origin.x = self.dragged.x - msg.mx
		end
	end
	

	function el:release(msg)
		self.dragged = nil
		self.cursor = 1
	end
	
	
	function el:mousewheel(msg)
		note_grid.origin.x -= msg.wheel_y * app.cell_width
	end
	
	-- Update -----------------------------------------------------------------
	

	function el:update()
		if self.note_playing then
			-- TODO: should be in main.lua (bug when switching view during note)
			if self.note_playing.tick > 10 then
				note(0xff, 0xff, 0xff, 0xff, 0xff, self.note_playing.channel)
				self.note_playing = nil
			else
				self.note_playing.tick += 1
			end
		end
		
		-- TODO: separate: take focus *xor* move
		if (keyp("pageup")) self:set_keyboard_focus(true); self:goto_previous_channel()
		if (keyp("pagedown")) self:set_keyboard_focus(true); self:goto_next_channel()
		if (keyp("up")) self:set_keyboard_focus(true); self:goto_previous_part()
		if (keyp("down")) self:set_keyboard_focus(true); self:goto_next_part()
		if (keyp("left")) self:set_keyboard_focus(true); self:goto_previous_step()
		if (keyp("right")) self:set_keyboard_focus(true); self:goto_next_step()

		if note_grid.selection then
			self:handle_positioned_key()
		end
	end


	function el:handle_positioned_key()
		local keys = settings.keys
		
		local track = peek(0x30100 + app.pattern * 20 + note_grid.selection.channel)
		local base_addr = 0x50000 + 8 + (track * 328) + note_grid.selection.step
		
		-- Pitched input
		local pitch_key = nil
		for i = 1, #settings.keys.pitched do
			local offset = settings.keys.pitched[i].offset
			for j = 0, #settings.keys.pitched[i] do
				local k = settings.keys.pitched[i][j]
				if keyp(k, true) then
					pitch_key = j + offset
				end
			end
		end
		
		local num_key = keyp_num()
		local hex_key = keyp_hex()
						
		-- Part-specific input
				
		if note_grid.selection.part == 0 then
			local note = peek(base_addr) % 12
			if key("shift") and num_key then
				local pitch = note + num_key * 12
				pitch = mid(0, pitch, 0xfe)
				poke(base_addr, pitch)
				self:goto_next_step()
			elseif pitch_key then
				local pitch = pitch_key + app.base_note
				if key("shift") then
					pitch += 12
				end
				pitch = mid(0, pitch, 0xfe)
				poke(base_addr, pitch)
				poke(base_addr + (2 * 64), app.base_volume)
				poke(base_addr + (1 * 64), app.base_instrument)
				-- TODO fx and fxp
				self:play_selection()
				self:goto_next_step()
			elseif keyp(keys.rest) and key("shift") then
				poke(base_addr, 0xff)
				self:goto_next_step()
			elseif keyp(keys.rest) then
				poke(base_addr, 0xff)
				poke(base_addr + (2 * 64), 0xff)
				poke(base_addr + (1 * 64), 0xff)
				-- TODO fx and fxp
				self:goto_next_step()
			end
			
		elseif note_grid.selection.part == 1 then
			if num_key then
				local vol = math.floor(((hex_key / 9) * 64) + 0.5)
				if key("shift") then
					vol += 64
				end
				notify("" .. vol)
				poke(base_addr + (2 * 64), vol)
				self:goto_next_step()
			elseif keyp(keys.rest) then
				poke(base_addr + (2 * 64), 0xff)
				self:goto_next_step()
			end
			
		elseif note_grid.selection.part == 2 then
			if num_key then
				local inst = peek(base_addr + (1 * 64))
				if (inst == 0xff) inst = 0
				if key("shift") then
					inst = (hex_key * 10) + (inst % 10)
				else
					inst = ((inst \ 10) * 10) + num_key
				end
				poke(base_addr + (1 * 64), inst)
				self:goto_next_step()
			elseif keyp(keys.rest) then
				poke(base_addr + (1 * 64), 0xff)
				self:goto_next_step()
			end
		--[[
		elseif note_grid.selection.part == 3 then
			if hexa_val then
				poke(base_addr + (4 * 64), hexa_val)
				self:goto_next_step()
			elseif keyp(keys.rest) then
				poke(base_addr + (4 * 64), 0xff)
				self:goto_next_step()
			end
		]]
		end
		
		-- Non part-specific input
		
		if keyp("backspace") then
			self:goto_previous_step()
			local base_addr = 0x50000 + 8 + (track * 328) + note_grid.selection.step
			poke(base_addr, 0xff)
			poke(base_addr + (2 * 64), 0xff)
			poke(base_addr + (1 * 64), 0xff)
			-- TODO: fx and fxp
			-- poke(base_addr + (3 * 64), 0xff)
			-- poke(base_addr + (4 * 64), 0xff)
		end
	end
	

	function el:goto_previous_part()
		if not note_grid.selection then
			self:goto_start()
		elseif note_grid.selection.part > 0 then
			note_grid.selection.part -= 1
		elseif note_grid.selection.channel > 0 then
			note_grid.selection.part = 3
			self:goto_previous_channel()
		end
		self:show_selection()
	end


	function el:goto_next_part()
		if not note_grid.selection then
			self:goto_start()
		elseif note_grid.selection.part < 3 then
			note_grid.selection.part += 1
		elseif note_grid.selection.channel < 7 then
			note_grid.selection.part = 0
			self:goto_next_channel()
		end
		self:show_selection()
	end
	
	
	function el:goto_previous_channel()
		-- TODO: skip muted
		if not note_grid.selection then
			self:goto_start()
		elseif note_grid.selection.channel > 0 then
			self:goto_channel(note_grid.selection.channel - 1)
		end
	end
	
	
	function el:goto_next_channel()
		-- TODO: skip muted
		if not note_grid.selection then
			self:goto_start()
		elseif note_grid.selection.channel < 7 then
			self:goto_channel(note_grid.selection.channel + 1)
		end
	end	

	

	function el:goto_previous_step()
		if not note_grid.selection then
			self:goto_start()
		elseif note_grid.selection.step > 0 then
			self:goto_step(note_grid.selection.step - 1)
		end
	end
		

	function el:goto_next_step()
		if not note_grid.selection then
			self:goto_start()
		elseif note_grid.selection.step < 63 then -- TODO: handle track length
			self:goto_step(note_grid.selection.step + 1)
		end
	end
	

	function el:goto_start()
		note_grid.selection = { part = 0, step = 0, channel = 0 }
		self:show_selection()
	end


	function el:goto_channel(c)
		-- TODO check if channel is muted
		note_grid.selection.channel = c
		self:show_selection()
	end
	

	function el:goto_step(s)
		note_grid.selection.step = s
		self:show_selection()
	end
	

	function el:show_selection()
		if (not note_grid.selection) return
		-- TODO: pagination by bars?
		local offset = 4 -- TODO
		if
			note_grid.origin.x > ((note_grid.selection.step * app.cell_width) - offset)
		then
			note_grid.origin.x = note_grid.selection.step * app.cell_width - offset
		elseif
			note_grid.origin.x + self.width < ((note_grid.selection.step + 1) * app.cell_width) + offset
		then
			note_grid.origin.x = ((note_grid.selection.step + 1) * app.cell_width) + offset - self.width
		end
	end
	

	function el:play_selection()
		if note_grid.selection and stat(464) == 0 then
			local track = peek(0x30100 + app.pattern * 20 + note_grid.selection.channel)
			local base_addr = 0x50000 + 8 + (track * 328) + note_grid.selection.step
			local pitch = peek(base_addr)
			local inst = peek(base_addr + 64)
			local vol  = peek(base_addr + (2 * 64))
			local fx   = peek(base_addr + (3 * 64))
			local fxp  = peek(base_addr + (4 * 64))
			note(
				pitch,
				inst,
				vol,
				ord(" "), 0x00, -- fx, fx param
				note_grid.selection.channel,
				false
			)
			self.note_playing = { channel = note_grid.selection.channel, tick = 0 }
		end
	end
	
	el:show_selection()
		
	return el
end


return note_grid
:: src/settings.lua
--[[pod_format="raw",created="2024-04-11 08:58:08",modified="2024-04-12 09:14:13",revision=723]]
local constants = require "src/constants"


local settings = {}

--[[
settings.keys = {
	pitched = constants.piano_keys,
	rest = constants.piano_rest,
	unspec = constants.piano_unspec,
}
--]]
---[[
settings.keys = {
	pitched = constants.piano_keys,
	play = "space",
	rest = "del",
}
--]]


return settings
:: src/sfx.lua
--[[pod_format="raw",created="2024-04-07 08:22:05",modified="2024-04-12 21:14:28",revision=1578]]
local sfx = {}


local sfx_index = 0x030000
local sfx_instr = 0x040000
local sfx_track = 0x050000
local sfx_wave = 0xf00000 -- maybe not? (search discord)


local num_instrument = 0
local num_tracks = 0
local num_patterns = 0
local header_flags = 0
local insts_addr = 0
local tracks_addr = 0
local patterns_addr = 0


function sfx.read_header()
	num_instruments = peek2(sfx_index)
	num_tracks = peek2(sfx_index + 2)
	num_patterns = peek2(sfx_index + 4)
	header_flags = peek2(sfx_index + 6)
	-- unused: peek2(sfx_index + 8)
	insts_addr = peek4(sfx_index + 10)
	tracks_addr = peek4(sfx_index + 14)
	patterns_addr = peek4(sfx_index + 18)
	?header_flags
	?string.format("%x", insts_addr)
	?string.format("%x", tracks_addr)
	?string.format("%x", patterns_addr)
end


function sfx.play_or_pause()
	-- is `stat(464)` enough?
	if stat(464) == 0 then
		music(0)
	else
		note()
	end
end


function sfx.channel_is_muted(pattern, channel)
	local channel_mutes = peek(0x30100 + (pattern * 20) + 9)
	local muted = (channel_mutes & (1 << channel)) == 0
	return muted
end


function sfx.mute_channel(pattern, channel, mute)
	local channel_mutes = peek(0x30100 + (pattern * 20) + 9)
	channel_mutes &= ~(1 << channel)
	channel_mutes |= (mute and 0 or 1) << channel
	poke(0x30100 + (pattern * 20) + 9, channel_mutes)
end


function sfx.pattern_track(pattern, channel)
	return peek(0x30100 + pattern * 20 + channel)
end


function sfx.track_speed(track)
	return peek(0x50000 + (track * 328) + 2)
end


function sfx.set_track_speed(track, val)
	return poke(0x50000 + (track * 328) + 2, val)
end


function sfx.track_loop0(track)
	return peek(0x50000 + (track * 328) + 3)
end


function sfx.set_track_loop0(track, val)
	return poke(0x50000 + (track * 328) + 3, val)
end


function sfx.track_loop1(track)
	return peek(0x50000 + (track * 328) + 4)
end


function sfx.set_track_loop1(track, val)
	return poke(0x50000 + (track * 328) + 4, val)
end


-- Track notes -------------------------------------------------------------


function sfx.track_pitch(track, step)
	return peek(0x50000 + 8 + (track * 328) + step)
end
function sfx.set_track_pitch(track, step, v)
	return poke(0x50000 + 8 + (track * 328) + step, v)
end


function sfx.track_instrument(track, step)
	return peek(0x50000 + 8 + (track * 328) + step + 64)
end
function sfx.set_track_instrument(track, step, v)
	return poke(0x50000 + 8 + (track * 328) + step + 64, v)
end


function sfx.track_volume(track, step)
	return peek(0x50000 + 8 + (track * 328) + step + (2 * 64))
end
function sfx.set_track_volume(track, step, v)
	return poke(0x50000 + 8 + (track * 328) + step + (2 * 64), v)
end


function sfx.track_fx(track, step)
	return peek(0x50000 + 8 + (track * 328) + step + (3 * 64))
end
function sfx.set_track_fx(track, step, v)
	return poke(0x50000 + 8 + (track * 328) + step + (3 * 64), v)
end


function sfx.track_fx_params(track, step)
	return peek(0x50000 + 8 + (track * 328) + step + (3 * 64))
end
function sfx.set_track_fx_params(track, step, v)
	return poke(0x50000 + 8 + (track * 328) + step + (3 * 64), v)
end


-- Pattern flow flags ------------------------------------------------------


function sfx.pattern_loop_start(pattern)
	return (peek(0x30100 + (pattern * 20) + 8) & 0x01) != 0
end


function sfx.set_pattern_loop_start(pattern, bool)
	local old = peek(0x30100 + (pattern * 20) + 8)
	if bool then
		poke(0x30100 + (pattern * 20) + 8, old | 0x01)
	else
		poke(0x30100 + (pattern * 20) + 8, old & (~ 0x01))
	end
end


function sfx.pattern_loop_end(pattern)
	return (peek(0x30100 + (pattern * 20) + 8) & 0x02) != 0
end


function sfx.set_pattern_loop_end(pattern, bool)
	local old = peek(0x30100 + (pattern * 20) + 8)
	if bool then
		poke(0x30100 + (pattern * 20) + 8, old | 0x02)
	else
		poke(0x30100 + (pattern * 20) + 8, old & (~ 0x02))
	end
end


function sfx.pattern_loop_stop(pattern)
	return (peek(0x30100 + (pattern * 20) + 8) & 0x04) != 0
end


function sfx.set_pattern_loop_stop(pattern, bool)
	local old = peek(0x30100 + (pattern * 20) + 8)
	if bool then
		poke(0x30100 + (pattern * 20) + 8, old | 0x04)
	else
		poke(0x30100 + (pattern * 20) + 8, old & (~ 0x04))
	end
end

-- Synth nodes ---------------------------------------------------------------

function sfx.node_parent(instrument, node)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr + 0) & 0x7	
end

function sfx.node_type(instrument, node)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr + 1) & 0xf
end

function sfx.node_op(instrument, node)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr) >> 4
end

return sfx
:: src/synth.lua
--[[pod_format="raw",created="2024-04-12 16:30:23",modified="2024-04-12 21:14:28",revision=504]]
local app = require "src/app"
local sfx = require "src/sfx"


local synth = {}


local node_width = 26
local node_gap = 14


synth.nodes = nil


function synth.attach(parent, el)
	el.width = parent.width
	el.height = parent.height
	parent:attach(el)
	
	synth.nodes = {}
	for n = 0, 7 do
		synth.nodes[n] = {
			parent = nil, -- id of the parent
			children = {}, -- list of direct references to the children
			type = nil,
		}
	end
	synth.root = synth.nodes[0]
	
	synth.refresh_nodes()
	
	function el:draw()
		rectfill(0, 0, self.width, self.height, 62)
		local ox, oy = 1, 160
		for n = 0, 7 do
			print("node " .. n .. " (" .. synth.nodes[n].type .. "," .. synth.nodes[n].op .. ") -> " .. synth.nodes[n].parent.id,
				ox, oy + n * 10, 7)
			for i = 1, #synth.nodes[n].children do
				print("" .. synth.nodes[n].children[i].id, ox + 60 + 5 * i, oy + n * 10, 22)
			end
			if synth.nodes[n].height then
				print("height=" .. synth.nodes[n].height, ox + 106, oy + n * 10, 14)
			end
			if synth.nodes[n].height then
				print("depth=" .. synth.nodes[n].depth, ox + 156, oy + n * 10, 26)
			end
		end
		-- tree
		for n = 0, 7 do
			local node = synth.nodes[n]
			local pos = node.position
			if pos then
				if node != synth.root then
					rectfill(pos.x, pos.y, pos.x + node_width, pos.y + 8, 17)
					local str = "??? "
					if node.type == 2 then
						if node.op == 0 then str = "osc "
						elseif node.op == 1 then str = "fm "
						elseif node.op == 2 then str = "ring "
						end
					elseif node.type == 8 then str = "filt "
					elseif node.type == 9 then str = "echo "
					elseif node.type == 10 then str = "shap "
					end
					p8_centered_print(str .. n, pos.x + (node_width \ 2) + 1, pos.y + 2, 63)
					local ppos = node.parent.position
					if (node.type == 2 or node == node.parent.children[1]) then
						line(
							pos.x + node_width + 1, pos.y + 4,
							pos.x + node_width + 7, pos.y + 4,
							7
						)
						line(
							pos.x + node_width + 7, pos.y + 4,
							ppos.x - 1 - 6, ppos.y + 4,
							7
						)
						line(
							ppos.x - 1 - 6, ppos.y + 4,
							ppos.x - 1, ppos.y + 4,
							7
						)
						-- Arrow
						line(pos.x + node_width + 2, pos.y + 3, pos.x + node_width + 2, pos.y + 5, 7)
						line(pos.x + node_width + 3, pos.y + 2, pos.x + node_width + 3, pos.y + 6, 7)
					else
						local x = pos.x + node_width \ 2
						line(x, pos.y - 1, x, pos.y - 5, 7)
						line(x - 1, pos.y - 2, x + 1, pos.y - 2)
						line(x - 2, pos.y - 3, x + 2, pos.y - 3)
					end
				end
			end
		end
	end
	
	return el
end


-- Nodes -------------------------------------------------------------------------


local function depth_walk(root, pre_fun, post_fun, depth)
	if (not depth) depth = 0
	if depth > 8 then
		notify("*** Deep recursion: cycle in synth nodes? ***")
		return
	end
	if (pre_fun) pre_fun(root)
	for i = 1, #root.children do
		local child = root.children[i]
		if child.type != 0 then
			depth_walk(child, pre_fun, post_fun, depth + 1)
		end
	end
	if (post_fun) post_fun(root)
end


function synth.refresh_nodes()
	for n = 0, 7 do
		synth.nodes[n].id = n
		synth.nodes[n].children = {}
		synth.nodes[n].height = nil -- TODO: or 0?
		synth.nodes[n].position = nil
	end
	for n = 0, 7 do
		local type = sfx.node_type(app.instrument, n)
		local op = sfx.node_op(app.instrument, n)
		local parent_id = sfx.node_parent(app.instrument, n)
		synth.nodes[n].parent = synth.nodes[parent_id]
		synth.nodes[n].type = type
		synth.nodes[n].op = op
		if type != 0 and n != 0 then
			add(synth.nodes[n].parent.children, synth.nodes[n])
		end
	end
	
	depth_walk(
		synth.root,
		nil,
		function(node)
			if #node.children == 0 then
				node.height = 1
			else
				local h = 0
				for i = 1, #node.children do
					local child = node.children[i]
					h += child.height
				end
				node.height = h
			end
		end
	)

	synth.root.position = { x = 300, y = 5 }
	depth_walk(
		synth.root,
		function(node)
			if node.id == 0 then
				node.depth = 0
			else
				node.depth = 1 + node.parent.depth
			end
			local y = node.position.y
			for i = 1, #node.children do
				node.children[i].position = {
					x = node.position.x - node_width - node_gap,
					y = y,
				}
				y += node.children[i].height * 14
			end
		end,
		nil
	)
end


return synth
:: src/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTA3IDA4OjE0OjAwIixzdG9yZWQ9IjIwMjQtMDQt
MDcgMDg6MTQ6MDAiXV1sejQABAAAAAMAAAAwbmls
:: todo.txt
--[[pod_format="raw",created="2024-04-10 20:46:30",modified="2024-04-10 20:46:41",revision=1]]
- add 4/4 config

:: .info.pod
b64$LS1bW3BvZCxhdXRob3I9ImRyYWttYW5pc28iLGljb249dXNlcmRhdGEoInU4IiwxNiwxNiwi
MDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDcw
NzAxMDAwMDAwMDEwNzBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwMTAwMDEwNzBkMGQwZDBkMGQwZDA3
MGQwZDBkMGQwZDA3MDEwMTA3MGQwZDBkMGQwZDBkMDcwNzBkMGQwZDBkMDcwMTAxMDcwZDBkMGQw
ZDBkMGQwNzBkMDcwZDBkMGQwNzAxMDEwNzBkMGQwZDBkMGQwZDA3MGQwNzBkMGQwZDA3MDEwMTA3
MGQwZDBkMGQwNzA3MDcwZDBkMGQwZDBkMDcwMTAxMDcwZDBkMGQwNzA3MDcwNzBkMGQwZDBkMGQw
NzAxMDEwNzBkMGQwZDBkMDcwNzBkMGQwZDBkMGQwZDA3MDEwMTA3MGQwZDBkMGQwZDBkMGQwZDBk
MGQwZDBkMDcwMTAxMDYwNzBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwNjAxMDEwNjA2MDcwNzA3MDcw
NzA3MDcwNzA3MDcwNjA2MDEwMDAxMDYwNjA2MDYwNjA2MDYwNjA2MDYwNjA2MDEwMDAwMDAwMTA2
MDYwNjA2MDYwNjA2MDYwNjA2MDEwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAi
KSxub3Rlcz0iTXVzaWMgVHJhY2tlciIscnVudGltZT01LHN0b3JlZD0iMjAyNC0wNC0xMiAyMTox
NDoyOSIsdGl0bGU9IlZpc2lUcmFjayIsdmVyc2lvbj0iMC4wLjEiLHdvcmtzcGFjZXM9e3tsb2Nh
dGlvbj0ibWFpbi5sdWEjMTEiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InNyYy9hcHAu
bHVhIzEyIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJzcmMvc2Z4Lmx1YSMyMDIiLHdv
cmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InNyYy9lZF9pbnN0Lmx1YSMxNiIsd29ya3NwYWNl
X2luZGV4PTF9LHtsb2NhdGlvbj0ic3JjL3N5bnRoLmx1YSMxNTciLHdvcmtzcGFjZV9pbmRleD0x
fSx7bG9jYXRpb249ImdmeC8wLmdmeCIsd29ya3NwYWNlX2luZGV4PTJ9LHtsb2NhdGlvbj0ibWFw
LzAubWFwIix3b3Jrc3BhY2VfaW5kZXg9M30se2xvY2F0aW9uPSJzZngvMC5zZngiLHdvcmtzcGFj
ZV9pbmRleD00fSx7bG9jYXRpb249InNmeC8xLnNmeCIsd29ya3NwYWNlX2luZGV4PTd9fV1dbHo0
AAQAAAADAAAAMG5pbA==
:: [eoc]
