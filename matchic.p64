picotron cartridge // www.picotron.net
version 2

:: docs/
:: docs/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTI2IDE0OjAzOjI1Iixtb2RpZmllZD0iMjAyNC0w
OS0xMyAyMToxNjoyOSJdXQ==
:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNC0w
OS0xMyAyMToxNjoyOCIscmV2aXNpb249NDcyOV1dbHo0AIxMAADVyAAA8xd7WzBdPXtibXA9cHh1
AEMgHR0E8P---zwsZmxhZ3M9MCxwYW5feAgAy3k9MCx6b29tPTZ9LDQA8CQ1bPAEHGob8AAcugnA
DNoJCKAMKh8qqgkIgAwqLqoZCHAMKh4ZShk6CQgPNVAMSgkcCSoEAPAMGQhQDDoJPAkKCTwJGhkI
DTAMSglMCUwJGikICwAQrAkAgQ0gDFoJjAkqCgBVaglsCToUACwaOQoAEDxNAMBJCA0wC1oJHAkK
CRwaAP8oHTALahkqGRpJCA1Q6kkIHVAZqmkIDXAIGWp5CB2ACOkIHaAYqRgdwA0YaRgt8AANaC3w
BG3wFwQBHvEQbxHwBB5vDx8Q8AAevw8PDsAO3w8PDg8NoA4vDx8qrwwA0YAOLw8vKq8PHw4PDXAY
AFEfDy8OfxwAMQ81UAoA8AEeDW8PHQ8NUA6PDw0eDVwdGgD0BzAOnA0uDUwtDw0wDowNPg1MLQsP
NSALAGUKIA58DU4KAEw_DUw9CgDALg1MTQsKMA8QfA0eFQD-KBowCYwNHg0sTQsKUJwtHE0LGlAd
rG0LCnALHWx9CxqAC_0LGqAbrRsawAobbRsq8AAKayrwBGoXASEQFhcBMBQfFRcB8QMUDxPADt8U
DxMPEqAOLxQfKq8MANGADi8ULyqvFB8TDxJwGAARzxgAARMBQRRPE18aALBQDm8UDxNODU8UHRsA
8gMwDm8UDW4NPC0PEjAOXA2ODSwVAQMLABwKCgAqHD0KAFFsDW4NHBUBYRVsDU4NLBUBIXxNEwEf
7BEBSRAbEQEwGR8aEQHxAxkPGMAO3xkPGA8XoA4vGR8qrwwA0YAOLxkvKq8ZHxgPF3AYAFEvGS8Y
bxwAARUB4BkPGC4NXxkdDxdQDm8Z-QEQHRoAEzAJApwPFzAObB1OHTwTAVVMDa4NHAoAKgw9CgCR
XA0uDQ4NLg0MFwFjGlw9Dj0cLAIwDg08GQE-jC0sGwFJECAbATAeHx8bAfEDHg8dwA7fHg8dDxyg
Di8eHyqvDADxAoAOLx4vKi8eDx1vHh8dDxxwHABRPx4PHX8gAAAfARGfDgAAHgChUA6PHg8dDg1v
HhsAsDAOnx4NDg1sLQ8cUwMACgADSQMxLg1cFwEGCgAASgEuPD0KABEsHQEXHzQCTw0uDSwdAVAQ
JR0BMCMfJB0B8QMjDyLADt8jDyIPIaAOLyMfKq8MANGADi8jLyqvIx8iDyFwGAARzxgAATQCQSM-
Im8aALBQDm8jDyIuDW8jHRsAwTAObyMNLg18LQ8hMAMCFIw2AkQuDTwdQQNVLg0sDQ5PAz8_LR5R
AwgfJFEDWxAqGQEwKB8pGQHwBSgPJ8AO3ygPJw8toA4vKB4dLw9dDQDyA4AOLS4NTw9NHycPLXAO
LR4dTxgAABoBkD0qDU8PDS8UHR0AwVAOLUoNLw8NTxQNHyAANDAOPREA0i8nDy0wDj1aDQ8PDV8P
AAApAWRNSi1PFB0OACX9BBgAc08jLU8ZDT8PAJU9XyMNDx4NXxkRAHNPIw0vHg1PEQBEMA8pLRIA
AEMAEB8SAIM9LyMNTx4NLyQAYVB9Tx4dTx0AcVAfJ11PHm8XAHFwDy0fJ00vDgBhHzWADy3vCQD-
C6AfLa8nHy0fNcAMHy1vJx8tLPAADGss8ARsZwEf8A1PPxJAPuAODxYfKg8VDiAOHyofFg7QDg8q
PxUuBQBADg81wB4ApBQfFS8WHxUfFA8TANUPFQ8UDxNPFQ8TDxQfKAABFQARLxUAEC8VADGQPyw_
AFATLxUfEz4A-AYeHytgDyw-LS8VXy0-LB8VHywPK1ARAD8PNUATACXzAFBPLC8TTywvKx8TLysf
NVsANU8tLyIAH2ATAITvcD8rLn0eHR81gPwD8C7JAR3yPDkvKxAPD-AGDysgHvAFTyzwBw0-LQ0O
8AYNDD0ODzXwAx1sHfABDawN4A28HcANLB8qjA0OoA0sK4wdDpANLBucHQ4PNXAN-AAtDgYAKwpg
BwAm7D0GAP8a3E0OCnANvE0OGnANrF0OCpAdbG0OGqAOzQ4awA6tDhrgHm0eGvABCm79AyPwBU0P
LOAOoA4PLQ7ADg0OkA4dDqAOoABAgA4tDgQA0QyADg0PKx0OYA4dCw0OAFIbHW4dGwsAMyuNKxQA
Eq0SACr9AQYAkHAOLS5tLi0OcFQA8QkaDyoLDk0OCgsPGg4dDgxgDh0OCRsJDi0GAAERADMtDikE
AIAMYA49Lk0uPQkAIP0DSQD-Im0vCW0OHEBbXQhdW3AOPQ4dDh0OPQ4cgDstHg0eLTtwGyAOrQ4c
ABuwHm0eHPABDG6mAyPwAosPK2AO8AQeQB7wBA4PLE4NDQDwMU0e0C4gDm0OIC4PNUAeLR4ADg0f
Dw0cDQ4AHi0eIA5tHgwPKg4MCw4MHm0OEA59DgweDB4MDn0ODzUADn0ODRwrAPAJfQ4KAA6NDk0O
jQ4KAD5tDi0ObT4KAA4a3wDwBhoOChAKAD7NPgoQCjAOGg4tDk0OLRYA8AZwCgBOTU4KEAqQDioO
TQ4qDgrQCiAbAP8CIArwAw4NDhrwCQ4a8AsK8HHoAB0gGg8KA3As8AoPKw8WFAMi8AkSACAPNRQA
ER8GAEEPNfALBgDwBATvK8AO7y0OoA4N-ywADpAODfwGAPAOHD5MPhwODzVgLgwODw0fDw8NDiwO
Cx8PCw4MLkDTAfAFDgofEAoOLA4KGQoODA4dDjAODQwWABYZFQAAQACxIA4cDgwOCxoLDiwGAAAW
ABAIFQACYQDwAhwOCDAu-AEuGEAIDvwBDihgBgBgCIAOPI48BwBSLA6NDiwJAFUNDkwODA0AEHwK
ADCQDhwKAK8cDhig7hjA6PAwKgEpHxIqARZQsA4N3yyWBQUyARcMLQFVPA4sDjwlAQMOAAUgATBe
LF4CARILFwEgDxyICQAwASIfHTEBGAsbARELGwEwG0ALFQERKxsBEgsbARQLGwEYCxsBFQsbARUL
GwFvG6DuG8DrGwEfoC8fK6AusA4fLR4SCPALkA4fLB0eQA48HR5gDkwdHhAOHA8NDw8PDRwWAPIE
bB0eLA8PDxAPDzwdDiAOnB0eDB4AoVwOIA4sHmwdHnwwA-ECHB4LDiwePB0eXA4LAC4rDgwQAKMM
HR48DgsQKxAeEgByHS4MDgtwGxAA8QUMDi0eC8AbEB4bDjwNDgvwAhsADhwB4PABHhAOTA4LsB4g
Dg0e-wAhG2ALAHIADkwuGxAuCwCSDB0eLB47IA4dDABAXB4rYAgA-xiMHiuADrweK7AOjB4r0A5s
HivwAQ48HivwAw4cHivwBh4r8Akb8CI1AR2wFh8rYB7wAB4PLQ48CYEPLR6wHh0PLA0A8BANHywe
cB4dHA4fNWAOPB5ADh08DgtwDlwOMA5MDhuAywDQMA48PkA_PA4bMA5MHQ8AUB1MDgtQHwAQQAUA
I1AODwAhC3DuAAAFAGFwDiw_ID7xAfADLB0OCxAOHSwOG5AOPA4bIA48FgABtwMQMCsAEICBAhAc
TAAQHCoCgA0sDgw_AD4MRAATDbABcQ4cHQ4LDh0gABIc0gEBMwAAcwEkG4D0AQATACALEAUAYKAO
XA4cLmUCQA5cDgzcBaAOC8AOXA4NPA4bCAABqQEw4A5MtAAw4A5chgCP8ACeG-ACm7BbAR3QMi8r
oB6gHi8tDnAeHQQAQD8sDkBPAQC3BRQdjgKiDhAeHUwOMA4dPL4AQSweHWyFBBNcuwCwHh2cDiAO
fB4dbB6XAfEEEA5cHh08HiwOCx4cDhAOPB4dDA0AxQwOCwALLgsADgwuHRAAlR4LICsAHi0ODA8A
IRtg6wAACgARsO0A8QogG-ABDkwOEB7wAw4sDgweDQ4gHuAuTA4ACgByoBseLB4dDA4AUi5wCx5c
DgBwHQ4LgAsejA0AsBugCx68DgvQCx6MLAHgCx5sDgvwAwsePA4b8AWlAL8L8AgLHhvwChvwEUMB
HfIGGp8r8AIOLy0OXQ7wAA4NPywOTA7wTgMgXA6mATFcDtAwAjAMDlwzCCAMLhkAELA3AiAvNbAE
BGUBEKATAAA9AQAUAAFoARAcBgUwLA4ABQAEJgBwkA4NPg81PgQFACMFQQ47ABtsAGCgDg0cDkAF
ABAMDAABnwIgDSxoAFI8DiAODbYCYBw_CxA_LDkAUBwOOyAbxQIQcBwAAXEBAQoAJAtQBgAQXE4A
sVwOUA4NLD4LMD48UQBgPA47QBsODAJADUwOgAUAQQswHjxGAHAsHhtACx4sTABBHB4rcN4B-wNQ
Dg0eK7ALHgtQHivwABtgG3BuCX0x-QMOBQABXQkQzV0GdGAOLU4tTi1ICQVOCRIpTQkfCU0JRl8Q
EATw8DEACx8yMQD--0hfHR0E-zeJFw8dMTUAHzg1ACFfOw3-PA0GAD4PhgAdBzsADwYAOA_GAAwP
pwEdDRMFTw87DzwEACEXHwwADzgA--------By8PO4kGHQc7AA8EABkXHwwADzgA--------By8P
PIkGHHGPPA89DzuvBgARTwYAMv88AAcAEAEHABHPFAAXfyAAER8GABePDAAX7wYAAjAAJF88NAAR
LwYAFQ80ABMvZAAWBFcAFx8pAASDABAHBwAX3xMAEZ8GABE-BgAYvyUAF28lACZfPFYANv88Eg0A
LD88KwAdHxgANv88CA0AE58TABYCLAAXfz4AA3wABV0AJztPIwATHyMAFhYTABd-uAAIEgAXzzoB
AiQBGd9DABYTkgAIqwAP5AEZ8SYjIARw-zYD4P4F0P4FwP4HsP4HoP4JkP4JgP4LcP4LYP4NUP4N
QP4PMP4PIP4REP4RAP42AAkAESAVABFAIQARYC0AEYA5ABGgRQARwFEAP_D_A5cUDB41jgAfN44A
eh84jgB68zM7A_D-PAXQ-zsFwP88B7D-Oweg-zwJkP87CYD-PAtw-zsLYP88DVD-Ow1A-zwPMP87
DyD-PBEQ-zsRAP88E-87EwAPABMgHwATQC8AE2A-ABOATwAToF8AE8BvAD-g-zyvAA4OgBEPMQB7
AEIBBD0DE59JAyDgbggAML7QLgcAEI4FAPAATsD_Bg89sA0PO-4ADQwu8gGgTg0MPg0Mjg0MDvoB
8QUuDQz_BmCeDQxeDQwuDQw_UAz_CwcCwT4NDO4NDH4gDg0Mzi8A8gA_EJ4NDP4CDQwOAAz_BA0E
ABADNgAQAEUAQgwQ-gBaAFEgDG4NDG8AAzcCQb4NDH5eABFgbgAQcBwAEI5EAgFAAJEeDaBeDQzu
sA4mACGewDoAz9BeDQzO4K4NDE4NcK8THPAT8BW-NA8x0N80LzGg3zRPMYBfNF8yDzEPMA80XzFg
TzR-MgsA8AkvMk8xQE80jzIPMU8yTzEwPzT-MgE-MSAIAEEDPzEQCAC-HzEfMBAvNP8yBS8IABlx
LzIPMf8yAQwAch8xDzD-MgIMADIwDzQMABAfGAAADABQPzAQPzFyACAwIAgA8Q4BPzAwTzF-Mg8x
XzJPMEBPMW8yHzE-Mk8wYF8xP8UA-wYvMl8wgE8x3zCgLzHfMNAPMb8w8BUIBxwDIgFQnzQPMi8m
AQAOAB8PKgEQQjAPND8sARGfDQAhTzIxAWG-Mg8wXzI0ARGvPwAQPx4AEzI9AWAPMg8xjzL7AAC9
AAFeACQyLxkAEn8RAGA0HzIPMC8KABIxKQEB_AACfQAQL3YAARUAEDJaAABWAAAXACAPMBIAAi4A
IzIfbwBFHzSfMoIBVC8wHzS-IgAAZwBBHzQvMBEAIQ80DwASMcQARQ8wrzKfARRfDwACogGhbzIP
ME8yDzE-MqkBMX8yH8QAIU8ysAEAIAETLx4AETCsARIw-wABuwEASwFSHzAfMR_-AT8PMj_-ATYA
IgEQcKIAYKBPNC8xQMUB4IBfNC8xMC80TzFgbzQvlwEAcQAhUE-rABAP6gFwMRAfND8yP78BAEsB
AUUBVDEPMAAfyAECywASHxIAAE8BMCAvNLoBQQAPNB-kAEEgLzR-KwEgMR-yAACBAAA0AACHAZIw
HzFPMEAPND-FAfBSMi8wQE5gPzEvMj7wAy8xXkA-NIAdAB8xTjBdHFAdDzIMEC5AXUwwDBsOkD0b
XCAMHhAtHCA9SzxgLRscEC1rHB5ALSssAB1bDBsuQC07HAAdSwwrLjAtGwwbLAANDCsMDg4A-x4L
DA0rDA4ALDsMCz4wHRwNOx4APCtOUDwrLgAsjmAcXiAMjoBuMH6wLoAu8BNkAR3xBTZPNPADLgAO
TzMPMgAuwA4vMw8yDQBwDi8zDrAOPQUC8AcPMU2gDD0PMgxDDAs9DHAeDQwNG4Mb0gTwBkAeLRwz
BRQFBBMcDh0bMA49CyMUBQIAogMLPQswDi0LIwUQALUEAy0LDDAMKwwTBBIAVCscQCwjDwBjFAMs
UC4TDAB3BRQDLkAOLQ8AYw4tMA4dCxEAEB8SAEMtCzAtEQDCCg8qGhQDHRswCx0MEgCCOgMEAysM
QCwOAEcFGhMEXwAvBBNfAAIIEAAaPQ8AJy0LfgALfQAAAgAAfAATK3sAAAIAAXwAj-8wASxw-zUE
Qh8f8BGELzT1AS5ADg8qDg8y9QEuDTAuDfQBLg0gLg31Ay4NEBkAgA30Aw4MDg0QBQAxZE5kDABw
Lg1UXg1ULgkA8AB_Kw4Njg0QrgsMDwwPCgkMAPAPnQ4LDwwfCgmtIC1TDgsqCQ1TLTAeDVQeKQ4N
VB4NCwATXgkAMWRNZAgAJvQDBwAi-ggEAHEO-QhA-zAH2QAfS9kAYSUvENoAVBEPDw8O2wBSER8P
Dw7cABAvFwAD3gAfKt4AnBUV3gAQFp4rBN4AUxYfFA8T3gAAFwAP3gCkIxod3QBUGw8ZDxjdAFMb
HxkPGN0AABcABN0AEx3cAC8eTdwAkRQf3ABUIA8eDx3cAFMgHx4PHdwAABcAD9wAoxQk3ABUJQ8j
DyLcAFMlHyMPItwAABcAD9wAXgvgCVZvNA8xP_QJAA4JAvwHAegJQB80DzIaCADJBwIVAAHyCQBk
CCRfMicJEz-NCBAwWAgAxwgyLzEvFwARMDwIER8qAEQ-MC80-wkBEAoAGwgBHQAdMRYKEB_tCA8Y
CgIBcQAfbxoKASAfNIYADRwKAdAJASoABCAKER9fAB4fIAoAOQoCzgAJKAoRP8MKAxUABi4KAZgA
A1cADzgKAALSADQvMU8_ChFPOgAAXgA2PzAfRgozPzIvFwAAVwAANAABTgpiHzIfMV8wbgABdQEA
VApXLzBPNA8VAAFaCgGRCRYwKAADXgovPzBcCjsOhA4PMQDQ8AgjEwQgDxb-FQxADxb-FA4gDxYv
FP8wCU4GEBAMAEYPMG8nBAAAFwBWAA8WPxUTAAAEAHA-FQ8TDxY-LQAWKAQAED8qOAIsAAgWAB8V
FgAIAEIAFikEAAFCAB8VFgACHxYWAAgIWAAGQgAMFgAPLAAJCNwAAfMAHxUKAQE1EA8VLQGvIP8U
Dg8TQP4NIH4BGZMFBwQAJwAHIBcCAE8HACcAQAALHDhAAJEQByAXEAcABzACAC8QRz8AHAF-AEIH
MAcgAgAPPwAlPxAXQL4AJBEwQACvAAcABxAHAEcgB0IAHW9XMDdABzB9ACMgFxB9ABE3gQEPQAAg
Ekc3AQLCAB8gOgEhAncADn8AD0IAGxA3ggA-EBcQQAAZ-wIHCwQAPyoQXgAeHzoeDR4NAAUAA39e
DQA_HRA9mwAMLDE0XADBEB8qMC4POhA_DSAN3gcFAwB-EF4AXg0AXVEAHQetAEAAHQAeqAhBEC4d
AAMAD1MANZ8eHSAuQB4NHhD4ACpgQB4POiAuTgBwEC4NHgAeHU4AQV4NAC3-AC9AHVMAHcJfKgBe
DzoeTU4QXhBEAAWhAC8ATaEAH_AvKiA_DzoALi0AHh0gTgEBHx3sASwCoQAA4AAF9wAFBgAQIPIA
HyCaASgBmgA-AD4dqAAwDFYAcV4NAE4NEB23AABNAV8uHSAtEFUAGvEBChAEEE8qMG4QjgAuLzou
DRcLDwUAEK_ODQBuHRBOHTBNcAAMHDlvAP8DIC8qUD4POjBODSBeDTAdLg1QAwABQCCOAI5lAB_N
XgAcDs0AxwAtEC4NQD4NMD4dIAMAHzBhADEBXAAgUC5cAHEwPg1ATlANDwAvLiAhASmBEC8qYC4P
OlC2AEFALh1ACQAhAC4qBAR_AQG8ABFNbgBfUC4NYC1kABz1BI8qAI4POo4NLm0uDVBuIH4QjhBN
AA__ACvxBSBPKjBeDzoQbg0ATj0APh0wLh1AYQAzAC4tvgADwwAPYgAlBLwAJwA9HwEPCQAFP2At
MEICLgEFAH8Abh0Abg0AxwA3D2gABKGODQB_DRBuDSAtxgBQME4NEF5hAG8gPh1APSBkABn_Bl4I
BBD-OkogDv87Sg89AA7-O0wPPgYAMAAPPSEATD4g-UrDALEtMjMuMzE5MDQ3NgYAA24Aki0wLjcx
NDI4NQYAIjY4fgAKWQTQZhwE8Fj1UiAF9FIDEAUAMA86AAcAHw4GAGt8EPNSHiD_UnoFUzI2Ljc1
3wAfM5caAQDPAO_-9FIgBPNSDzsQBPNSDgUAWw_0ACGwEQ4EEA8WrxUwDxYdRRIgBwBSEA8W3xUE
DTEUXw4yDBI6EwCDDzpPFV8OPxUSAAIaABcVJgASFRQAMAAPFUkAFB8JAK8POiC-Ex86ML4QOQwZ
XxEOBPADnwAREwASAASdABIAnAAWAJsAEgCaABIQjwASIAcAPzC_II8AHA8tAQNATxU-DmBAAZIA
UR8OHxQfdAAAIwEzfxUfLwEACgAiTxUWAFlfFB8OXzEBJg8VFAAPPQFND68ABBYArgAUAK0AFgCs
AANCARYAqgAPTQEqwQQEBAAfOwAOHzoPPQUAPwAdAEAACx8xBRAsoRcLBPABHzuATlBwAP8pUB5P
Oi4gDh0PPUAOnQ4gHEAOvR4wPh1cbT4dPFAMrQxQHiAcfQxQDh0MMBw9HGAOHQxQPJAc8ABzABxS
MB878ARxACFOcAgA8A4gLk86HmAfPSAOnzoOEC4wHr0OAA89HT5tXB0OAHkA8AIsEAx9HCAecBw9
HDAOHQyAPIUAT-AEHEAkER4PMQD--5jwXygoBP8-FgL_BQL_Lgb_HQJOAu4C-hQG-gYG-gcC-g0C
-gMC-gICBgKOBv4MAk4C-jAC-iICXgLeBv47Av4FBv4BAj4C-hECBgLeAo4CPgJOEgYPMgYS-hMC
BgL_FgL_FwL_NAL_EAL_KgL_Ywa_QgAQEBsAMAcC3jcAEf4mAAIrABADSgD-AD0GTgL_IwLuAl4C
ngb_JLMjGcIoKASvPwL_CgIOBu5WAGBuAj4G-gkTACE_AggAAOEAARoAEK4VAID_DAL_EgL_N4YA
oO4CBgJ_Br4C-gALAXoGAj4C7gLezADQngL_AQKeAn4GXgb_UK8AES6-AGAIAv4dBt5qABBHQAAy
DQJ_LwCBLgJOBi4C-h5FARAxggDgAAb_IAL_LgIuAn4G-g0mADEOBm6GAB8B6AAc4W8-Bv4xAo4G
jgL_GQZ_vQEgVwaKADIIAl7hABDODAAQ3hoAMF4CjmsAFxPNABF_lACgFwKuAr4C-hMCvt0BdFUG
-gsC-hQ5AWD_BQJ_Am45ACAWArYAQQEC-gurADEMAk4dAoFbBv4hBj4CPhgA4QUC-hIG-g8C-gsG
bgKeDQAfINMAHCCPP1wAES6aABACxgBwRAJ_Bo4CzncCAZQAYf4IAs4CHk8CEARpACH_BNQBQQYC
-hwSAALNARAtVQFB-gIGrs8CQAIC-htPABC_6QAVBt0BEN5PAFIFAo4CLhUBEh6VAjGuAk5KABAX
IQEwHQauBwFBHQL_A9oAUAUG-iUGRAAQIiQAIE4GTQI-DQKu5gAcYP8-CwL_b2AAMSIGnpMAExZk
AUECBv4e0QARMCYCEBJzAZDuAv4zBv6DAo6uACL_ACoAQa4C-k4QAGAMAq4G-idXAjN_Ar5GABA0
mAIASQDPLAL_DgL_UQL_HwaOpAAeE2yxAjABAp6PAxgWQAIQAfMDMQYCvqwAEAuOAEFCBv4OTwMQ
AS8BQK4G-pGxACQMAnABIf4zNgRQDAL_OgYSABUWPwAQNq4AQb4C-lJjAk8tAv4uqwAeEBmJAQK3
AUEiAv4GpQFQBQL_DwYIAVEdAm4CrvQDEDtnAFIRAj4CBoIEAMcAEDoUAAEiAhBubAQQLisAEQLM
ABEtgAERDFYAERymAUEJAv4EIQMQBGQBEh5fAwJzAVAMBs4CjoUDMUQCXlAATw0C-hrIAB5CNwb_
CTwDMRACvkEDEAbcAwFhA0EDBv5cdAMB9QEh-gU5BRABJwATFoQAAK0DBA0AEd6oABJG1gNABAL_
MoEBBJEBEARYBQC8AAU7AEEfAv4mRwIQIMQAEAJTBE8rAv4ewQAZABQdUDVr8AQbCVRQG7oJwAsJ
VDALKhwIVDALKiwIVDULKhwIVBgLCFQXCwhUNg4wCwhUEwsIVDMOIAsIVDMOIAsIVAMUACwaOQoA
AwhUGQ4IVBUeCFQQDghUER4IVBIOCFQQHghUEB4IVP8AHsAOGGkYLvAADmgu8ARuj04hEBCPThAP
JEUQvQZUIN0MBFRQLR8RrQwBVIAtLxGtHA8NcBIAQh0sfQz5U3B9DB8RDG0c91MQjQsAIl0c91Nw
nQwvEQxNLPhTMo0MPwsAAOxDCQ0AOH0MTw0AABoAHzwNAAIATAASTFkAAXEAABoAMh81MHMAES0a
AFBQnSwdTBYAQFAcrWwRAMBwDw0cbXwLHzWAC_yyTxGssk8fbLJPKxAVIwESFCMBERMjARASIwEw
Fq0MDVRQLS8WrRwKVGEtHxbNDA8HVEB9TF0cA1RwbQxPFgxNHBUAkDAObQxvFgw9LAFUcF0MjxYM
LSwYAB8gDQANLx08DQAAAUwAJB1MWQBwTxYMLTwPEh4BMX1MLRcAU1DtTA8SGQEQEhkBHxIZAT8Q
GhkBEhkZAREYGQEQFxkBMButDBVUUC0vG60cElRyLR8bLSxtDA1UQH0MLxsxAhEXHgEQGx4BEhfj
AQANAOMsDxcwDm0cTxscPSwPF-cAMxsMLQ0AaE0MrxsMHQ0ALw08DQAAEF1kAGILDCsMDUxdAIJd
PAs8HTwPFz8CMQsMPRgAc1CNLC1MDxclARAXJQH-EBccbXwKHzWACuwKGaAarBoZwAkabBop8AAJ
ainwBGklASEQHyUBEh4lAREdJQEQHCUBMCCtDB9UQC0vIC1LAxAcJwFSID0MfQwVVECdDH0cEVRB
jQwPICAAAmADAA0ANywPHAsAAmADTy8gDF0NAAF-fQxPIAw9PA0ABUMtTA8cQgIQIEICERxCAiQM
LxoAAiIBExwiARAcIgEfHEcCPxAkIgESIyIBESIiARAhIgEwJa0MJFRQLS8lrRwhVHEtHyXNDA8h
RQIwPG0cGlRAbQwvJR4BEiHFAFAvJQx9LBhUEF0LACCNLBgAEiANADg9HC0PAEYtDAsMEQAwOywb
WgMDDgAViwwAMG0Ma2UDA14AEEsiARUhZAMSIWQDEyEdARAhHQEfIT8CPxApHQESKB0BEScdARAt
HQEQKitUEQwqVBAvEVQhTRwqVEEfKh1PGAAJKlQoHA8pVBAcHgAHKFQZLCdUECweAAQmVBQsJVQZ
LCRUGzwjVBs8IlQSPGIABSBUECzfUyUwDh5UASAAAR1UEEwaAGBQHF1PHmwUAGBwDy0cTS8MAAEY
VEDsCx81ZAJgGcAJG2wbRwEea0cBD14OPg8kXBU0HEocJFxADBkMKgQAASRccww5DAoMOQwkXFIM
SQxJDCRcQgypDBoQXDMMiQwkXEUMaQw6FAAsGjkKABA5TQACJFxzDBkMCgwZDCRcTxwqHBokXDof
OCRcN0EufQ8OngdjDn0OHw4OKQhgDhwOXRwLGALAnQ4sDk0sCzAOjQ48CQAnCiAKADV9DkwKAEw8
Dk08CgBQLA5NTAscXDB9DhwVADAaMAlbALAtTAsKUJ0uHUwLGo8DALpXAKkEHxqoBCUfOBxcQSJO
XRpcVW0OTxMOFwgzDmwOFghRDowOLSzOWAMLABwKCgAqHTwKAAA9ABEdEAFhFW0OTA4tEAEhfU4O
AR-tDAFJHxsXXCMgLm0aAAIbAjMvGA4ICADzAQIbAgP_AXswDm0eTB49AQFVTQ6sDh0KACoNPAoA
MV0OLHRREQ0PAWMaXT4MPh0fAjAMDj0RAT_NLi0TAUkPD1wYQg5tHx3zB2MqPQ59Dx30ByIOfQZc
VY0ODx0O9QczDgwO9AcBCgABIAIAalIRXQsBBgoAADwBLj08CgARLREBFx8gAk8OLA4tEQFQDwNc
LiI_bQFcVW0OLyIO5wczDiwO5gcAc1MEMANELA49HigDESz5UAQOAD88Lhw4AwgfJDgDSA-PB-80
HzjPBzD1GWnwBBk8CwwLGfAAGRxqGxjACRyqCwkIoAkM6gkIgAkM_gEJCHAJDDrwDzMJDDrxD3M6
CQhQCQwq8g9QKgkIDjAdAADzDzE6CQgMABCsCgCSDiAJDEoJjAlKCwBRWglsCVoLABcLFgAGIQAh
C0r5DxFKUAAjC0r6D7BKCQgeMAkLWhkqGT0AoFAIC-oCCB5QCAmhAGAOcAgJ6gn-DzAZqhkBED8Z
ahkDEDDAbvAEHj8RDxAPEQ8QmQIgHxH0B6EfDcAOHxGvDw8Q8gcyDxHv7wdRDxH-DwHtB2MPEV8P
Ln3qB1APEW0OHIZZQA1QDgybByFtDtEFEAygBBBtAVIQDMYHIG0OfgMICwAAfwMCCwB0DxBtDjwO
fRcABAsAIQltWldSCwowDglkAFMLGjAOCWQAwApQCwl9Ll0OCxpQC5hRALUDMA7tDrUDMB6tHrcD
MR5tHrkDHm65Aw8lARggbxMmAQAeXjEWDxUmARAWCwhxHxLADh8Wrz9ewBKgDg8W7xQODxKADjks
IAEOBAgECgABJQFgFm8UTm0OAwhxDxZdDkwOXRkAYTAODF0ObA0AgDAODE0OjA5NPQEVIAwAGQoL
AC8PFRcAAhIJRAABKAECXAABKAEjbU4mAS-9ASUBTxAYJQFxGw8aDxsPGiUBEBskCLAfF8AOHxuv
GQ8aDiIIUA8b7xkOHwhgDxv-GQEOHQhyDxtvGS5tDhoIMQ8bbTQCABsIEwzKAAElAQMrAgAvAUwe
TB5dAQFhDD0OrA49CwAmDxoMAAcXACMJTSQIEk0nAVRNPgw_TU8CAERcASkBP20ubSoBTxAdKgFx
IA8fDyAPHyoBECA7CIAfHMAOHyCvHk8LgBygDg8g7x4ONghADyB-Hl0DYRxwDg8gfQoAASoBICCN
LAgQHAoAAsEAIw8cdQMRDBkABQsAAk8CAPkHAlUDBwsAAhoIDY4DFAkLAAtPAgLPAw8oAVYQIigB
cSUPJA8lDyQoARAlUgiwHyHADh8lryMPJA5QCFAPJe8jDk0IYA8l-yMBDksIBAoAAScBYCVvIz59
DkoIMQ8lXfkAIw8hdwNhLA6dDg8hdwMzLA6tKAERTU4IA1YCE01PCAIPADEPJE1RCA9-A4IQLS0B
cSoPKQ8qDyktARAqaWTwCB8swA4fKq8oDykPJw8soA4PKl8oLw9fdmQhLIAOABNPDgAZcA4AATsB
MyovKHcIEC0UAAASABMdaggSHSUARDAODyqNCAEkAAERAAOACBItJABQIA4PKj2DCBY9EAAl-QUM
ACEpPYkIBx0AFC2MCAZBAAZvZBUteQAkKR0UAAGNABEfFAAULZgIAygAklAPLA8pXU8eXSMAAA8A
FCcPAACkCAAPABQvHgBwgA8sHyetHAsAn6AfLBxtHBsfNX4QXw_vCBQj_gGsCCH6A6UIIqosTwhh
DLoMCgxanQgy2gxaeggjWowJACH6BQgAMws6rBEABCMAEws2AACQCCOqLIoIL-oDhwiPAgoAAoYI
II8PBAABhwgHDQABLQIwEZ8PBAA5Dg8NDQABXQIBDwBWDw8PEX8TABN-EwAKFwAfEBcAA0URTw8f
FwACBAA2HxFPNgAhTw93OwUfAAAMABVPmwBDED8PPxsAUj8RPw8O6RhRDxD-DwMjAFJQDw0PEOcA
AMECJA0O8wBScA8NDu8wAHCADw0erw8eCwAwoB8N1BmgHw0fNcANHw1uHAYSHmwqbg-6CFkgjxQE
AAP8CAUNAAH_AGAWbxRvFm8PAAINAFIPFk8UDxEAAT0BARMAWg8ULxYPFwATTxMAVS8ULxZPFwAS
FS4AHE9BABjPIgA1PxaffwAVFY4AGh8PAAB4ATISDxXGAAB4ASQSDtIAUnAPEg7vMwBwgA8SHq8U
HgsAMKAfEikaIR8SeAEeEngBD00JVAIKAAJMCTH-GQNKCcEPG08ZPxsPGT8bTxkdAGEwDg8bXxlS
PCMbDwgAEF8bAAQZADMPGR8EAAMZAAE9AQEbABxvEwACWgAGEwAjGo9WABaPJgAOEwAMJgBJMA4P
GqYAAZEBEhrDAACOATIXDxrcAACOASIXDgwAAI4BMhcO7zAAcIAPFx6vGR4LADCgHxeeGiEfF44B
HheOAQ_xCUoz-x4BsAkCCgACsAkz-x4DsAkQT04AUx4-IE8etQlBDyBfHgQ9IyAPCAAQXxsABBkA
Uw8eHyAPCAASXzQAEyAbAFY-Hg8gjxMAVU8eryBPDwBHH-8eBS4APo8gXxsAsjAODx9vHk8gbx4O
AxoiDx_pAAB0ATIcDx-CAAB0ASQcDs4AUnAPHA7vMABwgA8cHq8eHgsAMKAfHO0aIR8cdAEeHHQB
D-0JYGNfIz8ljyP-CSFfI4w9AhEAAfoAMCVvI6w9MB8lnxMABBEAEs8gABEgDwA4TyWPDwAxDyUv
MwA1LyVPFwASJEYACgQAHk82AAAEAAk2ADWPJU_LAFIk-yMDDmMaBAwAAIIBMiEPJNAAAIIBJCEO
3ABBcA8hDvsAAIIBUCEeryMeCwAwoB8hTRshHyGCAR4hggEPUgpCFe9OCjT-KAFLCgMLAAGGATEq
jygEAANECuJPKC8qDygPKg8oLypPKCYAETB_CgAUAAoEACRfKFYKAB4AEy8EABNfNgARIBgAGY8Q
ACGfKAQABToKDCAAD0gABCcpX3YABAQAFl_eAB4ptgABqwEWKdwAA24KA-oAA20KBQgBAWwKE_85
AAFqCjGvKB8NALGgHywfJ28oHycfLLgBbixvJx8sLboBD3MKRvAUTEmASYAJHCsJYAkcKwhgCQxK
CwlACQxaCEAJC2oLCSAJC2pQCoALegsJAAkLengKgiAJC4oLCQuKPQoymgmaCQABYApAMAj6BEEK
IwgJQQoBOgovHmA6CgFRoAkcqhvcClILCIAJC9wKAQcAcg5gCQt6CHoJACFqCQoAgXAIShkIDgha
RwD-BDkYHgAYOQgeoDguIA44HsA_YD5ZaR-RMX7wBQ4vET8QHw3wBKsJMh8QDwsAEF9bCWXwAw4P
EG8KAAEUAEUPNfACFgAFCgBHDzXwAQwAEQBFCg8MAAoR4KYKBQsAEn-LCRHgZwoFLQAJDAASbyMA
BgwAC3UANwIPDQsAFn8LABQOuQBUAw8NHk8MADEfDW4IAG8MfQzwBXwVSR8RUh8KG28ZCgAtCiK-
FBkKERUoCRSQCQBEDzVwDlQJBgoAASQEQhX-FAMhCgMKAD8PNUAMACgVUF4AFx8MAACGA0ES-xQA
FwAFxwk-DzWQxwkSHzQ1Sh_AGPAGHh8bLxqCaBANhglAHQ7wAgtsAdEBQQ2cDxcHABALAgJCDZwL
CgYA8AywPg2cO4AOHxsdrA0ZDQtgDgn8Aw4LQA4N-AUCEwEHAC8KIAgADPALMA5sDgscDgsOTB4L
GkBuGxwOG04bGmAKSwoWAFAKSyqQSgkAMWrwARAAJPAHBwAQLgYAf0sK8AhK8BjyAB1wOA8d8AwO
8JBoc-AKDg8fDxwHAADNbQQJACEIDuMIFRwJAHMPNfAHDg8fCwAhBg7WCBUcCQBCDzXwBO4IEByF
AwKqCAD4AhEf_Qgk8AAKAHAPNdAODx_vCwAFCQABxHMPCwAWFNBLAFAfNdAub9cIAKkBrx8cbh0f
NfABDG3rcCOgUl8i8AUeHyUfJKUHMPACHtYIEh__B2XwAg4fJC8MADMPJD8MABQDDAAAogMPGAAI
Hk8MABGw7wgxJF8jJAkRDRoDAA4AEA0AaSMPJBEAdG8jHnAODyQgAHB-Iw8kHjAevQgEEwBhjyMf
JD4MqwABYg9gDJ8jPCsOhg7wFw4M_wEODQpwDgzrDg0acB7rDg0KkC6rHg0aoB0eax4dGsAKHW4d
0BIRbdASDzsDHqBULvAJDh8RDxAOGwJxET8PDw3wBiwPAbsEcgApEA4PEC-JBJAALxOgCRwLCRAp
DwAccVAfNQ8TH7UOgBOACQwqCwgAGQASDy0AIQ8TxkOwFQ8ScAkLOggQDw3RAAPpQqMSDzVgGUoI
EA0XEQBwEw8SB3BZCItB8SJfEw8SF4BYBzAPE08SF6BXQFegXyJAXxigDyIfJS8kDyEHMA8YLxsf
Gg8YgA8iDyU-zBzwAwcADx0QDxgPGj8ZDxoPF3APIr4BAhgAIA8gHABwF08ZDxcHYBkAEi8zAAEa
ALEeDx8PHQAPFw8YL1EfdgdwPyIPIRccALEHAA8XLxgPFxeALxcAEB8rA3QQLxcXoCcADwCBBxAn
8AAfHS_AHv8CB-AGBi8dBhfwByYX8Akn8DZYCE_TSIBIgAgMOwhgBQBESgsIQAYAYGoLCCAIDFkI
gggLegsIAAgMWQhhCAuKCwgMWQhSCAuaC5oJAANZCAGTEkMeQAgLUggSC1IIkQvKCQgeoAgLqgcA
sgzaCKAIDPoACIAILRMTCFEIUggLegl6CQADUQgwYAgL9RIxCGoJ2hJyOgkIHgAISl8IQQgeIAhf
CC8eQF4IJvEBffAFDV8RDxAN8AUNDk8PDggAFkwHACAEDaBvUPADDQ5sHQBQAg0ObAvgAhEBCQAV
CggAwQANDxF8Cw0K4A0JjAcAGg4HAFF8Cw0a4CwAOxrwADwABEQAQAINDlwIAEADDQ5MCAARBAgA
JPAFBwCfaw3wBX0K8AV6CQgfMFGPEoAEYhZ-FQ7wAeMRIBUOgnkBIxIgwA6BETIPFQ4qEjMPFQ4q
EkEPFQ5gCgBCAw8TDqYHAAoAAX0EDwwAPgMGCDAPEw7zcQCRCAELAFKADg8VzwsAALAIEq8LAADG
CBKPCwAw4A6PBwCf8AGOHfADjfAzSA0fMBfwBSgRQRoO8APtGiEPGiYBABQREBjzbwELESEYDgYK
DwsACyKwPgsAED7zEWA-Gp8ZPxpCAQDoEUEPGg5ACgBCBQ8YDjkREQU0AB8gDAAUEG_sIyMaD71-
FA6RETAPGB4WACAPGGkXkA0OHzVADk0ODGR4IRkNGRlEHGBOHA8AZABOHIBMAA4ANRBM8AwAL-AH
CgABX04M8AhMZggfNVUPHGMIcSAO8AoODQ5XCBANGgUVDgkAAUwIIQ0vFAAECQABTAghDU8UAAQJ
AAAjCwB4fwAUAAQJAAKgCRGPFAAECQAAHwgQDcwjIQ7QMggQD1FwH8ALABgCXgghDx1WAgB2EQEL
AEHwAQ5vCABfA24c8AVfCCAwUW8hYgIAhQYRIkgAEQ5rEA8MABoArgYiDg8MABZPDAAfJAwAADaw
DlANADKgHg1dCEAPJA6QEU-BQA4MbyMMDnAODA8iDgCDfyMMDlAODAsPAGGLDF4MGwoLAGGbXCsK
Dg1MCP8VCg4dYA4M6woOHYAODMsKDh2gDgyrCg4dwA4MiwoOHeAOig4dggMmwVQt8AkNLxAN8AcN
DvRSI-AGCQAA5gElKBANALEALxKgCCsIEA0PDjNT9AAfNQ8SLxUPEoAICyoJCAAXAEEPNQ8SAUsA
6CcBGwAjEA0uAAQXAGAPNWAICzoZAADpJwNKCPAfDHAISQgMEAwAB08TBxyAWAwwVxygXEBcoF8h
QF8XoA8hTyQPIQwwDxdPGg8XgPoRAkQIcQwADxwQDxdECABPJwAaABUvGgAjDx8eAAIoCCcMYB8A
AR4AAC4IJxwAIgCGcA8hLyIPIRweABMMTAgyHIAvFwACMgh2EC8XHKAsABEAYgwQLPAABg4A-wAG
DPAGBiUGHPAHJhzwCSxPCFDwIzcp8AgZHyoMGPAEGR4MDgocGPAAGR4sDiocGLAZHkwOShwYcBke
bA5qHBhACR6MDoocYgjxKQoebB4MahsJCwgQCAwqHiweGgscKhspCwgPNQAIDEouKgsaCxwLSQsI
DRAIDEoMKgsaKwxJCwgdDgBQGgsaKwoPAGENIAgMWgwOAFFZCwgNMB0AISsaKgABDQAxCisqKAAQ
QCgAIRsqJgAQUBkAIQs6JQAADAAQbCEAkGAIDDoLaQs5C7Yr-xcMGguJCxkLCB1wCAwKC6kLCQsI
DYAIDAvJGwgNkAjrCB2g6B3A7XkIH5A4DvALDg8qDw1GCyAqD9MQEwgJAAJiDVEqDxEPKi52Gw0P
AAEiBXIPKh8RDyofIAAKDwABLgVyDyovEQ8qLyAACg8AAToFAhEAANUaAyQADhMAAQ8FJCovWAAD
FgAW0CgAGBAsABewGAAIMAAFGAAgEB_6EQUwABeQGAAXL0oAFZB0ADcvEB9gAACzFHE-EQ8qfxE-
EgARcPQAYx8qjh8QHyMAEVAnAWEfKs4fEA8TAINQDh8q-gEfEKUbMP8QA3sMr2D-DQMfNYD9A-Dw
gB7hcS8T8AgeHyoPFh8S8AQJAFAPKg8UHw8AAH8VUS8WDyovDwCRsB4fKk8WDypPDgCRcB4fKm8W
DypvDgBQQA4fKn-8gpAWfxQfFg8SIA0eADAfKg-2DCEUHxAbUA8VDRANKhuBDyo-Fh8qHxS5BCAV
HwRQQBYODxUNBRENTlcAjQAhKi8gABEvPwAAdRsVHiIAEC9CAAMeAAA8ABguPAATFjAAAR4AALkA
JA4MOgDxAAwPFAw7HBsvFRscPgwOChQA8CscaxwaCxxuDAoNCRANGnssfhoNGSAdGmsMbhodGUAJ
HRpLDE4aHSlwCR0aKwwuGh0psAkdGgsMDhodoB-vHSodKfAECS0p8Agp8FN7AR2RTf8YAaAO-yoB
TxuhKv8bAQ8qDxdgDaMaMCrvGxdW0BsNUA0MHxkPKswLHgwjD4MNDC8ZC6wLLg0ART8Zqz4LAHQL
Sg8aGgkMEQBgOgs6CRoZDwARCA4ARioJGikOAFYaCRopCg8AVgoJGikaDwBGCRopKg4ANhopOg0A
NgopSg0AJilaDAATnAoAUioJrgkuCwBSGgnOCR4LAP8QCgnuCQ4MDQhQDQz_AQkNGGAN_QENGID9
ARig_AHwLz0BHfELbT8dbxzwAQ8dLyp-IA8c4A8dDyofIA8qHx7VEQDQGkAfDxzAFwBSLyAPKg8X
AEEfDyAvGQAaoBkAFS8ZABCAGQAQPxkAAhcAAu8aSh8PHGAZABUvGQAQQBkAEU97ABAvAg8hIE8X
AIAgDx1-Kp8gbwsAQQ4PH080G5QPIE8dDx8OHzUTABZvEwAhQA5BDwETABI-EwATYBMAFk8TACGA
DgsHARMAEi8TABOgEwAWLxMAAAEKEx8TABIfEwAT4BMAFg8TAAASDCMfDxQAEw8UABYDFAABEAAi
BQ6EHCIOHzITAAgAjwkOHfALDfA3tQEdMjcvIh0GMCUPIU0AAAkAESq9GgFOCmIqHyUPKh8PABAD
NQVCJQ8qLw8AEAEsBUElDyo-DwAQ4NIZQSUPKk8OABDAYhlBJQ8qXw4AU6AOHypPVwAhTyPMG4Qh
gA0PJR8jH2AAAQoTcB8kHgwNcA2HCoIfKh8jDBsPJToDs2ANDyU7ChsMGxwKEACACjsKCwwbHAsQ
ABEJDwBFDBscGw4AcwwKCxwbCgwPAPAfGxweCgwbCh4cHgwNCXANHE4KCwpOHA0ZgA0MXgpeDA0Z
oA0MTgxODA0ZwA0MPjYA0RngDQwuDC4MDRnwAQ1ehEANGfADLIIQDgoA7wUNLA0Z8ActGfAJKfAZ
cwEdMVCvLT0BIJ8pnnwRD1sbEG9JG20uDykPLNASAAP3BhApMxsxDykvFAAOEgARD_0GcU8pDyo-
KU8SAAAQAIA-KQ8qHygPKQQAEz8oABNwKAARDxgAEx8uABNwLgACFgAVPy4AFFAuAFApHygvKR4A
AjAAM1AOXxQAMS8oXyoAEUAfGzEPKQ8UAAQoAAMPGxA-UwAFhQACFhtnKU8oHyk-KgAScCoAAkcA
BCoAEnAqABVPJgAQkBEABGEAEy8mAA8VAAAwDzWwFQAAswAkby5NAR8fFQABYQ810A8srx4AMOCv
LIYDP63wMskKTvAmNRo58AQqHDsZ8AAaTFsZsBp8axmACpyLCWAKrJsIUAk7bHsZCA81QAlrPGs5
CEAJixwrOjmbJYCrakkIMAmrej0_AgcAUDAJm3oprSVii4opCA5ABwBgUAg5K5oZtCUQaQ8AEmAH
APEAcAhpehkIHnAIeVopCA6QRz7ACNkIDsAIuQge0Ah5mTBfeD7wAn6CDh-QNj8P8AgOPxEe8AUO
becQ8RqNDvABDw4vEE0uDw7wAAwvEH4MDzXQDD8QfhzQDDuODA81sAxLjgwPDQcAkgoPNZAMW54M
CgYAcglwDFuuHAoGAPASCVAMa64sClAMW84cCgkwCjwb3iwKMApc3iwKCSAKfK48BwAwjI5MBwAk
-AcGAP8FMBr8AxoZQAkqzCopcBnKOcDJ8BTVAB3wLHJPFPAGHk8WHxPwAh5vFh4PE_AebxZODxOw
HR8VbxZeDYAdPxVfFn4NYA1vFS8Wrg1ADZ8Vzg0wDZzO_CXADZyuLQ8SEA2snj0L3giYrI5NCwoA
DZyeBwD-Jowdfk0LGhANPG1eTQsaMAutLl0LGlAb-QAbGnAKG70bKqAKG30bKuAKGy0rKvADCis6
8Acq7AUf8ANSjxnwAh5-Gw8aHxjgDo8bPxq2NbCPG18aDxigDp8bb7UWQA6fGy56DnBwDp8bTj8a
XCNwYA6PG24fGsU1EFDFFlBvG44PGikOAKeMdBgvGi8brj8OACZfGgwAP08avgwAAj8-Gs4MAAJh
LxoPGM49DQBiDR8aHb5NCwBQDxo9nl0LAP8XUA8XTV59DB81UAz9AwwLcAz9AQwbgAztDBugLK0M
G8AbrBvwALvjAR-wJ2yPHvACHo8gHj8dkB3PID8fHWANPJ8gbA1AHUxrHnwNMA1sO348DQ81EA18
3i0PHBANbO4tCs4B8Udc7j0KCQANPD2_TQoJEAp9rj0KGSAKfY49ChlACm2OPQoJYAptbj0KGXAK
XV49ChmQCl0uTQoZoArNChnACq0KGeAKjQoZ8AEKbQoZ8AMaLRoZ8AUJKrwKHzbGAB0wGT8jfgMR
JX4DYB7wAg8inXUD8iUfJH0bDNAMS007DMAMWz1LDKAMax4dSwwPNYAMa05bDIAMW25LDApwDyEs
K347DApwCUyOBwApnisHADAMGwkIACCOPAcAMVxuTAcAIV5cBwD-J05cCRqACVw_XAkKkAlsHmwJ
CqAJ3AkasAm8CRrQCZwJGvAACXwJGvACGTwZGvAECjkq8Ac6oOIAHYBQfy3wBA5-KmMq8RCtDyke
wA69LA6gDs08DoAOLJ1cDmAOTI1sDlAOXG18uRRSfF1cHycKAEFfKEw-QiJBXL8oT4khECB8ISYs
zw4AVD8nzyhfDQA2Tye-DQA2XyevDQAxbyePDQAA7ZBhLH8nXyhvGgBjQA8s-ycE2gYz-ycCugYz
-ycAngYj3yd9BhGv4SGv0K8sLzXwAKvwMzERT7Ao8AgYLBjwBBgcKS0RohgcGQoLChkcGLAKABIL
DgAWcA4AAxIAGjASAAMWADwQCAwWAAEaABIMSxE-CQsKAgAATwkMCA4dAAptEAgMCQoLAgBPCQwI
HhsABy8OIBsABx8wbgABAE8ADxkABS8OQBkABR5QZgAASQAPFwADLw5gFwADHHBeAABDAA8VAAFg
DoAIDOkMmwef7AgekPgBDrD_jQ0gsDgN8AsNDxEN8AoNqxSA8AgNDg8ODg0IABEMEQAgBg0oiBIM
BxUiDAsVABAEFQAyEBsMlBoiDCsWABACCwBCDxALDJwaQgwKKwoZAFIADQ4MGw4AAQwAQAsKKwom
ACMJ0A0AAEEAE9AlAABWACIJsD8AAg4AAA0AEysmACQJkA0AAUIAFJAoAAFdACMJcEQAAxAAFHBf
AARwAP8HUA0O-AMODVAN-gUNCVD9BRlg_QXwLXkRH_AS8AgeLxYe8AQeHS8THdEiIh0cMREgHB03
jJEcGw8VGwoLHB02jCEKGwIAAA8AUzAeHRwLEAACEgBCEA4NHA4ABBQAiA0OEA4NDBsKAgAhDA2F
jSYNDD0AAS0AQAwNDgkXACgKGwIABBYADUQAHwlDAAcNhQAQCdUAJBsKAgBWHB0eCSASAGMcHR4p
MAkQAADIACIpcA4AAAsAcLAJHh0sHR5oETAeLR5oER8uaBElEBdoESAbAQaKQP8YAQ0-ijEM7xoP
ARBgCwAWGQsADxYAkDD8AQ3Giq-9AQ4bgP4BG6D7PxEh8ACvHPABDq8gDuAODa8dDQ7tiwAgERMv
BAAgDA2ai2UMCw8eCwoCACAMDUIBQQwaCyoCACAMDUGLdwz6AQwNDkAYAAEaAAC1cy8LCgIAAAQc
ABMqAgAA1wAAEBEDSQAQGUoABxsALBlgSQAAFQAAhwAGIwAAqgAQigkAAMYABBUAFOA4AAAwACDw
AQ4AARgAABYlIQwKCgAxBQ4NCAAgBw4GAG8JDhnwCwnpCh_AGi8h8AkOLyU2IlENLyINDlgAAGcQ
MQwNDm4ARA8jDyQQAAGJAEAfIwsamAAR4DYBEhoNAAC9ACUKCw8AAX8BFhoQAAJ6AQcRABhwIQAF
HQIFQwAhGgusAxxgNwAsCWA4AB8JNwA3GHATAASpARYKRgAlGaAQABQKsQEBDwAEsgEADQAFsQE0
CgsKsgESLLABEC2uARAuChEPP5Aegk-PLfAADq8qFB1QKq8nDyrtjiIPJ6APCQQAECdNAR_wHQAE
AyEAAC12BRAACQQAAYsBH5AfAAYDIwABIQAHEwAKBAABRAAfcCMACgMnAB9waQAKBZAAH1AnAA4D
KwAfUHUADgWgAB5AVAAPfwAnAQcEH1DyABEPGQENAUoADhcBD6MBGAFCAA6hAQmEAAEAAg98AAP-
BbAODawNDgvQDq0OG9DOC-AAy-AxeQtTECt5CzAbKht5C-IQG2obGLAYG6obGHAYG_obGDAYG-oD
GxgQCAtqGUoZao0cIwtadkAgWgs0CyMLSndAIEoLJgsTC3dAMQsIHg0AEKwLAAAbJQFXQBELHiUw
SglsCwAgHjAhABGMIQAWQAsAEFCsHgB4QCAqC8QKIws6eEAAHABwYAgLShkqGUgAcnAIC_oLCB4H
ACIOgAcAAI0cD5QKLRkQlAobD5QKMywODQcANQvwBB4lEC86lxILfQpCHxEKHIkKMBwKGQ4KEAt8
CjQsCimHCjEcCjkXABDQFgAxOQocgwowHApJCgAiC7AVADY8Dg0KAJELkA0OPAopClx4CjBMChkK
AFILcA0ObAsAUHANDnwqEwAIZwp-C1D9BRtg_2cKJxIVZwoSFGcKEWxgChGsWQpBTE8TTFMKYVwL
TxYLXEwKUWwLagtsQgpTXAuKC1w3CgMMAB8JCwARA0IAAP8JUlwLSgtc_AkzTEtM8gkTrOwJH2zp
CUASGukJEhnpCQAuCQY3CXJgDg1sLxhsCgBiXAovGwpcDABdTApJCkwLAFI8GkkaPAsAUiwKiQos
CwBfHAqpChwLAAkAIAI0CQopMABDPDoJOkYAQ2wKCQp_ACNsKgkALvwBCAAP4Ak0ER-gCREeXQgR
zFQIQWwPHWxNCDF8C3zACWF8Cw8gC3zCCVGMCwoLjJ8JM4wLKgoAMHwLKh4AAaIJAcoBAqMJUkwL
SgtMnglSPAtKCzzrB1IsC0oLLOYHUiwLKgss4gcyLCss3gcTbNkHGkzVBw_FCTgSJIUJEiOFCRJM
gAkSbHcJEYxwCResDAFBTD8iXAwBYUwLLyULbC8CEjzwAAEyAhIsBgETCQsANjwbLA0ARSwLCgsP
ADY6KxoNABSKCwBSPAtqCzwLAAMvAQAgCTJMS0wtARLMKQESrCUBHowjAQ-4CDoSKfgIEClFNQD4
CCOvKMUGYU8oLydPKNAIgzwPJy8qDyc8HQcSTA8AEUysCKMcGxwLDyoLHBscgQdQHAsfKgtiCwAW
ChEcPAEQHPsLEAuCCxMc9AdRPDssOzxUCGX8Aw0OCUASACsJUC8AERkRABgaUgAiCXB3ABIKdgAQ
GT0BIQsqSAESkKkBAHcCAKkAECsUAAJ2BxIZBwAQCX0HfxnQzgnwAMl9B1Bwk3jwBQhaCNUQRQha
CA4GAIAaCCoIDmD4AQYAOgj6AwYAIDD4QQcr_gYGAHL4BCoIDkDuPAAFSgAHBgB-eA7wBX7wZqQA
HUBTTfAINkEA_jAPCAAYQE3wBA3aZwCRJwEJADIM4E0HAAEOAA8JAAshkF0JAEFdUA0_EQBqLg0_
DQxADQAhLh0NACAdLg0AX34NLg1_CQACj-0HDFD8B-As9wAdkRlPEvAIDi8UDvIxCggAkQB_LxRu
oA79APECRP0ADgwGADEtni0HADgOfQ4JACFQTgkAEE7RS4AtHi0ObQ4MEAsALA49CwCQTi0OLV4t
TgwgzUNBvQ5MUAcAJQyQBwBw3gyQDp0ObAUAMgzwAAYAkX4tDgzwAVwOLbMqFS2vKg_9Fh7RTP8X
A5AOfxkOfQ6QDsBFITWACAAhDIC4ACEtHo_aAK0ALT0OCwARrgcAAy8ACQcAEF7WAKEMkDwOLQ4t
DlzQBwA-DPADCAALEdA2AB_QUQACT-4DDJCnpSEwhv8c4QAaHtsAD_IAAwAEAAgLANhgLi1eLX5Q
Dv0FDgxABgBA-gcMUEObJxxQT5vxAWD_BQxwDA7tDiyADu0ODKAFAI-_AQyw-AHwTLcAHSAtn9og
In8jACwMCABCLyMeLQoAAagACAgAJs6wfQACBQAxLY4tBwABdAINCQBDfkAOLQIAQ10ODDAeAA8L
AAMxHQ4tDQAxji0_CQAr-QYGAI-_CAxA-AjwK4w2H3Et4J4vKJ5QPQMRfTIOAgoAFwwJAAGuAQKw
ARVApQEPDQAAS14tXi2xAQIGADqeLZ4RAAMGAAUyAApIAAkNAAh8AAWSAA0JAABiAF5QfE6c4Dku
D6ofQA8mXg8SyiNeIPoDHF4xuig6Fl5QyggKCDoUXiLqCP5dImqICAAh_gQHADFKqCoBXiLqCAgA
ADAAERoHXiK6KAFeL-oA-l14E838XbKdDw19HAtQDp0LfbNTU60LfSwLBwBzCiAOrQsNC5pSKwsN
DAACxFVBXRsNCwIAEhuMUTFdCx0QACEdC7tTgA5NOw0LDTsNk1E-Dv0AklE6D95dMzqdDxIDASF9
a7RUQ30LTQu7VkMLDSsNDAB0XSsNCy0rLRgAE0uZUyILnQgAITtd9QAxnQtd8QA-nQtN8gACD7dd
YyHNDHsfMQ79A6lVUl07DTs98wARbbUBMB0LPfkAkW0LDRsNGw0LPeUANG0LbQoAADAAAQoAEJ0K
Ah48CgARTf0AAFgAHx3wAVUPkF0OFK2OXRPNjF0A-gAfHP4ADDMLDRv0AEELPQttCgAiXav1ASH9
A_8AMW2LLQgAIf0C9AA-fUs98gAJD2BdazFtPyHiAgDoAATkAkILDRt95gIRrdcAM31LbdQCNi0L
DeACAwIAJB08HAAULQwAEovfAy-9AfgAVQ5sVRAm_ABQKq0MDyb4AFAqrRwPJvgAUirNDA8m2gMR
JvgAALQDJQ0r7QETDQIAA_8BANQAA_0BEosIAAT9BATkAQIkAAQMAAQ-AAAQABMwXAAfHe4DJA-v
Bn4h_gPuBgDVBgIGACwOIAcAKAM5BwARAuQGL-oB4waHIf0Dslwi-QMAAkL9BCwLBgAsCiAHACgD
PAcAHgLhAg_7BnwA2wAfEtsAkQ_kBiQP2wCRD4EGJA-bAJEPagYfANsAHyHbAJEPTQYfANsAHybb
ACEvAzzbACkPXRP-------_cDzEA---vUG09Nn19
:: gfx/1.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA5LTEzIDEzOjUxOjM5Iixtb2RpZmllZD0iMjAyNC0w
OS0xMyAxMzo1MzoxOCIscmV2aXNpb249OV1dbHo0AG0AAAAFMQAA8xR7WzBdPXtibXA9cHh1AEMg
EBAE8PAsZmxhZ3M9MCxwYW5feAgAz3k9MCx6b29tPTh9LDEA----------------------------
------------------------------------51BtPTh9fQ==
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNC0w
OS0xMyAyMToxNjoyOSIsc3RvcmVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Il1d
:: map/
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNC0w
OS0wMSAwNzozNDozNSIscmV2aXNpb249MzA3NV1dbHo0AMEAAABZEAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD-------_x0zIwMDAzMDAwNDAwMDYMAC81MIAAWxMxCAATNYAALzYw
AQBbFzb8ABMxDAAPAQBVBHwBAAABEzAMAA_AAVkTMXQAEzB4ABcxjAAPAAFVEzaEAAQMAC81MAEA
--------nvEJIiksaGlkZGVuPWZhbHNlLHBhbl94PTQ3CQDSeT0wLHRpbGVfaD0yOQoAEHcKAIB6
b29tPTF9fQ==
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNC0w
OS0xMyAyMToxNjoyOSIsc3RvcmVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Il1d
:: pal/
:: pal/0.pal
b64$LS1bW3BvZCxiZ19jb2xvcj0wLGJsYWNrZXN0X2NvbG9yPTAsY3JlYXRlZD0iMjAyNC0wOC0y
MyAxODo1OTowOSIsaGlkZGVuPXtbMF09dHJ1ZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxz
ZSxmYWxzZSx0cnVlLHRydWUsdHJ1ZSxmYWxzZSx0cnVlLHRydWUsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsdHJ1ZSx0cnVlLGZhbHNlLHRydWUsdHJ1ZSx0cnVlLHRydWUsZmFsc2UsdHJ1
ZSx0cnVlLHRydWUsdHJ1ZSxmYWxzZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLGZhbHNlLHRydWUsdHJ1
ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUs
dHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2V9LGhpZGRlbl90b2dnbGVzPXtbMF09dHJ1ZSx0cnVlLHRy
dWUsdHJ1ZX0saWNvbj11c2VyZGF0YSgidTgiLDE2LDE2LCIwMDAxMDEwMTAxMDEwMTAxMDEwMTAx
MDAwMDAwMDAwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDYwMTAwMDAwMDAwMDAwMTA3MDcwNzA3MDcw
NzA3MDcwNjA2MDEwMDAwMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA2MDYwNjAxMDAwMDAwMDEwNzA3
MDcwNzA3MDcwNzA3MDYwNjA2MDYwMTAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzAxMDAw
MDAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDEwNzA3MDYwNjAxMDEwZDBkMDEwMTA3
MDcwMTAwMDAwMTA3MDcwNjA2MDEwMTBkMGQwMTAxMDcwNzAxMDAwMDAxMDcwNzAxMDEwNzA3MDYw
NjBkMGQwNzA3MDEwMDAwMDEwNzA3MDEwMTA3MDcwNjA2MGQwZDA3MDcwMTAwMDAwMTA3MDcwZDBk
MDEwMTBkMGQwNjA2MDcwNzAxMDAwMDAxMDcwNzBkMGQwMTAxMGQwZDA2MDYwNzA3MDEwMDAwMDEw
NzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwMTAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzAx
MDAwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMCIpLGxvY2tlZD17WzBdPWZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlfSxtb2RpZmllZD0iMjAyNC0wOS0xMyAy
MToxNjoyOCIsb2twYWxfdmVyc2lvbj0iMS4wLjMiLHJldmlzaW9uPTQzMTIsdGVzdF9jdWJlX2Nv
bG9ycz17WzBdPXsxNSwzMSw0fSx7MzEsNCwyMH0sezQsMjAsMjF9LHsxMCw5LDI1fSx7OSwyNSwy
NH0sezgsMjQsMn0sezI2LDExLDI3fSx7MTEsMjcsM30sezI3LDMsMTl9LHsyOCwxNywxOX0sezI4
LDEyLDE2fSx7MTIsMTYsMX0sezYsMjksMTN9LHsyOSwxMywxOH0sezEzLDE4LDF9LHs3LDIzLDE0
fSx7MjMsMTQsMTN9LHsxNCwzMCwxOH0sezcsNiwyMn0sezYsMjIsNX0sezIyLDUsMjF9LHsxLDEs
MX0sezEsMSwxfSx7MSwxLDF9fSx3aGl0ZXN0X2NvbG9yPTddXWx6NADwAQAAFQIAAP0FdXNlcmRh
dGEoImkzMiIsNjQsIjABAPANNGMzNjVhMDA4MjNmMzgwMDk4NDczZjAwOWY1MQgAkTY0NDg3NzAw
ZgEA8DgwMDc0MWY2NTAwYTgyNTkyMDBlMjQ5YmEwMGVmODNjNTAwZjhiYmQ5MDA3NzJjMTYwMGEy
MzIxOTAwZDU0ZjIxMDBmMzgyNVAA8CRjYmM5YzAwNjc0OTEzMDA5YzcxMWEwMGQ2YTIyNTAwZWRj
NDU0MDBmYmUxOTkwMDJkNTMYAPAWMzE2ZTMyMDA1MGEzMmMwMDg3ZDQ1NjAwYmZmMjk1MDAxNjU4
NQgA8A03Nzk3ZDAwMjBiNGIzMDA1Y2Q4ZDIwMGFjZjZm_ACwNzIyODYwMDVlMjYgANA4ZDNiZWQw
MGFlODFmsABAOGM0ZqAAEGUCAEAwMGI3AgBAMDBlMwIAQDAwZjQCAADIAAACAEAwMDFkAgBAMDAy
ZQIAQDAwNDYCAEAwMDliAgBAMDBjMQIA4DAwNGY0YjNlMDA3MzZh4ADwEzllOGY3NDAwYWE5ZDg1
MDBiZWI1YTQwMDU4NTk1ZDAwNjgCAFEwMDZmNrkAETcBAFAwMDg2OK8B8QYwM2YyNzJhMDA1YjM3
MzQwMDY2NDBgAFAwNDk0NCgAIDVjEAGANDAyYzRkIik=
:: pal/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTIzIDE4OjU0OjE5Iixtb2RpZmllZD0iMjAyNC0w
OS0xMyAyMToxNjoyOSJdXQ==
:: sfx/
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM1Iixtb2RpZmllZD0iMjAyNC0w
OS0xMyAyMToxNjoyOCIscmV2aXNpb249NDI1OV1dbHo0ABoBAABSCAAA8CdweHUAAygAAAQABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDBAUGBwAP-5AICQoLDwwPDQ8ODw8QAPAADQ8RDxIPEw8UDxUP
Fg8XEwDxAQ8YDxkPGg8bDxwPHQ8eDx8UAPEAIA8hDyIPIw8kDyUPJg8nFADxACgPKQ8qDysPLA8t
Dy4PLxQA8QAwDzEPMg8zDzQPNQ82DzcUAP8FOA85DzoPOw88Dz0PPg8-AA--8P8BAOv-J1oBEAYP
IBABIAEgAfAAAhACDBABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDDAAAh9EMAAc
H0AwAPIf-wEA3L-4D0AADUD--7DwcAoA--9kH-8BAP_ZUP----8g
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNC0w
OS0xMyAyMToxNjoyOSIsc3RvcmVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Il1d
:: src/
:: src/logic/
:: src/logic/creation.lua
--[[pod_format="raw",created="2024-08-30 06:25:09",modified="2024-09-13 21:16:28",revision=1450]]
--- Board Creation Logic


function logic_new_test_cells(tiling, for_editor)
	local grid
	local size
	if tiling == "square" then
		grid = sgrid_new()
		for x = 2, 9 do
			for y = 0, 7 do
				grid:set(pos(x, y), cell_good)
			end
		end
	elseif tiling == "hex" then
		grid = hgrid_new()
		for i = 0, 4 do
			for y = i, 12 - i, 2 do
				grid:set(pos(6 + i, y), cell_good)
				grid:set(pos(6 - i, y), cell_good)
			end
		end
	end
	return grid
end


------------------------------------------------------------------------


--local function random_gem()
--	if false and rnd() < 0.05 then
--		local gem = gem_rainbow + flr(rnd(6))
--		if gem == gem_robot_E then
--			gem += flr(rnd(4))
--		end
--		return gem
--	end
--	return gem_color_first + flr(rnd(gem_color_last - gem_color_first))
--end
local bag_of_gems = {}
local rejected_gems = {}


local function random_gem()
	while #bag_of_gems == 0 do
		bag_of_gems = rejected_gems
		rejected_gems = {}
		for i = gem_air, gem_night do
			add(rejected_gems, i)
		end
	end
	local idx = math.random(1, #bag_of_gems)
	local gem = bag_of_gems[idx]
	deli(bag_of_gems, idx)
	return gem
end


function logic_fill_gem_at(cells, gems, states, p)
	local cell = cells:get(p) or 0
	if (cell & cell_mask == 0) or (cell & rock_mask != 0) then
		return
	end
	local test = (gems:tiling() == "square") and logic_test_sqr_match_at or logic_test_hex_match_at
	local gem = gems:get(p)
	if not gem then
		local attempts = 0
		local found = false
		while attempts < 16 and not found do
			if gem then
				add(rejected_gems, gem)
			end
			gem = random_gem()
			gems:set(p, gem)
			found = not test(gems, p)
			attempts += 1
		end
		if attempts == 16 then
			gem = gem_gift
			gems:set(p, gem)
		end
		states:set(p, { name = "new" })
	end
end


function logic_fill_gems(cells, gems, states)
	-- TODO: transform into a coroutine
	-- TODO: fill in reverse gravity order
	cells:foreachpos(
		function(p, _)
			logic_fill_gem_at(cells, gems, states, p)
		end
	)
end

:: src/logic/matching.lua
--[[pod_format="raw",created="2024-08-24 08:12:55",modified="2024-09-13 09:08:06",revision=2979]]
--- Matching Logic

-- The matching algorithm has two phases:
--
-- 1. First, a linear sweep through all the gems, and for each gem involved in a match
--    creates a mark registering which direction(s) matched.
-- 2. Then a flood-fill algorithm is used to group matches together.


local function logic_is_matching(gem1, gem2)
	if (not gem1) or (not gem2) then
		return false
	end
	
	-- Only colored gems can match.
	if (gem1 < gem_color_first) or (gem1 > gem_color_last) then
		return false
	end
	if (gem2 < gem_color_first) or (gem2 > gem_color_last) then
		return false
	end

	return (gem1 == gem2) or (gem1 == gem_rainbow)
		or (gem2 == gem_rainbow)
end


--------------------------------------------------------------------------


local function test_3(gems, p0, p1, p2)
	local gem0 = gems:get(p0)
	local gem1 = gems:get(p1)
	local gem2 = gems:get(p2)
	return logic_is_matching(gem0, gem1)
		and logic_is_matching(gem0, gem2)
		and logic_is_matching(gem1, gem2)
end


local function test_4(gems, p0, p1, p2, p3)
	local gem0 = gems:get(p0)
	local gem1 = gems:get(p1)
	local gem2 = gems:get(p2)
	local gem3 = gems:get(p3)
	return logic_is_matching(gem0, gem1)
		and logic_is_matching(gem0, gem2)
		and logic_is_matching(gem0, gem3)
		and logic_is_matching(gem1, gem2)
		and logic_is_matching(gem1, gem3)
		and logic_is_matching(gem2, gem3)
end


function logic_test_sqr_match_at(gems, p)
	local S = p + pos(0, 1)
	local SS = p + pos(0, 2)
	local N = p + pos(0, -1)
	local NN = p + pos(0, -2)
	local E = p + pos(1, 0)
	local EE = p + pos(2, 0)
	local W = p + pos(-1, 0)
	local WW = p + pos(-2, 0)
	local SE = p + pos(1, 1)
	local SW = p + pos(-1, 1)
	local NE = p + pos(1, -1)
	local NW = p + pos(-1, -1)
	return test_3(gems, SS, S, p) or test_3(gems, S, p, N) or test_3(gems, p, N, NN)
		or test_3(gems, EE, E, p) or test_3(gems, E, p, W) or test_3(gems, p, W, WW)
		or test_4(gems, p, S, SE, E) or test_4(gems, p, S, SW, W) 
		or test_4(gems, p, N, NE, E) or test_4(gems, p, N, NW, W)
end


function logic_test_hex_match_at(gems, p)
	local S = p + pos(0, 2)
	local S_S = p + pos(0, 4)
	local N = p + pos(0, -2)
	local N_N = p + pos(0, -4)
	local SE = p + pos(1, 1)
	local SE_SE = p + pos(2, 2)
	local SW = p + pos(-1, 1)
	local SW_SW = p + pos(-2, 2)
	local NE = p + pos(1, -1)
	local NE_NE = p + pos(2, -2)
	local NW = p + pos(-1, -1)
	local NW_NW = p + pos(-2, -2)
	local E = p + pos(2, 0)
	local W = p + pos(-2, 0)
	return test_3(gems, S_S, S, p) or test_3(gems, S, p, N) or test_3(gems, p, N, N_N)
		or test_3(gems, SE_SE, SE, p) or test_3(gems, SE, p, NW) or test_3(gems, p, NW, NW_NW)
		or test_3(gems, NE_NE, NE, p) or test_3(gems, NE, p, SW) or test_3(gems, p, SW, SW_SW)
		or test_4(gems, p, SE, S, SW) or test_4(gems, p, NE, N, NW)
		or test_4(gems, p, NE, E, SE) or test_4(gems, p, NW, W, SW)
end


local function check_3_and_mark(gems, p0, p1, p2, mark, marks)
	if test_3(gems, p0, p1, p2) then
		marks:merge(p0, mark)
		marks:merge(p1, mark)
		marks:merge(p2, mark)
	end
end


local function check_4_and_mark(gems, p0, p1, p2, p3, mark, marks)
	if test_4(gems, p0, p1, p2, p3) then
		marks:merge(p0, mark)
		marks:merge(p1, mark)
		marks:merge(p2, mark)
		marks:merge(p3, mark)
	end
end


local function mark_sgrid_matches_at(gems, p0, marks)
	check_3_and_mark( gems,
		p0,
		p0 + pos(0, 1),
		p0 + pos(0, 2),
		{ name = "matching", vertical = true }, marks )
	check_3_and_mark( gems,
		p0,
		p0 + pos(1, 0),
		p0 + pos(2, 0),
		{ name = "matching", horizontal= true }, marks )
	check_4_and_mark( gems,
		p0,
		p0 + pos(1, 0),
		p0 + pos(0, 1),
		p0 + pos(1, 1),
		{ name = "matching", vertical = true, horizontal = true }, marks )
end


local function mark_hgrid_matches_at(gems, p0, marks)
	check_3_and_mark( gems,
		p0,
		p0 + pos(0, 2),
		p0 + pos(0, 4),
		{ name = "matching", vertical = true }, marks )
	check_3_and_mark( gems,
		p0,
		p0 + pos(1, 1),
		p0 + pos(2, 2),
		{ name = "matching", horizontal_SE = true }, marks )
	check_3_and_mark( gems,
		p0,
		p0 + pos(1, -1),
		p0 + pos(2, -2),
		{ name = "matching", horizontal_NE = true }, marks )
	local p1 = p0 + pos(1, 1)
	local p2 = p0 + pos(1, -1)
	local p3 = p0 + pos(2, 0)
	if test_4(gems, p0, p1, p2, p3) then
		marks:merge(p0, { name = "matching", vertical = true, horizontal_NE = true, horizontal_SE = true})
		marks:merge(p1, { name = "matching", vertical = true, horizontal_SE = true })
		marks:merge(p2, { name = "matching", vertical = true, horizontal_NE = true })
		marks:merge(p3, { name = "matching", vertical = true, horizontal_NE = true, horizontal_SE = true})
	end
end


local function mark_all_matches(gems)
	local marks = gems:new_grid()
	if gems:tiling() == "square" then
		gems:foreachpos(
			function(p, _gem)
				mark_sgrid_matches_at(gems, p, marks)
			end
		)
	elseif gems:tiling() == "hex" then
		gems:foreachpos(
			function(p, _gem)
				mark_hgrid_matches_at(gems, p, marks)
			end
		)
	end
	return marks
end


---------------------------------------------------------------------------


local function group_this_match(cells, gems, marks, p)
	-- A simple flood-fill algorithm to group all
	-- intersecting linear matches together.
	local colour = gem_rainbow
	local positions = {}
	local one_good_cell = false
	local remaining = { p }
	local rainbows = {}
	while #remaining > 0 do
		local current = deli(remaining)
		local gem = gems:get(current)
		local mark = marks:get(current)
		if mark and mark.name == "matching"
			and (not mark.counted)
			and logic_is_matching(colour, gem)
		then
			if gem == gem_rainbow then
				-- Rainbow gems can be part of multiple matches,
				-- so they need to be unflagged at the end.
				add(rainbows, current)
			else
				colour = gem
			end
			add(positions, current)
			marks:merge(current, { counted = true })
			local cell = cells:get(current)
			if cell and cell & cell_mask == cell_good then
				one_good_cell = true
			end
			local neighbours = gems:neighbours(current)
			foreach(
				neighbours,
				function(n)
					local s = marks:get(n.position)
					if not s then
						return
					end
					if s and s.name == "matching"
						and (not s.counted)
						and s[n.direction]
					then
						add(remaining, n.position)
					end
				end
			)
		end
	end
	foreach(
		rainbows,
		function(p)
			marks:merge(p, { counted = false })
		end
	)
	return { colour = colour, positions = positions, one_good_cell = one_good_cell }
end


function logic_find_matches(cells, gems)
	local marks = mark_all_matches(gems)
	local matches = {}
	marks:foreachpos(
		function(p, mark)
			if mark and mark.name == "matching"
				and (not mark.counted)
			then
				local match = group_this_match(cells, gems, marks, p)
				if match.colour == gem_rainbow then
					-- Ignore, as this is probably a stray rainbow that was unflagged
					-- at the end of `count_this_match`.
					-- TODO: an edge case is when there is a legitime match of
					-- only rainbow gems (e.g. 3 rainbows surrounded by black things).
				else
					add(matches, match)
				end
			end
		end
	)
	return matches, marks
end
:: src/logic/mechanics.lua
--[[pod_format="raw",created="2024-08-30 06:41:59",modified="2024-09-13 09:08:06",revision=1632]]
--- Core Mechanics Logic


function logic_mark_gravity(cells, gems, marks, gravity)
	local some_gems_are_falling = false
	gems:foreachpos(
		function(p, gem)
			local below = p + gravity
			local distance = 0
			local cell_below = cells:get(below) or cell_none
			while (cell_below & cell_mask != cell_none)
				and (cell_below & rock_mask == 0)
			do
				if (not gems:get(below)) then
					some_gems_are_falling = true
					distance += 1
				end
				below += gravity
				cell_below = cells:get(below) or cell_none
			end
			if distance > 0 then
				marks:set(p, { name = "falling", target = p + distance * gravity })
			end
		end
	)
	return some_gems_are_falling
end


function logic_enact_gravity(gems, marks)
	local fell_gems = {}
	marks:foreachpos(
		function(p, mark)
			if mark.name == "falling" then
				local new_p = mark.target
				add(fell_gems, { gem = gems:get(p), pos = new_p })
				gems:del(p)
				marks:del(p)
			end
		end
	)
	foreach(fell_gems,
		function(fell_gem)
			gems:set(fell_gem.pos, fell_gem.gem)
			marks:del(fell_gem.pos)
		end
	)
end


------------------------------------------------------------------------


function logic_mark_swap(gems, marks, source, target)
	local gem0 = gems:get(source)
	local gem1 = gems:get(target)
	local test = (gems:tiling() == "square") and logic_test_sqr_match_at or logic_test_hex_match_at
	gems:set(source, gem1)
	gems:set(target, gem0)
	local matched = test(gems, target) or test(gems, source)
	gems:set(source, gem0)
	gems:set(target, gem1)
	if not matched then
		return false
	end
	marks:set(source, {
		name = "swapping",
		selected = true,
		target = target,
	})
	marks:set(target, {
		name = "swapping",
		target = source,
	})
	return true
end


function logic_enact_swap(gems, marks)
	local reinsert = {}
	marks:foreachpos(
		function(p, mark)
			if mark.name == "swapping" then
				add(reinsert, { gem = gems:get(p), position = mark.target })
				gems:del(p)
				marks:del(p)
			end
		end
	)
	foreach(
		reinsert,
		function(r) gems:set(r.position, r.gem) end
	)
end


-------------------------------------------------------------------------


function logic_enact_clear(gems, marks)
	marks:foreachpos(
		function(p, mark)
			if mark.name == "matching" then
				gems:del(p)
				marks:del(p)
			end
		end
	)
end

-------------------------------------------------------------------------


function logic_mark_repair(cells, marks, matches)
	local is_something_repaired = false
	foreach(
		matches,
		function(match)
			if match.one_good_cell then
				foreach(
					match.positions,
					function(position)
						local cell = cells:get(position) or 0
						if cell & cell_mask == cell_bad then
							marks:set(position, { name = "repaired" })
							is_something_repaired = true
						end
					end
				)
			end
		end
	)
	return is_something_repaired
end


function logic_enact_repair(cells, marks)
	local to_be_unmarked = {}
	marks:foreachpos(
		function(position, mark)
			if mark.name == "repaired" then
				local cell = cells:get(position)
				cell = (cell & ~cell_mask) | cell_good
				cells:set(position, cell)
				add(to_be_unmarked, position)
			end
		end
	)
	foreach(to_be_unmarked, function(p) marks:del(p) end)
end


----------------------------------------------------------------------


function logic_mark_breakage(cells, gems, marks, matches)
	local something_broke = false
	foreach(
		matches,
		function(match)
			foreach(
				match.positions,
				function(position)
					local neighbours = cells:neighbours(position)
					foreach(
						neighbours,
						function(n)
							local cell = (cells:get(n.position) or 0) & rock_mask
							if cell >= rock_full and cell <= rock_broken then
								marks:set(n.position, { name = "broken" })
								something_broke = true
							end
							local gem = gems:get(n.position) or 0
							if #match.positions > 3 then
								if gem == gem_cat or gem == gem_bat
									or gem == gem_robot_asleep
									or gem == gem_bomb
								then
									marks:set(n.position, { name = "broken" })
									something_broke = true
								elseif gem == gem_robot then
									gems:set(n.position, gem_robot_asleep2)
								end
							elseif gem == gem_bomb then
								marks:set(n.position, { name = "broken", exploded = true })
								something_broke = true
							end
						end
					)
				end
			)
		end
	)
	return something_broke
end


function logic_enact_breakage(cells, gems, marks)
	local to_be_unmarked = {}
	marks:foreachpos(
		function(position, mark)
			if mark.name == "broken" then
				local cell = cells:get(position) or 0
				if cell & rock_mask == rock_full then
					cells:set(position, (cell & cell_mask) | rock_cracked)
				elseif cell & rock_mask == rock_cracked then
					cells:set(position, (cell & cell_mask) | rock_broken)
				elseif cell & rock_mask == rock_broken then
					cells:set(position, (cell & cell_mask))
				end
				local gem = gems:get(position) or 0
				if gem == gem_cat or gem == gem_bat
					or gem == gem_robot_asleep
					or gem == gem_bomb
				then
					gems:del(position)
				end
				if gem == gem_bomb and mark.exploded then
					local neighbours = cells:blast_radius(position)
					foreach(
						neighbours,
						function(p)
							local cell = cells:get(p)
							if cell then
								cells:set(p, cell_bad | (cell & rock_mask))
							end
						end
					)
				end
				add(to_be_unmarked, position)
			end
		end
	)
	foreach(to_be_unmarked, function(p) marks:del(p) end)
end


-----------------------------------------------------------------------


function logic_mark_move(cells, gems, marks)
	local something_moved = false
	local movers = {}
	gems:foreachpos(
		function(position, gem)
			if gem == gem_cat or gem == gem_bat or gem == gem_robot then
				add(movers, position)
			elseif gem == gem_robot_asleep2 then
				gems:set(position, gem_robot_asleep)
			elseif gem == gem_robot_asleep then
				gems:set(position, gem_robot)
			end
		end
	)
	foreach(
		movers,
		function(position)
			local neighbours = cells:neighbours(position)
			local possibilities = {}
			foreach(
				neighbours,
				function(neighbour)
					local cell = cells:get(neighbour.position) or 0
					local gem = gems:get(neighbour.position) or 0
					if (cell & rock_mask == 0)
						and (cell & cell_mask != 0)
						and (gem < gem_rainbow)
					then
						add(possibilities, neighbour.position)
					end
				end
			)
			if #possibilities > 0 then
				something_moved = true
				local target = possibilities[math.random(1, #possibilities)]
				local moving_gem = gems:get(position)
				gems:del(position)
				local target_gem = gems:get(target)
				gems:set(target, moving_gem)
				local source_gem
				logic_fill_gem_at(cells, gems, marks, position)
				source_gem = gems:get(position)
				marks:set(target, {
					name = "moving",
					source = position,
					target = target,
					moving_gem = moving_gem,
					target_gem = target_gem,
					source_gem = source_gem,
				})
				if moving_gem == gem_bat or moving_gem == gem_robot then
					local cell = cells:get(target)
					cell = cell_bad | (cell & rock_mask)
					cells:set(target, cell)
				end
			end
		end
	)
	return something_moved
end


function logic_enact_move(cells, gems, marks)
	marks:foreachpos(
		function(position, mark)
			if mark.name == "moving" then
				if mark.moving_gem == gem_robot then
				end
			end
		end
	)
	marks:foreachpos(function(p, _) marks:del(p) end)
end
:: src/logic/shuffle.lua
--[[pod_format="raw",created="2024-09-13 09:11:02",modified="2024-09-13 21:16:28",revision=264]]

:: src/logic/spells.lua
--[[pod_format="raw",created="2024-08-30 06:37:36",modified="2024-09-07 08:00:48",revision=511]]
--- Spell Logic


function logic_gain_mana(stats, matches)
	local gained = false
	foreach(
		matches,
		function(match)
			local count = #(match.positions)
			if count > 3 then
				stats.mana += 10 * (count - 3)
				gained = true
			end
			if stats.in_cascade then
				stats.mana += 5
				gained = true
			end
			stats.in_cascade = true
			if match.colour == gem_rainbow then
				foreach(
					{ gem_air, gem_fire, gem_day, gem_earth, gem_water, gem_night },
					function(g) stats.colour[g] += count end
				)
			else
				stats.colours[match.colour] += count
			end
		end
	)
	return gained
end

:: src/logic/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTMwIDA2OjI0OjM5Iixtb2RpZmllZD0iMjAyNC0w
OS0xMyAyMToxNjoyOSJdXQ==
:: src/constants.lua
--[[pod_format="raw",created="2024-08-24 15:17:10",modified="2024-09-13 21:16:28",revision=2903]]
--- Match3 Global Constants


-- Gems and cells ------------------------------------------------------

-- Color gems
gem_air = 0x01
gem_fire = 0x02
gem_day = 0x03
gem_earth = 0x04
gem_water = 0x05
gem_night = 0x06
gem_rainbow = 0x07

gem_color_first = gem_air
gem_color_last = gem_rainbow

-- Black gems
gem_gift = 0x08
gem_bomb = 0x09
gem_cat = 0x0a
gem_bat = 0x0b
gem_robot = 0x0c
gem_robot_asleep = 0x0d
gem_robot_asleep2 = 0x0e

gem_names = {
	[gem_air] = "Air",
	[gem_fire] = "Fire",
	[gem_day] = "Day",
	[gem_earth] = "Earth",
	[gem_water] = "Water",
	[gem_night] = "Night",
	[gem_rainbow] = "Rainbow",
}


-- Cells
cell_mask = 0x03
cell_none = 0x00
cell_good = 0x01
cell_bad = 0x02

-- Rocks
rock_full = 0x10
rock_cracked = 0x20
rock_broken = 0x30
cell_door = 0x40
cell_chest_air = 0x50
cell_chest_fire = 0x60
cell_chest_day = 0x70
cell_chest_earth = 0x80
cell_chest_water = 0x90
cell_chest_night = 0xa0

rock_mask = 0xf0

:: src/gfx.lua
--[[pod_format="raw",created="2024-08-24 12:06:13",modified="2024-09-13 21:16:28",revision=4739]]
--- Graphics


local cell_width = 29
local cell_height = 29


function gfx_draw_cells(cells)
	local function draw_cell(p, cell)
		local x, y = cells:coords_cell(p)
		local sprite
		if cells:tiling() == "square" then
			if cell & cell_mask == cell_good then
				sprite = 32
				sprite += (p.x + p.y) % 2
			elseif cell & cell_mask == cell_bad then
				sprite = 34
				sprite += p.y % 2
			end
		elseif cells:tiling() == "hex" then
			if cell & cell_mask == cell_good then
				sprite = 40
				sprite += (p.y + (p.x * 3)) % 3
			elseif cell & cell_mask == cell_bad then
				sprite = 43
			end
		end
		spr(sprite, x, y)
		x, y = cells:coords_gem(p)
		if cell and cell & cell_mask == cell_bad then
			pal(53, 58)
		end
		if cell & rock_mask == 0 then
		elseif cell & rock_mask == rock_full then
			spr(48, x, y)
		elseif cell & rock_mask == rock_cracked then
			spr(49, x, y)
		elseif cell & rock_mask == rock_broken then
			spr(50, x, y)
		elseif cell & rock_mask == cell_door then
			spr(51, x, y)
		elseif cell & rock_mask == cell_chest_air then
			spr(52, x, y)
		elseif cell & rock_mask == cell_chest_fire then
			spr(53, x, y)
		elseif cell & rock_mask == cell_chest_day then
			spr(54, x, y)
		elseif cell & rock_mask == cell_chest_earth then
			spr(55, x, y)
		elseif cell & rock_mask == cell_chest_water then
			spr(56, x, y)
		elseif cell & rock_mask == cell_chest_night then
			spr(57, x, y)
		end	
		pal(53, 53)
	end
	cells:foreachpos(draw_cell)
	-- TODO: move border construction out of the hot loop
	local function draw_borders(p, cell)
		local x, y = cells:coords_cell(p)
		if cells:tiling() == "square" then
			local cell_S = cells:get(p + pos(0, 1))
			local cell_W = cells:get(p + pos(-1, 0))
			local cell_E = cells:get(p + pos(1, 0))
			local cell_N = cells:get(p + pos(0, -1))
			if cell & cell_good != 0 then
				if not cell_S or cell_S & cell_good == 0 then
					line(x, y + 28, x + 28, y + 28, 53)
				end
				if not cell_E or cell_E & cell_good == 0 then
					line(x + 28, y, x + 28, y + 28, 53)
				end
				if not cell_N or cell_N & cell_good == 0 then
					line(x, y, x + 28, y, 57)
				end
				if not cell_W or cell_W & cell_good == 0 then
					line(x, y, x, y + 28, 57)
				end
			elseif cell & cell_bad != 0 then
				if cell_N and cell_N & cell_good != 0 then
					line(x, y, x + 28, y, 58)
				end
				if cell_W and cell_W & cell_good != 0 then
					line(x, y, x, y + 28, 58)
				end
			end
		end
	end
	cells:foreachpos(draw_borders)
end


-----------------------------------------------------------------------


local sprites_color_gem = {
	[gem_air] = 1,
	[gem_fire] = 2,
	[gem_day] = 3,
	[gem_earth] = 4,
	[gem_water] = 5,
	[gem_night] = 6,
	[gem_rainbow] = 7,
}


local sprites_other_gem = {
	[gem_gift] = 8,
	[gem_bomb] = 9,
	[gem_cat] = 10,
	[gem_bat] = 11,
	[gem_robot] = 12,
	[gem_robot_asleep] = 13,
	[gem_robot_asleep2] = 13,
}

--color_gem_skin = math.random(0, 12)
color_gem_skin = 0
local function gem_sprite(gem)
	local base = 128 + color_gem_skin * 8
	if gem >= gem_air and gem <= gem_rainbow then
		return sprites_color_gem[gem] - 1 + base
	else
		return sprites_other_gem[gem]
	end
end


local function scaled_gem(sprite, x, y, size)
	local w, h = flr(29 * size + 0.5) // 2 * 2 + 1, flr(29 * size + 0.5) // 2 * 2 + 1
	local x, y = x + ((29 - w) / 2), y + ((29 - h) / 2)
	sspr(sprite, 0, 0, 29, 29, x, y, w, h)
end


local function draw_exploded_gem(gem, x, y, clock, new_clock)
	local size = 32 * new_clock
	local colour = 10 + (gem - 1) * 5
	oval(x - size, y - size, x + 29 + size, y + 29 + size, colour + 1)
	if clock < 0.25 then
		ovalfill(x + 2, y + 2, x + 25, y + 25, 7)
	elseif clock < 0.50 then
		ovalfill(x + 2, y + 2, x + 25, y + 25, colour + 2)
	elseif clock < 0.75 then
		ovalfill(x + 1, y + 1, x + 27, y + 27, colour + 1)
	elseif clock < 1.0 then
		ovalfill(x, y, x + 29, y + 29, colour)
	end
end


function gfx_draw_gems(cells, gems, states, clock)
	local function draw_gem(p, gem)
		local x, y = gems:coords_gem(p)
		local sprite = gem_sprite(gem)
		local cell = cells:get(p)
		if cell and cell & cell_mask == cell_bad then
			pal(53, 58)
		end
		local state = states:get(p)
		if not state or state.name == "broken" then
			spr(sprite, x, y)
		elseif state.name == "new" then
			scaled_gem(sprite, x, y, clock)
		elseif state.name == "matching" then
		elseif state.name == "falling" or state.name == "swapping"
		then
			local dest_x, dest_y = gems:coords_gem(state.target)
			local ix, iy = x + clock * (dest_x - x), y + clock * (dest_y - y)
			spr(sprite, ix, iy)
		elseif state.name == "moving" then
			x, y = gems:coords_gem(state.source, gem)
			local dest_x, dest_y = gems:coords_gem(state.target)
			scaled_gem(gem_sprite(state.target_gem), dest_x, dest_y, 1.0)
		end
		pal(53, 53)	
	end
	gems:foreachpos(draw_gem)
	local new_clock = clock * clock * clock * clock
	gems:foreachpos(
		function(p, gem)
			local x, y = gems:coords_gem(p)
			local sprite = gem_sprite(gem)
			local cell = cells:get(p)
			if cell and cell & cell_mask == cell_bad then
				pal(53, 58)
			end
			local state = states:get(p)
			if state and state.name == "matching" then
				draw_exploded_gem(gem, x, y, clock, new_clock)
			elseif state and state.name == "moving" then
				x, y = gems:coords_gem(state.source, gem)
				local dest_x, dest_y = gems:coords_gem(state.target)
				local ix, iy = x + clock * (dest_x - x), y + clock * (dest_y - y)
				spr(gem_sprite(state.moving_gem), ix, iy)
			end
		end
	)
end


-----------------------------------------------------------------------


function gfx_draw_turns(ox, oy, turn, anim_turn)
	spr(64, ox, oy)
	local hundreds = (turn // 100) % 10
	local tens = (turn // 10) % 10
	local ones = turn % 10
	local anim = anim_turn // 2
	pal(7, 1)
	clip(ox + 7, oy + 3, ox + 7 + 3 * 8, oy + 3 + 8)
	-- hundreds
	if anim == 0 or (turn % 100) > 0 then
		spr(65 + hundreds, ox + 7, oy + 6)
	else
		spr(65 + hundreds, ox + 7, oy + 6 + anim)
		spr(65 + ((hundreds - 1) % 10), ox + 7, oy + 6 + anim - 10)
	end
	-- tens
	if anim == 0 or ones > 0 then
		spr(65 + tens, ox + 7 + 8, oy + 6)
	else
		spr(65 + tens, ox + 7 + 8, oy + 6 + anim)
		spr(65 + ((tens - 1) % 10), ox + 7 + 8, oy + 6 + anim - 10)
	end
	-- ones
	spr(65 + ones, ox + 7 + 2 * 8, oy + 6 + anim)
	spr(65 + ((ones - 1) % 10), ox + 7 + 2 * 8, oy + 6 + anim - 10)
	clip()
	pal(7, 7)
end


function gfx_draw_mana(ox, oy, mana, zoomed)
	local base_char
	local char_width
	if zoomed then
		base_char = 85
		char_width = 11
		oy -= 3
	else
		base_char = 75
		char_width = 8
	end
	local thousands = (mana // 1000) % 10
	local hundreds = (mana // 100) % 10
	local tens = (mana // 10) % 10
	local ones = mana % 10
	local digits = 4
	if mana < 10 then
		digits = 1
	elseif mana < 100 then
		digits = 2
	elseif mana < 1000 then
		digits = 3
	else
		digits = 4
	end
	ox -= (digits * char_width) // 2
	if mana >= 1000 then
		spr(base_char + thousands, ox, oy)
		ox += char_width
	end
	if mana >= 100 then
		spr(base_char + hundreds, ox, oy)
		ox += char_width
	end
	if mana >= 10 then
		spr(base_char + tens, ox, oy)
		ox += char_width
	end
	spr(base_char + ones, ox, oy)
end


function gfx_draw_mana_bar(ox, oy, mana)
	spr(95, ox, oy)
	if mana == 0 then
		return
	end
	local size = min(91, flr(0.5 + 91*(mana / 250)))
	rectfill(ox+1, oy+2, ox+1+size, oy+5, 40)
	line(ox+1+size, oy+2, ox+1+size, oy+5, 39)
	line(ox+1, oy+2, ox+1, oy+5, 41)
	if size > 1 then
		line(ox+2, oy+1, ox+1+size-1, oy+1, 41)
		line(ox+2, oy+6, ox+1+size-1, oy+6, 39)
	end
end
:: src/hgrid.lua
--[[pod_format="raw",created="2024-08-25 08:16:09",modified="2024-09-13 09:08:06",revision=2694]]
--- Hex Grids

--- Hex grids use the "double height" coordinate system:
---
---     (0,0)         (2,0)         (4,0)
---            (1,1)         (3,1)
---     (0,2)         (2,2)         (4,2)
---            (1,3)         (3,3)
---     (0,4)         (2,4)         (4,4)
---
--- The origin of the grid, `pos(0, 0)`, is at the top left.


-- Local Constants --------------------------------------------------------


local max_width <const> = 13
local max_height <const> = 8


-- Constructors -----------------------------------------------------------


local metatable = {}


function hgrid_new()
	local grid = {}
	metatable.default_origin(grid)
	setmetatable(grid, { __index = metatable })
	for i = 0, max_width * max_height do
		grid[i] = false
	end
	return grid
end


function metatable:new_grid()
	return hgrid_new()
end


function metatable:clone()
	local grid = self:new_grid()
	grid.origin = self.origin
	self:foreachpos(function(p, item) grid:set(p, item) end)
	return grid
end


-- Indexing ------------------------------------------------------------


function metatable:tiling()
	return "hex"
end


function metatable:get(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	return self[p.x + ((p.y // 2) * max_width)]
end


function metatable:set(p, value)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	self[p.x + ((p.y // 2) * max_width)] = value
end


function metatable:merge(p, state)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	local index = p.x + ((p.y // 2) * max_width)
	if not self[index] then
		self[index] = {}
	end
	for k, v in pairs(state) do
		self[index][k] = v
	end
end


function metatable:del(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	self[p.x + ((p.y // 2) * max_width)] = false
end


-- Screen Coordinates ---------------------------------------------------------


function metatable:default_origin()
	self.origin = { x = 116, y = 7 }
end


function metatable:compute_origin()
	local min_p = pos(max_width, max_height)
	local max_p = pos(0, 0)
	self:foreachpos(
		function(position, cell)
			if not cell or cell == 0 then
				return
			end
			if position.x < min_p.x then min_p.x = position.x end
			if position.y < min_p.y then min_p.y = position.y end
			if position.x > max_p.x then max_p.x = position.x end
			if position.y > max_p.y then max_p.y = position.y end
		end
	)
	local width = 1 + max_p.x - min_p.x
	local height = 1 + max_p.y - min_p.y
	self.origin = {
		x = 110 + ((480 - 110) // 2) - ((width * 27) // 2) - (min_p.x * 27) - 4,
		y = (270 // 2) - ((height * 16) // 2) - (min_p.y * 16) - 8,
	}
end


function metatable:coords_origin()
	return self.origin.x, self.origin.y
end


function metatable:coords_cell(p)
	local ox, oy = self:coords_origin()
	return ox + p.x * 27, oy + p.y * 16
end


function metatable:coords_gem(p)
	local ox, oy = self:coords_origin()
	return ox + (p.x * 27) + 3, oy + (p.y * 16) + 1
end


function metatable:pos(x, y)
	local ox, oy = self:coords_origin()
	x -= ox
	y -= oy + 1
	local px, py = x // 27, y // 16
	local dx, dy = x - (px * 27), y - (py * 16)
	if dx < 8 then
		if (px + py) % 2 == 0 and dy < 14 + (-2 * dx) then
			px -= 1
			py -= 1
		elseif (px + py) % 2 != 0 and dy > -1 + (2 * dx) then
			px -= 1
		end
	end
	py = (2 * ((py - (px % 2)) // 2)) + (px % 2)
	return pos(px, py)
end


function metatable:distance(p0, p1)
	-- TODO: is this correct?
	return (abs(p0.x - p1.x) + abs(p0.y - p1.y)) // 2
end


-- Iterating ----------------------------------------------------------


function metatable:foreachpos(func)
	for x = 0, max_width do
		for y = x % 2, max_height * 2 - 1, 2 do
			local p = pos(x, y)
			local item = self:get(p)
			if item then
				func(p, item)
			end
		end
	end
end	


function metatable:neighbours(p)
	return {
		{ position = p + pos(1, 1), direction = "horizontal_SE" },
		{ position = p + pos(0, 2), direction = "vertical" },
		{ position = p + pos(-1, 1), direction = "horizontal_NE" },
		{ position = p + pos(-1, -1), direction = "horizontal_SE" },
		{ position = p + pos(0, -2), direction = "vertical" },
		{ position = p + pos(1, -1), direction = "horizontal_NE" },
	}
end


function metatable:blast_radius(p)
	return {
		p + pos(0, 0),
		p + pos(0, -2),
		p + pos(1, -1),
		p + pos(1, 1),
		p + pos(0, 2),
		p + pos(-1, 1),
		p + pos(-1, -1),
	}
end

:: src/in_editor.lua
--[[pod_format="raw",created="2024-08-30 08:13:35",modified="2024-09-13 09:08:06",revision=929]]
in_editor = {}

local tiling = "square"

local cells = false
local gems = false
local marks = false

local active_tool = 0
local ox, oy = 8, 8
local sx, sy = 32, 32

local tools = {
	[0] = cell_none,
	cell_good,
	cell_bad,
	rock_full,
	rock_cracked,
	rock_broken,
	cell_chest_air,
	cell_chest_fire,
	cell_chest_day,
	cell_chest_earth,
	cell_chest_water,
	cell_chest_night,
	cell_door,
	false,
	false,
	gem_gift,
	gem_bomb,
	false,
	gem_cat,
	gem_bat,
	gem_robot,
	false,
	false,
}



function in_editor:enter()
	if not cells then
		cells = logic_new_test_cells(tiling, true)
		gems = cells:new_grid()
	end
	cells:default_origin()
	gems:default_origin()
	marks = cells:new_grid()
end


function in_editor:exit()
end


function in_editor:update()
	if keyp("s") then
		tiling = "square"
		cells = false
		in_editor:enter()
	end
	if keyp("h") then
		tiling = "hex"
		cells = false
		in_editor:enter()
	end
	local mx, my, mb, _, _ = mouse()
	if mb == 0x1 and mx < 110 then
		mx -= ox
		my -= oy
		local x, y = clamp(mx // sx, 0, 2), clamp(my // sy, 0, 7)
		active_tool = clamp(x + 3 * y, 0, 22)
	elseif mb == 0x1 then
		local mp = cells:pos(mx, my)
		local tool = tools[active_tool]
		if tool == cell_none then
			local cell = cells:get(mp) or cell_none
			cell = (cell & ~cell_mask) | tool
			cells:set(mp, cell)
			gems:del(mp)
		elseif tool == cell_good or tool == cell_bad then
			local cell = cells:get(mp) or cell_none
			cell = (cell & ~cell_mask) | tool
			cells:set(mp, cell)
		elseif active_tool <= 12 then 
			local cell = cells:get(mp) or cell_none
			cell = (cell & cell_mask) | tool
			cells:set(mp, cell)
			gems:del(mp)
		elseif cells:get(mp) and cells:get(mp) & cell_mask != 0 then
			gems:set(mp, tool)
			local cell = cells:get(mp) or cell_none
			cell = (cell & cell_mask)
			cells:set(mp, cell)
		end
	end
	if mb == 0x2 then
		local mp = cells:pos(mx, my)
		local cell = cells:get(mp) or cell_none
		cell = (cell & cell_mask)
		cells:set(mp, cell)
		gems:del(mp)
	end
	if keyp("g") then
		in_game:load_from_editor(tiling, cells, gems)
		return in_game
	end
	return false
end


function in_editor:draw()
	cls(63)
	if not cells then
		return
	end
	local mx, _, _, _, _ = mouse()
	if mx <= 110 then
		window { cursor = "pointer" }
	else
		window { cursor = "crosshair" }
	end
	gfx_draw_cells(cells)
	gfx_draw_gems(cells, gems, marks, 0.0)
	-- Draw the panel
	rectfill(0, 0, 110, 269, 55)
	rectfill(ox, oy, ox + 28, oy + 28, 63)
	spr(33, ox + 1 * sx, oy + 0 * sy)
	spr(34, ox + 2 * sx, oy + 0 * sy)
	spr(48, ox + 0 * sx, oy + 1 * sy)
	spr(49, ox + 1 * sx, oy + 1 * sy)
	spr(50, ox + 2 * sx, oy + 1 * sy)
	spr(52, ox + 0 * sx, oy + 2 * sy)
	spr(53, ox + 1 * sx, oy + 2 * sy)
	spr(54, ox + 2 * sx, oy + 2 * sy)
	spr(55, ox + 0 * sx, oy + 3 * sy)
	spr(56, ox + 1 * sx, oy + 3 * sy)
	spr(57, ox + 2 * sx, oy + 3 * sy)
	spr(51, ox + 0 * sx, oy + 4 * sy)

	spr(8, ox + 0 * sx, oy + 5 * sy)
	spr(9, ox + 1 * sx, oy + 5 * sy)
--	spr(11, ox + 2 * sx, oy + 5 * sy)
	spr(10, ox + 0 * sx, oy + 6 * sy)
	spr(11, ox + 1 * sx, oy + 6 * sy)
	spr(12, ox + 2 * sx, oy + 6 * sy)
--	spr(14, ox + 0 * sx, oy + 7 * sy)
--	spr(15, ox + 1 * sx, oy + 7 * sy)

	local x, y = active_tool % 3, active_tool // 3
	rect(ox + x * sx - 1, oy + y * sy - 1, ox + x * sx + 29, oy + y * sy + 29, 7)
end
:: src/in_game.lua
--[[pod_format="raw",created="2024-08-27 17:11:11",modified="2024-09-13 21:16:28",revision=3931]]
in_game = {}


-- The Board
local tiling = "square"
local gravity = pos(0, 1)

local cells = false
local gems = false
local marks = false

local matches = {}

local prev_cells = false
local prev_gems = false
local prev_stats = false

-- State Machine
local editor_requested = false
local substate = false
local clock = 0.0
local interaction = false

local starting_stats = {
	turn = 0,
	mana = 0,
	colours = {
		[gem_air] = 0,
		[gem_fire] = 0,
		[gem_day] = 0,
		[gem_earth] = 0,
		[gem_water] = 0,
		[gem_night] = 0,
	},
	in_cascade = false,
}
local stats = deep_copy(starting_stats)
local anim_turn = 0
local displayed_mana = 0
local star_seed = 37


-----------------------------------------------------------------------


-- Functions for substate need to be global, because of Lua
-- forward-declaration rule for locals.


function creating_the_board()
--	cells = logic_new_test_cells(tiling)
--	gems = cells:new_grid()
	cells:compute_origin()
	gems.origin = cells.origin
	marks = cells:new_grid()
	matches = {}
	stats = deep_copy(starting_stats)
	anim_turn = 0
	displayed_mana = 0
	star_seed = math.random(37, 6584587)
	return creating_missing_gems
end


function creating_missing_gems()
	if clock == 0.0 then
		logic_fill_gems(cells, gems, marks)
	end
	clock += 1.0 / 8.0
	if clock < 1.0 then
		return creating_missing_gems
	end
	-- Clean-up
	marks:foreachpos(
		function(p, mark)
			if mark.name == "new" then
				marks:del(p)
			end
		end
	)
	return moving_things
end


function moving_things()
	if clock == 0.0 and stats.turn > 0 then
		local something_moved = logic_mark_move(cells, gems, marks)
		if not something_moved then
			return starting_new_turn
		end
	end
	clock += 1.0 / 16.0
	if clock < 1.0 then
		return moving_things
	end
	logic_enact_move(cells, gems, marks)
	return starting_new_turn
end


function starting_new_turn()
	stats.turn += 1
	anim_turn = 20
	stats.in_cascade = false
	return waiting_for_input
end


function waiting_for_input()
	local mx, my, mb, _, _ = mouse()
	if mb == 0x1 then
		local mp = cells:pos(mx, my)
		if gems:get(mp) then
			interaction = { name = "swap", position = mp, start = t() }
			return waiting_for_swap
		end
	end
	if keyp("del") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:set(p, gem_gift)
		marks = cells:new_grid()
		matches = {}
	end
	if keyp("w") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:set(p, gem_rainbow)
		marks:set(p, { name = "new" })
		matches = {}
		return checking_matches
	end
	if keyp("r") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		cells:set(p, (cells:get(p) or 0) | rock_full)
		gems:del(p)
		matches = {}
		return checking_matches
	end
	if keyp("a") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:set(p, gem_air)
		marks:set(p, { name = "new" })
		matches = {}
		return checking_matches
	end
	if keyp("m") then
		return checking_matches
	end
	if keyp("e") then
		editor_requested = true
		return creating_the_board
	end
	if keyp("z") then
		cells = prev_cells:clone()
		gems = prev_gems:clone()
		marks = cells:new_grid()
		stats = deep_copy(prev_stats)
	end
	if keyp("0") then color_gem_skin = 0 end
	if keyp("1") then color_gem_skin = 3 end
	if keyp("2") then color_gem_skin = 4 end
	if keyp("3") then color_gem_skin = 7 end
	if keyp("6") then color_gem_skin = 13 end
	if keyp("7") then
		color_gem_skin = (color_gem_skin - 1) % 13
	end
	if keyp("8") then
		local prev = color_gem_skin
		while prev == color_gem_skin do
			color_gem_skin = math.random(0, 12)
		end
	end
	if keyp("9") then
		color_gem_skin = (color_gem_skin + 1) % 13
	end
	return waiting_for_input
end


function waiting_for_swap()
	local mx, my, mb, _, _ = mouse()
	if mb != 0x1 then
		interaction = false
		return waiting_for_input
	end
	local mp = cells:pos(mx, my)
	if cells:distance(mp, interaction.position) != 1
		or (not gems:get(mp))
	then
		return waiting_for_swap
	end
	local success = logic_mark_swap(gems, marks, interaction.position, mp)
	interaction = false
	if not success then
		return waiting_for_input
	end
	prev_cells = cells:clone()
	prev_gems = gems:clone()
	prev_stats = deep_copy(stats)
	return swapping_two_gems
end


function swapping_two_gems()
	clock += 1.0 / 16.0
	if clock < 1.0 then
		return swapping_two_gems
	end
	logic_enact_swap(gems, marks)
	return checking_matches
end


function checking_matches()
	matches, marks = logic_find_matches(cells, gems)
	if #matches > 0 then
		local _ = logic_gain_mana(stats, matches)
		return clearing_gems
	end
	return creating_missing_gems
end


function clearing_gems()
	clock += 1.0 / 16.0
	if clock < 1.0 then
		return clearing_gems
	end
	logic_enact_clear(gems, marks)
	return repairing_cells
end


local repairing_done = false
function repairing_cells()
	if clock == 0.0 then
		local is_something_repaired = logic_mark_repair(cells, marks, matches)
		if not is_something_repaired then
			return breaking_things
		end
	end
	clock += 1.0 / 16.0
	if clock < 0.5 then
		repairing_done = false
		return repairing_cells
	elseif not repairing_done then
		logic_enact_repair(cells, marks)
		repairing_done = true
		return repairing_cells
	elseif clock < 1.0 then
		return repairing_cells
	end
	return breaking_things
end


local breaking_done = false
function breaking_things()
	if clock == 0.0 then
		local something_broke = logic_mark_breakage(cells, gems, marks, matches)
		if not something_broke then
			return applying_gravity
		end
		breaking_done = false
	end
	clock += 1.0 / 32.0
	if clock < 0.5 then
		return breaking_things
	elseif not breaking_done then
		logic_enact_breakage(cells, gems, marks)
		breaking_done = true
		return breaking_things
	elseif clock < 1.0 then
		return breaking_things
	end
	return applying_gravity
end


function applying_gravity()
	if clock == 0.0 then
		local some_gems_are_falling = logic_mark_gravity(cells, gems, marks, gravity)
		if not some_gems_are_falling then
			return creating_missing_gems
		end
	end
	clock += 1.0 / 16.0
	if clock < 1.0 then
		return applying_gravity
	end
	logic_enact_gravity(gems, marks)
	return checking_matches
end


-----------------------------------------------------------------------


function in_game:load_from_editor(ed_tiling, ed_cells, ed_gems)
	tiling = ed_tiling
	if tiling == "square" then
		gravity = pos(0, 1)
	else
		gravity = pos(0, 2)
	end
	cells = ed_cells:clone()
	gems = ed_gems:clone()
	marks = cells:new_grid()
	matches = {}
	stats = deep_copy(starting_stats)
	substate = creating_the_board
end


-----------------------------------------------------------------------


function in_game:enter()
	editor_requested = false
	if not substate then
		substate = creating_the_board
	end
end


function in_game:exit()
end


function in_game:update()
	local next = substate()
	if next != substate then
		clock = 0.0
		substate = next
	end
	if anim_turn > 0 then
		anim_turn -= 1
	end
	if displayed_mana < stats.mana then
		displayed_mana += 0.50
	elseif displayed_mana >= stats.mana then
		displayed_mana = stats.mana
	end
	if editor_requested then
		return in_editor
	end
	return false
end


function in_game:draw()
	if not cells then
		return
	end
	-- Starry background
	local hash = star_seed
	for x = 0, 9 do
		for y = 0, 6 do
			hash = hash~(hash << 13); hash = hash~(hash >> 17); hash = hash~(hash << 5)
			local flipped = (x+y)%2 == 0
			spr(120 + (hash%8), 110 + x * 40, 0 + y * 40, flipped, flipped)
		end
	end
	-- Draw the board
	gfx_draw_cells(cells)
	gfx_draw_gems(cells, gems, marks, clock)
	-- Draw the panel
	rectfill(0, 0, 110, 269, 60)
	line(0, 0, 110, 0, 62)
	line(0, 50, 110, 50, 62)
	line(0, 0, 0, 269, 62)
	line(110, 0, 110, 269, 58)
	line(0, 49, 110, 49, 58)
	line(0, 269, 110, 269, 58)
	-- Top bar
	spr(102, 6, 10)
	spr(98, 14, 5)
	gfx_draw_turns(37, 2, stats.turn, anim_turn)
	spr(100, 79, 5)
	spr(102, 101, 10)
	-- Mana
	spr(104, 16, 56)
	gfx_draw_mana(56, 56, flr(displayed_mana), displayed_mana < stats.mana)
	spr(105, 71, 56)
	gfx_draw_mana_bar(8, 71, flr(displayed_mana))
	for i = 0, 5 do
		spr(96, 4, 84 + i * 30)
	end
	cursor(11, 95, 58)
	print("Change Gravity")
	cursor(10, 94, 22)
	print("Change Gravity")
	--[[
	print("")
	print("Air: " .. tostr(stats.colours[gem_air]))
	print("Fire: " .. tostr(stats.colours[gem_fire]))
	print("Day: " .. tostr(stats.colours[gem_day]))
	print("Earth: " .. tostr(stats.colours[gem_earth]))
	print("Water: " .. tostr(stats.colours[gem_water]))
	print("Night: " .. tostr(stats.colours[gem_night]))
	]]--
	-- Update the cursor
	local mx, my = mouse()
	local cursor_pos = cells:pos(mx, my)
	local cell = cells:get(cursor_pos)
	if cell and cell != 0 then
		window { cursor = "grab" }
	else
		window { cursor = "" }
	end
	if false then
		rectfill(mx + 4 - 10, my + 10, mx + 36, my + 20, 7)
		print(tostr(cursor_pos.x)..","..tostr(cursor_pos.y), mx + 6 - 10, my + 12, 0)
	end
end
:: src/sgrid.lua
--[[pod_format="raw",created="2024-08-24 07:17:45",modified="2024-09-13 09:08:06",revision=3313]]
--- Square Grids

--- The origin of the grid, `pos(0, 0)`, is at the top left.


-- Local Constants --------------------------------------------------------


local max_width <const> = 12
local max_height <const> = 9


-- Constructors -----------------------------------------------------------


local metatable = {}


function metatable:new_grid()
	return sgrid_new()
end


function sgrid_new()
	local grid = {}
	metatable.default_origin(grid)
	setmetatable(grid, { __index = metatable })
	for i = 0, max_width * max_height do
		grid[i] = false
	end
	return grid
end


function metatable:clone()
	local grid = self:new_grid()
	grid.origin = self.origin
	self:foreachpos(function(p, item) grid:set(p, item) end)
	return grid
end


-- Indexing --------------------------------------------------------------------


function metatable:tiling()
	return "square"
end


function metatable:get(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	return self[p.x + (p.y * max_width)]
end


function metatable:set(p, value)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	self[p.x + (p.y * max_width)] = value
end


function metatable:merge(p, state)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	local index = p.x + (p.y * max_width)
	if not self[index] then
		self[index] = {}
	end
	for k, v in pairs(state) do
		self[index][k] = v
	end
end


function metatable:del(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	self[p.x + (p.y * max_width)] = false
end


function metatable:distance(p0, p1)
	return abs(p0.x - p1.x) + abs(p0.y - p1.y)
end


-- Screen Coordinates ---------------------------------------------------------


function metatable:default_origin()
	self.origin = { x = 121, y = 4 }
end


function metatable:compute_origin()
	local min_p = pos(max_width, max_height)
	local max_p = pos(0, 0)
	self:foreachpos(
		function(position, cell)
			if not cell or cell == 0 then
				return
			end
			if position.x < min_p.x then min_p.x = position.x end
			if position.y < min_p.y then min_p.y = position.y end
			if position.x > max_p.x then max_p.x = position.x end
			if position.y > max_p.y then max_p.y = position.y end
		end
	)
	local width = 1 + max_p.x - min_p.x
	local height = 1 + max_p.y - min_p.y
	self.origin = {
		x = 110 + ((480 - 110) // 2) - ((width * 29) // 2) - (min_p.x * 29),
		y = (270 // 2) - ((height * 29) // 2) - (min_p.y * 29),
	}
end


function metatable:coords_origin()
	return self.origin.x, self.origin.y
end


function metatable:coords_cell(p)
	local ox, oy = self:coords_origin()
	return ox + p.x * 29, oy + p.y * 29
end


function metatable:coords_gem(p)
	local ox, oy = self:coords_origin()
	return ox + p.x * 29, oy + p.y * 29
end


function metatable:pos(x, y)
	local ox, oy = self:coords_origin()
	return pos((x - ox) // 29, (y - oy) // 29)
end


-- Iterating -------------------------------------------------------


function metatable:foreachpos(func)
	local p = pos(0, 0)
	for x = 0, max_width do
		for y = 0, max_height do
			local p = pos(x, y)
			local item = self:get(p)
			if item then
				func(p, item)
			end
		end
	end
end	


function metatable:neighbours(p)
	return {
		{ position = p + pos(1, 0), direction = "horizontal" },
		{ position = p + pos(0, 1), direction = "vertical" },
		{ position = p + pos(-1, 0), direction = "horizontal" },
		{ position = p + pos(0, -1), direction = "vertical" },
	}
end


function metatable:blast_radius(p)
	return {
		p + pos(0, 0),
		p + pos(1, 0),
		p + pos(1, 1),
		p + pos(0, 1),
		p + pos(-1, 1),
		p + pos(-1, 0),
		p + pos(-1, -1),
		p + pos(0, -1),
		p + pos(1, -1),
	}
end

:: src/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTI0IDA3OjE3OjA5Iixtb2RpZmllZD0iMjAyNC0w
OS0xMyAyMToxNjoyOSJdXQ==
:: debug.lua
--[[pod_format="raw",created="2024-08-24 12:45:09",modified="2024-09-01 05:15:15",revision=75]]
-- Detect uninitialized globals and typos
-- from @snowkittykira from the BBS


-- if you're using include(), include this after including everything else,
-- since most included modules will need to assign global variables on load

-- these globals are needed by picotron
_init = _init or false
_draw = _draw or false
_update = _update or false
-- these are used by the picotron terminal
cproj_draw = cproj_draw or false
cproj_update = cproj_update or false
_ = _ or false
_is_terminal_command = _is_terminal_command or false
k = k or false
res = res or false
-- gui needs these
drag_t = drag_t or false

local function unknown_variable (t, k)
  error (debug.traceback ('unknown variable ' .. tostring (k), 2))
end

setmetatable (_G, {
  __index = unknown_variable,
  __newindex = unknown_variable,
})
:: drakma.lua
b64$LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNC0wNC0wNyAwNzo0Mjo0NSIsbW9k
aWZpZWQ9IjIwMjQtMDktMTMgMDk6MzQ6MjQiLHJldmlzaW9uPTE1MDddXQpfbW9kdWxlcyA9IHt9
CgotLSBBICdyZXF1aXJlJyBmdW5jdGlvbiBzaW1pbGFyIHRvIHN0YW5kYXJkIEx1YS4KLS0gSWRl
YSBmcm9tIGVsZ29waGVyIG9uIHRoZSBCQlMKZnVuY3Rpb24gcmVxdWlyZShuYW1lKQoJbG9jYWwg
Y2FjaGVkID0gX21vZHVsZXNbbmFtZV0KCWlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQKCglsb2Nh
bCBmaWxlbmFtZSA9IGZ1bGxwYXRoKG5hbWUgLi4gJy5sdWEnKQoJbG9jYWwgc3JjID0gZmV0Y2go
ZmlsZW5hbWUpIAoKCWlmICh0eXBlKHNyYykgIT0gInN0cmluZyIpIHBhbmljKCJjb3VsZCBub3Qg
aW5jbHVkZSAiIC4uIGZpbGVuYW1lKQoKCS0tIGh0dHBzOi8vd3d3Lmx1YS5vcmcvbWFudWFsLzUu
NC9tYW51YWwuaHRtbCNwZGYtbG9hZAoJLS0gY2h1bmsgbmFtZSAoZm9yIGVycm9yIHJlcG9ydGlu
ZykKCS0tIG1vZGUgKCJ0IiBmb3IgdGV4dCBvbmx5IC0tIG5vIGJpbmFyeSBjaHVuayBsb2FkaW5n
KQoJLS0gX0VOViB1cHZhbHVlCgktLSBAIGlzIGEgc3BlY2lhbCBjaGFyYWN0ZXIgdGhhdCB0ZWxs
cyBkZWJ1Z2dlciB0aGUgc3RyaW5nIGlzIGEgZmlsZW5hbWUKCWxvY2FsIGZ1bmMsIGVyciA9IGxv
YWQoc3JjLCAiQCIgLi4gZmlsZW5hbWUsICJ0IiwgX0VOVikKCWlmIChub3QgZnVuYykgcGFuaWMo
IlN5bnRheCBlcnJvcjoiLCB0b3N0cihlcnIpKQoKCWxvY2FsIG1vZHVsZSA9IGZ1bmMoKQoJX21v
ZHVsZXNbbmFtZV0gPSBtb2R1bGUKCglyZXR1cm4gbW9kdWxlCmVuZAoKCmZ1bmN0aW9uIHBhbmlj
KC4uLikKCWxvY2FsIGFyZ3MgPSB7IC4uLiB9Cglmb3JlYWNoKAoJCWFyZ3MsCgkJZnVuY3Rpb24o
c3RyKQoJCQlzZW5kX21lc3NhZ2UoMywgeyBldmVudCA9ICJyZXBvcnRfZXJyb3IiLCBjb250ZW50
ID0gc3RyIH0pCgkJZW5kCgkpCglzdG9wKCkKZW5kCgoKLS0gVGFibGUgdXRpbGl0eSBmdW5jdGlv
bnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0KCgpmdW5jdGlvbiBpc19lbXB0eSh0KQoJcmF3ZXF1YWwobmV4dCh0KSwgbmlsKQplbmQKCmZ1
bmN0aW9uIGRlZXBfY29weSh0LCBhbHJlYWR5KQoJaWYgKG5vdCBhbHJlYWR5KSBhbHJlYWR5ID0g
e30KCWlmIHR5cGUodCkgPT0gInRhYmxlIiB0aGVuCgkJaWYgYWxyZWFkeSBhbmQgYWxyZWFkeVt0
XSB0aGVuCgkJCXJldHVybiBhbHJlYWR5W3RdCgkJZW5kCgkJbG9jYWwgbmV3ID0ge30KCQlhbHJl
YWR5W3RdID0gbmV3CgkJZm9yIGssIHYgaW4gcGFpcnModCkgZG8KCQkJbmV3W2tdID0gZGVlcF9j
b3B5KHYsIGFscmVhZHkpCgkJZW5kCgkJcmV0dXJuIG5ldwoJZWxzZQoJCXJldHVybiB0CgllbmQK
ZW5kCgoKZnVuY3Rpb24gdG9zdHJyZWModCkKCWlmIHR5cGUodCkgIT0gInRhYmxlIiB0aGVuCgkJ
cmV0dXJuIHRvc3RyKHQpCgllbmQKCQoJbG9jYWwgcyA9IG5pbAoJZm9yIGssIHYgaW4gcGFpcnMo
dCkgZG8KCQlpZiBub3QocykgdGhlbgoJCQlzID0gInsgIgoJCWVsc2UKCQkJcyAuLj0gIiwgIgoJ
CWVuZAoJCXMgLi49IHRvc3RyKGspIC4uICIgPSAiIC4uIHRvc3RycmVjKHYpCgllbmQKCWlmIG5v
dCBzIHRoZW4KCQlyZXR1cm4gInt9IgoJZW5kCglzIC4uPSAiIH0iCgoJcmV0dXJuIHMKZW5kCgoK
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCgpmdW5jdGlvbiBjbGFtcCh2LCBtaW4sIG1heCkKCWlm
IHYgPCBtaW4gdGhlbgoJCXJldHVybiBtaW4KCWVuZAoJaWYgdiA_IG1heCB0aGVuCgkJcmV0dXJu
IG1heAoJZW5kCglyZXR1cm4gdgplbmQKCgpmdW5jdGlvbiBleHBfZGVjYXkoYSwgYiwgZGVjYXks
IGR0KQoJLS0tIExlcnAgc21vb3RoaW5nLCBidXQgZnJhbWVyYXRlLWluZGVwZW5kYW50LCBmcm9t
IEZyZXlhIEhvbG3DqXIKCS0tLSBodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PUxTTlF1
RkVET3lRCgktLS0gVXNlIGFzIGBhID0gZXhwX2RlY2F5KGEsIGIsIGRlY2F5LCBkdClgCglyZXR1
cm4gYiArIChhIC0gYikgKiBtYXRoLmV4cCgtIGRlY2F5ICogZHQpCmVuZAoKCi0tIFBvcyAtLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLQoKCi0tIFdBUk5JTkc6IGRvIG5vdCBmb3JnZXQgdGhhdCBgcG9zYCBpcyBh
IHJlZmVyZW5jZSB0eXBlLCBub3QgYSB2YWx1ZToKLS0gYXZvaWQgbW9kaWZ5aW5nIGluIHBsYWNl
LgpmdW5jdGlvbiBwb3MoeCwgeSkKCWxvY2FsIHAgPSB1c2VyZGF0YSgiaTE2IiwgMikKCXAueCA9
IHgKCXAueSA9IHkKCXJldHVybiBwCmVuZAoKCi0tIERyYXdpbmcgLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoK
Ci0tIEZyb20gU29waGllIG9uIHRoZSBkaXNjb3JkCmZ1bmN0aW9uIGdldF9kcmF3c3BhY2UoKQog
ICAgcmV0dXJuIHsKICAgICAgICBjYW1feD1wZWVrNCgweDU1MTApLAogICAgICAgIGNhbV95PXBl
ZWs0KDB4NTUxNCksCiAgICAgICAgY2xpcF9sPXBlZWsyKDB4NTUyOCksCiAgICAgICAgY2xpcF90
PXBlZWsyKDB4NTUyYSksCiAgICAgICAgY2xpcF9yPXBlZWsyKDB4NTUyYyksCiAgICAgICAgY2xp
cF9iPXBlZWsyKDB4NTUyZSksCiAgICB9CmVuZAoKCmZ1bmN0aW9uIHNldF9kcmF3c3BhY2UoZHJh
d3NwYWNlKQogICAgcG9rZTQoMHg1NTEwLGRyYXdzcGFjZS5jYW1feCkKICAgIHBva2U0KDB4NTUx
NCxkcmF3c3BhY2UuY2FtX3kpCiAgICBwb2tlMigweDU1MjgsZHJhd3NwYWNlLmNsaXBfbCkKICAg
IHBva2UyKDB4NTUyYSxkcmF3c3BhY2UuY2xpcF90KQogICAgcG9rZTIoMHg1NTJjLGRyYXdzcGFj
ZS5jbGlwX3IpCiAgICBwb2tlMigweDU1MmUsZHJhd3NwYWNlLmNsaXBfYikKZW5k
:: main.lua
--[[pod_format="raw",created="2024-03-30 05:39:34",modified="2024-09-13 21:16:28",revision=4638]]
include "drakma.lua"
include "src/constants.lua"
include "src/sgrid.lua"
include "src/hgrid.lua"
include "src/logic/creation.lua"
include "src/logic/matching.lua"
include "src/logic/spells.lua"
include "src/logic/mechanics.lua"
include "src/gfx.lua"
include "src/in_game.lua"
include "src/in_editor.lua"
include "debug.lua"


local state = in_editor
--local state = in_game
local next_state = false


function _init()
	window { cursor = "" }
	fetch("pal/0.pal"):poke(0x5000)
	state:enter()
end


function _update()
	if next_state then
		state:exit()
		state = next_state
		state:enter()
	end
	next_state = state:update()
end


function _draw()
	state:draw()
	print(string.format("\014% 3.0f", (stat(1) * 100.0)) .. "%", 460, 264, 1)
end
:: .info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTIzIDE4OjQ1OjEzIixtb2RpZmllZD0iMjAyNC0w
OS0xMyAyMToxNjoyOSIscnVudGltZT0xMCxzdG9yZWQ9IjIwMjQtMDMtMzAgMDY6NTQ6MjQiLHdv
cmtzcGFjZXM9e3tsb2NhdGlvbj0ibWFpbi5sdWEjNSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2Nh
dGlvbj0ic3JjL2luX2dhbWUubHVhIzE3NCIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0i
c3JjL2xvZ2ljL2NyZWF0aW9uLmx1YSM1NSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0i
c3JjL2xvZ2ljL3NodWZmbGUubHVhIzEiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InNy
Yy9jb25zdGFudHMubHVhIzM2Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJzcmMvZ2Z4
Lmx1YSMxMTciLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImdmeC8wLmdmeCIsd29ya3Nw
YWNlX2luZGV4PTJ9LHtsb2NhdGlvbj0ic2Z4LzAuc2Z4Iix3b3Jrc3BhY2VfaW5kZXg9NH0se2xv
Y2F0aW9uPSJwYWwvMC5wYWwiLHdvcmtzcGFjZV9pbmRleD03fX1dXQ==
:: [eoc]
