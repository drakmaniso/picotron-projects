picotron cartridge // www.picotron.net
version 2

:: docs/
:: docs/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTI2IDE0OjAzOjI1Iixtb2RpZmllZD0iMjAyNC0w
OC0yOCAxMToxMToyNCJdXQ==
:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNC0w
OC0yOCAxMToxMToyMyIscmV2aXNpb249MTc3M11dbHo0ANUQAACYSwAA8xd7WzBdPXtibXA9cHh1
AEMgHR0E8P---zwsZmxhZ3M9MCxwYW5feAgAy3k9MCx6b29tPTJ9LDQA8CQ1bPAEHGob8AAcugnA
DNoJCKAMKh8qqgkIgAwqLqoZCHAMKh4cShw6CQgPNVAMSgwZDCoEAPAMGQhQDDoMOQwKDDkMGhkI
DTAMSgxJDEkMGikICwAQqQkAgQ0gDFoMiQwqCgBVagxpDDoUACwaOQoAEDlNAMBJCA0wC1oMGQwK
DBkaAP8oHTALahwqHBpJCA1Q6kkIHVAZqmkIDXAIGWp5CB2ACOkIHaAYqRgdwA0YaRgt8AANaC3w
BG3wFwQBHvEQbxHwBB5vDx8Q8AAevw8PDsAO3w8PDg8NoA4vDx8qrwwA0YAOLw8vKq8PHw4PDXAY
AEAfDy59GgDwFw81UA59Dh8ODm0cDw1QDo0OHA5dHAsPNTAOnQ4sDk0sCzAOjQ48CQAnCiAKADV9
DkwKAEw8Dk08CgDALA5NTAsKMA8QfQ4cFQAwGjAJWwD-IS1MCwpQnS4dTAsaUBytbAsKcAscbXwL
GoAL7AsaoBusGxrAChtsGyrwAAprKvAEag8BIRAWDwEwFB8VDwHxAxQPE8AO3xQPEw8SoA4vFB8q
rwwA0YAOLxQvKq8UHxMPEnAYABHPGAAADQEw-xQDFwBxUA6PFC5tHxUAAAMBhC8TDl0sDxIw_gCR
DzUgDm0ObA49BQEKCgAkLTwjASI9PDcBMSwOPQ8BMhWNLg0BIP0ACgEf7QgBSRAbCAEwGR8aCAHx
AxkPGMAO3xkPGA8XoA4vGR8qrwwA0YAOLxkvKq8ZHxgPF3AYAEAvGS5tGgACFwKgLxgOXRwPF1AO
bfUAAhcCAwABYjAObR5MHvQAUV0OjA4tCgBVTQ6sDh0KACoNPAoAkV0OLA4MDiwODQwBYxpdPgw_
HRsCEQwhAU9QjS4tEwFJECATATAeHx8TAfEDHg8dwA7fHg8dDxygDi8eHyqvDADwB4AOLx4vKi8e
Dm0fHQ8ccA4tHyo9Dn0aAAATATCdDn0XAAAoAyAPHTMDEhwqA2QMDm0sDxwKAAEdAgD1ARFdCwEG
CgAGEwIKCgARLREBEB9mAREtEQEAQQMfLREBUBAlEQEwIx8kEQHxAyMPIsAO3yMPIg8hoA4vIx8q
rwwA0YAOLyMvKq8jHyIPIXAYABHPGAAADwFAfyM_bRgAACECIC8iEAEQIRABkW0OLA59LA8hMPIB
Eo0QAQALAEQ9Hi0sCQJELQ4MDg4AZDwuHA4dPEsCJB08SQMRHRgBFyQYAS9OLTgDThAqFAEwKB8p
FAHwBSgPNMAO3ygPNA85oA4vKB4dLw9dDQDyA4AOLS4NTw9NHzQPOXAOLR4dTxgAABUBkD0qDU8P
DS8UHR0AwVAOLUoNLw8NTxQNHyAANDAOPREA0i80DzkwDj1aDQ8PDV8PAAApAWRNSi1PFB0OACX9
BBgAc08jLU8ZDT8PAJU9XyMNDx4NXxkRAHNPIw0vHg1PEQBEMA8pLRIAAEMAEB8SAIM9LyMNTx4N
LyQAYVB9Tx4dTx0AcVAfNF1PHm8XAHFwDzkfNE0vDgBhHzWADznvCQD-C6AfOa80HzkfNcAMHzlv
NB85LPAADGss8ARsZwEf8A1PPxJAPuAODxYfKg8VDiAOHyofFg7QDg8qPxUuBQBADg81wB4ApBQf
FS8WHxUfFA8TANUPFQ8UDxNPFQ8TDxQfKAABFQARLxUAEC8VADGQPyw_AFATLxUfEz4A-AYeHytg
Dyw-LS8VXy0-LB8VHywPK1ARAD8PNUATACXzAFBPLC8TTywvKx8TLysfNVsANU8tLyIAH2ATAITv
cD8rLn0eHR81gPwD8C7JAR3yPDkvKxAPD-AGDysgHvAFTyzwBw0-LQ0O8AYNDD0ODzXwAx1sHfAB
DawN4A28HcANLB8qjA0OoA0sK4wdDpANLBucHQ4PNXAN-AAtDgYAKwpgBwAm7D0GAP8a3E0OCnAN
vE0OGnANrF0OCpAdbG0OGqAOzQ4awA6tDhrgHm0eGvABCm79AyPwBU0PLOAOoA4PLQ7ADg0OkA4d
DqAOoABAgA4tDgQA0QyADg0PKx0OYA4dCw0OAFIbHW4dGwsAMyuNKxQAEq0SACr9AQYAkHAOLS5t
Li0OcFQA8QkaDyoLDk0OCgsPGg4dDgxgDh0OCRsJDi0GAAERADMtDikEAIAMYA49Lk0uPQkAIP0D
SQD-Im0vCW0OHEBbXQhdW3AOPQ4dDh0OPQ4cgDstHg0eLTtwGyAOrQ4cABuwHm0eHPABDG6mAyPw
AosPK2AO8AQeQB7wBA4PLE4NDQBATR7QLp8F8CkgLg81QB4tHgAODR8PDRwNDgAeLR4gDm0eDA8q
DgwLDgwebQ4QDn0ODB4MHgwOfQ4PNQAOfQ4NHCsA8Al9DgoADo0OTQ6NDgoAPm0OLQ5tPgoADhrf
APAGGg4KEAoAPs0_ChAKMA4aDi0OTQ4tFgDwBnAKAE5NTgoQCpAOKg5NDioOCtAKIBsA-wIgCvAD
Dg0OGvAJDhrwCwrwcegAHdAyLyugHqAeLy0OcB4dBACAPywOQB4dHA7iAPAPHRwPDQ8PDw0cDhAe
HUwOMA4dPA8PDxAPDyweHWwOegUSXCEA8RQMHh2cDiAOfB4dbB4sDg81EA5cHh08HiwOCx4cDhAO
PB4dDA0AxQwOCwALLgsADgwuHRAAlR4LICsAHi0ODA8AcBtgDg08DhsKAPACsA4cDhwOIBvwAQ5M
DhAe8ANJCaEeDQ4gHuAuTA4ACgByoBseLB4dDA4AUi5wCx5cDgBwHQ4LgAsejA0A8A4boAsevA4L
0AsejA4b8AALHmwOC-ADCx48DhvwBaUAvwvwCAseG-AKG-ARQwEd8AQanyvwAg4vLQ5dDvAADg0-
LA5MCQAAuACxXA7gDkwOXA7QDg0BChBcXgMgDC4ZALSwDg0MDi81DhwODGUBEKATAAA9AQAUAAFo
AYAcDpAODSwOAAUABCYAoJAODT4PNT4MDjwLAFEMDjsAG2wAYKAODRwOQAUAEAwMAEAsDgswBgAQ
sEsBECAFAKALkA4NHD4LED4sOQCgHA47IBsOLA4LcBwAAXEBAQoAJAtQBgAQXE4AsVwOUA4NLD4L
MD48UQBgPA47QBsODAJADUwOgAUAQQswHjxGAHAsHhtACx4sTABBHB4rcN4B-wNQDg0eK7ALHgtQ
HivwABtgG3BeAR2gLx8roC6wDh8tHm4I9AOQDh8sHR5ADjwdHmAOTB0eEA6jAgAWAEJsHR4sOQGD
PB0OIA6cHR5cAaFcDiAOLB5sHR58jAPxAhweCw4sHjwdHlwOCwAuKw4MEAAgDB3JAEMQKxAeEgBy
HS4MDgtwGxAA8gMMDi0eC8AbEB4bDjwNDgvwAhvjAfAAC-ABHhAOTA4LsB4gDg0e5QshG2ALAHIA
DkwuGxAuCwCSDB0eLB47IA4dDABAXB4rYAgA-xiMHiuADrweK7AOjB4r0A5sHivwAQ48HivwAw4c
HivwBh4r8Akb8CI1AR2wFh8rYB7wAB4PLQ6YCYEPLR6wHh0PLA0AUA0fLB5w4gORHzVgDjweQA4d
vwGAXA4wDkwOG4DLANAwDjw_QD48DhswDkwdDwAgHUzLAUBMDhtABQAjUA4PACELcO4AAAUAcHAO
LD4gPixlAvICLB0OCxAOHSwOG5AOPA4bIA57AgBsAhAwKwAQgLYCEBxMAEAcDguApAJQDD4APgxE
ABMNsAFxDhwdDgsOHSAAEhzSAQEzAABzASQbgPQBABMAEAsuA6ALoA5cDhwuHA4bCQAQDDgGUA4L
wA5crwIQGwgAAakBAIsDEEwHABBchgCP8ACeG-ACm7BbARlfEBAE8PAxAP--_l8dHQT-N74UDx02
NQAfODUAIR88NQAhHz01AB0PBQEQHzExAI3xJiMgBHD-NgPg-gXQ-gXA-gew-geg-gmQ-gmA-gtw
-gtg-g1Q-g1A-g8w-g8g-hEQ-hEA-jYACQARIBUAEUAhABFgLQARgDkAEaBFABHAUQBP4P4DcI4A
Hh83jgB6HziOAHofO44Aeh88jgB6Hz2OAEkPtgN7ALkJ8BIVvzQPMdDfNC8xoN80TzGAXzRfMg8x
DzAPNF8xYE80fzILAPAJLzJPMUBPNI8yDzFPMk8xMD80-zIBPzEgCABBAz8xEAgAvx8xHzAQLzT-
MgUvCAAZcS8yDzH-MgEMAHIfMQ8w-zICDAAyMA80DAAQHxgAAAwAUD8wED8xcgAgMCAIAPEOAT8w
ME8xfzIPMV8yTzBATzFvMh8xPzJPMGBfMT-FAP8GLzJfMIBPMd8woC8x3zDQDzG-MPAVIgEjUJ80
DzIvJgEADgAfDyoBEEIwDzQ-LAERnw0AIU8yMQFhvzIPMF8yNAERrz8AED8eABMyPQFgDzIPMY8y
_wAAvQABXgAkMi8ZABJ-EQBgNB8yDzAvCgASMSkBAfgAAn0AEC92AAEVABAyWgAAVgAAFwAgDzAS
AAIuACMyH28ARR80nzKCAVQvMB80vyIAAGcAQR80LzARACEPNA8AEjHEAEUPMK8ynwEUXw8AAqIB
oW8yDzBPMg8xPzKpATF-Mh-EACFPMrABACABEy8eABEwrAESMP8AAbsBAEsBUh8wHzEfvwE-DzI-
vwFEVm80DzE-wwEA7QAAlgADxwFgHzQPMh80PQITHxUAAdEBAGUBJF8yBgETP6wAQTA-NA-VADIv
MS8XABEw4wERHyoARD8wLzTeAQHvAQCBAQEdAB0x9QFfHzAvNE-3AQIBcQAfb-kBASAfNIYADfsB
Aa8BASoABP8BER9fAA--AQAAGAICzgAJBwIRP6ICAxUABg0CAZgAA1cADxcCAALSADQvMU8dAhFP
OgAAXgA2PzAfJQIzPzIvFwAAVwAANAABLQJiHzIfMV8wbgABdQEAMwJXLzBPNA8VAAE5AhIfKgEF
KAADPQIvPzA7Aj-xBTZPNPADLgAOTzMPMgAuwA4vMw8yDQBwDi8zDrAOPdwC8XMPMU2gDD0PMgxD
DAs9DHAeDQwNG4MbDQweDUAeLRwzRBMcDh0bMA49CyOEAws9CzAOLQsjpAMtCwwwDCsME7QDKxxA
LCPEAyxQLhPUAy5ADi0T1AMOLTAOHQsThB8UJAMtCzAtCxN0Cg8qGhQDHRswCx0ME3Q6AwQDKwxA
LBOEGhMEPAA4lBMUPgAACAASPQcAIS0LTQAT1EoAENRFAEErDBPUQQCv-zABLHD-NQTwERwBHfAQ
hS805C5gDg8qDg8y5C4NUC4N5C4NDzUwLg30AS4NMBkAcA30AQ4MDg22E2AMDg1UTlQHAJELIC4N
RF4NRC4KAPEDbi8LDg1_DQsgngoMDwwPCg8JDgDwAo0OCg8MHwoPCZ0LMC1DDgovGQDhQy0LQB4N
RB4pDg1EHg0MABReCgAyVE1UCQAo9AEIACT_BgUAnw79BgtQ_wfwZs8LDA-oAEYWEOgAVREPDw8O
6ABUER8PDw7oAAAZAA-oADMP0AFlFhXoABAWKBoF6ABUFh8UDxPoAAAZAA-oAKskGh3nAFUbDxkP
GOcAVBsfGQ8Y5wAAGQAF5wAUHeYALx5N5gCWFR-mAFUgDx4PHeYAVCAfHg8d5gAAGQAP5gCqFSTm
AFUlDyMPIuYAVCUfIw8i5gAAGQAP5gBeD9MLEB82MQD---------------------------------
----------------xFBtPTZ9fQ==
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNC0w
OC0yOCAxMToxMToyNCIsc3RvcmVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Il1d
:: map/
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNC0w
OC0yOCAxMToxMToyMyIscmV2aXNpb249MTY1Nl1dbHo0AMEAAABZEAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD-------_x0zIwMDAzMDAwNDAwMDYMAC81MIAAWxMxCAATNYAALzYw
AQBbFzb8ABMxDAAPAQBVBHwBAAABEzAMAA_AAVkTMXQAEzB4ABcxjAAPAAFVEzaEAAQMAC81MAEA
--------nvEJIiksaGlkZGVuPWZhbHNlLHBhbl94PTQ3CQDSeT0wLHRpbGVfaD0yOQoAEHcKAIB6
b29tPTF9fQ==
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNC0w
OC0yOCAxMToxMToyNCIsc3RvcmVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Il1d
:: pal/
:: pal/0.pal
b64$LS1bW3BvZCxiZ19jb2xvcj0wLGJsYWNrZXN0X2NvbG9yPTAsY3JlYXRlZD0iMjAyNC0wOC0y
MyAxODo1OTowOSIsaGlkZGVuPXtbMF09ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2V9LGhpZGRlbl90b2dnbGVzPXtbMF09ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2V9LGlj
b249dXNlcmRhdGEoInU4IiwxNiwxNiwiMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDAw
MDAxMDcwNzA3MDcwNzA3MDcwNzA2MDEwMDAwMDAwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDYwNjAx
MDAwMDAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNjA2MDYwMTAwMDAwMDAxMDcwNzA3MDcwNzA3MDcw
NzA2MDYwNjA2MDEwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwMTAwMDAwMTA3MDcwNzA3
MDcwNzA3MDcwNzA3MDcwNzAxMDAwMDAxMDcwNzA2MDYwMTAxMGQwZDAxMDEwNzA3MDEwMDAwMDEw
NzA3MDYwNjAxMDEwZDBkMDEwMTA3MDcwMTAwMDAwMTA3MDcwMTAxMDcwNzA2MDYwZDBkMDcwNzAx
MDAwMDAxMDcwNzAxMDEwNzA3MDYwNjBkMGQwNzA3MDEwMDAwMDEwNzA3MGQwZDAxMDEwZDBkMDYw
NjA3MDcwMTAwMDAwMTA3MDcwZDBkMDEwMTBkMGQwNjA2MDcwNzAxMDAwMDAxMDcwNzA3MDcwNzA3
MDcwNzA3MDcwNzA3MDEwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwMTAwMDAwMTAxMDEw
MTAxMDEwMTAxMDEwMTAxMDEwMTAxMDAiKSxsb2NrZWQ9e1swXT1mYWxzZSxmYWxzZSxmYWxzZSxm
YWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxz
ZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxm
YWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxz
ZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxm
YWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxz
ZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxm
YWxzZSxmYWxzZSxmYWxzZSxmYWxzZX0sbW9kaWZpZWQ9IjIwMjQtMDgtMjggMTE6MTE6MjMiLG9r
cGFsX3ZlcnNpb249IjEuMC4zIixyZXZpc2lvbj0xNTUzLHRlc3RfY3ViZV9jb2xvcnM9e1swXT17
MTUsMzEsNH0sezMxLDQsMjB9LHs0LDIwLDIxfSx7MTAsOSwyNX0sezksMjUsMjR9LHs4LDI0LDJ9
LHsyNiwxMSwyN30sezExLDI3LDN9LHsyNywzLDE5fSx7MjgsMTcsMTl9LHsyOCwxMiwxNn0sezEy
LDE2LDF9LHs2LDI5LDEzfSx7MjksMTMsMTh9LHsxMywxOCwxfSx7NywyMywxNH0sezIzLDE0LDEz
fSx7MTQsMzAsMTh9LHs3LDYsMjJ9LHs2LDIyLDV9LHsyMiw1LDIxfSx7MSwxLDF9LHsxLDEsMX0s
ezEsMSwxfX0sd2hpdGVzdF9jb2xvcj03XV1sejQA8QEAABUCAAD9BXVzZXJkYXRhKCJpMzIiLDY0
LCIwAQDxGjRjNDUzMzAwNzk0NTNmMDA4YjUwNDkwMGU3YTEzZDAwZWVjNTcxMDBmAQDwMDAwNzQx
ZjY1MDBhODI1OTIwMGUyNDliYTAwZWY4M2M1MDBmOGJiZDkwMDc3MmMxNjAwYTIzMjE5MDBkNTRm
MkgA8CwzODI1NzAwZmNiYzljMDA2NzQ5MTMwMDljNzExYTAwZDZhMjI1MDBlZGM0NTQwMGZiZTE5
OTAwMmQ1MxgA8BYzMTZlMzIwMDUwYTMyYzAwODdkNDU2MDBiZmYyOTUwMDE2NTg1CADwDTc3OTdk
MDAyMGI0YjMwMDVjZDhkMjAwYWNmNmb4ALA3MjI4NjAwNWUyNiAA0DhkM2JlZDAwYWU4MWawAEA4
YzRmoAAQZQIAQDAwYjcCAEAwMGUzAgBAMDBmNAIAAMgAAAIAQDAwMWQCAEAwMDJlAgBAMDA0NgIA
QDAwOWICAEAwMGMxAgDgMDA0ZjRiM2UwMDczNmHgAPATOWU4Zjc0MDBhYTlkODUwMGJlYjVhNDAw
NTg1OTVkMDA2OAIAUTAwNmY2uQARNwEAcTAwODY4MzjIAEAzNDM1MACwNDI0MjAwNjA0ODQwABA5
oQDwAzAwODg2ZDZkMDAzMjIyM2MiKQ==
:: pal/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTIzIDE4OjU0OjE5Iixtb2RpZmllZD0iMjAyNC0w
OC0yOCAxMToxMToyNCJdXQ==
:: sfx/
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM1Iixtb2RpZmllZD0iMjAyNC0w
OC0yOCAxMToxMToyMyIscmV2aXNpb249MTY1M11dbHo0ABoBAABSCAAA8CdweHUAAygAAAQABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDBAUGBwAP-5AICQoLDwwPDQ8ODw8QAPAADQ8RDxIPEw8UDxUP
Fg8XEwDxAQ8YDxkPGg8bDxwPHQ8eDx8UAPEAIA8hDyIPIw8kDyUPJg8nFADxACgPKQ8qDysPLA8t
Dy4PLxQA8QAwDzEPMg8zDzQPNQ82DzcUAP8FOA85DzoPOw88Dz0PPg8-AA--8P8BAOv-J1oBEAYP
IBABIAEgAfAAAhACDBABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDDAAAh9EMAAc
H0AwAPIf-wEA3L-4D0AADUD--7DwcAoA--9kH-8BAP_ZUP----8g
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNC0w
OC0yOCAxMToxMToyNCIsc3RvcmVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Il1d
:: src/
:: src/constants.lua
--[[pod_format="raw",created="2024-08-24 15:17:10",modified="2024-08-28 11:11:23",revision=1541]]
--- Match3 Global Constants


-- Gems and cells ------------------------------------------------------

-- Color gems
gem_air = 0x01
gem_fire = 0x02
gem_day = 0x03
gem_earth = 0x04
gem_water = 0x05
gem_night = 0x06
gem_rainbow = 0x07

gem_color_first = gem_air
gem_color_last = gem_rainbow

gem_names = {
	[gem_air] = "Air",
	[gem_fire] = "Fire",
	[gem_day] = "Day",
	[gem_earth] = "Earth",
	[gem_water] = "Water",
	[gem_night] = "Night",
	[gem_rainbow] = "Rainbow",
}

-- Black gems
gem_gift = 0x08
gem_bomb = 0x09
gem_cat = 0x0a
gem_bat = 0x0b
gem_robot_E = 0x0c
gem_robot_S = 0x0d
gem_robot_W = 0x0e
gem_robot_N = 0x0f

-- Cells
cell_good = 0x01
cell_bad = 0x02

cell_mask = 0x0f

-- Rocks
rock_full = 0x10
rock_cracked = 0x20
rock_broken = 0x30
cell_door = 0x40
cell_chest_air = 0x50
cell_chest_fire = 0x60
cell_chest_day = 0x70
cell_chest_earth = 0x80
cell_chest_water = 0x90
cell_chest_night = 0xa0

rock_mask = 0xf0


-- Flags for the matching algorithm -----------------------------------------


flag_matching_mask = 0x0f
flag_vertical = 0x01
flag_horizontal = 0x02
flag_horizontal_SE = 0x02
flag_horizontal_NE = 0x04
flag_square = 0x08

flag_counted = 0x10

flag_new = 0x20
flag_falling_mask = 0xf00

:: src/gfx.lua
--[[pod_format="raw",created="2024-08-24 12:06:13",modified="2024-08-28 11:11:23",revision=1760]]
--- Graphics


local cell_width = 29
local cell_height = 29



function gfx_draw_cells(cells)
	local function draw_cell(p, cell)
		local x, y = cells:coords_cell(p)
		local sprite
		if cells.is_square then
			if cell & cell_mask == cell_good then
				sprite = 32
			elseif cell & cell_mask == cell_bad then
				sprite = 34
			end
			sprite += (p.x + p.y) % 2
		elseif cells.is_hex then
			if cell & cell_mask == cell_good then
				sprite = 40
			elseif cell & cell_mask == cell_bad then
				sprite = 43
			end
			sprite += (p.y + (p.x * 3)) % 3
		end
		spr(sprite, x, y)
		x, y = cells:coords_gem(p)
		if cell and cell & cell_mask == cell_bad then
			pal(53, 58)
		end
		if cell & rock_mask == 0 then
		elseif cell & rock_mask == rock_full then
			spr(48, x, y)
		elseif cell & rock_mask == rock_cracked then
			spr(49, x, y)
		elseif cell & rock_mask == rock_broken then
			spr(50, x, y)
		elseif cell & rock_mask == cell_door then
			spr(51, x, y)
		elseif cell & rock_mask == cell_chest_air then
			spr(52, x, y)
		elseif cell & rock_mask == cell_chest_fire then
			spr(53, x, y)
		elseif cell & rock_mask == cell_chest_day then
			spr(54, x, y)
		elseif cell & rock_mask == cell_chest_earth then
			spr(55, x, y)
		elseif cell & rock_mask == cell_chest_water then
			spr(56, x, y)
		elseif cell & rock_mask == cell_chest_night then
			spr(57, x, y)
		end	
		pal(53, 53)
	end
	cells:foreachpos(draw_cell)
end


-----------------------------------------------------------------------


local function scaled_gem(sprite, x, y, size)
	local w, h = flr(29 * size + 0.5) // 2 * 2 + 1, flr(29 * size + 0.5) // 2 * 2 + 1
	local x, y = x + ((29 - w) / 2), y + ((29 - h) / 2)
	sspr(sprite, 0, 0, 29, 29, x, y, w, h)
end


function gfx_draw_gems(cells, gems, flags, clock, gravity)
	local function draw_gem(p, gem)
		local x, y = gems:coords_gem(p)
		local sprite = 0 + gem
		local cell = cells:get(p)
		if cell and cell & cell_mask == cell_bad then
			pal(53, 58)
		end
		local flag = flags:get(p)
		if not flag or flag == 0 then
			spr(sprite, x, y)
		elseif flag & flag_new != 0 then
			scaled_gem(sprite, x, y, clock)
		elseif flag & flag_matching_mask != 0 then
			scaled_gem(sprite, x, y, 1.0 - clock)
		elseif flag & flag_falling_mask != 0 then
			local distance = (flag & flag_falling_mask) >> 8
			local destination = p + (distance * gravity)
			local dest_x, dest_y = gems:coords_gem(destination, gem)
			local ix, iy = x + clock * (dest_x - x), y + clock * (dest_y - y)
			spr(sprite, ix, iy)
		end
		pal(53, 53)	
	end
	gems:foreachpos(draw_gem)
end

:: src/hgrid.lua
--[[pod_format="raw",created="2024-08-25 08:16:09",modified="2024-08-28 11:11:23",revision=1526]]
--- Hex Grids

--- Hex grids use the "double height" coordinate system:
---
---     (0,0)         (2,0)         (4,0)
---            (1,1)         (3,1)
---     (0,2)         (2,2)         (4,2)
---            (1,3)         (3,3)
---     (0,4)         (2,4)         (4,4)
---
--- The origin of the grid, `pos(0, 0)`, is at the top left.


-- Local Constants --------------------------------------------------------


local max_width <const> = 13
local max_height <const> = 8


-- Constructors -----------------------------------------------------------


local metatable = {}


function hgrid_new()
	local grid = { is_hex = true }
	setmetatable(grid, { __index = metatable })
	return grid
end


function metatable:new_grid()
	return hgrid_new()
end


function metatable:clone()
	local grid = self:new()
	self:foreachpos(function(p, item) self:set(p, item) end)
	return grid
end


function hgrid_new_cells(size)
	local grid = hgrid_new()
	local p = pos(0, 0)
	while p.x < size.x do
		while p.y < size.y * 2 do
			local cell = cell_good
			if rnd() < 0.0000033 then
				cell = cell_bad
			end
			if rnd() < 0.03 then
				if rnd() < 0.60 then
					cell |= rock_full
				elseif rnd() < 0.75 then
					cell |= rock_cracked
				else
					cell |= rock_broken
				end
			elseif rnd() < 0.005 then
				cell |= math.random(5, 5 + 5) << 4
			elseif rnd() < 0.005 then
				cell |= cell_door
			end
			grid:set(p, cell)
			p.y += 2
		end
		p.x += 1
		p.y = p.x % 2
	end
	grid:set(pos(size.x // 2, size.y - 2), nil)
	grid:set(pos(size.x // 2, size.y), nil)
	return grid
end


-- Indexing ------------------------------------------------------------


function metatable:get(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return nil
	end
	return self[p.x + ((p.y // 2) * max_width)]
end


function metatable:set(p, value)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return nil
	end
	self[p.x + ((p.y // 2) * max_width)] = value
end


function metatable:flag(p, flag)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return nil
	end
	local index = p.x + ((p.y // 2) * max_width)
	if self[index] then
		self[index] |= flag
	else
		self[index] = flag
	end
end


function metatable:unflag(p, flag)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return nil
	end
	local index = p.x + ((p.y // 2) * max_width)
	if self[index] then
		self[index] &= ~flag
	end
end


function metatable:del(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return nil
	end
	self[p.x + ((p.y // 2) * max_width)] = nil
end


-- Screen Coordinates ---------------------------------------------------------


function metatable:coords_origin()
	return 119, 7
end


function metatable:coords_cell(p)
	local ox, oy = self:coords_origin()
	return ox + p.x * 27, oy + p.y * 16
end


function metatable:coords_gem(p)
	local ox, oy = self:coords_origin()
	return ox + (p.x * 27) + 3, oy + (p.y * 16) + 1
end


function metatable:pos(x, y)
	local ox, oy = self:coords_origin()
	x -= ox
	y -= oy + 1
	local px, py = x // 27, y // 16
	local dx, dy = x - (px * 27), y - (py * 16)
	if dx < 8 then
		if (px + py) % 2 == 0 and dy < 14 + (-2 * dx) then
			px -= 1
			py -= 1
		elseif (px + py) % 2 != 0 and dy > -1 + (2 * dx) then
			px -= 1
		end
	end
	py = (2 * ((py - (px % 2)) // 2)) + (px % 2)
	return pos(px, py)
end


-- Iterating ----------------------------------------------------------


function metatable:foreachpos(func)
local s = ""
	local p = pos(0, 0)
	while p.x < max_width do
		while p.y < max_height * 2 - 1 do
			local item = self:get(p)
			if item then
				func(p, item)
			end
			p.y += 2
		end
		p.x += 1
		p.y = p.x % 2
	end
end	


function metatable:neighbours(p)
	return {
		{ position = p + pos(1, 1), direction = flag_horizontal_SE },
		{ position = p + pos(0, 2), direction = flag_vertical },
		{ position = p + pos(-1, 1), direction = flag_horizontal_NE },
		{ position = p + pos(-1, -1), direction = flag_horizontal_SE },
		{ position = p + pos(0, -2), direction = flag_vertical },
		{ position = p + pos(1, -1), direction = flag_horizontal_NE },
	}
end

:: src/in_game.lua
--[[pod_format="raw",created="2024-08-27 17:11:11",modified="2024-08-28 11:11:23",revision=582]]
in_game = {}


local cells = {}
local gems = {}
local flags = {}
local matches = {}

local tiling = "square"
local gravity = pos(0, 1)
local substate = false
local clock = 1.0


----------------------------------------------------------------------


-- Functions for substate need to be global, because of Lua
-- forward-declaration rule for locals.


function creating_the_board()
	if tiling == "square" then
		cells = sgrid_new_cells(pos(12, 9))
	else
		cells = hgrid_new_cells(pos(13, 8))
	end
	gems = cells:new_grid()
	flags = cells:new_grid()
	matches = cells:new_grid()
	return creating_missing_gems
end


function creating_missing_gems()
	logic_fill_gems(cells, gems, flags)
	clock = 0.0
	return animating_new_gems
end


function animating_new_gems()
	clock += 1.0 / 8.0
	if clock >= 1.0 then
		flags:foreachpos(function(p, _) flags:unflag(p, flag_new) end)
		return waiting_for_input
	end
	return animating_new_gems
end


function waiting_for_input()
	if keyp("s") then
		tiling = "square"
		gravity = pos(0, 1)
		return creating_the_board
	end
	if keyp("h") then
		tiling = "hex"
		gravity = pos(0, 2)
		return creating_the_board
	end
	if keyp("del") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:set(p, nil)
		flags = cells:new_grid()
		matches = cells:new_grid()
	end
	if keyp("r") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:set(p, gem_rainbow)
		flags = cells:new_grid()
		matches = cells:new_grid()
	end
	if keyp("a") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:set(p, gem_air)
		flags = cells:new_grid()
		matches = cells:new_grid()
	end
	if keyp("m") then
		matches, flags = logic_find_matches(gems)
		if #matches > 0 then
			clock = 0.0
			return animating_cleared_gems()
		end
	end
	return waiting_for_input
end


function animating_cleared_gems()
	clock += 1.0 / 16.0
	if clock >= 1.0 then
		flags:foreachpos(function(p, _) flags:unflag(p, flag_new) end)
		return removing_cleared_gems
	end
	return animating_cleared_gems
end


function removing_cleared_gems()
	flags:foreachpos(
		function(p, flag)
			if flag != 0 then
				gems:del(p)
				flags:del(p)
			end
		end
	)
	return applying_gravity
end


function applying_gravity()
	local some_gems_are_falling = false
	gems:foreachpos(
		function(p, gem)
			local below = p + gravity
			local distance = 0
			while cells:get(below) and cells:get(below) & rock_mask == 0 do
				if not gems:get(below) then
					some_gems_are_falling = true
					distance += 1
				end
				below += gravity
			end
			if distance > 0 then
				local flag = flags:get(p) or 0
				flags:set(p, flag | (distance << 8))
			end
		end
	)
	if some_gems_are_falling then
		clock = 0.0
		return animating_falling_gems
	end
	return creating_missing_gems
end


function animating_falling_gems()
	clock += 1.0 / 16.0
	if clock >= 1.0 then
		local fell_gems = {}
		flags:foreachpos(
			function(p, flag)
				if flag & flag_falling_mask != 0 then
					local distance = (flag & flag_falling_mask) >> 8
					local new_pos = p + (distance * gravity)
					add(fell_gems, { gem = gems:get(p), pos = new_pos })
					gems:del(p)
					flags:del(p)
				end
			end
		)
		foreach(fell_gems,
			function(fell_gem)
				gems:set(fell_gem.pos, fell_gem.gem)
				flags:del(fell_gem.pos)
			end
		)
		return creating_missing_gems
	end
	return animating_falling_gems
end


-----------------------------------------------------------------------


function in_game:enter()
end


function in_game:update()
	if not substate then
		substate = creating_the_board
	end
	substate = substate()
end


function in_game:draw()
	if not cells then
		return
	end
	-- Display match counts
	cursor(4, 4, 7)
	foreach(
		matches,
		function(match)
			print(gem_names[match.colour]..": "..tostr(match.count))
		end
	)
	-- Draw the board
	gfx_draw_cells(cells)
	gfx_draw_gems(cells, gems, flags, clock, gravity)
	-- Update the cursor
	local mx, my = mouse()
	local cursor_pos = cells:pos(mx, my)
	if cells:get(cursor_pos) then
		window { cursor = "grab" }
		local matching = flags and flags:get(cursor_pos) or nil
--		if matching and matching != 0 then
--			rectfill(mx - 10, my - 16, mx + 12, my - 8, 7)
--			print(string.format("%02x", matching), mx - 4, my - 15, 0)
--		end
	else
		window { cursor = "" }
	end
	if false then
		rectfill(mx + 4 - 10, my + 10, mx + 36, my + 20, 7)
		print(tostr(cursor_pos.x)..","..tostr(cursor_pos.y), mx + 6 - 10, my + 12, 0)
	end
end
:: src/logic.lua
--[[pod_format="raw",created="2024-08-24 08:12:55",modified="2024-08-28 11:11:23",revision=1874]]
--- Match-3 Logic

local function random_gem()
	if rnd() < 0.05 then
		local gem = gem_rainbow + flr(rnd(6))
		if gem == gem_robot_E then
			gem += flr(rnd(4))
		end
		return gem
	end
	return gem_color_first + flr(rnd(gem_color_last - gem_color_first))
end


function logic_fill_gems(cells, gems, flags)
	local function fill_gem(p, cell)
		if (cell & cell_mask == 0) or (cell & rock_mask != 0) then
			return
		end
		local gem = gems:get(p)
		if not gem then
			gem = random_gem()
			gems:set(p, gem)
			flags:flag(p, flag_new)
		end
	end

	cells:foreachpos(fill_gem)
end


------------------------------------------------------------------------


local function logic_is_matching(gem1, gem2)
	if (not gem1) or (not gem2) then
		return false
	end
	
	-- Only colored gems can match.
	if (gem1 < gem_color_first) or (gem1 > gem_color_last) then
		return false
	end
	if (gem2 < gem_color_first) or (gem2 > gem_color_last) then
		return false
	end

	return (gem1 == gem2) or (gem1 == gem_rainbow)
		or (gem2 == gem_rainbow)
end


--------------------------------------------------------------------------


local function check_3_and_flag(gems, p0, p1, p2, flag, flags)
	local gem0 = gems:get(p0)
	local gem1 = gems:get(p1)
	local gem2 = gems:get(p2)
	if logic_is_matching(gem0, gem1)
		and logic_is_matching(gem0, gem2)
		and logic_is_matching(gem1, gem2)
	then
		flags:flag(p0, flag)
		flags:flag(p1, flag)
		flags:flag(p2, flag)
	end
end


local function check_4_and_flag(gems, p0, p1, p2, p3, flag, flags)
	local gem0 = gems:get(p0)
	local gem1 = gems:get(p1)
	local gem2 = gems:get(p2)
	local gem3 = gems:get(p3)
	if logic_is_matching(gem0, gem1)
		and logic_is_matching(gem0, gem2)
		and logic_is_matching(gem0, gem3)
		and logic_is_matching(gem1, gem2)
		and logic_is_matching(gem1, gem3)
		and logic_is_matching(gem2, gem3)
	then
		flags:flag(p0, flag)
		flags:flag(p1, flag)
		flags:flag(p2, flag)
		flags:flag(p3, flag)
	end
end


local function flag_sgrid_matches_at(gems, p0, flags)
	check_3_and_flag( gems,
		p0,
		p0 + pos(0, 1),
		p0 + pos(0, 2),
		flag_vertical, flags )
	check_3_and_flag( gems,
		p0,
		p0 + pos(1, 0),
		p0 + pos(2, 0),
		flag_horizontal, flags )
	local p1 = p0 + pos(1, 0)
	local p2 = p0 + pos(0, 1)
	local p3 = p0 + pos(1, 1)
	local gem0 = gems:get(p0)
	local gem1 = gems:get(p1)
	local gem2 = gems:get(p2)
	local gem3 = gems:get(p3)
	if logic_is_matching(gem0, gem1)
		and logic_is_matching(gem0, gem2)
		and logic_is_matching(gem0, gem3)
		and logic_is_matching(gem1, gem2)
		and logic_is_matching(gem1, gem3)
		and logic_is_matching(gem2, gem3)
	then
		flags:flag(p0, flag_square | flag_vertical | flag_horizontal)
		flags:flag(p1, flag_square | flag_vertical | flag_horizontal)
		flags:flag(p2, flag_square | flag_vertical | flag_horizontal)
		flags:flag(p3, flag_square | flag_vertical | flag_horizontal)
	end
end


local function flag_hgrid_matches_at(gems, p0, flags)
	check_3_and_flag( gems,
		p0,
		p0 + pos(0, 2),
		p0 + pos(0, 4),
		flag_vertical, flags )
	check_3_and_flag( gems,
		p0,
		p0 + pos(1, 1),
		p0 + pos(2, 2),
		flag_horizontal_SE, flags )
	check_3_and_flag( gems,
		p0,
		p0 + pos(1, -1),
		p0 + pos(2, -2),
		flag_horizontal_NE, flags )
	local p1 = p0 + pos(1, 1)
	local p2 = p0 + pos(1, -1)
	local p3 = p0 + pos(2, 0)
	local gem0 = gems:get(p0)
	local gem1 = gems:get(p1)
	local gem2 = gems:get(p2)
	local gem3 = gems:get(p3)
	if logic_is_matching(gem0, gem1)
		and logic_is_matching(gem0, gem2)
		and logic_is_matching(gem0, gem3)
		and logic_is_matching(gem1, gem2)
		and logic_is_matching(gem1, gem3)
		and logic_is_matching(gem2, gem3)
	then
		flags:flag(p0, flag_square | flag_vertical | flag_horizontal_NE | flag_horizontal_SE)
		flags:flag(p1, flag_square | flag_horizontal_NE | flag_horizontal_SE)
		flags:flag(p2, flag_square | flag_horizontal_NE | flag_horizontal_SE)
		flags:flag(p3, flag_square | flag_vertical | flag_horizontal_NE | flag_horizontal_SE)
	end
end


local function flag_all_matches(gems)
	local flags = gems:new_grid()
	if gems.is_square then
		gems:foreachpos(
			function(p, _gem)
				flag_sgrid_matches_at(gems, p, flags)
			end
		)
	elseif gems.is_hex then
		gems:foreachpos(
			function(p, _gem)
				flag_hgrid_matches_at(gems, p, flags)
			end
		)
	end
	return flags
end


---------------------------------------------------------------------------


local function count_this_match(gems, flags, p)
	-- A simple flood-fill algorithm to group all
	-- intersecting linear matches together.
	local colour = gem_rainbow
	local count = 0
	local remaining = { p }
	local rainbows = {}
	while #remaining > 0 do
		local current = deli(remaining)
		local gem = gems:get(current)
		local flag = flags:get(current)
		if (flag & flag_counted == 0)
			and logic_is_matching(colour, gem)
		then
			if gem == gem_rainbow then
				-- Rainbow gems can be part of multiple matches,
				-- so they need to be unflagged at the end.
				add(rainbows, current)
			else
				colour = gem
			end
			count += 1
			flags:flag(current, flag_counted)
			local neighbours = gems:neighbours(current)
			foreach(
				neighbours,
				function(n)
					local f = flags:get(n.position)
					if not f then
						return
					end
					if f and (f & flag_counted == 0)
						and (f & n.direction != 0)
					then
						add(remaining, n.position)
					end
				end
			)
		end
	end
	foreach(
		rainbows,
		function(p)
			flags:unflag(p, flag_counted)
		end
	)
	return { colour = colour, count = count }
end


function logic_find_matches(gems)
	local flags = flag_all_matches(gems)
	local matches = {}
	flags:foreachpos(
		function(p, flag)
			if (flag & flag_matching_mask != 0)
				and (flag & flag_counted == 0)
			then
				local count = count_this_match(gems, flags, p)
				if count.colour == gem_rainbow then
					-- Ignore, as this is probably a stray rainbow that was unflagged
					-- at the end of `count_this_match`.
					-- TODO: an edge case is when there is a legitime match of
					-- only rainbow gems (e.g. 3 rainbows surrounded by black things).
				else
					add(matches, count)
				end
			end
		end
	)
	return matches, flags
end
:: src/sgrid.lua
--[[pod_format="raw",created="2024-08-24 07:17:45",modified="2024-08-28 11:11:23",revision=1935]]
--- Square Grids

--- The origin of the grid, `pos(0, 0)`, is at the top left.


-- Local Constants --------------------------------------------------------


local max_width <const> = 12
local max_height <const> = 9


-- Constructors -----------------------------------------------------------


local metatable = {}


function metatable:new_grid()
	return sgrid_new()
end


function sgrid_new()
	local grid = { is_square = true }
	setmetatable(grid, { __index = metatable })
	return grid
end


function metatable:clone()
	local grid = self:new()
	self:foreachpos(function(p, item) self:set(p, item) end)
	return grid
end


function sgrid_new_cells(size)
	local grid = sgrid_new()
	local p = pos(0, 0)
	while p.x < size.x do
		while p.y < size.y do
			local cell = cell_good
			if rnd() < 0.0000033 then
				cell = cell_bad
			end
			if rnd() < 0.03 then
				if rnd() < 0.60 then
					cell |= rock_full
				elseif rnd() < 0.75 then
					cell |= rock_cracked
				else
					cell |= rock_broken
				end
			elseif rnd() < 0.005 then
				cell |= math.random(5, 5 + 5) << 4
			elseif rnd() < 0.005 then
				cell |= cell_door
			end
			grid:set(p, cell)
			p.y += 1
		end
		p.y = 0
		p.x += 1
	end
	grid:set(pos(size.x // 2 - 1, size.y // 2), nil)
	grid:set(pos(size.x // 2, size.y // 2), nil)
	return grid
end


-- Indexing --------------------------------------------------------------------


function metatable:get(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return nil
	end
	return self[p.x + (p.y * max_width)]
end


function metatable:set(p, value)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return nil
	end
	self[p.x + (p.y * max_width)] = value
end


function metatable:flag(p, flag)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return nil
	end
	local index = p.x + (p.y * max_width)
	if self[index] then
		self[index] |= flag
	else
		self[index] = flag
	end
end


function metatable:unflag(p, flag)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return nil
	end
	local index = p.x + (p.y * max_width)
	if self[index] then
		self[index] &= ~flag
	end
end


function metatable:del(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return nil
	end
	self[p.x + (p.y * max_width)] = nil
end


-- Screen Coordinates ---------------------------------------------------------


function metatable:coords_origin()
	return 124, 4
end


function metatable:coords_cell(p)
	local ox, oy = self:coords_origin()
	return ox + p.x * 29, oy + p.y * 29
end


function metatable:coords_gem(p)
	local ox, oy = self:coords_origin()
	return ox + p.x * 29, oy + p.y * 29
end


function metatable:pos(x, y)
	local ox, oy = self:coords_origin()
	return pos((x - ox) // 29, (y - oy) // 29)
end


-- Iterating -------------------------------------------------------


function metatable:foreachpos(func)
	local p = pos(0, 0)
	while p.x < max_width do
		while p.y < max_height do
			local item = self:get(p)
			if item then
				func(p, item)
			end
			p.y += 1
		end
		p.y = 0
		p.x += 1
	end
end	


function metatable:neighbours(p)
	return {
		{ position = p + pos(1, 0), direction = flag_horizontal },
		{ position = p + pos(0, 1), direction = flag_vertical },
		{ position = p + pos(-1, 0), direction = flag_horizontal },
		{ position = p + pos(0, -1), direction = flag_vertical },
	}
end

:: src/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTI0IDA3OjE3OjA5Iixtb2RpZmllZD0iMjAyNC0w
OC0yOCAxMToxMToyNCJdXQ==
:: debug.lua
--[[pod_format="raw",created="2024-08-24 12:45:09",modified="2024-08-25 08:41:10",revision=71]]
-- Detect uninitialized globals and typos
-- from @snowkittykira from the BBS


-- if you're using include(), include this after including everything else,
-- since most included modules will need to assign global variables on load

-- these globals are needed by picotron
_init = _init or false
_draw = _draw or false
_update = _update or false
-- these are used by the picotron terminal
cproj_draw = cproj_draw or false
cproj_update = cproj_update or false
_ = _ or false
_is_terminal_command = _is_terminal_command or false
k = k or false
res = res or false
-- gui needs these
drag_t = drag_t or false

local function unknown_variable (t, k)
  error (debug.traceback ('unknown variable ' .. tostring (k), 2))
end

setmetatable (_G, {
  __index = unknown_variable,
  __newindex = unknown_variable,
})
:: drakma.lua
--[[pod_format="raw",created="2024-04-07 07:42:45",modified="2024-08-24 12:51:02",revision=1288]]
_modules = {}

-- A 'require' function similar to standard Lua.
-- Idea from elgopher on the BBS
function require(name)
	local cached = _modules[name]
	if (cached) return cached

	local filename = fullpath(name .. '.lua')
	local src = fetch(filename) 

	if (type(src) != "string") panic("could not include " .. filename)

	-- https://www.lua.org/manual/5.4/manual.html#pdf-load
	-- chunk name (for error reporting)
	-- mode ("t" for text only -- no binary chunk loading)
	-- _ENV upvalue
	-- @ is a special character that tells debugger the string is a filename
	local func, err = load(src, "@" .. filename, "t", _ENV)
	if (not func) panic("Syntax error:", tostr(err))

	local module = func()
	_modules[name] = module

	return module
end


function panic(...)
	local args = { ... }
	foreach(
		args,
		function(str)
			send_message(3, { event = "report_error", content = str })
		end
	)
	stop()
end


-- Table utility functions --------------------------------------------------------


function table_deep_copy(t, already)
	if (not already) already = {}
	if type(t) == "table" then
		if already and already[t] then
			return already[t]
		end
		local new = {}
		already[t] = new
		for k, v in pairs(t) do
			new[k] = table_deep_copy(v, already)
		end
		return new
	else
		return t
	end
end


function tostrrec(t)
	if type(t) != "table" then
		return tostr(t)
	end
	
	local s = nil
	for k, v in pairs(t) do
		if not(s) then
			s = "{ "
		else
			s ..= ", "
		end
		s ..= tostr(k) .. " = " .. tostrrec(v)
	end
	s ..= " }"

	return s
end


-- Pos --------------------------------------------------------------------------


function pos(x, y)
	local p = userdata("i16", 2)
	p.x = x
	p.y = y
	return p
end


-- Drawing -------------------------------------------------------------------------


-- From Sophie on the discord
function get_drawspace()
    return {
        cam_x=peek4(0x5510),
        cam_y=peek4(0x5514),
        clip_l=peek2(0x5528),
        clip_t=peek2(0x552a),
        clip_r=peek2(0x552c),
        clip_b=peek2(0x552e),
    }
end


function set_drawspace(drawspace)
    poke4(0x5510,drawspace.cam_x)
    poke4(0x5514,drawspace.cam_y)
    poke2(0x5528,drawspace.clip_l)
    poke2(0x552a,drawspace.clip_t)
    poke2(0x552c,drawspace.clip_r)
    poke2(0x552e,drawspace.clip_b)
end

:: main.lua
--[[pod_format="raw",created="2024-03-30 05:39:34",modified="2024-08-28 11:11:23",revision=1997]]
include "drakma.lua"
include "src/constants.lua"
include "src/sgrid.lua"
include "src/hgrid.lua"
include "src/gfx.lua"
include "src/logic.lua"
include "src/in_game.lua"
include "debug.lua"


local state = in_game


function _init()
	window { cursor = "" }
	fetch("pal/0.pal"):poke(0x5000)
	state:enter()
end


function _update()
	state:update()
end


function _draw()
	cls(63)
	rectfill(0, 0, 116, 269, 55)
	state:draw()
end
:: .info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTIzIDE4OjQ1OjEzIixtb2RpZmllZD0iMjAyNC0w
OC0yOCAxMToxMToyNCIscnVudGltZT0xMCxzdG9yZWQ9IjIwMjQtMDMtMzAgMDY6NTQ6MjQiLHdv
cmtzcGFjZXM9e3tsb2NhdGlvbj0ibWFpbi5sdWEjMjkiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9j
YXRpb249InNyYy9pbl9nYW1lLmx1YSM2MCIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0i
c3JjL2xvZ2ljLmx1YSM2OSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ic3JjL2dmeC5s
dWEjODciLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InNyYy9zZ3JpZC5sdWEjMTE1Iix3
b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJzcmMvaGdyaWQubHVhIzEyNCIsd29ya3NwYWNl
X2luZGV4PTF9LHtsb2NhdGlvbj0ic3JjL2NvbnN0YW50cy5sdWEjNzMiLHdvcmtzcGFjZV9pbmRl
eD0xfSx7bG9jYXRpb249ImdmeC8wLmdmeCIsd29ya3NwYWNlX2luZGV4PTJ9LHtsb2NhdGlvbj0i
bWFwLzAubWFwIix3b3Jrc3BhY2VfaW5kZXg9M30se2xvY2F0aW9uPSJzZngvMC5zZngiLHdvcmtz
cGFjZV9pbmRleD00fSx7bG9jYXRpb249InBhbC8wLnBhbCIsd29ya3NwYWNlX2luZGV4PTd9fV1d
:: [eoc]
