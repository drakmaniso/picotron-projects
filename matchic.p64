picotron cartridge // www.picotron.net
version 2

:: docs/
:: docs/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTI2IDE0OjAzOjI1Iixtb2RpZmllZD0iMjAyNC0w
OS0xMiAyMDo0MjoyNiJdXQ==
:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNC0w
OS0xMiAyMDo0MjoyNiIscmV2aXNpb249NDI4M11dbHo0AJAeAACmbAAA8xd7WzBdPXtibXA9cHh1
AEMgHR0E8P---zwsZmxhZ3M9MCxwYW5feAgAy3k9MCx6b29tPTh9LDQA8CQ1bPAEHGob8AAcugnA
DNoJCKAMKh8qqgkIgAwqLqoZCHAMKh4ZShk6CQgPNVAMSgkcCSoEAPAMGQhQDDoJPAkKCTwJGhkI
DTAMSglMCUwJGikICwAQrAkAgQ0gDFoJjAkqCgBVaglsCToUACwaOQoAEDxNAMBJCA0wC1oJHAkK
CRwaAP8oHTALahkqGRpJCA1Q6kkIHVAZqmkIDXAIGWp5CB2ACOkIHaAYqRgdwA0YaRgt8AANaC3w
BG3wFwQBHvEQbxHwBB5vDx8Q8AAevw8PDsAO3w8PDg8NoA4vDx8qrwwA0YAOLw8vKq8PHw4PDXAY
AFEfDy8OfxwAMQ81UAoA8AEeDW8PHQ8NUA6PDw0eDVwdGgD0BzAOnA0uDUwtDw0wDowNPg1MLQsP
NSALAGUKIA58DU4KAEw_DUw9CgDALg1MTQsKMA8QfA0eFQD-KBowCYwNHg0sTQsKUJwtHE0LGlAd
rG0LCnALHWx9CxqAC_0LGqAbrRsawAobbRsq8AAKayrwBGoXASEQFhcBMBQfFRcB8QMUDxPADt8U
DxMPEqAOLxQfKq8MANGADi8ULyqvFB8TDxJwGAARzxgAARMBQRRPE18aALBQDm8UDxNODU8UHRsA
8gMwDm8UDW4NPC0PEjAOXA2ODSwVAQMLABwKCgAqHD0KAFFsDW4NHBUBYRVsDU4NLBUBIXxNEwEf
7BEBSRAbEQEwGR8aEQHxAxkPGMAO3xkPGA8XoA4vGR8qrwwA0YAOLxkvKq8ZHxgPF3AYAFEvGS8Y
bxwAARUB4BkPGC4NXxkdDxdQDm8Z-QEQHRoAEzAJApwPFzAObB1OHTwTAVVMDa4NHAoAKgw9CgCR
XA0uDQ4NLg0MFwFjGlw9Dj0cLAIwDg08GQE-jC0sGwFJECAbATAeHx8bAfEDHg8dwA7fHg8dDxyg
Di8eHyqvDADxAoAOLx4vKi8eDx1vHh8dDxxwHABRPx4PHX8gAAAfARGfDgAAHgChUA6PHg8dDg1v
HhsAsDAOnx4NDg1sLQ8cUwMACgADSQMxLg1cFwEGCgAASgEuPD0KABEsHQEXHzQCTw0uDSwdAVAQ
JR0BMCMfJB0B8QMjDyLADt8jDyIPIaAOLyMfKq8MANGADi8jLyqvIx8iDyFwGAARzxgAATQCQSM-
Im8aALBQDm8jDyIuDW8jHRsAwTAObyMNLg18LQ8hMAMCFIw2AkQuDTwdQQNVLg0sDQ5PAz8_LR5R
AwgfJFEDWxAqGQEwKB8pGQHwBSgPNMAO3ygPNA85oA4vKB4dLw9dDQDyA4AOLS4NTw9NHzQPOXAO
LR4dTxgAABoBkD0qDU8PDS8UHR0AwVAOLUoNLw8NTxQNHyAANDAOPREA0i80DzkwDj1aDQ8PDV8P
AAApAWRNSi1PFB0OACX9BBgAc08jLU8ZDT8PAJU9XyMNDx4NXxkRAHNPIw0vHg1PEQBEMA8pLRIA
AEMAEB8SAIM9LyMNTx4NLyQAYVB9Tx4dTx0AcVAfNF1PHm8XAHFwDzkfNE0vDgBhHzWADznvCQD-
C6AfOa80HzkfNcAMHzlvNB85LPAADGss8ARsZwEf8A1PPxJAPuAODxYfKg8VDiAOHyofFg7QDg8q
PxUuBQBADg81wB4ApBQfFS8WHxUfFA8TANUPFQ8UDxNPFQ8TDxQfKAABFQARLxUAEC8VADGQPyw_
AFATLxUfEz4A-AYeHytgDyw-LS8VXy0-LB8VHywPK1ARAD8PNUATACXzAFBPLC8TTywvKx8TLysf
NVsANU8tLyIAH2ATAITvcD8rLn0eHR81gPwD8C7JAR3yPDkvKxAPD-AGDysgHvAFTyzwBw0-LQ0O
8AYNDD0ODzXwAx1sHfABDawN4A28HcANLB8qjA0OoA0sK4wdDpANLBucHQ4PNXAN-AAtDgYAKwpg
BwAm7D0GAP8a3E0OCnANvE0OGnANrF0OCpAdbG0OGqAOzQ4awA6tDhrgHm0eGvABCm79AyPwBU0P
LOAOoA4PLQ7ADg0OkA4dDqAOoABAgA4tDgQA0QyADg0PKx0OYA4dCw0OAFIbHW4dGwsAMyuNKxQA
Eq0SACr9AQYAkHAOLS5tLi0OcFQA8QkaDyoLDk0OCgsPGg4dDgxgDh0OCRsJDi0GAAERADMtDikE
AIAMYA49Lk0uPQkAIP0DSQD-Im0vCW0OHEBbXQhdW3AOPQ4dDh0OPQ4cgDstHg0eLTtwGyAOrQ4c
ABuwHm0eHPABDG6mAyPwAosPK2AO8AQeQB7wBA4PLE4NDQDwMU0e0C4gDm0OIC4PNUAeLR4ADg0f
Dw0cDQ4AHi0eIA5tHgwPKg4MCw4MHm0OEA59DgweDB4MDn0ODzUADn0ODRwrAPAJfQ4KAA6NDk0O
jQ4KAD5tDi0ObT4KAA4a3wDwBhoOChAKAD7NPgoQCjAOGg4tDk0OLRYA8AZwCgBOTU4KEAqQDioO
TQ4qDgrQCiAbAP8CIArwAw4NDhrwCQ4a8AsK8HHoAB0gGg8KA3As8AoPKw8WFAMi8AkSACAPNRQA
ER8GAEEPNfALBgDwBATvK8AO7y0OoA4N-ywADpAODfwGAPAOHD5MPhwODzVgLgwODw0fDw8NDiwO
Cx8PCw4MLkDTAfAFDgofEAoOLA4KGQoODA4dDjAODQwWABYZFQAAQACxIA4cDgwOCxoLDiwGAAAW
ABAIFQACYQDwAhwOCDAu-AEuGEAIDvwBDihgBgBgCIAOPI48BwBSLA6NDiwJAFUNDkwODA0AEHwK
ADCQDhwKAK8cDhig7hjA6PAwKgEpHxIqARZQsA4N3yyWBQUyARcMLQFVPA4sDjwlAQMOAAUgATBe
LF4CARILFwEgDxyICQAwASIfHTEBGAsbARELGwEwG0ALFQERKxsBEgsbARQLGwEYCxsBFQsbARUL
GwFvG6DuG8DrGwEfoC8fK6AusA4fLR4SCPALkA4fLB0eQA48HR5gDkwdHhAOHA8NDw8PDRwWAPIE
bB0eLA8PDxAPDzwdDiAOnB0eDB4AoVwOIA4sHmwdHnwwA-ECHB4LDiwePB0eXA4LAC4rDgwQAKMM
HR48DgsQKxAeEgByHS4MDgtwGxAA8QUMDi0eC8AbEB4bDjwNDgvwAhsADhwB4PABHhAOTA4LsB4g
Dg0e-wAhG2ALAHIADkwuGxAuCwCSDB0eLB47IA4dDABAXB4rYAgA-xiMHiuADrweK7AOjB4r0A5s
HivwAQ48HivwAw4cHivwBh4r8Akb8CI1AR2wFh8rYB7wAB4PLQ48CYEPLR6wHh0PLA0A8BANHywe
cB4dHA4fNWAOPB5ADh08DgtwDlwOMA5MDhuAywDQMA48PkA_PA4bMA5MHQ8AUB1MDgtQHwAQQAUA
I1AODwAhC3DuAAAFAGFwDiw_ID7xAfADLB0OCxAOHSwOG5AOPA4bIA48FgABtwMQMCsAEICBAhAc
TAAQHCoCgA0sDgw_AD4MRAATDbABcQ4cHQ4LDh0gABIc0gEBMwAAcwEkG4D0AQATACALEAUAYKAO
XA4cLmUCQA5cDgzcBaAOC8AOXA4NPA4bCAABqQEw4A5MtAAw4A5chgCP8ACeG-ACm7BbAR3QMi8r
oB6gHi8tDnAeHQQAQD8sDkBPAQC3BRQdjgKiDhAeHUwOMA4dPL4AQSweHWyFBBNcuwCwHh2cDiAO
fB4dbB6XAfEEEA5cHh08HiwOCx4cDhAOPB4dDA0AxQwOCwALLgsADgwuHRAAlR4LICsAHi0ODA8A
IRtg6wAACgARsO0A8QogG-ABDkwOEB7wAw4sDgweDQ4gHuAuTA4ACgByoBseLB4dDA4AUi5wCx5c
DgBwHQ4LgAsejA0AsBugCx68DgvQCx6MLAHgCx5sDgvwAwsePA4b8AWlAL8L8AgLHhvwChvwEUMB
HfIGGp8r8AIOLy0OXQ7wAA4NPywOTA7wTgMgXA6mATFcDtAwAjAMDlwzCCAMLhkAELA3AiAvNbAE
BGUBEKATAAA9AQAUAAFoARAcBgUwLA4ABQAEJgBwkA4NPg81PgQFACMFQQ47ABtsAGCgDg0cDkAF
ABAMDAABnwIgDSxoAFI8DiAODbYCYBw_CxA_LDkAUBwOOyAbxQIQcBwAAXEBAQoAJAtQBgAQXE4A
sVwOUA4NLD4LMD48UQBgPA47QBsODAJADUwOgAUAQQswHjxGAHAsHhtACx4sTABBHB4rcN4B-wNQ
Dg0eK7ALHgtQHivwABtgG3BuCX0x-QMOBQABXQkQzV0GdGAOLU4tTi1ICQVOCRIpTQkfCU0JRl8Q
EATw8DEACx8yMQD--0hfHR0E-zeJFw8dMTUAHzg1ACFfOw3-PA0GAD4PhgAdBzsADwYAOA_GAAwP
pwEdHDa3AE8POw88BAAhFx8MAA84AP-------wcvDzuJBh0HOwAPBAAZFx8MAA84AP-------wcv
DzyJBhxxjzwPPQ87rwYAEU8GADL-PAAHABABBwARzxQAF38gABEfBgAXjwwAF_8GAAIwACRfPDQA
ES8GABUPNAATL2QAFgRXABcfKQAEgwAQBwcAF98TABGfBgARPwYAGL8lABdvJQAmXzxWADb-PBIN
ACw-PCsAHR8YADb-PAgNABOfEwAWAiwAF38_AAN8AAVdACc7TyMAEx8jABYWEwAXf7gACBIAF886
AQIkARnfQwAWE5IACKsAD_QBGfEmIyAEcP82A_D_BdD_BcD_B7D_B6D_CZD_CYD_C3D_C2D_DVD_
DUD_DzD_DyD_ERD_EQD_NgAJABEgFQARQCEAEWAtABGAOQARoEUAEcBRAD-g-gOXFAweNY4AHzeO
AHofOI4AevMzOwPg-zwF0P87BcD-PAew-zsHoP88CZD-OwmA-zwLcP87C2D-PA1Q-zsNQP88DzD-
Ow8g-zwREP87EQD-PBP-OxMADwATIB8AE0AvABNgPwATgE8AE6BfABPAbwA-4P88rwAODoARDzEA
ewBCAQQ9AxOfSQMg4G4IADC_0C4HABCOBQDwAE7A-gYPPbANDzv_AA0MLvIBoE4NDD4NDI4NDA76
AfEFLg0M-gZgng0MXg0MLg0MPlAM-gsHAsE_DQzuDQx_IA4NDM4vAPIAPhCeDQz_Ag0MDgAM-gQN
BAAQAzYAEABFAEIMEP4AWgBRIAxuDQxvAAM3AkG_DQx_XgARYG4AEHAcABCORAIBQACRHg2gXg0M
7rAOJgAhnsA6AM-QXg0MzuCuDQxODXCvExzwE-AVvzQPMdDfNC8xoN80TzGAXzRfMg8xDzAPNF8x
YE80fzILAPAJLzJPMUBPNI8yDzFPMk8xMD80-zIBPzEgCABBAz8xEAgAvx8xHzAQLzT-MgUvCAAZ
cS8yDzH-MgEMAHIfMQ8w-zICDAAyMA80DAAQHxgAAAwAUD8wED8xcgAgMCAIAPEOAT8wME8xfzIP
MV8yTzBATzFvMh8xPzJPMGBfMT-FAP8GLzJfMIBPMd8woC8x3zDQDzG-MPAVCAccAyIBUJ80DzIv
JgEADgAfDyoBEEIwDzQ-LAERnw0AIU8yMQFhvzIPMF8yNAERrz8AED8eABMyPQFgDzIPMY8y_wAA
vQABXgAkMi8ZABJ-EQBgNB8yDzAvCgASMSkBAfgAAn0AEC92AAEVABAyWgAAVgAAFwAgDzASAAIu
ACMyH28ARR80nzKCAVQvMB80vyIAAGcAQR80LzARACEPNA8AEjHEAEUPMK8ynwEUXw8AAqIBoW8y
DzBPMg8xPzKpATF-Mh-EACFPMrABACABEy8eABEwrAESMP8AAbsBAEsBUh8wHzEfvwE-DzI-vwE2
ACIBEHCiAGCgTzQvMUDFAeCAXzQvMTAvNE8xYG80L5cBAHEAIVBP6wAQD_oBcDEQHzQ-Mj_-AQBL
AQFFAVQxDzAAH8gBAssAEh8SAABPATAgLzS6AUEADzQf5ABBIC80fysBIDEf8gAAgQAANAAAhwGS
MB8xTzBADzQ-xQHwUjIvMEBOYD8xLzI_8AMvMV5APzSAHQAfMU4wXRxQHQ8yDBAuQF1MMAwbDpA9
G1wgDB4QLRwgPUs8YC0bHBAtaxweQC0rLAAdWwwbLkAtOxwAHUsMKy4wLRsMGywADQwrDA4OAP8e
CwwNKwwOACw7DAs_MB0cDTseADwrTlA8Ky4ALI5gHF4gDI6AbjB_sC6ALvATZAEd8QU2TzTwAy4A
Dk8zDzIALsAOLzMPMg0AcA4vMw6wDj0FAvAHDzFNoAw9DzIMQwwLPQxwHg0MDRuDG9IE8AZAHi0c
MwUUBQQTHA4dGzAOPQsjFAUCAKIDCz0LMA4tCyMFEAC1BAMtCwwwDCsMEwQSAFQrHEAsIw8AYxQD
LFAuEwwAdwUUAy5ADi0PAGMOLTAOHQsRABAfEgBDLQswLREAwgoPKhoUAx0bMAsdDBIAgjoDBAMr
DEAsDgBHBRoTBF8ALwQTXwACCBAAGj0PACctC34AC30AAAIAAHwAEyt7AAACAAF8AK--MAEscP81
BPARlAEd8BGELzT1AS5ADg8qDg8y9QEuDTAuDfQBLg0gLg31Ay4NEBkAgA30Aw4MDg0QBQAxZE5k
DABwLg1UXg1ULgkA8AB_Kw4Njg0QrgsMDwwPCgkMAPAPnQ4LDwwfCgmtIC1TDgsqCQ1TLTAeDVQe
KQ4NVB4NCwATXgkAMWRNZAgAJvQDBwAi-ggEAHEO-QhA-zAH2QAfS9kAYSUvENoAVBEPDw8O2wBS
ER8PDw7cABAvFwAD3gAfKt4AnBUV3gAQFp4rBN4AUxYfFA8T3gAAFwAP3gCkIxod3QBUGw8ZDxjd
AFMbHxkPGN0AABcABN0AEx3cAC8eTdwAkRQf3ABUIA8eDx3cAFMgHx4PHdwAABcAD9wAoxQk3ABU
JQ8jDyLcAFMlHyMPItwAABcAD9wAXgvgCVZvNA8xP_QJAA4JAvwHAegJQB80DzIaCADJBwIVAAHy
CQBkCCRfMicJEz-NCBAwWAgAxwgyLzEvFwARMDwIER8qAEQ-MC80-wkBEAoAGwgBHQAdMRYKEB_t
CA8YCgIBcQAfbxoKASAfNIYADRwKAdAJASoABCAKER9fAB4fIAoAOQoCzgAJKAoRP8MKAxUABi4K
AZgAA1cADzgKAALSADQvMU8_ChFPOgAAXgA2PzAfRgozPzIvFwAAVwAANAABTgpiHzIfMV8wbgAB
dQEAVApXLzBPNA8VAAFaCgGRCRYwKAADXgovPzBcCjsOhA4PMQDQ8AgjEwQgDxb-FQxADxb-FA4g
DxYvFP8wCU4GEBAMAEYPMG8nBAAAFwBWAA8WPxUTAAAEAHA-FQ8TDxY-LQAWKAQAED8qOAIsAAgW
AB8VFgAIAEIAFikEAAFCAB8VFgACHxYWAAgIWAAGQgAMFgAPLAAJCNwAAfMAHxUKAQE1EA8VLQGv
IP8UDg8TQP4NIH4BGZMFBwQAJwAHIBcCAE8HACcADCcZwQUHBBAHIBcQBwAHMAIALxBHPwAcAX8A
QgcwByACAA8-ACU-EBdAvgAkETBAAK8ABwAHEAcARyAHQgAdb1cwN0AHMH0AIyAXEH0AETeBAQ9A
ACASRzcBAsIAHyA6ASECdwAOfwAPQgAbEDeCAD8QFxBAABn-AgcLBAA-KhBeAB4fOh4NHg0ABQAD
f14NAD4dED2bAAwsMTRcAMEQHyowLg86ED4NIA3eBwUDAH8QXgBeDQBdUQAdB60AQAAdAB6oCEEQ
Lh0AAwAPUwA1nx4dIC5AHg0eEPgAKmBAHg86IC5OAHAQLg0eAB4dTgBBXg0ALf8AL0AdUwAdwl8q
AF4POh5NThBeEEQABaEALwBNoQAf4C8qID4POgAuLQAeHSBOAQEfHewBLAKhAADgAAX3AAUGABAg
8gAfIJoBKAGaAD8APh2oADAMVgBxXg0ATg0QHbcAAE0BXy4dIC0QVQAa8QEKEAQQTyowbhCOAC4v
Oi4NFwsPBQAQr44NAG4dEE4dME1wAAwcOW8A-wMgLypQPg86ME4NIF4NMB0uDVADAAFAII4AjmUA
H41eABwOzQDHAC0QLg1APg0wPh0gAwAfMGEAMQFcACBQLlwAcTA_DUBOUA0PAC8uICEBKYEQLypg
Lg86ULYAQUAuHUAJACEALioEBH4BAbwAEU1uAF9QLg1gLWQAHPUEjyoAjg86jg0ubS4NUG4gfhCO
EE0AD74AK-EFIE8qMF4POhBuDQBOPQA_HTAuHUBhADMALi2_AAPDAA9iACUEvAAnAD0fAQ8JAAU-
YC0wQgIuAQUAfwBuHQBuDQDHADcPaAAEoY4NAH4NEG4NIC3GAFAwTg0QXmEAbyA_HUA9IGQAGf4G
XggEEP86SiAO-ztKDz0ADv87TA8_BgAwAA89IQBMPiD9SsMAsS0yMy4zMTkwNDc2BgADbgCSLTAu
NzE0Mjg1BgAiNjh_AApZBNBmHATwWPVSIAX0UgMQBQAwDzoABwAfDgYAa3wQ81IeIP5SegVTMjYu
NzXfAB8zlxoBAM8A77-0UiAE81IPOxAE81IOBQBbD7QAIbARDgQQDxavFTAPFh1FEiAHAFIQDxbf
FQQNMRRfDjIMEjoTAIMPOk8VXw4-FRIAAhoAFxUmABIVFAAwAA8VSQAUHwkArw86IL8THzowvhA5
DBlfEQ4E8AOfABETABIABJ0AEgCcABYAmwASAJoAEhCPABIgBwA-ML4gjwAcDy0BA0BPFT8OYEAB
kgBRHw4fFB90AAAjATN-FR8vAQAKACJPFRYAWV8UHw5fMQEmDxUUAA89AU0PrwAEFgCuABQArQAW
AKwAA0IBFgCqAA9NASrBBAQEAB87AA4fOg89BQA-AB0AQAALHzEFECyhFwsE8AEfO4BOUHAA-ylQ
Hk86LiAOHQ89QA6dDiAcQA69HjA_HVxtPh08UAytDFAeIBx9DFAOHQwwHD0cYA4dDFA8kBzwAHMA
HFIwHzvwBHEAIU5wCADwDiAuTzoeYB89IA6fOg4QLjAevQ4ADz0dPm1cHQ4AeQDwAiwQDH0cIB5w
HD0cMA4dDIA8hQBP8AQcQCQRHg8xAP--mPBJKCgE-z8WAv4FAv4uBv4dAk4C7gL_FAb_Bgb_BwL_
DQL_AwL_AgIGAo4G-gwCTgL_MAL_IgJeAt4G-lEG-gECPgL_EgLuAo4CPgJuAgYC-hMSBg8yBhL_
Ew0A8AMWAv4XAv4MAv4QAv4qAv5jBr5CABAQGwCBBwLeAv4RAv4mAAIrABADTQD-AD0GTgL_IwLu
Al4Cngb_JLMjGcIoKASvPwL_CgIOBu5WAGBuAj4G-gkTACE_AggAAOEAARoAEK4VAACaAEISAv43
EwAgfgbuABEGAQEzzgIelQDAIgL_AQL_AwZeBv5QowARLrMAYAgC-h0G3l4AMEcGviYBEn4vAIEu
Ak4GLgL_HjkBEDF2AJIABv4gAv4uAi5gAGEGAv4OBm56AB8B3AAc4W8-Bv4xAo4GjgL_GQZ_sQEg
VwaKADIIAl7CAACwABAUOQEFDwCwjgL_QQK_Av4TAr7BAUBVBv4LIwADHQFC-gUCfrYBQRYC-iDp
ABELmwAxDAJOAQKBWwb_IQY_Aj4YAOEFAv4SBv4PAv4LBm4Cng0AHyDDABwgjz9cABEuHgEQArYA
cEQCfgaOAs5bAgKzABEIewFQ-jQC-gRpACH_BLgBQQYC-hwSAAKxARAtRQFB-gIGrrMCQAIC-htP
ADG_Ar4qABAAqwAwBgLeTwBSBQKOAi6SAhIeeQIxrgJOSgAwFwJ_xAEQrgcBEB3hAQDaAHEFBv4l
Bv4G9gEQBAQBEAq0AR_u5gAcYP8-CwL_b2AAMSIGnpMAExZkAUECBv4e0QARMBYCEBJzAXDuAv4z
Bv6DqwEQBb0AASoAQa4C-k4QAGAMAq4G-idHAjN_Ar5GABA0iAIASQDPLAL_DgL_UQL_HwaOpAAe
E2yhAjABAp5zAxgWvQMQAdoDMQYCvqwAEAuOAEFCBv4OMwMQAS8BQK4G-pGxACQMAnABIf4zGgRQ
DAL_OgYSABUWPwAQNq4AQb4C-lJjAk8tAv4uqwAeEBmJAQK3AUEiAv4GpQFQBQL_DwYIAVEdAm4C
rtgDEDtnAFIRAj4CBmYEAMcAEDoUAAEiAhBuUAQQLisAEQLMABEtgAERDFYAERymAUEJAv4EIQMQ
BGQBMB4Czo8CAnMBUAwGzgKOdQMxRAJeUABPDQL_GsgAHkI3Bv4JPAMxEAK_QQMQBswDAWEDQQMG
-lx0AwH1ASH_BR0FEAEnABMWhAAArQMEDQAR3qgAEkbWA0AEAv4ygQEEkQESBAMEFQguAFH_HwL_
JkcCECDEABACQwRPKwL_HsEADA_JBh4PMQD-------------------------------9RUG09Nn19
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNC0w
OS0xMiAyMDo0MjoyNiIsc3RvcmVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Il1d
:: map/
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNC0w
OS0wMSAwNzozNDozNSIscmV2aXNpb249MzA3NV1dbHo0AMEAAABZEAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD-------_x0zIwMDAzMDAwNDAwMDYMAC81MIAAWxMxCAATNYAALzYw
AQBbFzb8ABMxDAAPAQBVBHwBAAABEzAMAA_AAVkTMXQAEzB4ABcxjAAPAAFVEzaEAAQMAC81MAEA
--------nvEJIiksaGlkZGVuPWZhbHNlLHBhbl94PTQ3CQDSeT0wLHRpbGVfaD0yOQoAEHcKAIB6
b29tPTF9fQ==
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNC0w
OS0xMiAyMDo0MjoyNiIsc3RvcmVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Il1d
:: pal/
:: pal/0.pal
b64$LS1bW3BvZCxiZ19jb2xvcj0wLGJsYWNrZXN0X2NvbG9yPTAsY3JlYXRlZD0iMjAyNC0wOC0y
MyAxODo1OTowOSIsaGlkZGVuPXtbMF09dHJ1ZSx0cnVlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLHRydWUsdHJ1ZSx0cnVlLGZhbHNlLHRydWUsdHJ1ZSxmYWxzZSxmYWxzZSxmYWxzZSxm
YWxzZSxmYWxzZSx0cnVlLHRydWUsZmFsc2UsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSxmYWxzZSx0cnVl
LHRydWUsdHJ1ZSx0cnVlLGZhbHNlLHRydWUsdHJ1ZSx0cnVlLHRydWUsZmFsc2UsdHJ1ZSx0cnVl
LHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0
cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSxmYWxzZSxmYWxzZSxm
YWxzZSxmYWxzZSxmYWxzZSxmYWxzZX0saGlkZGVuX3RvZ2dsZXM9e1swXT10cnVlLHRydWUsdHJ1
ZSx0cnVlfSxpY29uPXVzZXJkYXRhKCJ1OCIsMTYsMTYsIjAwMDEwMTAxMDEwMTAxMDEwMTAxMDEw
MDAwMDAwMDAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNjAxMDAwMDAwMDAwMDAxMDcwNzA3MDcwNzA3
MDcwNzA2MDYwMTAwMDAwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDYwNjA2MDEwMDAwMDAwMTA3MDcw
NzA3MDcwNzA3MDcwNjA2MDYwNjAxMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAw
MDEwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwMTAwMDAwMTA3MDcwNjA2MDEwMTBkMGQwMTAxMDcw
NzAxMDAwMDAxMDcwNzA2MDYwMTAxMGQwZDAxMDEwNzA3MDEwMDAwMDEwNzA3MDEwMTA3MDcwNjA2
MGQwZDA3MDcwMTAwMDAwMTA3MDcwMTAxMDcwNzA2MDYwZDBkMDcwNzAxMDAwMDAxMDcwNzBkMGQw
MTAxMGQwZDA2MDYwNzA3MDEwMDAwMDEwNzA3MGQwZDAxMDEwZDBkMDYwNjA3MDcwMTAwMDAwMTA3
MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzAxMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEw
MDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAwIiksbG9ja2VkPXtbMF09ZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2V9LG1vZGlmaWVkPSIyMDI0LTA5LTEyIDIw
OjQyOjI2Iixva3BhbF92ZXJzaW9uPSIxLjAuMyIscmV2aXNpb249Mzk3MSx0ZXN0X2N1YmVfY29s
b3JzPXtbMF09ezE1LDMxLDR9LHszMSw0LDIwfSx7NCwyMCwyMX0sezEwLDksMjV9LHs5LDI1LDI0
fSx7OCwyNCwyfSx7MjYsMTEsMjd9LHsxMSwyNywzfSx7MjcsMywxOX0sezI4LDE3LDE5fSx7Mjgs
MTIsMTZ9LHsxMiwxNiwxfSx7NiwyOSwxM30sezI5LDEzLDE4fSx7MTMsMTgsMX0sezcsMjMsMTR9
LHsyMywxNCwxM30sezE0LDMwLDE4fSx7Nyw2LDIyfSx7NiwyMiw1fSx7MjIsNSwyMX0sezEsMSwx
fSx7MSwxLDF9LHsxLDEsMX19LHdoaXRlc3RfY29sb3I9N11dbHo0APABAAAVAgAA-QV1c2VyZGF0
YSgiaTMyIiw2NCwiMAEA8A00YzM2NWEwMDgyM2YzODAwOTg0NzNmMDA5ZjUxCACRNjQ0ODc3MDBm
AQDwODAwNzQxZjY1MDBhODI1OTIwMGUyNDliYTAwZWY4M2M1MDBmOGJiZDkwMDc3MmMxNjAwYTIz
MjE5MDBkNTRmMjEwMGYzODI1UADwJGNiYzljMDA2NzQ5MTMwMDljNzExYTAwZDZhMjI1MDBlZGM0
NTQwMGZiZTE5OTAwMmQ1MxgA8BYzMTZlMzIwMDUwYTMyYzAwODdkNDU2MDBiZmYyOTUwMDE2NTg1
CADwDTc3OTdkMDAyMGI0YjMwMDVjZDhkMjAwYWNmNmb4ALA3MjI4NjAwNWUyNiAA0DhkM2JlZDAw
YWU4MWawAEA4YzRmoAAQZQIAQDAwYjcCAEAwMGUzAgBAMDBmNAIAAMgAAAIAQDAwMWQCAEAwMDJl
AgBAMDA0NgIAQDAwOWICAEAwMGMxAgDgMDA0ZjRiM2UwMDczNmHgAPATOWU4Zjc0MDBhYTlkODUw
MGJlYjVhNDAwNTg1OTVkMDA2OAIAUTAwNmY2uQARNwEAUDAwODY4rwHxBjAzZjI3MmEwMDViMzcz
NDAwNjY0MGAAUDA0OTQ0KAAgNWMQAYA0MDJjNGQiKQ==
:: pal/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTIzIDE4OjU0OjE5Iixtb2RpZmllZD0iMjAyNC0w
OS0xMiAyMDo0MjoyNiJdXQ==
:: sfx/
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM1Iixtb2RpZmllZD0iMjAyNC0w
OS0xMiAyMDo0MjoyNiIscmV2aXNpb249MzkyM11dbHo0ABoBAABSCAAA8CdweHUAAygAAAQABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDBAUGBwAP-5AICQoLDwwPDQ8ODw8QAPAADQ8RDxIPEw8UDxUP
Fg8XEwDxAQ8YDxkPGg8bDxwPHQ8eDx8UAPEAIA8hDyIPIw8kDyUPJg8nFADxACgPKQ8qDysPLA8t
Dy4PLxQA8QAwDzEPMg8zDzQPNQ82DzcUAP8FOA85DzoPOw88Dz0PPg8-AA--8P8BAOv-J1oBEAYP
IBABIAEgAfAAAhACDBABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDDAAAh9EMAAc
H0AwAPIf-wEA3L-4D0AADUD--7DwcAoA--9kH-8BAP_ZUP----8g
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNC0w
OS0xMiAyMDo0MjoyNiIsc3RvcmVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Il1d
:: src/
:: src/logic/
:: src/logic/creation.lua
--[[pod_format="raw",created="2024-08-30 06:25:09",modified="2024-09-07 08:00:48",revision=1087]]
--- Board Creation Logic


function logic_new_test_cells(tiling, for_editor)
	local grid
	local size
	if tiling == "square" then
		grid = sgrid_new()
		for x = 2, 9 do
			for y = 0, 7 do
				grid:set(pos(x, y), cell_good)
			end
		end
	elseif tiling == "hex" then
		grid = hgrid_new()
		for i = 0, 4 do
			for y = i, 12 - i, 2 do
				grid:set(pos(6 + i, y), cell_good)
				grid:set(pos(6 - i, y), cell_good)
			end
		end
	end
	return grid
end


------------------------------------------------------------------------


local function random_gem()
	if false and rnd() < 0.05 then
		local gem = gem_rainbow + flr(rnd(6))
		if gem == gem_robot_E then
			gem += flr(rnd(4))
		end
		return gem
	end
	return gem_color_first + flr(rnd(gem_color_last - gem_color_first))
end


function logic_fill_gem_at(cells, gems, states, p)
	local cell = cells:get(p) or 0
	if (cell & cell_mask == 0) or (cell & rock_mask != 0) then
		return
	end
	local test = gems.is_square and logic_test_sqr_match_at or logic_test_hex_match_at
	local gem = gems:get(p)
	if not gem then
		local attempts = 0
		local found = false
		while attempts < 8 and not found do
			gem = random_gem()
			gems:set(p, gem)
			found = not test(gems, p)
			attempts += 1
		end
		if attempts == 16 then
			gem = gem_gift
			gems:set(p, gem)
		end
		states:set(p, { name = "new" })
	end
end


function logic_fill_gems(cells, gems, states)
	-- TODO: transform into a coroutine
	-- TODO: fill in reverse gravity order
	cells:foreachpos(
		function(p, _)
			logic_fill_gem_at(cells, gems, states, p)
		end
	)
end

:: src/logic/matching.lua
--[[pod_format="raw",created="2024-08-24 08:12:55",modified="2024-09-02 06:18:54",revision=2910]]
--- Matching Logic

-- The matching algorithm has two phases:
--
-- 1. First, a linear sweep through all the gems, and for each gem involved in a match
--    creates a mark registering which direction(s) matched.
-- 2. Then a flood-fill algorithm is used to group matches together.


local function logic_is_matching(gem1, gem2)
	if (not gem1) or (not gem2) then
		return false
	end
	
	-- Only colored gems can match.
	if (gem1 < gem_color_first) or (gem1 > gem_color_last) then
		return false
	end
	if (gem2 < gem_color_first) or (gem2 > gem_color_last) then
		return false
	end

	return (gem1 == gem2) or (gem1 == gem_rainbow)
		or (gem2 == gem_rainbow)
end


--------------------------------------------------------------------------


local function test_3(gems, p0, p1, p2)
	local gem0 = gems:get(p0)
	local gem1 = gems:get(p1)
	local gem2 = gems:get(p2)
	return logic_is_matching(gem0, gem1)
		and logic_is_matching(gem0, gem2)
		and logic_is_matching(gem1, gem2)
end


local function test_4(gems, p0, p1, p2, p3)
	local gem0 = gems:get(p0)
	local gem1 = gems:get(p1)
	local gem2 = gems:get(p2)
	local gem3 = gems:get(p3)
	return logic_is_matching(gem0, gem1)
		and logic_is_matching(gem0, gem2)
		and logic_is_matching(gem0, gem3)
		and logic_is_matching(gem1, gem2)
		and logic_is_matching(gem1, gem3)
		and logic_is_matching(gem2, gem3)
end


function logic_test_sqr_match_at(gems, p)
	local S = p + pos(0, 1)
	local SS = p + pos(0, 2)
	local N = p + pos(0, -1)
	local NN = p + pos(0, -2)
	local E = p + pos(1, 0)
	local EE = p + pos(2, 0)
	local W = p + pos(-1, 0)
	local WW = p + pos(-2, 0)
	local SE = p + pos(1, 1)
	local SW = p + pos(-1, 1)
	local NE = p + pos(1, -1)
	local NW = p + pos(-1, -1)
	return test_3(gems, SS, S, p) or test_3(gems, S, p, N) or test_3(gems, p, N, NN)
		or test_3(gems, EE, E, p) or test_3(gems, E, p, W) or test_3(gems, p, W, WW)
		or test_4(gems, p, S, SE, E) or test_4(gems, p, S, SW, W) 
		or test_4(gems, p, N, NE, E) or test_4(gems, p, N, NW, W)
end


function logic_test_hex_match_at(gems, p)
	local S = p + pos(0, 2)
	local S_S = p + pos(0, 4)
	local N = p + pos(0, -2)
	local N_N = p + pos(0, -4)
	local SE = p + pos(1, 1)
	local SE_SE = p + pos(2, 2)
	local SW = p + pos(-1, 1)
	local SW_SW = p + pos(-2, 2)
	local NE = p + pos(1, -1)
	local NE_NE = p + pos(2, -2)
	local NW = p + pos(-1, -1)
	local NW_NW = p + pos(-2, -2)
	local E = p + pos(2, 0)
	local W = p + pos(-2, 0)
	return test_3(gems, S_S, S, p) or test_3(gems, S, p, N) or test_3(gems, p, N, N_N)
		or test_3(gems, SE_SE, SE, p) or test_3(gems, SE, p, NW) or test_3(gems, p, NW, NW_NW)
		or test_3(gems, NE_NE, NE, p) or test_3(gems, NE, p, SW) or test_3(gems, p, SW, SW_SW)
		or test_4(gems, p, SE, S, SW) or test_4(gems, p, NE, N, NW)
		or test_4(gems, p, NE, E, SE) or test_4(gems, p, NW, W, SW)
end


local function check_3_and_mark(gems, p0, p1, p2, mark, marks)
	if test_3(gems, p0, p1, p2) then
		marks:merge(p0, mark)
		marks:merge(p1, mark)
		marks:merge(p2, mark)
	end
end


local function check_4_and_mark(gems, p0, p1, p2, p3, mark, marks)
	if test_4(gems, p0, p1, p2, p3) then
		marks:merge(p0, mark)
		marks:merge(p1, mark)
		marks:merge(p2, mark)
		marks:merge(p3, mark)
	end
end


local function mark_sgrid_matches_at(gems, p0, marks)
	check_3_and_mark( gems,
		p0,
		p0 + pos(0, 1),
		p0 + pos(0, 2),
		{ name = "matching", vertical = true }, marks )
	check_3_and_mark( gems,
		p0,
		p0 + pos(1, 0),
		p0 + pos(2, 0),
		{ name = "matching", horizontal= true }, marks )
	check_4_and_mark( gems,
		p0,
		p0 + pos(1, 0),
		p0 + pos(0, 1),
		p0 + pos(1, 1),
		{ name = "matching", vertical = true, horizontal = true }, marks )
end


local function mark_hgrid_matches_at(gems, p0, marks)
	check_3_and_mark( gems,
		p0,
		p0 + pos(0, 2),
		p0 + pos(0, 4),
		{ name = "matching", vertical = true }, marks )
	check_3_and_mark( gems,
		p0,
		p0 + pos(1, 1),
		p0 + pos(2, 2),
		{ name = "matching", horizontal_SE = true }, marks )
	check_3_and_mark( gems,
		p0,
		p0 + pos(1, -1),
		p0 + pos(2, -2),
		{ name = "matching", horizontal_NE = true }, marks )
	local p1 = p0 + pos(1, 1)
	local p2 = p0 + pos(1, -1)
	local p3 = p0 + pos(2, 0)
	if test_4(gems, p0, p1, p2, p3) then
		marks:merge(p0, { name = "matching", vertical = true, horizontal_NE = true, horizontal_SE = true})
		marks:merge(p1, { name = "matching", vertical = true, horizontal_SE = true })
		marks:merge(p2, { name = "matching", vertical = true, horizontal_NE = true })
		marks:merge(p3, { name = "matching", vertical = true, horizontal_NE = true, horizontal_SE = true})
	end
end


local function mark_all_matches(gems)
	local marks = gems:new_grid()
	if gems.is_square then
		gems:foreachpos(
			function(p, _gem)
				mark_sgrid_matches_at(gems, p, marks)
			end
		)
	elseif gems.is_hex then
		gems:foreachpos(
			function(p, _gem)
				mark_hgrid_matches_at(gems, p, marks)
			end
		)
	end
	return marks
end


---------------------------------------------------------------------------


local function group_this_match(cells, gems, marks, p)
	-- A simple flood-fill algorithm to group all
	-- intersecting linear matches together.
	local colour = gem_rainbow
	local positions = {}
	local one_good_cell = false
	local remaining = { p }
	local rainbows = {}
	while #remaining > 0 do
		local current = deli(remaining)
		local gem = gems:get(current)
		local mark = marks:get(current)
		if mark and mark.name == "matching"
			and (not mark.counted)
			and logic_is_matching(colour, gem)
		then
			if gem == gem_rainbow then
				-- Rainbow gems can be part of multiple matches,
				-- so they need to be unflagged at the end.
				add(rainbows, current)
			else
				colour = gem
			end
			add(positions, current)
			marks:merge(current, { counted = true })
			local cell = cells:get(current)
			if cell and cell & cell_mask == cell_good then
				one_good_cell = true
			end
			local neighbours = gems:neighbours(current)
			foreach(
				neighbours,
				function(n)
					local s = marks:get(n.position)
					if not s then
						return
					end
					if s and s.name == "matching"
						and (not s.counted)
						and s[n.direction]
					then
						add(remaining, n.position)
					end
				end
			)
		end
	end
	foreach(
		rainbows,
		function(p)
			marks:merge(p, { counted = false })
		end
	)
	return { colour = colour, positions = positions, one_good_cell = one_good_cell }
end


function logic_find_matches(cells, gems)
	local marks = mark_all_matches(gems)
	local matches = {}
	marks:foreachpos(
		function(p, mark)
			if mark and mark.name == "matching"
				and (not mark.counted)
			then
				local match = group_this_match(cells, gems, marks, p)
				if match.colour == gem_rainbow then
					-- Ignore, as this is probably a stray rainbow that was unflagged
					-- at the end of `count_this_match`.
					-- TODO: an edge case is when there is a legitime match of
					-- only rainbow gems (e.g. 3 rainbows surrounded by black things).
				else
					add(matches, match)
				end
			end
		end
	)
	return matches, marks
end
:: src/logic/mechanics.lua
--[[pod_format="raw",created="2024-08-30 06:41:59",modified="2024-09-07 08:00:48",revision=1568]]
--- Core Mechanics Logic


function logic_mark_gravity(cells, gems, marks, gravity)
	local some_gems_are_falling = false
	gems:foreachpos(
		function(p, gem)
			local below = p + gravity
			local distance = 0
			local cell_below = cells:get(below) or cell_none
			while (cell_below & cell_mask != cell_none)
				and (cell_below & rock_mask == 0)
			do
				if (not gems:get(below)) then
					some_gems_are_falling = true
					distance += 1
				end
				below += gravity
				cell_below = cells:get(below) or cell_none
			end
			if distance > 0 then
				marks:set(p, { name = "falling", target = p + distance * gravity })
			end
		end
	)
	return some_gems_are_falling
end


function logic_enact_gravity(gems, marks)
	local fell_gems = {}
	marks:foreachpos(
		function(p, mark)
			if mark.name == "falling" then
				local new_p = mark.target
				add(fell_gems, { gem = gems:get(p), pos = new_p })
				gems:del(p)
				marks:del(p)
			end
		end
	)
	foreach(fell_gems,
		function(fell_gem)
			gems:set(fell_gem.pos, fell_gem.gem)
			marks:del(fell_gem.pos)
		end
	)
end


------------------------------------------------------------------------


function logic_mark_swap(gems, marks, source, target)
	local gem0 = gems:get(source)
	local gem1 = gems:get(target)
	local test = gems.is_square and logic_test_sqr_match_at or logic_test_hex_match_at
	gems:set(source, gem1)
	gems:set(target, gem0)
	local matched = test(gems, target) or test(gems, source)
	gems:set(source, gem0)
	gems:set(target, gem1)
	if not matched then
		return false
	end
	marks:set(source, {
		name = "swapping",
		selected = true,
		target = target,
	})
	marks:set(target, {
		name = "swapping",
		target = source,
	})
	return true
end


function logic_enact_swap(gems, marks)
	local reinsert = {}
	marks:foreachpos(
		function(p, mark)
			if mark.name == "swapping" then
				add(reinsert, { gem = gems:get(p), position = mark.target })
				gems:del(p)
				marks:del(p)
			end
		end
	)
	foreach(
		reinsert,
		function(r) gems:set(r.position, r.gem) end
	)
end


-------------------------------------------------------------------------


function logic_enact_clear(gems, marks)
	marks:foreachpos(
		function(p, mark)
			if mark.name == "matching" then
				gems:del(p)
				marks:del(p)
			end
		end
	)
end

-------------------------------------------------------------------------


function logic_mark_repair(cells, marks, matches)
	local is_something_repaired = false
	foreach(
		matches,
		function(match)
			if match.one_good_cell then
				foreach(
					match.positions,
					function(position)
						local cell = cells:get(position) or 0
						if cell & cell_mask == cell_bad then
							marks:set(position, { name = "repaired" })
							is_something_repaired = true
						end
					end
				)
			end
		end
	)
	return is_something_repaired
end


function logic_enact_repair(cells, marks)
	local to_be_unmarked = {}
	marks:foreachpos(
		function(position, mark)
			if mark.name == "repaired" then
				local cell = cells:get(position)
				cell = (cell & ~cell_mask) | cell_good
				cells:set(position, cell)
				add(to_be_unmarked, position)
			end
		end
	)
	foreach(to_be_unmarked, function(p) marks:del(p) end)
end


----------------------------------------------------------------------


function logic_mark_breakage(cells, gems, marks, matches)
	local something_broke = false
	foreach(
		matches,
		function(match)
			foreach(
				match.positions,
				function(position)
					local neighbours = cells:neighbours(position)
					foreach(
						neighbours,
						function(n)
							local cell = (cells:get(n.position) or 0) & rock_mask
							if cell >= rock_full and cell <= rock_broken then
								marks:set(n.position, { name = "broken" })
								something_broke = true
							end
							local gem = gems:get(n.position) or 0
							if #match.positions > 3 then
								if gem == gem_cat or gem == gem_bat
									or gem == gem_robot_asleep
									or gem == gem_bomb
								then
									marks:set(n.position, { name = "broken" })
									something_broke = true
								elseif gem == gem_robot then
									gems:set(n.position, gem_robot_asleep2)
								end
							elseif gem == gem_bomb then
								marks:set(n.position, { name = "broken", exploded = true })
								something_broke = true
							end
						end
					)
				end
			)
		end
	)
	return something_broke
end


function logic_enact_breakage(cells, gems, marks)
	local to_be_unmarked = {}
	marks:foreachpos(
		function(position, mark)
			if mark.name == "broken" then
				local cell = cells:get(position) or 0
				if cell & rock_mask == rock_full then
					cells:set(position, (cell & cell_mask) | rock_cracked)
				elseif cell & rock_mask == rock_cracked then
					cells:set(position, (cell & cell_mask) | rock_broken)
				elseif cell & rock_mask == rock_broken then
					cells:set(position, (cell & cell_mask))
				end
				local gem = gems:get(position) or 0
				if gem == gem_cat or gem == gem_bat
					or gem == gem_robot_asleep
					or gem == gem_bomb
				then
					gems:del(position)
				end
				if gem == gem_bomb and mark.exploded then
					local neighbours = cells:blast_radius(position)
					foreach(
						neighbours,
						function(p)
							local cell = cells:get(p)
							if cell then
								cells:set(p, cell_bad | (cell & rock_mask))
							end
						end
					)
				end
				add(to_be_unmarked, position)
			end
		end
	)
	foreach(to_be_unmarked, function(p) marks:del(p) end)
end


-----------------------------------------------------------------------


function logic_mark_move(cells, gems, marks)
	local something_moved = false
	local movers = {}
	gems:foreachpos(
		function(position, gem)
			if gem == gem_cat or gem == gem_bat or gem == gem_robot then
				add(movers, position)
			elseif gem == gem_robot_asleep2 then
				gems:set(position, gem_robot_asleep)
			elseif gem == gem_robot_asleep then
				gems:set(position, gem_robot)
			end
		end
	)
	foreach(
		movers,
		function(position)
			local neighbours = cells:neighbours(position)
			local possibilities = {}
			foreach(
				neighbours,
				function(neighbour)
					local cell = cells:get(neighbour.position) or 0
					local gem = gems:get(neighbour.position) or 0
					if (cell & rock_mask == 0)
						and (cell & cell_mask != 0)
						and (gem < gem_rainbow)
					then
						add(possibilities, neighbour.position)
					end
				end
			)
			if #possibilities > 0 then
				something_moved = true
				local target = possibilities[math.random(1, #possibilities)]
				local moving_gem = gems:get(position)
				gems:del(position)
				local target_gem = gems:get(target)
				gems:set(target, moving_gem)
				local source_gem
				logic_fill_gem_at(cells, gems, marks, position)
				source_gem = gems:get(position)
				marks:set(target, {
					name = "moving",
					source = position,
					target = target,
					moving_gem = moving_gem,
					target_gem = target_gem,
					source_gem = source_gem,
				})
				if moving_gem == gem_bat or moving_gem == gem_robot then
					local cell = cells:get(target)
					cell = cell_bad | (cell & rock_mask)
					cells:set(target, cell)
				end
			end
		end
	)
	return something_moved
end


function logic_enact_move(cells, gems, marks)
	marks:foreachpos(
		function(position, mark)
			if mark.name == "moving" then
				if mark.moving_gem == gem_robot then
				end
			end
		end
	)
	marks:foreachpos(function(p, _) marks:del(p) end)
end
:: src/logic/spells.lua
--[[pod_format="raw",created="2024-08-30 06:37:36",modified="2024-09-07 08:00:48",revision=511]]
--- Spell Logic


function logic_gain_mana(stats, matches)
	local gained = false
	foreach(
		matches,
		function(match)
			local count = #(match.positions)
			if count > 3 then
				stats.mana += 10 * (count - 3)
				gained = true
			end
			if stats.in_cascade then
				stats.mana += 5
				gained = true
			end
			stats.in_cascade = true
			if match.colour == gem_rainbow then
				foreach(
					{ gem_air, gem_fire, gem_day, gem_earth, gem_water, gem_night },
					function(g) stats.colour[g] += count end
				)
			else
				stats.colours[match.colour] += count
			end
		end
	)
	return gained
end

:: src/logic/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTMwIDA2OjI0OjM5Iixtb2RpZmllZD0iMjAyNC0w
OS0xMiAyMDo0MjoyNiJdXQ==
:: src/constants.lua
--[[pod_format="raw",created="2024-08-24 15:17:10",modified="2024-09-02 06:18:54",revision=2655]]
--- Match3 Global Constants


-- Gems and cells ------------------------------------------------------

-- Color gems
gem_air = 0x01
gem_fire = 0x02
gem_day = 0x03
gem_earth = 0x04
gem_water = 0x05
gem_night = 0x06
gem_rainbow = 0x07

gem_color_first = gem_air
gem_color_last = gem_rainbow

-- Black gems
gem_gift = 0x08
gem_bomb = 0x09
gem_cat = 0x0a
gem_bat = 0x0b
gem_robot = 0x0c
gem_robot_asleep = 0x0d
gem_robot_asleep2 = 0x0e

gem_names = {
	[gem_air] = "Air",
	[gem_fire] = "Fire",
	[gem_day] = "Day",
	[gem_earth] = "Earth",
	[gem_water] = "Water",
	[gem_night] = "Night",
	[gem_rainbow] = "Rainbow",
}

gem_sprites = {
	[gem_air] = 1,
	[gem_fire] = 2,
	[gem_day] = 3,
	[gem_earth] = 4,
	[gem_water] = 5,
	[gem_night] = 6,
	[gem_rainbow] = 7,
	[gem_gift] = 8,
	[gem_bomb] = 9,
	[gem_cat] = 10,
	[gem_bat] = 11,
	[gem_robot] = 12,
	[gem_robot_asleep] = 13,
	[gem_robot_asleep2] = 13,
}

-- Cells
cell_mask = 0x03
cell_none = 0x00
cell_good = 0x01
cell_bad = 0x02

-- Rocks
rock_full = 0x10
rock_cracked = 0x20
rock_broken = 0x30
cell_door = 0x40
cell_chest_air = 0x50
cell_chest_fire = 0x60
cell_chest_day = 0x70
cell_chest_earth = 0x80
cell_chest_water = 0x90
cell_chest_night = 0xa0

rock_mask = 0xf0

:: src/gfx.lua
--[[pod_format="raw",created="2024-08-24 12:06:13",modified="2024-09-12 20:42:26",revision=4378]]
--- Graphics


local cell_width = 29
local cell_height = 29


function gfx_draw_cells(cells)
	local function draw_cell(p, cell)
		local x, y = cells:coords_cell(p)
		local sprite
		if cells.is_square then
			if cell & cell_mask == cell_good then
				sprite = 32
				sprite += (p.x + p.y) % 2
--			elseif cell & cell_mask == cell_bad then
--				sprite = 39
			elseif cell & cell_mask == cell_bad then
				sprite = 34
				sprite += p.y % 2
			end
		elseif cells.is_hex then
			if cell & cell_mask == cell_good then
				sprite = 40
				sprite += (p.y + (p.x * 3)) % 3
--			elseif cell & cell_mask == cell_bad then
--				sprite = 47
			elseif cell & cell_mask == cell_bad then
				sprite = 43
			end
		end
		spr(sprite, x, y)
		x, y = cells:coords_gem(p)
		if cell and cell & cell_mask == cell_bad then
			pal(53, 58)
		end
		if cell & rock_mask == 0 then
		elseif cell & rock_mask == rock_full then
			spr(48, x, y)
		elseif cell & rock_mask == rock_cracked then
			spr(49, x, y)
		elseif cell & rock_mask == rock_broken then
			spr(50, x, y)
		elseif cell & rock_mask == cell_door then
			spr(51, x, y)
		elseif cell & rock_mask == cell_chest_air then
			spr(52, x, y)
		elseif cell & rock_mask == cell_chest_fire then
			spr(53, x, y)
		elseif cell & rock_mask == cell_chest_day then
			spr(54, x, y)
		elseif cell & rock_mask == cell_chest_earth then
			spr(55, x, y)
		elseif cell & rock_mask == cell_chest_water then
			spr(56, x, y)
		elseif cell & rock_mask == cell_chest_night then
			spr(57, x, y)
		end	
		pal(53, 53)
	end
	cells:foreachpos(draw_cell)
	-- TODO: move border construction out of the hot loop
	local function draw_borders(p, cell)
		local x, y = cells:coords_cell(p)
		if cells.is_square then
			local cell_S = cells:get(p + pos(0, 1))
			local cell_W = cells:get(p + pos(-1, 0))
			local cell_E = cells:get(p + pos(1, 0))
			local cell_N = cells:get(p + pos(0, -1))
			if cell & cell_good != 0 then
				if not cell_S or cell_S & cell_good == 0 then
					line(x, y + 28, x + 28, y + 28, 53)
				end
				if not cell_E or cell_E & cell_good == 0 then
					line(x + 28, y, x + 28, y + 28, 53)
				end
				if not cell_N or cell_N & cell_good == 0 then
					line(x, y, x + 28, y, 57)
				end
				if not cell_W or cell_W & cell_good == 0 then
					line(x, y, x, y + 28, 57)
				end
			elseif cell & cell_bad != 0 then
				if cell_N and cell_N & cell_good != 0 then
					line(x, y, x + 28, y, 58)
				end
				if cell_W and cell_W & cell_good != 0 then
					line(x, y, x, y + 28, 58)
				end
			end
		end
	end
	cells:foreachpos(draw_borders)
end


-----------------------------------------------------------------------


local function scaled_gem(sprite, x, y, size)
	local w, h = flr(29 * size + 0.5) // 2 * 2 + 1, flr(29 * size + 0.5) // 2 * 2 + 1
	local x, y = x + ((29 - w) / 2), y + ((29 - h) / 2)
	sspr(sprite, 0, 0, 29, 29, x, y, w, h)
end


local function draw_exploded_gem(sprite, x, y, clock, new_clock)
	local size = 32 * new_clock
	local colour = 10 + (sprite - 1) * 5
	oval(x - size, y - size, x + 29 + size, y + 29 + size, colour + 1)
	if clock < 0.25 then
		ovalfill(x + 2, y + 2, x + 25, y + 25, 7)
	elseif clock < 0.50 then
		ovalfill(x + 2, y + 2, x + 25, y + 25, colour + 2)
	elseif clock < 0.75 then
		ovalfill(x + 1, y + 1, x + 27, y + 27, colour + 1)
	elseif clock < 1.0 then
		ovalfill(x, y, x + 29, y + 29, colour)
	end
end


function gfx_draw_gems(cells, gems, states, clock)
	local function draw_gem(p, gem)
		local x, y = gems:coords_gem(p)
		local sprite = gem_sprites[gem]
		local cell = cells:get(p)
		if cell and cell & cell_mask == cell_bad then
			pal(53, 58)
		end
		local state = states:get(p)
		if not state or state.name == "broken" then
			spr(sprite, x, y)
		elseif state.name == "new" then
			scaled_gem(sprite, x, y, clock)
		elseif state.name == "matching" then
		elseif state.name == "falling" or state.name == "swapping"
		then
			local dest_x, dest_y = gems:coords_gem(state.target)
			local ix, iy = x + clock * (dest_x - x), y + clock * (dest_y - y)
			spr(sprite, ix, iy)
		elseif state.name == "moving" then
			x, y = gems:coords_gem(state.source, gem)
			local dest_x, dest_y = gems:coords_gem(state.target)
			scaled_gem(gem_sprites[state.target_gem], dest_x, dest_y, 1.0)
		end
		pal(53, 53)	
	end
	gems:foreachpos(draw_gem)
	local new_clock = clock * clock * clock * clock
	gems:foreachpos(
		function(p, gem)
			local x, y = gems:coords_gem(p)
			local sprite = gem_sprites[gem]
			local cell = cells:get(p)
			if cell and cell & cell_mask == cell_bad then
				pal(53, 58)
			end
			local state = states:get(p)
			if state and state.name == "matching" then
				draw_exploded_gem(sprite, x, y, clock, new_clock)
			elseif state and state.name == "moving" then
				x, y = gems:coords_gem(state.source, gem)
				local dest_x, dest_y = gems:coords_gem(state.target)
				local ix, iy = x + clock * (dest_x - x), y + clock * (dest_y - y)
				spr(gem_sprites[state.moving_gem], ix, iy)
			end
		end
	)
end


-----------------------------------------------------------------------


function gfx_draw_turns(ox, oy, turn, anim_turn)
	spr(64, ox, oy)
	local hundreds = (turn // 100) % 10
	local tens = (turn // 10) % 10
	local ones = turn % 10
	local anim = anim_turn // 2
	pal(7, 1)
	clip(ox + 7, oy + 3, ox + 7 + 3 * 8, oy + 3 + 8)
	-- hundreds
	if anim == 0 or (turn % 100) > 0 then
		spr(65 + hundreds, ox + 7, oy + 6)
	else
		spr(65 + hundreds, ox + 7, oy + 6 + anim)
		spr(65 + ((hundreds - 1) % 10), ox + 7, oy + 6 + anim - 10)
	end
	-- tens
	if anim == 0 or ones > 0 then
		spr(65 + tens, ox + 7 + 8, oy + 6)
	else
		spr(65 + tens, ox + 7 + 8, oy + 6 + anim)
		spr(65 + ((tens - 1) % 10), ox + 7 + 8, oy + 6 + anim - 10)
	end
	-- ones
	spr(65 + ones, ox + 7 + 2 * 8, oy + 6 + anim)
	spr(65 + ((ones - 1) % 10), ox + 7 + 2 * 8, oy + 6 + anim - 10)
	clip()
	pal(7, 7)
end


function gfx_draw_mana(ox, oy, mana, zoomed)
	local base_char
	local char_width
	if zoomed then
		base_char = 85
		char_width = 11
		oy -= 3
	else
		base_char = 75
		char_width = 8
	end
	local thousands = (mana // 1000) % 10
	local hundreds = (mana // 100) % 10
	local tens = (mana // 10) % 10
	local ones = mana % 10
	local digits = 4
	if mana < 10 then
		digits = 1
	elseif mana < 100 then
		digits = 2
	elseif mana < 1000 then
		digits = 3
	else
		digits = 4
	end
	ox -= (digits * char_width) // 2
	if mana >= 1000 then
		spr(base_char + thousands, ox, oy)
		ox += char_width
	end
	if mana >= 100 then
		spr(base_char + hundreds, ox, oy)
		ox += char_width
	end
	if mana >= 10 then
		spr(base_char + tens, ox, oy)
		ox += char_width
	end
	spr(base_char + ones, ox, oy)
end


function gfx_draw_mana_bar(ox, oy, mana)
	spr(95, ox, oy)
	if mana == 0 then
		return
	end
	local size = min(91, flr(0.5 + 91*(mana / 250)))
	rectfill(ox+1, oy+2, ox+1+size, oy+5, 40)
	line(ox+1+size, oy+2, ox+1+size, oy+5, 39)
	line(ox+1, oy+2, ox+1, oy+5, 41)
	if size > 1 then
		line(ox+2, oy+1, ox+1+size-1, oy+1, 41)
		line(ox+2, oy+6, ox+1+size-1, oy+6, 39)
	end
end
:: src/hgrid.lua
--[[pod_format="raw",created="2024-08-25 08:16:09",modified="2024-09-12 20:42:26",revision=2611]]
--- Hex Grids

--- Hex grids use the "double height" coordinate system:
---
---     (0,0)         (2,0)         (4,0)
---            (1,1)         (3,1)
---     (0,2)         (2,2)         (4,2)
---            (1,3)         (3,3)
---     (0,4)         (2,4)         (4,4)
---
--- The origin of the grid, `pos(0, 0)`, is at the top left.


-- Local Constants --------------------------------------------------------


local max_width <const> = 13
local max_height <const> = 8


-- Constructors -----------------------------------------------------------


local metatable = {}


function hgrid_new()
	local grid = { is_hex = true }
	metatable.default_origin(grid)
	setmetatable(grid, { __index = metatable })
	for i = 0, max_width * max_height do
		grid[i] = false
	end
	return grid
end


function metatable:new_grid()
	return hgrid_new()
end


function metatable:clone()
	local grid = self:new_grid()
	grid.origin = self.origin
	self:foreachpos(function(p, item) grid:set(p, item) end)
	return grid
end


-- Indexing ------------------------------------------------------------


function metatable:get(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	return self[p.x + ((p.y // 2) * max_width)]
end


function metatable:set(p, value)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	self[p.x + ((p.y // 2) * max_width)] = value
end


function metatable:merge(p, state)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	local index = p.x + ((p.y // 2) * max_width)
	if not self[index] then
		self[index] = {}
	end
	for k, v in pairs(state) do
		self[index][k] = v
	end
end


function metatable:del(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	self[p.x + ((p.y // 2) * max_width)] = false
end


-- Screen Coordinates ---------------------------------------------------------


function metatable:default_origin()
	self.origin = { x = 116, y = 7 }
end


function metatable:compute_origin()
	local min_p = pos(max_width, max_height)
	local max_p = pos(0, 0)
	self:foreachpos(
		function(position, cell)
			if not cell or cell == 0 then
				return
			end
			if position.x < min_p.x then min_p.x = position.x end
			if position.y < min_p.y then min_p.y = position.y end
			if position.x > max_p.x then max_p.x = position.x end
			if position.y > max_p.y then max_p.y = position.y end
		end
	)
	local width = 1 + max_p.x - min_p.x
	local height = 1 + max_p.y - min_p.y
	self.origin = {
		x = 110 + ((480 - 110) // 2) - ((width * 27) // 2) - (min_p.x * 27) - 4,
		y = (270 // 2) - ((height * 16) // 2) - (min_p.y * 16) - 8,
	}
end


function metatable:coords_origin()
	return self.origin.x, self.origin.y
end


function metatable:coords_cell(p)
	local ox, oy = self:coords_origin()
	return ox + p.x * 27, oy + p.y * 16
end


function metatable:coords_gem(p)
	local ox, oy = self:coords_origin()
	return ox + (p.x * 27) + 3, oy + (p.y * 16) + 1
end


function metatable:pos(x, y)
	local ox, oy = self:coords_origin()
	x -= ox
	y -= oy + 1
	local px, py = x // 27, y // 16
	local dx, dy = x - (px * 27), y - (py * 16)
	if dx < 8 then
		if (px + py) % 2 == 0 and dy < 14 + (-2 * dx) then
			px -= 1
			py -= 1
		elseif (px + py) % 2 != 0 and dy > -1 + (2 * dx) then
			px -= 1
		end
	end
	py = (2 * ((py - (px % 2)) // 2)) + (px % 2)
	return pos(px, py)
end


function metatable:distance(p0, p1)
	-- TODO: is this correct?
	return (abs(p0.x - p1.x) + abs(p0.y - p1.y)) // 2
end


-- Iterating ----------------------------------------------------------


function metatable:foreachpos(func)
	for x = 0, max_width do
		for y = x % 2, max_height * 2 - 1, 2 do
			local p = pos(x, y)
			local item = self:get(p)
			if item then
				func(p, item)
			end
		end
	end
end	


function metatable:neighbours(p)
	return {
		{ position = p + pos(1, 1), direction = "horizontal_SE" },
		{ position = p + pos(0, 2), direction = "vertical" },
		{ position = p + pos(-1, 1), direction = "horizontal_NE" },
		{ position = p + pos(-1, -1), direction = "horizontal_SE" },
		{ position = p + pos(0, -2), direction = "vertical" },
		{ position = p + pos(1, -1), direction = "horizontal_NE" },
	}
end


function metatable:blast_radius(p)
	return {
		p + pos(0, 0),
		p + pos(0, -2),
		p + pos(1, -1),
		p + pos(1, 1),
		p + pos(0, 2),
		p + pos(-1, 1),
		p + pos(-1, -1),
	}
end

:: src/in_editor.lua
--[[pod_format="raw",created="2024-08-30 08:13:35",modified="2024-09-12 20:42:26",revision=847]]
in_editor = {}

local tiling = "square"

local cells = false
local gems = false
local marks = false

local active_tool = 0
local ox, oy = 8, 8
local sx, sy = 32, 32

local tools = {
	[0] = cell_none,
	cell_good,
	cell_bad,
	rock_full,
	rock_cracked,
	rock_broken,
	cell_chest_air,
	cell_chest_fire,
	cell_chest_day,
	cell_chest_earth,
	cell_chest_water,
	cell_chest_night,
	cell_door,
	false,
	false,
	gem_gift,
	gem_bomb,
	false,
	gem_cat,
	gem_bat,
	gem_robot,
	false,
	false,
}



function in_editor:enter()
	if not cells then
		cells = logic_new_test_cells(tiling, true)
		gems = cells:new_grid()
	end
	cells:default_origin()
	gems:default_origin()
	marks = cells:new_grid()
end


function in_editor:exit()
end


function in_editor:update()
	if keyp("s") then
		tiling = "square"
		cells = false
		in_editor:enter()
	end
	if keyp("h") then
		tiling = "hex"
		cells = false
		in_editor:enter()
	end
	local mx, my, mb, _, _ = mouse()
	if mb == 0x1 and mx < 110 then
		mx -= ox
		my -= oy
		local x, y = clamp(mx // sx, 0, 2), clamp(my // sy, 0, 7)
		active_tool = clamp(x + 3 * y, 0, 22)
	elseif mb == 0x1 then
		local mp = cells:pos(mx, my)
		local tool = tools[active_tool]
		if tool == cell_none then
			local cell = cells:get(mp) or cell_none
			cell = (cell & ~cell_mask) | tool
			cells:set(mp, cell)
			gems:del(mp)
		elseif tool == cell_good or tool == cell_bad then
			local cell = cells:get(mp) or cell_none
			cell = (cell & ~cell_mask) | tool
			cells:set(mp, cell)
		elseif active_tool <= 12 then 
			local cell = cells:get(mp) or cell_none
			cell = (cell & cell_mask) | tool
			cells:set(mp, cell)
			gems:del(mp)
		elseif cells:get(mp) and cells:get(mp) & cell_mask != 0 then
			gems:set(mp, tool)
			local cell = cells:get(mp) or cell_none
			cell = (cell & cell_mask)
			cells:set(mp, cell)
		end
	end
	if mb == 0x2 then
		local mp = cells:pos(mx, my)
		local cell = cells:get(mp) or cell_none
		cell = (cell & cell_mask)
		cells:set(mp, cell)
		gems:del(mp)
	end
	if keyp("g") then
		in_game:load_from_editor(tiling, cells, gems)
		return in_game
	end
	return false
end


function in_editor:draw()
	cls(63)
	if not cells then
		return
	end
	local mx, _, _, _, _ = mouse()
	if mx <= 110 then
		window { cursor = "pointer" }
	else
		window { cursor = "crosshair" }
	end
	gfx_draw_cells(cells)
	gfx_draw_gems(cells, gems, marks, 0.0)
	-- Draw the panel
	rectfill(0, 0, 110, 269, 55)
	rectfill(ox, oy, ox + 28, oy + 28, 63)
	spr(33, ox + 1 * sx, oy + 0 * sy)
	spr(34, ox + 2 * sx, oy + 0 * sy)
	spr(48, ox + 0 * sx, oy + 1 * sy)
	spr(49, ox + 1 * sx, oy + 1 * sy)
	spr(50, ox + 2 * sx, oy + 1 * sy)
	spr(52, ox + 0 * sx, oy + 2 * sy)
	spr(53, ox + 1 * sx, oy + 2 * sy)
	spr(54, ox + 2 * sx, oy + 2 * sy)
	spr(55, ox + 0 * sx, oy + 3 * sy)
	spr(56, ox + 1 * sx, oy + 3 * sy)
	spr(57, ox + 2 * sx, oy + 3 * sy)
	spr(51, ox + 0 * sx, oy + 4 * sy)

	spr(8, ox + 0 * sx, oy + 5 * sy)
	spr(9, ox + 1 * sx, oy + 5 * sy)
--	spr(11, ox + 2 * sx, oy + 5 * sy)
	spr(10, ox + 0 * sx, oy + 6 * sy)
	spr(11, ox + 1 * sx, oy + 6 * sy)
	spr(12, ox + 2 * sx, oy + 6 * sy)
--	spr(14, ox + 0 * sx, oy + 7 * sy)
--	spr(15, ox + 1 * sx, oy + 7 * sy)

	local x, y = active_tool % 3, active_tool // 3
	rect(ox + x * sx - 1, oy + y * sy - 1, ox + x * sx + 29, oy + y * sy + 29, 7)
end
:: src/in_game.lua
--[[pod_format="raw",created="2024-08-27 17:11:11",modified="2024-09-12 20:42:26",revision=3561]]
in_game = {}


-- The Board
local tiling = "square"
local gravity = pos(0, 1)

local cells = false
local gems = false
local marks = false

local matches = {}

local prev_cells = false
local prev_gems = false
local prev_stats = false

-- State Machine
local editor_requested = false
local substate = false
local clock = 0.0
local interaction = false

local starting_stats = {
	turn = 0,
	mana = 0,
	colours = {
		[gem_air] = 0,
		[gem_fire] = 0,
		[gem_day] = 0,
		[gem_earth] = 0,
		[gem_water] = 0,
		[gem_night] = 0,
	},
	in_cascade = false,
}
local stats = deep_copy(starting_stats)
local anim_turn = 0
local displayed_mana = 0
local star_seed = 37


-----------------------------------------------------------------------


-- Functions for substate need to be global, because of Lua
-- forward-declaration rule for locals.


function creating_the_board()
--	cells = logic_new_test_cells(tiling)
--	gems = cells:new_grid()
	cells:compute_origin()
	gems.origin = cells.origin
	marks = cells:new_grid()
	matches = {}
	stats = deep_copy(starting_stats)
	anim_turn = 0
	displayed_mana = 0
	star_seed = math.random(37, 6584587)
	return creating_missing_gems
end


function creating_missing_gems()
	if clock == 0.0 then
		logic_fill_gems(cells, gems, marks)
	end
	clock += 1.0 / 8.0
	if clock < 1.0 then
		return creating_missing_gems
	end
	-- Clean-up
	marks:foreachpos(
		function(p, mark)
			if mark.name == "new" then
				marks:del(p)
			end
		end
	)
	return moving_things
end


function moving_things()
	if clock == 0.0 and stats.turn > 0 then
		local something_moved = logic_mark_move(cells, gems, marks)
		if not something_moved then
			return starting_new_turn
		end
	end
	clock += 1.0 / 16.0
	if clock < 1.0 then
		return moving_things
	end
	logic_enact_move(cells, gems, marks)
	return starting_new_turn
end


function starting_new_turn()
	stats.turn += 1
	anim_turn = 20
	stats.in_cascade = false
	return waiting_for_input
end


function waiting_for_input()
	local mx, my, mb, _, _ = mouse()
	if mb == 0x1 then
		local mp = cells:pos(mx, my)
		if gems:get(mp) then
			interaction = { name = "swap", position = mp, start = t() }
			return waiting_for_swap
		end
	end
	if keyp("del") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:set(p, gem_gift)
		marks = cells:new_grid()
		matches = {}
	end
	if keyp("w") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:set(p, gem_rainbow)
		marks:set(p, { name = "new" })
		matches = {}
		return checking_matches
	end
	if keyp("r") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		cells:set(p, (cells:get(p) or 0) | rock_full)
		gems:del(p)
		matches = {}
		return checking_matches
	end
	if keyp("a") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:set(p, gem_air)
		marks:set(p, { name = "new" })
		matches = {}
		return checking_matches
	end
	if keyp("m") then
		return checking_matches
	end
	if keyp("e") then
		editor_requested = true
		return creating_the_board
	end
	if keyp("z") then
		cells = prev_cells:clone()
		gems = prev_gems:clone()
		marks = cells:new_grid()
		stats = deep_copy(prev_stats)
	end
	return waiting_for_input
end


function waiting_for_swap()
	local mx, my, mb, _, _ = mouse()
	if mb != 0x1 then
		interaction = false
		return waiting_for_input
	end
	local mp = cells:pos(mx, my)
	if cells:distance(mp, interaction.position) != 1
		or (not gems:get(mp))
	then
		return waiting_for_swap
	end
	local success = logic_mark_swap(gems, marks, interaction.position, mp)
	interaction = false
	if not success then
		return waiting_for_input
	end
	prev_cells = cells:clone()
	prev_gems = gems:clone()
	prev_stats = deep_copy(stats)
	return swapping_two_gems
end


function swapping_two_gems()
	clock += 1.0 / 16.0
	if clock < 1.0 then
		return swapping_two_gems
	end
	logic_enact_swap(gems, marks)
	return checking_matches
end


function checking_matches()
	matches, marks = logic_find_matches(cells, gems)
	if #matches > 0 then
		local _ = logic_gain_mana(stats, matches)
		return clearing_gems
	end
	return creating_missing_gems
end


function clearing_gems()
	clock += 1.0 / 16.0
	if clock < 1.0 then
		return clearing_gems
	end
	logic_enact_clear(gems, marks)
	return repairing_cells
end


local repairing_done = false
function repairing_cells()
	if clock == 0.0 then
		local is_something_repaired = logic_mark_repair(cells, marks, matches)
		if not is_something_repaired then
			return breaking_things
		end
	end
	clock += 1.0 / 16.0
	if clock < 0.5 then
		repairing_done = false
		return repairing_cells
	elseif not repairing_done then
		logic_enact_repair(cells, marks)
		repairing_done = true
		return repairing_cells
	elseif clock < 1.0 then
		return repairing_cells
	end
	return breaking_things
end


local breaking_done = false
function breaking_things()
	if clock == 0.0 then
		local something_broke = logic_mark_breakage(cells, gems, marks, matches)
		if not something_broke then
			return applying_gravity
		end
		breaking_done = false
	end
	clock += 1.0 / 32.0
	if clock < 0.5 then
		return breaking_things
	elseif not breaking_done then
		logic_enact_breakage(cells, gems, marks)
		breaking_done = true
		return breaking_things
	elseif clock < 1.0 then
		return breaking_things
	end
	return applying_gravity
end


function applying_gravity()
	if clock == 0.0 then
		local some_gems_are_falling = logic_mark_gravity(cells, gems, marks, gravity)
		if not some_gems_are_falling then
			return creating_missing_gems
		end
	end
	clock += 1.0 / 16.0
	if clock < 1.0 then
		return applying_gravity
	end
	logic_enact_gravity(gems, marks)
	return checking_matches
end


-----------------------------------------------------------------------


function in_game:load_from_editor(ed_tiling, ed_cells, ed_gems)
	tiling = ed_tiling
	if tiling == "square" then
		gravity = pos(0, 1)
	else
		gravity = pos(0, 2)
	end
	cells = ed_cells:clone()
	gems = ed_gems:clone()
	marks = cells:new_grid()
	matches = {}
	stats = deep_copy(starting_stats)
	substate = creating_the_board
end


-----------------------------------------------------------------------


function in_game:enter()
	editor_requested = false
	if not substate then
		substate = creating_the_board
	end
end


function in_game:exit()
end


function in_game:update()
	local next = substate()
	if next != substate then
		clock = 0.0
		substate = next
	end
	if anim_turn > 0 then
		anim_turn -= 1
	end
	if displayed_mana < stats.mana then
		displayed_mana += 0.50
	elseif displayed_mana >= stats.mana then
		displayed_mana = stats.mana
	end
	if editor_requested then
		return in_editor
	end
	return false
end


function in_game:draw()
	if not cells then
		return
	end
	-- Starry background
	local hash = star_seed
	for x = 0, 9 do
		for y = 0, 6 do
			hash = hash~(hash << 13); hash = hash~(hash >> 17); hash = hash~(hash << 5)
			spr(120 + (hash%8), 110 + x * 40, 0 + y * 40, (x+y)%2 == 0, (x*y)%2== 0)
		end
	end
	-- Draw the board
	gfx_draw_cells(cells)
	gfx_draw_gems(cells, gems, marks, clock)
	-- Draw the panel
	rectfill(0, 0, 110, 269, 60)
	line(0, 0, 110, 0, 62)
	line(0, 50, 110, 50, 62)
	line(0, 0, 0, 269, 62)
	line(110, 0, 110, 269, 58)
	line(0, 49, 110, 49, 58)
	line(0, 269, 110, 269, 58)
	-- Top bar
	spr(102, 6, 10)
	spr(98, 14, 5)
	gfx_draw_turns(37, 2, stats.turn, anim_turn)
	spr(100, 79, 5)
	spr(102, 101, 10)
	-- Mana
	spr(104, 16, 56)
	gfx_draw_mana(56, 56, flr(displayed_mana), displayed_mana < stats.mana)
	spr(105, 71, 56)
	gfx_draw_mana_bar(8, 71, flr(displayed_mana))
	for i = 0, 5 do
		spr(96, 4, 84 + i * 30)
	end
	cursor(11, 95, 58)
	print("Change Gravity")
	cursor(10, 94, 22)
	print("Change Gravity")
	--[[
	print("")
	print("Air: " .. tostr(stats.colours[gem_air]))
	print("Fire: " .. tostr(stats.colours[gem_fire]))
	print("Day: " .. tostr(stats.colours[gem_day]))
	print("Earth: " .. tostr(stats.colours[gem_earth]))
	print("Water: " .. tostr(stats.colours[gem_water]))
	print("Night: " .. tostr(stats.colours[gem_night]))
	]]--
	-- Update the cursor
	local mx, my = mouse()
	local cursor_pos = cells:pos(mx, my)
	local cell = cells:get(cursor_pos)
	if cell and cell != 0 then
		window { cursor = "grab" }
	else
		window { cursor = "" }
	end
	if false then
		rectfill(mx + 4 - 10, my + 10, mx + 36, my + 20, 7)
		print(tostr(cursor_pos.x)..","..tostr(cursor_pos.y), mx + 6 - 10, my + 12, 0)
	end
end
:: src/sgrid.lua
--[[pod_format="raw",created="2024-08-24 07:17:45",modified="2024-09-12 20:42:26",revision=3222]]
--- Square Grids

--- The origin of the grid, `pos(0, 0)`, is at the top left.


-- Local Constants --------------------------------------------------------


local max_width <const> = 12
local max_height <const> = 9


-- Constructors -----------------------------------------------------------


local metatable = {}


function metatable:new_grid()
	return sgrid_new()
end


function sgrid_new()
	local grid = {
		is_square = true,
	}
	metatable.default_origin(grid)
	setmetatable(grid, { __index = metatable })
	for i = 0, max_width * max_height do
		grid[i] = false
	end
	return grid
end


function metatable:clone()
	local grid = self:new_grid()
	grid.origin = self.origin
	self:foreachpos(function(p, item) grid:set(p, item) end)
	return grid
end


-- Indexing --------------------------------------------------------------------


function metatable:get(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	return self[p.x + (p.y * max_width)]
end


function metatable:set(p, value)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	self[p.x + (p.y * max_width)] = value
end


function metatable:merge(p, state)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	local index = p.x + (p.y * max_width)
	if not self[index] then
		self[index] = {}
	end
	for k, v in pairs(state) do
		self[index][k] = v
	end
end


function metatable:del(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	self[p.x + (p.y * max_width)] = false
end


function metatable:distance(p0, p1)
	return abs(p0.x - p1.x) + abs(p0.y - p1.y)
end


-- Screen Coordinates ---------------------------------------------------------


function metatable:default_origin()
	self.origin = { x = 121, y = 4 }
end


function metatable:compute_origin()
	local min_p = pos(max_width, max_height)
	local max_p = pos(0, 0)
	self:foreachpos(
		function(position, cell)
			if not cell or cell == 0 then
				return
			end
			if position.x < min_p.x then min_p.x = position.x end
			if position.y < min_p.y then min_p.y = position.y end
			if position.x > max_p.x then max_p.x = position.x end
			if position.y > max_p.y then max_p.y = position.y end
		end
	)
	local width = 1 + max_p.x - min_p.x
	local height = 1 + max_p.y - min_p.y
	self.origin = {
		x = 110 + ((480 - 110) // 2) - ((width * 29) // 2) - (min_p.x * 29),
		y = (270 // 2) - ((height * 29) // 2) - (min_p.y * 29),
	}
end


function metatable:coords_origin()
	return self.origin.x, self.origin.y
end


function metatable:coords_cell(p)
	local ox, oy = self:coords_origin()
	return ox + p.x * 29, oy + p.y * 29
end


function metatable:coords_gem(p)
	local ox, oy = self:coords_origin()
	return ox + p.x * 29, oy + p.y * 29
end


function metatable:pos(x, y)
	local ox, oy = self:coords_origin()
	return pos((x - ox) // 29, (y - oy) // 29)
end


-- Iterating -------------------------------------------------------


function metatable:foreachpos(func)
	local p = pos(0, 0)
	for x = 0, max_width do
		for y = 0, max_height do
			local p = pos(x, y)
			local item = self:get(p)
			if item then
				func(p, item)
			end
		end
	end
end	


function metatable:neighbours(p)
	return {
		{ position = p + pos(1, 0), direction = "horizontal" },
		{ position = p + pos(0, 1), direction = "vertical" },
		{ position = p + pos(-1, 0), direction = "horizontal" },
		{ position = p + pos(0, -1), direction = "vertical" },
	}
end


function metatable:blast_radius(p)
	return {
		p + pos(0, 0),
		p + pos(1, 0),
		p + pos(1, 1),
		p + pos(0, 1),
		p + pos(-1, 1),
		p + pos(-1, 0),
		p + pos(-1, -1),
		p + pos(0, -1),
		p + pos(1, -1),
	}
end

:: src/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTI0IDA3OjE3OjA5Iixtb2RpZmllZD0iMjAyNC0w
OS0xMiAyMDo0MjoyNiJdXQ==
:: debug.lua
--[[pod_format="raw",created="2024-08-24 12:45:09",modified="2024-09-01 05:15:15",revision=75]]
-- Detect uninitialized globals and typos
-- from @snowkittykira from the BBS


-- if you're using include(), include this after including everything else,
-- since most included modules will need to assign global variables on load

-- these globals are needed by picotron
_init = _init or false
_draw = _draw or false
_update = _update or false
-- these are used by the picotron terminal
cproj_draw = cproj_draw or false
cproj_update = cproj_update or false
_ = _ or false
_is_terminal_command = _is_terminal_command or false
k = k or false
res = res or false
-- gui needs these
drag_t = drag_t or false

local function unknown_variable (t, k)
  error (debug.traceback ('unknown variable ' .. tostring (k), 2))
end

setmetatable (_G, {
  __index = unknown_variable,
  __newindex = unknown_variable,
})
:: drakma.lua
b64$LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNC0wNC0wNyAwNzo0Mjo0NSIsbW9k
aWZpZWQ9IjIwMjQtMDktMTIgMjA6NDI6MjYiLHJldmlzaW9uPTE0OTFdXQpfbW9kdWxlcyA9IHt9
CgotLSBBICdyZXF1aXJlJyBmdW5jdGlvbiBzaW1pbGFyIHRvIHN0YW5kYXJkIEx1YS4KLS0gSWRl
YSBmcm9tIGVsZ29waGVyIG9uIHRoZSBCQlMKZnVuY3Rpb24gcmVxdWlyZShuYW1lKQoJbG9jYWwg
Y2FjaGVkID0gX21vZHVsZXNbbmFtZV0KCWlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQKCglsb2Nh
bCBmaWxlbmFtZSA9IGZ1bGxwYXRoKG5hbWUgLi4gJy5sdWEnKQoJbG9jYWwgc3JjID0gZmV0Y2go
ZmlsZW5hbWUpIAoKCWlmICh0eXBlKHNyYykgIT0gInN0cmluZyIpIHBhbmljKCJjb3VsZCBub3Qg
aW5jbHVkZSAiIC4uIGZpbGVuYW1lKQoKCS0tIGh0dHBzOi8vd3d3Lmx1YS5vcmcvbWFudWFsLzUu
NC9tYW51YWwuaHRtbCNwZGYtbG9hZAoJLS0gY2h1bmsgbmFtZSAoZm9yIGVycm9yIHJlcG9ydGlu
ZykKCS0tIG1vZGUgKCJ0IiBmb3IgdGV4dCBvbmx5IC0tIG5vIGJpbmFyeSBjaHVuayBsb2FkaW5n
KQoJLS0gX0VOViB1cHZhbHVlCgktLSBAIGlzIGEgc3BlY2lhbCBjaGFyYWN0ZXIgdGhhdCB0ZWxs
cyBkZWJ1Z2dlciB0aGUgc3RyaW5nIGlzIGEgZmlsZW5hbWUKCWxvY2FsIGZ1bmMsIGVyciA9IGxv
YWQoc3JjLCAiQCIgLi4gZmlsZW5hbWUsICJ0IiwgX0VOVikKCWlmIChub3QgZnVuYykgcGFuaWMo
IlN5bnRheCBlcnJvcjoiLCB0b3N0cihlcnIpKQoKCWxvY2FsIG1vZHVsZSA9IGZ1bmMoKQoJX21v
ZHVsZXNbbmFtZV0gPSBtb2R1bGUKCglyZXR1cm4gbW9kdWxlCmVuZAoKCmZ1bmN0aW9uIHBhbmlj
KC4uLikKCWxvY2FsIGFyZ3MgPSB7IC4uLiB9Cglmb3JlYWNoKAoJCWFyZ3MsCgkJZnVuY3Rpb24o
c3RyKQoJCQlzZW5kX21lc3NhZ2UoMywgeyBldmVudCA9ICJyZXBvcnRfZXJyb3IiLCBjb250ZW50
ID0gc3RyIH0pCgkJZW5kCgkpCglzdG9wKCkKZW5kCgoKLS0gVGFibGUgdXRpbGl0eSBmdW5jdGlv
bnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0KCgpmdW5jdGlvbiBkZWVwX2NvcHkodCwgYWxyZWFkeSkKCWlmIChub3QgYWxyZWFkeSkgYWxy
ZWFkeSA9IHt9CglpZiB0eXBlKHQpID09ICJ0YWJsZSIgdGhlbgoJCWlmIGFscmVhZHkgYW5kIGFs
cmVhZHlbdF0gdGhlbgoJCQlyZXR1cm4gYWxyZWFkeVt0XQoJCWVuZAoJCWxvY2FsIG5ldyA9IHt9
CgkJYWxyZWFkeVt0XSA9IG5ldwoJCWZvciBrLCB2IGluIHBhaXJzKHQpIGRvCgkJCW5ld1trXSA9
IGRlZXBfY29weSh2LCBhbHJlYWR5KQoJCWVuZAoJCXJldHVybiBuZXcKCWVsc2UKCQlyZXR1cm4g
dAoJZW5kCmVuZAoKCmZ1bmN0aW9uIHRvc3RycmVjKHQpCglpZiB0eXBlKHQpICE9ICJ0YWJsZSIg
dGhlbgoJCXJldHVybiB0b3N0cih0KQoJZW5kCgkKCWxvY2FsIHMgPSBuaWwKCWZvciBrLCB2IGlu
IHBhaXJzKHQpIGRvCgkJaWYgbm90KHMpIHRoZW4KCQkJcyA9ICJ7ICIKCQllbHNlCgkJCXMgLi49
ICIsICIKCQllbmQKCQlzIC4uPSB0b3N0cihrKSAuLiAiID0gIiAuLiB0b3N0cnJlYyh2KQoJZW5k
CglzIC4uPSAiIH0iCgoJcmV0dXJuIHMKZW5kCgoKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCgpm
dW5jdGlvbiBjbGFtcCh2LCBtaW4sIG1heCkKCWlmIHYgPCBtaW4gdGhlbgoJCXJldHVybiBtaW4K
CWVuZAoJaWYgdiA_IG1heCB0aGVuCgkJcmV0dXJuIG1heAoJZW5kCglyZXR1cm4gdgplbmQKCgpm
dW5jdGlvbiBleHBfZGVjYXkoYSwgYiwgZGVjYXksIGR0KQoJLS0tIExlcnAgc21vb3RoaW5nLCBi
dXQgZnJhbWVyYXRlLWluZGVwZW5kYW50LCBmcm9tIEZyZXlhIEhvbG3DqXIKCS0tLSBodHRwczov
L3d3dy55b3V0dWJlLmNvbS93YXRjaD92PUxTTlF1RkVET3lRCgktLS0gVXNlIGFzIGBhID0gZXhw
X2RlY2F5KGEsIGIsIGRlY2F5LCBkdClgCglyZXR1cm4gYiArIChhIC0gYikgKiBtYXRoLmV4cCgt
IGRlY2F5ICogZHQpCmVuZAoKCi0tIFBvcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKCi0tIFdBUk5JTkc6
IGRvIG5vdCBmb3JnZXQgdGhhdCBgcG9zYCBpcyBhIHJlZmVyZW5jZSB0eXBlLCBub3QgYSB2YWx1
ZToKLS0gYXZvaWQgbW9kaWZ5aW5nIGluIHBsYWNlLgpmdW5jdGlvbiBwb3MoeCwgeSkKCWxvY2Fs
IHAgPSB1c2VyZGF0YSgiaTE2IiwgMikKCXAueCA9IHgKCXAueSA9IHkKCXJldHVybiBwCmVuZAoK
Ci0tIERyYXdpbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKCi0tIEZyb20gU29waGllIG9uIHRoZSBkaXNj
b3JkCmZ1bmN0aW9uIGdldF9kcmF3c3BhY2UoKQogICAgcmV0dXJuIHsKICAgICAgICBjYW1feD1w
ZWVrNCgweDU1MTApLAogICAgICAgIGNhbV95PXBlZWs0KDB4NTUxNCksCiAgICAgICAgY2xpcF9s
PXBlZWsyKDB4NTUyOCksCiAgICAgICAgY2xpcF90PXBlZWsyKDB4NTUyYSksCiAgICAgICAgY2xp
cF9yPXBlZWsyKDB4NTUyYyksCiAgICAgICAgY2xpcF9iPXBlZWsyKDB4NTUyZSksCiAgICB9CmVu
ZAoKCmZ1bmN0aW9uIHNldF9kcmF3c3BhY2UoZHJhd3NwYWNlKQogICAgcG9rZTQoMHg1NTEwLGRy
YXdzcGFjZS5jYW1feCkKICAgIHBva2U0KDB4NTUxNCxkcmF3c3BhY2UuY2FtX3kpCiAgICBwb2tl
MigweDU1MjgsZHJhd3NwYWNlLmNsaXBfbCkKICAgIHBva2UyKDB4NTUyYSxkcmF3c3BhY2UuY2xp
cF90KQogICAgcG9rZTIoMHg1NTJjLGRyYXdzcGFjZS5jbGlwX3IpCiAgICBwb2tlMigweDU1MmUs
ZHJhd3NwYWNlLmNsaXBfYikKZW5k
:: main.lua
--[[pod_format="raw",created="2024-03-30 05:39:34",modified="2024-09-12 20:42:26",revision=4341]]
include "drakma.lua"
include "src/constants.lua"
include "src/sgrid.lua"
include "src/hgrid.lua"
include "src/logic/creation.lua"
include "src/logic/matching.lua"
include "src/logic/spells.lua"
include "src/logic/mechanics.lua"
include "src/gfx.lua"
include "src/in_game.lua"
include "src/in_editor.lua"
include "debug.lua"


local state = in_editor
--local state = in_game
local next_state = false


function _init()
	window { cursor = "" }
	fetch("pal/0.pal"):poke(0x5000)
	state:enter()
end


function _update()
	if next_state then
		state:exit()
		state = next_state
		state:enter()
	end
	next_state = state:update()
end


function _draw()
	state:draw()
	print(string.format("\014% 3.0f", (stat(1) * 100.0)) .. "%", 460, 264, 1)
end
:: .info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTIzIDE4OjQ1OjEzIixtb2RpZmllZD0iMjAyNC0w
OS0xMiAyMDo0MjoyNiIscnVudGltZT0xMCxzdG9yZWQ9IjIwMjQtMDMtMzAgMDY6NTQ6MjQiLHdv
cmtzcGFjZXM9e3tsb2NhdGlvbj0ibWFpbi5sdWEjMzkiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9j
YXRpb249InNyYy9pbl9nYW1lLmx1YSMxNTgiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249
InNyYy9pbl9lZGl0b3IubHVhIzQ4Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJzcmMv
Z2Z4Lmx1YSMxMDEiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InNyYy9zZ3JpZC5sdWEj
MzkiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InNyYy9oZ3JpZC5sdWEjNDUiLHdvcmtz
cGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImRyYWttYS5sdWEjOTUiLHdvcmtzcGFjZV9pbmRleD0x
fSx7bG9jYXRpb249ImdmeC8wLmdmeCIsd29ya3NwYWNlX2luZGV4PTJ9LHtsb2NhdGlvbj0ic2Z4
LzAuc2Z4Iix3b3Jrc3BhY2VfaW5kZXg9NH0se2xvY2F0aW9uPSJwYWwvMC5wYWwiLHdvcmtzcGFj
ZV9pbmRleD03fX1dXQ==
:: [eoc]
