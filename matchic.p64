picotron cartridge // www.picotron.net
version 2

:: docs/
:: docs/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTI2IDE0OjAzOjI1Iixtb2RpZmllZD0iMjAyNC0w
OS0wMSAxNzoxMjoxNiJdXQ==
:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNC0w
OS0wMSAxNzoxMjoxNiIscmV2aXNpb249MzM5N11dbHo0AG8VAAD0XgAA8xd7WzBdPXtibXA9cHh1
AEMgHR0E8P---zwsZmxhZ3M9MCxwYW5feAgAy3k9MCx6b29tPTJ9LDQA8CQ1bPAEHGob8AAcugnA
DNoJCKAMKh8qqgkIgAwqLqoZCHAMKh4cShw6CQgPNVAMSgwZDCoEAPAMGQhQDDoMOQwKDDkMGhkI
DTAMSgxJDEkMGikICwAQqQkAgQ0gDFoMiQwqCgBVagxpDDoUACwaOQoAEDlNAMBJCA0wC1oMGQwK
DBkaAP8oHTALahwqHBpJCA1Q6kkIHVAZqmkIDXAIGWp5CB2ACOkIHaAYqRgdwA0YaRgt8AANaC3w
BG3wFwQBHvEQbxHwBB5vDx8Q8AAevw8PDsAO3w8PDg8NoA4vDx8qrwwA0YAOLw8vKq8PHw4PDXAY
AEAfDy59GgDwFw81UA59Dh8ODm0cDw1QDo0OHA5dHAsPNTAOnQ4sDk0sCzAOjQ48CQAnCiAKADV9
DkwKAEw8Dk08CgDALA5NTAsKMA8QfQ4cFQAwGjAJWwD-IS1MCwpQnS4dTAsaUBytbAsKcAscbXwL
GoAL7AsaoBusGxrAChtsGyrwAAprKvAEag8BIRAWDwEwFB8VDwHxAxQPE8AO3xQPEw8SoA4vFB8q
rwwA0YAOLxQvKq8UHxMPEnAYABHPGAAADQEw-xQDFwBxUA6PFC5tHxUAAAMBhC8TDl0sDxIw_gCR
DzUgDm0ObA49BQEKCgAkLTwjASI9PDcBMSwOPQ8BMhWNLg0BIP0ACgEf7QgBSRAbCAEwGR8aCAHx
AxkPGMAO3xkPGA8XoA4vGR8qrwwA0YAOLxkvKq8ZHxgPF3AYAEAvGS5tGgACFwKgLxgOXRwPF1AO
bfUAAhcCAwABYjAObR5MHvQAUV0OjA4tCgBVTQ6sDh0KACoNPAoAkV0OLA4MDiwODQwBYxpdPgw_
HRsCEQwhAU9QjS4tEwFJECATATAeHx8TAfEDHg8dwA7fHg8dDxygDi8eHyqvDADwB4AOLx4vKi8e
Dm0fHQ8ccA4tHyo9Dn0aAAATATCdDn0XAAAoAyAPHTMDEhwqA2QMDm0sDxwKAAEdAgD1ARFdCwEG
CgAGEwIKCgARLREBEB9mAREtEQEAQQMfLREBUBAlEQEwIx8kEQHxAyMPIsAO3yMPIg8hoA4vIx8q
rwwA0YAOLyMvKq8jHyIPIXAYABHPGAAADwFAfyM_bRgAACECIC8iEAEQIRABkW0OLA59LA8hMPIB
Eo0QAQALAEQ9Hi0sCQJELQ4MDg4AZDwuHA4dPEsCJB08SQMRHRgBFyQYAS9OLTgDThAqFAEwKB8p
FAHwBSgPNMAO3ygPNA85oA4vKB4dLw9dDQDyA4AOLS4NTw9NHzQPOXAOLR4dTxgAABUBkD0qDU8P
DS8UHR0AwVAOLUoNLw8NTxQNHyAANDAOPREA0i80DzkwDj1aDQ8PDV8PAAApAWRNSi1PFB0OACX9
BBgAc08jLU8ZDT8PAJU9XyMNDx4NXxkRAHNPIw0vHg1PEQBEMA8pLRIAAEMAEB8SAIM9LyMNTx4N
LyQAYVB9Tx4dTx0AcVAfNF1PHm8XAHFwDzkfNE0vDgBhHzWADznvCQD-C6AfOa80HzkfNcAMHzlv
NB85LPAADGss8ARsZwEf8A1PPxJAPuAODxYfKg8VDiAOHyofFg7QDg8qPxUuBQBADg81wB4ApBQf
FS8WHxUfFA8TANUPFQ8UDxNPFQ8TDxQfKAABFQARLxUAEC8VADGQPyw_AFATLxUfEz4A-AYeHytg
Dyw-LS8VXy0-LB8VHywPK1ARAD8PNUATACXzAFBPLC8TTywvKx8TLysfNVsANU8tLyIAH2ATAITv
cD8rLn0eHR81gPwD8C7JAR3yPDkvKxAPD-AGDysgHvAFTyzwBw0-LQ0O8AYNDD0ODzXwAx1sHfAB
DawN4A28HcANLB8qjA0OoA0sK4wdDpANLBucHQ4PNXAN-AAtDgYAKwpgBwAm7D0GAP8a3E0OCnAN
vE0OGnANrF0OCpAdbG0OGqAOzQ4awA6tDhrgHm0eGvABCm79AyPwBU0PLOAOoA4PLQ7ADg0OkA4d
DqAOoABAgA4tDgQA0QyADg0PKx0OYA4dCw0OAFIbHW4dGwsAMyuNKxQAEq0SACr9AQYAkHAOLS5t
Li0OcFQA8QkaDyoLDk0OCgsPGg4dDgxgDh0OCRsJDi0GAAERADMtDikEAIAMYA49Lk0uPQkAIP0D
SQD-Im0vCW0OHEBbXQhdW3AOPQ4dDh0OPQ4cgDstHg0eLTtwGyAOrQ4cABuwHm0eHPABDG6mAyPw
AosPK2AO8AQeQB7wBA4PLE4NDQBATR7QLp8F8CkgLg81QB4tHgAODR8PDRwNDgAeLR4gDm0eDA8q
DgwLDgwebQ4QDn0ODB4MHgwOfQ4PNQAOfQ4NHCsA8Al9DgoADo0OTQ6NDgoAPm0OLQ5tPgoADhrf
APAGGg4KEAoAPs0_ChAKMA4aDi0OTQ4tFgDwBnAKAE5NTgoQCpAOKg5NDioOCtAKIBsA-wIgCvAD
Dg0OGvAJDhrwCwrwcegAHSAaDwoDcCzwCg8rDxYUAyLwCRIAIA81FAARHwYAQQ818AsGAPAEBO8r
wA7vLQ6gDg3-LAAOkA4N-AYA8A4cPkw_HA4PNWAuDA4PDR8PDw0OLA4LHw8LDgwuQNMB8AUOCh8Q
Cg4sDgoZCg4MDh0OMA4NDBYAFhkVAABAALEgDhwODA4LGgsOLAYAABYAEAgVAAJhAPACHA4IMC78
AS4YQAgO-AEOKGAGAGAIgA48jjwHABEsbwgBCQBVDQ5MDgwNABB8CgAwkA4cCgCvHA4YoO4YwOjw
MCoBKR8SKgEWULAODd8slgUFMgEXDC0BVTwOLA48JQEDDgAFIAEwXixeAgESCxcBIA8cgAkAMAEi
Hx0xARgLGwERCxsBMBtACxUBESsbARILGwEUCxsBGAsbARULGwEVCxsBbxug7hvA6xsBH6AvHyug
LrAOHy0eEgjwC5AOHywdHkAOPB0eYA5MHR4QDhwPDQ8PDw0cFgDyBGwdHiwPDw8QDw88HQ4gDpwd
HgweAKFcDiAOLB5sHR58MAPxAhweCw4sHjwdHlwOCwAuKw4MEACjDB0ePA4LECsQHhIAch0uDA4L
cBsQAPEFDA4tHgvAGxAeGw48DQ4L8AIbAA4cAeDwAR4QDkwOC7AeIA4NHv8AIRtgCwByAA5MLhsQ
LgsAkgwdHiweOyAOHQwAQFweK2AIAP8YjB4rgA68HiuwDoweK9AObB4r8AEOPB4r8AMOHB4r8AYe
K-AJG-AiNQEdsBYfK2Ae8AAeDy0OPAmBDy0esB4dDywNAPAQDR8sHnAeHRwOHzVgDjweQA4dPA4L
cA5cDjAOTA4bgMsA0DAOPD5APjwOGzAOTB0PAFAdTA4LUB8AEEAFACNQDg8AIQtw7gAABQBhcA4s
PiA_8QHwAywdDgsQDh0sDhuQDjwOGyAOPBYAAbcDEDArABCAgQIQHEwAEBwqAoANLA4MPgA_DEQA
Ew2wAXEOHB0OCw4dIAASHNIBATMAAHMBJBuA9AEAEwAgCxAFAGCgDlwOHC5lAiAOXAELAOoDgMAO
XA4NPA4bCAABqQEw4A5MtAAw4A5chgCP8ACeG-ACm7BbAR3QMi8roB6gHi8tDnAeHQQAQD8sDkBP
AQC3BRQdjgKiDhAeHUwOMA4dPL4AQSweHWyFBBNcuwCwHh2cDiAOfB4dbB6XAfEEEA5cHh08HiwO
Cx4cDhAOPB4dDA0AxQwOCwALLgsADgwuHRAAlR4LICsAHi0ODA8AIRtg6wAACgARsO0AsCAb8AEO
TA4QHvADHg6hHg0OIB7gLkwOAAoAcqAbHiweHQwOAFIucAseXA4AcB0OC4ALHowNALAboAsevA4L
0AsejCwB4AsebA4L8AMLHjwOG-AFpQC-C-AICx4b8Aob8BFDAR3yBhqfK-ACDi8tDl0O8AAODT8s
DkwO8E4DIFwOpgExXA7QMAIwDA5cMwggDC4ZABCwNwIgLzWwBARlARCgEwAAPQEAFAABaAEQHAYF
MCwOAAUABCYAcJAODT4PNT4EBQAjBUEOOwAbbABgoA4NHA5ABQAQDAwAAZ8CIA0saABSPA4gDg22
AmAcPgsQPiw5AFAcDjsgG8UCEHAcAAFxAQEKACQLUAYAEFxOALFcDlAODSw_CzA_PFEAYDwOO0Ab
DgwCQA1MDoAFAEELMB48RgBwLB4bQAseLEwAQRweK3DeAf8DUA4NHiuwCx4LUB4r8AAbYBtwbgl9
Mf0DDgUAAV0JEM1dBnRgDi1OLU4tSAkFTgkSKU0JHwlNCUZfEBAE8PAxAP--Z18dHQT-N18XDx0x
NQAfODUAIV87Df88DQYAPg_GAB0HOwAPBgA4D4YADA_nAR0cNrcATw87DzwEACEXHwwADzgA----
----By8PO4kGHQc7AA8EABkXHwwADzgA--------By8PPIkGHHGPPA89DzuvBgARTwYAMv88AAcA
EAEHABHPFAAXfyAAER8GABePDAAX7wYAAjAAJF88NAARLwYAFQ80ABMvZAAWBFcAFx8pAASDABAH
BwAX3xMAEZ8GABE-BgAYvyUAF28lACZfPFYANv88Eg0ALD88KwAdHxgANv88CA0AE58TABYCLAAX
fz4AA3wABV0AJztPIwATHyMAFhYTABd-uAAIEgAXzzoBAiQBGd9DABYTkgAIqwAP5AEZ8SYjIARw
-zYD4P4F0P4FwP4HsP4HoP4JkP4JgP4LcP4LYP4NUP4NQP4PMP4PIP4REP4RAP42AAkAESAVABFA
IQARYC0AEYA5ABGgRQARwFEAP_D_A5cUDB41jgAfN44Aeh84jgB68zM7A_D-PAXQ-zsFwP88B7D-
Oweg-zwJkP87CYD-PAtw-zsLYP88DVD-Ow1A-zwPMP87DyD-PBEQ-zsRAP88E-87EwAPABMgHwAT
QC8AE2A-ABOATwAToF8AE8BvAD-g-zyvAA4OgBEPMQB7AEIBBD0DE59JAyDgbggAML7QLgcAEI4F
APAATsD_Bg89sA0PO-4ADQwu8gGgTg0MPg0Mjg0MDvoB8QUuDQz_BmCeDQxeDQwuDQw_UAz_CwcC
wT4NDO4NDH4gDg0Mzi8A8gA_EJ4NDP4CDQwOAAz_BA0EABADNgAQAEUAQgwQ-gBaAFEgDG4NDG8A
AzcCQb4NDH5eABFgbgAQcBwAEI5EAgFAAJEeDaBeDQzusA4mACGewDoAz9BeDQzO4K4NDE4NcK8T
HPAT8BW-NA8x0N80LzGg3zRPMYBfNF8yDzEPMA80XzFgTzR-MgsA8AkvMk8xQE80jzIPMU8yTzEw
PzT-MgE-MSAIAEEDPzEQCAC-HzEfMBAvNP8yBS8IABlxLzIPMf8yAQwAch8xDzD-MgIMADIwDzQM
ABAfGAAADABQPzAQPzFyACAwIAgA8Q4BPzAwTzF-Mg8xXzJPMEBPMW8yHzE-Mk8wYF8xP8UA-wYv
Ml8wgE8x3zCgLzHfMNAPMb8w8BUIBxwDIgFQnzQPMi8mAQAOAB8PKgEQQjAPND8sARGfDQAhTzIx
AWG-Mg8wXzI0ARGvPwAQPx4AEzI9AWAPMg8xjzL7AAC9AAFeACQyLxkAEn8RAGA0HzIPMC8KABIx
KQEB_AACfQAQL3YAARUAEDJaAABWAAAXACAPMBIAAi4AIzIfbwBFHzSfMoIBVC8wHzS-IgAAZwBB
HzQvMBEAIQ80DwASMcQARQ8wrzKfARRfDwACogGhbzIPME8yDzE-MqkBMX8yH8QAIU8ysAEAIAET
Lx4AETCsARIw-wABuwEASwFSHzAfMR_-AT8PMj_-ATYAIgEQcKIAYKBPNC8xQMUB4IBfNC8xMC80
TzFgbzQvlwEAcQAhUE-rABAP6gFwMRAfND8yP78BAEsBAUUBVDEPMAAfyAECywASHxIAAE8BMCAv
NLoBQQAPNB-kAEEgLzR-KwEgMR-yAACBAAA0AACHAZIwHzFPMEAPND-FAfBSMi8wQE5gPzEvMj7w
Ay8xXkA-NIAdAB8xTjBdHFAdDzIMEC5AXUwwDBsOkD0bXCAMHhAtHCA9SzxgLRscEC1rHB5ALSss
AB1bDBsuQC07HAAdSwwrLjAtGwwbLAANDCsMDg4A-x4LDA0rDA4ALDsMCz4wHRwNOx4APCtOUDwr
LgAsjmAcXiAMjoBuMH6wLoAu8BNkAR3xBTZPNPADLgAOTzMPMgAuwA4vMw8yDQBwDi8zDrAOPQUC
8AcPMU2gDD0PMgxDDAs9DHAeDQwNG4Mb0gTwBkAeLRwzBRQFBBMcDh0bMA49CyMUBQIAogMLPQsw
Di0LIwUQALUEAy0LDDAMKwwTBBIAVCscQCwjDwBjFAMsUC4TDAB3BRQDLkAOLQ8AYw4tMA4dCxEA
EB8SAEMtCzAtEQDCCg8qGhQDHRswCx0MEgCCOgMEAysMQCwOAEcFGhMEXwAvBBNfAAIIEAAaPQ8A
Jy0LfgALfQAAAgAAfAATK3sAAAIAAXwAr-8wASxw-zUE8BGUAR3wEYQvNPUBLkAODyoODzL1AS4N
MC4N9AEuDSAuDfUDLg0QGQCADfQDDgwODRAFADFkTmQMAHAuDVReDVQuCQDwAH4rDg2ODRCuCwwP
DA8KCQwA8A_dDgsPDB8KCa0gLVMOCyoJDVMtMB4NVB4pDg1UHg0LABNeCQAxZE1kCAAm9AMHACL_
CAQAcQ79CED-MAfZAB9L2QBhJS8Q2gBUEQ8PDw7bAFIRHw8PDtwAEC8XAAPeAB8q3gCcFRXeABAW
nisE3gBTFh8UDxPeAAAXAA-eAKQjGh3dAFQbDxkPGN0AUxsfGQ8Y3QAAFwAE3QATHdwALx5N3ACR
FB-cAFQgDx4PHdwAUyAfHg8d3AAAFwAP3ACjFCTcAFQlDyMPItwAUyUfIw8i3AAAFwAP3ABeC_AJ
Vm80DzE-5AkADgkC-AcB6AlAHzQPMhoIAMkHAhUAAfIJAGQIJF8yJwkTP80IEDBYCADHCDIvMS8X
ABEwPAgRHyoARD8wLzT-CQEQCgAbCAEdAB0xFgoQH60IDxgKAgFxAB9vGgoBIB80hgANHAoB0AkB
KgAEIAoRH18AHh8gCgA5CgLOAAkoChE-wwoDFQAGLgoBmAADVwAPOAoAAtIANC8xTz4KEU86AABe
ADY-MB9GCjM-Mi8XAABXAAA0AAFOCmIfMh8xXzBuAAF1AQBUClcvME80DxUAAVoKAZEJFjAoAANe
Ci8-MFwKOw6EDg8xAP------------------------------------------------_lUG09Nn19
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNC0w
OS0wMSAxNzoxMjoxNiIsc3RvcmVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Il1d
:: map/
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNC0w
OS0wMSAwNzozNDozNSIscmV2aXNpb249MzA3NV1dbHo0AMEAAABZEAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD-------_x0zIwMDAzMDAwNDAwMDYMAC81MIAAWxMxCAATNYAALzYw
AQBbFzb8ABMxDAAPAQBVBHwBAAABEzAMAA_AAVkTMXQAEzB4ABcxjAAPAAFVEzaEAAQMAC81MAEA
--------nvEJIiksaGlkZGVuPWZhbHNlLHBhbl94PTQ3CQDSeT0wLHRpbGVfaD0yOQoAEHcKAIB6
b29tPTF9fQ==
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNC0w
OS0wMSAxNzoxMjoxNiIsc3RvcmVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Il1d
:: pal/
:: pal/0.pal
b64$LS1bW3BvZCxiZ19jb2xvcj0wLGJsYWNrZXN0X2NvbG9yPTAsY3JlYXRlZD0iMjAyNC0wOC0y
MyAxODo1OTowOSIsaGlkZGVuPXtbMF09dHJ1ZSx0cnVlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLHRydWUsdHJ1ZSx0cnVlLGZhbHNlLHRydWUsdHJ1ZSxmYWxzZSxmYWxzZSxmYWxzZSxm
YWxzZSxmYWxzZSx0cnVlLHRydWUsZmFsc2UsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSxmYWxzZSx0cnVl
LHRydWUsdHJ1ZSx0cnVlLGZhbHNlLHRydWUsdHJ1ZSx0cnVlLHRydWUsZmFsc2UsdHJ1ZSx0cnVl
LHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0
cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSxmYWxzZSxmYWxzZSxm
YWxzZSxmYWxzZSxmYWxzZSxmYWxzZX0saGlkZGVuX3RvZ2dsZXM9e1swXT10cnVlLHRydWUsdHJ1
ZSx0cnVlfSxpY29uPXVzZXJkYXRhKCJ1OCIsMTYsMTYsIjAwMDEwMTAxMDEwMTAxMDEwMTAxMDEw
MDAwMDAwMDAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNjAxMDAwMDAwMDAwMDAxMDcwNzA3MDcwNzA3
MDcwNzA2MDYwMTAwMDAwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDYwNjA2MDEwMDAwMDAwMTA3MDcw
NzA3MDcwNzA3MDcwNjA2MDYwNjAxMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAw
MDEwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwMTAwMDAwMTA3MDcwNjA2MDEwMTBkMGQwMTAxMDcw
NzAxMDAwMDAxMDcwNzA2MDYwMTAxMGQwZDAxMDEwNzA3MDEwMDAwMDEwNzA3MDEwMTA3MDcwNjA2
MGQwZDA3MDcwMTAwMDAwMTA3MDcwMTAxMDcwNzA2MDYwZDBkMDcwNzAxMDAwMDAxMDcwNzBkMGQw
MTAxMGQwZDA2MDYwNzA3MDEwMDAwMDEwNzA3MGQwZDAxMDEwZDBkMDYwNjA3MDcwMTAwMDAwMTA3
MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzAxMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEw
MDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAwIiksbG9ja2VkPXtbMF09ZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2V9LG1vZGlmaWVkPSIyMDI0LTA5LTAxIDE3
OjEyOjE2Iixva3BhbF92ZXJzaW9uPSIxLjAuMyIscmV2aXNpb249MzE3MCx0ZXN0X2N1YmVfY29s
b3JzPXtbMF09ezE1LDMxLDR9LHszMSw0LDIwfSx7NCwyMCwyMX0sezEwLDksMjV9LHs5LDI1LDI0
fSx7OCwyNCwyfSx7MjYsMTEsMjd9LHsxMSwyNywzfSx7MjcsMywxOX0sezI4LDE3LDE5fSx7Mjgs
MTIsMTZ9LHsxMiwxNiwxfSx7NiwyOSwxM30sezI5LDEzLDE4fSx7MTMsMTgsMX0sezcsMjMsMTR9
LHsyMywxNCwxM30sezE0LDMwLDE4fSx7Nyw2LDIyfSx7NiwyMiw1fSx7MjIsNSwyMX0sezEsMSwx
fSx7MSwxLDF9LHsxLDEsMX19LHdoaXRlc3RfY29sb3I9N11dbHo0AOkBAAAVAgAA-wV1c2VyZGF0
YSgiaTMyIiw2NCwiMAEABvAFODIzZjM4MDA5ODQ3M2YwMDlmNTEIACBhMwIAMTAwZgEA8G8wMDc0
MWY2NTAwYTgyNTkyMDBlMjQ5YmEwMGVmODNjNTAwZjhiYmQ5MDA3NzJjMTYwMGEyMzIxOTAwZDU0
ZjIxMDBmMzgyNTcwMGZjYmM5YzAwNjc0OTEzMDA5YzcxMWEwMGQ2YTIyNTAwZWRjNDU0MDBmYmUx
OTkwMDJkNTMYAPAWMzE2ZTMyMDA1MGEzMmMwMDg3ZDQ1NjAwYmZmMjk1MDAxNjU4NQgA8Bw3Nzk3
ZDAwMjBiNGIzMDA1Y2Q4ZDIwMGFjZjZmMDAwNDcyMjg2MDA1ZTI2IADQOGQzYmVkMDBhZTgxZrAA
QDhjNGagABBlAgBAMDBiNwIAQDAwZTMCAEAwMGY0AgAAyAAAAgBAMDAxZAIAQDAwMmUCAEAwMDQ2
AgBAMDA5YgIAQDAwYzECAOAwMDRmNGIzZTAwNzM2YeAA8BM5ZThmNzQwMGFhOWQ4NTAwYmViNWE0
MDA1ODU5NWQwMDY4AgBRMDA2Zja5ABE3AQBQMDA4NjivAfEGMDNmMjcyYTAwNWIzNzM0MDA2NjQw
YABQMDQ5NDQoACA1YxABgDM2MWQ0NSIp
:: pal/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTIzIDE4OjU0OjE5Iixtb2RpZmllZD0iMjAyNC0w
OS0wMSAxNzoxMjoxNiJdXQ==
:: sfx/
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM1Iixtb2RpZmllZD0iMjAyNC0w
OS0wMSAxNzoxMjoxNiIscmV2aXNpb249MzE2NV1dbHo0ABoBAABSCAAA8CdweHUAAygAAAQABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDBAUGBwAP-5AICQoLDwwPDQ8ODw8QAPAADQ8RDxIPEw8UDxUP
Fg8XEwDxAQ8YDxkPGg8bDxwPHQ8eDx8UAPEAIA8hDyIPIw8kDyUPJg8nFADxACgPKQ8qDysPLA8t
Dy4PLxQA8QAwDzEPMg8zDzQPNQ82DzcUAP8FOA85DzoPOw88Dz0PPg8-AA--8P8BAOv-J1oBEAYP
IBABIAEgAfAAAhACDBABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDDAAAh9EMAAc
H0AwAPIf-wEA3L-4D0AADUD--7DwcAoA--9kH-8BAP_ZUP----8g
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Iixtb2RpZmllZD0iMjAyNC0w
OS0wMSAxNzoxMjoxNiIsc3RvcmVkPSIyMDI0LTAzLTMwIDA1OjM5OjM0Il1d
:: src/
:: src/logic/
:: src/logic/creation.lua
--[[pod_format="raw",created="2024-08-30 06:25:09",modified="2024-09-01 17:12:16",revision=820]]
--- Board Creation Logic


function logic_new_test_cells(tiling, for_editor)
	local grid
	local size
	if tiling == "square" then
		grid = sgrid_new()
		for x = 2, 9 do
			for y = 0, 7 do
				grid:set(pos(x, y), cell_good)
			end
		end
	elseif tiling == "hex" then
		grid = hgrid_new()
		for i = 0, 4 do
			for y = i, 12 - i, 2 do
				grid:set(pos(6 + i, y), cell_good)
				grid:set(pos(6 - i, y), cell_good)
			end
		end
	end
	return grid
end


------------------------------------------------------------------------


local function random_gem()
	if false and rnd() < 0.05 then
		local gem = gem_rainbow + flr(rnd(6))
		if gem == gem_robot_E then
			gem += flr(rnd(4))
		end
		return gem
	end
	return gem_color_first + flr(rnd(gem_color_last - gem_color_first))
end


function logic_fill_gem_at(cells, gems, states, p)
	local cell = cells:get(p) or 0
	if (cell & cell_mask == 0) or (cell & rock_mask != 0) then
		return
	end
	local test = gems.is_square and logic_test_sqr_match_at or logic_test_hex_match_at
	local gem = gems:get(p)
	if not gem then
		local attempts = 0
		local found = false
		while attempts < 8 and not found do
			gem = random_gem()
			gems:set(p, gem)
			found = not test(gems, p)
			attempts += 1
		end
		if attempts == 16 then
			gem = gem_gift
			gems:set(p, gem)
		end
		states:set(p, { name = "new" })
	end
end


function logic_fill_gems(cells, gems, states)
	-- TODO: transform into a coroutine
	-- TODO: fill in reverse gravity order
	cells:foreachpos(
		function(p, _)
			logic_fill_gem_at(cells, gems, states, p)
		end
	)
end

:: src/logic/matching.lua
--[[pod_format="raw",created="2024-08-24 08:12:55",modified="2024-08-31 13:21:41",revision=2898]]
--- Matching Logic

-- The matching algorithm has two phases:
--
-- 1. First, a linear sweep through all the gems, and for each gem involved in a match
--    creates a mark registering which direction(s) matched.
-- 2. Then a flood-fill algorithm is used to group matches together.


local function logic_is_matching(gem1, gem2)
	if (not gem1) or (not gem2) then
		return false
	end
	
	-- Only colored gems can match.
	if (gem1 < gem_color_first) or (gem1 > gem_color_last) then
		return false
	end
	if (gem2 < gem_color_first) or (gem2 > gem_color_last) then
		return false
	end

	return (gem1 == gem2) or (gem1 == gem_rainbow)
		or (gem2 == gem_rainbow)
end


--------------------------------------------------------------------------


local function test_3(gems, p0, p1, p2)
	local gem0 = gems:get(p0)
	local gem1 = gems:get(p1)
	local gem2 = gems:get(p2)
	return logic_is_matching(gem0, gem1)
		and logic_is_matching(gem0, gem2)
		and logic_is_matching(gem1, gem2)
end


local function test_4(gems, p0, p1, p2, p3)
	local gem0 = gems:get(p0)
	local gem1 = gems:get(p1)
	local gem2 = gems:get(p2)
	local gem3 = gems:get(p3)
	return logic_is_matching(gem0, gem1)
		and logic_is_matching(gem0, gem2)
		and logic_is_matching(gem0, gem3)
		and logic_is_matching(gem1, gem2)
		and logic_is_matching(gem1, gem3)
		and logic_is_matching(gem2, gem3)
end


function logic_test_sqr_match_at(gems, p)
	local S = p + pos(0, 1)
	local SS = p + pos(0, 2)
	local N = p + pos(0, -1)
	local NN = p + pos(0, -2)
	local E = p + pos(1, 0)
	local EE = p + pos(2, 0)
	local W = p + pos(-1, 0)
	local WW = p + pos(-2, 0)
	local SE = p + pos(1, 1)
	local SW = p + pos(-1, 1)
	local NE = p + pos(1, -1)
	local NW = p + pos(-1, -1)
	return test_3(gems, SS, S, p) or test_3(gems, S, p, N) or test_3(gems, p, N, NN)
		or test_3(gems, EE, E, p) or test_3(gems, E, p, W) or test_3(gems, p, W, WW)
		or test_4(gems, p, S, SE, E) or test_4(gems, p, S, SW, W) 
		or test_4(gems, p, N, NE, E) or test_4(gems, p, N, NW, W)
end


function logic_test_hex_match_at(gems, p)
	local S = p + pos(0, 2)
	local S_S = p + pos(0, 4)
	local N = p + pos(0, -2)
	local N_N = p + pos(0, -4)
	local SE = p + pos(1, 1)
	local SE_SE = p + pos(2, 2)
	local SW = p + pos(-1, 1)
	local SW_SW = p + pos(-2, 2)
	local NE = p + pos(1, -1)
	local NE_NE = p + pos(2, -2)
	local NW = p + pos(-1, -1)
	local NW_NW = p + pos(-2, -2)
	local E = p + pos(2, 0)
	local W = p + pos(-2, 0)
	return test_3(gems, S_S, S, p) or test_3(gems, S, p, N) or test_3(gems, p, N, N_N)
		or test_3(gems, SE_SE, SE, p) or test_3(gems, SE, p, NW) or test_3(gems, p, NW, NW_NW)
		or test_3(gems, NE_NE, NE, p) or test_3(gems, NE, p, SW) or test_3(gems, p, SW, SW_SW)
		or test_4(gems, p, SE, S, SW) or test_4(gems, p, NE, N, NW)
		or test_4(gems, p, NE, E, SE) or test_4(gems, p, NW, W, SW)
end


local function check_3_and_mark(gems, p0, p1, p2, mark, marks)
	if test_3(gems, p0, p1, p2) then
		marks:merge(p0, mark)
		marks:merge(p1, mark)
		marks:merge(p2, mark)
	end
end


local function check_4_and_mark(gems, p0, p1, p2, p3, mark, marks)
	if test_4(gems, p0, p1, p2, p3) then
		marks:merge(p0, mark)
		marks:merge(p1, mark)
		marks:merge(p2, mark)
		marks:merge(p3, mark)
	end
end


local function mark_sgrid_matches_at(gems, p0, marks)
	check_3_and_mark( gems,
		p0,
		p0 + pos(0, 1),
		p0 + pos(0, 2),
		{ name = "matching", vertical = true }, marks )
	check_3_and_mark( gems,
		p0,
		p0 + pos(1, 0),
		p0 + pos(2, 0),
		{ name = "matching", horizontal= true }, marks )
	check_4_and_mark( gems,
		p0,
		p0 + pos(1, 0),
		p0 + pos(0, 1),
		p0 + pos(1, 1),
		{ name = "matching", vertical = true, horizontal = true }, marks )
end


local function mark_hgrid_matches_at(gems, p0, marks)
	check_3_and_mark( gems,
		p0,
		p0 + pos(0, 2),
		p0 + pos(0, 4),
		{ name = "matching", vertical = true }, marks )
	check_3_and_mark( gems,
		p0,
		p0 + pos(1, 1),
		p0 + pos(2, 2),
		{ name = "matching", horizontal_SE = true }, marks )
	check_3_and_mark( gems,
		p0,
		p0 + pos(1, -1),
		p0 + pos(2, -2),
		{ name = "matching", horizontal_NE = true }, marks )
	local p1 = p0 + pos(1, 1)
	local p2 = p0 + pos(1, -1)
	local p3 = p0 + pos(2, 0)
	if test_4(gems, p0, p1, p2, p3) then
		marks:merge(p0, { name = "matching", vertical = true, horizontal_NE = true, horizontal_SE = true})
		marks:merge(p1, { name = "matching", vertical = true, horizontal_SE = true })
		marks:merge(p2, { name = "matching", vertical = true, horizontal_NE = true })
		marks:merge(p3, { name = "matching", vertical = true, horizontal_NE = true, horizontal_SE = true})
	end
end


local function mark_all_matches(gems)
	local marks = gems:new_grid()
	if gems.is_square then
		gems:foreachpos(
			function(p, _gem)
				mark_sgrid_matches_at(gems, p, marks)
			end
		)
	elseif gems.is_hex then
		gems:foreachpos(
			function(p, _gem)
				mark_hgrid_matches_at(gems, p, marks)
			end
		)
	end
	return marks
end


---------------------------------------------------------------------------


local function group_this_match(cells, gems, marks, p)
	-- A simple flood-fill algorithm to group all
	-- intersecting linear matches together.
	local colour = gem_rainbow
	local positions = {}
	local one_good_cell = false
	local remaining = { p }
	local rainbows = {}
	while #remaining > 0 do
		local current = deli(remaining)
		local gem = gems:get(current)
		local mark = marks:get(current)
		if mark and mark.name == "matching"
			and (not mark.counted)
			and logic_is_matching(colour, gem)
		then
			if gem == gem_rainbow then
				-- Rainbow gems can be part of multiple matches,
				-- so they need to be unflagged at the end.
				add(rainbows, current)
			else
				colour = gem
			end
			add(positions, current)
			marks:merge(current, { counted = true })
			local cell = cells:get(current)
			if cell and cell & cell_mask == cell_good then
				one_good_cell = true
			end
			local neighbours = gems:neighbours(current)
			foreach(
				neighbours,
				function(n)
					local s = marks:get(n.position)
					if not s then
						return
					end
					if s and s.name == "matching"
						and (not s.counted)
						and s[n.direction]
					then
						add(remaining, n.position)
					end
				end
			)
		end
	end
	foreach(
		rainbows,
		function(p)
			marks:merge(p, { counted = false })
		end
	)
	return { colour = colour, positions = positions, one_good_cell = one_good_cell }
end


function logic_find_matches(cells, gems)
	local marks = mark_all_matches(gems)
	local matches = {}
	marks:foreachpos(
		function(p, mark)
			if mark and mark.name == "matching"
				and (not mark.counted)
			then
				local match = group_this_match(cells, gems, marks, p)
				if match.colour == gem_rainbow then
					-- Ignore, as this is probably a stray rainbow that was unflagged
					-- at the end of `count_this_match`.
					-- TODO: an edge case is when there is a legitime match of
					-- only rainbow gems (e.g. 3 rainbows surrounded by black things).
				else
					add(matches, match)
				end
			end
		end
	)
	return matches, marks
end
:: src/logic/mechanics.lua
--[[pod_format="raw",created="2024-08-30 06:41:59",modified="2024-09-01 17:12:16",revision=910]]
--- Core Mechanics Logic


function logic_mark_gravity(cells, gems, marks, gravity)
	local some_gems_are_falling = false
	gems:foreachpos(
		function(p, gem)
			local below = p + gravity
			local distance = 0
			local cell_below = cells:get(below) or cell_none
			while (cell_below & cell_mask != cell_none)
				and (cell_below & rock_mask == 0)
			do
				if (not gems:get(below)) then
					some_gems_are_falling = true
					distance += 1
				end
				below += gravity
				cell_below = cells:get(below) or cell_none
			end
			if distance > 0 then
				marks:set(p, { name = "falling", target = p + distance * gravity })
			end
		end
	)
	return some_gems_are_falling
end


function logic_enact_gravity(gems, marks)
	local fell_gems = {}
	marks:foreachpos(
		function(p, mark)
			if mark.name == "falling" then
				local new_p = mark.target
				add(fell_gems, { gem = gems:get(p), pos = new_p })
				gems:del(p)
				marks:del(p)
			end
		end
	)
	foreach(fell_gems,
		function(fell_gem)
			gems:set(fell_gem.pos, fell_gem.gem)
			marks:del(fell_gem.pos)
		end
	)
end


------------------------------------------------------------------------


function logic_mark_swap(gems, marks, source, target)
	local gem0 = gems:get(source)
	local gem1 = gems:get(target)
	local test = gems.is_square and logic_test_sqr_match_at or logic_test_hex_match_at
	gems:set(source, gem1)
	gems:set(target, gem0)
	local matched = test(gems, target) or test(gems, source)
	gems:set(source, gem0)
	gems:set(target, gem1)
	if not matched then
		return false
	end
	marks:set(source, {
		name = "swapping",
		selected = true,
		target = target,
	})
	marks:set(target, {
		name = "swapping",
		target = source,
	})
	return true
end


function logic_enact_swap(gems, marks)
	local reinsert = {}
	marks:foreachpos(
		function(p, mark)
			if mark.name == "swapping" then
				add(reinsert, { gem = gems:get(p), position = mark.target })
				gems:del(p)
				marks:del(p)
			end
		end
	)
	foreach(
		reinsert,
		function(r) gems:set(r.position, r.gem) end
	)
end


-------------------------------------------------------------------------


function logic_enact_clear(gems, marks)
	marks:foreachpos(
		function(p, mark)
			if mark.name == "matching" then
				gems:del(p)
				marks:del(p)
			end
		end
	)
end

-------------------------------------------------------------------------


function logic_mark_repair(cells, marks, matches)
	local is_something_repaired = false
	foreach(
		matches,
		function(match)
			if match.one_good_cell then
				foreach(
					match.positions,
					function(position)
						local cell = cells:get(position) or 0
						if cell & cell_mask == cell_bad then
							marks:set(position, { name = "repaired" })
							is_something_repaired = true
						end
					end
				)
			end
		end
	)
	return is_something_repaired
end


function logic_enact_repair(cells, marks)
	local to_be_unmarked = {}
	marks:foreachpos(
		function(position, mark)
			if mark.name == "repaired" then
				local cell = cells:get(position)
				cell = (cell & ~cell_mask) | cell_good
				cells:set(position, cell)
				add(to_be_unmarked, position)
			end
		end
	)
	foreach(to_be_unmarked, function(p) marks:del(p) end)
end


----------------------------------------------------------------------


function logic_mark_breakage(cells, gems, marks, matches)
	local something_broke = false
	foreach(
		matches,
		function(match)
			foreach(
				match.positions,
				function(position)
					local neighbours = cells:neighbours(position)
					foreach(
						neighbours,
						function(n)
							local cell = (cells:get(n.position) or 0) & rock_mask
							if cell >= rock_full and cell <= rock_broken then
								marks:set(n.position, { name = "broken" })
								something_broke = true
							end
							local gem = gems:get(n.position) or 0
							if #match.positions > 3 then
								if gem == gem_cat or gem == gem_bat
									or gem == gem_robot_asleep
								then
									marks:set(n.position, { name = "broken" })
									something_broke = true
								elseif gem == gem_robot then
									gems:set(n.position, gem_robot_asleep2)
								end
							end
						end
					)
				end
			)
		end
	)
	return something_broke
end


function logic_enact_breakage(cells, gems, marks)
	local to_be_unmarked = {}
	marks:foreachpos(
		function(position, mark)
			if mark.name == "broken" then
				local cell = cells:get(position) or 0
				if cell & rock_mask == rock_full then
					cells:set(position, (cell & cell_mask) | rock_cracked)
				elseif cell & rock_mask == rock_cracked then
					cells:set(position, (cell & cell_mask) | rock_broken)
				elseif cell & rock_mask == rock_broken then
					cells:set(position, (cell & cell_mask))
				end
				local gem = gems:get(position) or 0
				if gem == gem_cat or gem == gem_bat
					or gem == gem_robot_asleep
				then
					gems:del(position)
				end
				add(to_be_unmarked, position)
			end
		end
	)
	foreach(to_be_unmarked, function(p) marks:del(p) end)
end


-----------------------------------------------------------------------


function logic_mark_move(cells, gems, marks)
	local something_moved = false
	local movers = {}
	gems:foreachpos(
		function(position, gem)
			if gem == gem_cat or gem == gem_bat or gem == gem_robot then
				add(movers, position)
			elseif gem == gem_robot_asleep2 then
				gems:set(position, gem_robot_asleep)
			elseif gem == gem_robot_asleep then
				gems:set(position, gem_robot)
			end
		end
	)
	foreach(
		movers,
		function(position)
			local neighbours = cells:neighbours(position)
			local possibilities = {}
			foreach(
				neighbours,
				function(neighbour)
					local cell = cells:get(neighbour.position) or 0
					local gem = gems:get(neighbour.position) or 0
					if (cell & rock_mask == 0)
						and (cell & cell_mask != 0)
						and (gem < gem_rainbow)
					then
						add(possibilities, neighbour.position)
					end
				end
			)
			if #possibilities > 0 then
				something_moved = true
				local target = possibilities[math.random(1, #possibilities)]
				local moving_gem = gems:get(position)
				gems:del(position)
				local target_gem = gems:get(target)
				gems:set(target, moving_gem)
				local source_gem
				logic_fill_gem_at(cells, gems, marks, position)
				source_gem = gems:get(position)
				marks:set(target, {
					name = "moving",
					source = position,
					target = target,
					moving_gem = moving_gem,
					target_gem = target_gem,
					source_gem = source_gem,
				})
				if moving_gem == gem_bat or moving_gem == gem_robot then
					local cell = cells:get(target)
					cell = cell_bad | (cell & rock_mask)
					cells:set(target, cell)
				end
			end
		end
	)
	return something_moved
end


function logic_enact_move(cells, gems, marks)
	marks:foreachpos(
		function(position, mark)
			if mark.name == "moving" then
				if mark.moving_gem == gem_robot then
				end
			end
		end
	)
	marks:foreachpos(function(p, _) marks:del(p) end)
end
:: src/logic/spells.lua
--[[pod_format="raw",created="2024-08-30 06:37:36",modified="2024-08-31 13:18:07",revision=172]]
--- Spell Logic


function logic_gain_mana(stats, matches)
	foreach(
		matches,
		function(match)
			local count = #(match.positions)
			if count > 3 then
				stats.mana += 10 * (count - 3)
			end
			if stats.in_cascade then
				stats.mana += 5
			end
			stats.in_cascade = true
			if match.colour == gem_rainbow then
				foreach(
					{ gem_air, gem_fire, gem_day, gem_earth, gem_water, gem_night },
					function(g) stats.colour[g] += count end
				)
			else
				stats.colours[match.colour] += count
			end
		end
	)
end

:: src/logic/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTMwIDA2OjI0OjM5Iixtb2RpZmllZD0iMjAyNC0w
OS0wMSAxNzoxMjoxNiJdXQ==
:: src/constants.lua
--[[pod_format="raw",created="2024-08-24 15:17:10",modified="2024-09-01 17:12:16",revision=2625]]
--- Match3 Global Constants


-- Gems and cells ------------------------------------------------------

-- Color gems
gem_air = 0x01
gem_fire = 0x02
gem_day = 0x03
gem_earth = 0x04
gem_water = 0x05
gem_night = 0x06
gem_rainbow = 0x07

gem_color_first = gem_air
gem_color_last = gem_rainbow

-- Black gems
gem_gift = 0x08
gem_bomb = 0x09
gem_cat = 0x0a
gem_bat = 0x0b
gem_robot = 0x0c
gem_robot_asleep = 0x0d
gem_robot_asleep2 = 0x0e

gem_names = {
	[gem_air] = "Air",
	[gem_fire] = "Fire",
	[gem_day] = "Day",
	[gem_earth] = "Earth",
	[gem_water] = "Water",
	[gem_night] = "Night",
	[gem_rainbow] = "Rainbow",
}

gem_sprites = {
	[gem_air] = 1,
	[gem_fire] = 2,
	[gem_day] = 3,
	[gem_earth] = 4,
	[gem_water] = 5,
	[gem_night] = 6,
	[gem_rainbow] = 7,
	[gem_gift] = 8,
	[gem_bomb] = 9,
	[gem_cat] = 10,
	[gem_bat] = 11,
	[gem_robot] = 12,
	[gem_robot_asleep] = 13,
	[gem_robot_asleep2] = 13,
}

-- Cells
cell_mask = 0x03
cell_none = 0x00
cell_good = 0x01
cell_bad = 0x02

-- Rocks
rock_full = 0x10
rock_cracked = 0x20
rock_broken = 0x30
cell_door = 0x40
cell_chest_air = 0x50
cell_chest_fire = 0x60
cell_chest_day = 0x70
cell_chest_earth = 0x80
cell_chest_water = 0x90
cell_chest_night = 0xa0

rock_mask = 0xf0

:: src/gfx.lua
--[[pod_format="raw",created="2024-08-24 12:06:13",modified="2024-09-01 17:12:16",revision=3469]]
--- Graphics


local cell_width = 29
local cell_height = 29


function gfx_draw_cells(cells)
	local function draw_cell(p, cell)
		local x, y = cells:coords_cell(p)
		local sprite
		if cells.is_square then
			if cell & cell_mask == cell_good then
				sprite = 32
				sprite += (p.x + p.y) % 2
--			elseif cell & cell_mask == cell_bad then
--				sprite = 39
			elseif cell & cell_mask == cell_bad then
				sprite = 34
				sprite += p.y % 2
			end
		elseif cells.is_hex then
			if cell & cell_mask == cell_good then
				sprite = 40
				sprite += (p.y + (p.x * 3)) % 3
--			elseif cell & cell_mask == cell_bad then
--				sprite = 47
			elseif cell & cell_mask == cell_bad then
				sprite = 43
			end
		end
		spr(sprite, x, y)
		x, y = cells:coords_gem(p)
		if cell and cell & cell_mask == cell_bad then
			pal(53, 58)
		end
		if cell & rock_mask == 0 then
		elseif cell & rock_mask == rock_full then
			spr(48, x, y)
		elseif cell & rock_mask == rock_cracked then
			spr(49, x, y)
		elseif cell & rock_mask == rock_broken then
			spr(50, x, y)
		elseif cell & rock_mask == cell_door then
			spr(51, x, y)
		elseif cell & rock_mask == cell_chest_air then
			spr(52, x, y)
		elseif cell & rock_mask == cell_chest_fire then
			spr(53, x, y)
		elseif cell & rock_mask == cell_chest_day then
			spr(54, x, y)
		elseif cell & rock_mask == cell_chest_earth then
			spr(55, x, y)
		elseif cell & rock_mask == cell_chest_water then
			spr(56, x, y)
		elseif cell & rock_mask == cell_chest_night then
			spr(57, x, y)
		end	
		pal(53, 53)
	end
	cells:foreachpos(draw_cell)
	-- TODO: move border construction out of the hot loop
	local function draw_borders(p, cell)
		local x, y = cells:coords_cell(p)
		if cells.is_square then
			local cell_S = cells:get(p + pos(0, 1))
			local cell_W = cells:get(p + pos(-1, 0))
			local cell_E = cells:get(p + pos(1, 0))
			local cell_N = cells:get(p + pos(0, -1))
			if cell & cell_good != 0 then
				if not cell_S or cell_S & cell_good == 0 then
					line(x, y + 28, x + 28, y + 28, 53)
				end
				if not cell_E or cell_E & cell_good == 0 then
					line(x + 28, y, x + 28, y + 28, 53)
				end
				if not cell_N or cell_N & cell_good == 0 then
					line(x, y, x + 28, y, 57)
				end
				if not cell_W or cell_W & cell_good == 0 then
					line(x, y, x, y + 28, 57)
				end
			elseif cell & cell_bad != 0 then
				if cell_N and cell_N & cell_good != 0 then
					line(x, y, x + 28, y, 58)
				end
				if cell_W and cell_W & cell_good != 0 then
					line(x, y, x, y + 28, 58)
				end
			end
		end
	end
	cells:foreachpos(draw_borders)
end


-----------------------------------------------------------------------


local function scaled_gem(sprite, x, y, size)
	local w, h = flr(29 * size + 0.5) // 2 * 2 + 1, flr(29 * size + 0.5) // 2 * 2 + 1
	local x, y = x + ((29 - w) / 2), y + ((29 - h) / 2)
	sspr(sprite, 0, 0, 29, 29, x, y, w, h)
end


local function draw_exploded_gem(sprite, x, y, clock, new_clock)
	local size = 32 * new_clock
	local colour = 10 + (sprite - 1) * 5
	oval(x - size, y - size, x + 29 + size, y + 29 + size, colour + 1)
	if clock < 0.25 then
		ovalfill(x + 2, y + 2, x + 25, y + 25, 7)
	elseif clock < 0.50 then
		ovalfill(x + 2, y + 2, x + 25, y + 25, colour + 2)
	elseif clock < 0.75 then
		ovalfill(x + 1, y + 1, x + 27, y + 27, colour + 1)
	elseif clock < 1.0 then
		ovalfill(x, y, x + 29, y + 29, colour)
	end
end


function gfx_draw_gems(cells, gems, states, clock)
	local function draw_gem(p, gem)
		local x, y = gems:coords_gem(p)
		local sprite = gem_sprites[gem]
		local cell = cells:get(p)
		if cell and cell & cell_mask == cell_bad then
			pal(53, 58)
		end
		local state = states:get(p)
		if not state or state.name == "broken" then
			spr(sprite, x, y)
		elseif state.name == "new" then
			scaled_gem(sprite, x, y, clock)
		elseif state.name == "matching" then
		elseif state.name == "falling" or state.name == "swapping"
		then
			local dest_x, dest_y = gems:coords_gem(state.target)
			local ix, iy = x + clock * (dest_x - x), y + clock * (dest_y - y)
			spr(sprite, ix, iy)
		elseif state.name == "moving" then
			x, y = gems:coords_gem(state.source, gem)
			local dest_x, dest_y = gems:coords_gem(state.target)
			scaled_gem(gem_sprites[state.target_gem], dest_x, dest_y, 1.0)
		end
		pal(53, 53)	
	end
	gems:foreachpos(draw_gem)
	local new_clock = clock * clock * clock * clock
	gems:foreachpos(
		function(p, gem)
			local x, y = gems:coords_gem(p)
			local sprite = gem_sprites[gem]
			local cell = cells:get(p)
			if cell and cell & cell_mask == cell_bad then
				pal(53, 58)
			end
			local state = states:get(p)
			if state and state.name == "matching" then
				draw_exploded_gem(sprite, x, y, clock, new_clock)
			elseif state and state.name == "moving" then
				x, y = gems:coords_gem(state.source, gem)
				local dest_x, dest_y = gems:coords_gem(state.target)
				local ix, iy = x + clock * (dest_x - x), y + clock * (dest_y - y)
				spr(gem_sprites[state.moving_gem], ix, iy)
			end
		end
	)
end

:: src/hgrid.lua
--[[pod_format="raw",created="2024-08-25 08:16:09",modified="2024-09-01 17:12:16",revision=2373]]
--- Hex Grids

--- Hex grids use the "double height" coordinate system:
---
---     (0,0)         (2,0)         (4,0)
---            (1,1)         (3,1)
---     (0,2)         (2,2)         (4,2)
---            (1,3)         (3,3)
---     (0,4)         (2,4)         (4,4)
---
--- The origin of the grid, `pos(0, 0)`, is at the top left.


-- Local Constants --------------------------------------------------------


local max_width <const> = 13
local max_height <const> = 8


-- Constructors -----------------------------------------------------------


local metatable = {}


function hgrid_new()
	local grid = { is_hex = true }
	setmetatable(grid, { __index = metatable })
	for i = 0, max_width * max_height do
		grid[i] = false
	end
	return grid
end


function metatable:new_grid()
	return hgrid_new()
end


function metatable:clone()
	local grid = self:new_grid()
	self:foreachpos(function(p, item) grid:set(p, item) end)
	return grid
end


-- Indexing ------------------------------------------------------------


function metatable:get(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	return self[p.x + ((p.y // 2) * max_width)]
end


function metatable:set(p, value)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	self[p.x + ((p.y // 2) * max_width)] = value
end


function metatable:merge(p, state)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	local index = p.x + ((p.y // 2) * max_width)
	if not self[index] then
		self[index] = {}
	end
	for k, v in pairs(state) do
		self[index][k] = v
	end
end


function metatable:del(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= 2 * max_height - (p.x % 2) then
		return false
	end
	self[p.x + ((p.y // 2) * max_width)] = false
end


-- Screen Coordinates ---------------------------------------------------------


function metatable:coords_origin()
	return 116, 7
end


function metatable:coords_cell(p)
	local ox, oy = self:coords_origin()
	return ox + p.x * 27, oy + p.y * 16
end


function metatable:coords_gem(p)
	local ox, oy = self:coords_origin()
	return ox + (p.x * 27) + 3, oy + (p.y * 16) + 1
end


function metatable:pos(x, y)
	local ox, oy = self:coords_origin()
	x -= ox
	y -= oy + 1
	local px, py = x // 27, y // 16
	local dx, dy = x - (px * 27), y - (py * 16)
	if dx < 8 then
		if (px + py) % 2 == 0 and dy < 14 + (-2 * dx) then
			px -= 1
			py -= 1
		elseif (px + py) % 2 != 0 and dy > -1 + (2 * dx) then
			px -= 1
		end
	end
	py = (2 * ((py - (px % 2)) // 2)) + (px % 2)
	return pos(px, py)
end


function metatable:distance(p0, p1)
	-- TODO: is this correct?
	return (abs(p0.x - p1.x) + abs(p0.y - p1.y)) // 2
end


-- Iterating ----------------------------------------------------------


function metatable:foreachpos(func)
	for x = 0, max_width do
		for y = x % 2, max_height * 2 - 1, 2 do
			local p = pos(x, y)
			local item = self:get(p)
			if item then
				func(p, item)
			end
		end
	end
end	


function metatable:neighbours(p)
	return {
		{ position = p + pos(1, 1), direction = "horizontal_SE" },
		{ position = p + pos(0, 2), direction = "vertical" },
		{ position = p + pos(-1, 1), direction = "horizontal_NE" },
		{ position = p + pos(-1, -1), direction = "horizontal_SE" },
		{ position = p + pos(0, -2), direction = "vertical" },
		{ position = p + pos(1, -1), direction = "horizontal_NE" },
	}
end

:: src/in_editor.lua
--[[pod_format="raw",created="2024-08-30 08:13:35",modified="2024-09-01 08:29:15",revision=428]]
in_editor = {}

local tiling = "square"

local cells = false
local gems = false
local marks = false

local active_tool = 0
local ox, oy = 8, 8
local sx, sy = 32, 32

local tools = {
	[0] = cell_none,
	cell_good,
	cell_bad,
	rock_full,
	rock_cracked,
	rock_broken,
	cell_chest_air,
	cell_chest_fire,
	cell_chest_day,
	cell_chest_earth,
	cell_chest_water,
	cell_chest_night,
	cell_door,
	false,
	false,
	gem_gift,
	gem_bomb,
	false,
	gem_cat,
	gem_bat,
	gem_robot,
	false,
	false,
}



function in_editor:enter()
	if not cells then
		cells = logic_new_test_cells(tiling, true)
		gems = cells:new_grid()
	end
	marks = cells:new_grid()
end


function in_editor:exit()
end


function in_editor:update()
	if keyp("s") then
		tiling = "square"
		cells = false
		in_editor:enter()
	end
	if keyp("h") then
		tiling = "hex"
		cells = false
		in_editor:enter()
	end
	local mx, my, mb, _, _ = mouse()
	if mb == 0x1 and mx < 110 then
		mx -= ox
		my -= oy
		local x, y = clamp(mx // sx, 0, 2), clamp(my // sy, 0, 7)
		active_tool = clamp(x + 3 * y, 0, 22)
	elseif mb == 0x1 then
		local mp = cells:pos(mx, my)
		local tool = tools[active_tool]
		if tool == cell_none then
			local cell = cells:get(mp) or cell_none
			cell = (cell & ~cell_mask) | tool
			cells:set(mp, cell)
			gems:del(mp)
		elseif tool == cell_good or tool == cell_bad then
			local cell = cells:get(mp) or cell_none
			cell = (cell & ~cell_mask) | tool
			cells:set(mp, cell)
		elseif active_tool <= 12 then 
			local cell = cells:get(mp) or cell_none
			cell = (cell & cell_mask) | tool
			cells:set(mp, cell)
			gems:del(mp)
		elseif cells:get(mp) and cells:get(mp) & cell_mask != 0 then
			gems:set(mp, tool)
			local cell = cells:get(mp) or cell_none
			cell = (cell & cell_mask)
			cells:set(mp, cell)
		end
	end
	if mb == 0x2 then
		local mp = cells:pos(mx, my)
		local cell = cells:get(mp) or cell_none
		cell = (cell & cell_mask)
		cells:set(mp, cell)
		gems:del(mp)
	end
	if keyp("g") then
		in_game:load_from_editor(tiling, cells, gems)
		return in_game
	end
	return false
end


function in_editor:draw()
	cls(63)
	if not cells then
		return
	end
	local mx, _, _, _, _ = mouse()
	if mx <= 110 then
		window { cursor = "pointer" }
	else
		window { cursor = "crosshair" }
	end
	gfx_draw_cells(cells)
	gfx_draw_gems(cells, gems, marks, 0.0)
	-- Draw the panel
	rectfill(0, 0, 110, 269, 55)
	rectfill(ox, oy, ox + 28, oy + 28, 63)
	spr(33, ox + 1 * sx, oy + 0 * sy)
	spr(34, ox + 2 * sx, oy + 0 * sy)
	spr(48, ox + 0 * sx, oy + 1 * sy)
	spr(49, ox + 1 * sx, oy + 1 * sy)
	spr(50, ox + 2 * sx, oy + 1 * sy)
	spr(52, ox + 0 * sx, oy + 2 * sy)
	spr(53, ox + 1 * sx, oy + 2 * sy)
	spr(54, ox + 2 * sx, oy + 2 * sy)
	spr(55, ox + 0 * sx, oy + 3 * sy)
	spr(56, ox + 1 * sx, oy + 3 * sy)
	spr(57, ox + 2 * sx, oy + 3 * sy)
	spr(51, ox + 0 * sx, oy + 4 * sy)

	spr(8, ox + 0 * sx, oy + 5 * sy)
	spr(9, ox + 1 * sx, oy + 5 * sy)
--	spr(11, ox + 2 * sx, oy + 5 * sy)
	spr(10, ox + 0 * sx, oy + 6 * sy)
	spr(11, ox + 1 * sx, oy + 6 * sy)
	spr(12, ox + 2 * sx, oy + 6 * sy)
--	spr(14, ox + 0 * sx, oy + 7 * sy)
--	spr(15, ox + 1 * sx, oy + 7 * sy)

	local x, y = active_tool % 3, active_tool // 3
	rect(ox + x * sx - 1, oy + y * sy - 1, ox + x * sx + 29, oy + y * sy + 29, 7)
end
:: src/in_game.lua
--[[pod_format="raw",created="2024-08-27 17:11:11",modified="2024-09-01 17:12:16",revision=2468]]
in_game = {}


-- The Board
local tiling = "square"
local gravity = pos(0, 1)

local cells = false
local gems = false
local marks = false

local matches = {}

local prev_cells = false
local prev_gems = false
local prev_stats = false

-- State Machine
local editor_requested = false
local substate = false
local clock = 0.0
local interaction = false

local starting_stats = {
	turn = 0,
	mana = 0,
	colours = {
		[gem_air] = 0,
		[gem_fire] = 0,
		[gem_day] = 0,
		[gem_earth] = 0,
		[gem_water] = 0,
		[gem_night] = 0,
	},
	in_cascade = false,
}
local stats = deep_copy(starting_stats)


-----------------------------------------------------------------------


-- Functions for substate need to be global, because of Lua
-- forward-declaration rule for locals.


function creating_the_board()
	cells = logic_new_test_cells(tiling)
	gems = cells:new_grid()
	marks = cells:new_grid()
	matches = {}
	stats = deep_copy(starting_stats)
	return creating_missing_gems
end


function creating_missing_gems()
	if clock == 0.0 then
		logic_fill_gems(cells, gems, marks)
	end
	clock += 1.0 / 8.0
	if clock < 1.0 then
		return creating_missing_gems
	end
	-- Clean-up
	marks:foreachpos(
		function(p, mark)
			if mark.name == "new" then
				marks:del(p)
			end
		end
	)
	return moving_things
end


function moving_things()
	if clock == 0.0 then
		local something_moved = logic_mark_move(cells, gems, marks)
		if not something_moved then
			return starting_new_turn
		end
	end
	clock += 1.0 / 16.0
	if clock < 1.0 then
		return moving_things
	end
	logic_enact_move(cells, gems, marks)
	return starting_new_turn
end


function starting_new_turn()
	stats.turn += 1
	stats.in_cascade = false
	return waiting_for_input
end


function waiting_for_input()
	local mx, my, mb, _, _ = mouse()
	if mb == 0x1 then
		local mp = cells:pos(mx, my)
		if gems:get(mp) then
			interaction = { name = "swap", position = mp, start = t() }
			return waiting_for_swap
		end
	end
	if keyp("del") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:set(p, gem_gift)
		marks = cells:new_grid()
		matches = {}
	end
	if keyp("w") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:set(p, gem_rainbow)
		marks:set(p, { name = "new" })
		matches = {}
		return checking_matches
	end
	if keyp("r") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		cells:set(p, (cells:get(p) or 0) | rock_full)
		gems:del(p)
		matches = {}
		return checking_matches
	end
	if keyp("a") then
		local mx, my = mouse()
		local p = cells:pos(mx, my)
		gems:set(p, gem_air)
		marks:set(p, { name = "new" })
		matches = {}
		return checking_matches
	end
	if keyp("m") then
		return checking_matches
	end
	if keyp("e") then
		editor_requested = true
		return creating_the_board
	end
	if keyp("z") then
		cells = prev_cells:clone()
		gems = prev_gems:clone()
		marks = cells:new_grid()
		stats = deep_copy(prev_stats)
	end
	return waiting_for_input
end


function waiting_for_swap()
	local mx, my, mb, _, _ = mouse()
	if mb != 0x1 then
		interaction = false
		return waiting_for_input
	end
	local mp = cells:pos(mx, my)
	if cells:distance(mp, interaction.position) != 1
		or (not gems:get(mp))
	then
		return waiting_for_swap
	end
	local success = logic_mark_swap(gems, marks, interaction.position, mp)
	interaction = false
	if not success then
		return waiting_for_input
	end
	prev_cells = cells:clone()
	prev_gems = gems:clone()
	prev_stats = deep_copy(stats)
	return swapping_two_gems
end


function swapping_two_gems()
	clock += 1.0 / 16.0
	if clock < 1.0 then
		return swapping_two_gems
	end
	logic_enact_swap(gems, marks)
	return checking_matches
end


function checking_matches()
	matches, marks = logic_find_matches(cells, gems)
	if #matches > 0 then
		logic_gain_mana(stats, matches)
		return clearing_gems
	end
	return creating_missing_gems
end


function clearing_gems()
	clock += 1.0 / 16.0
	if clock < 1.0 then
		return clearing_gems
	end
	logic_enact_clear(gems, marks)
	return repairing_cells
end


local repairing_done = false
function repairing_cells()
	if clock == 0.0 then
		local is_something_repaired = logic_mark_repair(cells, marks, matches)
		if not is_something_repaired then
			return breaking_things
		end
	end
	clock += 1.0 / 16.0
	if clock < 0.5 then
		repairing_done = false
		return repairing_cells
	elseif not repairing_done then
		logic_enact_repair(cells, marks)
		repairing_done = true
		return repairing_cells
	elseif clock < 1.0 then
		return repairing_cells
	end
	return breaking_things
end


local breaking_done = false
function breaking_things()
	if clock == 0.0 then
		local something_broke = logic_mark_breakage(cells, gems, marks, matches)
		if not something_broke then
			return applying_gravity
		end
		breaking_done = false
	end
	clock += 1.0 / 32.0
	if clock < 0.5 then
		return breaking_things
	elseif not breaking_done then
		logic_enact_breakage(cells, gems, marks)
		breaking_done = true
		return breaking_things
	elseif clock < 1.0 then
		return breaking_things
	end
	return applying_gravity
end


function applying_gravity()
	if clock == 0.0 then
		local some_gems_are_falling = logic_mark_gravity(cells, gems, marks, gravity)
		if not some_gems_are_falling then
			return creating_missing_gems
		end
	end
	clock += 1.0 / 16.0
	if clock < 1.0 then
		return applying_gravity
	end
	logic_enact_gravity(gems, marks)
	return checking_matches
end


-----------------------------------------------------------------------


function in_game:load_from_editor(ed_tiling, ed_cells, ed_gems)
	tiling = ed_tiling
	if tiling == "square" then
		gravity = pos(0, 1)
	else
		gravity = pos(0, 2)
	end
	cells = ed_cells:clone()
	gems = ed_gems:clone()
	marks = cells:new_grid()
	matches = {}
	stats = deep_copy(starting_stats)
	substate = creating_missing_gems
end


-----------------------------------------------------------------------


function in_game:enter()
	editor_requested = false
	if not substate then
		substate = creating_the_board
	end
end


function in_game:exit()
end


function in_game:update()
	local next = substate()
	if next != substate then
		clock = 0.0
		substate = next
	end
	if editor_requested then
		return in_editor
	end
	return false
end


function in_game:draw()
	cls(63)
	if not cells then
		return
	end
	-- Draw the board
	gfx_draw_cells(cells)
	gfx_draw_gems(cells, gems, marks, clock)
	-- Draw the panel
	rectfill(0, 0, 110, 269, 55)
	-- Display match counts
	cursor(4, 4, 7)
	print("Turn: " .. tostr(stats.turn))
	print("Mana: " .. tostr(stats.mana))
	print("")
	print("Air: " .. tostr(stats.colours[gem_air]))
	print("Fire: " .. tostr(stats.colours[gem_fire]))
	print("Day: " .. tostr(stats.colours[gem_day]))
	print("Earth: " .. tostr(stats.colours[gem_earth]))
	print("Water: " .. tostr(stats.colours[gem_water]))
	print("Night: " .. tostr(stats.colours[gem_night]))
	-- Update the cursor
	local mx, my = mouse()
	local cursor_pos = cells:pos(mx, my)
	if cells:get(cursor_pos) then
		window { cursor = "grab" }
	else
		window { cursor = "" }
	end
	if false then
		rectfill(mx + 4 - 10, my + 10, mx + 36, my + 20, 7)
		print(tostr(cursor_pos.x)..","..tostr(cursor_pos.y), mx + 6 - 10, my + 12, 0)
	end
end
:: src/sgrid.lua
--[[pod_format="raw",created="2024-08-24 07:17:45",modified="2024-09-01 17:12:16",revision=2890]]
--- Square Grids

--- The origin of the grid, `pos(0, 0)`, is at the top left.


-- Local Constants --------------------------------------------------------


local max_width <const> = 12
local max_height <const> = 9


-- Constructors -----------------------------------------------------------


local metatable = {}


function metatable:new_grid()
	return sgrid_new()
end


function sgrid_new()
	local grid = { is_square = true }
	setmetatable(grid, { __index = metatable })
	for i = 0, max_width * max_height do
		grid[i] = false
	end
	return grid
end


function metatable:clone()
	local grid = self:new_grid()
	self:foreachpos(function(p, item) grid:set(p, item) end)
	return grid
end


-- Indexing --------------------------------------------------------------------


function metatable:get(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	return self[p.x + (p.y * max_width)]
end


function metatable:set(p, value)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	self[p.x + (p.y * max_width)] = value
end


function metatable:merge(p, state)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	local index = p.x + (p.y * max_width)
	if not self[index] then
		self[index] = {}
	end
	for k, v in pairs(state) do
		self[index][k] = v
	end
end


function metatable:del(p)
	if p.x < 0 or p.y < 0 or p.x >= max_width or p.y >= max_height then
		return false
	end
	self[p.x + (p.y * max_width)] = false
end


-- Screen Coordinates ---------------------------------------------------------


function metatable:coords_origin()
	return 121, 4
end


function metatable:coords_cell(p)
	local ox, oy = self:coords_origin()
	return ox + p.x * 29, oy + p.y * 29
end


function metatable:coords_gem(p)
	local ox, oy = self:coords_origin()
	return ox + p.x * 29, oy + p.y * 29
end


function metatable:pos(x, y)
	local ox, oy = self:coords_origin()
	return pos((x - ox) // 29, (y - oy) // 29)
end


function metatable:distance(p0, p1)
	return abs(p0.x - p1.x) + abs(p0.y - p1.y)
end


-- Iterating -------------------------------------------------------


function metatable:foreachpos(func)
	local p = pos(0, 0)
	for x = 0, max_width do
		for y = 0, max_height do
			local p = pos(x, y)
			local item = self:get(p)
			if item then
				func(p, item)
			end
		end
	end
end	


function metatable:neighbours(p)
	return {
		{ position = p + pos(1, 0), direction = "horizontal" },
		{ position = p + pos(0, 1), direction = "vertical" },
		{ position = p + pos(-1, 0), direction = "horizontal" },
		{ position = p + pos(0, -1), direction = "vertical" },
	}
end

:: src/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTI0IDA3OjE3OjA5Iixtb2RpZmllZD0iMjAyNC0w
OS0wMSAxNzoxMjoxNiJdXQ==
:: debug.lua
--[[pod_format="raw",created="2024-08-24 12:45:09",modified="2024-09-01 05:15:15",revision=75]]
-- Detect uninitialized globals and typos
-- from @snowkittykira from the BBS


-- if you're using include(), include this after including everything else,
-- since most included modules will need to assign global variables on load

-- these globals are needed by picotron
_init = _init or false
_draw = _draw or false
_update = _update or false
-- these are used by the picotron terminal
cproj_draw = cproj_draw or false
cproj_update = cproj_update or false
_ = _ or false
_is_terminal_command = _is_terminal_command or false
k = k or false
res = res or false
-- gui needs these
drag_t = drag_t or false

local function unknown_variable (t, k)
  error (debug.traceback ('unknown variable ' .. tostring (k), 2))
end

setmetatable (_G, {
  __index = unknown_variable,
  __newindex = unknown_variable,
})
:: drakma.lua
--[[pod_format="raw",created="2024-04-07 07:42:45",modified="2024-08-31 11:21:24",revision=1451]]
_modules = {}

-- A 'require' function similar to standard Lua.
-- Idea from elgopher on the BBS
function require(name)
	local cached = _modules[name]
	if (cached) return cached

	local filename = fullpath(name .. '.lua')
	local src = fetch(filename) 

	if (type(src) != "string") panic("could not include " .. filename)

	-- https://www.lua.org/manual/5.4/manual.html#pdf-load
	-- chunk name (for error reporting)
	-- mode ("t" for text only -- no binary chunk loading)
	-- _ENV upvalue
	-- @ is a special character that tells debugger the string is a filename
	local func, err = load(src, "@" .. filename, "t", _ENV)
	if (not func) panic("Syntax error:", tostr(err))

	local module = func()
	_modules[name] = module

	return module
end


function panic(...)
	local args = { ... }
	foreach(
		args,
		function(str)
			send_message(3, { event = "report_error", content = str })
		end
	)
	stop()
end


-- Table utility functions --------------------------------------------------------


function deep_copy(t, already)
	if (not already) already = {}
	if type(t) == "table" then
		if already and already[t] then
			return already[t]
		end
		local new = {}
		already[t] = new
		for k, v in pairs(t) do
			new[k] = deep_copy(v, already)
		end
		return new
	else
		return t
	end
end


function tostrrec(t)
	if type(t) != "table" then
		return tostr(t)
	end
	
	local s = nil
	for k, v in pairs(t) do
		if not(s) then
			s = "{ "
		else
			s ..= ", "
		end
		s ..= tostr(k) .. " = " .. tostrrec(v)
	end
	s ..= " }"

	return s
end


--------------------------------------------------------------------------------


function clamp(v, min, max)
	if v < min then
		return min
	end
	if v > max then
		return max
	end
	return v
end


-- Pos --------------------------------------------------------------------------


-- WARNING: do not forget that `pos` is a reference type, not a value:
-- avoid modifying in place.
function pos(x, y)
	local p = userdata("i16", 2)
	p.x = x
	p.y = y
	return p
end


-- Drawing -------------------------------------------------------------------------


-- From Sophie on the discord
function get_drawspace()
    return {
        cam_x=peek4(0x5510),
        cam_y=peek4(0x5514),
        clip_l=peek2(0x5528),
        clip_t=peek2(0x552a),
        clip_r=peek2(0x552c),
        clip_b=peek2(0x552e),
    }
end


function set_drawspace(drawspace)
    poke4(0x5510,drawspace.cam_x)
    poke4(0x5514,drawspace.cam_y)
    poke2(0x5528,drawspace.clip_l)
    poke2(0x552a,drawspace.clip_t)
    poke2(0x552c,drawspace.clip_r)
    poke2(0x552e,drawspace.clip_b)
end

:: main.lua
--[[pod_format="raw",created="2024-03-30 05:39:34",modified="2024-09-01 17:12:16",revision=3564]]
include "drakma.lua"
include "src/constants.lua"
include "src/sgrid.lua"
include "src/hgrid.lua"
include "src/logic/creation.lua"
include "src/logic/matching.lua"
include "src/logic/spells.lua"
include "src/logic/mechanics.lua"
include "src/gfx.lua"
include "src/in_game.lua"
include "src/in_editor.lua"
include "debug.lua"


local state = in_editor
--local state = in_game
local next_state = false


function _init()
	window { cursor = "" }
	fetch("pal/0.pal"):poke(0x5000)
	state:enter()
end


function _update()
	if next_state then
		state:exit()
		state = next_state
		state:enter()
	end
	next_state = state:update()
end


function _draw()
	state:draw()
	print(string.format("\014% 3.0f", (stat(1) * 100.0)) .. "%", 1, 264, 7)
end
:: .info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTIzIDE4OjQ1OjEzIixtb2RpZmllZD0iMjAyNC0w
OS0wMSAxNzoxMjoxNiIscnVudGltZT0xMCxzdG9yZWQ9IjIwMjQtMDMtMzAgMDY6NTQ6MjQiLHdv
cmtzcGFjZXM9e3tsb2NhdGlvbj0ibWFpbi5sdWEjMTYiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9j
YXRpb249InNyYy9nZngubHVhIzEzMiIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ic3Jj
L2luX2dhbWUubHVhIzI0MyIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ic3JjL2xvZ2lj
L21lY2hhbmljcy5sdWEjMTczIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJzcmMvbG9n
aWMvY3JlYXRpb24ubHVhIzU4Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJzcmMvc2dy
aWQubHVhIzQ4Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJzcmMvaGdyaWQubHVhIzEi
LHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InNyYy9jb25zdGFudHMubHVhIzUxIix3b3Jr
c3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJnZngvMC5nZngiLHdvcmtzcGFjZV9pbmRleD0yfSx7
bG9jYXRpb249InNmeC8wLnNmeCIsd29ya3NwYWNlX2luZGV4PTR9LHtsb2NhdGlvbj0icGFsLzAu
cGFsIix3b3Jrc3BhY2VfaW5kZXg9N319XV0=
:: [eoc]
