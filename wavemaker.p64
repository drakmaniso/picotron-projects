picotron cartridge // www.picotron.net
version 2

:: fonts/
:: gfx/
:: map/
:: pal/
:: sfx/
:: src/
:: src/sfx/
:: src/ui/
:: src/wavetables/
:: changelog.txt
--[[pod_format="raw",created="2026-01-31 19:58:41",icon=userdata("u8",16,16,"00000101010101010101010101000000000104040404040404040404040100000107010404040404040404040404010000010104040404040404040404040100000104040404040404040404040401000107010404040404040404040404010000010104040404040404040404040100000104040404040404040404040401000107010404040404040404040404010000010104040404040404040404040100000104040404040404040404040401000107010404040404040404040401010000010101010101010101010101070100000101070707070707070707070401000000010404040404040404040401000000000001010101010101010101000000"),modified="2026-02-19 21:34:53",revision=15384]]
Version 0.2.1, aka #wavemaker-???:

- Changed: when there is a selection spanning multiple rows, the jump step is
  now implicitly set to 0; only the preview key (ENTER) retain the previous
  behavior of adding the selection length to the jump step. While it was
  sometimes convenient, the previous behavior was also sometimes very surprising
  and inconvenient.
- Fixed: the number of patterns is now 128 like in the default tracker; this
  is hardcoded for now, since the info stored in sfx files is wrong (says 64).
- Fixed: the maximum number of tracks is now 255; the default tracker is
  supposed to support 384 tracks, but only actually support 256, since there is
  only 1 byte reserved for track IDs in the sfx format... Also, the info
  stored in sfx files is wrong (says 512).
- Fixed: the modulation target of reversed knobs (filter LP and shaper cut) was
  not reversed.
- Fixed: missing undo checkpoints in synth view.
- Fixed: default instrument was played when overwriting sustained notes.
  
Version 0.2.0, aka #wavemaker-7:

- Added: scrollbar for the tracker; it also shows the position of bar divisions
  and of the current selection.
- Changed: the DELETE key now doesn't jump to next row; use the "'" (single
  quote) key to delete and jump (aka rest).
- Changed: replaced the "create new track" dialog with a more comprehensive
  channel dialog, with allows to mute the current track, clone it, create a
  new empty track, or pick an existing one. The dialog is accessed by clicking
  on the channel header.
- Added: oscilloscope for the synth nodes.
- Changed: all the oscilloscopes are now synced on zero-crossings (thanks to
  abledbody on discord for the suggestion).
- Added: right-click a channel header to mute it.
- Added: double-click a channel header to enter a track number manually.
- Added: visualization for the shaper and the echo effects.
- Changed: a lot or UI polishing, especially in the synth part.
- Fixed: when music stopped playing by reaching the stop marker, the "follow
  played" status was not reset.

Version 0.1.1, aka #wavemaker-6:

- Fixed: opening the new track dialog was resetting the speed of whichever track
  was on this channel (thanks to cheez_itz_12oz on the discord for the bug
  report).

Version 0.1.0, aka #wavemaker-5:

- Added: level meter (in the panel), showing the level in dB of the audio output.
- Added: "+" button at the bottom of muted channels, to initialize a new track
  and assign it to the channel.
- Added: direct access to various tools at the bottom of the screen.
- Added: "pattern" tool, to view and reorder (via drag and drop) patterns.
- Added: "channels" tool, to quickly assign tracks to channels.
- Added: "loops" tool, to quickly change the loop boundaries of all channels.
- Added: "speeds" tool, to quickly change the speed of all channels.
- Added: "levels" tool, with an oscilloscope and a level meter for each channel.
- Changed: track headers are simplified; click to mute/unmute, right-click to
  change the track (or better, use the new "channels" tool).
- Changed: instruments have the "retrigger" flag on by default.
- Fixed: entering a one digit value + ENTER was editing the wrong rows. (thanks
  to cheez_itz_12oz on the discord for the bug report)

Version 0.0.7, aka #wavemaker-4:

- Added: crash protection mechanism: if the application crashes, a copy of
  the current file is saved with the suffix ".CRASH.sfx"
- Added: "enter" key to preview the note under the cursor and move to next
  step; also works with single-row selections, to preview chords.
- Added: shift+enter/delete/backspace to perform the corresponding action
  but with inserting or removing rows instead of overwriting.
- Added: key = (equal) to repeat the last entered value on instr, vol, and fx.
- Added: ctrl+E and ctrl+D to increase/decrase the selected part(s).
- Added: key ' (single quote) to enter a rest (same as delete).
- Added: shift+key to enter sustained notes with "retrigger" instruments
  (i.e. to enter only the pitch).
- Added: shift+digit to enter instrument with a single keystroke (first 16
  instruments only).
- Added: shift+digit to enter volume with a single keystroke (1 -> 08,
  9 -> 48, ... f -> 78).
- Added: right-click to move selection without collapsing it.
- Added: double-click to select a row, triple-click to select a beat,
  quadruple-click to select a column.
- Added: when playing a notes on the keyboard, its name is displayed (in place
  of the octave selector).
- Added: new isomorphic layout for playing notes on the keyboard, with a
  major third interval between rows.
- Added: configuration of the bar length and beat length in the track dialog.
- Changed: jump step now takes into account the selection length; makes it easy
  to enter a succession of sustained notes.
- Changed: continuation lines (on sustained notes) now take into account the
  retrigger flag of the instrument.
- Changed: continuation lines now take into account the cut and retrigger fx.
- Fixed: wrong value when entering only params in fx.
- Fixed: the cursor could sometimes leave the screen.
- Fixed: a crash when opening the settings dialog (a regression).

Version 0.0.6, aka #wavemaker-3:

- Fixed: crash when copying (a regression; thanks to Thelxinoe5 for the
  report).

Version 0.0.5, aka #wavemaker-2:

- Fixed: crash when clicking on empty and muted track, or muting a track
  containing the cursor (thanks to cheez_itz_12oz on the discord for the report).
- Added: colored border around the note editor in recording mode, for better
  awareness.

:: lune.lua
--[[pod_format="raw",created="2025-03-19 09:08:58",modified="2026-02-19 21:34:53",revision=28152]]
----------------------------------------------------------------------------------------------------
-- Logging and Errors
----------------------------------------------------------------------------------------------------


is_loaded_cart =
	env().argv[0] == "/ram/cart/main.lua"
	or env().argv[0] == "/system/apps/terminal.lua"


if is_loaded_cart then
	function log(str)
		local path = debug.getinfo(2).source
		if path[1] == "@" then path = path:sub(2, -1) end
		local line = debug.getinfo(2).currentline
		printh(path .. ":" .. line .. ": " .. (str or ""))
	end
else
	function log(_str) end
end


function error(msg, level, title)
	level = (level or 1) + 1
	-- TODO: check if debug.getinfo(level)
	local path = debug.getinfo(level).source
	local line = debug.getinfo(level).currentline
	local str = sub(path, 2) .. ":" .. string.format("%d", line) .. ": " .. msg
	send_message(3, { event = "report_error", content = "*" .. (title or "error") })
	send_message(3, { event = "report_error", content = str })
	send_message(3, { event = "report_error", content = debug.traceback("", level) })
end


function panic(msg, level, title)
	level = (level or 1) + 1
	error(msg, level, title or "panic")
	stop()
end


----------------------------------------------------------------------------------------------------
-- Require
----------------------------------------------------------------------------------------------------


_modules = {}


-- A 'require' function similar to standard Lua.
-- Idea from elgopher on the BBS
function require(name)
	if (_modules == nil) _modules = {}

	local cached = _modules[name]
	if (cached) return cached

	local filename = fullpath(name)
	local src = fetch(filename)
	if (type(src) != "string") panic("could not include " .. filename, 2)

	-- https://www.lua.org/manual/5.4/manual.html#pdf-load
	-- chunk name (for error reporting)
	-- mode ("t" for text only -- no binary chunk loading)
	-- _ENV upvalue
	-- @ is a special character that tells debugger the string is a filename
	local func, err = load(src, "@" .. filename, "t", _ENV)
	if (not func) panic("\n"..tostr(err), 2, "Syntax error:")

	local module = func()
	_modules[name] = module

	return module
end


----------------------------------------------------------------------------------------------------
-- Structure
----------------------------------------------------------------------------------------------------


function structure(meta)
	meta.__index = meta
	meta.type = meta
	setmetatable(
		meta,
		{
			__call =
				function(mt, instance)
					setmetatable(instance, mt)
					return instance
				end,
		}
	)
	return meta
end

:: main.lua
--[[pod_format="raw",created="2024-03-24 00:48:06",modified="2026-02-19 21:34:53",revision=36616]]
include "lune.lua"
include "src/waves.lua"
local app = require "src/app.lua"
local sfx = require "src/sfx/sfx.lua"
local file = require "src/file.lua"
local selection = require "src/selection.lua"
local settings = require "src/settings.lua"
local undo = require "src/undo.lua"
local ui = require "src/ui/ui.lua"
local ui_help = require "src/ui/help.lua"
local ui_routing = require "src/ui/routing.lua"
local ui_settings = require "src/ui/settings.lua"
local ui_synth = require "src/ui/synth.lua"
local ui_tracker = require "src/ui/tracker.lua"
local ui_visual = require "src/ui/visual.lua"
local ui_wavetable = require "src/ui/wavetable.lua"


local tracker = nil


function call_protected(func)
	if is_loaded_cart then
		func()
	else
		local function err_handler(err)
			return err .. "\n" .. debug.traceback("", 0)
		end
		local ok, err = pcall(func, err_handler)
		if not ok then
			-- Save the crashed file
			local ud = userdata("u8", 0x40000)
			for i=0,0x3f do
				set(ud, i * 0x1000, peek(0x30000 + i * 0x1000, 0x1000))
			end
			local crashloc = pwf()
			if type(crashloc) ~= "string" then
				crashloc = env().argv[1]
			end
			if type(crashloc) ~= "string" then
				crashloc = "/ram/cart/sfx/0.sfx"
			end
			if crashloc:sub(-4, -1) == ".sfx" then
				crashloc = crashloc:sub(1, -5)
			end
			store(crashloc .. ".CRASH.sfx", ud)
			store(crashloc .. ".CRASH.txt", type(err) == "string" and err or pod(err))
			-- Report the error
			if type(err) == "string" then
				send_message(3, { event = "report_error", content = "*runtime error"})
				for s in err:gmatch("[^\n]+") do
					send_message(3, { event = "report_error", content = s })
				end
			else
				send_message(3, { event = "report_error", content = "*unknown runtime error"})
				send_message(3, { event = "report_error", content = pod(err) })
			end
		end
	end
end



function _init()
	log("-------------------------------------------------------------------------------")
	log("                                 WaveMaker")
	log("-------------------------------------------------------------------------------")
	log("Path: " .. pod(env().argv[0]))
	log("Opening: " .. pod(env().argv[1]))

	window {
		tabbed = true,
		-- capture_escapes = true, -- (done in tracker's update)
		icon = --[[pod_type="gfx"]]unpod("b64:bHo0AB4AAAAcAAAA8A1weHUAQyAICAQwB2AXUAcAB0AHAAcgJzA3QBew")
	}
	
	wrangle_working_file {
		save_state = file.save,
		load_state = file.load,
		untitled_filename = 
			is_loaded_cart and "/test/sfx/test.sfx" or "/ram/cart/sfx/sfx.0",
		--[[
		-- TODO: Not until I am 100% sure everything has undo checkpoints
		state_hint =
			function()
				return undo_stack and #undo_stack.undo_stack
			end
		--]]
	}
		
--	on_event("drop_items", file.handle_drop_items)
	on_event("resize", function(msg) app.refresh_gui = true end)
	on_event("gained_focus", function(msg) app.window_focused = true end)
	on_event("lost_focus", function(msg) app.window_focused = false end)

--	menuitem() -- TODO: custrom open/save menu entries
	
	menuitem {
		id = "export",
		label = "\^:0000000000000000 Export Instruments",
		action =
			function()
				ui.chooser (
					{
						path = "/ram/cart/sfx/",
						intention = "select_file",
						title = "Export Instruments",
						prompt = "Export into:",
						verb = "Export",
						workspace = "current",
					},
					function(msg)
						file.export_into(msg.filename)
					end
				)
			end,
	}	
	menuitem { divider = true, id = "settings_divider", label = "" }
	menuitem {
		id = "settings",
		label = "\^:0000000000000000 Settings",
		action = function() ui_settings.open() end,
	}
	menuitem {
		id = "help",
		label = "\^:0000000000000000 Help",
		action = function() ui_help.open() end,
	}
		
	settings.load()
	
	--poke(0x4000, get(fetch("fonts/p8_mod.font")))
	fetch("fonts/p8_mod.font"):poke(0x4000)
	fetch("fonts/cozi.font"):poke(0x5600)
	
	poke4(0x5000, get(fetch("pal/0.pal")))
	
	for i = 0, 255 do
		local sprite = userdata("u8", 7, 5)
		set_draw_target(sprite)
		print(string.format("%02x", i), 0, 0, 7)
		set_spr(256 + i, sprite)
	end
	set_draw_target()
	
	--app.node = nil
	music(-1)
	selection.set(0, 0, selection.note)
	undo.init()
end


local previously_focused = nil


function _update()
	call_protected(
		function()
			-- Keyboard Focus
			local currently_focused = ui.head() and ui.head():get_keyboard_focus_element()
			if currently_focused ~= previously_focused then
				ui_visual.close()
			end
			previously_focused = currently_focused
			-- GUI Refresh
			if app.refresh_gui then
				generate_gui()
				app.refresh_gui = false
			end
			-- GUI Update
			ui.head():update_all()
			-- Keys
			if key("ctrl") then
				if keyp("z") then
					if key("shift") then
						undo.redo()
					else
						undo.undo()
					end
				end
				if keyp("y") then
					undo.redo()
				end
			end
		end
	)
end


local fpses = { [0] = 0, 0, 0, 0, 0, 0, 0, 0}
local fps_idx = 0
function _draw()
	call_protected(
		function()
			ui.head():draw_all()
			if app.view == "tracker" and app.is_editing then
				local width = get_display():width() - app.panel_width - 4
				local height = get_display():height() - 9 - 8
				if tracker and tracker.notegrids and tracker.notegrids[1] then
					height = tracker.notegrids[1].height
				end
				rrect(
					app.panel_width, 9, 
					width, height, 
					0, 36
				)
			end
			-- Show FPS when in dev
			if is_loaded_cart then
				fpses[fps_idx] = stat(1)
				fps_idx = (fps_idx + 1) % 8
				local fps = 0
				for v in all(fpses) do
					fps = max(fps, v)
				end
				fps = flr(0.5 + fps * 100.0)
				local y = app.view == "tracker" and 253 or 250
				print(string.format("%3.0f%%", fps), 463, y, 58)		
			end
		end
	)
end


function generate_gui()
	ui.create_head()
	local width <const> = get_display():width()
	local height <const> = get_display():height()
	if app.view == "tracker" then
		tracker = ui_tracker.attach(ui.head(), { x = 0, y = 0, width = width, height = height })
	elseif app.view == "synth" and app.synth_mode == "wavetable" then
		ui_wavetable.attach(ui.head(), { x = 0, y = 0, width = width, height = height })
	elseif app.view == "synth" then
		ui_synth.attach(ui.head(), { x = 0, y = 0, width = width, height = height })
	end
end

:: manual.txt
--[[pod_format="raw",created="2024-04-14 09:49:39",icon=userdata("u8",16,16,"000001010101010101010101010000000001040404040404040404040401000001070104040404040404040404040100000101040404040f0f0f0404040401000001040404040f0f040f0f04040401000107010404040404040f0f040404010000010104040404040f0f040404040100000104040404040f0f0404040404010001070104040404040404040404040100000101040404040f0f04040404040100000104040404040404040404040401000107010404040404040404040401010000010101010101010101010101070100000101070707070707070707070401000000010404040404040404040401000000000001010101010101010101000000"),modified="2026-02-19 21:34:53",revision=26364]]
# WaveMaker

WaveMaker is an alternative to Picotron's default
tracker.

## Tracker

### Overview

The tracker has two modes: "playing" and "recording".
Switch between the two by hitting TAB, or clicking
the record button. Use the first mode to explore
melodies on the keyboard, and the second to enter
the notes in the track.

An important difference with the default tracker is
that parameters for the instrument, volume and fx
each have a single column. When the cursor is on one
of them, you have to type two digits (or a letter and
two digits for fx) to validate the entry and move to
the next row.

### Selections and Multi-Cursors

The way selection work is somewhat unconventional:
you can move the selections around with the arrow
keys, and if you type a note or a value for a
parameter, it will be entered in every selected row.

In other words, the selection behaves like a cursor.

You can double-click to select a row (i.e. the note
with its instrument, volume and fx), triple-click to
select a beat, and quadruple-click to select a
column. You can also do "sparse" selections using the
CTRL key, i.e. to select rows that are not contiguous.

Two important shortcuts are CTRL-E and CTRL-D,
which are used to increase the selected value(s). For
notes they will raise or lower the octave, for
instruments they will go to the next or previous one,
for volume they will increase or decrease it by step
of 8. If several parts are selected, only the
left-most part is affected.

### Jump Step

The jump step specifies how much the cursor move
after entering a note. It is displayed in the right
panel, under the default note volume.

The current selection also influences the distance
moved after entering a note: if multiple rows are
selected, the cursors will move down by the same
amount. This makes it easy to enter a succession
of long notes.

Most editing keys use the jump step when they move
around the cursor. The only exception are the keys
"Up" and "Down", which always move by a single row.

### Keybindings

```
	*** Edition ***
	 
	Tab: toggle recording on/off
	 
	Space: play from current pattern
	S-Space: play and follow playhead
	 
	S-Enter: insert rows
	 
	Backspace: jump upward and clear selected parts
	C-Backspace: jump upward and clear selected rows
	S-Backspace: remove selected rows
	
	Delete: clear selected parts
	C-Delete: clear selected rows
	S-Delete: remove selected rows
	
	': rest (clear selected parts and jump down)
	C-': rest (clear selected rows and jump down)
	 
	=: repeat last entered value
	
	C-E: Increase part(s) under cursor
	C-D: Decrease part(s) under cursor
	
	*** Movement ***
	 
	Left: move to previous part
	Right: move to next part
	 
	C-Left: move to previous channel
	C-Right: move to next channel

	Down: move to next row
	Up: move to previous row

	Enter: play current note and jump to next row
	C-Enter: play current note (without moving)
	 
	C-Down: move to next beat
	C-Up: move to previous beat
	 
	PageDown: move to next bar
	PageUp: move to previous bar
	 
	C-PageDown: move to next pattern (not yet implemented)
	C-PageUp: move to previous pattern (not yet implemented)
	 
	Home: move to start of current bar (or previous)
	End: move to the start of next bar
	 
	C-Home: move to start of the track (not yet implemented)
	C-End: move to end of the track (not yet implemented)

	*** Default Note and Jump Step ***
	
	A-O: enter default octave
	A-I: enter default instrument
	A-V: enter default volume
	A-J: enter jump step
	Insert: set jump step to 0 (toggle)
```

## Synth
...

:: src/actions.lua
--[[pod_format="raw",created="2026-02-04 10:08:37",modified="2026-02-19 21:34:53",revision=13281]]
local app = require "src/app.lua"
local selection = require "src/selection.lua"
local sfx = require "src/sfx/sfx.lua"
local undo = require "src/undo.lua"


local actions = {}

--[[
This module contains all the functions available for keybindings,
and only them.
--]]


-------------------------------------------------------------------------------
-- Locals
-------------------------------------------------------------------------------


local function clear_steps(track, step)
	sfx.set_track_row(track, step, sfx.empty_row())
end


local function clear_parts(track, step)
	if selection.has_part(selection.note) then
		sfx.set_track_pitch(track, step, 0xff)
	end
	if selection.has_part(selection.instrument) then
		sfx.set_track_instrument(track, step, 0xff)
	end
	if selection.has_part(selection.volume) then
		sfx.set_track_volume(track, step, 0xff)
	end
	if selection.has_part(selection.fx) then
		sfx.set_track_fx(track, step, 0x00)
		sfx.set_track_fx_params(track, step, 0x00)
	end
end


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

	
local function remove_steps(step, count)
	selection.for_each_channel(
		function(channel, track)
			local last = sfx.track_size(app.pattern, track) - 1
			for dest = step, last - count do
				local src = dest + count
				if src <= last then
					local row = sfx.track_row(track, src)
					sfx.set_track_row(track, dest, row)
				end
			end
			for s = last - count + 1, last do
				clear_steps(track, s)
			end
		end
	)
end


local function remove_selected_steps()
	selection.for_each_channel(
		function(channel, track)
			local size = sfx.track_size(app.pattern, track)
			local dest = 0
			for src = 0, size - 1 do
				if not selection.has_step(src) then
					local row = sfx.track_row(track, src)
					sfx.set_track_row(track, dest, row)
					dest += 1
				end
			end
			for step = dest, size - 1 do
				clear_steps(track, step)
			end
		end
	)
end


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


local function insert_steps(step, count)
	selection.for_each_channel(
		function(channel, track)
			local last = sfx.track_size(app.pattern, track) - 1
			for dest = last, step + count, -1 do
				local src = dest - count
				local row = sfx.track_row(track, src)
				sfx.set_track_row(track, dest, row)
			end
			for s = step, step + count - 1 do
				clear_steps(track, s)
			end
		end
	)
end


-------------------------------------------------------------------------------
-- Context
-------------------------------------------------------------------------------


function actions.play_or_pause(tracker)
	tracker:clear_edit()
	app.play_or_pause(nil)
end


function actions.follow_play_or_pause(tracker)
	tracker:clear_edit()
	app.play_or_pause("follow_playhead")
end


function actions.toggle_record_mode(tracker)
	tracker:clear_edit()
	app.is_editing = not app.is_editing
	if app.is_editing and sfx.music_is_playing() and app.follow_playhead then
		app.play_or_pause()
	end
end


function actions.toggle_jump_step(tracker)
	readtext(true)
	if app.jump_step == 0 and app.saved_jump_step then
		app.jump_step = app.saved_jump_step
	else
		app.saved_jump_step = app.jump_step
		app.jump_step = 0
	end
end


-------------------------------------------------------------------------------
-- Movement
-------------------------------------------------------------------------------


function actions.move_down(tracker)
	tracker:clear_edit()
	local moved = selection.move_step(1)
	if not moved then
		local min_step = selection.min_step()
		selection.move_step(0 - min_step)
	end
	tracker:show_cursor()
end


function actions.move_up(tracker)
	tracker:clear_edit()
	local moved = selection.move_step(-1)
	if not moved then
		local min_step = selection.min_step()
		local channel = selection.min_channel()
		local track = sfx.pattern_track(app.pattern, channel)
		local size = sfx.track_size(track)
		selection.move_step((size - 1) - min_step)
	end
	tracker:show_cursor()
end


function actions.move_to_next_beat(tracker)
	tracker:clear_edit()
	local moved = selection.move_step(app.beat_length)
	if not moved then
		local min_step = selection.min_step()
		local target = min_step % app.beat_length
		selection.move_step(target - min_step)
	end
	tracker:show_cursor()
end


function actions.move_to_previous_beat(tracker)
	tracker:clear_edit()
	local moved = selection.move_step(-1 * app.beat_length)
	if not moved then
		local min_step = selection.min_step()
		local channel = selection.min_channel()
		local track = sfx.pattern_track(app.pattern, channel)
		local size = sfx.track_size(track)
		local target = min_step
		while target + app.beat_length < size do
			target += app.beat_length
		end
		selection.move_step(target - min_step)
	end
	tracker:show_cursor()
end


function actions.move_to_next_bar(tracker)
	tracker:clear_edit()
	local moved = selection.move_step(1 * app.bar_length)
	if not moved then
		local min_step = selection.min_step()
		local target = min_step % app.bar_length
		selection.move_step(target - min_step)
	end
	tracker:show_cursor()
end


function actions.move_to_previous_bar(tracker)
	tracker:clear_edit()
	local moved = selection.move_step(-1 * app.bar_length)
	if not moved then
		local min_step = selection.min_step()
		local channel = selection.min_channel()
		local track = sfx.pattern_track(app.pattern, channel)
		local size = sfx.track_size(track)
		local target = min_step
		while target + app.bar_length < size do
			target += app.bar_length
		end
		selection.move_step(target - min_step)
	end
	tracker:show_cursor()
end

	
function actions.home(tracker)
	readtext(true)
	local step = selection.min_step()
	local channel = selection.min_channel()
	local bar_length = app.bar_length
	local target
	if step % bar_length == 0 then
		target = max(step - bar_length, 0)
	else
		target = (step // bar_length) * bar_length
	end
	if key("shift") then
		-- TODO: not yet implemented
		return
	end
	selection.move_step(target - step)
	tracker:show_cursor()
end


function actions.fin(tracker)
	readtext(true)
	local step = selection.min_step()
	local channel = selection.min_channel()
	local size = sfx.track_size(sfx.pattern_track(app.pattern, channel))
	local bar_length = app.bar_length
	local target
	if step % bar_length == 0 then
		target = min(step + bar_length, size - 1)
	else
		target = (step // bar_length) * bar_length + bar_length
	end
	if key("shift") then
		-- TODO: not yet implemented
		return
	end
	selection.move_step(target - step)
	tracker:show_cursor()
end

	
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


local function preview(tracker, jump, direction)
	if tracker.str_instrument or tracker.str_volume or tracker.str_fx then return end
	local step = selection.min_step()
	if step then
		selection.for_each_channel(
			function(channel, track)
				local pitch = tracker:note_to_preview(track, step)
				local instr = tracker:instrument_to_preview(track, step)
				local vol = tracker:volume_to_preview(track, step)
				note(pitch, instr, vol,
					0x00, 0x00,
					8 + channel,
					false -- don't force retrigger
				)
			end
		)
		tracker.preview_timer = 16
		-- Now move down
		if jump == "jump" then
			local jump_step = selection.extended_jump_step()
			if direction == "back" then
				jump_step = - jump_step
			end
			local moved = selection.move_step(jump_step)
			if not moved then
				local min_step = selection.min_step()
				local target = min_step % jump_step
				selection.move_step(target - min_step)
			end
			tracker:show_cursor()
		end
	end
end


function actions.preview_row(tracker)
	preview(tracker, nil)
end


function actions.preview_row_and_jump_down(tracker)
	preview(tracker, "jump")
end


function actions.preview_row_and_jump_back(tracker)
	preview(tracker, "jump", "back")
end

	
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


function actions.move_to_next_part(tracker)
	readtext(true)
	selection.move_to_next_part()
	tracker:show_cursor()
end


function actions.move_to_previous_part(tracker)
	readtext(true)
	selection.move_to_previous_part()
	tracker:show_cursor()
end


function actions.move_to_next_channel(tracker)
	readtext(true)
	selection.move_to_next_channel()
	tracker:show_cursor()
end


function actions.move_to_previous_channel(tracker)
	readtext(true)
	selection.move_to_previous_channel()
	tracker:show_cursor()
end


-------------------------------------------------------------------------------
-- Selection
-------------------------------------------------------------------------------


function actions.select_next_row(tracker)
	tracker:clear_edit()
	selection.grow_steps(1)
	tracker:show_cursor()
end


function actions.shrink_selection_rows(tracker)
	tracker:clear_edit()
	selection.shrink_steps(1)
	tracker:show_cursor()
end


function actions.select_next_beat(tracker)
	tracker:clear_edit()
	selection.grow_steps(app.beat_length)
	tracker:show_cursor()
end


function actions.select_next_bar(tracker)
	tracker:clear_edit()
	selection.grow_steps(app.bar_length)
	tracker:show_cursor()
end


function actions.select_next_part(tracker)
	tracker:clear_edit()
	selection.grow_parts()
	tracker:show_cursor()
end


function actions.shrink_selection_parts(tracker)
	tracker:clear_edit()
	selection.shrink_parts()
	tracker:show_cursor()
end


function actions.select_next_channel(tracker)
	tracker:clear_edit()
	selection.grow_channels()
	tracker:show_cursor()
end


function actions.shrink_selection_channels(tracker)
	tracker:clear_edit()
	selection.shrink_channels()
	tracker:show_cursor()
end


-------------------------------------------------------------------------------
-- Edition
-------------------------------------------------------------------------------


function actions.repeat_last_entry(tracker)
	if not app.is_editing then return end
	if tracker.str_instrument or tracker.str_volume or tracker.str_fx then return end
	undo.checkpoint()
	readtext(true)
	local sth_entered = false
	selection.for_each_channel_each_step(
		function(track, step)
			if selection.has_part(selection.note) and tracker.last_pitch_entered then
				sfx.set_track_pitch(track, step, tracker.last_pitch_entered)
				sth_entered = true
			end
			if selection.has_part(selection.instrument) and tracker.last_instrument_entered then
				sfx.set_track_instrument(track, step, tracker.last_instrument_entered)
				sth_entered = true
			end
			if selection.has_part(selection.volume) and tracker.last_volume_entered then
				sfx.set_track_volume(track, step, tracker.last_volume_entered)
				sth_entered = true
			end
			if selection.has_part(selection.fx) and tracker.last_fx_entered then
				sfx.set_track_fx(track, step, tracker.last_fx_entered)
				sth_entered = true
			end
			if selection.has_part(selection.fx) and tracker.last_fx_params_entered then
				sfx.set_track_fx_params(track, step, tracker.last_fx_params_entered)
				sth_entered = true
			end
		end
	)
	if sth_entered then
		selection.move_step(selection.jump_step())
		tracker:show_cursor()
	end
end

	
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


function actions.clear_parts(tracker)
	if tracker.str_instrument or tracker.str_volume or tracker.str_fx then return end
	undo.checkpoint()
	readtext(true)
	selection.for_each_channel_each_step(clear_parts)
	tracker:show_cursor()
end


function actions.clear_rows(tracker)
	if tracker.str_instrument or tracker.str_volume or tracker.str_fx then return end
	undo.checkpoint()
	readtext(true)
	selection.for_each_channel_each_step(clear_steps)
	tracker:show_cursor()
end


function actions.clear_parts_and_jump_down(tracker)
	if tracker.str_instrument or tracker.str_volume or tracker.str_fx then return end
	undo.checkpoint()
	readtext(true)
	selection.for_each_channel_each_step(clear_parts)
	local jump_step = selection.jump_step()
	local moved = selection.move_step(jump_step)
	if not moved then
		local min_step = selection.min_step()
		local target = min_step % jump_step
		selection.move_step(target - min_step)
	end
	tracker:show_cursor()
end


function actions.clear_rows_and_jump_down(tracker)
	if tracker.str_instrument or tracker.str_volume or tracker.str_fx then return end
	undo.checkpoint()
	readtext(true)
	selection.for_each_channel_each_step(clear_steps)
	local jump_step = selection.jump_step()
	local moved = selection.move_step(jump_step)
	if not moved then
		local min_step = selection.min_step()
		local target = min_step % jump_step
		selection.move_step(target - min_step)
	end
	tracker:show_cursor()
end


function actions.remove_rows(tracker)
	if tracker.str_instrument or tracker.str_volume or tracker.str_fx then return end
	undo.checkpoint()
	readtext(true)
	remove_selected_steps()
	tracker:show_cursor()
end

	
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

	
local function backspace(tracker, how, what)
	if tracker.str_instrument or tracker.str_volume or tracker.str_fx then return end
	undo.checkpoint()
	readtext(true)
	local should_proceed = true
	should_proceed = selection.move_step(-1 * selection.jump_step())
	if should_proceed then
		if how == "remove" then
			remove_steps(selection.min_step(), selection.jump_step())
		else
			local full_row = what == "rows"
			selection.for_each_channel_each_step(
				full_row and clear_steps or clear_parts
			)
		end
	end
	tracker:show_cursor()
	return nil
end


function actions.jump_up_and_clear_parts(tracker)
	backspace(tracker, "clear", "parts")
end


function actions.jump_up_and_clear_rows(tracker)
	backspace(tracker, "clear", "rows")
end


function actions.jump_up_and_remove_rows(tracker)
	backspace(tracker, "remove", "rows")
end

	
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


function actions.insert_rows(tracker)
	undo.checkpoint()
	readtext(true)
	insert_steps(selection.min_step(), selection.jump_step())
	selection.move_step(selection.jump_step())
end

	
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


function actions.increase_part(tracker)
	if selection.has_part(selection.note) then
		actions.increase_octave(tracker)
	elseif selection.has_part(selection.instrument) then
		actions.increase_instrument(tracker)
	elseif selection.has_part(selection.volume) then
		actions.increase_volume(tracker)
	end
end


function actions.decrease_part(tracker)
	if selection.has_part(selection.note) then
		actions.decrease_octave(tracker)
	elseif selection.has_part(selection.instrument) then
		actions.decrease_instrument(tracker)
	elseif selection.has_part(selection.volume) then
		actions.decrease_volume(tracker)
	end
end


function actions.increase_part_slightly(tracker)
	if selection.has_part(selection.note) then
		actions.increase_pitch(tracker)
	elseif selection.has_part(selection.instrument) then
		actions.increase_instrument(tracker)
	elseif selection.has_part(selection.volume) then
		actions.increase_volume_slightly(tracker)
	end
end


function actions.decrease_part_slightly(tracker)
	if selection.has_part(selection.note) then
		actions.decrease_pitch(tracker)
	elseif selection.has_part(selection.instrument) then
		actions.decrease_instrument(tracker)
	elseif selection.has_part(selection.volume) then
		actions.decrease_volume_slightly(tracker)
	end
end

	
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


function actions.increase_octave(tracker)
	undo.checkpoint()
	readtext(true)
	selection.for_each_channel_each_step(
		function(track, step)
			local pitch = sfx.track_pitch(track, step)
			if pitch ~= 0xff then
				local note = pitch % 12
				local octave = flr(pitch // 12)
				octave = mid(octave + 1, 0, 7)
				pitch = mid(note + 12 * octave, 0, 0xfe)
				sfx.set_track_pitch(track, step, pitch)
			end
		end
	)
end


function actions.decrease_octave(tracker)
	undo.checkpoint()
	readtext(true)
	selection.for_each_channel_each_step(
		function(track, step)
			local pitch = sfx.track_pitch(track, step)
			if pitch ~= 0xff then
				local note = pitch % 12
				local octave = flr(pitch // 12)
				octave = mid(octave - 1, 0, 7)
				pitch = mid(note + 12 * octave, 0, 0xfe)
				sfx.set_track_pitch(track, step, pitch)
			end
		end
	)
end


function actions.increase_pitch(tracker)
	undo.checkpoint()
	readtext(true)
	selection.for_each_channel_each_step(
		function(track, step)
			local pitch = sfx.track_pitch(track, step)
			if pitch ~= 0xff then
				pitch = mid(pitch + 1, 0, 0xfe)
				sfx.set_track_pitch(track, step, pitch)
			end
		end
	)
end


function actions.decrease_pitch(tracker)
	undo.checkpoint()
	readtext(true)
	selection.for_each_channel_each_step(
		function(track, step)
			local pitch = sfx.track_pitch(track, step)
			if pitch ~= 0xff then
				pitch = mid(pitch - 1, 0, 0xfe)
				sfx.set_track_pitch(track, step, pitch)
			end
		end
	)
end

	
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


function actions.increase_instrument(tracker)
	undo.checkpoint()
	readtext(true)
	selection.for_each_channel_each_step(
		function(track, step)
			local inst = sfx.track_instrument(track, step)
			if inst ~= 0xff then
				inst = mid(inst + 1, 0, sfx.num_instruments())
				sfx.set_track_instrument(track, step, inst)
			end
		end
	)
end


function actions.decrease_instrument(tracker)
	undo.checkpoint()
	readtext(true)
	selection.for_each_channel_each_step(
		function(track, step)
			local inst = sfx.track_instrument(track, step)
			if inst ~= 0xff then
				inst = mid(inst - 1, 0, sfx.num_instruments())
				sfx.set_track_instrument(track, step, inst)
			end
		end
	)
end

	
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


function actions.increase_volume(tracker)
	undo.checkpoint()
	readtext(true)
	selection.for_each_channel_each_step(
		function(track, step)
			local vol = sfx.track_volume(track, step)
			if vol ~= 0xff then
				vol = mid(vol + 8, 0, 0xfe)
				sfx.set_track_volume(track, step, vol)
			end
		end
	)
end


function actions.decrease_volume(tracker)
	undo.checkpoint()
	readtext(true)
	selection.for_each_channel_each_step(
		function(track, step)
			local vol = sfx.track_volume(track, step)
			if vol ~= 0xff then
				vol = mid(vol - 8, 0, 0xfe)
				sfx.set_track_volume(track, step, vol)
			end
		end
	)
end


function actions.increase_volume_slightly(tracker)
	undo.checkpoint()
	readtext(true)
	selection.for_each_channel_each_step(
		function(track, step)
			local vol = sfx.track_volume(track, step)
			if vol ~= 0xff then
				vol = mid(vol + 1, 0, 0xfe)
				sfx.set_track_volume(track, step, vol)
			end
		end
	)
end


function actions.decrease_volume_slightly(tracker)
	undo.checkpoint()
	readtext(true)
	selection.for_each_channel_each_step(
		function(track, step)
			local vol = sfx.track_volume(track, step)
			if vol ~= 0xff then
				vol = mid(vol - 1, 0, 0xfe)
				sfx.set_track_volume(track, step, vol)
			end
		end
	)
end

	
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


function actions.copy(tracker)
	set_clipboard(pod(selection.pack(), 0, { pod_type = "wavemaker notes" }))
	notify("copied notes")
end


function actions.cut(tracker)
	set_clipboard(pod(selection.pack(), 0, { pod_type = "wavemaker notes" }))
	actions.clear_parts(tracker) -- Note: this calls `undo:checkpoint()`
	notify("cut notes")
end


function actions.cut_and_remove_rows(tracker)
	set_clipboard(pod(selection.pack("rows"), 0, { pod_type = "wavemaker notes" }))
	actions.remove_rows(tracker) -- Note: this calls `undo:checkpoint()`
	notify("cut notes")
end


function actions.paste(tracker)
	local data, metadata = unpod(get_clipboard())
	if metadata and metadata.pod_type == "wavemaker notes" then
		undo.checkpoint()
		selection.unpack(data)
	end
end


function actions.insert_rows_and_paste(tracker)
	-- TODO: not yet implemented
	--[[
	local data, metadata = unpod(get_clipboard())
	if metadata and metadata.pod_type == "wavemaker notes" then
		undo.checkpoint()
		selection.unpack(data)
	end
	--]]
end
	
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
	

return actions
:: src/app.lua
--[[pod_format="raw",created="2024-04-12 08:11:00",modified="2026-02-19 21:34:53",revision=33421]]
local settings = require "src/settings.lua"
local sfx = require "src/sfx/sfx.lua"


local app = {}


----------------------------------------------------------------------------------------------------
-- Transient State
----------------------------------------------------------------------------------------------------

app.current_location = nil

app.window_focused = false -- TODO: remove?

app.refresh_gui = true

app.is_editing = false

app.was_in_text_field = false
	-- Used to stop interference between field entry
	-- and playing notes (eg when entering "2d" in
	-- default volume field).

app.capture_escapes = false
	-- Caches the state of `window { capture_escapes }`.

app.follow_playhead = false

app.saved_jump_step = nil


----------------------------------------------------------------------------------------------------
-- Global State
----------------------------------------------------------------------------------------------------


app.version = "?.?.?"
local metadata = fetch_metadata("/ram/cart")
if type(metadata) == "table" and type(metadata.version) == "string" then
	if metadata.version then
		app.version = metadata.version
	end
end


-- Shared State

app.pattern = 0
app.track = 0
app.instrument = 0

-- Synth State

app.node = nil -- selected in instrument editor
app.wt = 0 -- selected in instrument editor

-- Tracker State

app.base_note = 48
app.base_volume = 0x20
app.jump_step = 1

-- Metadata

app.new_tracks_speed = 16
app.new_tracks_length = 0
app.beat_length = 4
app.bar_length = 4 * app.beat_length

-- UI State

app.view = "synth" -- "tracker" or "synth"
app.detail = false -- TODO: remove?
app.tracker_mode = "tracker" -- "tracker" or "pianoroll"
app.synth_mode = "wavetable" -- "instrument" or "wavetable"
app.wavetable = 0
app.toolrack_tab = nil
app.toolrack_track_scrollstart = 0
app.channel_oscillos_visible = true
app.row_height = 8
app.starting_row = 0
app.env_advanced = { [0] = false, false, false, false }
app.show_meter = true
app.meter_speed = 1 / 64


----------------------------------------------------------------------------------------------------
-- Constants
----------------------------------------------------------------------------------------------------


-- Meters Range


app.min_db = 40


-- Layout constants


app.panel_width = 19
app.track_header_height = 9
app.column_width = 57 -- 57

app.synth_width = 83
app.synth_height = 72
app.synth_gap = 5
app.mod_width = 57
app.mod_height = app.synth_height


----------------------------------------------------------------------------------------------------
-- Reverse Track Lookup
----------------------------------------------------------------------------------------------------


local track_patterns = {}


function app.update_track_patterns()
	track_patterns = {}
	for p = 0, sfx.num_patterns() do
		for c = 0, 7 do
			local muted = sfx.channel_is_muted(p, c)
			if not muted then
				local track = sfx.pattern_track(p, c)
				if not track_patterns[track] then
					track_patterns[track] = {}
				end
				add(track_patterns[track], { pattern = p, channel = c })
			end
		end
	end
end


function app.track_patterns(track)
	return track_patterns[track]
end


function app.set_pattern_track(pattern, channel, track)
	sfx.set_pattern_track(pattern, channel, track)
	app.update_track_patterns()
end


function app.mute_channel(pattern, channel, muted)
	sfx.mute_channel(pattern, channel, muted)
	app.update_track_patterns()
end


----------------------------------------------------------------------------------------------------
-- Wavetables
----------------------------------------------------------------------------------------------------


local wavetables = {}
local wavetable_list = {}


function app.update_wavetables()
	for inst = 0, sfx.num_instruments() do
		for wt = 0, 3 do
			local addr, width, height = sfx.wavetable_info(inst, wt)
			if addr == 0 then
				-- Do nothing
			elseif wavetables[addr] then
				local info = wavetables[addr]
				if info.width ~= width or info.height ~= height then
					notify("WARNING: wavetable at 0x" .. string.format("%04x", addr)
						.." has conflicting width or height")
					info.width = max(info.width, width)
					info.height = max(info.height, height)
				end
				add(info.instruments, inst)
			else
				local info = {
					addr = addr,
					width = width,
					height = height,
					instruments = { inst },
				}
				wavetables[addr] = info
			end
		end
	end
	wavetable_list = {}
	local i = 0
	for addr, info in pairs(wavetables) do
		wavetable_list[i] = addr
		i += 1
		log(string.format("%04x:", addr).." width="..info.width..", height="..info.height)
	end
end


function app.num_wavetables()
	return #wavetable_list + 1
end


function app.wavetable_info(wavetable)
	return wavetables[wavetable_list[wavetable]]
end


----------------------------------------------------------------------------------------------------
-- Helpers
----------------------------------------------------------------------------------------------------


function app.play_or_pause(mode)
	if sfx.music_is_playing() then
		music(-1)
		app.follow_playhead = false
	else
		if mode == "follow_playhead" then
			app.is_editing = false
			app.follow_playhead = true
		end
		music(app.pattern)
	end
end


----------------------------------------------------------------------------------------------------
-- Helpers
----------------------------------------------------------------------------------------------------


function app.draw_borders(x, y, width, height)
	pset(x, y, 58)
	line(x - 1, y + 1, x - 1, y + height - 2, 58)
	line(x + 1, y - 1, x + width - 2, y - 1, 58)
	pset(x + width - 1, y, 58)
	line(x + width, y + 1, x + width, y + height - 2, 57)
	pset(x + width - 1, y + height - 1, 57)
	line(x + 1, y + height, x + width - 2, y + height, 57)
	pset(x, y + height - 1, 57)
end


local fg_clip <const> = 8
local fg_high <const> = 51 -- 51, 25
local fg_mid <const> = 43 -- 43, 10
local fg_low <const> = 45 -- 45, 11


function app.draw_vert_meter(x, y, width, height, value)
	local target = flr(0.5 + y + height - 1 - value * (height - 1))
	local zone1 = flr(0.5 + y + height - 1 - 0.5 * (height - 1))
	local zone2 = flr(0.5 + y + height - 1 - 0.8 * (height - 1))
	rectfill(x, y, x + width - 1, y + height - 1, 60)
	if target > zone1 then
		rectfill(x, target, x + width - 1, y + height - 1, fg_low)
	elseif target > zone2 then
		rectfill(x, zone1, x + width - 1, y + height - 1, fg_low)
		rectfill(x, target, x + width - 1, zone1 - 1, fg_mid)
	else
		rectfill(x, zone1, x + width - 1, y + height - 1, fg_low)
		rectfill(x, zone2, x + width - 1, zone1 - 1, fg_mid)
		if value == 1 then
			rectfill(x, zone2 - 1, x + width - 1, target, fg_clip)
		else
			rectfill(x, zone2 - 1, x + width - 1, target, fg_high)
		end
	end
end


function app.draw_horiz_meter(x, y, width, height, value)
	local target = flr(0.5 + x + value * (width - 1))
	local zone1 = flr(0.5 + x + 0.5 * (width - 1))
	local zone2 = flr(0.5 + x + 0.8 * (width - 1))
	rectfill(x, y, x + width - 1, y + height - 1, 60)
	if target <= zone1 then
		rectfill(x, y, target, y + height - 1, fg_low)
	elseif target <= zone2 then
		rectfill(x, y, zone1, y + height - 1, fg_low)
		rectfill(zone1 + 1, y, target, y + height - 1, fg_mid)
	else
		rectfill(x, y, zone1, y + height - 1, fg_low)
		rectfill(zone1 + 1, y, zone2, y + height - 1, fg_mid)
		rectfill(zone2 + 1, y, target, y + height - 1, fg_high)
	end
end


----------------------------------------------------------------------------------------------------
-- Helpers
----------------------------------------------------------------------------------------------------


local last_pitch = nil
function app.pitched_key()
	if app.was_in_text_field then
		last_pitch = nil
		return nil, false
	end
	if key("ctrl") or key("alt") then
		last_pitch = nil
		return nil, false
	end
	local pitch = nil
	for i = 1, #settings.keys.pitched do
		local offset = settings.keys.pitched[i].offset
		for j = 0, #settings.keys.pitched[i] do
			local k = settings.keys.pitched[i][j]
			if key(k, true) then
				pitch = app.base_note + offset + j
				pitch = mid(pitch, 0, 0xfe)
			end
		end
	end
	local is_new = pitch and (pitch ~= last_pitch)
	last_pitch = pitch
	return pitch, is_new
end


function app.decimal_digit_key()
	if keyp("0") then return 0, "0"
	elseif keyp("1") then return 1, "1"
	elseif keyp("2") then return 2, "2"
	elseif keyp("3") then return 3, "3"
	elseif keyp("4") then return 4, "4"
	elseif keyp("5") then return 5, "5"
	elseif keyp("6") then return 6, "6"
	elseif keyp("7") then return 7, "7"
	elseif keyp("8") then return 8, "8"
	elseif keyp("9") then return 9, "9"
	end
	return nil
end


function app.hexadecimal_digit_key()
	if keyp("0") then return 0, "0"
	elseif keyp("1") then return 1, "1"
	elseif keyp("2") then return 2, "2"
	elseif keyp("3") then return 3, "3"
	elseif keyp("4") then return 4, "4"
	elseif keyp("5") then return 5, "5"
	elseif keyp("6") then return 6, "6"
	elseif keyp("7") then return 7, "7"
	elseif keyp("8") then return 8, "8"
	elseif keyp("9") then return 9, "9"
	elseif keyp("a") then return 0xa, "a"
	elseif keyp("b") then return 0xb, "b"
	elseif keyp("c") then return 0xc, "c"
	elseif keyp("d") then return 0xd, "d"
	elseif keyp("e") then return 0xe, "e"
	elseif keyp("f") then return 0xf, "f"
	end
	return nil
end


app.is_valid_fx = {
	["0"] = "\0", ["."] = "\0",
	["1"] = "s", s="s",
	["2"] = "v", v="v",
	["3"] = "-", ["-"] = "-", 
	["4"] = "<", ["<"] = "<", 
	["5"] = ">", [">"] = ">", 
	["6"] = "a", a = "a", A = "A",
	["7"] = "b", b = "b", B = "B",
	["8"] = "t", ["t"] = "t",
	["9"] = "+", ["+"] = "+",
	w = "w", 
	r = "r", c = "c", d = "d", 
	p = "p",
	f = "f", -- fade (0.2.1c)
	m = "m", M = "M", -- arp spd 1
	n = "n", N = "N", -- arp spd 2
	o = "o", O = "O", -- ornament (2-note arp w/ spd parameter)
}


function app.fx_key()
	for k, _ in pairs(app.is_valid_fx) do
		if keyp(k) then
			return k
		end
	end
	return nil
end


return app


:: src/file.lua
--[[pod_format="raw",created="2024-04-07 08:14:09",modified="2026-02-19 21:34:53",revision=27800]]
local app = require "src/app.lua"
local sfx = require "src/sfx/sfx.lua"
local undo = require "src/undo.lua"
local Wavetable = require "src/wavetable.lua"


local file = {}



--local wt = Wavetable.new(1024, 32)
--wt:set_wavetable(drakma_cosine2saw2reso)
--local wt_addr = 0x070000
--wt:poke(wt_addr)



file.default_filename = "/ram/cart/sfx/0.sfx"


-- `file.save` and `file.load` are direct copies of `sfx.p64` code to
-- ensure perfect compatibility.


function file.save()
	local ud = userdata("u8", 0x40000) -- + wt.width * wt.height)
	ud:peek(0x30000)
	local metadata = file.save_metadata()
	return ud, metadata
end

	
function file.load(ud, metadata)
	if (type(ud)~="userdata") then
		init_data()
	else
		memset(0x30000, 0, 0x40000) -- in case stored short / legacy userdata
		ud:poke(0x30000)
	end
--	wt:poke(wt_addr)
	-- TODO
	app.instrument = 0
	app.node = 0
	app.refresh_gui = true
	file.load_metadata(metadata)
	app.update_wavetables()
	app.update_track_patterns()
	undo.init()
end


function file.export_into(filename)
	local target = fetch(filename)
	if type(target) ~= "userdata" then
		notify("unable to read file " .. pod(filename))
		return
	end
	
	-- TODO: only copy existing instruments
	target:peek(0x040000, 0x010000, 0xffff)
	-- TODO: where to put the wavetables?
	-- target:peek(0xf00000, 0xed0000, 0xfffff)
	
	store(filename, target)
	notify("all instruments exported into " .. pod(filename))
end


function file.handle_drop_items(msg)
	for i = 1, #msg.items do
		local item = msg.items[i]
		if item.pod_type == "file_reference" and item.attrib == "file" then
			local ext = item.fullpath:ext()
			if ext == "sfx" then
				local metadata = fetch_metadata(item.fullpath) or {} -- TODO
				send_message(pid(), {event = "open_file", filename = item.fullpath})
			else
				notify("wrong file extension")
				-- TODO: dialog for unknown file extensions?
				--current_filename = item.fullpath
				--send_message(pid(), {event = "open_file", filename = item.fullpath})
			end
		end
	end
end


-------------------------------------------------------------------------------
-- Metadata
-------------------------------------------------------------------------------


function file.save_metadata()
	return {
		wavemaker = {
			version = app.version,
			new_tracks_speed = app.new_tracks_speed,
			new_tracks_length = app.new_tracks_length,
			beat_length = app.beat_length,
			bar_length = app.bar_length,
		}
	}
end


function file.load_metadata(md)
	if not md then md = {} end
	if not md.wavemaker then md.wavemaker = {} end
	-- TODO: check `md.wavemaker.version` for futureness
	-- TODO: default values should be in a single place...
	app.new_tracks_speed = md.wavemaker.new_tracks_speed or 16
	app.new_tracks_length = md.wavemaker.new_tracks_length or 0
	app.beat_length = md.wavemaker.beat_length or 4
	app.bar_length = md.wavemaker.bar_length or 16
end


-------------------------------------------------------------------------------
-- Initialization
-------------------------------------------------------------------------------


function init_track(track)
	local size <const> = 64 -- TODO: support other sizes? how?
	sfx.set_track_size(track, size)
	sfx.set_track_speed(track, app.new_tracks_speed)
	sfx.set_track_loop0(track, app.new_tracks_length)
	sfx.set_track_loop1(track, 0)
	sfx.set_track_delay(track, 0)
	sfx.set_track_flags(track, 0)
	sfx.set_track_unused(track, 0)
	for step = 0, size - 1 do
		sfx.set_track_pitch(track, step, 0xff)
		sfx.set_track_instrument(track, step, 0xff)
		sfx.set_track_volume(track, step, 0xff)
		sfx.set_track_fx(track, step, 0x0)
		sfx.set_track_fx_params(track, step, 0x0)
	end
end


-- copied from "/system/apps/sfx.lua" in Picotron 0.2.2b

function __init_track(addr)
--	printh("init_track "..addr)
	poke2(addr, 64) -- len
	poke(addr+2,16) -- spd
	poke(addr+3,0)  -- loop0
	poke(addr+4,0)  -- loop1
	poke(addr+5,0)  -- delay
	poke(addr+6,0)  -- flags (0x1 mute)
	poke(addr+7,0)  -- unused
	
	-- pitch, inst, vol: not set (0xff)
	memset(addr+8, 0xff, 64*3)
	
	-- fx, fx_p: clear
	memset(addr+8+64*3, 0x0, 64*2)
end

function clear_pattern(i)
	local addr = 0x30100 + i*20
	memset(addr,0,20)
end


function clear_instrument(i)
	local addr = 0x40000 + i * 0x200
	
	memset(addr, 0, 0x200)
	
	-- node 0: root
	poke(addr + (0 * 32), -- node 0
	
			0,    -- parent (0x7)  op (0xf0)
			1,    -- kind (0x0f): 1 root  kind_p (0xf0): 0  -- wavetable_index
			0,    -- flags
			0,    -- unused extra
				
			-- MVALs:  kind/flags,  val0, val1, envelope_index
			
			0x2|0x4,0x30,0,0,  -- volume: mult. 0x40 is max (-0x40 to invert, 0x7f to overamp)
			0x1,0,0,0,     -- pan:   add. center
			0x1,0,0,0,     -- tune: +0 -- 0,48,0,0 absolute for middle c (c4) 261.6 Hz
			0x1,0,0,0,     -- bend: none
			-- following shouldn't be in root
			0x0,0,0,0,     -- wave: use wave 0 
			0x0,0,0,0      -- phase 
	)
	
	
	-- node 1: sine
	poke(addr + (1 * 32), -- instrument 0, node 1
	
			0,    -- parent (0x7)  op (0xf0)
			2,    -- kind (0x0f): 2 osc  kind_p (0xf0): 0  -- wavetable_index
			0,    -- flags
			0,    -- unused extra
				
			-- MVALs:  kind/flags,  val0, val1, envelope_index
			
			0x2,0x30,0,0,  -- volume: mult. 0x40 is max (-0x40 to invert, 0x7f to overamp)
			0x1,0,0,0,     -- pan:   add. center
			0x21,0,0,0,    -- tune: +0 -- 0,48,0,0 absolute for middle c (c4) 261.6 Hz
			               -- tune is quantized to semitones with 0x20
			0x1,0,0,0,     -- bend: none
			0x0,0x40,0,0,  -- wave: triangle
			0x0,0,0,0      -- phase 
	)
	
	
	-- wavetables
	poke(addr + 0x1e0,
		0x00, -- address (low)  in 256 byte increments
		0xf8, -- address (high) in 64k increments
		0x0a, -- samples (1 << n) 1024
		0xff,  -- wt_height 256(0); wave mval points at one of the entries
		
		-- white noise
		0x80,
		0xf7,
		0x0d, -- samples (1 << n) 8192
		0x01,
		
		-- *** TEMP ***
--		0x80,
--		0xf7, --0x060000 >> 32,
--		flr(math.log(wt.width, 2)),
--		wt.height,
		
		(wt_addr >> 8) & 0xff, -- addr >> 16
		wt_addr >> 16, -- addr >> 32,
		flr(math.log(wt.width, 2)),
		wt.height
	)

	-- envelope 0 inst 1
	
	poke(addr + 0x100,
		0,0,0,0, 0,0,0,0,
		0,40,255,0 -- adsr
	)
	
	poke(addr + 0x1df, 0x01)
end


function init_data()

	-- use 256k from 0x30000
	-- gives 399 SFX and managemable size for undo state comparisons
	-- if change this need, to adjust undo stack size and loader/saver
	
	memset(0x30000, 0, 0x40000)
	

	-- index (0x30000)
	
	-- first 3 values are almost metadata only -- not currently
	-- acted on anywhere. perhaps useful in future for deciding
	-- scope of copy/paste, and gui cues, but can be calculated
	-- from content.
	
	poke2(0x30000,
		64,  -- num_instruments
		512, -- num_tracks (64 patterns * 8 channels for default indexing)
		64,  -- num_patterns
		-- flags: 0x1 use default track indexing (base+0x20000, increments of 328 bytes)
		0x1
	)
	poke4(0x30010,
		0x10000, -- insts_addr      (I32)    relative address of instruments
		0x20000, -- tracks_addr     (I32)    relative address of track index
		0,       -- patterns_addr   (I32)    relative address of pattern data
		0        -- unused          (I32)    should be 0
	)
	poke2(0x30020,
		0,  -- tick len (0 for default -- custom vals not supported yet)
		64, -- default track length
		16 -- default track spd
	)
	
	-- default track speed (+3 unused)
	poke(0x30026, 16, 0, 0, 0) 
	
	-- pattern data: first 16 patterns
	-- want to keep default sfx file quite tiny
	-- .. should be ok to save a whole .sfx for just one inst / experiment
	-- later: interface to generate more default patterns
	
	for pp = 0,0 do
		local addr = 0x30100 + pp * 20
		for i = 0, 7 do
			if i < 4 then
				poke(addr+i, pp*8 + i)
			else
				poke(addr+i, 0)
			end
		end
		poke(addr+8, 0x0)  -- flow flags
		if pp == 0 then
			poke(addr+9, 0x0f) -- channel mask -- 8 channels
		else
			poke(addr+9, 0x00) -- channel mask -- 8 channels
		end
		poke(addr+10, 0,0) -- length (I16)
	end
	
	
	----------------------------------------------------------------------------
	-- single instrument at 0x40000 (instrument 0)
	
	clear_instrument(0)
	
	-- copy default instrument to 1..31
	for i=1,31 do
		memcpy(0x40000 + 0x200*i, 0x40000, 0x200)
	end
	
	
	--------------------------------------------------
	-- Track Data  0x50000
	--------------------------------------------------
	
	-- Default track size is 5 * 64 rows + 8 = 328 bytes
	
	-- header (8)
	
	for track = 0, 7 do
--		init_track(0x50000 + 328 * track)
		init_track(track)
	end
	
	-- copy to other tracks: 128k worth
	-- ** only first 399 are saved / undoable (0x20000\328) **
	-- 384 used in tracker
	--[[
	for i=1,398 do
		memcpy(0x50000 + i*328, 0x50000, 328)
	end
	]]

end


return file
:: src/selection.lua
--[[pod_format="raw",created="2026-01-27 06:45:26",modified="2026-02-19 21:34:53",revision=22558]]
local app = require "src/app.lua"
local sfx = require "src/sfx/sfx.lua"


local selection = {}

----------------------------------------------------------------------------------------------------
-- Locals
----------------------------------------------------------------------------------------------------


local channels = {}
local steps = {}
local parts = 0x0

local anchor_channel
local anchor_step
local anchor_part
local anchor_what
local channels_to_extend
local steps_to_extend
local parts_to_extend


-- Parts
selection.note = 1 << 0
selection.instrument = 1 << 1
selection.volume = 1 << 2
selection.fx = 1 << 3
selection.all_parts =
	selection.note | selection.instrument
	| selection.volume | selection.fx


local parts_before <const> = {
	[selection.note] = selection.note,
	[selection.instrument] = selection.note | selection.instrument,
	[selection.volume] = selection.note | selection.instrument | selection.volume,
	[selection.fx] = selection.note | selection.instrument | selection.volume | selection.fx,
}

local parts_after <const> = {
	[selection.note] = selection.note | selection.instrument | selection.volume | selection.fx,
	[selection.instrument] = selection.instrument | selection.volume | selection.fx,
	[selection.volume] = selection.volume | selection.fx,
	[selection.fx] = selection.fx,
}

local is_unique_part <const> = {
	[selection.note] = true,
	[selection.instrument] = true,
	[selection.volume] = true,
	[selection.fx] = true,
}


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


local function min_part_of(p)
	if p & selection.note ~= 0 then
		return selection.note
	elseif p & selection.instrument ~= 0 then
		return selection.instrument
	elseif p & selection.volume ~= 0 then
		return selection.volume
	elseif p & selection.fx ~= 0 then
		return selection.fx
	end
	return 0
end


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


local function channel_not_valid(channel)
	local track = sfx.pattern_track(app.pattern, channel)
	local size = sfx.track_size(track)
	return size < 1 or sfx.channel_is_muted(app.pattern, channel)
end


----------------------------------------------------------------------------------------------------
-- Creation
----------------------------------------------------------------------------------------------------


function selection.set(channel, step, part)
	if channel then
		channels = { [channel] = true }
	end
	if step then
		local track = sfx.pattern_track(app.pattern, channel)
		local step = mid(step, 0, sfx.track_size(track) - 1)
		steps = { [step] = true }
	end
	if part then
		parts = part
	end
end


function selection.extend(channel, step, part)
	if channel then
		channels[channel] = true
	end
	if step then
		local track = sfx.pattern_track(app.pattern, channel)
		local step = mid(step, 0, sfx.track_size(track) - 1)
		steps[step] = true
	end
	if part then
		parts = parts | part
	end
end


function selection.shrink_channels()
	if selection.channel_count() < 2 then
		return false
	end
	channels[selection.max_channel()] = nil
end


function selection.grow_channels()
	local current_channels = copy_channels()
	local changed = selection.move_to_next_channel()
	for c, v in pairs(current_channels) do
		channels[c] = v
	end
	return changed
end


function selection.grow_steps(delta)
	local current_steps = copy_steps()
	selection.move_step(delta)
	-- TODO: check limits
	for step, v in pairs(current_steps) do
		steps[step] = v
	end
end


function selection.shrink_steps(mode)
	if selection.step_count() < 2 then return end
	steps[selection.max_step()] = nil
end




function selection.shrink_parts()
	if selection.channel_count() > 1 then
		selection.shrink_channels()
	elseif parts == selection.note or parts == selection.instrument
		or parts == selection.volume or parts == selection.fx
	then
		return false
	elseif parts & selection.fx ~= 0 then
		parts ^^= selection.fx
	elseif parts & selection.volume ~= 0 then
		parts ^^= selection.volume
	elseif parts & selection.instrument ~= 0 then
		parts ^^= selection.instrument
	elseif parts & selection.note ~= 0 then
		-- impossible
	end
end


function selection.grow_parts()
	if parts & selection.fx ~= 0 then
		local channel_changed = selection.grow_channels()
		if channel_changed then
			parts |= selection.note
		end
	end
	if parts & selection.volume ~= 0 then
		parts |= selection.fx
	end
	if parts & selection.instrument ~= 0 then
		parts |= selection.volume
	end
	if parts & selection.note ~= 0 then
		parts |= selection.instrument
	end
end


function selection.set_anchor(channel, step, part, how, what)
	local track = sfx.pattern_track(app.pattern, channel)
	local step = mid(step, 0, sfx.track_size(track) - 1)
	if how == "extend" then
		channels_to_extend = channels
		steps_to_extend = steps
		parts_to_extend = parts
	else
		selection.set(channel, step, part)
		channels_to_extend = {}
		steps_to_extend = {}
		parts_to_extend = 0
	end
	anchor_channel = channel
	anchor_step = step
	anchor_part = part
	anchor_what = what
end


function selection.set_from_anchor_to(channel, step, part)
	if not anchor_channel or not anchor_step
		or not anchor_part
	then
		return
	end
	local track = sfx.pattern_track(app.pattern, channel)
	local size = sfx.track_size(track)
	local step = mid(step, 0, size - 1)
	-- Channels
	channels = {}
	for k, v in pairs(channels_to_extend) do channels[k] = v end
	local from = min(channel, anchor_channel)
	local to = max(channel, anchor_channel)
	for c = from, to do
		if not channel_not_valid(c) then
			channels[c] = true
		end
	end
	-- Steps
	steps = {}
	for k, v in pairs(steps_to_extend) do steps[k] = v end
	local from = min(step, anchor_step)
	local to = max(step, anchor_step)
	if anchor_what == "beat" then
		from = from - from % app.beat_length
		to = to - to % app.beat_length + app.beat_length - 1
	elseif anchor_what == "column" or anchor_what == "track" then
		from = 0
		to = size - 1
	end
	from = mid(from, 0, size - 1)
	to = mid(to, 0, size - 1)
	for c = from, to do
		steps[c] = true
	end
	-- Parts
	if 	channel == anchor_channel 
		and (anchor_what == "part" or anchor_what == "column")
	then
		local from = min(anchor_part, part)
		local to = max(anchor_part, part)
		local range_parts = parts_after[from] & parts_before[to]
		parts = parts_to_extend | range_parts
	elseif anchor_what == "column" then
		parts = anchor_part
	else
		parts = selection.all_parts
	end
end


function selection.clear_anchor()
	anchor_channel = nil
	anchor_step = nil
	anchor_part = nil
	channels_to_extend = {}
	steps_to_extend = {}
	parts_to_extend = 0
end


function selection.unset(channel, step, part)
	-- TODO: clear if one of the mask is empty
	if channel then
		channels[channel] = nil
	end
	if step then
		steps[step] = nil
	end
	if part then
		parts = parts & (~part)
	end
end


function selection.clear()
	local min_channel = selection.min_channel()
	local min_step = selection.min_step()
	channels = { [min_channel] = true }
	steps = { [min_step] = true }
	parts = selection.min_part()
end


function selection.sanitize()
	-- Remove muted channels
	for channel, _ in pairs(channels) do
		if channel_not_valid(channel) then
			channels[channel] = nil
		end
	end
	-- Check if there is still some selection
	for channel, cv in pairs(channels) do
		for step, sv in pairs(steps) do
			if cd and sv and channels[channel] and steps[step] then
				-- At least one cursor is not muted,
				-- nothing more to do
				return	
			end
		end
	end
	-- No selection: find the first unmuted channel
	for channel = 0, 7 do
		if not channel_not_valid(channel) then
			channels[channel] = true
			return
		end
	end
end


----------------------------------------------------------------------------------------------------
-- Movement
----------------------------------------------------------------------------------------------------


function selection.move_to_previous_channel()
	local first_channel = find_first_channel(0)
	if channels[first_channel] then
		return false
	end
	local new_channels = {}
	for c, v in pairs(channels) do
		local prev = find_last_channel(c - 1)
		if not prev then
			return false
		end
		new_channels[prev] = v
	end
	channels = new_channels
	return true
end


function selection.move_to_next_channel()
	local last_channel = find_last_channel()
	if channels[last_channel] then
		return false
	end
	local new_channels = {}
	for c, v in pairs(channels) do
		local next = find_first_channel(c + 1)
		if not next then
			return false
		end
		new_channels[next] = v
	end
	channels = new_channels
	return true
end


function selection.move_step(delta)
	local max_size = sfx.pattern_max_size(app.pattern) -- TODO: is this correct?
	local new_steps = {}
	for s, v in pairs(steps) do
		local step = s + delta
		if step < 0 or step >= max_size then
			return false
		end
		new_steps[step] = v
	end
	steps = new_steps
	return true
end


function selection.move_to_step(channel, step, part)
	-- Move channels
	local min_channel = selection.min_channel()
	local max_channel = selection.max_channel()
	local channel_delta = channel - min_channel
	channel_delta = mid(channel_delta, - min_channel, 7 - max_channel)
	while channel_delta < 0 do
		selection.move_to_previous_channel()
		channel_delta += 1
	end
	while channel_delta > 0 do
		selection.move_to_next_channel()
		channel_delta -= 1
	end
	-- Move steps
	local size = sfx.pattern_max_size(app.pattern)
	local min_step = selection.min_step()
	local max_step = selection.max_step()
	local step_delta = step - min_step
	step_delta = mid(step_delta, - min_step, size - 1 - max_step)
	selection.move_step(step_delta)
	-- Parts
	if is_unique_part[parts] then
		parts = part
	end
end


function selection.move_to_previous_part()
	-- TODO: should probably cache these in a table...
	if parts == 0 then
		return
	elseif parts == selection.note then
		local channel_changed = selection.move_to_previous_channel()
		if channel_changed then
			parts = selection.fx
		end
	elseif parts == selection.instrument then
		parts = selection.note
	elseif parts == selection.volume then
		parts = selection.instrument
	elseif parts == selection.fx then
		parts = selection.volume
	else -- multiple parts
		parts = selection.min_part()
	end
end


function selection.move_to_next_part()
	-- TODO: should probably cache these in a table...
	if parts == 0 then
		return
	elseif parts == selection.note then
		parts = selection.instrument
	elseif parts == selection.instrument then
		parts = selection.volume
	elseif parts == selection.volume then
		parts = selection.fx
	elseif parts == selection.fx then
		local channel_changed = selection.move_to_next_channel()
		if channel_changed then
			parts = selection.note
		end
	else -- multiple parts
		parts = selection.max_part()
	end
end


----------------------------------------------------------------------------------------------------
-- Querying
----------------------------------------------------------------------------------------------------


function selection.has_cursor()
	local has_channels = (next(channels) ~= nil)
	local has_steps = (next(steps) ~= nil)
	return has_channels and has_steps and parts ~= 0
end


function selection.has_selection()
	-- TODO: something more efficient? (called each frame in update)
	if parts ~= 0 and parts ~= selection.note and parts ~= selection.instrument
		and parts ~= selection.volume and parts ~= selection.fx
	then
		return true
	end
	return selection.channel_count() > 1
		or selection.step_count() > 1
end


function selection.has_channel(channel)
	return channels[channel] or false
end


function selection.channels()
	local result = {}
	for c, v in pairs(channels) do
		if v then
			add(result, c)
		end
	end
	return result
end


function selection.has_step(step)
	return steps[step] or false
end


function selection.channel_count()
	local count = 0
	for _, v in pairs(channels) do
		if v then
			count += 1
		end
	end
	return count
end


function selection.step_count()
	local count = 0
	for _, v in pairs(steps) do
		if v then
			count += 1
		end
	end
	return count
end


function selection.steps()
	local result = {}
	for c, v in pairs(steps) do
		if v then
			add(result, c)
		end
	end
	return result
end


function selection.has_part(part)
	return parts & part ~= 0
end


function selection.parts()
	return parts
end


function selection.min_channel()
	local min = 9
	for c, v in pairs(channels) do
		if v and c < min then
			min = c
		end
	end
	if min == 9 then
		return 0 -- safer than nil or false
	end
	return min
end


function selection.max_channel()
	local max = -1
	for c, v in pairs(channels) do
		if v and (c > max) then
			max = c
		end
	end
	if max == -1 then
		return 0 -- safer than nil or false
	end
	return max
end


function selection.unique_step()
	local step
	local count = 0
	for k, v in pairs(steps) do
		if v then
			step = k
			count += 1
		end
	end
	if count == 1 then
		return step
	end
end


function selection.min_step()
	local min = 999999 -- hmmm..
	for s, _ in pairs(steps) do
		if s < min then
			min = s
		end
	end
	if min == 999999 then
		return 0 -- safer than nil or false
	end
	return min
end


function selection.max_step()
	local max = -1
	for s, _ in pairs(steps) do
		if s > max then
			max = s
		end
	end
	if max == -1 then
		return 0 -- safer than nil or false
	end
	return max
end


function selection.max_step_span()
	local max_count = 0
	for s, v in pairs(steps) do
		if v then
			local count = 1
			local next_s = s + 1
			while steps[next_s] do
				count += 1
				next_s += 1
			end
			if count > max_count then
				max_count = count
			end
		end
	end
	return max_count
	--[[
	local max_count = 0
	local count = 0
	local prev_step
	local step_array = selection.steps()
	notify(pod(step_array))
	for s in all(step_array) do
		if not prev_step then
			if count > max_count then
				max_count = count
			end
			count = 1
		elseif s == prev_step + 1 then
			count += 1
		end
		prev_step = s
	end
	return max_count
	--]]
end


function selection.min_part()
	return min_part_of(parts)
end


function selection.max_part()
	if parts & selection.fx ~= 0 then
		return selection.fx
	elseif parts & selection.volume ~= 0 then
		return selection.volume
	elseif parts & selection.instrument ~= 0 then
		return selection.instrument
	elseif parts & selection.note ~= 0 then
		return selection.note
	end
	return 0
end


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


function selection.jump_step()
	local selection_size = selection.max_step() - selection.min_step() + 1
	if app.jump_step == 0 or selection_size > 1 then
		return 0
	else
		return app.jump_step
	end
end



-- Old algorithm
--[[
function selection.jump_step()
	local selection_span = selection.max_step_span()
	-- This seem convoluted, but is actually pretty intuitive.
	-- A jump step of 1 is actually the neutral position,
	-- other values are relative to it.
	if app.jump_step == 0 then
		return 0
	elseif selection_span == 1 then
		return app.jump_step
	elseif app.jump_step == 1 then
		return selection_span
	elseif selection_span > 1 then
		return selection_span + app.jump_step
	end
end
--]]


function selection.extended_jump_step()
	local selection_span = selection.max_step() - selection.min_step() + 1
	if app.jump_step == 0 then
		return 0
	else
		return selection_span + app.jump_step - 1
	end
end


----------------------------------------------------------------------------------------------------
-- Iteration
----------------------------------------------------------------------------------------------------

	
function selection.for_each_channel(func)
	for channel in all(selection.channels()) do
		local track = sfx.pattern_track(app.pattern, channel)
		func(channel, track)
	end
end

	
function selection.for_each_channel_each_step(func)
	for channel in all(selection.channels()) do
		local track = sfx.pattern_track(app.pattern, channel)
		for step in all(selection.steps()) do
			func(track, step)
		end
	end
end


----------------------------------------------------------------------------------------------------
-- Copy / Pase
----------------------------------------------------------------------------------------------------


function selection.pack(mode)
	local result = {
		parts = mode == "rows" and selection.all_parts or parts,
		columns = {}
	}
	for channel = selection.min_channel(), selection.max_channel() do
		local rows = {}
		if channels[channel] then
			local track <const> = sfx.pattern_track(app.pattern, channel)
			local size <const> = sfx.track_size(track)
			for step = selection.min_step(), selection.max_step() do
				if step < size and steps[step] then
					local row = {
						pitch = sfx.track_pitch(track, step),
						instrument = sfx.track_instrument(track, step),
						volume = sfx.track_volume(track, step),
						fx = sfx.track_fx(track, step),
						fx_params = sfx.track_fx_params(track, step),
					}
					add(rows, row)
				else
					add(rows, {})
				end
			end
		end
		add(result.columns, rows)
	end
	return result
end


function selection.unpack(package)
	local starting_channel = selection.min_channel()
	local starting_step = selection.min_step()
	if not package.parts or not package.columns then return false end
	for c, column in ipairs(package.columns) do
		for s, row in ipairs(column) do
			local channel = starting_channel + c - 1
			local step = starting_step + s - 1
			if channel <= 7 then
				local track <const> = sfx.pattern_track(app.pattern, channel)
				if row.pitch and step < sfx.track_size(track) then
					if package.parts & selection.note ~= 0 then
						sfx.set_track_pitch(track, step, row.pitch)
					end
					if package.parts & selection.instrument ~= 0 then
						if not row.instrument then return false end
						sfx.set_track_instrument(track, step, row.instrument)
					end
					if package.parts & selection.volume ~= 0 then
						if not row.volume then return false end
						sfx.set_track_volume(track, step, row.volume)
					end
					if package.parts & selection.fx ~= 0 then
						if not row.fx or not row.fx_params then return false end
						sfx.set_track_fx(track, step, row.fx)
						sfx.set_track_fx_params(track, step, row.fx_params)
					end
				end
			end
		end
	end
	return true
end


----------------------------------------------------------------------------------------------------
-- Undo / Redo
----------------------------------------------------------------------------------------------------


function selection.state()
	return { channels = channels, steps = steps, parts = parts }
end


function selection.set_state(state)
	channels = state.channels
	steps = state.steps
	parts = state.parts
end


----------------------------------------------------------------------------------------------------
-- Helper Functions
----------------------------------------------------------------------------------------------------


function copy_channels()
	local result = {}
	for k, _ in pairs(channels) do
		result[k] = true
	end
	return result
end


function copy_steps()
	local result = {}
	for k, _ in pairs(steps) do
		result[k] = true
	end
	return result
end


function find_first_channel(channel)
	channel = channel or 0
	while channel_not_valid(channel) and channel <= 8 do
		channel += 1
	end
	if channel == 8 then
		return nil
	end
	return channel
end


function find_last_channel(channel)
	channel = channel or 7
	while channel_not_valid(channel) and channel >= -1 do
		channel -= 1
	end
	if channel == -1 then
		return nil
	end
	return channel
end


return selection
:: src/settings.lua
--[[pod_format="raw",created="2024-04-11 08:58:08",modified="2026-02-19 21:34:53",revision=28706]]
local settings = {}

local settings_folder = "/appdata/wavemaker/"
local settings_filepath = "/appdata/wavemaker/settings.pod"
local keys_filepath = "/appdata/wavemaker/keys.pod"


settings.piano_keys = { pitched = {
	{
		offset = -12,
		[0] = "z", "s", "x", "d", "c", "v", "g", "b", "h", "n", "j", "m",
		",", "l", ".", ";", "/"
	},
	{
		offset = 0,
		[0] = "q", "2", "w", "3", "e", "r", "5", "t", "6", "y", "7", "u",
		"i", "9", "o", "0", "p",
	}
}}


settings.guitar_keys = { pitched = {
	{
		offset = 0,
		[0] = "z", "x", "c", "v", "b", "n", "m", ",", ".", "/",
	},
	{
		offset = 5,
		[0] = "a", "s", "d", "f", "g", "h", "j", "k", "l", ";", "'",
	},
	{
	offset = 10,
		[0] = "q", "w", "e", "r", "t", "y", "u", "i", "o", "p", "[", "]", "\\",
	},
	{
	offset = 15,
		[0] = "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "-", "=",
	}
}}


settings.gl_two_handed_keys = { pitched = {
	{
		offset = 0,
		[0] = 
			"z", "x", "c", "v", "b", 
			"a", "s", "d", "f", "g",
			"q", "w", "e", "r", "t",
			"1", "2", "3", "4", "5",
	},
	{
		offset = 11,
		[0] = 
			"n", "m", ",", ".", "/", 
			"h", "j", "k", "l", ";",
			"y", "u", "i", "o", "p",
			"6", "7", "8", "9", "0",
	},
}}


settings.major_thirds_keys = { pitched = {
	{
		offset = 0,
		[0] =
			"z", "x", "c", "v",
			"a", "s", "d", "f",
			"q", "w", "e", "r",
			"1", "2", "3", "4",
	},
	{ offset = 12,
		[0] = "t",
	},
	{
		offset = 12,
		[0] =
			"m", ",", ".", "/",
			"j", "k", "l", ";",
			"u", "i", "o", "p",
			"7", "8", "9", "0",
	},
}}


settings.chromatic_keys = { pitched = {
	{
		offset = 0,
		[0] = "z", "x", "c", "v", "b", "n", "m", ",", ".", "/",
	},
	{
		offset = 10,
		[0] = "a", "s", "d", "f", "g", "h", "j", "k", "l", ";", "'",
	},
	{
	offset = 20,
		[0] = "q", "w", "e", "r", "t", "y", "u", "i", "o", "p", "[", "]", "\\",
	},
	{
	offset = 30,
		[0] = "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "-", "=",
	}
}}

settings.keys = {
	pitched = settings.piano_keys.pitched,
	play = "space",
	rest = "del",
}


settings.user = {
	pitched_layout = "piano-like",
	drag_sensitivity = 0.5,
	sustain_line_enabled = true,
	instrument_square_enabled = true,
	look_back = 4,
	look_ahead = 6,
}


function settings.load()
	mkdir(settings_folder)
	local user_keys = fetch(keys_filepath)
	if user_keys then
		for k, v in pairs(settings.keys) do
			if user_keys[k] then
				settings.keys[k] = user_keys[k]
			end
		end
	end
	local user_settings = fetch(settings_filepath)
	if user_settings then
		for k, v in pairs(settings.user) do
			if user_settings[k] then
				settings.user[k] = user_settings[k]
			end
		end
	end
end


function settings.change_keys(t)
	for k, v in pairs(t) do
		settings.keys[k] = v
	end
	store(keys_filepath, settings.keys)
end


function settings.change_user(t)
	for k, v in pairs(t) do
		settings.user[k] = v
	end
	store(settings_filepath, settings.user)
end


return settings
:: src/sfx/sfx.lua
--[[pod_format="raw",created="2024-04-07 08:22:05",modified="2026-02-19 21:34:53",revision=33192]]
local sfx = {}


----------------------------------------------------------------------------------------------------
-- Stat
----------------------------------------------------------------------------------------------------


function sfx.playing_channels()
	return stat(464)
end


function sfx.music_is_playing()
--	return stat(464) ~= 0
	return stat(466) ~= -1
end


function sfx.channel_is_playing(channel)
	local mask = 1 << channel
	return (stat(464) & mask) ~= 0
end


function sfx.playing_pattern()
	return stat(466)
end


function sfx.playing_lead_channel()
	return stat(467)
end


function sfx.playing_channel_row(channel)
	return stat(400 + channel, 9)
end

function sfx.playing_row()
	return sfx.playing_channel_row(sfx.playing_lead_channel())
end

--[[
--TODO:
stat(400 + c,  0) -- note is held (0 false 1 true)
stat(400 + c,  1) -- channel instrument
stat(400 + c,  2) -- channel vol
stat(400 + c,  3) -- channel pan
stat(400 + c,  4) -- channel pitch
stat(400 + c,  5) -- channel bend
stat(400 + c,  6) -- channel effect
stat(400 + c,  7) -- channel effect_p
stat(400 + c,  8) -- channel tick len
stat(400 + c,  9) -- channel row
stat(400 + c, 10) -- channel row tick
stat(400 + c, 11) -- channel sfx tick
stat(400 + c, 12) -- channel sfx index (-1 if none finished)
stat(400 + c, 13) -- channel last played sfx index 
--]]

----------------------------------------------------------------------------------------------------
-- Header
----------------------------------------------------------------------------------------------------


-- This should probably be configurable?
local baddr <const> = 0x30000


local function paddr()
	-- default 0x030100 = base + 0x000100
	return baddr + peek4(baddr + 0x18) + 0x100
end
local function saddr()
	-- default 0x040000 = base + 0x010000
	return baddr + peek4(baddr + 0x10)
end
local function taddr()
	-- default 0x050000 = base + 0x020000
	return baddr + peek4(baddr + 0x14)
end


local function defaddr()
	return peek(baddr + 0x6) & 0x01 ~= 0
end


function sfx.num_instruments()
	return peek2(baddr)
end


function sfx.num_tracks()
	if defaddr() then
		-- Since Picotron 0.1.0h the default tracker is supposed
		-- to support 384 tracks, but can only use 256, since in the
		-- file format there is only 1 byte to store track IDs.
		-- Also, the info stored at this address in sfx files says
		-- 512, which correspong to neither...
		return 256
	else
		return peek2(baddr + 0x2)
	end
end


function sfx.num_patterns()
	if defaddr() then
		return 128
	else
		return peek2(baddr + 0x4)
	end
end


sfx.default_addressing = defaddr


function sfx.instruments_address()
	return saddr()
end


function sfx.tracks_address()
	return taddr()
end


function sfx.patterns_address()
	return paddr()
end


function sfx.tick_length()
	return peek2(baddr + 0x20)
end


function sfx.set_tick_length(value)
	return poke2(baddr + 0x20, value)
end


function sfx.default_length()
	return peek2(baddr + 0x22)
end


function sfx.set_default_length(value)
	-- TODO: doesn't seem to work?
	return poke2(baddr + 0x22, value)
end


function sfx.default_speed()
	return peek2(baddr + 0x26)
end


function sfx.set_default_speed(value)
	-- TODO: doesn't seem to work?
	return poke2(baddr + 0x26, value)
end


----------------------------------------------------------------------------------------------------
-- Pattern Info
----------------------------------------------------------------------------------------------------


function sfx.pattern_length(pattern)
	return peek2(paddr() + (pattern * 20) + 10)
end


function sfx.set_pattern_length(pattern, value)
	poke2(paddr() + (pattern * 20) + 10, value)
end

function sfx.pattern_loop_start(pattern)
	return (peek(paddr() + (pattern * 20) + 8) & 0x01) != 0
end


function sfx.set_pattern_loop_start(pattern, bool)
	local old = peek(paddr() + (pattern * 20) + 8)
	if bool then
		poke(paddr() + (pattern * 20) + 8, old | 0x01)
	else
		poke(paddr() + (pattern * 20) + 8, old & (~ 0x01))
	end
end


function sfx.pattern_loop_end(pattern)
	return (peek(paddr() + (pattern * 20) + 8) & 0x02) != 0
end


function sfx.set_pattern_loop_end(pattern, bool)
	local old = peek(paddr() + (pattern * 20) + 8)
	if bool then
		poke(paddr() + (pattern * 20) + 8, old | 0x02)
	else
		poke(paddr() + (pattern * 20) + 8, old & (~ 0x02))
	end
end


function sfx.pattern_loop_stop(pattern)
	return (peek(paddr() + (pattern * 20) + 8) & 0x04) != 0
end


function sfx.set_pattern_loop_stop(pattern, bool)
	local old = peek(paddr() + (pattern * 20) + 8)
	if bool then
		poke(paddr() + (pattern * 20) + 8, old | 0x04)
	else
		poke(paddr() + (pattern * 20) + 8, old & (~ 0x04))
	end
end


function sfx.pattern_channels(pattern)
	return peek(paddr() + (pattern * 20) + 9)
end


function sfx.channel_is_muted(pattern, channel)
	local channel_mutes = peek(paddr() + (pattern * 20) + 9)
	local muted = (channel_mutes & (1 << channel)) == 0
	return muted
end


function sfx.mute_channel(pattern, channel, mute)
	local channel_mutes = peek(paddr() + (pattern * 20) + 9)
	channel_mutes &= ~(1 << channel)
	channel_mutes |= (mute and 0 or 1) << channel
	poke(paddr() + (pattern * 20) + 9, channel_mutes)
end


function sfx.pattern_track(pattern, channel)
	return peek(paddr() + pattern * 20 + channel)
end


function sfx.set_pattern_track(pattern, channel, track)
	poke(paddr() + pattern * 20 + channel, track)
end


function sfx.remove_pattern(pattern)
	local last_pattern = sfx.num_patterns() - 1
	local addr = paddr() + pattern * 20
	local size = (last_pattern - pattern) * 20
	memcpy(addr, addr + 20, size)
	local last_addr = paddr() + last_pattern * 20
	memset(last_addr, 0, 20)
end


function sfx.insert_pattern(pattern)
	local last_pattern = sfx.num_patterns() - 1
	local addr = paddr() + pattern * 20
	local size = (last_pattern - pattern) * 20
	memcpy(addr + 20, addr, size)
	memset(addr, 0, 20)
end


function sfx.copy_pattern(pattern)
	local addr = paddr() + pattern * 20
	local ud = userdata("u8", 20)
	ud:peek(addr)
	return ud
end


function sfx.paste_pattern(pattern, ud)
	local width, height, typ = ud:attribs()
	assert(width == 20 and height == 1 and typ == "u8")
	local addr = paddr() + pattern * 20
	ud:poke(addr)
end


----------------------------------------------------------------------------------------------------
-- Track Info
----------------------------------------------------------------------------------------------------


local function tstride()
	if defaddr() then
		return 328 -- i.e. 64 rows * 5 columns + 8 byte header
	else
		return 328 -- TODO: how to know the track size?
	end
end


function sfx.track_size(track)
	return peek2(taddr() + (track * tstride())) -- TODO
end


function sfx.set_track_size(track, value)
	poke2(taddr() + (track * tstride()), value)
end


function sfx.pattern_max_size(pattern)
	local max_length = 0
	for channel = 0, 7 do
		local track = sfx.pattern_track(pattern, channel)
		max_length = max(sfx.track_size(track), max_length)
	end
	return max_length
end


function sfx.track_speed(track)
	return peek(taddr() + (track * tstride()) + 2)
end


function sfx.set_track_speed(track, val)
	return poke(taddr() + (track * tstride()) + 2, val)
end


function sfx.track_loop0(track)
	return peek(taddr() + (track * tstride()) + 3)
end


function sfx.set_track_loop0(track, val)
	return poke(taddr() + (track * tstride()) + 3, val)
end


function sfx.track_loop1(track)
	return peek(taddr() + (track * tstride()) + 4)
end


function sfx.set_track_loop1(track, val)
	poke(taddr() + (track * tstride()) + 4, val)
end


function sfx.track_is_looping(track)
	local loop0 <const> = sfx.track_loop0(track)
	local loop1 <const> = sfx.track_loop1(track)
	return loop1 > loop0
end


function sfx.track_length(track)
	local loop0 <const> = sfx.track_loop0(track)
	local loop1 <const> = sfx.track_loop1(track)
	local length = max(loop0, loop1)
	if length == 0 then
		return sfx.default_length()
	end
	return length
end	


function sfx.track_delay(track)
	return peek(taddr() + (track * tstride()) + 5)
end


function sfx.set_track_delay(track, val)
	poke(taddr() + (track * tstride()) + 5, val)
end


function sfx.track_flags(track)
	return peek(taddr() + (track * tstride()) + 6)
end


function sfx.set_track_flags(track, flags)
	return poke(taddr() + (track * tstride()) + 6, flags)
end


function sfx.track_unused(track)
	return peek(taddr() + (track * tstride()) + 7)
end


function sfx.set_track_unused(track, flags)
	return poke(taddr() + (track * tstride()) + 7, flags)
end


----------------------------------------------------------------------------------------------------
-- Track Notes
----------------------------------------------------------------------------------------------------


function sfx.track_row(track, step)
	local row = userdata("u8", 5)
	row:peek(taddr() + 8 + (track * tstride()) + step + (0 * 64), 0, 1)
	row:peek(taddr() + 8 + (track * tstride()) + step + (1 * 64), 1, 1)
	row:peek(taddr() + 8 + (track * tstride()) + step + (2 * 64), 2, 1)
	row:peek(taddr() + 8 + (track * tstride()) + step + (3 * 64), 3, 1)
	row:peek(taddr() + 8 + (track * tstride()) + step + (4 * 64), 4, 1)
	return row
end


function sfx.set_track_row(track, step, row)
	row:poke(taddr() + 8 + (track * tstride()) + step + (0 * 64), 0, 1)
	row:poke(taddr() + 8 + (track * tstride()) + step + (1 * 64), 1, 1)
	row:poke(taddr() + 8 + (track * tstride()) + step + (2 * 64), 2, 1)
	row:poke(taddr() + 8 + (track * tstride()) + step + (3 * 64), 3, 1)
	row:poke(taddr() + 8 + (track * tstride()) + step + (4 * 64), 4, 1)
end


local empty_row_ud <const> = userdata("u8", 5, "ffffff0000")
function sfx.empty_row()
	return empty_row_ud
end


function sfx.track_pitch(track, step)
	return peek(taddr() + 8 + (track * tstride()) + step)
end


function sfx.set_track_pitch(track, step, v)
	return poke(taddr() + 8 + (track * tstride()) + step, v)
end


function sfx.track_instrument(track, step)
	return peek(taddr() + 8 + (track * tstride()) + step + 64)
end


function sfx.set_track_instrument(track, step, v)
	return poke(taddr() + 8 + (track * tstride()) + step + 64, v)
end


function sfx.track_volume(track, step)
	return peek(taddr() + 8 + (track * tstride()) + step + (2 * 64))
end


function sfx.set_track_volume(track, step, v)
	return poke(taddr() + 8 + (track * tstride()) + step + (2 * 64), v)
end


function sfx.track_fx(track, step)
	return peek(taddr() + 8 + (track * tstride()) + step + (3 * 64))
end


function sfx.set_track_fx(track, step, v)
	return poke(taddr() + 8 + (track * tstride()) + step + (3 * 64), v)
end


function sfx.track_fx_params(track, step)
	return peek(taddr() + 8 + (track * tstride()) + step + (4 * 64))
end


function sfx.track_fx_param0(track, step)
	return peek(taddr() + 8 + (track * tstride()) + step + (4 * 64)) >> 4
end


function sfx.track_fx_param1(track, step)
	return peek(taddr() + 8 + (track * tstride()) + step + (4 * 64)) & 0xf
end


function sfx.set_track_fx_params(track, step, v)
	return poke(taddr() + 8 + (track * tstride()) + step + (4 * 64), v)
end


function sfx.set_track_fx_param0(track, step, v)
	local previous = peek(taddr() + 8 + (track * tstride()) + step + (4 * 64))
	return poke(taddr() + 8 + (track * tstride()) + step + (4 * 64), (previous & 0x0f) | (v << 4))
end


function sfx.set_track_fx_param1(track, step, v)
	local previous = peek(taddr() + 8 + (track * tstride()) + step + (4 * 64))
	return poke(taddr() + 8 + (track * tstride()) + step + (4 * 64), (previous & 0xf0) | (v & 0x0f))
end


----------------------------------------------------------------------------------------------------
-- Synth: Instrument Info
----------------------------------------------------------------------------------------------------


function sfx.instrument_name(instrument)
	local inst_addr = saddr() + instrument * 0x200
	local length = 16
	for j = 15, 0, -1 do
		if peek(inst_addr + 496 + j) == 0 then
			length = j
		end
	end
	return chr(peek(inst_addr + 496, length))
end


function sfx.set_instrument_name(instrument, name)
	if type(name) ~= "string" then return end
	local inst_addr = saddr() + instrument * 0x200
	memset(inst_addr + 496, 0, 16)
	poke(inst_addr + 496, ord(name, 1, min(16, #name)))
end


function sfx.instrument_flag(instrument, flag)
	local inst_addr = saddr() + instrument * 0x200
	local addr = inst_addr + 0x1df
	return (peek(addr) & flag) > 0
end


function sfx.set_instrument_flag(instrument, flag, value)
	local inst_addr = saddr() + instrument * 0x200
	local addr = inst_addr + 0x1df
	local other_flags = peek(addr) & (~ flag)
	if value then
		poke(addr, other_flags | flag)
	else
		poke(addr, other_flags)
	end
end


function sfx.toggle_instrument_flag(instrument, flag)
	local inst_addr = saddr() + instrument * 0x200
	local addr = inst_addr + 0x1df
	local previous = peek(addr)
	poke(addr, previous ^^ flag)
end


function sfx.wavetable_info(instrument, wt_index)
	local inst_addr = saddr() + instrument * 0x200
	local wt_4defs_addr = inst_addr + 0x1e0 -- start of the 4 wt definitions
	local wt_def_addr = wt_4defs_addr + wt_index * 4
	local addr0, addr1, width_bits, wt_height = peek(wt_def_addr,4)
	local dat_addr = (addr0 << 8) | (addr1 << 16)
	local wt_width = 1 << width_bits
	return dat_addr, wt_width, wt_height
end


----------------------------------------------------------------------------------------------------
-- Synth: Node Tree
----------------------------------------------------------------------------------------------------


sfx.nodes = {}
for n = 0, 7 do
	sfx.nodes[n] = {
		parent = nil, -- id of the parent
		children = {}, -- list of direct references to the children
		type = nil,
	}
end
	

local function depth_walk(root, pre_fun, post_fun, depth)
	if (not depth) depth = 0
	if depth > 8 then
		-- TODO: remove notification
		notify("*** Deep recursion: cycle in synth nodes? ***")
		return
	end
	if (pre_fun) pre_fun(root)
	for i = 1, #root.children do
		local child = root.children[i]
		if child.type != 0 then
			depth_walk(child, pre_fun, post_fun, depth + 1)
		end
	end
	if (post_fun) post_fun(root)
end


function sfx.refresh_nodes(instrument)
	for n = 0, 7 do
		sfx.nodes[n].id = n
		sfx.nodes[n].children = {}
		sfx.nodes[n].older_sibling = nil
		sfx.nodes[n].height = nil -- TODO: or 0?
		sfx.nodes[n].position = nil
	end
	sfx.root = sfx.nodes[0]
	sfx.root.free_nodes = 7
	--- printh("* refresh *")
	for n = 0, 7 do
		local type = sfx.node_type(instrument, n)
		local op = sfx.node_op(instrument, n)
		local parent_id = sfx.node_parent(instrument, n)
		--- printh("" .. parent_id .. " -> " .. n .. " type=" .. type .. " op=" .. op)
		sfx.nodes[n].parent = sfx.nodes[parent_id]
		sfx.nodes[n].type = type
		sfx.nodes[n].op = op
		sfx.nodes[n].last_child = function(self)
			if (#self.children == 0) return self
			return self.children[#self.children]:last_child()
		end
		if type != 0 and n != 0 then
			add(sfx.nodes[n].parent.children, sfx.nodes[n])
			sfx.root.free_nodes -= 1
		end
	end
	
	depth_walk(
		sfx.root,
		nil,
		function(node)
			if #node.children == 0 then
				node.height = 1
			else
				local h = 0
				for i = 1, #node.children do
					local child = node.children[i]
					if i > 1 then
						child.older_sibling = node.children[i - 1]
					end
					h += child.height
				end
				node.height = h
			end
		end
	)

	sfx.root.position = { row = 0, column = 0 }
	depth_walk(
		sfx.root,
		function(node)
			local row = node.position.row
			for i = 1, #node.children do
				node.children[i].position = {
					column = node.position.column + 1,
					row = row,
				}
				row += node.children[i].height
			end
		end,
		nil
	)
end


function sfx.add_node(instrument, parent_id, node_type, node_op, target_id, child_id)
	local parent = sfx.nodes[parent_id]
	
	if (not parent) notify("invalid parent (nil)"); return
	if (parent.type >= 8) notify("invalid parent (filter)"); return

	if target_id >= 8 then
		-- no room!
		return
	end	

	sfx.insert_node(instrument, target_id, parent_id, child_id)
	
	if node_type == 0x2 and node_op == 1 then
		-- FM mod osc
		sfx.set_node_type(instrument, target_id, node_type)
		sfx.set_node_op(instrument, target_id, node_op)
		sfx.set_node_param_val1(instrument, target_id, 0, 0x20) -- volume
		sfx.set_node_param_flags(instrument, target_id, 2, 0x02) -- not quantized, and relation + for tune
		sfx.set_node_param_flags(instrument, target_id, 3, 0x01) -- relation + for bend
	elseif node_type == 0x2 and node_op == 2 then
		-- Ring mod osc
		sfx.set_node_type(instrument, target_id, node_type)
		sfx.set_node_op(instrument, target_id, node_op)
		sfx.set_node_param_val1(instrument, target_id, 0, 0x20) -- volume
		sfx.set_node_param_flags(instrument, target_id, 2, 0x01) -- not quantized, and relation + for tune
		sfx.set_node_param_flags(instrument, target_id, 3, 0x01) -- relation + for bend
	elseif node_type == 0x2 then
		-- Osc
		sfx.set_node_type(instrument, target_id, node_type)
		sfx.set_node_op(instrument, target_id, node_op)
		sfx.set_node_param_val1(instrument, target_id, 0, 0x30) -- volume
		sfx.set_node_param_flags(instrument, target_id, 0, 0x02) -- relation * for volume
		sfx.set_node_param_flags(instrument, target_id, 1, 0x01) -- relation + for pan
		sfx.set_node_param_flags(instrument, target_id, 2, 0x21) -- quantized, and relation + for tune
		sfx.set_node_param_flags(instrument, target_id, 3, 0x01) -- relation + for bend
	elseif node_type == 0xa then
		sfx.set_node_type(instrument, target_id, node_type)
		sfx.set_node_param_val1(instrument, target_id, 3, 0x40) -- mix
	else
		sfx.set_node_type(instrument, target_id, node_type)
	end
	return target_id
end


----------------------------------------------------------------------------------------------------
-- Synth: Node Configuration
----------------------------------------------------------------------------------------------------


function sfx.delete_node(instrument, node_id)
	local deleted_node_parent = sfx.node_parent(instrument, node_id)
	local inst_addr = saddr() + instrument * 0x200
	-- move everything up
	for j = node_id, 7 do
		memcpy(inst_addr + j * 0x20, inst_addr + (j + 1) * 0x20, 0x20)
	end
	memset(inst_addr + 7 * 0x20, 0, 0x20)
	-- fix parents
	for j = 0, 6 do
		local parent = sfx.node_parent(instrument, j)
		if parent == node_id then
			sfx._set_node_parent(instrument, j, deleted_node_parent)
		elseif parent > node_id then
			sfx._set_node_parent(instrument, j, parent - 1)
		end
	end
end


function sfx.insert_node(instrument, node_id, parent_id, child_id)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node_id * 0x20
	-- move everything down
	for j = 7, node_id + 1, -1 do
		memcpy(inst_addr + j * 0x20, inst_addr + ( j - 1) * 0x20, 0x20)
	end
	memset(node_addr, 0, 0x20)
	-- fix parents
	poke(node_addr, parent_id)
	for j = 0, 7 do
		local parent = sfx.node_parent(instrument, j)
		if parent >= node_id then
			sfx._set_node_parent(instrument, j, parent + 1)
		end
	end
	if child_id then
		if child_id >= node_id then
			child_id += 1
		end
		if child_id <= 7 then
			sfx._set_node_parent(instrument, child_id, node_id)
		end
	end
end


function sfx.node_parent(instrument, node)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr + 0) & 0x7	
end

function sfx._set_node_parent(instrument, node, parent)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	local previous = peek(node_addr + 0)
	poke(node_addr + 0, (previous & ~0x7) | (parent & 0x7))
end

function sfx.node_op(instrument, node)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr) >> 4
end

function sfx.set_node_op(instrument, node, op)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	local previous = peek(node_addr)
	poke(node_addr, (previous & 0x0f) | (op << 4))
end

function sfx.node_type(instrument, node)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr + 1) & 0xf
end

function sfx.set_node_type(instrument, node, type)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	local previous = peek(node_addr + 1)
	poke(node_addr + 1, (previous & 0xf0) | (type & 0x0f))
end

function sfx.node_osc_wavetable(instrument, node)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr + 1) >> 4
end

function sfx.set_node_osc_wavetable(instrument, node, wt)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	local previous = peek(node_addr + 1)
	poke(node_addr + 1, (previous & 0x0f) | (wt << 4))
end

function sfx.node_flags(instrument, node)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr + 2)
end

function sfx.set_node_flags(instrument, node, flags)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 2, flags)
end

-- node_addr + 3 is unused

-- 0 <= p <= 7
function sfx.node_param(instrument, node, p)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	local flags,val1,val0,env = peek(node_addr + 4 + (4 * p), 4)
	return flags, val1, val0, env
end


function sfx.param_scale(flags)
	local bits = 0
	if flags & 0xc0 == 0 then return 1 end
	if flags & 0x40 >  0 then
		bits += 2
	end
	if flags & 0x80 >  0 then
		bits += 2
	end
	return (flags & 0x20) > 0 and 1 / (1 << bits) or (1 << bits)
end


function sfx.set_node_param_flags(instrument, node, p, flags)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 4 + (4 * p), flags)
end

function sfx.set_node_param_val1(instrument, node, p, val1)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 4 + (4 * p) + 1, val1)
end

function sfx.set_node_param_val0(instrument, node, p, val0)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 4 + (4 * p) + 2, val0)
end

function sfx.set_node_param_env(instrument, node, p, env)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 4 + (4 * p) + 3, env)
end

function sfx.node_wavetable_info(instrument, node)
	local inst_addr = saddr() + instrument * 0x200
	local wt_4defs_addr = inst_addr + 0x1e0 -- start of the 4 wt definitions
	local node_addr = inst_addr + node * 0x20
	local wt_index = (peek(node_addr+1)>>4)
	local wt_def_addr = wt_4defs_addr + wt_index * 4
	local addr0, addr1, width_bits, wt_height = peek(wt_def_addr,4)
	local dat_addr = (addr0 << 8) | (addr1 << 16)
	local wt_width = 1 << width_bits
	return dat_addr, wt_width, wt_height
end

function sfx.node_wavetable_index(instrument, node)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	local wt_index = (peek(node_addr+1)>>4)
	return wt_index
end


----------------------------------------------------------------------------------------------------
-- Synth: Envelopes
----------------------------------------------------------------------------------------------------


function sfx.env_type(instrument, env)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr)
end


function sfx.set_env_type(instrument, env, type)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr, type)
end


function sfx.env_flags(instrument, env)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 1)
end


function sfx.set_env_flags(instrument, env, flags)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 1, flags)
end


function sfx.env_speed(instrument, env)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 2)
end


function sfx.set_env_speed(instrument, env, val)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 2, val)
end


function sfx.env_loop0(instrument, env)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 3)
end


function sfx.set_env_loop0(instrument, env, val)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 3, val)
end


function sfx.env_loop1(instrument, env)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 4)
end


function sfx.set_env_loop1(instrument, env, val)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 4, val)
end


function sfx.env_start(instrument, env)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 5)
end


function sfx.set_env_start(instrument, env, val)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 5, val)
end


function sfx.env_param(instrument, env, param)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 8 + param)
end


function sfx.set_env_param(instrument, env, param, val)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 8 + param, val)
end


return sfx
:: src/soft_wrap.lua
--[[pod_format="raw",created="2025-03-07 11:09:14",modified="2026-02-19 21:34:53",revision=9275]]
local soft_wrap = {}

-- Soft-wraps a very tiny subset of markdown.
function soft_wrap.parse(text, width, with_small_font, transform)
	local function prefix(s) if with_small_font then return "\014"..s else return s end end
	local space_width <const> = print(prefix(" "), -1000, -1000) + 1000
	local lines = {}
	local context = "default" -- "default", "paragraph", "list" or "code"
	local x = 0
	
	local function add_line_break()
		if #lines == 0 then
			return
		end
		if lines[#lines] ~= "" then
			add(lines, "")
		end
		x = 0
	end
	
	local function add_paragraph_break()
		if #lines == 0 then
			return
		end
		if lines[#lines] ~= "" then
			add(lines, "")
			add(lines, "")
		elseif #lines > 1 and lines[#lines - 1] ~= "" then
			add(lines, "")
		end
		x = 0
	end
	
	local function add_line(line)
		if lines[#lines] == "" then
			lines[#lines] = line
		elseif context == "code" and line == "" then
			add(lines, " ")
		else
			add(lines, line)
		end
		x = 0
	end

	local function add_word(word)
		local word = transform and transform(word) or word
		local dx = print(prefix(word), -1000, -1000) + 1000
		if lines[#lines] == "" then
			lines[#lines] = word
			x += dx
		elseif x + space_width + dx >= width then
			-- Start a new line
			add(lines, "")
			x = 0
			if context == "list" then
				lines[#lines] ..= "  "
				x += 2 * space_width
			end
			lines[#lines] ..= word
			x += dx
		else
			lines[#lines] ..= " " .. word
			x += space_width + dx
		end
	end
	
	for source_line in text:gmatch("([^\n]*)\n") do
		if context == "code" then
			if source_line:find("^```") then
				context = "default"
				indentation = 0
				add_paragraph_break()
			else
				source_line = transform and transform(source_line) or source_line
				add_line(source_line)
			end
			goto next_line
		end
		if source_line:find("^```") then
			context = "code"
			goto next_line
		end
		if source_line:find("^#+") then
			add_paragraph_break()
			add_line(source_line)
			add_paragraph_break()
			context = "default"
			goto next_line
		end
		if source_line:find("^%s*$") then
			add_paragraph_break()
			context = "default"
			goto next_line
		end
		if source_line:find("^%s*-") then
			add_line_break()
			context = "list"
		end
		for word in source_line:gmatch("[^%s]+") do
			add_word(word)
		end
		::next_line::
	end
	
	return lines
end


return soft_wrap
:: src/ui/envelopes.lua
--[[pod_format="raw",created="2024-04-14 20:24:26",modified="2026-02-19 21:34:53",revision=29011]]
local app = require "src/app.lua"
local sfx = require "src/sfx/sfx.lua"
local undo = require "src/undo.lua"
local ui = require "src/ui/ui.lua"
local ui_visual = require "src/ui/visual.lua"


local ui_envelopes = {}

	
-------------------------------------------------------------------------------
-- Envelope Panel
-------------------------------------------------------------------------------


local env_type_names = { [0] = "adsr", "lfo", "custom" }
local lfo_shape_names = { [0] = "sine", "tri", "saw", "isaw", "square", "pulse" }


function ui_envelopes.make_label(env_id)
	local env_type = sfx.env_type(app.instrument, env_id)
	return env_type_names[env_type] .. "\-f " .. env_id
end


function ui_envelopes.attach_panel(parent, el)
	el.width =
		el.large and (2 * app.mod_width + app.synth_gap + 4) 
		or app.mod_width + 5
	el.height = app.mod_height
	parent:attach(el)

	el:attach(ui.create_menu_button {
		x = 2, y = 1, 
		env_id = el.env_id,
		get_label = function()
			return ui_envelopes.make_label(el.env_id)
		end,
		fg = 7,
		highlight = 29,
		items = {
			{
				label = "adsr",
				action =
					function()
						undo.checkpoint()
						sfx.set_env_type(app.instrument, el.env_id, 0)
						app.refresh_gui = true
					end 
			},
			{
				label = "lfo",
				action = function()
					undo.checkpoint()
					sfx.set_env_type(app.instrument, el.env_id, 1)
					app.refresh_gui = true
				end
			},
			{
				label = "custom",
				action =
					function()
						undo.checkpoint()
						sfx.set_env_type(app.instrument, el.env_id, 2)
						app.refresh_gui = true
					end
				},
		}
	})
	
	if not el.large then
		ui_envelopes.attach_advanced_button(el, { x = el.width - 17, y = 1 })
	end

	local xsliders, xloop = 3, el.width - app.mod_width - 3
	if el.x > 240 then
		xsliders, xloop = xloop, xsliders
	end
	
	if el.large or not app.env_advanced[el.env_id] then

		local env_type = sfx.env_type(app.instrument, el.env_id)	
		if env_type == 0 then
			-- ADSR ----------------------------------------------
			local labels = { [0] = "a", "d", "s", "r" }
			for i = 0, 3 do
				ui_envelopes.attach_slider(el, { x = xsliders + 3 + 13 * i, y = 13, slider_height = 40, env_id = el.env_id, param = i, label = labels[i] })
			end
			
		elseif env_type == 1 then
			-- LFO -----------------------------------------------
			--[[ not yet implemented?
			local items = {}
			for i = 0, #lfo_shape_names do
				add(items, {
					label = lfo_shape_names[i],
					action =
						function()
							undo.checkpoint()
							sfx.set_env_param(app.instrument, el.env_id, 5, i)
						end
				})
			end
			ui_envelopes.attach_menu_button(el, {
				x = xsliders + 14, y = 12, 
				env_id = el.env_id,
				get_label = function()
					local shape = sfx.env_param(app.instrument, el.env_id, 5)
					return lfo_shape_names[shape] or "???"
				end,
				fg = 5,
				highlight = 29,
				items = items,
			})
			]]--
			ui_envelopes.attach_slider(el, {
				x = xsliders + 8, y = 13, slider_height = 40,
				env_id = el.env_id, param = 4, label = "freq"
			})
			ui_envelopes.attach_slider(el, {
				x = xsliders + 34, y = 13, slider_height = 40,
				env_id = el.env_id, param = 6, label = "phase"
			})
			

		else
			-- Custom -------------------------------------
			el:attach(ui.create_toggle {
				x = xsliders + 4, y = 13,
				label = "lerp",
				fg = 56,
				get =
					function(self) return
						(sfx.env_flags(app.instrument, el.env_id) & 0x01) > 0
					end,
				set =
					function(self, v)
						undo.checkpoint()
						local flags = sfx.env_flags(app.instrument, el.env_id)
						sfx.set_env_flags(app.instrument, el.env_id, (flags & ~0x01) | (v and 0x01 or 0x00))
					end,
			})
			ui_envelopes.attach_custom_editor(el, { x = xsliders + 0, y = 21 })
			--[[
			el:attach(ui.create_label { x = xsliders + 4, y = 65, label = "speed\-f:" })
			el:attach(ui.create_field {
				x = xsliders + 4 + 30, y = 64,
				fg = 36,
				visible = function(self) return true end,
				get = function(self) return sfx.env_speed(app.instrument, el.env_id) end,
				set = function(self, v) sfx.set_env_speed(app.instrument, el.env_id, v) end,
			})
			--]]
		end
	end
	
	if el.large or app.env_advanced[el.env_id] then
		local visifun =
			function(self)
				return (sfx.env_flags(app.instrument, el.env_id) & 0x10 > 0)
					or (sfx.env_type(app.instrument, el.env_id) == 2)
			end
		el:attach(ui.create_toggle {
			x = xloop + 4, y = 14,
			label = "loop",
			fg = 56,
			visible =
				function(self)
					return sfx.env_type(app.instrument, el.env_id) != 2
				end,
			get =
				function(self) return
					(sfx.env_flags(app.instrument, el.env_id) & 0x10) > 0
				end,
			set =
				function(self, v)
					undo.checkpoint()
					local flags = sfx.env_flags(app.instrument, el.env_id)
					sfx.set_env_flags(app.instrument, el.env_id, (flags & ~0x10) | (v and 0x10 or 0x00))
				end,
		})
		el:attach(ui.create_label { x = xloop + 3, y = 25, label = "speed\-f:", visible = visifun })
		el:attach(ui.create_field {
			x = xloop + 34, y = 24,
			fg = 36,
			visible = visifun,
			get =
				function(self)
					return sfx.env_speed(app.instrument, el.env_id)
					end,
			set = 
				function(self, v)
					sfx.set_env_speed(app.instrument, el.env_id, mid(v, 0, 255))
				end,
		})
		el:attach(ui.create_label { x = xloop + 3, y = 35, label = "start\-f:", visible = visifun })
		el:attach(ui.create_field {
			x = xloop + 34, y = 34,
			fg = 12,
			onclick =
				function(self)
					if (not el.large) ui_visual.open_custom_envelope(el.env_id)
				end,
			onrelease =
				function(self)
					if (not el.large) ui_visual.close()
				end,
			visible = visifun,
			get =
				function(self)
					return sfx.env_start(app.instrument, el.env_id)
				end,
			set =
				function(self, v)
					sfx.set_env_start(app.instrument, el.env_id, mid(v, 0, 255))
				end,
		})
		el:attach(ui.create_toggle {
			x = xloop + 4, y = 44,
			label = "rnd start",
			fg = 56,
			visible = visifun,
			get =
				function(self) return
					(sfx.env_flags(app.instrument, el.env_id) & 0x08) > 0
				end,
			set =
				function(self, v)
					undo.checkpoint()
					local flags = sfx.env_flags(app.instrument, el.env_id)
					sfx.set_env_flags(app.instrument, el.env_id, (flags & ~0x08) | (v and 0x08 or 0x00))
				end,
		})
		el:attach(ui.create_label { x = xloop + 3, y = 55, label = "loop0\-f:", visible = visifun })
		el:attach(ui.create_field {
				x = xloop + 34, y = 54,
				fg = 11,
				onclick =
					function(self)
						if (not el.large) ui_visual.open_custom_envelope(el.env_id)
					end,
				onrelease =
					function(self)
						if (not el.large) ui_visual.close()
					end,
				visible = visifun,
				get =
					function(self)
						return sfx.env_loop0(app.instrument, el.env_id)
					end,
				set =
					function(self, v)
						sfx.set_env_loop0(app.instrument, el.env_id, v)
					end,
		})
		el:attach(ui.create_label { x = xloop + 3, y = 65, label = "loop1\-f:", visible = visifun })
		el:attach(ui.create_field {
				x = xloop + 34, y = 64,
				fg = 9,
				onclick =
					function(self)
						if (not el.large) ui_visual.open_custom_envelope(el.env_id)
					end,
				onrelease =
					function(self)
						if (not el.large) ui_visual.close()
					end,
				visible = visifun,
				get =
					function(self)
						return sfx.env_loop1(app.instrument, el.env_id)
					end,
				set =
					function(self, v)
						sfx.set_env_loop1(app.instrument, el.env_id, v)
					end,
		})
	end
	
	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 8)
		if self.large then
			rectfill(1, 0, self.width - 2, 10, 18)
		else
			rectfill(1, 0, self.width - 19, 10, 18)
		end
	end
	
	function el:click()
		return true
	end
		
	return el
end


function ui_envelopes.attach_advanced_button(parent, el)
	el.width = 16
	el.height = 9
	el.cursor = "pointer"
	parent:attach(el)
	function el:draw()
--		spr(39, 1, 1)
		if app.env_advanced[parent.env_id] then
			spr(133, 0, 0)
		else
			spr(132, 0, 0)
		end
	end
	function el:tap()
		app.env_advanced[parent.env_id] = not app.env_advanced[parent.env_id]
		app.refresh_gui = true
	end
	return el
end

	
-------------------------------------------------------------------------------
-- Slider Widget
-------------------------------------------------------------------------------


function ui_envelopes.attach_slider(parent, el)
	el.width = 13
	el.height = el.slider_height + 20
	el.cursor = "dial"
	parent:attach(el)
	function el:draw()
		---rectfill(0, 0, self.width - 1, self.height - 1, 7)
		local oy = 9
		for i = 0, 8, 1 do
			local h = math.floor(0.5 + (i / 8) * (el.slider_height - 1))
			if i % 8 == 0 then
				line(0, oy + el.slider_height - 1 - h, 12, oy + el.slider_height - 1 - h, 7)
			elseif i % 4 == 0 then
				line(2, oy + el.slider_height - 1 - h, 10, oy + el.slider_height - 1 - h, 7)
			else
				line(4, oy + el.slider_height - 1 - h, 8, oy + el.slider_height - 1 - h, 7)
			end
		end
		local val = sfx.env_param(app.instrument, self.env_id, self.param)
		local h = math.floor(0.5 + (val / 255) * (el.slider_height - 1))
		spr(60, 2, oy + el.slider_height - 1 - h - 3)
		line(6, oy, 6, oy + el.slider_height - 1, 59)
		if (self.dragged) pal(15, 7)
		spr(61, 2, oy + el.slider_height - 1 - h - 3)
		pal(15, 15)
		clip()
		ui.print_centered(self.label, 4 + 3, 0, 56)
		ui.print_centered(tostr(val), 4 + 3, self.height - 7, self.dragged and 55 or 56)
	end
	--[[function el:update(msg)
		if (app.has_modal()) return
		local mx, my, mb = mouse()
		if mb != 0 then
			self.hovered = self.dragged != nil
		else
			self.hovered = self.sx <= mx and mx < self.sx + self.width
				and self.sy <= my and my < self.sy + self.height
		end
	end]]
	function el:click(msg)
		undo.checkpoint()
		self.cursor = 0
		self.dragged = true
	end
	function el:drag(msg)
		if self.dragged then
			local delta = ui.mouse_lock()
			local old = sfx.env_param(app.instrument, self.env_id, self.param)
			local new = old - delta
			new = mid(0, new, 255)
			sfx.set_env_param(app.instrument, self.env_id, self.param, new)
		end
	end
	function el:release(msg)
		ui.mouse_unlock()
		self.cursor = "dial"
		self.dragged = nil
	end
	return el
end


-------------------------------------------------------------------------------
-- Custom Envelopes Editor
-------------------------------------------------------------------------------


function ui_envelopes.attach_custom_editor(parent, el)
	el.width = 58
	el.height = 52
	el.cursor = "crosshair"
	parent:attach(el)
	el.env_id = parent.env_id
	el.draw = ui_visual.draw_custom_envelope
	function el:drag(msg)
		local param = mid(0, (msg.mx - 1) \ 3, 15)
		local val = ((self.height - 1 - msg.my) * 255) / (self.height - 2)
		local val = mid(0, math.floor(0.5 + val), 255)
		sfx.set_env_param(app.instrument, parent.env_id, param, val)
	end
	function el:update()
		local mx, my, mb = mouse()
		if
			self.sx <= mx and mx < self.sx + self.width
			and self.sy <= my and my < self.sy + self.height
		then
			local param = mid(0, (mx - self.sx - 1) \ 3, 15)
			self.selected = param
		else
			self.selected = nil
		end
	end
	return el
end


return ui_envelopes
:: src/ui/help.lua
--[[pod_format="raw",created="2026-02-11 10:17:11",modified="2026-02-19 21:34:53",revision=6526]]
local app = require "src/app.lua"
local ui = require "src/ui/ui.lua"
local soft_wrap = require "src/soft_wrap.lua"


local ui_help = {}


-------------------------------------------------------------------------------
-- Locals
-------------------------------------------------------------------------------


local function create_text_viewer(el)
	el.start = 1
	ui.head():new(el)
	
	local raw_text = el.file and fetch(el.file)
	raw_text = raw_text or [[(could not find "manual.txt")]]
	el.text = soft_wrap.parse(raw_text, el.width - 2, true, nil)
	
	function el:draw(msg)
		rrectfill(1, 1, self.width - 2, self.height - 2, 0, 7)
		local l = self.start
		local y = 0
		color(5)
		cursor(2, 2)
		while y < self.height - 2 and l <= #self.text do
--			if small_font then
--				print(string.lower(self.text[l]))
--				y += 6
--			else
				print("\014"..self.text[l])
				y += 11
--			end
			l += 1
		end
		app.draw_borders(1, 1, self.width - 2, self.height - 2)
	end
	
	function el:mousewheel(msg)
		local nb_lines = (self.height - 2) // 11
		self.start -= msg.wheel_y
		self.start = mid(self.start, 1, #self.text - nb_lines)
	end
	
	return el
end


-------------------------------------------------------------------------------
-- Help Dialog
-------------------------------------------------------------------------------


function ui_help.open()
	local el = { width = 300, height = 270 - 11 - 40 }
	ui.open_modal(el)
	
	el:attach(create_text_viewer {
		file = "manual.txt",
		x = 6, y = 18,
		width = el.width - 2 * 6,
		height = el.height - 18 - 6,
	})
	
	el:attach(ui.create_button {
		x = el.width - 16, y = 4,
		width = 11, height = 11,
		spr = 36,
		label = "close",
		action = function(self)
			ui.close_modal()
		end,
	})
	
	function el:draw()
		local width, height = self.width, self.height
		local xw, yh = self.width - 1, self.y - 1
		rrectfill(0, 0, width, height, 0, 6)
		local xw, yh = 0 + width - 2, 0 + height - 2
		line(0 + 1, yh, 0 + 1, 0 + 1, 57)
		line(0 + 2, yh, 0 + 2, 0 + 1, 57)
		line(0 + 1, 0 + 1, xw, 0 + 1, 57)
		line(0 + 1, 0 + 2, xw, 0 + 2, 57)
		line(xw, yh, xw, 0 + 1, 58)
		line(xw - 1, yh, xw - 1, 0 + 2, 58)
		line(0 + 1, yh, xw, yh, 58)
		line(0 + 2, yh - 1, xw, yh - 1, 58)
		rrect(0 + 0, 0 + 0, width, height, 0, 0)
		rrectfill(0 + 4, 0 + 4, width - 8, 11, 0, 55)
		ui.print_centered("help", 0 + width // 2, 0 + 7, 6)
	end
	
	function el:click()
		return true
	end
end


return ui_help

:: src/ui/menus.lua
--[[pod_format="raw",created="2024-04-20 10:41:15",modified="2026-02-19 21:34:53",revision=27994]]
local app = require "src/app.lua"
local sfx = require "src/sfx/sfx.lua"
local ui = require "src/ui/ui.lua"
local ui_envelopes = require "src/ui/envelopes.lua"
local undo = require "src/undo.lua"


local ui_menus = {}


-------------------------------------------------------------------------------
-- Relationship Menu
-------------------------------------------------------------------------------


function ui_menus.open_relationship(self)
	local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
	local node_type = sfx.node_type(app.instrument, self.parent.node_id)
	
	if node_type == 0x2 and self.parent.param == 2 then
		ui.open_menu {
			x = self.sx - 10, y = self.sy + 7,
			width = 55,
			items = {
				{
					label = (flags & 0x03 == 0x00)
						and "\|f\^:1c225d5d5d221c00\|h set"
						or "\|f\^:1c22414141221c00\|h set",
					action =
						function()
							undo.checkpoint()
							self.parent.min_val, self.parent.max_val = -128, 127
							local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
							-- set bit: replace parent
							sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, flags & ~0x3)
					 	end,
				},
				{
					label = (flags & 0x03 == 0x01)
						and "\|f\^:1c225d5d5d221c00\|h add"
						or "\|f\^:1c22414141221c00\|h add",
					action =
						function()
							undo.checkpoint()
							self.parent.min_val, self.parent.max_val = -128, 127
							local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
							-- set bit: add parent
							sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, (flags & ~0x3) | 0x1)
					 	end,
				},
				{
					label = (flags & 0x03 == 0x02)
						and "\|f\^:1c225d5d5d221c00\|h multiply"
						or "\|f\^:1c22414141221c00\|h multiply",
					action =
						function()
							undo.checkpoint()
							self.parent.min_val, self.parent.max_val = 0, 255
							local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
							-- set bit: mul parent
							sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, (flags & ~0x3) | 0x2)
					 	end,
				},
				{ divider = true },
				{
					label = 
						(flags & 0x20 > 0)
							and "\|f\^:7f415d5d5d417f00\|h quantized"
							or "\|f\^:7f41414141417f00\|h quantized",
					action =
						function()
							undo.checkpoint()
							local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
							sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, flags ^^ 0x20)
					 	end,
				},
			}
		}
	elseif
		(node_type == 0x02 and self.parent.param == 0)
		or (node_type == 10 and self.parent.param == 3)
		or (node_type == 8 and self.parent.param == 2)
	then
		ui.open_menu {
			x = self.sx - 10, y = self.sy + 7,
			width = 52,
			items = {
				{
					label = (flags & 0x03 == 0x00)
						and "\|f\^:1c225d5d5d221c00\|h set"
						or "\|f\^:1c22414141221c00\|h set",
					action =
						function()
							undo.checkpoint()
							local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
							-- set bit: replace parent
							sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, flags & ~0x3)
					 	end,
				},
				{
					label = (flags & 0x03 == 0x02)
						and "\|f\^:1c225d5d5d221c00\|h multiply"
						or "\|f\^:1c22414141221c00\|h multiply",
					action =
						function()
							undo.checkpoint()
							local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
							-- set bit: mul parent
							sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, (flags & ~0x3) | 0x2)
					 	end,
				},
			}
		}
	elseif
		(node_type == 8 and self.parent.param ~= 2)
		or (node_type == 9)
		or (node_type == 10 and self.parent.param ~= 3)
	then
		-- no menu
	else
		ui.open_menu {
			x = self.sx - 10, y = self.sy + 7,
			width = 40,
			items = {
				{
					label = (flags & 0x03 == 0x00)
						and "\|f\^:1c225d5d5d221c00\|h set"
						or "\|f\^:1c22414141221c00\|h set",
					action =
						function()
							undo.checkpoint()
							local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
							-- set bit: replace parent
							sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, flags & ~0x3)
					 	end,
				},
				{
					label = (flags & 0x03 == 0x01)
						and "\|f\^:1c225d5d5d221c00\|h add"
						or "\|f\^:1c22414141221c00\|h add",
					action =
						function()
							undo.checkpoint()
							local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
							-- set bit: add parent
							sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, (flags & ~0x3) | 0x1)
					 	end,
				},
			}
		}
	end
end


-------------------------------------------------------------------------------
-- Multiplier Menu
-------------------------------------------------------------------------------


function ui_menus.open_multiplier(self)
	local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)

	local mult_options = {
		[0] = 
		{ label = "\^:221408142200000064", val = 0x00 | 0xc0 },
		{ label = "\^:221408142200000016", val = 0x00 | 0x80 },
		{ label = "\^:22140814220000004", val = 0x00 | 0x40 },
		{ label = "none", val = 0x00 | 0x00 },
		{ label = "\|f\^:1010080804040000\|h4", val = 0x20 | 0x40 },
		{ label = "\|f\^:1010080804040000\|h16", val = 0x20 | 0x80 },
		{ label = "\|f\^:1010080804040000\|h64", val = 0x20 | 0xc0 },
	}
	local mult_menu_items = {}
	for i = 0, #mult_options do
		add(mult_menu_items, 
			{
				label = (env & 0xe0 == mult_options[i].val)
					and ("\|f\^:1c225d5d5d221c00\|h " .. mult_options[i].label)
					or ("\|f\^:1c22414141221c00\|h " .. mult_options[i].label),
				fg = i == 3 and 55 or 24,
				action =
					function()
						undo.checkpoint()
						local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
						sfx.set_node_param_env(app.instrument, self.parent.node_id, self.parent.param, (env & ~0xe0) | mult_options[i].val)
				 	end,
			}
		)
	end

	ui.open_menu {
		x = self.sx - 10, y = self.sy + 7,
		width = 36,
		items = mult_menu_items,
	}
end


-------------------------------------------------------------------------------
-- Envelope Menu
-------------------------------------------------------------------------------


function ui_menus.open_envelope(self)
	local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
	local has_env = flags & 0x04 > 0
	local has_free_run = flags & 0x08 > 0
	local has_random = flags & 0x10 > 0
	local env_id = env & 0x0f
	ui.open_menu {
		x = self.sx - 10, y = self.sy + 7,
		width = 51,
		items = {
			{
				label = (not has_env and not has_random)
					and "\|f\^:1c225d5d5d221c00\|h none"
					or "\|f\^:1c22414141221c00\|h none",
				fg = 5,
				action = function()
					local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
					sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, flags & ~(0x4 | 0x8 | 0x10))
				 end,
			},
			{
				label = (has_env and env_id == 0)
					and ("\|f\^:1c225d5d5d221c00\|h " .. ui_envelopes.make_label(0))
					or ("\|f\^:1c22414141221c00\|h " .. ui_envelopes.make_label(0)),
				fg = 18,
				action = function()
					local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
					sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, (flags & ~0x10) | 0x4)
					sfx.set_node_param_env(app.instrument, self.parent.node_id, self.parent.param, (env & 0xf0) | 0)
				 end,
			},
			{
				label = (has_env and env_id == 1)
					and ("\|f\^:1c225d5d5d221c00\|h " .. ui_envelopes.make_label(1))
					or ("\|f\^:1c22414141221c00\|h " .. ui_envelopes.make_label(1)),
				fg = 18,
				action = function()
					local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
					sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, (flags & ~0x10) | 0x4)
					sfx.set_node_param_env(app.instrument, self.parent.node_id, self.parent.param, (env & 0xf0) | 1)
				 end,
			},
			{
				label = (has_env and env_id == 2)
					and ("\|f\^:1c225d5d5d221c00\|h " .. ui_envelopes.make_label(2))
					or ("\|f\^:1c22414141221c00\|h " .. ui_envelopes.make_label(2)),
				fg = 18,
				action = function()
					local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
					sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, (flags & ~0x10) | 0x4)
					sfx.set_node_param_env(app.instrument, self.parent.node_id, self.parent.param, (env & 0xf0) | 2)
				end,
			},
			{
				label = (has_env and env_id == 3)
					and ("\|f\^:1c225d5d5d221c00\|h " .. ui_envelopes.make_label(3))
					or ("\|f\^:1c22414141221c00\|h " .. ui_envelopes.make_label(3)),
				fg = 18,
				action = function()
					local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
					sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, (flags & ~0x10) | 0x4)
					sfx.set_node_param_env(app.instrument, self.parent.node_id, self.parent.param, (env & 0xf0) | 3)
				end,
			},
			{
				label = has_random
						and "\|f\^:1c225d5d5d221c00\|h random"
						or "\|f\^:1c22414141221c00\|h random",
				fg = 30,
				action = function()
					local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
					sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, (flags & ~0x4) | 0x10)
				 end,
			},
			{
				divider = true,
			},
			{
				label = has_free_run
							and "\|f\^:7f415d5d5d417f00\|h free run"
							or "\|f\^:7f41414141417f00\|h free run",
				fg = 5,
				action = function()
					local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
					sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, flags ^^ 0x08)
				 end,
			},
		}
	}
end


return ui_menus
:: src/ui/nodes.lua
--[[pod_format="raw",created="2024-04-12 16:30:23",modified="2026-02-19 21:34:53",revision=34569]]
local app = require "src/app.lua"
local sfx = require "src/sfx/sfx.lua"
local ui = require "src/ui/ui.lua"
local ui_envelopes = require "src/ui/envelopes.lua"
local ui_params = require "src/ui/params.lua"
local ui_visual = require "src/ui/visual.lua"
local undo = require "src/undo.lua"


local ui_nodes = {}


-------------------------------------------------------------------------------
-- Locals
-------------------------------------------------------------------------------


function instrument_flag_toggle(el)
	el.width = el.width or 41
	el.height = el.height or 9
	el.label = el.label or "---"
	el.cursor = "pointer"
	
	function el:draw()
		palt(59, true)
		pal(2, 0)
		pal(17, 18)
		if sfx.instrument_flag(app.instrument, el.flag) then
			spr(116, 0, 1)
		else
			spr(115, 0, 1)
		end
		pal(17, 17)
		pal(2, 2)
		palt(59, false)
		print(el.label, 16, 2, 56)
	end
	
	function el:tap()
		sfx.toggle_instrument_flag(app.instrument, el.flag)
	end
	
	return el
end


-------------------------------------------------------------------------------


function attach_mute_toggle(parent, el)
	el.x = 1
	el.y = 2
	el.width = 3 + 4 * #(el.label .. " " .. el.node_id) + 3
	el.height = 9
	el.cursor = "pointer"
	parent:attach(el)
	el.muted = (sfx.node_flags(app.instrument, el.node_id) & 0x2) > 0
	function el:draw()
		local label = self.label .. " " .. self.node_id
		print(label, 3, 1, 63)
		if self.muted then
			line(1, 3, 3 + 4 * #label, 3, 24)
		end
	end
	function el:click()
		return true -- don't pass to panel to avoid selection
	end
	function el:tap()
		self.muted = not self.muted
		local flags = sfx.node_flags(app.instrument, self.node_id)
		if self.muted then
			flags |= 0x2
		else
			flags &= ~0x2
		end
		sfx.set_node_flags(app.instrument, self.node_id, flags)
	end
	return el
end


-------------------------------------------------------------------------------


function attach_close_button(parent, el)
	el.x = parent.width - 10
	el.y = 3
	el.width = 12
	el.height = 9
	el.cursor = "pointer"
	parent:attach(el)
	function el:draw()
		pal(7, 63)
		spr(36, 0, 0)
		pal(7, 7)
	end
	function el:click()
		return true -- don't pass to panel to avoid selection
	end
	function el:tap()
		if app.node then
			if app.node == self.node_id then
				if #(sfx.nodes[app.node].children) > 0 then
					app.node = sfx.nodes[app.node].children[1].id
				else
					app.node = sfx.nodes[app.node].parent.id
				end
			end
		end
		sfx.delete_node(app.instrument, self.node_id)
		if app.node and app.node > self.node_id then
			app.node = max(0, self.node_id - 1)
		end
		app.refresh_gui = true
	end
	return el
end


-------------------------------------------------------------------------------
-- Node Panels
-------------------------------------------------------------------------------


function ui_nodes.attach_node_panel(parent, el)
	if app.node and app.node == el.node_id then
		el.width = 480 - 4 * app.mod_width - 6 * app.synth_gap + 2
		el.height = 2 * app.synth_height + app.synth_gap
	else
		el.width = app.synth_width
		el.height = app.synth_height
	end
	parent:attach(el)
	
	local type = sfx.node_type(app.instrument, el.node_id)
	if el.node_id == 0 then return ui_nodes.populate_root(parent, el)
	elseif type == 0 then return ui_nodes.populate_unused(parent, el)
	elseif type == 2 then
		local op = sfx.node_op(app.instrument, el.node_id)
		if op == 0 then return ui_nodes.populate_osc(parent, el)
		elseif op == 1 then return ui_nodes.populate_fm(parent, el)
		elseif op == 2 then return ui_nodes.populate_ring(parent, el)
		end
	elseif type == 8 then return ui_nodes.populate_filt(parent, el)
	elseif type == 9 then return ui_nodes.populate_echo(parent, el)
	elseif type == 10 then return ui_nodes.populate_shap(parent, el)
	end
	return ui_nodes.populate_unknown(parent, el)
end


-------------------------------------------------------------------------------
-- Unused slot
-------------------------------------------------------------------------------


function ui_nodes.populate_unused(parent, el)
	function el:draw()
		clip()
		local x, y = 21, 14
		pal(7, 58)
--		sspr(63, 0, 0, 7, 7, x, y, 10 * 4, 10 * 4)
		spr(62, 28, 24)
		pal(7, 7)
		if self.node_id == 7 then
			print("pfx6416", 52, 66, 58)
		end
	end
	return el
end


-------------------------------------------------------------------------------
-- Root Synth Node
-------------------------------------------------------------------------------


local instrument_name_field


function ui_nodes.populate_root(parent, el)
	local params = {
		[0] = { label = "vol", long_label = "volume", param = 0,
			min_val = 0, max_val = 64, init_val = 32, sensitivity = 0.25 },
		{ label = "pan", param = 1, min_val = -128, max_val = 127, },
		{ label = "tune", param = 2, min_val = -128, max_val = 127, },
		{ label = "bend", param = 3, min_val = -128, max_val = 127, },
	}
	for i = 0, #params do params[i].node_id = el.node_id end

	if el.large then
		el:attach(instrument_flag_toggle { x = 180, y = 1, label = "retrig", flag = 0x01 })
		ui_params.attach(el, 18, 30, params[0], { emphasis = true})
		ui_params.attach(el, 60, 30, params[1], { small = true })
		el:attach(instrument_flag_toggle { x = 62, y = 92, label = "wide", flag = 0x02 })
		params[2].x = 12; params[2].y = 110
		ui_params.attach_mini(el, params[2])
		params[3].x = 12; params[3].y = 120
		ui_params.attach_mini(el, params[3])
		
		ui_visual.attach_stereo_oscillo(el, {
			x = 114, y = 27, width = 104, height = 84,
			channel = nil,
		})

		-- TODO: replace with a custom field
		-- also: add the same field to the mini version
		instrument_name_field = el:attach_text_editor{
			x = 18, y = 2,
			width = 8 + 16 * 4, height = 7,
			margin_top = 1,
			bgcol = 7, fgcol = 59, curcol = 14,
			block_scrolling = true, max_lines = 1,
			key_callback = {
				enter = function () 
					if name == "---" then name = "" end
					sfx.set_instrument_name(app.instrument, name)
					instrument_name_field:set_keyboard_focus(false)
				end
			},
			update = function(self)
				self.cursor = "pointer"
				-- update in realtime -- don't need to press enter to change
				if (instrument_name_field:has_keyboard_focus()) then
					local name = instrument_name_field:get_text()[1]
					if name == "---" then name = "" end
					sfx.set_instrument_name(app.instrument, name)
				end
			end,
		}
		local name = sfx.instrument_name(app.instrument)
		if name == "" then name = "---" end
		instrument_name_field:set_text{ name }
	else
		ui_params.attach_mini(el, params[0])
		ui_params.attach_mini(el, params[1])
		ui_params.attach_mini(el, params[2])
		ui_params.attach_mini(el, params[3])
		el:attach(instrument_flag_toggle { x = 16, y = 53, label = "wide", flag = 0x02 })
		el:attach(instrument_flag_toggle { x = 42, y = 1, label = "retrig", flag = 0x01 })
	end
	function el:draw()
		if self.large then
			rrectfill(1, 0, self.width - 50, 11, 0, 7)
			rrect(16, -1, 8 + 16 * 4 + 4, 13, 5, 6)
			print(string.format("%02x", app.instrument), 4, 3, 44)
--			spr(108, 128, 2)
			spr(131, 128, 3)
			spr(129, 136, 119)
		else
			rrectfill(1, 0, 33, 11, 0, 7)
			print("inst ", 4, 3, 5)
			print(string.format("%02x", app.instrument), 24, 3, 44)
		end
	end
	function el:click() return true end
	function el:doubleclick() app.node = self.node_id; app.refresh_gui = true end
	return el
end


-------------------------------------------------------------------------------
-- Oscillator
-------------------------------------------------------------------------------



local wt_labels = { [0] = "wt0", "wt1", "wt2", "wt3" }
local wt_long_labels = { [0] = "wavetable 0", "wavetable 1", "wavetable 2", "wavetable 3" }
local osc_params = {
	[0] = { label = "vol", long_label = "volume", param = 0,
		min_val = 0, max_val = 64, init_val = 32, sensitivity = 0.25 },
	{ label = "pan", param = 1, min_val = -128, max_val = 127, },
	{ label = "tune", param = 2, min_val = -128, max_val = 127, },
	{ label = "bend", param = 3, min_val = -128, max_val = 127, },
	{ label = "", long_label = "wave", param = 4, min_val = 0, max_val = 255, },
	{ label = "phase", param = 5, min_val = -128, max_val = 127, },
}

function ui_nodes.populate_osc(parent, el)
	local params = unpod(pod(osc_params))
	
	for i = 0, #params do params[i].node_id = el.node_id end
	local flags, _, _, _ = sfx.node_param(app.instrument, el.node_id, 2)
	if flags & 0x03 == 0x02 then
		-- tune param in "multiply" relationship:
		-- change the min and max values
		params[2].min_val = 0
		params[2].max_val = 255
	end
	
	params[1].visible =
		function(self)
			return sfx.instrument_flag(app.instrument, 0x02)
		end

	attach_mute_toggle(el, { label = "osc", node_id = el.node_id })
	attach_close_button(el, { node_id = el.node_id })
	if el.large then
		ui_params.attach(el, 18, 18, params[0], { emphasis = true})
		ui_params.attach(el, 60, 18, params[1], { small = true })
		ui_params.attach(el, 18, 86, params[2], { small = true })
		ui_params.attach(el, 60, 86, params[3], { small = true })
		local wave = ui_params.attach(el, 130, 86, params[4], { emphasis = true })
		ui_visual.attach_wavetable(el, wave, { x = 114, y = 16, width = 104, height = 58, fg = 47 })
		ui_params.attach(el, 172, 86, params[5], { small = true })
		el:attach(ui.create_menu_button {
			x = 142, y = 74,
			get_label = function()
				local wt = sfx.node_osc_wavetable(app.instrument, el.node_id)
				return wt_long_labels[wt] or "wt?"
			end,
			fg = 46,
			highlight = 15,
			items = {
				{ label = "wavetable 0", action = function() undo.checkpoint() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 0) end },
				{ label = "wavetable 1", action = function() undo.checkpoint() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 1) end },
				{ label = "wavetable 2", action = function() undo.checkpoint() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 2) end },
				{ label = "wavetable 3", action = function() undo.checkpoint() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 3) end },
			}
		})
	else
		-- closures are not copied by unpod/pod?
		params[4].onclick = function(self) ui_visual.open_wavetable(self, 47) end
		params[4].onrelease = function(self) ui_visual.close() end
		params[5].onclick = params[4].onclick
		params[5].onrelease = params[4].onrelease
		ui_params.attach_mini(el, params[0])
		ui_params.attach_mini(el, params[1])
		ui_params.attach_mini(el, params[2])
		ui_params.attach_mini(el, params[3])
		ui_params.attach_mini(el, params[4])
		ui_params.attach_mini(el, params[5])
		el:attach(ui.create_menu_button {
			x = 2, y = 53,
			get_label = function()
				local wt = sfx.node_osc_wavetable(app.instrument, el.node_id)
				return wt_labels[wt] or "wt?"
			end,
			fg = 46,
			highlight = 15,
			items = {
				{ label = "wt 0", action = function() undo.checkpoint() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 0) end },
				{ label = "wt 1", action = function() undo.checkpoint() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 1) end },
				{ label = "wt 2", action = function() undo.checkpoint() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 2) end },
				{ label = "wt 3", action = function() undo.checkpoint() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 3) end },
			}
		})
	end
	
	function el:click() return true end
	function el:doubleclick() app.node = self.node_id; app.refresh_gui = true end
		
	function el:draw()
		rrectfill(1, 0, self.width - 1, 11, 0, 17)
	end
	
	return el
end


-------------------------------------------------------------------------------
-- FM modulator
-------------------------------------------------------------------------------


function ui_nodes.populate_fm(parent, el)
	local params = unpod(pod(osc_params))
	params[1].visible =
		function(self)
			return sfx.instrument_flag(app.instrument, 0x02)
		end
	
	for i = 0, #params do params[i].node_id = el.node_id end
	local flags, _, _, _ = sfx.node_param(app.instrument, el.node_id, 2)
	if flags & 0x03 == 0x02 then
		-- tune param in "multiply" relationship:
		-- change the min and max values
		params[2].min_val = 0
		params[2].max_val = 255
	end

	attach_mute_toggle(el, { label = "fm", node_id = el.node_id })
	attach_close_button(el, { node_id = el.node_id })
	if el.large then
		ui_params.attach(el, 18, 18, params[0], { emphasis = true})
		ui_params.attach(el, 60, 18, params[1], { small = true })
		ui_params.attach(el, 18, 86, params[2], { small = true })
		ui_params.attach(el, 60, 86, params[3], { small = true })
		local wave = ui_params.attach(el, 130, 86, params[4], { emphasis = true })
		ui_visual.attach_wavetable(el, wave, { x = 114, y = 16, width = 104, height = 58, fg = 45 })
		ui_params.attach(el, 172, 86, params[5], { small = true })
		el:attach(ui.create_menu_button {
			x = 142, y = 74,
			get_label = function()
				local wt = sfx.node_osc_wavetable(app.instrument, el.node_id)
				return wt_long_labels[wt] or "wt?"
			end,
			fg = 44,
			highlight = 15,
			items = {
				{ label = "wavetable 0", action = function() undo.checkpoint() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 0) end },
				{ label = "wavetable 1", action = function() undo.checkpoint() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 1) end },
				{ label = "wavetable 2", action = function() undo.checkpoint() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 2) end },
				{ label = "wavetable 3", action = function() undo.checkpoint() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 3) end },
			}
		})
	else
		params[4].onclick = function(self) ui_visual.open_wavetable(self, 45) end
		params[4].onrelease = function(self) ui_visual.close() end
		params[5].onclick = params[4].onclick
		params[5].onrelease = params[4].onrelease
		ui_params.attach_mini(el, params[0])
		ui_params.attach_mini(el, params[1])
		ui_params.attach_mini(el, params[2])
		ui_params.attach_mini(el, params[3])
		ui_params.attach_mini(el, params[4])
		ui_params.attach_mini(el, params[5])
		el:attach(ui.create_menu_button {
			x = 2, y = 53,
			get_label = function()
				local wt = sfx.node_osc_wavetable(app.instrument, el.node_id)
				return wt_labels[wt] or "wt?"
			end,
			fg = 44,
			highlight = 15,
			items = {
				{ label = "wt 0", action = function() undo.checkpoint() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 0) end },
				{ label = "wt 1", action = function() undo.checkpoint() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 1) end },
				{ label = "wt 2", action = function() undo.checkpoint() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 2) end },
				{ label = "wt 3", action = function() undo.checkpoint() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 3) end },
			}
		})
	end
	
	function el:click() return true end
	function el:doubleclick() app.node = self.node_id; app.refresh_gui = true end
		
	function el:draw()
		rrectfill(1, 0, self.width - 1, 11, 0, 27)
	end
	
	return el
end


-------------------------------------------------------------------------------
-- Ring mod
-------------------------------------------------------------------------------


function ui_nodes.populate_ring(parent, el)
	local params = unpod(pod(osc_params))
	params[1].visible =
		function(self)
			return sfx.instrument_flag(app.instrument, 0x02)
		end
	
	for i = 0, #params do params[i].node_id = el.node_id end
	local flags, _, _, _ = sfx.node_param(app.instrument, el.node_id, 2)
	if flags & 0x03 == 0x02 then
		-- tune param in "multiply" relationship:
		-- change the min and max values
		params[2].min_val = 0
		params[2].max_val = 255
	end

	attach_mute_toggle(el, { label = "ring", node_id = el.node_id })
	attach_close_button(el, { node_id = el.node_id })
	if el.large then
		ui_params.attach(el, 18, 18, params[0], { emphasis = true})
		ui_params.attach(el, 60, 18, params[1], { small = true })
		ui_params.attach(el, 18, 86, params[2], { small = true })
		ui_params.attach(el, 60, 86, params[3], { small = true })
		local wave = ui_params.attach(el, 130, 86, params[4], { emphasis = true })
		ui_visual.attach_wavetable(el, wave, { x = 114, y = 16, width = 104, height = 58, fg = 51 })
		ui_params.attach(el, 172, 86, params[5], { small = true })
		el:attach(ui.create_menu_button {
			x = 142, y = 74,
			get_label = function()
				local wt = sfx.node_osc_wavetable(app.instrument, el.node_id)
				return wt_long_labels[wt] or "wt?"
			end,
			fg = 50,
			highlight = 15,
			items = {
				{ label = "wavetable 0", action = function() undo.checkpoint() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 0) end },
				{ label = "wavetable 1", action = function() undo.checkpoint() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 1) end },
				{ label = "wavetable 2", action = function() undo.checkpoint() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 2) end },
				{ label = "wavetable 3", action = function() undo.checkpoint() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 3) end },
			}
		})
	else
		params[4].onclick = function(self) ui_visual.open_wavetable(self, 51) end
		params[4].onrelease = function(self) ui_visual.close() end
		params[5].onclick = params[4].onclick
		params[5].onrelease = params[4].onrelease
		ui_params.attach_mini(el, params[0])
		ui_params.attach_mini(el, params[1])
		ui_params.attach_mini(el, params[2])
		ui_params.attach_mini(el, params[3])
		ui_params.attach_mini(el, params[4])
		ui_params.attach_mini(el, params[5])
		el:attach(ui.create_menu_button {
			x = 2, y = 53,
			get_label = function()
				local wt = sfx.node_osc_wavetable(app.instrument, el.node_id)
				return wt_labels[wt] or "wt?"
			end,
			fg = 50,
			highlight = 15,
			items = {
				{ label = "wt 0", action = function() undo.checkpoint() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 0) end },
				{ label = "wt 1", action = function() undo.checkpoint() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 1) end },
				{ label = "wt 2", action = function() undo.checkpoint() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 2) end },
				{ label = "wt 3", action = function() undo.checkpoint() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 3) end },
			}
		})
	end
	
	function el:click() return true end
	function el:doubleclick() app.node = self.node_id; app.refresh_gui = true end
		
	function el:draw()
		rrectfill(1, 0, self.width - 1, 11, 0, 22)
	end
	
	return el
end


-------------------------------------------------------------------------------
-- Filter
-------------------------------------------------------------------------------


function ui_nodes.populate_filt(parent, el)
	local params = {
		[0] =
		{ label = "lp", param = 0, min_val = 0, max_val = 255, },
		{ label = "hp", param = 1, min_val = 0, max_val = 255, },
		{ label = "res", param = 2, min_val = 0, max_val = 255, },
	}
	for i = 0, #params do params[i].node_id = el.node_id end
	
	attach_mute_toggle(el, { label = "filt", node_id = el.node_id })
	attach_close_button(el, { node_id = el.node_id })
	if el.large then
		ui_params.attach(el, 54, 84, params[1], {})
		ui_params.attach(el, 96, 84, params[0], { reversed = true })
		ui_params.attach(el, 138, 84, params[2], { small = true })
		ui_visual.attach_filter_display(el, { x = 25, y = 20, width = 176, height = 58 })
	else
		ui_params.attach_mini(el, params[0])
		ui_params.attach_mini(el, params[1])
		ui_params.attach_mini(el, params[2])
	end
	function el:draw()
		rrectfill(1, 0, self.width - 1, 11, 0, 14)
		spr(111, 29, 100)
		spr(111, 182, 100)
	end
	function el:click() return true end
	function el:doubleclick() app.node = self.node_id; app.refresh_gui = true end
	return el
end


-------------------------------------------------------------------------------
-- Delay
-------------------------------------------------------------------------------


function ui_nodes.populate_echo(parent, el)
	local params = {
		[0] =
		{ label = "delay", param = 0, min_val = 0, max_val = 255, },
		{ label = "vol", param = 1, min_val = 0, max_val = 255, },
	}
	for i = 0, #params do params[i].node_id = el.node_id end
	
	attach_mute_toggle(el, { label = "echo", node_id = el.node_id })
	attach_close_button(el, { node_id = el.node_id })
	if el.large then
		ui_params.attach(el, 75, 86, params[0], {})
		ui_params.attach(el, 117, 86, params[1], {})
		ui_visual.attach_delay_display(el, { x = 25, y = 20, width = 176, height = 58 })
	else
		ui_params.attach_mini(el, params[0])
		ui_params.attach_mini(el, params[1])
	end
	function el:draw()
		rrectfill(1, 0, self.width - 1, 11, 0, 31)
		spr(127, 20, 98)
		spr(127, 168, 98)
	end
	function el:click() return true end
	function el:doubleclick() app.node = self.node_id; app.refresh_gui = true end
	return el
end


-------------------------------------------------------------------------------
-- Waveshaper
-------------------------------------------------------------------------------


function ui_nodes.populate_shap(parent, el)
	local params = {
		[0] =
		{ label = "gain", param = 0, min_val = 0, max_val = 255, },
		{ label = "elbow", param = 1, min_val = 0, max_val = 255, },
		{ label = "cut", param = 2, min_val = 0, max_val = 255, },
		{ label = "mix", param = 3, min_val = 0, max_val = 64, sensitivity = 0.25 },
	}
	for i = 0, #params do params[i].node_id = el.node_id end
	
	attach_mute_toggle(el, { label = "shap", node_id = el.node_id })
	attach_close_button(el, { node_id = el.node_id })
	if el.large then
		ui_params.attach(el, 18, 86, params[0], {})
		ui_params.attach(el, 60, 86, params[2], { reversed = true })
		ui_params.attach(el, 102, 86, params[1], {})
		ui_params.attach(el, 160, 86, params[3], { small = true })
		ui_visual.attach_shaper_display(el, { x = 25, y = 20, width = 104, height = 58 })
	else
		ui_params.attach_mini(el, params[0])
		ui_params.attach_mini(el, params[1])
		ui_params.attach_mini(el, params[2])
		ui_params.attach_mini(el, params[3])
	end
	function el:draw()
		rrectfill(1, 0, self.width - 1, 11, 0, 9)
		spr(110, 159, 33)
	end
	function el:click() return true end
	function el:doubleclick() app.node = self.node_id; app.refresh_gui = true end
	return el
end


-------------------------------------------------------------------------------
-- Unknown
-------------------------------------------------------------------------------


function ui_nodes.populate_unknown(parent, el)
	local params = {
		[0] =
		{ label = "p0", param = 0, min_val = 0, max_val = 255, },
		{ label = "p1", param = 1, min_val = 0, max_val = 255, },
		{ label = "p2", param = 2, min_val = 0, max_val = 255, },
		{ label = "p3", param = 3, min_val = 0, max_val = 255, },
		{ label = "p4", param = 4, min_val = 0, max_val = 255, },
		{ label = "p5", param = 5, min_val = 0, max_val = 255, },
	}
	for i = 0, #params do params[i].node_id = el.node_id end
	
	attach_mute_toggle(el, { label = "???", node_id = el.node_id })
	attach_close_button(el, { node_id = el.node_id })
	ui_params.attach_mini(el, params[0])
	ui_params.attach_mini(el, params[1])
	ui_params.attach_mini(el, params[2])
	ui_params.attach_mini(el, params[3])
	ui_params.attach_mini(el, params[4])
	ui_params.attach_mini(el, params[5])
	function el:draw()
		rrectfill(1, 0, self.width - 1, 9, 0, 30)
	end
	function el:click() return true end
	function el:doubleclick() app.node = self.node_id; app.refresh_gui = true end
	return el
end


return ui_nodes
:: src/ui/notegrid.lua
--[[pod_format="raw",created="2026-01-26 13:53:28",modified="2026-02-19 21:34:53",revision=24141]]
local app = require "src/app.lua"
local selection = require "src/selection.lua"
local settings = require "src/settings.lua"
local sfx = require "src/sfx/sfx.lua"
local ui = require "src/ui/ui.lua"
local ui_trakdial = require "src/ui/trakdial.lua"
local undo = require "src/undo.lua"


local ui_notegrid = {}


-------------------------------------------------------------------------------
-- Locals
-------------------------------------------------------------------------------


local note_names <const> = {"c ","c\|f+","d ","d\|f+","e ","f ","f\|f+","g ","g\|f+","a ","a\|f+", "b "}
local note_names <const> = {"c ","c+","d ","d+","e ","f ","f+","g ","g+","a ","a+", "b "}


local w_note <const> = 11
local w_octave <const> = 7
local w_note_octave <const> = 11 + 7
local w_instrument <const> = 11
local w_volume <const> = 11
local w_fx <const> = 16


local x_note <const> = 0
local x_octave <const> = w_note
local x_instrument <const> = w_note + w_octave
local x_volume <const> = w_note + w_octave + w_instrument
local x_fx <const> = w_note + w_octave + w_instrument + w_volume


local fgd_note = 42
local fg_note = 43
local fgd_octave = 50
local fg_octave = 51
local fgd_inst = 44
local fg_inst = 45
local fgd_vol = 46
local fg_vol = 47
local fgd_fx = 48
local fg_fx = 49
local fg_greyed = 34


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


local function channel_not_valid(channel)
	local track = sfx.pattern_track(app.pattern, channel)
	local size = sfx.track_size(track)
	return size < 1 or sfx.channel_is_muted(app.pattern, channel)
end


-------------------------------------------------------------------------------
-- Channel Dialog
-------------------------------------------------------------------------------


local channel_dialog = nil
local channel_dialog_start = 0


local function init_first_empty_track(track)
	if sfx.track_size(track) ~= 0 then
		for t = 0, sfx.num_tracks() - 1 do
			if sfx.track_size(t) == 0 then
				track = t
				break
			end
		end
	end
	if sfx.track_size(track) == 0 then
		init_track(track)
		return track
	end
	return nil
end


local function create_channel_dialog(el)
	ui.head():new(el)
	
	el:attach(ui.create_toggle {
		x = 4, y = 4,
		off_spr = get_spr(115), on_spr = get_spr(116),
		get = function(self) return not sfx.channel_is_muted(app.pattern, el.channel) end,
		set =
			function(self)
				local muted = sfx.channel_is_muted(app.pattern, el.channel)
				app.mute_channel(app.pattern, el.channel, not muted)
				ui_notegrid.close_channel_dialog()
			end,
	})
	
	--[[
	el:attach(ui.create_field {
		x = 21, y = 4, width = 15,
		centered = true,
		to_str = function(self, v) return string.format("%03d", v) end,
		get = function(self) return sfx.pattern_track(app.pattern, el.channel) end,
		set =
			function(self, track)
				notify("***")
				app.set_pattern_track(app.pattern, el.channel, track)
			end,
		on_confirm = function(self) ui_notegrid.close_channel_dialog() end,
	})
	--]]
	
	el:attach(ui.create_list {
		x = 3, y = 14,
		width = el.width - 6, height = el.height - 72,
		cursor = "pointer",
		row_height = 9,
		nb_columns = 1,
		channel = el.channel,
		get_active = function(self) return sfx.pattern_track(app.pattern, self.channel) end,
		set_active =
			function(self, track)
				undo.checkpoint()
				if sfx.track_size(track) == 0 then
					init_track(track)
				end
				if sfx.channel_is_muted(app.pattern, self.channel) then
					sfx.mute_channel(app.pattern, self.channel, false)
				end
				app.set_pattern_track(app.pattern, self.channel, track)
			end,
		on_tap = function(self) ui_notegrid.close_channel_dialog() end,
		get_start = function(self) return channel_dialog_start end,
		set_start = function(self, start) channel_dialog_start = start end,
		get_max = function(self) return sfx.num_tracks() - 1 end,
		disabled = function(self) return sfx.channel_is_muted(app.pattern, self.channel) end,
		draw_item =
			function(self, track, x, y, w, h, has_pointer)
				local muted = sfx.channel_is_muted(app.pattern, self.channel)
				local active = sfx.pattern_track(app.pattern, self.channel)
				local size = sfx.track_size(track)
				if track == active then
					rrectfill(x, y, w, h, 0, muted and 19 or 17)
				elseif has_pointer then
					rrectfill(x, y, w, h, 0, 60)
				end
				local fg = size == 0 and (has_pointer and 59 or 60) or 57
				print(string.format("%03d", track), x + 3, y + 2, fg)
				local trk_patts = app.track_patterns(track)
				if trk_patts then
					if size > 0 then
						--print("\^:08047e0408000000", x + 15, y + 2, 58)
						print("\^:080c7e0c08000000", x + 15, y + 2, 58)
					end
					local x = 25
					for i = 1, #trk_patts do
						print(
							string.format("%02d", trk_patts[i].pattern),
							x, y + 2,
							trk_patts[i].channel == self.channel and 58 or 58 -- TODO: keep?
						)
						x += 12
					end
				end
			end
	})
	
	local oy = el.height - 35
	local x_button = app.column_width - 33 -- 14
	
	el:attach(ui.create_button {
		x = x_button, y = oy - 19,
		label = "clone",
		action =
			function(self)
				undo.checkpoint()
				local track = sfx.pattern_track(app.pattern, el.channel)
				track = init_first_empty_track(track)
				if track then
					local current_track = sfx.pattern_track(app.pattern, el.channel)
					for step = 0, sfx.track_size(track) - 1 do
						sfx.set_track_pitch(track, step, sfx.track_pitch(current_track, step))
						sfx.set_track_instrument(track, step, sfx.track_instrument(current_track, step))
						sfx.set_track_volume(track, step, sfx.track_volume(current_track, step))
						sfx.set_track_fx(track, step, sfx.track_fx(current_track, step))
						sfx.set_track_fx_params(track, step, sfx.track_fx_params(current_track, step))
					end
					sfx.set_track_speed(track, sfx.track_speed(current_track))
					sfx.set_track_loop0(track, sfx.track_loop0(current_track))
					sfx.set_track_loop1(track, sfx.track_loop1(current_track))
					sfx.mute_channel(app.pattern, el.channel, false)
					app.set_pattern_track(app.pattern, el.channel, track)
					ui_notegrid.close_channel_dialog()
				end
			end
	})
	
	el:attach(ui.create_horiz_divider {
		x = 0, y = oy - 5, -- 58,
		width = el.width - 1,
	})
	
	el:attach(ui.create_label {
		x = 4, y = oy, fg = 35,
		label = "length\-f:",
	})
	el:attach(ui.create_field {
		x = 4 + 32, y = oy - 1,
		width = 15, height = 7,
		get = function(self) return app.new_tracks_length end,
		set =
			function(self, value)
				local size = sfx.pattern_max_size(app.pattern) -- TODO: this is not corrent...
				value = mid(value, 0, size)
				app.new_tracks_length = value
			end,
	})
	
	el:attach(ui.create_label {
		channel = el.channel, fg = 36,
		x = 4, y = oy + 10,
		label = "speed\-f:",
	})
	el:attach(ui.create_field {
		x = 4 + 32, y = oy + 10 - 1,
		width = 15, height = 7,
		get = function(self) return app.new_tracks_speed end,
		set = 
			function(self, value)
				value = mid(value, 0, 255)
				app.new_tracks_speed = value
			end,
	})
	
	el:attach(ui.create_button {
		x = x_button, y = oy + 20,
		label = " new ",
		action =
			function(self)
				undo.checkpoint()
				local track = sfx.pattern_track(app.pattern, el.channel)
				track = init_first_empty_track(track)
				if track then
					sfx.mute_channel(app.pattern, el.channel, false)
					app.set_pattern_track(app.pattern, el.channel, track)
					ui_notegrid.close_channel_dialog()
				end
			end
	})
	
	function el:draw()
		rrectfill(0, 0, self.width, self.height, 0, 6)
		line(0, 0, 0, self.height - 1, 57)
		line(0, 0, self.width - 1, 0, 57)
		line(self.width - 1, self.height - 1, 0, self.height - 1, 58)
		line(self.width - 1, self.height - 1, self.width - 1, 0, 58)
	end
	function el:click()
		return true
	end
	function el:drag()
		return true
	end
	function el:tap()
		return true
	end
	function el:mousewheel()
		return true
	end
	return el
end


function ui_notegrid.close_channel_dialog()
	if channel_dialog then
		channel_dialog:detach()
	end
	channel_dialog = nil
end


-------------------------------------------------------------------------------
-- Note Grid
-------------------------------------------------------------------------------


function ui_notegrid.attach(parent, el)
	parent:attach(el)
	
	-- Private Fields
	local last_click_time = 0
	local click_counter = 0
	
	function el:draw(msg)
		local muted = sfx.channel_is_muted(app.pattern, self.channel)
		local track <const> = sfx.pattern_track(app.pattern, self.channel)
		local track_size <const> = sfx.track_size(track)
		if muted or track_size == 0 then
			return
		end
		local sustain_line_enabled = settings.user.sustain_line_enabled
		local inst_square_enabled = settings.user.instrument_square_enabled
		local pattern_is_playing <const> =
			sfx.playing_channels() != 0
			and sfx.playing_pattern() == app.pattern
		local channel_is_playing <const> = sfx.channel_is_playing(self.channel)
		local playing_channel_row <const> = sfx.playing_channel_row(self.channel)
		local track_length <const> = sfx.track_length(track)
		local track_loop0 <const> = sfx.track_loop0(track)
		local track_loop1 <const> = sfx.track_loop1(track)
		local track_is_looping <const> = sfx.track_is_looping(track)
		local start <const> = app.starting_row
		local nb_rows <const> = math.ceil(self.height / app.row_height)
		local selection_parts <const> = selection.parts()
		-- TODO: pattern_max_size
		-- Hot Loop for the Notes
		local prev_freq, prev_inst, prev_vol, prev_fx = 0xff, 0xff, 0xff, 0x00
		local last_int = 0xff
		local dy_text = math.ceil((app.row_height - 5) / 2)
		if app.row_height < 7 then dy_text = 0 end
		
		-----------------------------------------------------------------------------
		-- Hot Loop
		-----------------------------------------------------------------------------
		
		for row = 0, nb_rows - 1 do
			local step <const> = start + row
			local x <const> = 0
			local y <const> = 1 + row * app.row_height
			local y_text <const> = y + dy_text
			if step < 0 then
				goto continue
			elseif step >= track_size then
				--line(x, y, x + app.column_width - 2, y, 36)
				break
			end
			local is_greyed = step >= track_length
			local is_selected <const> = selection.has_channel(self.channel) 
				and selection.has_step(step)
			local step_is_playing <const> = playing_channel_row == step
			local step_in_bar = step % app.bar_length
			local step_in_beat = step_in_bar % app.beat_length
			if pattern_is_playing and channel_is_playing and step_is_playing then
				rrectfill(x, y, app.column_width - 1, app.row_height, 0, 36)
			elseif step_in_bar == 0 and (not is_greyed) then
				rrectfill(x, y, app.column_width - 1, app.row_height, 0, 35)
			elseif step_in_beat == 0 and (not is_greyed) then
				rrectfill(x, y, app.column_width - 1, app.row_height, 0, 34)
			end
			local freq <const> = sfx.track_pitch(track, step)
			local inst <const> = sfx.track_instrument(track, step)
			local vol <const> = sfx.track_volume(track, step)
			local fx <const> = sfx.track_fx(track, step)
			local fxp0 <const> = sfx.track_fx_param0(track, step)
			local fxp1 <const> = sfx.track_fx_param1(track, step)
			local note <const> = freq % 12
			local octave <const> = freq // 12
			-- Cursors and Selection
			-- TODO: only when the app.pattern is where the cursor is
			if is_selected and not app.follow_playhead then
				local selcol = app.is_editing and 37 or 38
				selcol = self.parent:has_keyboard_focus() and selcol or 39
				if selection_parts & selection.note ~= 0 then
					rrectfill(x_note, y, w_note_octave, app.row_height, 0, selcol)
				end
				if selection_parts & selection.instrument ~= 0 then
					local rr = self.parent.str_instrument and rrect or rrectfill
					rr(x_instrument, y, w_instrument, app.row_height, 0, selcol)
				end
				if selection_parts & selection.volume ~= 0 then
					local rr = self.parent.str_volume and rrect or rrectfill
					rr(x_volume, y, w_volume, app.row_height, 0, selcol)
				end
				if selection_parts & selection.fx ~= 0 then
					local rr = self.parent.str_fx and rrect or rrectfill
					rr(x_fx, y, w_fx, app.row_height, 0, selcol)
				end
			end
			-- Note and Octave
			local is_retrig_inst = sfx.instrument_flag(last_inst or inst, 0x01)
			local is_sustained
			if is_retrig_inst then
				is_sustained =
					inst == 0xff
					and fx ~= ord("r")
			else
				is_sustained =
					freq == prev_freq
					and (inst == last_inst or inst == 0xff)
					and fx ~= ord("r")
					and prev_fx ~= ord("c")
			end
			if freq != 0xff then
				if is_sustained and sustain_line_enabled then
					line(x + 4, y, x + 4, y + app.row_height - 1, is_greyed and fg_greyed or fg_note)
					if is_retrig_inst and freq ~= prev_freq then
						pal(7, is_greyed and fg_greyed or fg_note)
						spr(72 + note, x + 3 + 4, y_text)
						if octave <= 9 then
							pal(7, is_greyed and fg_greyed or fg_octave)
							spr(96 + min(octave, 10), x + 13 + 4, y_text)
						else
							-- TODO
						end
					end
				else
					pal(7, is_greyed and fg_greyed or fg_note)
					spr(72 + note, x + 3, y_text)
					if octave <= 9 then
						pal(7, is_greyed and fg_greyed or fg_octave)
						spr(96 + min(octave, 10), x + 13, y_text)
					else
						-- TODO
					end
				end
			else
				pal(7, is_greyed and fg_greyed or fgd_note)
				spr(65, x + 4, y_text)
			end
			-- Instrument
			if is_selected and self.parent.str_instrument then
				pal(7, self.parent.str_instrument_is_valid and 7 or 8)
				print(self.parent.str_instrument, x + 20, y_text, 7)
			elseif inst_square_enabled and inst == prev_inst and inst ~= 0xff then
				pal(7, is_greyed and fg_greyed or fg_inst)
				spr(69, x + 20, y_text)
			elseif inst != 0xff then
				local unchanged = false and inst == prev_inst
				local fg = (unchanged and fgd_inst or fg_inst)
				pal(7, is_greyed and fg_greyed or fg)
				spr(256 + inst, x + 20, y_text)
			else
				pal(7, is_greyed and fg_greyed or fgd_inst)
				spr(64, x + 20, y_text)
			end
			-- Volume
			if is_selected and self.parent.str_volume then
				pal(7, self.parent.str_volume_is_valid and 7 or 8)
				print(self.parent.str_volume, x + 31, y_text, 7)
			elseif false and vol == prev_vol and vol ~= 0xff then
				pal(7, is_greyed and fg_greyed or fg_vol)
				spr(69, x + 31, y_text)
			elseif vol != 0xff then
				local unchanged = false and vol == prev_vol
				local fg = (unchanged and fgd_vol or fg_vol)
				pal(7, is_greyed and fg_greyed or fg)
				spr(256 + vol, x + 31, y_text)
			else
				pal(7, is_greyed and fg_greyed or fgd_vol)
				spr(64, x + 31, y_text)
			end
			-- FX
			if is_selected and self.parent.str_fx then
				pal(7, 7)
				print(self.parent.str_fx, x + 42, y_text, self.parent.str_fx_is_valid and 7 or 8)
			elseif fx != 0x0 then
				print(chr(fx), x + 42, y_text, is_greyed and fg_greyed or fg_fx) -- TODO: replace with sprites
				pal(7, is_greyed and fg_greyed or fg_fx)
				spr(256 + ((fxp0 << 4) | fxp1), x + 46, y_text)
			else
				pal(7, is_greyed and fg_greyed or fgd_fx)
				spr(66, x + 42, y_text)
			end
			-- Loop Markers
			if track_is_looping then
				if step == track_length then
					spr(22, x, y - 8)
				end
				if step > 0 and step == track_loop0 then
					spr(21, x, y)
				end
			elseif step == track_length then
				line(x, y - 1, x + app.column_width - 2, y - 1, 37)
			end
			prev_fx = fx
			if inst ~= 0xff then
				prev_inst = inst
				last_inst = inst
				prev_vol = vol
			end
			prev_freq = freq
			pal(7, 7)
			::continue::
		end
		-----------------------------------------------------------------------------
		-- End of Hot Loop
		-----------------------------------------------------------------------------
	end
	
	function el:update(msg)
		local muted = sfx.channel_is_muted(app.pattern, self.channel)
		local track = sfx.pattern_track(app.pattern, self.channel)
		local size = sfx.track_size(track)
		if muted then
			return
		end
		local track = sfx.pattern_track(app.pattern, self.channel)
		if sfx.track_size(track) == 0 then
			return
		end
		local mx, my = mouse()
		mx -= self.sx
		my -= self.sy
		local has_pointer = 
			mx >= 0 and mx < self.width
			and my >= 0 and my < self.height
		if has_pointer and self.parent.is_selecting then
			local start <const> = app.starting_row
			local step <const> = app.starting_row + (msg.my - 1) // app.row_height
			local part <const> = self:x_to_part(mx)
			selection.set_from_anchor_to(self.channel, step, part)
		end
	end
	
	function el:click(msg)
		local muted = sfx.channel_is_muted(app.pattern, self.channel)
		if channel_dialog then
			ui_notegrid.close_channel_dialog()
		end
		if muted or app.follow_playhead then return end
		local track = sfx.pattern_track(app.pattern, self.channel)
		-- Check for double and triple click
		local t = time()
		if t - last_click_time < 0.25 then
			click_counter += 1
		else
			click_counter = 1
		end
		last_click_time = time()
		
		local step <const> = app.starting_row + (msg.my - 1) // app.row_height
		local part <const> = self:x_to_part(msg.mx)
		if msg.mb == 1 then
			self.parent:clear_edit()
			self.parent.is_selecting = true
			local how = key("ctrl") and "extend" or "set"
			local what =
				(click_counter == 1 and "part")
				or (click_counter == 2 and "row")
				or (click_counter == 3 and "beat")
				or (click_counter == 4 and "column")
				or "column"
			selection.set_anchor(self.channel, step, part, how, what)
		elseif msg.mb == 2 then
			self.parent:clear_edit()
			selection.move_to_step(self.channel, step, part)
		end
	end
	
	function el:drag(msg)
		local muted = sfx.channel_is_muted(app.pattern, self.channel)
		if muted or app.follow_playhead then return end
		if channel_dialog and channel_dialog.channel == self.channel then
			return
		end
		if msg.mb == 2 then
			local step <const> = app.starting_row + (msg.my - 1) // app.row_height
			local part <const> = self:x_to_part(msg.mx)
			self.parent:clear_edit()
			selection.move_to_step(self.channel, step, part)
		end
	end
	
	function el:release(msg)
		self.parent.is_selecting = false
		selection.clear_anchor()
	end
	
	function el:x_to_part(x)
		if x < x_instrument then
			return selection.note
		elseif x < x_volume then
			return selection.instrument
		elseif x < x_fx then
			return selection.volume
		else
			return selection.fx
		end
	end
	
	return el
end


-------------------------------------------------------------------------------
-- Channel Header
-------------------------------------------------------------------------------


function ui_notegrid.attach_header(parent, el)
	el.width = app.column_width
	el.height = app.track_header_height
	el.cursor = "pointer"
	el.blink_timer = 0
	parent:attach(el)
	
	function el:draw(msg)
		local muted <const> = sfx.channel_is_muted(app.pattern, self.channel)
		local track <const> = sfx.pattern_track(app.pattern, self.channel)
		local size <const> = sfx.track_size(track)
		local trk_patts <const> = app.track_patterns(track)
		-- Background is drawn by `tracker`
		if self:has_keyboard_focus() then
			rectfill(20, 1, 20 + 14, 7, 7)
			local x_cursor = print(self.str, 22, 2, self.str_is_valid and 55 or 8)
			if self.blink_timer % 32 > 16 then
				line(x_cursor, 1, x_cursor, 7, 14)
			end
		elseif muted or size == 0 then
			--print("\|e\-i.\-e.\-e.", 22, 2, 55)
			print(" + ", 22, 2, 55)
		else
			print(string.format("%03d", track), 22, 2, 55)
			if trk_patts and #trk_patts > 1 then
				pset(15, 4, 55) pset(17, 4, 55) pset(19, 4, 55)
				pset(35, 4, 55) pset(37, 4, 55) pset(39, 4, 55)
			end
		end
	end

	function el:update(msg)
		if self:has_keyboard_focus() then
			self.blink_timer += 1
			while peektext() do
				if #self.str < 3 then
					self.str = self.str .. readtext()
				else
					readtext()
				end
			end

			local val = tonum(self.str)
			self.str_is_valid = val ~= nil and val >= 0 and val < sfx.num_tracks() - 1

			if keyp("backspace") then
				self.str = sub(self.str, 1, -2)
			elseif keyp("escape") or (keyp("enter") and #self.str == 0) then
				self:set_keyboard_focus(false)
				app.was_in_text_field = true
			elseif keyp("enter") or (val and #self.str == 3) then
				if val then
					undo.checkpoint()
					track = mid(val, 0, sfx.num_tracks() - 1)
					sfx.mute_channel(app.pattern, self.channel, false)
					app.set_pattern_track(app.pattern, self.channel, track)
					ui_notegrid.close_channel_dialog()
				end
				self:set_keyboard_focus(false)
				app.was_in_text_field = true
			end
		end
	end
	
	function el:tap(msg)
		if self.last_tap and time() - self.last_tap < 0.4 then return end
		self.last_tap = time()
		local muted <const> = sfx.channel_is_muted(app.pattern, self.channel)
		local track = sfx.pattern_track(app.pattern, self.channel)
		local size <const> = sfx.track_size(track)
		if msg.last_mb == 1 and (not key("ctrl")) then
			local notegrid = self.parent.notegrids[self.channel]
			local has_dialog = channel_dialog and channel_dialog.channel == self.channel
			if channel_dialog then
				ui_notegrid.close_channel_dialog()
			end
			if notegrid and not has_dialog then
				channel_dialog = create_channel_dialog {
					channel = self.channel,
					x = 0, y = 1, width = app.column_width - 1,
					height = notegrid.height - 2,
				}
				notegrid:attach(channel_dialog)
			end
--		elseif size == 0 and not muted then
--			app.mute_channel(app.pattern, self.channel, true)
		elseif msg.last_mb == 2 then
			undo.checkpoint()
			local muted = sfx.channel_is_muted(app.pattern, self.channel)
			app.mute_channel(app.pattern, self.channel, not muted)
		end
	end
	
	function el:doubletap(msg)
		self:set_keyboard_focus(true)
		readtext(true)
		self.str = ""
	end
	
	function el:release(msg)
		self.clicked_prev = false
		self.clicked_next = false
	end

	return el
end


-------------------------------------------------------------------------------
-- Scrollbar
-------------------------------------------------------------------------------


function ui_notegrid.attach_scrollbar(parent, el)
	el.cursor = 1
	parent:attach(el)
	function el:draw(msg)
		local start <const> = app.starting_row
		local max_rows <const> = sfx.pattern_max_size(app.pattern)
		local nb_rows <const> = math.ceil(self.height / app.row_height)
		local scale = self.height / max_rows
		local y = start * scale
		local h = nb_rows * scale + 1
		rrectfill(0, 0, self.width, self.height, 0, 55)
		rrectfill(0, y, self.width, h, 0, 56)
		for r = app.bar_length, max_rows, app.bar_length do
			local y = r * scale
			line(0, y, 3, y, pget(0, y) == 55 and 0 or 55)
		end
		local following_playhead =	sfx.music_is_playing() and app.follow_playhead
		if selection.has_selection() and (not following_playhead) then
			selection.for_each_channel_each_step(
				function(_track, step)
					local y = step * scale
					rect(1, y, 2, y + scale - 1, app.is_editing and 37 or 38)
				end
			)
		end
		if sfx.music_is_playing() then
			local leading_channel = sfx.playing_lead_channel()
			local playing_step = sfx.playing_channel_row(leading_channel)
			local y = playing_step * scale
			line(0, y, 3, y, 36)
		end
	end
	function el:drag(msg)
		local start <const> = app.starting_row
		local max_rows <const> = sfx.pattern_max_size(app.pattern)
		local nb_rows <const> = math.ceil(self.height / app.row_height)
		local scale = self.height / max_rows
--		local y = start * scale
		local h = nb_rows * scale + 1
		local row = flr((msg.my - h / 2) / scale)
		app.starting_row = mid(row, 0, max_rows - nb_rows)
	end
	return el
end


return ui_notegrid
:: src/ui/panel.lua
--[[pod_format="raw",created="2026-02-01 19:17:43",modified="2026-02-19 21:34:53",revision=14922]]
local app = require "src/app.lua"
local selection = require "src/selection.lua"
local sfx = require "src/sfx/sfx.lua"
local ui = require "src/ui/ui.lua"
local ui_routing = require "src/ui/routing.lua"
local ui_panel = {}
local undo = require "src/undo.lua"


----------------------------------------------------------------------------------------------------
-- View Selector
----------------------------------------------------------------------------------------------------


function ui_panel.attach_view_selector(parent, el)
	el.width = 19
	el.height = 34
	el.cursor = "pointer"
	parent:attach(el)
	
	function el:draw(msg)
		--rrectfill(0, 0, self.width, self.height, 0, 47)
		local clicked = msg.mb == 1
		if clicked and false then
			rrectfill(0, 0, self.width, self.height, 0, 58)
		end
		pal(7, app.view == "tracker" and 59 or 58)
		pal(57, app.view == "tracker" and 7 or 57)
		spr(1, 1, 0)
		pal(7, app.view == "synth" and 59 or 58)
		pal(57, app.view == "synth" and 7 or 57)
		spr(3, 1, 18)
		pal(7, 7)
		pal(57, 57)
	end
	
	function el:click(msg)
		undo.checkpoint()
		if app.view == "synth" then
			app.view = "tracker"
		else
			app.view = "synth"
		end
		app.refresh_gui = true
		undo.checkpoint()
	end
	
	return el
end


----------------------------------------------------------------------------------------------------
-- Octave Selector
----------------------------------------------------------------------------------------------------


function ui_panel.attach_octave_selector(parent, el)
	el.width = 19
	el.height = 10
	el.cursor = get_spr(50)
	el.blink_timer = 0
	parent:attach(el)
	
	el.drag_start = nil

	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 47)
		-- Base Note
		if self:has_keyboard_focus() then
			rrectfill(4, 2, 11, 7, 0, 7)
			local x_cursor = print(self.str or "", 6, 3, self.str_is_valid and 55 or 8)
			if self.blink_timer % 32 > 16 then
				line(x_cursor, 2, x_cursor, 8, 14)
			end
		else		
			local displayed_note = app.base_note
			if stat(408, 0) == 1 then
				displayed_note = stat(408, 4)
			end
			local note = flr(displayed_note % 12)
			local octave = flr(displayed_note / 12)
			
			local ox_note <const> = 3
			local fg <const> = 4
			pal(7, self.dragged and 7 or fg)
			spr(84 + note, ox_note, 2)
			local x_oct = ox_note + 9
			pal(7, 7)
			print(
				string.format("%1d", octave),
				x_oct, 2 + 1,
				self.dragged and 7 or fg
			)
		end
	end	

	function el:update()
		if self:has_keyboard_focus() then
			self.blink_timer += 1
			while peektext() do
				if #self.str < 3 then
					self.str = self.str .. readtext()
				else
					readtext()
				end
			end
			
			local char_to_note <const> = {
				["c"] = 0, ["c#"] = 1,
				["d"] = 2, ["d#"] = 3,
				["e"] = 4,
				["f"] = 5, ["f#"] = 6,
				["g"] = 7, ["g#"] = 8,
				["a"] = 9, ["a#"] = 10,
				["b"] = 11,
			}
			
			local key_str = self.str:sub(1, -2)
			local key = char_to_note[key_str]
			local oct_str = self.str[#self.str]
			local oct = oct_str and tonumber(oct_str) or nil
			self.str_is_valid = 
				char_to_note[self.str]
				or (oct and #self.str == 1)
				or (key and oct)

			if keyp("backspace") then
				self.str = sub(self.str, 1, -2)
			elseif keyp("escape") or (keyp("enter") and #self.str == 0) then
				self:set_keyboard_focus(false)
				app.was_in_text_field = true
			elseif keyp("enter") or (key and oct) or (oct and #self.str == 1) then
				if not key then
					key = app.base_note % 12
				end
				if key and oct then
					app.base_note = mid(key + 12 * oct, 0, 0xfe)
				end
				self:set_keyboard_focus(false)
				app.was_in_text_field = true
			end
		end
	end
	
	function el:click(msg)
		self.dragged = true
		self.key_mode = msg.mb == 2
		self.cursor = 0
	end
	
	function el:drag(msg)
		local delta = ui.mouse_lock(0.125)
		if self.key_mode then
			app.base_note = mid(0, app.base_note - delta, 12 * 7)
		else
			app.base_note = mid(0, app.base_note - (12 * delta), 12 * 7)
		end
	end
	
	function el:release(msg)
		ui.mouse_unlock()
		self.cursor = get_spr(50)
		self.dragged = nil
		self.key_mode = nil
	end
	
	function el:tap(msg)
		if msg.last_mb == 1 then
			self:set_keyboard_focus(true)
			readtext(true)
			self.str = ""
		end
	end

	function el:doubleclick(msg)
		app.base_note = 48
	end
	
	return el
end


----------------------------------------------------------------------------------------------------
-- Instrument Selector
----------------------------------------------------------------------------------------------------


function ui_panel.attach_instrument_selector(parent, el)
	el.width = 19
	el.height = 16
	el.cursor = get_spr(53)
	el.blink_timer = 0
	parent:attach(el)
	
	el.drag_start = nil

	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 47)
		print("inst", 2, 1, 58)
		if self:has_keyboard_focus() then
			rrectfill(4, 8, 11, 7, 0, 7)
			local x_cursor = print(self.str or "", 6, 9, self.str_is_valid and 55 or 8)
			if self.blink_timer % 32 > 16 then
				line(x_cursor, 8, x_cursor, 14, 14)
			end
		elseif app.instrument == 0xff and self.saved_instrument then
			pal(7, 44)
			spr(64, 6, 9)
			pal(7, 7)
		else
			local sprite = 256 + app.instrument
			pal(7, self.dragged and 7 or 44)
			spr(sprite, 6, 9)
			pal(7, 7)
		end
	end	

	function el:update()
		if self:has_keyboard_focus() then
			self.blink_timer += 1
			while peektext() do
				if #self.str < 2 then
					self.str = self.str .. readtext()
				else
					readtext()
				end
			end
			
			local val = tonumber(self.str, 16)
			self.str_is_valid = val ~= nil

			if keyp("backspace") then
				self.str = sub(self.str, 1, -2)
			elseif keyp("escape") or (keyp("enter") and #self.str == 0) then
				self:set_keyboard_focus(false)
				app.was_in_text_field = true
			elseif keyp("enter") or (val and #self.str == 2) then
				if val then
					app.instrument = mid(val, 0, 0xff)
				end
				self:set_keyboard_focus(false)
				app.was_in_text_field = true
			end
		end
	end
	
	function el:click(msg)
		-- TODO: replace with pull-down menus
		self.dragged = true
		self.cursor = 0
	end
	
	function el:drag(msg)
		if self.dragged then
			local delta = ui.mouse_lock(0.125)
			-- TODO: allow "ff"
			local instrument = mid(0, app.instrument - delta, 0xff)
			if instrument ~= app.instrument then
				app.instrument = instrument
				app.node = 0
				-- TODO: cannot refresh gui in real time (lose mouselock)
				-- instead, recreate just the router?
				self.need_refresh_gui = true
				ui_routing.clear_placement_buttons()
			end
		end
	end
	
	function el:tap(msg)
		if msg.last_mb == 1 then
			self:set_keyboard_focus(true)
			readtext(true)
			self.str = ""
		elseif msg.last_mb == 2 then
			if self.saved_instrument then
				app.instrument = self.saved_instrument
				self.saved_instrument = nil
			else
				self.saved_instrument = app.instrument
				app.instrument = 0xff
			end
		end
	end
	
	function el:release(msg)
		if self.need_refresh_gui then
			app.refresh_gui = true
		end
		ui.mouse_unlock()
		self.cursor = get_spr(53)
		self.dragged = nil
	end

	function el:doubleclick(msg)
		app.instrument = 0
	end
	
	function el:mousewheel(msg)
		-- TODO: allow "ff"
		app.instrument = mid(app.instrument + msg.wheel_y, 0, 0xff)
		-- TODO: only refresh router
		app.refresh_gui = true
	end
	
	return el
end


----------------------------------------------------------------------------------------------------
-- Volume Selector
----------------------------------------------------------------------------------------------------


function ui_panel.attach_volume_selector(parent, el)
	el.width = 19
	el.height = 16
	el.cursor = get_spr(53)
	el.blink_timer = 0
	parent:attach(el)
	
	el.drag_start = nil

	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 47)
		print("vol", 4, 1, 58)
		if self:has_keyboard_focus() then
			rrectfill(4, 8, 11, 7, 0, 7)
			local x_cursor = print(self.str or "", 6, 9, self.str_is_valid and 55 or 8)
			if self.blink_timer % 32 > 16 then
				line(x_cursor, 8, x_cursor, 14, 14)
			end
		else
			local sprite = 256 + app.base_volume
			pal(7, self.dragged and 7 or 46)
			spr(sprite, 6, 9)
			pal(7, 7)
		end
	end	

	function el:update()
		if self:has_keyboard_focus() then
			self.blink_timer += 1
			while peektext() do
				if #self.str < 2 then
					self.str = self.str .. readtext()
				else
					readtext()
				end
			end
			
			local val = tonumber(self.str, 16)
			self.str_is_valid = val ~= nil

			if keyp("backspace") then
				self.str = sub(self.str, 1, -2)
			elseif keyp("escape") or (keyp("enter") and #self.str == 0) then
				self:set_keyboard_focus(false)
				app.was_in_text_field = true
			elseif keyp("enter") or (val and #self.str == 2) then
				if val then
					app.base_volume = mid(val, 0, 0xff)
				end
				self:set_keyboard_focus(false)
				app.was_in_text_field = true
			end
		end
	end
	
	function el:click(msg)
		self.dragged = true
		self.cursor = 0
	end
	
	function el:drag(msg)
		if self.dragged then
			local delta = ui.mouse_lock(0.125)
			app.base_volume = mid(0, app.base_volume - delta, 0xff)
		end
	end
	
	function el:tap(msg)
		if msg.last_mb == 1 then
			self:set_keyboard_focus(true)
			readtext(true)
			self.str = ""
		end
	end
	
	function el:release(msg)
		if self.need_refresh_gui then
			readtext(true)
			app.refresh_gui = true
		end
		ui.mouse_unlock()
		self.cursor = get_spr(53)
		self.dragged = nil
	end

	function el:doubleclick(msg)
		app.instrument = 0
	end
	
	function el:mousewheel(msg)
		app.base_volume = mid(app.base_volume + msg.wheel_y * 0x8, 0, 0x60)
	end
	
	return el
end


----------------------------------------------------------------------------------------------------
-- Step Selector
----------------------------------------------------------------------------------------------------


function ui_panel.attach_step_selector(parent, el)
	el.width = 19
	el.height = 16
	el.cursor = get_spr(53)
	el.blink_timer = 0
	parent:attach(el)
	
	el.drag_start = nil

	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 47)
		print("jump", 2, 1, 58)
		if self:has_keyboard_focus() then
			rrectfill(4, 8, 11, 7, 0, 7)
			local x_cursor = print(self.str or "", 6, 9, self.str_is_valid and 55 or 8)
			if self.blink_timer % 32 > 16 then
				line(x_cursor, 8, x_cursor, 14, 14)
			end
		else
			local str = string.format("%02d", app.jump_step)
			print(str, 6, 9, self.dragged and 7 or 35)
		end
	end	

	function el:update()
		if self:has_keyboard_focus() then
			self.blink_timer += 1
			while peektext() do
				if #self.str < 2 then
					self.str = self.str .. readtext()
				else
					readtext()
				end
			end

			local val = tonumber(self.str)
			self.str_is_valid = val ~= nil

			if keyp("backspace") then
				self.str = sub(self.str, 1, -2)
			elseif keyp("escape") or (keyp("enter") and #self.str == 0) then
				self:set_keyboard_focus(false)
				app.was_in_text_field = true
			elseif keyp("enter") or (val and #self.str == 2) then
				if val then
					app.jump_step = mid(math.floor(val), 0, 99)
				end
				self:set_keyboard_focus(false)
				app.was_in_text_field = true
			end
		end
	end
	
	function el:click(msg)
		self.dragged = true
		self.cursor = 0
	end
	
	function el:drag(msg)
		if self.dragged then
			local delta = ui.mouse_lock(0.125)
			local val = math.floor(app.jump_step - delta)
			app.jump_step = mid(val, 0, 99)
		end
	end
	
	function el:tap(msg)
		self:set_keyboard_focus(true)
		readtext(true)
		self.str = ""
	end
	
	function el:release(msg)
		if self.need_refresh_gui then
			app.refresh_gui = true
		end
		ui.mouse_unlock()
		self.cursor = get_spr(53)
		self.dragged = nil
	end

	function el:doubleclick(msg)
		app.instrument = 0
	end
	
	function el:mousewheel(msg)
		app.jump_step = mid(app.jump_step + msg.wheel_y, 0, 99)
	end
	
	return el
end


----------------------------------------------------------------------------------------------------
-- Pattern Selector
----------------------------------------------------------------------------------------------------


function ui_panel.attach_pattern_selector(parent, el)
	el.width = 19
	el.height = 16
	parent:attach(el)
	
	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 49)
		ui.print_centered("patt", 10, 1, 58)
		ui.print_centered(string.format("%02d", app.pattern), 10, 9, 56) -- 12 or 19
	end
	
	function el:mousewheel(msg)
		app.pattern = mid(app.pattern + msg.wheel_y, 0, sfx.num_patterns() - 1)
	end
	
	return el
end


----------------------------------------------------------------------------------------------------
-- Pattern Arrows
----------------------------------------------------------------------------------------------------


function ui_panel.attach_pattern_arrows(parent, el)
	el.width = 19
	el.height = 13
	el.cursor = "pointer"
	parent:attach(el)
	
	function el:draw(msg)
		--rrectfill(0, 0, self.width, self.height, 0, 47)
		pal(7, self.clicked_prev and 13 or 58)
		spr(43, 2, 2)
		pal(7, self.clicked_next and 13 or 58)
		spr(44, 10, 2)
		pal(7, 7)
	end
	
	function el:click(msg)
		if msg.mx < 9 then
			self.clicked_prev = true
			app.pattern = mid(app.pattern - 1, 0, sfx.num_patterns() - 1)
		elseif msg.mx > 9 then
			self.clicked_next = true
			app.pattern = mid(app.pattern + 1, 0, sfx.num_patterns() - 1)
		end
	end
	
	function el:release(msg)
		self.clicked_prev = false
		self.clicked_next = false
	end
	
	return el
end


----------------------------------------------------------------------------------------------------
-- Pattern Flags
----------------------------------------------------------------------------------------------------


function ui_panel.attach_pattern_flags(parent, el)
	el.width = 22
	el.height = 10 + 2 * 11
	el.cursor = "pointer"
	parent:attach(el)
	
	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 43)
		ui.print_centered("loop", 12, 1, 58)
		pal(58, sfx.pattern_loop_start(app.pattern) and 37
			or (self.clicked_loop_start and 13 or 58))
		spr(40, 2, 10)
		pal(58, sfx.pattern_loop_end(app.pattern) and 37
			or (self.clicked_loop_end and 13 or 58))
		spr(41, 13, 10)
		pal(58, sfx.pattern_loop_stop(app.pattern) and 37
			or (self.clicked_loop_stop and 13 or 58))
		spr(42, 7, 10 + 11)
		pal(58, 58)
	end	
	
	function el:hover(msg)
		if msg.my < 10 then
			self.cursor = 1
		else
			self.cursor = "pointer"
		end
	end
	
	function el:click(msg)
		if msg.my < 10 then
			-- nothing
		elseif msg.my < 22 then
			if msg.mx < 12 then
				self.clicked_loop_start = true
			else
				self.clicked_loop_end = true
			end
		else
			self.clicked_loop_stop = true
		end
	end
	
	function el:tap(msg)
		if msg.my < 10 then
			-- nothing
		elseif msg.my < 22 then
			if msg.mx < 12 then
				local is_on = sfx.pattern_loop_start(app.pattern)
				sfx.set_pattern_loop_start(app.pattern, not is_on)
			else
				local is_on = sfx.pattern_loop_end(app.pattern)
				sfx.set_pattern_loop_end(app.pattern, not is_on)
			end
		else
			local is_on = sfx.pattern_loop_stop(app.pattern)
			sfx.set_pattern_loop_stop(app.pattern, not is_on)
		end
	end
	
	function el:release(msg)
		self.clicked_loop_start = false
		self.clicked_loop_end = false
		self.clicked_loop_stop = false
	end
	
	return el
end


----------------------------------------------------------------------------------------------------
-- Meters
----------------------------------------------------------------------------------------------------


local sample_scale <const> = 32767.0

local last_lpeak = 0
local last_rpeak = 0


function ui_panel.attach_meters(parent, el)
	el.width = 13
	el.height = 52
	parent:attach(el)
	function el:draw(msg)
		local hmet = self.height - 4
		--rrectfill(0, 0, self.width, self.height, 0, 47)
		rrectfill(1, 1, self.width - 2, self.height - 2, 0, 59)
		app.draw_borders(1, 1, self.width - 2, self.height - 2)
		if not app.show_meter then return end
		local ox, oy = 2, self.height - 3
		local n = stat(465, 0, 0x90000)
		local lpeak, rpeak = 0.0, 0.0
		for i = 0, n, 4 do
			local lsample = abs(peek2(0x90000 + i))
			lpeak = max(lpeak, lsample)
			local rsample = abs(peek2(0x90002 + i))
			rpeak = max(rpeak, rsample)
		end
		-- Convert to decibels
		lpeak = 20 * math.log(lpeak / sample_scale, 10)
		rpeak = 20 * math.log(rpeak / sample_scale, 10)
		-- Scale so that -40db = 0 and 0db = 1
		lpeak = 1 + lpeak / app.min_db
		lpeak = mid(lpeak, 0, 1)
		rpeak = 1 + rpeak / app.min_db
		rpeak = mid(rpeak, 0, 1)
		-- Slow down the fall
		lpeak = max(lpeak, last_lpeak - app.meter_speed)
		last_lpeak = lpeak
		rpeak = max(rpeak, last_rpeak - app.meter_speed)
		last_rpeak = rpeak
		app.draw_vert_meter(ox + 0, oy - hmet + 1, 4, hmet, lpeak)
		app.draw_vert_meter(ox + 5, oy - hmet + 1, 4, hmet, rpeak)
--		if lpeak == 1 then rrectfill(ox, oy - hmet + 1, 4, 0.2*hmet, 0, 8) end
--		if rpeak == 1 then rrectfill(ox + 5, oy - hmet + 1, 4, 0.2*hmet, 0, 8) end
	end
	function el:tap(msg)
		if msg.last_mb == 1 then
			app.show_meter = not app.show_meter
		end
	end
	return el
end


----------------------------------------------------------------------------------------------------
-- Record Button
----------------------------------------------------------------------------------------------------


function ui_panel.attach_edit_button(parent, el)
	el.width = 19
	el.height = 14
	el.cursor = "pointer"
	parent:attach(el)

	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 43)
		spr(app.is_editing and 7 or 6, 0, 0)
	end
	
	function el:click()
		app.is_editing = not app.is_editing
		if app.is_editing and sfx.music_is_playing() and app.follow_playhead then
			app.play_or_pause()
		end
	end
	
	return el
end


----------------------------------------------------------------------------------------------------
-- Play Button
----------------------------------------------------------------------------------------------------


function ui_panel.attach_play_button(parent, el)
	el.width = 19
	el.height = 14
	el.cursor = "pointer"
	parent:attach(el)

	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 45)
		spr(sfx.music_is_playing() and 5 or 4, 0, 0)
	end
	
	function el:click()
		app.play_or_pause("follow_playhead")
	end
	
	return el
end


----------------------------------------------------------------------------------------------------
-- Piano-Roll Toggle
----------------------------------------------------------------------------------------------------


function ui_panel.attach_piano_toggle(parent, el)
	el.width = 17
	el.height = 11 -- * 2 + 2
	el.cursor = "pointer"
	parent:attach(el)
	
	function el:draw(msg)
		--rrectfill(0, 0, self.width, self.height, 0, 47)
		if app.tracker_mode == "tracker" then
			spr(134)
--			spr(135, 1, 0)
--			pal(7, 57) pal(63, 58)
--			spr(134, 1, 13)
--			pal(7, 7) pal(63, 63)
		else
			spr(135)
--			pal(7, 57) pal(63, 58) pal(59, 6) pal(60, 6)
--			spr(135, 1, 0)
--			pal(7, 7) pal(63, 63) pal(59, 59) pal(60, 60)
--			spr(134, 1, 13)
		end
	end
	
	function el:click(msg)
		undo.checkpoint()
		if app.tracker_mode == "pianoroll" then
			app.tracker_mode = "tracker"
		else
			app.tracker_mode = "pianoroll"
		end
		app.refresh_gui = true
		undo.checkpoint()
	end
	
	return el
end


----------------------------------------------------------------------------------------------------
-- Wavetables Toggle
----------------------------------------------------------------------------------------------------


function ui_panel.attach_wavetable_toggle(parent, el)
	el.cursor = "pointer"
	el.x_left = el.width // 4 - 14
	el.x_right = 3 * el.width // 4 - 14
	parent:attach(el)
	
	function el:draw(msg)
		--rrectfill(0, 0, self.width, self.height, 0, 47)
		if app.synth_mode == "instrument" then
			spr(136, self.x_left, 1)
			pal(7, 60)
			spr(137, self.x_right, 1)
			pal(7, 7)
		else
			pal(7, 60)
			spr(136, self.x_left, 1)
			pal(7, 7)
			spr(137, self.x_right, 1)
		end
	end
	
	function el:click(msg)
--		local pointer_on_left = msg.mx < self.width // 2
--		if pointer_on_left and app.synth_mode == "wavetable" then
		if app.synth_mode == "wavetable" then
			undo.checkpoint()
			app.synth_mode = "instrument"
			app.refresh_gui = true
			undo.checkpoint()
--		elseif (not pointer_on_left) and app.synth_mode == "instrument" then
		else
			undo.checkpoint()
			app.synth_mode = "wavetable"
			app.refresh_gui = true
			undo.checkpoint()
		end
	end
	
	return el
end


return ui_panel
:: src/ui/params.lua
--[[pod_format="raw",created="2024-04-20 11:45:24",modified="2026-02-19 21:34:53",revision=29316]]
local app = require "src/app.lua"
local sfx = require "src/sfx/sfx.lua"
local undo = require "src/undo.lua"
local ui = require "src/ui/ui.lua"
local ui_menus = require "src/ui/menus.lua"


local ui_params = {}


-------------------------------------------------------------------------------
-- Local Functions
-------------------------------------------------------------------------------


local function attach_relationship(parent, el)
	el.width, el.height = 8, 7
	el.cursor = "pointer"
	parent:attach(el)
	function el:draw()
		local flags, _, _, _ = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
--		rectfill(2, 1, 6, 5, 57)
--		if self.mini then
--			spr(114, 2, 0)
--		else
			spr(112, 1, 0)
--		end
		if flags & 0x03 == 0x01 then
			print("\^:2070200000000000", -1, 2, 63)
		elseif flags & 0x03 == 0x02 then
			print("\^:5020500000000000", -1, 2, 63)
		elseif flags & 0x03 > 0 then
			print("?", 3, 1, 63)
		end
	end
	function el:tap()
		ui_menus.open_relationship(self)
	end
	return el
end


local function attach_multiplier(parent, el)
	el.width, el.height = 13, 7
	el.cursor = "pointer"
	parent:attach(el)
	function el:draw()
		local flags, _, _, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
		clip()
		if self.mini then
			rectfill(0, 2, 2, 4, 57)
			if (env & 0xc0 > 0) then
				rectfill(0, 0, 2, 6, 57)
				print("!", 0, 1, 24)
--			else
--				spr(114, -1, 0)
			end
			return
		end
		--rrectfill(0, 0, self.width, self.height, 0, 47)
		if (env & 0xc0 > 0) then
			local dx = 0
			str2 = (env & 0x20 == 0) and 
				"\^:5020500000000000" or  -- *
				"\^:4020100000000000"     -- /
			if env & 0xc0 == 0x40 then
				str2 = str2 .. "\-c\^:5070400000000000"
				dx = 2 
				spr(113, 0, 0)
			end -- 4
			if env & 0xc0 == 0x80 then
				str2 = str2 .. "\^:1372770000000000"
				dx = 6
				spr(114, 0, 0)
			end -- 16
			if env & 0xc0 == 0xc0 then
				str2 = str2 .. "\^:5177470000000000"
				dx = 6 
				spr(114, 0, 0)
			end -- 64
			clip()
--			rectfill(0, 0, 4 + dx, 6, 57)
			print(str2, -3, 2, 24)
		else
			spr(112, 0, 0)
		end
	end
	function el:tap()
		ui_menus.open_multiplier(self)
	end
	return el
end


local function attach_envelope(parent, el)
	el.width, el.height = 7, 7
	el.cursor = "pointer"
	parent:attach(el)
	function el:draw()
		local flags, _, _, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
		clip()
		if flags & 0x04 > 0 then
			local fg, bg = 7, 18
			if flags & 0x08 > 0 then
				fg, bg = bg, fg
			end
			line(1, 0, self.width - 1 - 1, 0, bg)
			rectfill(0, 1, self.width - 1 - 0, self.height - 1 - 1, bg)
			line(1, self.height - 1 - 0, self.width - 1 - 1, self.height - 1 - 0, bg)
--			line(2, 0, self.width - 3, 0, bg)
--			rectfill(1, 1, self.width - 2, self.height - 2, bg)
--			line(2, self.height - 1, self.width - 3, self.height - 1, bg)
			print(string.format("%x", env & 0x0f), 2, 1, fg)
		elseif flags & 0x10 > 0 then
			line(1, 0, self.width - 1 - 1, 0, 30)
			rectfill(0, 1, self.width - 1 - 0, self.height - 1 - 1, 30)
			line(1, self.height - 1 - 0, self.width - 1 - 1, self.height - 1 - 0, 30)
			print("r", 2, 1, 7)
		else
--			spr(112, 0, -1)
			line(2, 1, self.width - 1 - 2, 1, 57)
			rectfill(1, 2, self.width - 1 - 1, self.height - 1 - 2, 57)
			line(2, self.height - 1 - 1, self.width - 1 - 2, self.height - 1 - 1, 57)
		end
	end
	function el:tap()
		ui_menus.open_envelope(self)
	end
	return el
end


-------------------------------------------------------------------------------
-- Local Functions: Getters and Setters
-------------------------------------------------------------------------------


local function get_val1(self)
	local _, val1, _, _ = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
	if (self.parent.max_val < 128) then
		if (val1 >= 128) val1 -= 256
	end
	return val1
end


local function set_val1(self, val)
	val = mid(self.parent.min_val, val, self.parent.max_val)
	sfx.set_node_param_val1(app.instrument, self.parent.node_id, self.parent.param, val)
end


local function get_val0(self)
	local _, _, val0, _ = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
	if (self.parent.max_val < 128) then
		if (val0 >= 128) val0 -= 256
	end
	return val0
end


local function set_val0(self, val)
	val = mid(self.parent.min_val, val, self.parent.max_val)
	sfx.set_node_param_val0(app.instrument, self.parent.node_id, self.parent.param, val)
end


local function has_env(self)
	local flags, _, _, _ = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
	return flags & (0x4 | 0x10) > 0
end


local function smart_str(self, val)
	local flags, _, _, _ = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
	local node_type = sfx.node_type(app.instrument, self.parent.node_id)
	if node_type == 0x02 and self.parent.param == 0x02 and (flags & 0x03 == 0x02) then
		local num = 1 + val % 16
		local den = 1 + val \ 16
		return num .. "/" .. den
	end
	return tostr(val)
end


-------------------------------------------------------------------------------
-- Full Widget with Knob
-------------------------------------------------------------------------------


function ui_params.attach(parent, x, y, el, style)
	el.x, el.y = x, y
	el.small = small
	el.width, el.height = 35 + 6, 58
	el.small = style.small
	el.emphasis = style.emphasis
	el.visible = el.visible or function(self) return true end
	parent:attach(el)
	el:attach(ui.create_knob {
		x = 2, y = 10,
		small = style.small,
		reversed = style.reversed,
		get = get_val1,
		set = set_val1,
		has_secondary = has_env,
		get_secondary = get_val0,
		set_secondary = set_val0,
	})
	attach_relationship(
		el,
		{
			x = -1, y = 41,
		}
	)
	el:attach(ui.create_field {
		x = 8, y = 41,
		centered = true,
		get = get_val1,
		set = set_val1,
		to_str = smart_str,
	})
	attach_multiplier(
		el,
		{
			x = 28, y = 41,
		}
	)
	el:attach(ui.create_field {
		x = 8, y = 51,
		fg = 18, centered = true,
		visible = has_env,
		get = get_val0,
		set = set_val0,
		to_str = smart_str,
	})
	attach_envelope(
		el,
		{
			x = 28, y = 51,
		}
	)
	
	function el:draw()
		--rectfill(0, 0, self.width - 1, self.height - 1, 43)
		if self.emphasis then
			rectfill(0, 0, self.width - 1 - 6, 8, 56)
		else
			rectfill(0, 0, self.width - 1 - 6, 8, 56)
		end
		ui.print_centered(
			el.long_label or el.label,
			(self.width - 6) // 2 + 1, 2,
			self.emphasis and 6 or 6
		)
	end
	
	function el:update(msg)
		self.hidden = not self:visible()
	end
	
	function el:click() return true end
	function el:doubleclick() return true end
	
	return el
end


-------------------------------------------------------------------------------
-- Mini Widget
-------------------------------------------------------------------------------


function ui_params.attach_mini(parent, el)
	el.x = el.x or 0
	el.y = el.y or (14 + 10 * el.param)
	el.width = parent.width
	el.height = 10
	el.visible = el.visible or function(self) return true end
	parent:attach(el)
	attach_relationship(
		el,
		{
			x = 23, y = 0,
			mini = true,
		}
	)
	el:attach(ui.create_field {
		x = 24 + 7, y = 0,
		get = get_val1,
		set = set_val1,
		to_str = smart_str,
	})
	attach_multiplier(
		el,
		{
			x = 24 + 7 + 20, y = 0,
			mini = true,
		}
	)
	el:attach(ui.create_field {
		x = 24 + 7 + 20 + 4, y = 0,
		fg = 18,
		visible = has_env,
		get = get_val0,
		set = set_val0,
		to_str = smart_str,
	})
	attach_envelope(
		el,
		{
			x = 24 + 7 + 20 + 4 + 20, y = 0,
		}
	)
	function el:draw()
		print(self.label, 24 - (4 * #self.label), 1, 56)
		---print(self.label, 2, 1, 5)
	end
	
	function el:update()
		self.hidden = not self:visible()
	end
	
	function el:click() return true end
	function el:doubleclick() return true end
end


return ui_params
:: src/ui/pianoroll.lua
--[[pod_format="raw",created="2026-02-18 10:38:25",modified="2026-02-19 21:34:53",revision=673]]
local app = require "src/app.lua"
local selection = require "src/selection.lua"
local settings = require "src/settings.lua"
local sfx = require "src/sfx/sfx.lua"
local ui = require "src/ui/ui.lua"
local undo = require "src/undo.lua"


local ui_pianoroll = {}


return ui_pianoroll
:: src/ui/routing.lua
--[[pod_format="raw",created="2024-04-13 06:33:13",modified="2026-02-19 21:34:53",revision=28941]]
local app = require "src/app.lua"
local sfx = require "src/sfx/sfx.lua"
local ui = require "src/ui/ui.lua"
local ui_visual = require "src/ui/visual.lua"
local undo = require "src/undo.lua"


local ui_routing = {}


-------------------------------------------------------------------------------
-- Locals
-------------------------------------------------------------------------------


local node_width <const> = 26
local node_height <const> = 16 -- TODO: if 7 vertical nodes, lower to 15?
local node_gap <const> = 14


local placement_buttons = {}


local function attach_placement_button(el)
	el.x -= 3
	el.y -= 3
	el.width = 7 -- TODO
	el.height = 7
	el.cursor = "pointer"
	app.routing_widget:attach(el)
	add(placement_buttons, el)
	function el:draw()
		local x, y = 3, 3
		rectfill(
			x - 2, y - 3, 
			x + 2, y + 3,
			24
		)
		rectfill(
			x - 3, y - 2,
			x + 3, y + 2,
			24
		)
		print("+", x - 1, y - 2, 7)
	end
	function el:click()
		return true -- ed_inst click() refreshes gui
	end
	function el:tap()
		ui_routing.clear_placement_buttons()
		undo.checkpoint()
		local new_node = sfx.add_node(app.instrument, self.parent_id,
			self.new_node_type, self.new_node_op, self.target_id, self.child_id)
		if app.node then
			app.node = new_node
		end
		app.refresh_gui = true
	end
	return el
end


local function attach_insert_between_parent(new_node_type, new_node_op, node, pos)
--	if (node == sfx.root) return
--	if (new_node_type >= 8) return
--	if new_node_type == 2 and new_node_op > 0 then
--		if (node.parent == sfx.root) return
--	end
	if node == sfx.root then return end
	attach_placement_button {
		parent_id = node.parent.id, target_id = node.id, child_id = node.id,
		new_node_type = new_node_type, new_node_op = new_node_op,
		x = pos.x - 2, y = pos.y + 4,
	}
end


local function attach_insert_top_child(new_node_type, new_node_op, node, pos)
--	if new_node_type >= 8 then
--		if (node == sfx.root) return
--		if (node.type >= 8) return
--	end
	if #node.children == 0 then
		-- add only child
		attach_placement_button {
			parent_id = node.id, target_id = node.id + 1,
			new_node_type = new_node_type, new_node_op = new_node_op,
			x = pos.x + node_width + 2, y = pos.y + 4,
		}
	else
		-- add above first child
		attach_placement_button {
			parent_id = node.id, target_id = node.id + 1,
			new_node_type = new_node_type, new_node_op = new_node_op,
			x = pos.x + node_width + node_gap + node_width \ 2, y = pos.y - 0,
		}
	end
end


local function attach_insert_sibling_below(new_node_type, new_node_op, node, pos)
	if (node == sfx.root) return
	attach_placement_button {
		parent_id = node.parent.id, target_id = node:last_child().id + 1,
		new_node_type = new_node_type, new_node_op = new_node_op,
		x = pos.x + node_width \ 2, y = pos.y + 8
	}
end


local function start_new_node(new_node_type, new_node_op, mode)
--	app.node = nil
--	app.refresh_gui = true
	for n = 0, 7 do
		local node = sfx.nodes[n]
		local pos = node.position
		if (not pos) break -- TODO: when does this occur?
		-- Coordinates from logical position
		pos.x = 4 + pos.column * (node_width + node_gap)
		pos.y = 4 + pos.row * node_height
		local ppos = node.parent.position
		ppos.x = 4 + ppos.column * (node_width + node_gap)
		ppos.y = 4 + ppos.row * node_height
		
		if mode == "anything-goes" then
			attach_insert_between_parent(new_node_type, new_node_op, node, pos)
			attach_insert_top_child(new_node_type, new_node_op, node, pos)
			attach_insert_sibling_below(new_node_type, new_node_op, node, pos)
			goto continue
		end
		
		if new_node_type == 2 and new_node_op > 0 then
			-- Modulators --
			if node != sfx.root and node.parent != sfx.root then
				-- insert between parent
				attach_placement_button {
					parent_id = node.parent.id, target_id = node.id, child_id = node.id,
					new_node_type = new_node_type, new_node_op = new_node_op,
					x = pos.x - 2, y = pos.y + 4,
				}
			end
			if node.type == 2 then -- and node.op == 0 then
				if #node.children == 0 then
					-- add only child
					attach_placement_button {
						parent_id = node.id, target_id = node.id + 1,
						new_node_type = new_node_type, new_node_op = new_node_op,
						x = pos.x + node_width + 2, y = pos.y + 4,
					}
				elseif node.children[1].type != 2 or node.children[1].op == 0 then
					-- add above first child
					attach_placement_button {
						parent_id = node.id, target_id = node.id + 1,
						new_node_type = new_node_type, new_node_op = new_node_op,
						x = pos.x + node_width + node_gap + node_width \ 2, y = pos.y - 0,
					}
				end
			end
			
		elseif new_node_type == 2 then
			-- Oscillators --
			if node != sfx.root and not (node.type == 2 and node.op > 0) then
				-- insert between parent
				attach_placement_button {
					parent_id = node.parent.id, target_id = node.id, child_id = node.id,
					new_node_type = new_node_type, new_node_op = new_node_op,
					x = pos.x - 2, y = pos.y + 4,
				}
			end
			if node != sfx.root then
				-- add sibling below
				attach_placement_button {
					parent_id = node.parent.id, target_id = node:last_child().id + 1,
					new_node_type = new_node_type, new_node_op = new_node_op,
					x = pos.x + node_width \ 2, y = pos.y + 8
				}
			end
			if node.type == 2 or node == sfx.root then
				if #node.children == 0 then
					-- add only child
					attach_placement_button {
						parent_id = node.id, target_id = node.id + 1,
						new_node_type = new_node_type, new_node_op = new_node_op,
						x = pos.x + node_width + 2, y = pos.y + 4,
					}
				elseif node.children[1].type != 2 	or node.children[1].op == 0 then
					-- add above first child
					attach_placement_button {
						parent_id = node.id, target_id = node.id + 1,
						new_node_type = new_node_type, new_node_op = new_node_op,
						x = pos.x + node_width + node_gap + node_width \ 2, y = pos.y - 0,
					}
				end
			end
			
		else
			-- Effects --
			if node != sfx.root then
				-- add sibling below
				attach_placement_button {
					parent_id = node.parent.id, target_id = node:last_child().id + 1,
					new_node_type = new_node_type, new_node_op = new_node_op,
					x = pos.x + node_width \ 2, y = pos.y + 8
				}
			end
			if 	node.type == 2 then
				if #node.children == 0 then
					-- add only child
					attach_placement_button {
						parent_id = node.id, target_id = node.id + 1,
						new_node_type = new_node_type, new_node_op = new_node_op,
						x = pos.x + node_width + 2, y = pos.y + 4,
					}
				elseif node.children[1].type != 2 or node.children[1].op == 0 then
					-- add above first child
					attach_placement_button {
						parent_id = node.id, target_id = node.id + 1,
						new_node_type = new_node_type, new_node_op = new_node_op,
						x = pos.x + node_width + node_gap + node_width \ 2, y = pos.y - 0,
					}
				end
			end
		end
		::continue::
	end -- for n = 0, 7
end


function ui_routing.clear_placement_buttons()
	local cleared_something = #placement_buttons > 0
	for i = 1, #placement_buttons do
		placement_buttons[i]:detach()
	end
	placement_buttons = {}
	return cleared_something
end


-- Routing display -------------------------------------------------------------


function ui_routing.attach(parent, el)
	parent:attach(el)
	ui_routing.attach_node_chooser(el, { x = el.width - 87, y = 58 })
	ui_visual.attach_node_oscillo(el, 8, {
		x = el.width - 87, y = 4,
		width = 81, height = 50,
		border = 60,
		horiz_scale = 2,
	})
	
	function el:draw()
		rectfill(0, 0, self.width, self.height, 59)
		-- Overview and Wavetable buttons
		for i, label in ipairs({"all","wt 0","wt 1","wt 2","wt 3"}) do
			local bg = (i == 1) and 7 or 60
			local fg = (i == 1) and 22 or 63
			rrectfill(4, 4 + i * node_height, node_width + 1, 9, 0, bg)
			print(label, 10 + (i==1 and 2 or 0), 4 + i * node_height + 2, fg)
			if app.node then
				-- nothing to do
			elseif
				(i == 1 and not app.wt)
				or (i == 2 and app.wt == 0)
				or (i == 3 and app.wt == 1)
				or (i == 4 and app.wt == 2)
				or (i == 5 and app.wt == 3)
			then
				rect(4 - 1, 4 + i * node_height - 1, 4 + node_width + 1, 4 + i * node_height + 8 + 1, 0)
				rect(4 - 2, 4 + i * node_height - 2, 4 + node_width + 2, 4 + i * node_height + 8 + 2, 24)
			end
		end
		-- Routing graph
		for n = 0, 7 do
			local node = sfx.nodes[n]
			local pos = node.position
			if (not pos) break -- TODO: when does this occur?
			-- Coordinates from logical position
			pos.x = 4 + pos.column * (node_width + node_gap)
			pos.y = 4 + pos.row * node_height
			local ppos = node.parent.position
			ppos.x = 4 + ppos.column * (node_width + node_gap)
			ppos.y = 4 + ppos.row * node_height

			if app.node == n then
				rect(pos.x - 2, pos.y - 2, pos.x + node_width + 2, pos.y + 8 + 2, 24)
				rect(pos.x - 1, pos.y - 1, pos.x + node_width + 1, pos.y + 8 + 1, 0)
			end
			
			if node.type >= 8 and node.older_sibling then
				-- Horizontal bracket
				local col = 6
				local x = pos.x + node_width \ 2
				local orig = node.older_sibling
				local depth = 0
				while #orig.children > 0 and depth < 8 do
					orig = orig.children[#orig.children]
					depth += 1
				end
				local orig_x = orig.position.x + node_width
				line(x - (node_width \ 2) - 3, pos.y - 4, x - (node_width \ 2) - 3 - 2, pos.y - 6, col)
				line(x - 3, pos.y - 4, x - (node_width \ 2) - 3, pos.y - 4, col)
				line(x, pos.y - 2, x - 2, pos.y - 4, col)
				line(x, pos.y - 2, x + 2, pos.y - 4, col)
				line(x + 3, pos.y - 4, orig_x + 3, pos.y - 4, col)
				line(orig_x + 3, pos.y - 4, orig_x + 3 + 2, pos.y - 6, col)
			elseif node != sfx.root then
				-- Arrow
				line(
					ppos.x + node_width + 7, ppos.y + 4,
					ppos.x + node_width + 1, ppos.y + 4,
					7
				)
				line(
					pos.x - 7, pos.y + 4,
					ppos.x + node_width + 7, ppos.y + 4,
					7
				)
				line(
					pos.x - 1, pos.y + 4,
					pos.x - 7, pos.y + 4,
					7
				)
				line(pos.x - 2, pos.y + 3, pos.x - 2, pos.y + 5, 7)
				line(pos.x - 3, pos.y + 2, pos.x - 3, pos.y + 6, 7)
			end
			
			-- Node boxes
			local str = "??? "
			local fg = 63
			local bg = 30
			if node == sfx.root then str = "main"; fg = 22; bg = 7
			elseif node.type == 2 then
				if node.op == 0 then str = "osc " .. n; bg = 17
				elseif node.op == 1 then str = "fm " .. n; bg = 27
				elseif node.op == 2 then str = "ring " .. n; bg = 22
				end
			elseif node.type == 8 then str = "filt " .. n; bg = 14
			elseif node.type == 9 then str = "echo " .. n; bg = 31
			elseif node.type == 10 then str = "shap " .. n; bg = 9
			end
			rectfill(pos.x, pos.y, pos.x + node_width, pos.y + 8, bg)
			ui.print_centered(str, pos.x + (node_width \ 2) + 1, pos.y + 2, fg)
			if sfx.node_flags(app.instrument, node.id) & 0x2 ~= 0 then
				line(pos.x + 2, pos.y + 4,
					pos.x + node_width - 2, pos.y + 4,
					8)
			end
		end
		clip()
		line()
		line(1, -1, 58)
		line(self.width - 2, -1, 58)
		line(self.width, 1, 58)
		line(self.width, self.height - 2, 57)
		line(self.width - 2, self.height, 57)
		line(1, self.height, 57)
		line(-1, self.height - 2, 57)
		line(-1, 1, 58)
		line(1, -1, 58)
		clip(self.sx, self.sy, self.width - 1, self.height - 1)
	end
	
	function el:hover(msg)
		self.cursor = 1
		if (#placement_buttons != 0) return
		for n = 0, 7 do
			local node = sfx.nodes[n]
			local pos = node.position
			if
				pos and pos.x and pos.x <= msg.mx and msg.mx <= pos.x + node_width
				and pos.y <= msg.my and msg.my <= pos.y + 10
			then
				self.cursor = "pointer"
			end
		end
		if msg.mx <= node_width + 4 then
			if (msg.my >= 4 + node_height and msg.my <= 4 + node_height + 10)
				or (msg.my >= 4 + 2 * node_height and msg.my <= 4 + 2 * node_height + 10)
				or (msg.my >= 4 + 3 * node_height and msg.my <= 4 + 3 * node_height + 10)
				or (msg.my >= 4 + 4 * node_height and msg.my <= 4 + 4 * node_height + 10)
				or (msg.my >= 4 + 5 * node_height and msg.my <= 4 + 5 * node_height + 10)
			then
				self.cursor = "pointer"
			end
		end
	end

	function el:click(msg)
		if #placement_buttons != 0 then
			ui_routing.clear_placement_buttons()
			return
		end
		for n = 0, 7 do
			local node = sfx.nodes[n]
			local pos = node.position
			if
				pos and pos.x and pos.x <= msg.mx and msg.mx <= pos.x + node_width
				and pos.y <= msg.my and msg.my <= pos.y + 10
			then
				if msg.mb == 1 then
					app.node = n
					app.refresh_gui = true
				else
					local flags = sfx.node_flags(app.instrument, node.id)
					flags ^^= 0x2
					sfx.set_node_flags(app.instrument, node.id, flags)
				end
				return true
			end
		end
		if msg.mx <= node_width + 4 then
			if msg.my >= 4 + node_height and msg.my <= 4 + node_height + 10 then
				app.node = nil
				app.wt = nil
				app.refresh_gui = true
				return true
			elseif msg.my >= 4 + 2 * node_height and msg.my <= 4 + 2 * node_height + 10 then
				app.node = nil
				app.wt = 0
				app.refresh_gui = true
				return true
			elseif msg.my >= 4 + 3 * node_height and msg.my <= 4 + 3 * node_height + 10 then
				app.node = nil
				app.wt = 1
				app.refresh_gui = true
				return true
			elseif msg.my >= 4 + 4 * node_height and msg.my <= 4 + 4 * node_height + 10 then
				app.node = nil
				app.wt = 2
				app.refresh_gui = true
				return true
			elseif msg.my >= 4 + 5 * node_height and msg.my <= 4 + 5 * node_height + 10 then
				app.node = nil
				app.wt = 3
				app.refresh_gui = true
				return true
			end
		end
	end
	
	return el
end


-- Node chooser ----------------------------------------------------------------


local node_choice = {
	[0] = {
		[0] = { label = "osc", color = 17, node_type = 0x2, node_op = 0x0 },
		{ label = "fm", color = 27, node_type = 0x2, node_op = 0x1 },
		{ label = "ring", color = 22, node_type = 0x2, node_op = 0x2 },
	},
	{
		[0] = { label = "filt", color = 14, node_type = 0x8, node_op = 0x0 },
		{ label = "echo", color = 31, node_type = 0x9, node_op = 0x0 },
		{ label = "shap", color = 9, node_type = 0x0a, node_op = 0x0 },
	},
}


function ui_routing.attach_node_chooser(parent, el)
	el.width = 118
	el.height = 50
	parent:attach(el)
	
	for i = 1, #placement_buttons do
		app.routing_widget:attach(placement_buttons[i])
	end

	function el:draw()
		--- rectfill(0, 0, self.width - 1, self.height - 1, 0)
		if #placement_buttons > 0 then
			print("choose position...", 4, 28, 22)
			return
		end
		if sfx.root.free_nodes == 0 then
			print("(8 nodes max)", 22, 28, 22)
			return
		end
		print("add module:", 4, 2, 57)
		local ox, oy = 4, 12
		for row = 0, #node_choice do
			for column = 0, #(node_choice[row]) do
				local x = ox + column * node_width
				local y = oy + row * (8 + 4)
				local col = node_choice[row][column].color
				rectfill(x, y, x + (node_width - 6), y + 8, col)
				ui.print_centered(
					node_choice[row][column].label,
					x + ((node_width - 6) \ 2) + 1,
					y + 2,
					63
				)
			end
		end
	end
	
	function el:hover(msg)
		self.cursor = 1
		if (#placement_buttons > 0) return
		if (sfx.root.free_nodes == 0) return
		local ox, oy = 4, 12
		for row = 0, #node_choice do
			for column = 0, #(node_choice[row]) do
				local x = ox + column * node_width
				local y = oy + row * (8 + 4)
				if
					x <= msg.mx and msg.mx <= x + (node_width - 6)
					and y <= msg.my and msg.my <= y + 8
				then
					self.cursor = "pointer"
				end
			end
		end
	end

	function el:click(msg)
		return true -- don't want to deselect the node!
	end
	
	function el:tap(msg)
		if #placement_buttons > 0 then
			ui_routing.clear_placement_buttons()
			return
		end
		if (sfx.root.free_nodes == 0) return
		local ox, oy = 4, 12
		for row = 0, #node_choice do
			for column = 0, #(node_choice[row]) do
				local x = ox + column * node_width
				local y = oy + row * (8 + 4)
				if
					x <= msg.mx and msg.mx <= x + (node_width - 6)
					and y <= msg.my and msg.my <= y + 8
				then
					start_new_node(
						node_choice[row][column].node_type,
						node_choice[row][column].node_op,
						msg.last_mb == 2 and "anything-goes"
					)
				end
			end
		end
	end
	

	return el
end


return ui_routing
:: src/ui/settings.lua
--[[pod_format="raw",created="2024-04-30 07:47:36",modified="2026-02-19 21:34:53",revision=26378]]
local settings = require "src/settings.lua"
local ui = require "src/ui/ui.lua"


local ui_settings = {}


-------------------------------------------------------------------------------
-- Settings Dialog
-------------------------------------------------------------------------------


function ui_settings.open()
	local el = { width = 480 - 300, height = 270 - 11 - 60 }
	ui.open_modal(el)
	el:attach(ui.create_label { x = 20, y = 30, label = "keys for playing notes", fg = 55})
	el:attach(ui.create_label { x = 20, y = 40, label = "- layout:", fg = 55})
	el:attach(ui.create_menu_button {
		x = 58, y = 40 - 2,
		bg = 7,
		get_label = function()
			return settings.user.pitched_layout
		end,
		fg = 59,
		highlight = 15,
		items = {
			{
				label = "piano",
				action = function()
					settings.change_keys(settings.piano_keys)
					settings.change_user { pitched_layout = "piano" }
				end
			},
			{
				label = "guitar",
				action = function()
					settings.change_keys(settings.guitar_keys)
					settings.change_user { pitched_layout = "guitar" }
				end
			},
			{
				label = "guitar (split)",
				action = function()
					settings.change_keys(settings.gl_two_handed_keys)
					settings.change_user { pitched_layout = "guitar (split)" }
				end
			},
			--[[
			{
				label = "major-thirds (split)",
				action = function()
					settings.change_keys(settings.major_thirds_keys)
					settings.change_user { pitched_layout = "major-thirds" }
				end
			},
			--]]
			{
				label = "chromatic",
				action = function()
					settings.change_keys(settings.chromatic_keys)
					settings.change_user { pitched_layout = "chromatic" }
				end
			},
		}		
	})
	
	el:attach(ui.create_label { x = 20, y = 60, label = "visuals:", fg = 55})
	el:attach(ui.create_toggle {
		x = 26, y = 72 - 1,
		label = "",
		fg = 55, check_fg = 18,
		get = function(self) return settings.user.sustain_line_enabled end,
		set = function(self, val) settings.change_user({ sustain_line_enabled = val }) end,
	})
	el:attach(ui.create_label {
		x = 44, y = 72,
		fg = 55,
		label = "sustain lines",
	})
	el:attach(ui.create_toggle {
		x = 26, y = 84 - 1,
		label = [[]],
		fg = 55, check_fg = 18,
		get = function(self) return settings.user.instrument_square_enabled end,
		set = function(self, val) settings.change_user({ instrument_square_enabled = val }) end,
	})
	el:attach(ui.create_label {
		x = 44, y = 84,
		fg = 55,
		label = "show unchanged instr. as \^:001c1c1c00000000",
	})
	
	el:attach(ui.create_label { x = 20, y = 140, label = "mouse movements (knobs, sliders, ...)", fg = 55})
	el:attach(ui.create_label { x = 20, y = 150, label = "- sensitivity:", fg = 55})
	el:attach_field {
		x = 78, y = 150 - 1,
		width = 30, height = 7,
		get = function() return settings.user.drag_sensitivity end,
		set = function(self, val)
			local v = mid(0.0, tonum(val), 8.0)
			if (v == 0) v = 0.5
			settings.change_user { drag_sensitivity = v }
		end
	}
	
	el:attach(ui.create_button {
		x = el.width - 16, y = 4,
		width = 11, height = 11,
		spr = 36,
		label = "close",
		action = function(self)
			ui.close_modal()
		end,
	})
	
	function el:draw()
		local width, height = self.width, self.height
		local xw, yh = self.width - 1, self.y - 1
		rrectfill(0, 0, width, height, 0, 6)
		local xw, yh = 0 + width - 2, 0 + height - 2
		line(0 + 1, yh, 0 + 1, 0 + 1, 57)
		line(0 + 2, yh, 0 + 2, 0 + 1, 57)
		line(0 + 1, 0 + 1, xw, 0 + 1, 57)
		line(0 + 2, 0 + 2, xw, 0 + 2, 57)
		line(xw, yh, xw, 0 + 1, 58)
		line(xw - 1, yh, xw - 1, 0 + 2, 58)
		line(0 + 1, yh, xw, yh, 58)
		line(0 + 2, yh - 1, xw, yh - 1, 58)
		rrect(0 + 0, 0 + 0, width, height, 0, 0)
		rrectfill(0 + 4, 0 + 4, width - 8, 11, 0, 55)
		ui.print_centered("settings", 0 + width // 2, 0 + 7, 6)
	end
	
	function el:click()
		return true
	end
end


return ui_settings

:: src/ui/synth.lua
--[[pod_format="raw",created="2024-04-10 15:43:44",modified="2026-02-19 21:34:53",revision=31110]]
local app = require "src/app.lua"
local settings = require "src/settings.lua"
local sfx = require "src/sfx/sfx.lua"
local ui = require "src/ui/ui.lua"
local ui_envelopes = require "src/ui/envelopes.lua"
local ui_nodes = require "src/ui/nodes.lua"
local ui_panel = require "src/ui/panel.lua"
local ui_routing = require "src/ui/routing.lua"
local ui_visual = require "src/ui/visual.lua"
--local ui_wavetable = require "src/ui/wavetable.lua"


local ui_synth = {}


-------------------------------------------------------------------------------
-- Locals
-------------------------------------------------------------------------------


local instr_chooser = false


-------------------------------------------------------------------------------
-- Synth View
-------------------------------------------------------------------------------


function ui_synth.attach(parent, el)
--	el.width = 480 - (app.detail and app.detail_width or 0)
--	el.height = 270 - 11 -- TODO: remove - 16
	parent:attach(el)

	app.is_editing = false

	ui_panel.attach_view_selector(el, { x = 0, y = 4 })
	el:attach(ui.create_horiz_divider { x = 3, y = 41, width = 13 })
	ui_panel.attach_octave_selector(el, { x = 0, y = 45 })
	ui_panel.attach_instrument_selector(el, { x = 0, y = 57 })
	ui_panel.attach_volume_selector(el, { x = 0, y = 75 })
		
	ui_synth.attach_instr_chooser(el, {
		x = app.panel_width, y = 4,
		width = 82, height = 97,
	})

	sfx.refresh_nodes(app.instrument)		
	app.routing_widget = ui_routing.attach(el, {
		x = app.panel_width + 90 - 4, y = 4,
		width = 356, height = 97,
	})

	ui_panel.attach_meters(el, { x = 464, y = 3 })
	
	local dx = app.synth_width + app.synth_gap
	local dy = app.synth_height + app.synth_gap
	local ox = (480 - (4 * dx) + app.synth_gap) \ 2
	local oy = 270 - 11 - (2 * app.synth_height) - app.synth_gap - 2
			
	if app.node then
		ui_nodes.attach_node_panel(
			el,
			{
				x = ox + app.mod_width + app.synth_gap, y = oy , 
				node_id = app.node,
				large = true,
			}
		)
		for row = 0, 1 do
			ui_envelopes.attach_panel(
				el,
				{
					x = 1, y = oy + row * dy, 
					env_id = row, large = true,
				}
			)
			ui_envelopes.attach_panel(
				el,
				{
					x = 480 - 2 * app.mod_width - 2 * app.synth_gap, y = oy + row * dy,
					env_id = 2 + row, large = true,
				}
			)
		end
	elseif not app.wt then
		local id = 0
		for row = 0, 1 do
			ui_envelopes.attach_panel(
				el,
				{
					x = 1, y = oy + row * dy, 
					env_id = row,
				}
			)
			for column = 0, 3 do
				ui_nodes.attach_node_panel(
					el,
					{
						x = ox + column * dx, y = oy + row * dy, 
						node_id = id
					}
				)
				id += 1
			end
			ui_envelopes.attach_panel(
				el,
				{
					x = 480 - app.mod_width - 4 - 2, y = oy + row * dy,
					env_id = 2 + row,
				}
			)
		end
	else -- A wavetable is selected
--		ui_wavetable.attach_temp_widget(
--			el,
--			{
--				x = 4, y = oy, 
--			}
--		)
	end

	function el:draw()
		local w <const> = self.width
		local h <const> = self.height
		cls(6)
		line(0, 0, w - 1, 0, 57)
		line(0, 0, 0, h - 1, 57)
		line(0, 106, w - 1, 106, 57)
		line(0, 105, w - 1, 105, 58)
		line(w - 1, 0, w - 1, h - 1, 58)
		line(0, h - 1, w - 1, h - 1, 58)
		-- divider
--		line(3, 41, app.panel_width - 4, 41, 58)
--		line(3, 42, app.panel_width - 4, 42, 57)
		if app.node then
			line(0, 183, 125, 183, 57)
			line(354, 183, 480, 183, 57)
			line(126, 106, 126, h - 1, 57)
			line(355, 106, 355, h - 1, 57)
			line(0, 182, 125, 182, 58)
			line(354, 182, 480, 182, 58)
			line(125, 106, 125, h - 1, 58)
			line(354, 106, 354, h - 1, 58)
		elseif not app.wt then
			line(0, 183, w - 1, 183, 57)
			line(64, 106, 64, h - 1, 57)
			line(152, 106, 152, h - 1, 57)
			line(240, 106, 240, h - 1, 57)
			line(328, 106, 328, h - 1, 57)
			line(416, 106, 416, h - 1, 57)
			line(0, 182, w - 1, 182, 58)
			line(63, 106, 63, h - 1, 58)
			line(151, 106, 151, h - 1, 58)
			line(239, 106, 239, h - 1, 58)
			line(327, 106, 327, h - 1, 58)
			line(415, 106, 415, h - 1, 58)
		end
	end	
	
	function el:update()
		-- Keys
		if ui.has_modal_or_menu() then return end
		if ui.head():get_keyboard_focus_element() then return end
		if app.was_in_text_field and not keyp() then
			return
		end
		app.was_in_text_field = false
		
		if keyp(settings.keys.play) and not currently_focused then
			app.play_or_pause(key("shift") and "follow_playhead" or nil)
		end

		local pitch, just_pressed = app.pitched_key()
		if pitch and not key("ctrl") then
			if just_pressed then
				note(pitch, app.instrument, app.base_volume,
					ord(" "), 0x00,
					8, -- channel 8 so it can play with pattern
					false -- don't force retrigger
				)
			end
		else
			note(0xff, 0xff, 0xff, 0xff, 0xff, 8)
		end
		
		if key("ctrl") and keyp("c") then
			local data = userdata("u8", 0x200)
			set(data, 0, peek(0x40000 + (app.instrument * 0x200), 0x200))
			set_clipboard(
				pod(
					{ instrument = data },
					7,
					{ pod_type = "instrument" }
				)
			)
			notify("copied instrument")
		end
		
		if key("ctrl") and keyp("v") then
			local data = unpod(get_clipboard())
			if data and type(data.instrument == "userdata") then
				poke(
					0x40000 + (app.instrument * 0x200),
					get(data.instrument, 0, 0x200)
				)
				app.refresh_gui = true
				app.node = 0
				notify("pasted instrument")
			else
				nodify("unable to paste instrument: invalid data in clipboard")
			end
		end
	end

	return el
end


-------------------------------------------------------------------------------
-- Instrument chooser
-------------------------------------------------------------------------------


local instr_chooser_start = 0


function ui_synth.attach_instr_chooser(parent, el)
	parent:attach(el)
	
	ui_panel.attach_wavetable_toggle(el, {
		x = 0, y = 0,
		width = el.width, height = 10,
	})
	
	el:attach(ui.create_list {
		x = 0, y = 12,
		width = el.width, height = el.height - 12,
		with_bg = false, with_border = false,
		get_max = function(self) return sfx.num_instruments() - 1 end,
		get_start = function(self) return instr_chooser_start end,
		set_start = function(self, instr) instr_chooser_start = instr end,
		get_active = function(self) return app.instrument end,
		set_active =
			function(self, instrument)
				app.instrument = instrument
				ui_routing.clear_placement_buttons()
				if app.node then
					app.node = 0 -- TODO: something else?
				end
				app.refresh_gui = true
			end,
		draw_item =
			function(self, instrument, x, y, w, h, has_pointer)
				if instrument == app.instrument then
					rrectfill(x, y, w, h, 0, 17)
					if y + h >= self.height - 1 then
						pset(0, self.height - 1, 58)
						pset(self.width - 1, self.height - 1, 57)
					end
				end
				local name = sfx.instrument_name(instrument)
				if name == "" then name = "---" end
				print(string.format("%02x", instrument), x + 2, y + 2, 45)
				print(":", x + 2 + 8, y + 2, 58)
				print(name, x + 2 + 14, y + 2, 57)
			end
	})
		
	function el:draw(msg)
		rrectfill(0, 0, self.width, self.height, 0, 59)
		clip()
		line(0, 11, self.width - 1, 11, 60)
		app.draw_borders(0, 0, self.width, self.height)
	end

	return el
end


return ui_synth
:: src/ui/toolrack.lua
--[[pod_format="raw",created="2026-02-08 05:11:28",modified="2026-02-19 21:34:53",revision=10887]]
local app = require "src/app.lua"
local ui = require "src/ui/ui.lua"
local ui_visual = require "src/ui/visual.lua"
local selection = require "src/selection.lua"
local sfx = require "src/sfx/sfx.lua"
local undo = require "src/undo.lua"


local toolrack = {}


-------------------------------------------------------------------------------
-- LOCALS
-------------------------------------------------------------------------------


local function create_nyi(el)
	ui.head():new(el)
	function el:draw()
		local cx = self.width // 2
		local cy = self.height // 2
		ui.print_centered(
			"(the \""..self.name.."\" tool is not yet implemented)", 
			cx, cy,
			56
		)
	end
	return el
end


-------------------------------------------------------------------------------
-- Pattern Tool
-------------------------------------------------------------------------------


local patt_width <const> = 26
local function create_pattern_list(el)
	el.start = 0
	ui.head():new(el)
	function el:draw(msg)
		local max_pattern = sfx.num_patterns() - 1
		local playing_pattern = sfx.playing_pattern()
		--local playing_row = sfx.playing_row()
		--local row_width = patt_width // (app.bar_length // app.beat_length)
		rrectfill(1, 1, self.width - 2, self.height - 2, 0, 59)
		clip(self.sx + 1, self.sy + 1, self.width - 2, self.height - 2)
		local nb_cols = (self.width - 2) // patt_width
		for i = 0, nb_cols do
			local pattern = self.start + i
			if pattern > max_pattern then break end
			local channels = sfx.pattern_channels(pattern)
			local x = 1 + i * patt_width
			local y = 8
			if pattern == playing_pattern then
				rrectfill(x, 1, patt_width + 1, self.height - 2, 0, 36)
				--local px = row_width * ((playing_row % app.bar_length) // app.beat_length)
				--line(x + px, 0, x + px, self.height, 37)
			end
			local bg = pattern == app.pattern and 17 or 60
			rrectfill(x + 2, y + 4, patt_width - 3, 18, 1, bg)
			if pattern > 0 then
				line(x, y + 13, x + 1, y + 13, 60)
			end
			if pattern < max_pattern then
				line(x + patt_width - 1, y + 13, x + patt_width - 1, y + 13, 60)
			end
			local fg = channels == 0 and 59 or 57
			print(string.format("%02d", pattern), x + 6, y + 7, fg)
			for c = 0, 7 do
				local cx = x + 6 + 2 * c
				local cfg = (channels & (1 << c) == 0) and 59 or 57
				line(cx, y + 14, cx, y + 15, cfg)
			end
			local y = 3
			local pointer_over_these_toggles =
				msg.has_pointer and msg.my <= 11
				and msg.mx // patt_width == i
			local toggle_pointed_at = 
				(msg.mx - 1) % patt_width // (patt_width // 3)
			if sfx.pattern_loop_start(pattern) then
				spr(12, x + 2, y)
			elseif pointer_over_these_toggles and toggle_pointed_at == 0 then
				pal(57, 60)
				spr(12, x + 2, y)
				pal(57, 57)
			end
			if sfx.pattern_loop_stop(pattern) then
				spr(14, x + 2 + 8, y)
			elseif pointer_over_these_toggles and toggle_pointed_at == 1 then
				pal(57, 60)
				spr(14, x + 2 + 8, y)
				pal(57, 57)
			end
			if sfx.pattern_loop_end(pattern) then
				spr(13, x + 2 + 8 * 2, y)
			elseif pointer_over_these_toggles and toggle_pointed_at == 2 then
				pal(57, 60)
				spr(13, x + 2 + 8 * 2, y)
				pal(57, 57)
			end
		end
		if self.drop_point then
			local x = 1 + (self.drop_point - self.start) * patt_width
			line(x, 8, x, self.height - 3, 57)
		end
		-- Borders
		clip()
		line()
		line(0, self.height - 3, 58)
		line(0, 2, 58)
		line(2, 0, 58)
		line(self.width - 3, 0, 58)
		line(self.width - 1, 2, 58)
		line(self.width - 1, self.height - 3, 57)
		line(self.width - 3, self.height - 1, 57)
		line(2, self.height - 1, 57)
		line(1, self.height - 2, 57)
	end
	
	function el:hover(msg)
		local nb_cols = (self.width - 2) // patt_width
		local idx = self.start + (msg.mx - 1) // patt_width
		local local_x = msg.mx % patt_width
		if msg.my > 11 then
			self.cursor = 1 --"grab"
		else
			self.cursor = "pointer"
		end
	end
	
	function el:click(msg)
		local nb_cols = (self.width - 2) // patt_width
		local pattern = self.start + (msg.mx - 1) // patt_width
		if msg.my > 11 and (msg.mb == 1 or msg.mb == 2) then
			app.pattern = mid(pattern, 0, sfx.num_patterns() - 1)
		end
	end
	
	function el:drag(msg)
		if not (msg.my0 > 11) then return end
		self.cursor = "grab"
		local nb_cols = (self.width - 2) // patt_width
		local idx0 = self.start + msg.mx0 // patt_width
		local idx = self.start + (msg.mx + patt_width // 2) // patt_width
		if msg.mx < msg.mx0 - 6 or msg.mx > msg.mx0 + 6 then
			self.drop_point = idx
			self.dragged_pattern = idx0
			self.drag_duplicate = msg.mb == 2
		else
			self.drop_point = nil
			self.dragged_pattern = nil
			self.drag_duplicate = nil
		end
	end
	
	function el:release(msg)
		local num_patterns = sfx.num_patterns()
		if self.drop_point and self.drop_point >= 0 and self.drop_point < num_patterns then
			undo.checkpoint()
			local ud = sfx.copy_pattern(self.dragged_pattern)
			if self.drag_duplicate then
				sfx.insert_pattern(self.drop_point)
				sfx.paste_pattern(self.drop_point, ud)
				app.pattern = self.drop_point
			else
				sfx.remove_pattern(self.dragged_pattern)
				if self.drop_point > self.dragged_pattern then
					app.pattern = self.drop_point - 1
				else
					app.pattern = self.drop_point
				end
				sfx.insert_pattern(app.pattern)
				sfx.paste_pattern(app.pattern, ud)
			end
		end
		self.cursor = 1
		self.drop_point = nil
		self.dragged_pattern = nil
		self.drag_duplicate = nil
	end
	
	function el:tap(msg)
		if not (msg.my > 11) then
			local pattern = self.start + (msg.mx - 1) // patt_width
			if (msg.mx - 1) % patt_width <= patt_width // 3 then
				undo.checkpoint()
				local prev = sfx.pattern_loop_start(pattern)
				sfx.set_pattern_loop_start(pattern, not prev)
			elseif (msg.mx - 1) % patt_width <= 2 * (patt_width // 3) then
				undo.checkpoint()
				local prev = sfx.pattern_loop_stop(pattern)
				sfx.set_pattern_loop_stop(pattern, not prev)
			else
				undo.checkpoint()
				local prev = sfx.pattern_loop_end(pattern)
				sfx.set_pattern_loop_end(pattern, not prev)
			end
		end
	end
	
	function el:mousewheel(msg)
		local nb_cols = (self.width - 2) // patt_width
		self.start -= msg.wheel_y
		self.start = mid(self.start, 0, sfx.num_patterns() - nb_cols)
	end
	return el
end


local function generate_pattern_tool(parent)
	parent:attach(create_pattern_list {
		x = 3, y = 5,
		width = parent.width - 6, height = parent.height - 18,
	})
end


-------------------------------------------------------------------------------
-- Track Tool
-------------------------------------------------------------------------------


local function attach_track_strip(parent, el)
	el.width = app.column_width
	el.height = parent.height - 9
	parent:attach(el)
	
	local nb_rows = (el.height - 13) // 8
	el.track_list = ui.create_list {
		x = 3, y = 8,
		width = app.column_width - 6, height = el.height - 15,
		row_height = 8,
		nb_columns = 3,
--		start = sfx.pattern_track(app.pattern, el.channel) - nb_rows // 2,
--		overshoot = nb_rows // 2,
		channel = el.channel,
		get_active = function(self) return sfx.pattern_track(app.pattern, self.channel) end,
		set_active =
			function(self, idx)
				undo.checkpoint()
				if sfx.channel_is_muted(app.pattern, self.channel) then
					sfx.mute_channel(app.pattern, self.channel, false)
				end
				app.set_pattern_track(app.pattern, self.channel, idx)
			end,
		get_start = function(self) return app.toolrack_track_scrollstart end,
		set_start = function(self, start) app.toolrack_track_scrollstart = start end,
--		get_start = function(self) return self.start end,
--		set_start = function(self, start) self.start = start end,
		get_max = function(self) return sfx.num_tracks() - 1 end,
		disabled = function(self) return sfx.channel_is_muted(app.pattern, self.channel) end,
		draw_item =
			function(self, track, x, y, w, h)
				local muted = sfx.channel_is_muted(app.pattern, self.channel)
				local active = sfx.pattern_track(app.pattern, self.channel)
				local size = sfx.track_size(track)
				if track == active and not muted then
					rrectfill(x, y, w, h + 1, 0, 4)
				--[[
				elseif not muted then
					for c = 0, 7 do
						if sfx.pattern_track(app.pattern, c) == track then
							rrectfill(x, y, w, h, 0, 60)
							break
						end
					end
				--]]
				end
				local fg = size == 0 and 60 or (trach == active and 7 or 57)
				print(string.format("%03d", track), x + 3, y + 2, fg)
			end
		
	}
	el:attach(el.track_list)
	
	el.track_list:attach(ui.create_toggle {
		channel = el.channel,
		off_spr = get_spr(20), on_spr = get_spr(15),
		x = el.track_list.width - 13, y = el.track_list.height - 13,
		horiz_padding = 0,
		has_pointer =
			function(self, x, y)
				return x > 5 and y > 5
			end,
		get =
			function(self)
				return not sfx.channel_is_muted(app.pattern, self.channel)
			end,
		set =
			function(self)
				undo.checkpoint()
				local muted = sfx.channel_is_muted(app.pattern, self.channel)
				app.mute_channel(app.pattern, self.channel, not muted)
			end,
	})

	return el
end


local function generate_track_tool(parent)
	for channel = 0, 7 do
		attach_track_strip(parent, {
			channel = channel,
			x = channel * app.column_width, y = 0,
		})
	end
end


-------------------------------------------------------------------------------
-- Loop Tool
-------------------------------------------------------------------------------


local function attach_loop_strip(parent, el)
	el.width = app.column_width
	el.height = 26
	parent:attach(el)
	
	local ox = 4
	local oy = 6

	el.label_loop0 = ui.create_label {
		visible = function(self) return not sfx.channel_is_muted(app.pattern, el.channel) end,
		x = ox, y = oy + 0, fg = 35,
		label = "length\-f:  ",
	}
	el:attach(el.label_loop0)
	el:attach(ui.create_field {
		x = ox + 34, y = oy + 0 - 1,
		width = 15, height = 7,
		visible = function(self) return not sfx.channel_is_muted(app.pattern, el.channel) end,
		get = function(self) return sfx.track_loop0(sfx.pattern_track(app.pattern, el.channel)) end,
		set =
			function(self, value)
				value = mid(value, 0, sfx.track_size(sfx.pattern_track(app.pattern, el.channel)))
				sfx.set_track_loop0(sfx.pattern_track(app.pattern, el.channel), value)
			end,
	})
	
	el:attach(ui.create_label {
		visible = function(self) return not sfx.channel_is_muted(app.pattern, el.channel) end,
		x = ox, y = oy + 10, fg = 35,
		label = "loop \-fend\-f:",
	})
	el:attach(ui.create_field {
		x = ox + 34, y = oy + 10 - 1,
		width = 15, height = 7,
		visible = function(self) return not sfx.channel_is_muted(app.pattern, el.channel) end,
		get = function(self) return sfx.track_loop1(sfx.pattern_track(app.pattern, el.channel)) end,
		set =
			function(self, value)
				value = mid(value, 0, sfx.track_size(sfx.pattern_track(app.pattern, el.channel)))
				sfx.set_track_loop1(sfx.pattern_track(app.pattern, el.channel), value)
				if value > sfx.track_loop0(sfx.pattern_track(app.pattern, el.channel)) then
					self.parent.label_loop0.label = "l. \-fstart\-f:"
				else
					self.parent.label_loop0.label = "length\-f:"
				end
			end,
	})
	
	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 47)
		local track <const> = sfx.pattern_track(app.pattern, self.channel)
		local is_muted <const> = sfx.channel_is_muted(app.pattern, self.channel)
		-- Dividers
		local xh <const> = app.column_width - 1
		local yh <const> = self.height - 1
		if self.channel ~= 0 then
			line(0, 1, 0, yh - 1, 57)
		end
		if self.channel ~= 7 then
			line(xh, 1, xh, yh - 1, 58)
		end
	end

	return el
end


local function generate_loop_tool(parent)
	for channel = 0, 7 do
		attach_loop_strip(parent, {
			channel = channel,
			x = channel * app.column_width, y = 1,
		})
	end
	
	parent:attach(ui.create_horiz_divider {
		x = 3, y = parent.height - 26,
		width = parent.width - 6,
	})
	
	local ox = 4
	local oy = parent.height - 19

	parent:attach(ui.create_label {
		x = ox + 0, y = oy + 0, fg = 56,
		label = "pattern flags\-f:",
	})
	parent:attach(ui.create_toggle {
		off_spr = get_spr(40), on_spr = get_spr(45),
		x = ox + 60, y = oy - 3,
		width = 15, height = 7,
		get = function(self) return sfx.pattern_loop_start(app.pattern) end,
		set = 
			function(self, value)
				local v = sfx.pattern_loop_start(app.pattern)
				sfx.set_pattern_loop_start(app.pattern, not v)
			end,
	})
	parent:attach(ui.create_toggle {
		off_spr = get_spr(42), on_spr = get_spr(47),
		x = ox + 74, y = oy - 3,
		width = 15, height = 7,
		get = function(self) return sfx.pattern_loop_stop(app.pattern) end,
		set = 
			function(self, value)
				local v = sfx.pattern_loop_stop(app.pattern)
				sfx.set_pattern_loop_stop(app.pattern, not v)
			end,
	})
	parent:attach(ui.create_toggle {
		off_spr = get_spr(41), on_spr = get_spr(46),
		x = ox + 88, y = oy - 3,
		width = 15, height = 7,
		get = function(self) return sfx.pattern_loop_end(app.pattern) end,
		set = 
			function(self, value)
				local v = sfx.pattern_loop_end(app.pattern)
				sfx.set_pattern_loop_end(app.pattern, not v)
			end,
	})
end


-------------------------------------------------------------------------------
-- Speed Tool
-------------------------------------------------------------------------------


local function attach_speed_strip(parent, el)
	el.width = app.column_width
	el.height = 26
	parent:attach(el)
	
	local ox = 4
	local oy = 6
	
	el:attach(ui.create_label {
		channel = el.channel, fg = 36,
		x = ox, y = oy + 0,
		label = "speed\-f:",
		visible = function(self) return not sfx.channel_is_muted(app.pattern, el.channel) end,
	})
	el:attach(ui.create_field {
		x = ox + 34, y = oy + 0 - 1,
		width = 15, height = 7,
		visible = function(self) return not sfx.channel_is_muted(app.pattern, el.channel) end,
		get = function(self) return sfx.track_speed(sfx.pattern_track(app.pattern, el.channel)) end,
		set = 
			function(self, value)
				value = mid(value, 0, 255)
				sfx.set_track_speed(sfx.pattern_track(app.pattern, el.channel), value)
			end,
	})

	el:attach(ui.create_label {
		channel = el.channel, fg = 56,
		x = ox, y = oy + 10,
		label =
			function(self)
				local speed = sfx.track_speed(sfx.pattern_track(app.pattern, el.channel))
				if speed == 0 then
					speed = sfx.default_speed() -- TODO: this seem to be `16` hardcoded instead?
				end
				local tempo = 7168 / (speed * app.beat_length)
				local fmt = (tempo % 1 == 0) and "tempo\-f:   %3.0f" or "tempo: %5.01f"
				return string.format(fmt, tempo)
			end,
		visible = function(self) return not sfx.channel_is_muted(app.pattern, el.channel) end,
	})

	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 47)
		local track <const> = sfx.pattern_track(app.pattern, self.channel)
		local is_muted <const> = sfx.channel_is_muted(app.pattern, self.channel)
		-- Dividers
		local xh <const> = app.column_width - 1
		local yh <const> = self.height - 1
		if self.channel ~= 0 then
			line(0, 1, 0, yh - 1, 57)
		end
		if self.channel ~= 7 then
			line(xh, 1, xh, yh - 1, 58)
		end
	end

	return el
end


local function generate_speed_tool(parent)
	for channel = 0, 7 do
		attach_speed_strip(parent, {
			channel = channel,
			x = channel * app.column_width, y = 1,
		})
	end
	
	parent:attach(ui.create_horiz_divider {
		x = 3, y = parent.height - 26,
		width = parent.width - 6,
	})
	
	local ox = 4
	local oy = parent.height - 19

	parent:attach(ui.create_label {
		x = ox + 0, y = oy + 0, fg = 35,
		label = "beat length\-f:",
	})
	parent:attach(ui.create_field {
		x = ox + 0 + 49, y = oy + 0 - 1,
		width = 15, height = 7,
		get = function(self) return app.beat_length end,
		set = 
			function(self, value)
				local v = mid(0, flr(value), 64)
				app.beat_length = value
			end,
	})
		
	parent:attach(ui.create_label {
		x = ox + 80, y = oy + 0, fg = 35,
		label = "bar length\-f:",
	})
	parent:attach(ui.create_field {
		x = ox + 80 + 45, y = oy + 0 - 1,
		width = 15, height = 7,
		get = function(self) return app.bar_length end,
		set =
			function(self, value)
				local v = mid(0, flr(value), 64)
				app.bar_length = value
			end,
	})
	
	-- Default speed and default length doesn't seem to be implemented
	-- by Picotron.
	--[[
	local ox = 10
	
	parent:attach(ui.create_label {
		x = ox + 356, y = oy + 0, fg = 56,
		label = "default speed:",
	})
	parent:attach(ui.create_field {
		x = ox + 356 + 60, y = oy + 0 - 1,
		width = 15, height = 7,
		get = function(self) return sfx.default_speed() end,
		set = 
			function(self, value)
				local v = mid(0, flr(value), 255)
				sfx.set_default_speed(v)
			end,
	})
	--]]
end


-------------------------------------------------------------------------------
-- Select Tools
-------------------------------------------------------------------------------


local function generate_select_tool(parent)
	parent:attach(create_nyi {
		name = "selection",
		x = 0, y = 0,
		width = parent.width,
		height = parent.height - 9,
	})
end


-------------------------------------------------------------------------------
-- Note Tool
-------------------------------------------------------------------------------


local function generate_note_tool(parent)
	parent:attach(create_nyi {
		name = "note",
		x = 0, y = 0,
		width = parent.width,
		height = parent.height - 9,
	})
end


-------------------------------------------------------------------------------
-- Instrument Tool
-------------------------------------------------------------------------------


local function generate_instrument_tool(parent)
	parent:attach(create_nyi {
		name = "instrument",
		x = 0, y = 0,
		width = parent.width,
		height = parent.height - 9,
	})
end


-------------------------------------------------------------------------------
-- Volume Tool
-------------------------------------------------------------------------------


local function generate_volume_tool(parent)
	parent:attach(create_nyi {
		name = "volume",
		x = 0, y = 0,
		width = parent.width,
		height = parent.height - 9,
	})
end


-------------------------------------------------------------------------------
-- Effect Tool
-------------------------------------------------------------------------------


local function generate_effect_tool(parent)
	parent:attach(create_nyi {
		name = "effect",
		x = 0, y = 0,
		width = parent.width,
		height = parent.height - 9,
	})
end


-------------------------------------------------------------------------------
-- Chord Tools
-------------------------------------------------------------------------------


local function generate_chord_tool(parent)
	parent:attach(create_nyi {
		name = "chord",
		x = 0, y = 0,
		width = parent.width,
		height = parent.height - 9,
	})
end


-------------------------------------------------------------------------------
-- Mixer Tools
-------------------------------------------------------------------------------


local height_oscillo = 39

		
local sample_scale <const> = 26175.0

local function create_channel_oscillo(el)
	el.last_lpeak = 0
	el.last_rpeak = 0
	ui.head():new(el)
	function el:draw()
		local delta_channel = 0
		if not sfx.music_is_playing() then
			delta_channel = 8
		end
		--
		local n = stat(400 + self.channel + delta_channel, 19, 0x90000)
		local lpeak, rpeak = 0.0, 0.0
		local last_sgn = sgn(peek2(0x90000))
		local zero_crossing = 0
		for i = 0, n, 4 do
			local sleft = peek2(0x90000 + i)
			if zero_crossing == 0 then
				if last_sgn > 0 then
					last_sgn = sgn(sleft)
				elseif sgn(sleft) > last_sgn then
					zero_crossing = i
				end
			end
			sleft = abs(sleft)
			lpeak = max(lpeak, sleft)
			local sright = abs(peek2(0x90002 + i))
			rpeak = max(rpeak, sright)
			smax = max(smax, lpeak)
		end
		-- Convert to decibels
		lpeak = 20 * math.log(lpeak / sample_scale, 10)
		rpeak = 20 * math.log(rpeak / sample_scale, 10)
		-- Scale so that -40db = 0 and 0db = 1
		lpeak = 1 + lpeak / app.min_db
		lpeak = mid(lpeak, 0, 1)
		lpeak = max(lpeak, self.last_lpeak - app.meter_speed)
		self.last_lpeak = lpeak
		rpeak = 1 + rpeak / app.min_db
		rpeak = mid(rpeak, 0, 1)
		rpeak = max(rpeak, self.last_rpeak - app.meter_speed)
		self.last_rpeak = rpeak
		local lx = lpeak * (app.column_width - 9)
		local rx = rpeak * (app.column_width - 9)
		rrectfill(1, 1, app.column_width - 6, 9, 0, 59)
		app.draw_borders(1, 1, app.column_width - 6, 9, 0, 59)
		app.draw_horiz_meter(2, 2, app.column_width - 8, 3, lpeak)
		app.draw_horiz_meter(2, 6, app.column_width - 8, 3, rpeak)
		if app.channel_oscillos_visible then
			-- Oscilloscope
			ui_visual.draw_stereo_signal(1, 16, self.width - 2, height_oscillo, 
				0x90000, n, zero_crossing, 4)
			--[[
			rrectfill(1, oy, self.width - 2, height_oscillo, 0, 59)
			app.draw_borders(1, oy, self.width - 2, height_oscillo)
			local ymid = oy + height_oscillo // 2
			local last_y_left, last_y_right = ymid, ymid
			for x = 0, self.width - 3 do
				local y_left = flr(0.5 + ymid - peek2(0x90000 + zero_crossing + x * 16) / 1638)
				line(x, last_y_left, x + 1, y_left, fg_left)
				y_right = flr(0.5 + ymid - peek2(0x90002 + zero_crossing + x * 16) / 1638)
				local same_spot = (y_right == y_left)
				line(x, last_y_right, x + 1, y_right, same_spot and fg_both or fg_right)
				last_y_left, last_y_right = y_left, y_right
			end
			--]]
		end
	end
	return el
end


local function attach_mixer_strip(parent, el)
	el.width = app.column_width
	el.height = parent.height
	parent:attach(el)
	
	el:attach(create_channel_oscillo {
		channel = el.channel,
		x = 2, y = 5,
		width = el.width - 4, height = el.height - 13,
	})
	
	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 47)
		local track <const> = sfx.pattern_track(app.pattern, self.channel)
		local is_muted <const> = sfx.channel_is_muted(app.pattern, self.channel)
	end

	return el
end


local function generate_mixer_tool(parent)
	for channel = 0, 7 do
		attach_mixer_strip(parent, {
			channel = channel,
			x = channel * app.column_width, y = 0,
		})
	end
	parent:attach(ui.create_toggle {
		x = parent.width - 7, y = parent.height - 9 - 16,
		off_spr = get_spr(125), on_spr = get_spr(126),
		get = function(self) return app.channel_oscillos_visible end,
		set = function(self, v)
			app.channel_oscillos_visible = not app.channel_oscillos_visible
			app.refresh_gui = true
		end
	})
end


-------------------------------------------------------------------------------
-- Locals
-------------------------------------------------------------------------------


local toolrack_tab_width <const> = 40


local tabs = {
	[0] =
	{ name = "pattern", height = 45, generate = generate_pattern_tool }, 
--	{ name = "track", height = 110, generate = generate_track_tool }, 
	{ name = "loop", height = 45, generate = generate_loop_tool }, 
	{ name = "speed", height = 45, generate = generate_speed_tool }, 
	{ name = "select", height = 45, generate = generate_select_tool }, 
	{ name = "note", height = 45, generate = generate_note_tool }, 
	{ name = "inst", height = 45, generate = generate_instrument_tool }, 
	{ name = "volume", height = 45, generate = generate_volume_tool }, 
	{ name = "effect", height = 45, generate = generate_effect_tool }, 
	{ name = "chord", height = 45, generate = generate_chord_tool }, 
	{ name = "level", height = 66, generate = generate_mixer_tool }, 
}


-------------------------------------------------------------------------------
-- Tool-Rack
-------------------------------------------------------------------------------


function toolrack.attach_toolrack(parent, el)
	el.height = 8
	if app.toolrack_tab then
		if app.toolrack_tab == 9 then
			el.height += app.channel_oscillos_visible and 66 or 21
		else
			el.height += tabs[app.toolrack_tab].height
		end
	end
	el.y -= el.height
	parent:attach(el)
	if app.toolrack_tab then
		local generate = tabs[app.toolrack_tab].generate
		generate(el)
	end
	
	function el:draw()
		local right <const> = self.width - 1
		local bottom <const> = self.height - 1
		local tabwidth <const> = toolrack_tab_width
		-- Content
		if app.toolrack_tab then
			rrectfill(0, 0, self.width, self.height - 9, 0, 6)
			line(0, 0, right, 0, 57)
			line(0, 0, 0, bottom - 9, 57)
			line(right, 0, right, bottom - 9, 58)
			line(0, bottom - 8, right, bottom - 8, 58)
		end
		-- Tabs
		rectfill(0, bottom - 7, right, bottom, 56)
		for t = 0, #tabs do
			local x = t * tabwidth
			local dy = 0
			local fg = 55
			if t == app.toolrack_tab then
				dy = -2
				fg = 57
				spr(16, x - 4, bottom - 8)
				if t == 0 then
					line(x, bottom - 8, x, bottom, 57)
					line(x + 1, bottom - 8, x + 1, bottom - 2, 6)
				end
			end
			ui.print_centered(tabs[t].name, x + tabwidth // 2, bottom - 5 + dy, fg)
		end
		local step = selection.min_step()
		if sfx.music_is_playing() and app.follow_playhead then
			print("row\-f:", self.width - 26, bottom - 5, 55)
			print(string.format("%02d", sfx.playing_row()), self.width - 10, bottom - 5, 55)
		elseif step then
			print("row\-f:", self.width - 26, bottom - 5, 55)
			print(string.format("%02d", step), self.width - 10, bottom - 5, 55)
		end
	end
	
	
	function el:hover(msg)
		if msg.my > self.height - 1 - 8
			and msg.mx <= (#tabs + 1) * toolrack_tab_width
		then
			self.cursor = "pointer"
		else
			self.cursor = 1
		end
	end
	
	
	function el:click(msg)
		if msg.my >= self.height - 1 - 8 then
			local tab = msg.mx // toolrack_tab_width
			if tab == app.toolrack_tab then
				app.toolrack_tab = nil
			elseif tab <= #tabs then
				app.toolrack_tab = tab
			end
			app.refresh_gui = true
		end
	end
	
	
	function el:mousewheel(msg)
		return true
	end
	
	
	return el
end


return toolrack
:: src/ui/tracker.lua
--[[pod_format="raw",created="2026-01-26 12:39:34",modified="2026-02-19 21:34:53",revision=24272]]
local app = require "src/app.lua"
local actions = require "src/actions.lua"
local selection = require "src/selection.lua"
local settings = require "src/settings.lua"
local sfx = require "src/sfx/sfx.lua"
local undo = require "src/undo.lua"
local ui = require "src/ui/ui.lua"
local ui_notegrid = require "src/ui/notegrid.lua"
local ui_toolrack = require "src/ui/toolrack.lua"
local ui_panel = require "src/ui/panel.lua"

local ui_tracker = {}


-------------------------------------------------------------------------------
-- Locals
-------------------------------------------------------------------------------


local instr_chooser = false


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


local function create_overlay(el)
	ui.head():new(el)
	function el:draw(msg)
		if app.is_editing then
			rrect(0, 0, self.width, self.height, 0, 37)
		end
	end
	function el:click(msg) return false end
	function el:drag(msg) return false end
	function el:tap(msg) return false end
	return el
end


-------------------------------------------------------------------------------
-- Tracker Widget
-------------------------------------------------------------------------------


function ui_tracker.attach(parent, el)
	parent:attach(el)
	el:set_keyboard_focus(true)
	
	el.headers = {}
	el.notegrids = {}
	el.preview_timer = 0

	-- TODO: Doesn't seem to work?
	--sfx.set_pattern_length(app.pattern, 8)
	--notify("pattern length: " .. pod(sfx.pattern_length(app.pattern)))
		
	local y = app.track_header_height
	local h = el.height - app.track_header_height
	el.toolrack = ui_toolrack.attach_toolrack(el, {
		x = app.panel_width,
		y = el.height, -- set in `attach_toolrack`
		width = el.width - app.panel_width,
		height = 0, -- set in `attach_toolrack`
	})
	h -= el.toolrack.height
	for channel = 0, 7 do
		el.headers[channel] = ui_notegrid.attach_header(el, {
			x = app.panel_width + 1 + channel * app.column_width,
			y = 0,
			channel = channel,
		})
		el.notegrids[channel] = ui_notegrid.attach(el, {
			x = app.panel_width + 1 + channel * app.column_width, y = y,
			width = app.column_width, height = h,
			channel = channel,
		})
	end
	ui_notegrid.attach_scrollbar(el, {
		x = el.width - 4, y = y + 1,
		width = 4, height = h - 2,
	})
	
	ui_notegrid.close_channel_dialog()
	
	ui_panel.attach_view_selector(el, { x = 0, y = 4 })
	el:attach(ui.create_horiz_divider { x = 3, y = 41, width = 13 })
	el.octave_selector = ui_panel.attach_octave_selector(el, { x = 0, y = 45 })
	el.instrument_selector = ui_panel.attach_instrument_selector(el, { x = 0, y = 57 })
	el.volume_selector = ui_panel.attach_volume_selector(el, { x = 0, y = 75 })
	
	el.step_selector = ui_panel.attach_step_selector(el, { x = 0, y = 93 })
	el:attach(ui.create_horiz_divider { x = 3, y = 111, width = 13 })
	ui_panel.attach_pattern_selector(el, { x = 0, y = 116 })
	ui_panel.attach_pattern_arrows(el, { x = 0, y = 132 })

	ui_panel.attach_meters(el, { x = 3, y = el.height - 85 })
	ui_panel.attach_edit_button(el, { x = 0, y = el.height - 28 })
	ui_panel.attach_play_button(el, { x = 0, y = el.height - 14 })

	if is_loaded_cart then		
		ui_panel.attach_piano_toggle(el, { x = 1, y = el.height - 100 })
	end

	
	------------------------------------------------------------------------------
	-- Draw
	------------------------------------------------------------------------------

	
	function el:draw()
		local w <const> = self.width
		local h <const> = self.height
		cls(32)
		-- panel
		rrectfill(0, 0, app.panel_width, h, 0, 6)
		line(0, 0, app.panel_width - 1, 0, 57)
		line(0, 0, 0, h - 1, 57)
		line(app.panel_width - 1, 0, app.panel_width - 1, h - 1, 58)
		line(0, h - 29, app.panel_width - 1, h - 29, 58)
		-- dividers
--		line(3, 41, app.panel_width - 4, 41, 58)
--		line(3, 42, app.panel_width - 4, 42, 57)
--		line(3, 111, app.panel_width - 4, 111, 58)
--		line(3, 112, app.panel_width - 4, 112, 57)
--		line(3, el.height - 91, app.panel_width - 4, el.height - 91, 58)
--		line(3, el.height - 90, app.panel_width - 4, el.height - 90, 57)
		-- channel headers
		rrectfill(app.panel_width, 0, self.width, app.track_header_height, 0, 56)
	end	

		
	------------------------------------------------------------------------------
	-- Update
	------------------------------------------------------------------------------
	
	
	function el:update()
		-- State queryied each frame
		local music_is_playing = sfx.music_is_playing()
		local pitch, pitch_just_pressed = app.pitched_key()
		local has_selection = selection.has_selection()
		local min_step = selection.min_step()
		if has_selection ~= app.capture_escapes then
			app.capture_escapes = has_selection
			window { capture_escapes = app.capture_escapes }
		end
		-- Stop playing previewed notes
		if (not pitch) and self.preview_timer == 0 then
			for channel = 8, 15 do
				note(0xff, 0xff, 0xff, 0x00, 0x00, channel)
			end
		end
		-- Preview
		if self.preview_timer > 0 then
			self.preview_timer -= 1
		end
		-- Handle auto-scroll while playing
		self:handle_playing_scroll()
		-- Various hacks related to keyboard focus
		if (not ui.head():get_keyboard_focus_element())
			and not (music_is_playing and app.follow_playhead)
		then
			readtext(true)
			self:clear_edit()
			self:set_keyboard_focus(true)
		end
		if keyp("space") then
			if key("shift") then
				actions.follow_play_or_pause(self)
			else
				actions.play_or_pause(self)
			end
		end
		
		if not self:has_keyboard_focus() then
			return
		end
		if app.was_in_text_field and not keyp() then
			return
		end
		app.was_in_text_field = false
		-- Keys
		selection.sanitize()
		
		-----------------------------------------------------------------------------
		-- Shift + Ctrl + Alt
		-----------------------------------------------------------------------------
		if key("shift") and key("ctrl") and key("alt") then
			-- currently unused
			
		-----------------------------------------------------------------------------
		-- Ctrl + Alt
		-----------------------------------------------------------------------------
		elseif key("ctrl") and key("alt") then
			-- currently unused
			
		-----------------------------------------------------------------------------
		-- Shift + Alt
		-----------------------------------------------------------------------------
		elseif key("shift") and key("alt") then
			
		-----------------------------------------------------------------------------
		-- Shift + Ctrl
		-----------------------------------------------------------------------------
		elseif key("shift") and key("ctrl") then
			-- Selection
			if keyp("down") then actions.select_next_beat(self) end
			if keyp("up") then actions.shrink_selection_rows(self) end
			if keyp("right") then actions.select_next_channel(self) end
			if keyp("left") then actions.shrink_selection_channels(self) end
			-- Edition
			if keyp("e") then actions.increase_part_slightly(self) end
			if keyp("d") then actions.decrease_part_slightly(self) end
			if keyp("x") then actions.cut_and_remove_rows(self) end
			
		-----------------------------------------------------------------------------
		-- Alt
		-----------------------------------------------------------------------------
		elseif key("alt") then
			-- TODO
			if keyp("o") then
				readtext(true)
				self.octave_selector.str = ""
				self.octave_selector:set_keyboard_focus(true)
				return
			end
			if keyp("i") then
				readtext(true)
				self.instrument_selector.str = ""
				self.instrument_selector:set_keyboard_focus(true)
				return
			end
			if key("v") then
				readtext(true)
				self.volume_selector.str = ""
				self.volume_selector:set_keyboard_focus(true)
				return
			end
			if keyp("j") then
				readtext(true)
				self.step_selector.str = ""
				self.step_selector:set_keyboard_focus(true)
				return
			end
			
		-----------------------------------------------------------------------------
		-- Ctrl
		-----------------------------------------------------------------------------
		elseif key("ctrl") then
			-- Movement
			if keyp("down") then actions.move_to_next_beat(self) end
			if keyp("up") then actions.move_to_previous_beat(self) end
			if keyp("right") then actions.move_to_next_channel(self) end
			if keyp("left") then actions.move_to_previous_channel(self) end
			-- Edition
			if keyp("delete") then actions.clear_rows(self) end
			if keyp("'") then actions.clear_rows_and_jump_down(self) end
			if keyp("backspace") then actions.jump_up_and_clear_rows(self) end
			if keyp("enter") then actions.preview_row_and_jump_back(self) end
			if keyp("e") then actions.increase_part(self) end
			if keyp("d") then actions.decrease_part(self) end
			if keyp("c") then actions.copy(self) end
			if keyp("x") then actions.cut(self) end
			if keyp("v") then actions.paste(self) end
			-- TODO: create actions for these
			if keyp("t") then
				-- TODO: focus track selector
			end
			if keyp(",") then
				app.row_height = mid(app.row_height - 1, 6, 9)
			end
			if keyp(".") then
				app.row_height = mid(app.row_height + 1, 6, 9)
			end
			
		-----------------------------------------------------------------------------
		-- Shift
		-----------------------------------------------------------------------------
		elseif key("shift") then
			-- Context
			-- Selection
			if keyp("down") then actions.select_next_row(self) end
			if keyp("up") then actions.shrink_selection_rows(self) end
			if keyp("right") then actions.select_next_part(self) end
			if keyp("left") then actions.shrink_selection_parts(self) end
			if keyp("pagedown") then actions.select_next_bar(self) end
			if keyp("pageup") then actions.shrink_selection_rows(self) end
			-- Edition
			if keyp("delete") then actions.remove_rows(self) end
			if keyp("backspace") then actions.jump_up_and_remove_rows(self) end
			if keyp("enter") then actions.insert_rows(self) end
			
		-----------------------------------------------------------------------------
		-- No Modifiers
		-----------------------------------------------------------------------------
		else
			-- Context
			if keyp("tab") then actions.toggle_record_mode(self) end
			if keyp("insert") then actions.toggle_jump_step(self) end
			-- Movement
			if keyp("down") then actions.move_down(self) end
			if keyp("up") then actions.move_up(self) end
			if keyp("pagedown") then actions.move_to_next_bar(self) end
			if keyp("pageup") then actions.move_to_previous_bar(self) end
			if keyp("home") then actions.home(self) end
			if keyp("end") then actions.fin(self) end
			if keyp("right") then actions.move_to_next_part(self) end
			if keyp("left") then actions.move_to_previous_part(self) end
			-- Edition
			if keyp("=") then actions.repeat_last_entry(self) end
			if keyp("delete") then actions.clear_parts(self) end
			if keyp("'") then actions.clear_parts_and_jump_down(self) end
			if keyp("backspace") then actions.jump_up_and_clear_parts(self) end
			if keyp("enter") then actions.preview_row_and_jump_down(self) end
			-- Hardwired
			if keyp("escape") then
				if has_selection then
					selection.clear()
					window { capture_escapes = false }
				elseif app.toolrack_tab then
					app.toolrack_tab = nil
					-- TODO: how to handle `capture_escapes`?
				end
			end
		end
			
		-----------------------------------------------------------------------------
		-- Play Notes
		-----------------------------------------------------------------------------
		if pitch and pitch_just_pressed and not (app.is_editing and music_is_playing) then
			if selection.has_part(selection.note) or (not app.is_editing) then
				local track = sfx.pattern_track(app.pattern, selection.min_channel())
				local step = selection.min_step()
				local existing_note = sfx.track_pitch(track, step)
				local inst
				if existing_note == 0xff and not key("shift") then
					inst = self:instrument_to_use(track, step)
				else
					inst = self:instrument_to_preview(track, step)
				end
				if inst == 0xff then
					inst = self:current_instrument(track, step)
				end
				local vol
				if existing_note == 0xff and not key("shift") then
					vol = self:volume_to_use(track, step)
				else
					vol = self:volume_to_preview(track, step)
				end
				if vol == 0xff then
					vol = self:current_volume(track, step)
				end
				note(pitch, inst, vol,
					0x00, 0x00,
					8, -- channel 8 so it can play with pattern
					false -- don't force retrigger
				)
			end
		elseif pitch then
			-- nothing
		elseif preview == 0 then
			note(0xff, 0xff, 0xff, 0x00, 0x00, 8)
		end
			
		-----------------------------------------------------------------------------
		-- Enter Notes
		-----------------------------------------------------------------------------
		if app.is_editing then
			if selection.has_part(selection.note) then
				if key("alt") then
					self:edit_octave(pitch, pitch_just_pressed)
				else
					self:edit_note(pitch, pitch_just_pressed, key("shift"))
				end
			elseif selection.parts() == selection.instrument then
				if key("shift") then
					self:edit_fast_instrument()
				else
					self:edit_instrument()
				end
			elseif selection.parts() == selection.volume then
				if key("shift") then
					self:edit_fast_volume()
				else
					self:edit_volume()
				end
			elseif selection.parts() == selection.fx then
				self:edit_fx()
			end
		end
	end
	
	function el:click(msg)
		self:set_keyboard_focus(true)
	end
	
	function el:mousewheel(msg)
		if msg.mx > app.panel_width then
			self:scroll_channels(msg.wheel_y)
		end
	end
	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
	
	function el:handle_playing_scroll()
		if not app.window_focused then
			return
		end
		if sfx.music_is_playing() and app.follow_playhead then
			self:set_keyboard_focus(false)
			if not self.was_playing then
				self:save_position()
			end
			local pattern = sfx.playing_pattern()
			local step = sfx.playing_row()
			if pattern and pattern >= 0 and step and step >= 0 then
				app.pattern = mid(sfx.playing_pattern(), 0, sfx.num_patterns() - 1)
				self:show_step(step, "centered")
			end
			self.was_playing = true
		else
			if self.was_playing then
				self:restore_position()
				app.follow_playhead = false
			end
			self.was_playing = false
		end
	end
	
	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
	
	
	function el:note_to_preview(track, step)
		local pitch = sfx.track_pitch(track, step)
		if pitch == 0xff or (not selection.has_part(selection.note)) then
			return 0xff
		end
		return pitch
	end
	
	
	function el:instrument_to_preview(track, step)
		local instr = sfx.track_instrument(track, step)
		local s = step
		while instr == 0xff and s > 1 do
			s -= 1
			instr = sfx.track_instrument(track, s)
		end
		return instr
	end
	
	
	function el:volume_to_preview(track, step)
		local volume = sfx.track_volume(track, step)
		local s = step
		while volume == 0xff and s > 1 do
			s -= 1
			volume = sfx.track_volume(track, s)
		end
		return volume
	end
	
	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
	
	
	function el:instrument_to_use(track, step)
		local instr = sfx.track_instrument(track, step)
		local last_instr = self:current_instrument(track, step)
		if instr == 0xff
			or (selection.has_part(selection.note)
				and selection.has_part(selection.instrument) )
		then
			instr = app.instrument
		end
		return instr
	end
	
	
	function el:volume_to_use(track, step)
		local vol = sfx.track_volume(track, step)
		if vol == 0xff
			or (selection.has_part(selection.note)
				and selection.has_part(selection.volume) )
		then
			vol = app.base_volume
		end
		return vol
	end
	
	
	function el:fx_to_use(track, step)
		local fx = sfx.track_fx(track, step)
		local fx_params = sfx.track_fx_params(track, step)
		if (selection.has_part(selection.note)
				and selection.has_part(selection.fx) )
		then
			fx = 0x00
			fx_params = 0x00
		end
		return fx, fx_params
	end
		
	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
	
	
	function el:clear_edit()
		readtext(true)
		self.str_instrument = nil
		self.str_volume = nil
		self.str_fx = nil
	end
		
	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

	
	function el:edit_note(pitch, pitch_just_pressed, only_note)
		if key("ctrl") or key("alt") then return end
		if not pitch_just_pressed then return end
		undo.checkpoint()
		selection.for_each_channel_each_step(
			function(track, step)
				sfx.set_track_pitch(track, step, pitch)
				if not only_note then
					sfx.set_track_instrument(track, step, self:instrument_to_use(track, step))
					sfx.set_track_volume(track, step, self:volume_to_use(track, step))
					local fx, fx_params = self:fx_to_use(track, step)
					sfx.set_track_fx(track, step, fx)
					sfx.set_track_fx_params(track, step, fx_params)
				end
			end
		)
		selection.move_step(selection.jump_step())
		self:show_cursor()
		self.last_pitch_entered = pitch
		return nil
	end
		
	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
	
	
	function el:edit_instrument()
		if key("ctrl") or key("alt") then return end
		if not self.str_instrument then
			if peektext() then
				undo.checkpoint()
				self.str_instrument = ""
				self:show_cursor()
			else
				return
			end
		end
		
		while peektext() do
			if #self.str_instrument < 2 then
				self.str_instrument ..= readtext()
			else
				readtext()
			end
		end
		
		local val = tonumber(self.str_instrument, 16)
		self.str_instrument_is_valid = val ~= nil

		if keyp("backspace") then
			self.str_instrument = sub(self.str_instrument, 1, -2)
		
		elseif keyp("escape") then
			self.str_instrument = nil
					
		elseif keyp("enter") and (not val) then
			self.str_instrument = nil

		elseif keyp("enter") or (val and #self.str_instrument == 2) then
			readtext(true)
			self.str_instrument = nil
			app.was_in_text_field = true
			selection.for_each_channel_each_step(
				function(track, step)
					sfx.set_track_instrument(track, step, val)
				end
			)
			selection.move_step(selection.jump_step())
			self:show_cursor()
			self.last_instrument_entered = val
		end
	end
		
	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
	
	
	function el:edit_volume()
		if key("ctrl") or key("alt") then return end
		if not self.str_volume then
			if peektext() then
				undo.checkpoint()
				self.str_volume = ""
				self:show_cursor()
			else
				return
			end
		end
		
		while peektext() do
			if #self.str_volume < 2 then
				self.str_volume ..= readtext()
			else
				readtext()
			end
		end
		
		local val = tonumber(self.str_volume, 16)
		self.str_volume_is_valid = val ~= nil

		if keyp("backspace") then
			self.str_volume = sub(self.str_volume, 1, -2)
		
		elseif keyp("escape") then
			self.str_volume = nil
			
		elseif keyp("enter") and (not val) then
			self.str_volume = nil
			
		elseif keyp("enter") or (val and #self.str_volume == 2) then
			readtext(true)
			self.str_volume = nil
			selection.for_each_channel_each_step(
				function(track, step)
					sfx.set_track_volume(track, step, val)
				end
			)
			selection.move_step(selection.jump_step())
			self:show_cursor()
			self.last_volume_entered = val
		end
	end
		
	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
	
	
	function el:edit_fx()
		if key("ctrl") or key("alt") then return end
		if not self.str_fx then
			if peektext() then
				undo.checkpoint()
				self.str_fx = ""
				self:show_cursor()
			else
				return
			end
		end
		
		while peektext() do
			if #self.str_fx < 3 then
				self.str_fx ..= readtext()
			else
				readtext()
			end
		end
		
		local fx = ord(app.is_valid_fx[self.str_fx[1]])
		local str_val = self.str_fx:sub(2, -1)
		local val = tonumber(str_val, 16)
		local only_val = tonumber(self.str_fx, 16)
		self.str_fx_is_valid =
			(fx and val)
			or (fx and #str_val == 0)
			or only_val
		if fx == 0 then
			val = 0
		end

		if keyp("backspace") then
			self.str_fx = sub(self.str_fx, 1, -2)
		
		elseif keyp("escape") then
			self.str_fx = nil
			
		elseif self.str_fx == "." then
			self.str_fx = nil
			if selection.step_count() == 1 then
				selection.move_step(selection.jump_step())
				self:show_cursor()
			end
			
		elseif keyp("enter") and (not self.str_fx_is_valid) then
			self.str_fx = nil
			
		elseif keyp("enter") or (fx and val and #self.str_fx == 3) then
			readtext(true)
			selection.for_each_channel_each_step(
				function(track, step)
					if fx and (#self.str_fx == 1 or #self.str_fx == 3) then
						sfx.set_track_fx(track, step, fx)
					elseif only_val then
						val = only_val
					end
					if val then
						sfx.set_track_fx_param0(track, step, val >> 4)
						sfx.set_track_fx_param1(track, step, val & 0x0f)
					end
					if #self.str_fx == 1 or #self.str_fx == 3 then
						self.last_fx_entered = fx
					else
						-- Cover the case or digits as valid fx
						self.last_fx_entered = nil
					end
					self.last_fx_params_entered = val
				end
			)
			self.str_fx = nil
			selection.move_step(selection.jump_step())
			self:show_cursor()
		end
	end
	
	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
	
	
	function el:edit_octave()
		if key("ctrl") or key("alt") then return end
		local digit = app.decimal_digit_key()
		if digit then
			undo.checkpoint()
			selection.for_each_channel_each_step(
				function(track, step)
					local pitch = sfx.track_pitch(track, step)
					if pitch ~= 0xff then
						pitch %= 12
						pitch += digit * 12
						sfx.set_track_pitch(track, step, pitch)
					end
				end
			)
			selection.move_step(selection.jump_step())
			self:show_cursor()
		end
	end
		
	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
	
	
	function el:edit_fast_instrument()
		if key("ctrl") or key("alt") then return end
		local digit = app.hexadecimal_digit_key()
		if digit then
			undo.checkpoint()
			readtext(true)
			selection.for_each_channel_each_step(
				function(track, step)
					sfx.set_track_instrument(track, step, digit)
				end
			)
			selection.move_step(selection.jump_step())
			self:show_cursor()
		end
	end
		
	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
	
	
	function el:edit_fast_volume()
		if key("ctrl") or key("alt") then return end
		local digit = app.hexadecimal_digit_key()
		if digit then
			undo.checkpoint()
			readtext(true)
			selection.for_each_channel_each_step(
				function(track, step)
					sfx.set_track_volume(track, step, digit * 8)
				end
			)
			selection.move_step(selection.jump_step())
			self:show_cursor()
		end
	end
	
	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
	
	
	function el:current_instrument(track, step)
		for s = step, 0, -1 do
			local inst = sfx.track_instrument(track, s)
			if inst ~= 0xff then
				return inst
			end
		end
		return 0xff
	end
	
	
	function el:current_volume(track, step)
		for s = step, 0, -1 do
			local inst = sfx.track_volume(track, s)
			if inst ~= 0xff then
				return inst
			end
		end
		return 0xff
	end

	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

	
	function el:save_position()
		self.saved_pattern = app.pattern
		self.saved_start = app.starting_row
	end
	
	
	function el:restore_position()
		if self.saved_pattern then
			app.pattern = mid(self.saved_pattern, 0, sfx.num_patterns() - 1)
		end
		app.starting_row = self.saved_start
		self:show_step(app.starting_row)
	end
		
	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
	
	
	function el:show_cursor(mode)
		mode = mode or "centered"
		-- TODO: improve heuristic
		local start = app.starting_row
		local nb_rows = flr(self.notegrids[1].height // app.row_height)
		local max_step = selection.max_step()
		local min_step = selection.min_step()
		local look_ahead = settings.user.look_ahead
		local look_back = settings.user.look_back
		if look_ahead >= nb_rows then
			look_ahead = nb_rows - 1
		end
		if look_ahead + look_back >= nb_rows then
			look_back = nb_rows - look_ahead - 1
		end
		if max_step < start + look_back then
				start = max_step - look_back
		elseif min_step >= start + nb_rows - look_ahead then
			start = min_step - nb_rows + 1 + look_ahead
		end
		local size = sfx.pattern_max_size(app.pattern)
		start = mid(start, 0, size - nb_rows + 1)
		app.starting_row = start
	end
	
	
	function el:show_step(step, mode)
		local start = app.starting_row
		local nb_rows = flr(self.notegrids[1].height // app.row_height)
		if mode == "centered" then
			start = step - nb_rows // 2
		else
			if step < start + settings.user.look_back then
				start = step - settings.user.look_back
			elseif step >= start + nb_rows - settings.user.look_ahead  then
				start = step - nb_rows + 1 + settings.user.look_ahead
			end
			local size = sfx.pattern_max_size(app.pattern)
			start = mid(start, 0, size - nb_rows + 1)
		end
		app.starting_row = start
	end

	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
	
	
	function el:scroll_channels(delta)
		local start = app.starting_row - delta
		app.starting_row = start
		self:scrolling_guardrail()
	end
	
	
	function el:scrolling_guardrail(mode)
		local nb_rows = flr(self.notegrids[1].height // app.row_height)
		local max_size = sfx.pattern_max_size(app.pattern)
		local min_step, max_step
		if mode == "overshoot" then -- TODO: add settings?
			min_step = - (nb_rows // 2)
			max_step = max_size - (nb_rows // 2)
		else
			min_step = 0
			max_step = max_size - nb_rows
		end
		app.starting_row = mid(app.starting_row, min_step, max_step)
	end

	return el
end


return ui_tracker
:: src/ui/trakdial.lua
--[[pod_format="raw",created="2026-01-27 14:07:26",modified="2026-02-19 21:34:53",revision=21721]]
local app = require "src/app.lua"
local ui = require "src/ui/ui.lua"
local sfx = require "src/sfx/sfx.lua"


local ui_trakdial = {}


-------------------------------------------------------------------------------
-- Locals
-------------------------------------------------------------------------------


local function draw_dialog_window(x, y, width, height, label)
	rrectfill(x, y, width, height, 0, 6)
	local xw, yh = x + width - 2, y + height - 2
	line(x + 1, yh, x + 1, y + 1, 57)
	line(x + 2, yh, x + 2, y + 1, 57)
	line(x + 1, y + 1, xw, y + 1, 57)
	line(x + 1, y + 2, xw, y + 2, 57)
	line(xw, yh, xw, y + 1, 58)
	line(xw - 1, yh, xw - 1, y + 2, 58)
	line(x + 1, yh, xw, yh, 58)
	line(x + 2, yh - 1, xw, yh - 1, 58)
	rrect(x + 0, y + 0, width, height, 0, 0)
--	rrectfill(x + 4, y + 4, width - 8, 11, 0, 5)
--	ui.print_centered(label, x + width // 2, y + 7, 5)
end


local function create_track_selector(el)
	el.width = 80
	el.height = 13
	ui.head():new(el)
	
	function el:draw(msg)
--		rrect(0, 0, self.width, self.height, 0, 47)
		if msg.has_pointer and msg.mx < 20 then
			rrectfill(2, 2, 17, 9, 0, 57)
		end
		if msg.has_pointer and msg.mx > self.width - 20 then
			rrectfill(self.width - 2 - 17, 2, 17, 9, 0, 57)
		end
		pal(7, self.previous_clicked and 13 or 58)
		spr(43, 7, 3)
		pal(7, self.next_clicked and 13 or 58)
		spr(44, self.width - 7 - 7, 3)
		pal(7, 7)
		ui.print_centered(string.format("track %03d", self.parent:track()),
			self.width // 2, 4, 5)
	end
	
	function el:hover(msg)
		if msg.mx < 20 then
			self.cursor = "pointer"
		elseif msg.mx > self.width - 20 then
			self.cursor = "pointer"
		else
			self.cursor = 1
		end
	end
	
	function el:click(msg)
		if msg.mx < 20 then
			self.previous_clicked = true
		elseif msg.mx > self.width - 20 then
			self.next_clicked = true
		end
	end
	
	function el:tap(msg)
		local track = self.parent:track()
		if msg.mx < 20 then
			track = mid(track - 1, 0, sfx.num_tracks() - 1)
			app.set_pattern_track(app.pattern, self.parent.channel, track)
		elseif msg.mx > self.width - 20 then
			track = mid(track + 1, 0, sfx.num_tracks() - 1)
			app.set_pattern_track(app.pattern, self.parent.channel, track)
		end
	end
	
	function el:release(msg)
		self.previous_clicked = false
		self.next_clicked = false
	end
	
	return el
end


-------------------------------------------------------------------------------
-- Track Dialog
-------------------------------------------------------------------------------


function ui_trakdial.create(el)
	ui.head():new(el)

	assert(el.tracker)
	el.w_win = 4 * app.column_width - 2 * 10
	el.h_win = 170
	el.y_win = (el.height - el.h_win) // 2
	if el.side == "left" then
		el.x_win = el.x_overlay - 4 * app.column_width + 10
	elseif el.side == "right" then
		el.x_win = el.x_overlay + app.column_width + 10
	end
	
	el:attach(create_track_selector {
		x = el.x_win + el.w_win // 2 - 40,
		y = el.y_win + 3,
	})
	
	local ox <const> = el.x_win + 10
	local oy <const> = el.y_win + 10
		
	el:attach(ui.create_label {
		x = ox, y = oy + 20,
		label = "speed:",
	})
	el:attach(ui.create_field {
		x = ox + 55, y = oy + 20 - 1,
		width = 15, height = 7,
		get = function(self) return sfx.track_speed(self.parent:track()) end,
		set = 
			function(self, value)
				value = mid(value, 0, 255)
				sfx.set_track_speed(self.parent:track(), value)
			end,
	})

	el.label_loop0 = ui.create_label {
		x = ox, y = oy + 40,
		label = "length:          ",
	}
	el:attach(el.label_loop0)
	el:attach(ui.create_field {
		x = ox + 55, y = oy + 40 - 1,
		width = 15, height = 7,
		get = function(self) return sfx.track_loop0(self.parent:track()) end,
		set =
			function(self, value)
				value = mid(value, 0, sfx.track_size(self.parent:track()))
				sfx.set_track_loop0(self.parent:track(), value)
			end,
	})
	
	el:attach(ui.create_label {
		x = ox, y = oy + 60,
		label = "loop end:",
	})
	el:attach(ui.create_field {
		x = ox + 55, y = oy + 60 - 1,
		width = 15, height = 7,
		get = function(self) return sfx.track_loop1(self.parent:track()) end,
		set =
			function(self, value)
				value = mid(value, 0, sfx.track_size(self.parent:track()))
				sfx.set_track_loop1(self.parent:track(), value)
				if value > sfx.track_loop0(self.parent:track()) then
					self.parent.label_loop0.label = "loop start:"
				else
					self.parent.label_loop0.label = "length:"
				end
			end,
	})

	oy += 20
		
	el:attach(ui.create_label {
		x = ox, y = oy + 80,
		label = "new tracks speed:",
	})
	el:attach(ui.create_field {
		x = ox + 75, y = oy + 80 - 1,
		width = 15, height = 7,
		get = function(self) return app.new_tracks_speed end,
		set =
			function(self, value)
				value = mid(value, 0, sfx.track_size(self.parent:track()))
				app.new_tracks_speed = value
			end,
	})
		
	el:attach(ui.create_label {
		x = ox, y = oy + 100,
		label = "new tracks length:",
	})
	el:attach(ui.create_field {
		x = ox + 75, y = oy + 100 - 1,
		width = 15, height = 7,
		get = function(self) return app.new_tracks_length end,
		set =
			function(self, value)
				value = mid(value, 0, sfx.track_size(self.parent:track()))
				app.new_tracks_length = value
			end,
	})
		
	--[[
	-- Not implemented yet? (as picotron 0.2.2b)
	el:attach(ui.create_label {
		x = ox, y = oy + 120,
		label = "tick length:",
	})
	el:attach_field {
		x = ox + 66, y = oy + 120 - 1,
		width = 15, height = 7,
		get = function(self) return sfx.tick_length() end,
		set = function(self, value) sfx.set_tick_length(value) end,
	}
	--]]
		
	el:attach(ui.create_label {
		x = ox + 110, y = oy + 80,
		label = "beat length:",
	})
	el:attach(ui.create_field {
		x = ox + 110 + 50, y = oy + 80 - 1,
		width = 15, height = 7,
		get = function(self) return app.beat_length end,
		set = 
			function(self, value)
				local v = mid(0, flr(value), 64)
				app.beat_length = value
			end,
	})
		
	el:attach(ui.create_label {
		x = ox + 110, y = oy + 100,
		label = "bar length:",
	})
	el:attach(ui.create_field {
		x = ox + 110 + 50, y = oy + 100 - 1,
		width = 15, height = 7,
		get = function(self) return app.bar_length end,
		set =
			function(self, value)
				local v = mid(0, flr(value), 64)
				app.bar_length = value
			end,
	})
		
	function el:track()
		return sfx.pattern_track(app.pattern, self.channel)
	end

	function el:draw()
		local nb_rows = flr(self.tracker.notegrids[1].height // app.row_height)
		local start = app.starting_row
		local x_numbers = self.side == "left"
			and (self.x_overlay - 11)
			or (self.x_overlay + app.column_width - 1)
		for i = 0, nb_rows do
			rrectfill(x_numbers, i * app.row_height, 11, app.row_height, 0, 58)
			print(string.format("%02d", i + start), x_numbers + 2, i * app.row_height + 2, 34)
		end
		if self.side == "left" then
			rrect(x_numbers, 0, app.column_width + 11, self.height, 0, 57)
		else
			rrect(self.x_overlay - 1, 0, app.column_width + 11, self.height, 0, 57)
		end
		draw_dialog_window(self.x_win, self.y_win, self.w_win, self.h_win,
			string.format("channel %d", self.channel))
		line(self.x_win + 3, self.y_win + 16,
			self.x_win + self.w_win - 1 * 3 - 1, self.y_win + 16, 58)
		line(self.x_win + 3, self.y_win + 16 + 1,
			self.x_win + self.w_win - 1 * 3 - 1, self.y_win + 16 + 1, 57)
		ui.print_centered("song settings", self.x_win + self.w_win // 2, self.y_win + 90, 5)
		line(self.x_win + 10, self.y_win + 90 + 2, self.x_win + 64, self.y_win + 90 + 2, 5)
		line(self.x_win + 140, self.y_win + 90 + 2, self.x_win + self.w_win - 10, self.y_win + 90 + 2, 5)
	end
	
	function el:click(msg)
		if msg.mx < self.x_win or msg.my < self.y_win
			or msg.mx > self.x_win + self.w_win
			or msg.my > self.y_win + self.h_win
		then
			return false
		end
		return true
	end
	
	function el:mousewheel(msg)
		self.tracker:scroll_channels(msg.wheel_y)
		return false
	end
	
	return el
end


return ui_trakdial
:: src/ui/ui.lua
--[[pod_format="raw",created="2024-04-23 10:25:40",modified="2026-02-19 21:34:53",revision=26902]]
local app = require "src/app.lua"
local settings = require "src/settings.lua"
local undo = require "src/undo.lua"


local ui = {}


----------------------------------------------------------------------------------------------------
-- Head
----------------------------------------------------------------------------------------------------


local head = false


function ui.create_head()
	head = create_gui()
end


function ui.head()
	return head
end


----------------------------------------------------------------------------------------------------
-- Misc
----------------------------------------------------------------------------------------------------


function ui.print_centered(s, x, y, col)
	local count = #s
	return print(s, x - ((count * 4) \ 2), y, col)
end


----------------------------------------------------------------------------------------------------
-- Mouse
----------------------------------------------------------------------------------------------------


function ui.mouse_lock(sensitivity, precise)
	local s = settings.user.drag_sensitivity
	if precise or key("shift") then
		s /= 4
	end
	s *= sensitivity or 1
	local dx, dy = mouselock(0x4|0x8, s, 0.0)
	if settings.user.drag_horizontal then -- TODO: remove?
		return -dx
	end
	return dy
end


function ui.mouse_unlock()
	mouselock(false)
end


----------------------------------------------------------------------------------------------------
-- Modal
----------------------------------------------------------------------------------------------------


local layer = false


function ui.open_modal(el)
	ui.close_modal()
	layer = ui.head():attach {
		x = 0, y = 0,
		width = ui.head().width, height = ui.head().height,
		draw = function(self)
			if self.dim_background then
				poke(0x550b, 0x3f)
				---fillp(0b0101101001011010)
				---fillp(0b0001001001001000)
				---fillp(0b1110110110110111)
				fillp(0b0011011011001001)
				rectfill(0, 0, self.width - 1, self.height - 1, 55)
				fillp()
				poke(0x550b, 0x00)
			end
		end,
		click = function(self)
			ui.close_modal()
		end,
		mousewheel = function(self)
			return false -- does not work?
		end
	}
	if not el.x then
		el.x = layer.width // 2 - el.width // 2
	end
	if not el.y then
		el.y = layer.height // 2 - el.height // 2
	end
	layer:attach(el)
	return el
end


function ui.has_modal()
	return layer
end


function ui.close_modal()
	if layer then
		layer:detach()
	end
	layer = false
end


function ui.has_modal_or_menu()
	return ui.has_modal() or ui.has_menu()
end


----------------------------------------------------------------------------------------------------
-- Chooser
----------------------------------------------------------------------------------------------------


function ui.chooser(options, callback)
	-- Copied from system 0.2.2b
	if (type(options) == "string") options = {path = options}
	if (type(options) ~= "table") options = {}

	options.path = fullpath(options.path or ".") -- can be relative to pwd; default to pwd()
	if (not options.path) return "could not resolve path"
	if (fstat(options.path) ~= "folder") return "path not found"

	local intention = options.intention or "choose_items"
	local intention_event = nil

	if (callback) intention_event = "_chooser_response_"..stat(333) -- unique id

	create_process("/system/apps/filenav.p64",{
		window_attribs = {autoclose = true, workspace = "current"},
		intention = intention,
		intention_event = intention_event,
		title = options.title, -- window title
		prompt = options.prompt, -- "Choose a File" (bottom left in intention pane)
		verb = options.verb, -- "Open" ~ (bottom right button in intention pane)
		path = options.path  -- starting path
	})

	if (callback) then
		-- create a unique, use-once handler 
		-- to do: mechanism to delete event handler when filenav never gets a chance to respond
		-- (but maybe too complex -- is harmless to have ~100 or so dormant event handlers sitting around)
		on_event(intention_event, function(msg)
			callback(msg)
			on_event(intention_event) -- delete
		end)
	end
	
end


----------------------------------------------------------------------------------------------------
-- Divider
----------------------------------------------------------------------------------------------------


function ui.create_horiz_divider(el)
	el.width = el.width or 15
	el.height = 2
	ui.head():new(el)
	function el:draw(msg)
		line(0, 0, self.width - 1, 0, 58)
		line(0, 1, self.width - 1, 1, 57)
	end
	return el
end


----------------------------------------------------------------------------------------------------
-- Label
----------------------------------------------------------------------------------------------------


function ui.create_label(el)
	local function get_str()
		local str = "---"
		if type(el.label) == "function" then
			str = el:label()
		elseif type(el.label) == "string" then
			str = el.label
		end
		return str
	end
	el.width = 4 * #(get_str()) + 4
	el.height = 5
	el.visible = el.visible or function() return true end
	ui.head():new(el)
	function el:draw()
		print(get_str(), 0, 0, el.fg or 56)
	end
	function el:update(el)
		if not self:visible() then
			self.hidden = true
			return
		end
		self.hidden = false
	end
	return el
end


-------------------------------------------------------------------------------
-- Button
-------------------------------------------------------------------------------


function ui.create_button(el)
	if not el.width then
		if el.spr then
			el.width = get_spr(el.spr):width()
			el.height = get_spr(el.spr):height()
		elseif el.label then
			el.width = 8 + (4 * #el.label)
		else
			el.width = 9
		end
	end
	el.height = el.height or 11
	el.fg = el.fg or 55
	el.bg = el.bg or 6
	el.bg_hi = el.bg_hi or 57
	el.bg_lo = el.bg_lo or 58
	el.border = el.border or 56
	el.cursor = "pointer"
	el.visible = el.visible or function() return true end
	if el.spr then
		el.x_spr = el.width // 2 - get_spr(el.spr):width() // 2
		el.y_spr = el.height // 2 - get_spr(el.spr):height() // 2
	end
	function el:draw()
		if self.spr then
			spr(self.spr, self.x_spr, self.y_spr)
			return
		end
		rrect(0, 0, self.width, self.height, 2, self.border)
		if self.clicked then
			rrectfill(1, 1, self.width - 2, self.height - 2, 1, self.bg_lo)
		else
			rrectfill(1, 1, self.width - 2, self.height - 2, 1, self.bg)
			line(1, 2, 1, self.height - 3, self.bg_hi)
			line(2, 1, self.width - 3, 1, self.bg_hi)
			line(self.width - 2, 2, self.width - 2, self.height - 3, self.bg_lo)
			line(2, self.height - 2, self.width - 3, self.height - 2, self.bg_lo)
		end
		local label = self.get_label and self:get_label() or self.label
		if label then
			print(label, (self.width \ 2) - (2 * #label), 3, self.fg)
		end
	end
	function el:hover()
		return true
	end
	function el:click()
		self.clicked = true
		return true
	end
	function el:doubleclick()
		return true
	end
	function el:tap()
		if self.action then
			self:action()
		end
	end
	function el:release()
		self.clicked = false
		return true
	end
	function el:update(el)
		if not self:visible() then
			self.hidden = true
			return
		end
		self.hidden = false
	end
	return el
end


----------------------------------------------------------------------------------------------------
-- Checkbox
----------------------------------------------------------------------------------------------------


function ui.create_checkbox(el)
	el.label = el.label or ""
	el.width = 9 + 4 * #el.label
	el.height = 7
	el.cursor = "pointer"
	ui.head():new(el)
	el.visible = el.visible or function() return true end
	function el:draw()
--		rect(0, 0, 6, 6,  el.check_border or 59)
		if el.check_bg then
--			rectfill(1, 1, 5, 5, el.check_bg)
		end
		if self:get() then
--			rectfill(2, 2, 4, 4, el.check_fg or 17)
			spr(33, 0, 0)
		else
			spr(32, 0, 0)
		end
		print(el.label, 10, 1, el.fg or 5)
	end
	function el:tap()
		self:set(not self:get())
	end
	function el:update(el)
		if not self:visible() then
			self.hidden = true
			return
		end
		self.hidden = false
	end
	return el
end


----------------------------------------------------------------------------------------------------
-- Toggle
----------------------------------------------------------------------------------------------------


function ui.create_toggle(el)
	el.horiz_padding = el.horiz_padding or 0
	el.vert_padding = el.vert_padding or 0
	el.off_spr = el.off_spr or get_spr(115)
	el.on_spr = el.on_spr or get_spr(116)
 	el.width = el.off_spr:width() + 2 * el.horiz_padding
 	if type(el.label) == "string" then el.width += 4 + 4 * #el.label end
	el.height = el.off_spr:height() + 2 * el.vert_padding
	el.has_pointer = el.has_pointer or function() return true end
	el.cursor = "pointer"
	ui.head():new(el)
	if (not el.visible) el.visible = function() return true end
	function el:draw()
		if not self:visible() then return end
		local is_on = self:get() == true
		spr(is_on and self.on_spr or self.off_spr, el.horiz_padding, el.vert_padding)
		if type(el.label) == "string" then
			print(el.label, 16, 1, el.fg or 55)
		end
	end
	function el:click(msg)
		if self:has_pointer(msg.mx, msg.my) then return true end
	end
	function el:tap(msg)
		if not self:visible() then return end
		if not self:has_pointer(msg.mx, msg.my) then return end
		self:set(not self:get())
	end
	function el:hover(msg)
		if not self:visible() then self.cursor = 1 return end
		if self:has_pointer(msg.mx, msg.my) then
			self.cursor = "pointer"
		else
			self.cursor = 1
		end
	end
	return el
end


----------------------------------------------------------------------------------------------------
-- Numeric Field
----------------------------------------------------------------------------------------------------


function ui.create_list(el)
	el.row_height = el.row_height or 9
	el.nb_columns = el.nb_columns or 1
	if el.with_bg == nil then el.with_bg = true end
	if el.with_border == nil then el.with_border = true end
	el.get_str = el.get_str or function(self, idx) return tostr(idx) end
	el.get_active = el.get_active or function(self) return nil end
	el.scrolled_to = el.scrolled_to or function(self) end
	el.get_start = el.get_start or function(self) return self.start end
	el.set_start = el.set_start or function(self, start) self.start = start end
	el.get_max = el.get_max or function(self) return 999 end
	el.disabled = el.disabled or function(self) return false end
	el.on_tap = el.on_tap or function(self) end
	el.start = el.start or 0
	el.overshoot = el.overshoot or 0
	ui.head():new(el)
	
	function el:draw(msg)
		if self.with_bg then
			rrectfill(0, 0, self.width, self.height, 0, 59)
		end
--		clip(self.sx + 1, self.sy + 1, self.width - 2, self.height - 2)
		local nb_rows = self.height // self.row_height
		local column_width = self.width // self.nb_columns
		local active_idx = self:get_active()
		local max = self:get_max()
		local first_row = 0
		local start = self:get_start()
		local bg_active = self:disabled() and 19 or 17
		if start < 0 then
			first_row = -start
		end
		for row = first_row, nb_rows do
			for col = 0, self.nb_columns - 1 do
				local idx = col + (start + row) * self.nb_columns
				if idx > max then break end
				local x = col * column_width
				local y = row * self.row_height
				local w = column_width
				if col == self.nb_columns - 1 then w += self.width % self.nb_columns end
				if self.draw_item then
					local hovered = msg.has_pointer and row == (msg.my - 1) // self.row_height
					self:draw_item(idx, x, y, w, self.row_height, hovered)
				else
					if idx == active_idx then
						rrectfill(x, y, w, self.row_height, 0, bg_active)
					end
					print(self:get_str(idx), x + 3, y + 2, 57)
				end
			end
		end
		if (active_idx // self.nb_columns) < start then
			pal(17, bg_active)
			spr(9, self.width // 2 - 13, 1)
			pal(17, 17)
		elseif (active_idx // self.nb_columns) > start + nb_rows then
			pal(17, bg_active)
			spr(10, self.width // 2 - 13, self.height - 7)
			pal(17, 17)
		end
		-- Borders
		clip()
		if self.with_border then
			app.draw_borders(0, 0, self.width, self.height)
--			line()
--			line(0, self.height - 3, 58)
--			line(0, 2, 58)
--			line(2, 0, 58)
--			line(self.width - 3, 0, 58)
--			line(self.width - 1, 2, 58)
---			line(self.width - 1, self.height - 3, 57)
--			line(self.width - 3, self.height - 1, 57)
--			line(2, self.height - 1, 57)
--			line(1, self.height - 2, 57)
		end
	end
	
	function el:show_active()
		local active_row = self:get_active() // self.nb_columns
		local nb_rows = (self.height - 2) // self.row_height
		local start = self:get_start()
		if start > active_row then
			start = active_row
		elseif active_row > start + nb_rows - 1 then
			self:set_start(max(active_row - nb_rows + 1, 0))
		end
	end
	
	function el:center_active()
		local active_row = self:get_active() // self.nb_columns
		local nb_rows = (self.height - 2) // self.row_height
		self:set_start(active_row - nb_rows // 2)
	end
	
	function el:click(msg)
		local max = self:get_max()
		local row = (msg.my - 2) // self.row_height
		local column_width = (self.width - 2) // self.nb_columns
		local col = msg.mx // column_width
		local idx = col + (self:get_start() + row) * self.nb_columns
		if idx < 0 or idx > max then return end
		if msg.mb == 1 then
			self:set_active(idx)
		end
	end
	function el:tap(msg)
		local max = self:get_max()
		local row = (msg.my - 2) // self.row_height
		local column_width = (self.width - 2) // self.nb_columns
		local col = msg.mx // column_width
		local idx = col + (self:get_start() + row) * self.nb_columns
		if idx < 0 or idx > max then return end
		if msg.last_mb == 1 then
			self:on_tap(idx)
		end
	end
	
	function el:mousewheel(msg)
		local nb_rows = (self.height - 2) // self.row_height
		local start = self:get_start()
		local max_row = self:get_max() // self.nb_columns - nb_rows + 1
		start -= msg.wheel_y
		start = mid(start, 0 - self.overshoot, max_row + self.overshoot)
		self:set_start(start)
	end

	return el
end


----------------------------------------------------------------------------------------------------
-- Numeric Field
----------------------------------------------------------------------------------------------------


-- TODO: is this still used?
function ui.create_num_field(el)
	el.width = el.width or 62
	el.height = 12
	ui.head():new(el)
	el.visible = el.visible or function() return true end
	el.dragged = nil
	function el:draw()
		local label_fg = self.label_fg or 56
		local field_fg = self.field_fg or 22
		local dragged_fg = self.dragged_fg or 7
		local field_bg = self.field_bg or 59
		local dragged_bg = self.dragged_bg or 59
		if (not self.visible()) return
		local val = self.get()
		rectfill(self.width - 24, 0, self.width - 10, 6, self.dragged and dragged_bg or field_bg)
		print(el.label, 3, 1, label_fg)
		if val then
			print(string.format("%3d", val), self.width - 22, 1, self.dragged and dragged_fg or field_fg)
		else
			print("-", self.width - 4, 1, self.dragged and dragged_fg or field_fg)
		end
	end
	function el:hover(msg)
		if msg.mx >= self.width - 21 then
			--- self.cursor = "pointer"
			self.cursor = get_spr(50)
		else
			self.cursor = 1
		end
	end
	function el:click(msg)
		if (self.onclick) self.onclick(msg)
		if msg.mx >= self.width - 21 then
			self.dragged = true
			self.cursor = 0 -- TODO: capture mouse
		end
	end
	function el:drag(msg)
		if self.dragged then
			local _, delta = mouselock(true, key("shift") and 0.025 or 0.125, 0)
			new = mid(0, self.get() - delta, 0xff)
			self.set(new)
		end
	end
	function el:release(msg)
		self.dragged = nil
		mouselock(false)
		if (self.onrelease) self.onrelease(msg)
	end
	function el:update(el)
		if not self:visible() then
			self.hidden = true
			return
		end
		self.hidden = false
	end
	return el
end


----------------------------------------------------------------------------------------------------
-- Numeric Field (bis repetitae)
----------------------------------------------------------------------------------------------------


function ui.create_field(el)
	el.width = el.width or 4 * 4 + 3
	el.height = 7
	el.cursor = get_spr(53)
	ui.head():new(el)
	el.visible = el.visible or function(self) return true end
	el.on_confirm = el.on_confirm or function(self) end
	el.blink_timer = 0
	
	function el:draw()
		local fg = self.fg or (self.dragged and 63 or 55)
		local bg = self.dragged and 7 or 57
		if self:has_keyboard_focus() then
			fg = self.str_is_valid and 63 or 8
			bg = 7
		end
		rrectfill(0, 0, self.width, self.height, 1, bg)
		if (not self.visible) or self:visible() then
			local str
			if self:has_keyboard_focus() then
				str = self.str
			else
				local val = self:get()
				if self.to_str then
					str = self:to_str(val)
				else
					str = tostr(val)
				end
			end
			local x_cursor = 0
			if self.centered then
				x_cursor = ui.print_centered(str, self.width // 2 + 1, 1, fg)
			else
				x_cursor = print(str, self.width - 1 - 4*#str, 1, fg)
			end
			if self:has_keyboard_focus() and self.blink_timer % 32 > 16 then
				line(x_cursor, 0, x_cursor, 6, 14)
			end
		end
	end


	function el:update()
		if not self:visible() then
			self.hidden = true
			return
		end
		self.hidden = false
		if self:has_keyboard_focus() then
			self.blink_timer += 1
			while peektext() do
				if #self.str < 4 then
					self.str = self.str .. readtext()
				else
					readtext()
				end
			end
		end
		
		if not self.str then return end
		
		local val = tonum(self.str)
		self.str_is_valid = (val ~= nil) or self.str == "-"

		if keyp("backspace") then
			self.str = sub(self.str, 1, -2)
		elseif keyp("escape") or (keyp("enter") and #self.str == 0) then
			self.str = nil
 			self:set_keyboard_focus(false)
			app.was_in_text_field = true
		elseif keyp("enter") or not self:has_keyboard_focus() then
			if val then
				self:set(val)
				self:on_confirm()
			end
			self.str = nil
			self:set_keyboard_focus(false)
			app.was_in_text_field = true
		end
	end

	
	function el:click(msg)
		-- TODO: the situation with checpoints in widgets is inconsistent: some
		-- widgets handle it themselves (have to), others let that to the caller.
		undo.checkpoint()
		if self.visible and (not self.visible(self)) then
			return true
		end
		self.cursor = 0
		self.dragged = true
		ui.mouse_lock(1.0, true)
		if self.onclick then
			self:onclick(msg)
		elseif self.parent.onclick then
			self.parent:onclick(msg)
		end
		return true
	end
	
	
	function el:doubleclick()
		return true
	end

	
	function el:tap()
		if self.visible and (not self.visible(self)) then
			return true
		end
		self:set_keyboard_focus(true)
		readtext(true)
		self.str = ""
	end	

	
	function el:drag(msg)
		local delta = ui.mouse_lock(1.0, true)
		local old = self:get()
		local new = old - delta
		self:set(new)
	end

	
	function el:release()
		self.cursor = get_spr(53)
		self.dragged = false
		ui.mouse_unlock()
		self.up_barrier = nil
		self.down_barrier = nil
		-- TODO: it would be nice to keep the visual modal open
		-- when the field has keyboard focus, but I didn't find
		-- a way to close the modal when the focus is lost...
		if self.onrelease then
			self:onrelease()
		elseif self.parent.onrelease then
			self.parent:onrelease()
		end
	end


	return el
end


----------------------------------------------------------------------------------------------------
-- Menu
----------------------------------------------------------------------------------------------------


local popup = false


function ui.create_menu_button(el)
	local label = el.get_label()
	local label_width = print(label, 0, -1000)
	el.width = label_width + 12
	el.height = 9
	el.cursor = "pointer"
	ui.head():new(el)
	el.opened = false
	function el:draw()
		if self.bg then
			rectfill(0, 0, self.width - 1, self.height - 1, self.bg)
		end
		local label = self:get_label()
		print(label, 2, 2, self.fg or 7)
		pal(7, self.fg or 7)
		spr(self.opened and 38 or 37, self.width - 7, 2)
		pal(7, 7)
	end
	function el:tap()
		self.opened = true
		ui.open_menu {
			x = self.sx, y = self.sy + 9,
			highlight = self.highlight,
			onclose = function()
				self.opened = false
				local label = el.get_label()
				self.width = (4 * #label) + 12
			end,
			items = self.items,
		}
	end
	return el
end


function ui.open_menu(menu)
	for i = 1, #menu.items do
		if menu.items[i].get_label then
			menu.items[i].label = menu.items[i].get_label()
		end
		if (not menu.items[i].label) menu.items[i].label = "---"
	end
	local entry_height = 9
	-- Calculate popup size
	if not menu.width then
		menu.width = 0
		for i = 1, #menu.items do
			menu.width = max(menu.width, #menu.items[i].label or 0)
		end
		menu.width = 8 + (4 * menu.width)
	end
	if not menu.height then
		menu.height = max(12, 4 + (#menu.items * entry_height))
	end
	if menu.y + menu.height > ui.head().height then
		menu.y = menu.y - 7 - menu.height
	end

	-- Modal layer	
	popup = ui.head():attach {
		x = 0, y = 0,
		width = ui.head().width, height = ui.head().height,
		draw = function(self)
			local ox, oy = menu.x, menu.y
			rectfill(ox, oy, ox + menu.width - 1, oy + menu.height - 1, menu.bg or 7)
			rect(ox, oy, ox + menu.width - 1, oy + menu.height - 1, menu.border or 55)
			for i = 1, #menu.items do
				local y = oy + 2 + (entry_height * (i - 1))
				if self.highlighted == i then
					rectfill(
						ox + 1, y,
						ox + menu.width - 2, y + entry_height - 1,
						menu.highlight or 15
					) 
				end
				print(
					menu.items[i].label,
					ox + 4, y + 2,
					menu.items[i].fg or menu.fg or 55
				)
			end
		end,
		hover = function(self)
			local ox, oy = menu.x, menu.y
			local mx, my, mb = mouse()
			if
				ox <= mx and mx < ox + menu.width
				and oy <= my and my < oy + menu.height
			then
				self.cursor = "pointer"
				self.highlighted = 1 + ((my - oy - 4) \ entry_height)
			else
				self.cursor = "pointer"
				self.highlighted = false
			end
		end,
		click = function(self)
			if popup then
				popup:detach()
			end
			popup = false
			if self.highlighted and menu.items[self.highlighted]
				and menu.items[self.highlighted].action
			then
				menu.items[self.highlighted].action()
			end
			if (menu.onclose) menu.onclose()
		end
	}
end


function ui.has_menu()
	return popup != false
end


----------------------------------------------------------------------------------------------------
-- Knob
----------------------------------------------------------------------------------------------------


function ui.create_knob(el)
	if el.small then
		el.x += 3
		el.y += 5
		el.width, el.height = 25, 25
		el.cx, el.cy, el.r = 12, 12, 7
		el.sprite = 58
	else
		el.width, el.height = 31, 31
		el.cx, el.cy, el.r = 15, 15, 9
		el.sprite = 56
	end
	if el.reversed then
		local prev_get, prev_set = el.get, el.set
		el.get = function(self) return 255 - prev_get(self) end
		el.set = function(self, v) prev_set(self, 255 - v) end
		local prev_get_sec, prev_set_sec = el.get_secondary, el.set_secondary
		el.get_secondary = function(self) return 255 - prev_get_sec(self) end
		el.set_secondary = function(self, v) prev_set_sec(self, 255 - v) end
	end
	el.cursor = "dial"
	ui.head():new(el)
	

	function el:draw()
		local target = self.min_val and self or self.parent
		local sprite = (target.min_val < 0)
			and (self.sprite + 1) or self.sprite
		spr(sprite, 0, 0)	
		local range = target.max_val - target.min_val
		-- primary value
		local val = self:get()
		local a = ((val - target.min_val) / range) * 0.75
		local x = self.cx + flr(0.5 + self.r * cos(0.625 - a))
		local y = self.cy + flr(0.5 + self.r * sin(0.625 - a))
		-- secondary value: arc and needle
		if self:has_secondary() then
			local val2 = self:get_secondary()
			local a2 = ((val2 - target.min_val) / range) * 0.75
			local r = self.small and 6 or 7.75
			local incr = 0.01 -- self.small and 0.01 or 0.01
			local function line_to(aa, col)
				local xx = self.cx + flr(0.5 + r * cos(0.625 - aa))
				local yy = self.cy + flr(0.5 + r * sin(0.625 - aa))
--				line(xx, yy, 18)
				line(self.cx, self.cy, xx, yy, 55)
			end
			local in_between =
				(a < a2) 
					and function(ai) return a < ai and ai < a2 end
					or function(ai) return a2 < ai and ai < a end
			line()
			line_to((a < a2) and a or a2)
			for ai = 0.0, 0.75, incr do
				if in_between(ai) then
					line_to(ai)
				end
			end
			line_to((a < a2) and a2 or a)
			local x2 = self.cx + flr(0.5 + (self.r - 2) * cos(0.625 - a2))
			local y2 = self.cy + flr(0.5 + (self.r - 2) * sin(0.625 - a2))
			line(self.cx, self.cy, x2, y2, self.dragged_secondary and 7 or 29)
--			circfill(x2, y2, 1.5, self.dragged_secondary and 7 or 29)
			circfill(self.cx, self.cy, self.small and 2 or 3, 32)
		end	
		-- primary needle
		local needle_col = self.dragged and 7 or 15
		if self.white then
			needle_col = self.dragged and 5 or 22
		end
		line(self.cx, self.cy, x, y, needle_col)
	end
	

	function el:click(msg)
		undo.checkpoint()
		local target = self.min_val and self or self.parent
		self.dragged = msg.mb == 1
		self.dragged_secondary = msg.mb == 2
		ui.mouse_lock(target.sensitivity)
		return true
	end
	

	function el:doubleclick(msg)
		local target = self.min_val and self or self.parent
		if msg.mb == 1 then
			self:set(target.init_val)
		elseif msg.mb == 2 then
			self:set_secondary(target.init_val)
		end
		return true
	end
	

	function el:drag(msg)
		local target = self.min_val and self or self.parent
		local delta = ui.mouse_lock(target.sensitivity)

		local old = self:get()
		local new = old - delta
		local old2, new2 = 0, 0
		if self:has_secondary() and msg.mb == 2 then
			old2 = self:get_secondary()
			new2 = old2 - delta
		end

		if delta < 0 then
			self.down_barrier = nil
			if self.up_barrier then
				self.up_barrier += delta
				if self.up_barrier <= 0 then
					self.up_barrier = nil
				else
					return
				end
			end
		elseif delta > 0 then
			self.up_barrier = nil
			if self.down_barrier then
				self.down_barrier -= delta
				if self.down_barrier <= 0 then
					self.down_barrier = nil
				else
					return
				end
			end
		end
		if old > 0 and new <= 0 then
			new = 0
			self.down_barrier = 24
		end
		if old < 0 and new >= 0 then
			new = 0
			self.up_barrier = 24
		end
		if old2 > 0 and new2 <= 0 then
			new2 = 0
			self.down_barrier = 24
		end
		if old2 < 0 and new2 >= 0 then
			new2 = 0
			self.up_barrier = 24
		end
		
		if msg.mb == 1 then
			self:set(new)
		elseif msg.mb == 2 then
			self:set_secondary(new2)
		end
	end
	

	function el:release(msg)
		self.dragged = false
		self.dragged_secondary = false
		ui.mouse_unlock()
		self.up_barrier = nil
		self.down_barrier = nil
	end
	

	return el
end


return ui
:: src/ui/visual.lua
--[[pod_format="raw",created="2024-04-16 18:22:58",modified="2026-02-19 21:34:53",revision=27626]]
local app = require "src/app.lua"
local sfx = require "src/sfx/sfx.lua"
local ui = require "src/ui/ui.lua"


local ui_visual = {}


-------------------------------------------------------------------------------
-- Locals
-------------------------------------------------------------------------------


local overlay = nil


-------------------------------------------------------------------------------


local function draw_wave(
		wt_addr, wt_width, wt_height,
		wave, phase,
		display_width, display_height,
		fg
)
	local oy = display_height \ 2
	local pos_addr = wt_addr + (wave * wt_height >> 8) * wt_width * 2
	local function pos_at(i)
		local sample = i / display_width
		sample += (phase / 256.0) % 1.0
		sample = flr(0.5 + sample * wt_width)
		local val = peek2(pos_addr + sample * 2)
		local h = flr(0.5 + ((val * display_height) / 72000))
		return h
	end
	local last_h = pos_at(0)
	for i = 0, (display_width - 1) do
		local h = pos_at(i)
		local dx = abs(h - last_h) > 3 and 0 or -1
		line(i + dx, oy - last_h, i, oy - h, fg)
 		last_h = h
	end
end
ui_visual.draw_wave = draw_wave


-------------------------------------------------------------------------------
-- Closing any Visual Modal
-------------------------------------------------------------------------------


function ui_visual.close()
	if overlay then
		overlay:detach()
		overlay = nil
	end
end


-------------------------------------------------------------------------------
-- Wavetable Visual and Widget
-------------------------------------------------------------------------------


function ui_visual.open_wavetable(target, fg)
	if (overlay) ui_visual.close()
	
	overlay = ui_visual.attach_wavetable(ui.head(), target, {
		x = 374, y = 8,
		width = 81, height = 50,
		border = 60,
		fg = fg
	})
end


function ui_visual.attach_wavetable(parent, target, el)
	parent:attach(el)
	function el:draw()
		rectfill(0, 0, self.width - 1, self.height - 1, 59)
		local wt_index = sfx.node_wavetable_index(app.instrument, target.node_id)
		local wt_addr, wt_width, wt_height = sfx.wavetable_info(app.instrument, wt_index)
		local _, wave1, wave0, _ = sfx.node_param(app.instrument, target.node_id, 4)
		local _, phase, _, _ = sfx.node_param(app.instrument, target.node_id, 5)
		-- Show val0 if there is an envelope
		local flags, _, _, _ = sfx.node_param(app.instrument, target.node_id, target.param)
		if flags & (0x04 | 0x10) > 0  then
			draw_wave(wt_addr, wt_width, wt_height, wave0, phase,
				self.width, self.height, 48)
		end
		-- Show val1
		draw_wave(wt_addr, wt_width, wt_height, wave1, phase,
			self.width, self.height, self.fg or 43)
		-- Border
		clip()
		if self.border then
			rrect(-1, -1, self.width + 2, self.height + 2, 2, self.border)
		else
			line()
			line(1, -1, 58)
			line(self.width - 2, -1, 58)
			line(self.width, 1, 58)
			line(self.width, self.height - 2, 57)
			line(self.width - 2, self.height, 57)
			line(1, self.height, 57)
			line(-1, self.height - 2, 57)
			line(-1, 1, 58)
			line(1, -1, 58)
		end
		clip(self.sx, self.sy, self.width, self.height)
	end
	return el
end


-------------------------------------------------------------------------------
-- Shaper Visual
-------------------------------------------------------------------------------


function ui_visual.attach_shaper_display(parent, el)
	parent:attach(el)
	function el:draw()
		rectfill(0, 0, self.width - 1, self.height - 1, 59)
	
		-- Adapted from the default tracker
		
		local _, gain, _, gain_scale  = sfx.node_param(app.instrument, parent.node_id, 0)
		gain = gain * 7.0 / 255.0
		gain = 1.0 + gain * sfx.param_scale(gain_scale)
		
		local _, elbow, _, elbow_scale = sfx.node_param(app.instrument, parent.node_id, 1)
		elbow /= 255.0
		elbow *= sfx.param_scale(elbow_scale)
		
		local _, cut = sfx.node_param(app.instrument, parent.node_id, 2)
		cut = 1.0 - cut / 255.0
		local _, mix = sfx.node_param(app.instrument, parent.node_id, 3)
		local ww = self.width
		local hh = self.height
		
		
--		fillp(0x5555)
		line(0, hh - cut * hh, ww, hh - cut * hh, 60)
--		fillp()
		
		local elbow_y = cut
		local elbow_x = elbow_y / gain
		local slope = 0
		
		if (elbow_x == 1.0) then
			slope = 0
		elseif (elbow < 0.5) then
		
			local tt = elbow * 2
			local slope0 = (gain - elbow_y) / (1 - elbow_x)
			local slope1 = (1 - elbow_y) / (1 - elbow_x)
			slope = (1 - tt) * slope0 + (tt * slope1)
		else
			local tt = (elbow - .5)*2
			local slope0 = (1 - elbow_y) / (1 - elbow_x)
			slope = (1 - tt) * slope0
		end
		
		local last_xx, last_yy = 0, self.height
		for i = 0, self.width - 1, 1 do
			local tt = i / self.width
			local val = 0
			
			if tt < elbow_x then
				val = tt * gain
			else
				if elbow < 1 then
					val = elbow_y + (tt - elbow_x) * slope
				else
					-- foldback \m/
					local e2 = elbow - 1
					local h2 = elbow_y / 2
					--val = h2 + cos((tt-elbow_x)*e2) * h2
					-- 0.1.0h: linear reflection
					val = ((tt - elbow_x) * e2) % 1
					val = ((val < 0.5) and 1 - val * 4 or -1 + (val - 0.5) * 4)
					val = h2 + val * h2
				end
			end
			
			local xx = i
			local yy = self.height - val * self.height
		
			line(last_xx, last_yy, xx, yy, 9)
			last_xx, last_yy = xx, yy
		end
		
		clip()
		if self.border then
			rrect(-1, -1, self.width + 2, self.height + 2, 2, self.border)
		else
			app.draw_borders(0, 0, self.width, self.height)
		end
		clip(self.sx, self.sy, self.width, self.height)
	end
	return el
end


-------------------------------------------------------------------------------
-- Filter Visual
-------------------------------------------------------------------------------


function ui_visual.attach_filter_display(parent, el)
	parent:attach(el)
	function el:draw()
		rectfill(0, 0, self.width - 1, self.height - 1, 59)
	
		clip()
		if self.border then
			rrect(-1, -1, self.width + 2, self.height + 2, 2, self.border)
		else
			app.draw_borders(0, 0, self.width, self.height)
		end
		clip(self.sx, self.sy, self.width, self.height)
	end
	return el
end


-------------------------------------------------------------------------------
-- Delay Visual
-------------------------------------------------------------------------------


function ui_visual.attach_delay_display(parent, el)
	parent:attach(el)
	function el:draw()
		rectfill(0, 0, self.width - 1, self.height - 1, 59)
		
		local _, delay, _, delay_scale  = sfx.node_param(app.instrument, parent.node_id, 0)
		delay /= 255
		delay = delay * min(sfx.param_scale(delay_scale), 1.0)
		local _, vol, _, vol_scale  = sfx.node_param(app.instrument, parent.node_id, 1)
		vol /= 255
		vol = vol * min(sfx.param_scale(vol_scale), 1.0)
		
		local h = self.height - 16
		if delay == 0 then
			line(8, self.height - 8, 8, self.height - 8 - h, 31)
		else
			for x = 8, self.width - 9, max(flr(0.5 + delay * 70), 1) do
				local fg = h < 0.25 and 60 or 31
				line(x, self.height - 8, x, flr(0.5 + self.height - 8 - h), fg)
				h *= vol
			end
		end
	
		clip()
		if self.border then
			rrect(-1, -1, self.width + 2, self.height + 2, 2, self.border)
		else
			app.draw_borders(0, 0, self.width, self.height)
		end
		clip(self.sx, self.sy, self.width, self.height)
	end
	return el
end


-------------------------------------------------------------------------------
-- Oscilloscope Visual
-------------------------------------------------------------------------------


function ui_visual.attach_node_oscillo(parent, channel, el)
	parent:attach(el)
	el.frame_counter = 0
	function el:draw()
		local node_id = self.node_id or app.node or 0
		local horiz_scale = self.horiz_scale or 2
		local vert_scale = self.vert_scale or 1
		local bg, fg = self.bg or 59, self.fg or 58 -- 49
		local node_kind = sfx.node_type(app.instrument, node_id)
		if node_id == 0 then
			-- Nothing to do, but no early return
		elseif node_kind == 2 then -- OSC
			local node_op = sfx.node_op(app.instrument, node_id)
			if node_op == 0 then
			elseif node_op == 1 or node_op == 2 then
				node_id = sfx.node_parent(app.instrument, node_id)
			end
		else
			node_id = 0
		end
		rectfill(0, 0, self.width - 1, self.height - 1, bg)
		print(tostr(node_id), 4, 4, 60)
		-- Oscilloscope
		local tick_addr = 0x200000 + node_id * 8192
		-- `tick_len` is never used by sfx.p64...
		-- but the second `stat` is necessary to get
		-- audio data into `tick_addr`
		local tick_len = stat(400 + channel, 8)
		self.frame_counter += 1
		if self.frame_counter % 1 == 0 then
			tick_len = stat(400 + channel, 20 + node_id, tick_addr)
		end
		local last_sgn = sgn(peek2(tick_addr))
		local zero_crossing = 0
		for i = 0, tick_len - horiz_scale * self.width, 2 do
			local sample = peek2(tick_addr + i)
			if zero_crossing == 0 then
				if last_sgn > 0 then
					last_sgn = sgn(sample)
				elseif sgn(sample) > last_sgn then
					zero_crossing = i
					break
				end
			end
		end
		local last_y = (self.height / 2) - (vert_scale * (peek2(tick_addr + zero_crossing) * self.height) / 72000)
		for x = 0, self.width - 1 do
			local sample = flr(x * horiz_scale) -- i.e. horizontal scaling of the waveform
			local val = peek2(tick_addr + zero_crossing + sample * 2)
			local y = (self.height / 2) - (vert_scale * (val * self.height) / 72000)
			local dx = abs(y - last_y) > 3 and 0 or -1
			line(x + dx, last_y, x, y, fg)
			last_y = y
		end

		-- Border
		clip()
		if self.border then
			rrect(-1, -1, self.width + 2, self.height + 2, 2, self.border)
		else
			line()
			line(1, -1, 58)
			line(self.width - 2, -1, 58)
			line(self.width, 1, 58)
			line(self.width, self.height - 2, 57)
			line(self.width - 2, self.height, 57)
			line(1, self.height, 57)
			line(-1, self.height - 2, 57)
			line(-1, 1, 58)
			line(1, -1, 58)
		end
		clip(self.sx, self.sy, self.width, self.height)
	end
	return el
end


-------------------------------------------------------------------------------
-- Stereo Oscillo
-------------------------------------------------------------------------------


local fg_left = 47 -- 37, 45
local fg_left_dim = 46
local fg_right = 41 -- 39, 41
local fg_right_dim = 40
local fg_both = 49 -- 38, 43
local fg_both_dim = 48

function ui_visual.draw_stereo_signal(x, y, width, height, addr, length, zero_crossing, hscale)
	rrectfill(x, y, width, height, 0, 59)
	local ymid = y + height // 2
	local vscale = (height - 0) // 2
	local function sample_to_y(sample)
		return flr(0.5 + ymid - (sample / 32768) * vscale)
	end
	local last_y_left = sample_to_y(peek2(0x90000 + zero_crossing))
	local last_y_right = sample_to_y(peek2(0x90002 + zero_crossing))
	local cliff <const> = height // 6
	for x = 0, width - 1 do
		local pos = zero_crossing + x * 4 * hscale
		local y_left = sample_to_y(peek2(0x90000 + pos))
		local dx_left = abs(y_left - last_y_left) > cliff and 1 or 0
		line(x + dx_left, last_y_left, x + 1, y_left, fg_left)
		local y_right = sample_to_y(peek2(0x90002 + pos))
		local dx_right = abs(y_right - last_y_right) > cliff and 1 or 0
		local same_spot = (y_right == y_left)
		line(x + dx_right, last_y_right, x + 1, y_right, same_spot and fg_both or fg_right)
		last_y_left, last_y_right = y_left, y_right
	end
	clip()
	app.draw_borders(x, y, width, height)
end


function ui_visual.attach_stereo_oscillo(parent, el)
	el.horiz_scale = el.horiz_scale or 3
	el.frame_counter = 1
	parent:attach(el)
	function el:draw()
		local n
		if el.channel then
			n = stat(400 + el.channel, 19, 0x90000)
		else
			n = stat(465, 0, 0x90000)
		end
		local last_sgn = sgn(peek2(0x90000))
		local zero_crossing = 0
		for i = 0, 2 * n - self.horiz_scale * self.width, 4 do
			local sample = peek2(0x90000 + i)
			if zero_crossing == 0 then
				if last_sgn > 0 then
					last_sgn = sgn(sample)
				elseif sgn(sample) > last_sgn then
					zero_crossing = i
					break
				end
			end
		end
		ui_visual.draw_stereo_signal(0, 0, self.width, self.height,
			0x90000, n, zero_crossing, self.horiz_scale)
	end
	return el
end

-------------------------------------------------------------------------------
-- Custom Envelopes Visual and Widget
-------------------------------------------------------------------------------


function ui_visual.open_custom_envelope(env_id)
	if (overlay) ui_visual.close()
	
	local env_type = sfx.env_type(app.instrument, env_id)
	if (env_type != 2) return
	
	overlay = ui.head():attach {
		x = 374 - 1, y = 8 - 1,
		width = 81 + 2, height = 50 + 2,
		border = 60,
		env_id = env_id,
	}
	
	function overlay:draw()
		ui_visual.draw_custom_envelope(overlay)
	end
end


function ui_visual.draw_custom_envelope(self)
	local bar_width = self.width \ 16
	rectfill(1, 1, self.width - 2, self.height - 2, 59)
	local start = sfx.env_start(app.instrument, self.env_id)
	local loop0 = sfx.env_loop0(app.instrument, self.env_id)
	local loop1 = sfx.env_loop1(app.instrument, self.env_id)
	for i = 0, 15 do
		local val = sfx.env_param(app.instrument, self.env_id, i)
		local h = (val * (self.height - 2)) \ 255
		local col = (i % 2 == 0) and 29 or 18
		if loop0 <= i and i < loop1 then
			col = (i % 2 == 0) and 23 or 14
		end
		if h > 0 then
			rectfill(
				1 + (bar_width * i), self.height - 2,
				bar_width + (bar_width * i), self.height - h - 1,
				col
			)
		end
	end
	fillp(0b1111000011110000)
	poke(0x550b,0x3f)
	if start > 0 then
		local x = 1 + (bar_width * start)
		line(x, 1, x, self.height - 2, 12)
	end
	if loop0 > 0 then
		local x = 1 + (bar_width * loop0)
		line(x, 1, x, self.height - 2, 11)
	end
	if loop1 > 0 then
		local x = bar_width + (bar_width * (loop1 - 1))
		line(x, 1, x, self.height - 2, 9)
	end
	fillp()
	poke(0x550b,0x0)
	if self.selected then
		local val = sfx.env_param(app.instrument, self.env_id, self.selected)
		local str = tostr(val)
		print(str, self.width - 3 - (4 * #str), 3, 7)
	end
	--rect(0, 0, self.width - 1, self.height - 1, 5)
	clip()
	if self.border then
		rrect(0, 0, self.width, self.height, 2, self.border)
	else
		app.draw_borders(1, 1, self.width - 2, self.height - 2)
	end
end


return ui_visual
:: src/ui/wavetable.lua
--[[pod_format="raw",created="2026-01-25 09:41:43",modified="2026-02-19 21:34:53",revision=25852]]
local app = require "src/app.lua"
local sfx = require "src/sfx/sfx.lua"
local Wavetable = require "src/wavetable.lua"
local ui = require "src/ui/ui.lua"
local ui_panel = require "src/ui/panel.lua"
local ui_synth = require "src/ui/synth.lua"
local ui_visual = require "src/ui/visual.lua"


local ui_wavetable = {}


-------------------------------------------------------------------------------
-- Wavetable Synth View
-------------------------------------------------------------------------------


function ui_wavetable.attach(parent, el)
	parent:attach(el)

	app.is_editing = false

	ui_panel.attach_view_selector(el, { x = 0, y = 4 })
	el:attach(ui.create_horiz_divider { x = 3, y = 41, width = 13 })
	ui_panel.attach_octave_selector(el, { x = 0, y = 45 })
	ui_panel.attach_instrument_selector(el, { x = 0, y = 57 })
	ui_panel.attach_volume_selector(el, { x = 0, y = 75 })
		
	ui_wavetable.attach_wavetable_chooser(el, {
		x = app.panel_width, y = 4,
		width = 82, height = 97,
	})
	
	ui_wavetable.attach_wavetable_display(el, {
		x = app.panel_width + 90 - 4, y = 4,
		width = 356, height = 97,
	})
	
	--[[
	ui_wavetable.attach_temp_widget(el, {
		x = 4, y = 100,
		width = 356, height = 97,
	})
	--]]

	ui_panel.attach_meters(el, { x = 464, y = 3 })
	
	function el:draw()
		local w <const> = self.width
		local h <const> = self.height
		cls(6)
		line(0, 0, w - 1, 0, 57)
		line(0, 0, 0, h - 1, 57)
		line(0, 106, w - 1, 106, 57)
		line(0, 105, w - 1, 105, 58)
		line(w - 1, 0, w - 1, h - 1, 58)
		line(0, h - 1, w - 1, h - 1, 58)
	end
	
	return el
end


-------------------------------------------------------------------------------
-- Wavetable Chooser
-------------------------------------------------------------------------------


local wavetable_chooser_start = 0


function ui_wavetable.attach_wavetable_chooser(parent, el)
	parent:attach(el)
	
	ui_panel.attach_wavetable_toggle(el, {
		x = 0, y = 0,
		width = el.width, height = 10,
	})
	
	el:attach(ui.create_list {
		x = 0, y = 12,
		width = el.width, height = el.height - 12,
		with_bg = false, with_border = false,
		get_max = function(self) return app.num_wavetables() - 1 end,
		get_start = function(self) return wavetable_chooser_start end,
		set_start = function(self, instr) wavetable_chooser_start = instr end,
		get_active = function(self) return app.instrument end,
		set_active =
			function(self, wavetable)
				app.wavetable = wavetable
			end,
		draw_item =
			function(self, wavetable, x, y, w, h, has_pointer)
				if wavetable == app.wavetable then
					rrectfill(x, y, w, h, 0, 17)
					if y + h >= self.height - 1 then
						pset(0, self.height - 1, 58)
						pset(self.width - 1, self.height - 1, 57)
					end
				end
				local info = app.wavetable_info(wavetable)
--				local name = sfx.instrument_name(instrument)
--				if name == "" then name = "---" end
				print(string.format("%06x", info.addr), x + 2, y + 2, 49)
--				print(":", x + 2 + 16, y + 2, 58)
--				print(name, x + 2 + 14, y + 2, 57)
			end
	})
		
	function el:draw(msg)
		rrectfill(0, 0, self.width, self.height, 0, 59)
		clip()
		line(0, 11, self.width - 1, 11, 60)
		app.draw_borders(0, 0, self.width, self.height)
	end

	return el
end


-------------------------------------------------------------------------------
-- Wavetable Display
-------------------------------------------------------------------------------


function ui_wavetable.attach_wavetable_display(parent, el)
	parent:attach(el)
	el.wave = 0
	function el:draw()
		local info = app.wavetable_info(app.wavetable)
		rrectfill(0, 0, self.width, self.height, 0, 59)
		ui_visual.draw_wave(info.addr, info.width, info.height,
			el.wave, 0,
			self.width, self.height,
			60)
		print(string.format("address: %06x", info.addr), 4, 4, 57)
		print("width: " .. tostr(info.width))
		print("height: " .. tostr(info.height))
		print("instruments: " .. tostr(#info.instruments))
		--[[
		for inst in all(info.instruments) do
			print(tostr(inst) .. " \0")
		end
		--]]
		clip()
		app.draw_borders(0, 0, self.width, self.height)
	end
	function el:mousewheel(msg)
		el.wave -= msg.wheel_y
		el.wave = mid(el.wave, 0, 255)
	end
	return el
end


-------------------------------------------------------------------------------
-- Wavetable Temporary Widget
-------------------------------------------------------------------------------


local wt = nil
local wave = 25


function ui_wavetable.attach_temp_widget(parent, el)
	el.width = 480 - 2 * 4
	el.height = 270 - 11 - 100
	parent:attach(el)
	

	-- TODO	
	wt = Wavetable.new(256, 32)
	wt:set_wavetable(drakma_cosine2saw2reso)

	
	function el:update()
		if not wt then return end
		
		local _, _, _, _, wheel_y = mouse()
		if wheel_y > 0 and wave > 0 then
			wave -= 1
		elseif wheel_y < 0 and wave < wt.height - 1 then
			wave += 1
		end
	
		if key("alt") then
			if keyp("1") then
				wt:set_wavetable(cz_saw)
			end	
			if keyp("2") then
				wt:set_wavetable(cz_square)
			end	
			if keyp("3") then
				wt:set_wavetable(cz_pulse)
			end	
			if keyp("4") then
				wt:set_wavetable(cz_doublesine)
			end	
			if keyp("5") then
				wt:set_wavetable(cz_sawpulse)
			end	
			if keyp("6") then
				wt:set_wavetable(cz_reso1)
			end	
			if keyp("7") then
				wt:set_wavetable(cz_reso2)
			end	
			if keyp("8") then
				wt:set_wavetable(cz_reso3)
			end
			if keyp("9") then
				wt:set_wavetable(split(cz_saw, cz_reso1))
			end
			
			if keyp("q") then
				wt:set_wavetable(drakma_cosine2saw)
			end
			if keyp("w") then
				wt:set_wavetable(drakma_triangle2saw)
			end
			if keyp("e") then
				wt:set_wavetable(drakma_sine2saw)
			end
			if keyp("r") then
				wt:set_wavetable(drakma_square2saw)
			end
			if keyp("t") then
				wt:set_wavetable(drakma_cosine2saw2reso)
			end
			if keyp("a") then
				wt:set_wavetable(drakma_cosine2square)
			end
			if keyp("s") then
				wt:set_wavetable(drakma_triangle2square)
			end
			if keyp("d") then
				wt:set_wavetable(drakma_triangle2square2saw)
			end
			if keyp("f") then
				wt:set_wavetable(drakma_pulsewidth)
			end
			if keyp("g") then
				wt:set_wavetable(drakma_sawpulse)
			end
			if keyp("z") then
				wt:set_wavetable(drakma_saw2reso)
			end
			if keyp("x") then
				wt:set_wavetable(drakma_square2reso)
			end
			if keyp("c") then
				wt:set_wavetable(drakma_triangle2reso)
			end
			if keyp("v") then
				wt:set_wavetable(drakma_sawpulse2reso)
			end
			if keyp("b") then
				wt:set_wavetable(drakma_sawpulse2resoalt)
			end
		end
	end
	
	
	function el:draw()
		--print("(the wavetable editor is coming soon!)", 158, 70, 5)
		---[[
		print("num_instruments: "..sfx.num_instruments(), 4, 60, 58)
		print("num_tracks: "..sfx.num_tracks(), nil, nil, 58)
		print("num_patterns: "..sfx.num_patterns(), nil, nil, 58)
		print("patterns_address: "..string.format("%x",sfx.patterns_address()), nil, nil, 58)
		print("instruments_address: "..string.format("%x",sfx.instruments_address()), nil, nil, 58)
		print("tracks_address: "..string.format("%x",sfx.tracks_address()), nil, nil, 58)
		-- Temporary wavetable display		
		if not wt then return end
		local ox <const> = 270
		local oy <const> = el.height // 2
		rrectfill(ox, oy - 50, 200, 101, 0, 59)
		line(ox, oy, ox + 200 - 1, oy, 60)
		local last_y
		for i = 0, 199 do
			local sample = (i * wt.width) // 200
			local value = wt:get(wave, sample)
			local y = oy - math.floor(0.5 + 50 * value)
			if last_y then
				line(ox + i, last_y, ox + i, y, 27)
			end
			pset(ox + i, y, 26)
			last_y = y
		end
		print(string.format("%d", wave), ox + 4, oy - 60, 19)
		--]]
	end
end


return ui_wavetable
:: src/undo.lua
--[[pod_format="raw",created="2026-01-29 15:20:29",modified="2026-02-19 21:34:53",revision=18655]]
local app = require "src/app.lua"
local selection = require "src/selection.lua"


local undo = {}


local undo_stack


local count = 1
function undo.init()
	undo_stack = create_undo_stack(
		function()
--			notify("checkpoint "..count) count += 1
			return {
				sfx = userdata("u8", 0x40000):peek(0x30000),
				app = {
					-- Shared State
					pattern = app.pattern,
					track = app.track,
					instrument = app.instrument,
					-- Synth State
					node = app.node,
					wt = app.wt,
					-- Tracker State
					base_note = app.base_note,
					base_volume = app.base_volume,
					jump_step = app.jump_step,
					-- UI State
					view = app.view,
					detail = app.detail,
					track_header = app.track_header,
					toolrack_tab = app.toolrack_tab,
					row_height = app.row_height,
					starting_row = app.starting_row,
					env_advanced = app.env_advanced,
				},
				selection = selection.state(),
			}
		end,
		function(state)
			state.sfx:poke(0x30000)
			-- Shared State
			app.pattern = state.app.pattern
			app.track = state.app.track
			app.instrument = state.app.instrument
			-- Synth State
			app.node = state.app.node
			app.wt = state.app.wt
			-- Tracker State
			app.base_note = state.app.base_note
			app.base_volume = state.app.base_volume
			app.tracker_state = state.app.tracker_state
			-- UI State
			app.view = state.app.view
			app.detail = state.app.detail
			app.track_header = state.app.track_header
			app.toolrack_tab = state.app.toolrack_tab
			app.row_height = state.app.row_height
			app.starting_row = state.app.starting_row
			app.env_advanced = state.app.env_advanced
			-- Refresh
			app.refresh_gui = true
			-- Selection
			selection.set_state(state.selection)
		end,
		0x81 -- (0x1 binary  0x80 pxu rle)
	)
end


function undo.checkpoint()
	undo_stack:checkpoint()
end


function undo.undo()
	undo_stack:undo()
	app.update_track_patterns()
end


function undo.redo()
	undo_stack:redo()
	app.update_track_patterns()
end


return undo
:: src/waves.lua
--[[pod_format="raw",created="2026-01-23 20:54:55",modified="2026-02-19 21:34:53",revision=27506]]
----------------------------------------------------------------------------------------------------
-- Transforms
----------------------------------------------------------------------------------------------------


function nes_slope(func, coeff)
	local coeff = coeff or 2
	return function(x, w)
		local value = 2 * func(x, w) - 1
		if value > 0.0 then
			value -= x * coeff
		else
			value -= (1 - x) * coeff
		end
		value /= 1 + coeff
		local y = 0.5 + value / 2
		return y
	end
end


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


function bitcrunch(func, res)
	res = res and (res - 1) or 15
	return function(x, w)
		return math.floor(0.5 + res * func(x, w)) / res
	end
end


function phase(func, ph)
	return function(x, w)
		return func(x + ph, w)
	end
end


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


function split(funcA, funcB)
	return function(x, w)
		if x < 0.5 then
			return funcA(2 * x, w)
		else
			return funcB(2 * x - 1, w)
		end
	end
end


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


function mask(func1, func2)
	return function(x, w)
		return 1 - (1 - func1(x, w)) * (1 - func2(x, w))
	end
end


function multiply(func1, func2)
	return function(x, w)
		return func1(x, w) * func2(x, w)
	end
end


function multiply_bipolar(func1, func2)
	return function(x, w)
		local value1 = 2 * func1(x, w) - 1
		local value2 = 2 * func2(x, w) - 1
		return 0.5 + (value1 * value2) / 2
	end
end


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


function inverse(func)
	return function(x, w)
		return 1 - func(x, w)
	end
end


function reverse(func)
	return function(x, w)
		return func(x, 1 - w)
	end
end


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


function sequence(...)
	local funcs = {...}
	local count = #funcs
	return function(x, w)
		local idx = 1 + math.floor(0.5 + w * (count - 1))
		return funcs[idx](x, w * count % 1.000000000001) -- TODO
	end
end


----------------------------------------------------------------------------------------------------
-- Basic Waves
----------------------------------------------------------------------------------------------------


function w_cos(x, w)
	return 0.5 + cos(x) / 2
end


function w_sin(x, w)
	return 0.5 + sin(x) / 2
end


function w_saw(x, w)
	return x % 1.0
end


function w_triangle(x, w)
	x = x % 1.0
	if x < 0.5 then
		return 1 - (2 * x)
	else
		return (2 * x) - 1
	end
end


w_cotriangle = phase(w_triangle, 0.25)


function w_pulse50(x, w)
	x = x % 1.0
	if x < 0.5 then
		return 1
	else
		return 0
	end
end


w_square = w_pulse50


function w_pulse75(x, w)
	x = x % 1.0
	if x < 0.75 then
		return 1
	else
		return 0
	end
end


function w_pulse25(x, w)
	x = x % 1.0
	if x < 0.25 then
		return 1
	else
		return 0
	end
end


function w_pulse12(x, w)
	x = x % 1.0
	if x < 0.125 then
		return 1
	else
		return 0
	end
end


function w_pulse01(x, w)
	x = x % 1.0
	if x < 0.0078125 then
		return 1
	else
		return 0
	end
end


function w_trapeze(x, w)
	x = x % 1.0
	if x < 0.5 then
		return 0
	else
		return (2 * x) - 1
	end
end


w_triangle16 = bitcrunch(w_triangle, 16)


nes_triangle = nes_slope(phase(w_triangle16, 0.75), 1)


nes_pulse12 = nes_slope(w_pulse12, 1)
nes_pulse25 = nes_slope(w_pulse25, 1)
nes_pulse50 = nes_slope(w_pulse50, 1)
nes_pulse75 = nes_slope(w_pulse75, 1)


nes_waveforms = sequence(nes_triangle, nes_pulse75,
	nes_pulse50, nes_pulse25, nes_pulse12)


----------------------------------------------------------------------------------------------------
-- Phase Distortion
----------------------------------------------------------------------------------------------------


--[[
	y = a * x + b
	0 = a * 0 + b
	b = 0
	py = a * px
	a = py / px
	1 = c * 1 + d
	d = 1 - c
	py = c * px + d
	py = c * px + 1 - c
	py - 1 = c * (px - 1)
	c = (py - 1) / (px - 1)
]]
function bend(p0x, p0y, p1x, p1y)
	return function(x, w)
		local px = p0x + (p1x - p0x) * w
		local py = p0y + (p1y - p0y) * w
		
		local a <const> = py / px
		local c <const> = (py - 1) / (px - 1)
		local d <const> = 1 - c
		
		if x < px then
			return x * a
		else
			return x * c + d
		end
	end
end


function doublebend(funcA, funcB)
	return function(x, w)
		if x < 0.5 then
			return funcA(2 * x, w) / 2
		else
			return 0.5 + funcB(2 * x - 1, w) / 2
		end
	end
end


function distort(wfunc, bfunc)
	return function(x, w)
		return wfunc(bfunc(x, w), w)
	end
end


function reso(func)
	return function(x, w)
		local r = (15 * w) + 1
		return func((r * x) % 1, w)
	end
end


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


cz_saw =
	distort(
		w_cos,
		bend(0.5, 0.5, 0.0, 0.5)
	)


cz_square =
	distort(
		w_cos, 
		doublebend(
			bend(0.0, 0.0, 1.0, 0.0),
			bend(0.0, 0.0, 1.0, 0.0)
		)
	)


cz_pulse =
	distort(
		w_cos, 
		bend(0.0, 0.0, 0.99, 0.0)
	)


cz_doublesine =
	distort(
		split(w_cos, w_cos),
		bend(0.5, 0.5, 0.01, 0.5)
	)


cz_sawpulse =
	distort(
		w_cos,
		doublebend(
			bend(0.0, 0.0, 0.0, 0.0),
			bend(1.0, 1.0, 0.0, 1.0)
		)
	)


cz_reso1 =
	mask(
		reso(w_cos),
		w_saw
	)


cz_reso2 =
	mask(
		reso(w_cos),
		w_triangle
	)


cz_reso3 =
	mask(
		reso(w_cos),
		w_trapeze
	)


cz_saw_reso1 = split(cz_saw, cz_reso1)	

	
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


drakma_cosine2saw =
	distort(
		inverse(w_cos),
		bend(0.5, 0.5, 1.0, 0.5)
	)


drakma_triangle2saw =
	distort(
		inverse(w_triangle),
		bend(0.5, 0.5, 1.0, 0.5)
	)


drakma_sine2saw =
	distort(
		w_sin,
		doublebend(
			bend(0.5, 0.5, 0.0, 0.5),
			bend(0.5, 0.5, 1.0, 0.5)
		)
	)


drakma_square2saw =
	reverse(
		distort(
			w_saw,
			doublebend(
				bend(0.5, 0.5, 1.0, 0.0),
				bend(0.5, 0.5, 0.0, 0.99999)
			)
		)
	)


drakma_cosine2square =
	distort(
		phase(w_cos, 0.5), 
		doublebend(
			bend(0.5, 0.5, 1.0, 0.0),
			bend(0.5, 0.5, 1.0, 0.0)
		)
	)


drakma_triangle2square =
	distort(
		phase(w_triangle, 0.5),
		doublebend(
			bend(0.5, 0.5, 1.0, 0.0),
			bend(0.5, 0.5, 1.0, 0.0)
		)
	)


drakma_triangle2square2saw =
	sequence(drakma_triangle2square, drakma_square2saw)
	

drakma_pulsewidth =
	distort(
		w_square, 
		bend(0.5, 0.5, 1 - 0.001953, 0.5)
	)
	
	
drakma_sawpulse =
	split(
		distort(
			w_cos,	
			bend(0.5, 0.5, 0.0, 0.5)
		),
		distort(
			w_cos,
			doublebend(
				bend(0.5, 0.5, 0.0, 1.0),
				bend(0.5, 0.5, 1.0, 0.0)
			)
		)
	)

	
drakma_saw2reso =
	mask(
		reso(reverse(drakma_cosine2saw)),
		w_saw
	)

	
drakma_square2reso =
	mask(
		reso(reverse(drakma_cosine2square)),
		w_trapeze
	)

	
drakma_triangle2reso =
	mask(
		reso(w_triangle),
		w_triangle
	)


drakma_cosine2saw2reso = sequence(drakma_cosine2saw, drakma_saw2reso)

	
drakma_sawpulse2reso = mask(reso(w_cos), inverse(drakma_pulsewidth))

	
drakma_sawpulse2resoalt =
	mask(
		reso(reverse(cz_sawpulse)),
		distort(
			w_trapeze, 
			bend(0.5, 0.5, 1 - 0.001953, 0.5)
		)
	)

:: src/wavetable.lua
--[[pod_format="raw",created="2026-01-23 13:43:16",modified="2026-02-19 21:34:53",revision=27841]]
-- TODO: move into pfx

local Wavetable = structure {
	-- width: Int -- number of samples in a wave
	-- height: Int -- number of waves in the wavetable
	-- samples: Array[Int]
}


function Wavetable.new(width, height)
--	local samples = {}
--	for i = 0, width * height do
--		samples[i] = 0.0
--	end
	samples = userdata("i16", width, height)
	return Wavetable {
		width = width,
		height = height,
		samples = samples,
	}
end


function Wavetable:get(wave, sample)
	assert(0 <= wave and wave < self.height) -- TODO: should be < height?
--	assert(0 <= sample and sample < self.width) -- TODO: should be < width?
	local sample = sample % self.width
	local value = self.samples:get(sample, wave)
	return value / 0x7fff
end


function Wavetable:set(wave, sample, value)
	assert(0 <= wave and wave < self.height) -- TODO: should be < height?
	assert(0 <= sample and sample < self.width) -- TODO: should be < width?
	assert(-1.0 <= value and value <= 1.0)
	local sample = sample % self.width
	self.samples:set(sample, wave, value * 0x7fff)
end


function Wavetable:set_wave(wave, func)
	-- func: (x: Float) -> Float
	-- `x` is in [0,1] (instead of [0, pi])
	-- `result` is in [0, 1] (instead of [-1, +1])
	local start = wave * self.width
	local length <const> = self.width
	for i = 0, self.width - 1 do
		local value = 2 * func(i / length) - 1
		self:set(wave, i, value)
	end
end


function Wavetable:set_wavetable(func)
	-- func: (x: Float, w: Float) -> Float
	-- `x` is in [0,1] (instead of [0, pi])
	-- `w` is in [0,1] (0 = first wave of the wt, 1 = last wave)
	-- `result` is in [0, 1] (instead of [-1, +1])
	for wave = 0, self.height - 1 do
		local w = wave / (self.height - 1)
		local wavefunc = function(x) return func(x, w) end
		self:set_wave(wave, wavefunc)
	end
end


function Wavetable:poke(addr)
	self.samples:poke(addr)
end


return Wavetable
:: todo.txt
--[[pod_format="raw",created="2024-04-10 20:46:30",icon=userdata("u8",16,16,"00000101010101010101010101000000000112121212121212121212120100000107011212121212121212121212010000010112121212121212121212120100000112121212121212121212121201000107011212121212121212121212010000010112121212121212121212120100000112121212121212121212121201000107011212121212121212121212010000010112121212121212121212120100000112121212121212121212121201000107011212121212121212121201010000010101010101010101010101070100000101070707070707070707071201000000011212121212121212121201000000000001010101010101010101000000"),modified="2026-02-19 21:34:53",revision=26211]]
# Things To Do

## Before Next Release

## Soonish

- fix: channel dialog stays open when changing pattern
- fix: follow playhead for looping tracks and tracks with different speeds.
- add: shift-ctrl-V for insert and paste
- add: S-C-Enter to insert rows without moving.
- add: num field entry for tuning in fm node (should support fractions).
- add: scroll-wheel support for synth knobs and fields.
- add: track config for beat and bar length.
- add: metadata (key...)
- add: drag channels left and right to reorder them.
- add: drag tracks (in track picker) to reorder them.
- add: contextual help for entering FXs (especially their parameters).
- add: group patterns together
- add: save some UI state in the metadata (view, current pattern, ...)

## Whenever

- allow editing note, instr., vol, fx in a single go, then jump.
- related: chord mode (when selection span multiple channels).
- paginated scrolling mode, both for cursor movement and playhead
  following; configurable length: screen, beat or bar.
- enter key to preview block selection (plays all the steps in the
  selection).
- show next and previous pattern in notegrid?
- add different coloring: by instruments, scale, harmony, volume, (fx?).
- add "selection" tools in the tool-rack.
- add "edition" tools in the tool-rack.
- add "harmony" tools in the tool-rack.

## Longterm Roadmap

- improve track picker.
- add track editor.
- add wavetable creator.
- add wavetable importer.

:: .info.pod
--[[pod,author="drakmaniso",created="2024-04-16 13:35:13",icon=userdata("u8",16,16,"00000001010101010101010101000000000001070707070707070707070100000001071818181818181818181807010001071818181818180718181818180701010718181818181807071818181807010107181818181818071807181818070101071818181818180718071818180701010718181818070707181818181807010107181818070707071818181818070101071818181807071818181818180701010718181818181818181818181807010106071818181818181818181807060101060607070707070707070707060601000106060606060606060606060601000000010606060606060606060601000000000001010101010101010101000000"),lowcol_icon=false,modified="2026-02-19 21:34:53",notes="A music tracker (and instruments\neditor) for \".sfx\" files.",runtime=24,stored="2024-04-16 11:37:51",title="WaveMaker",version="0.2.1",workspaces={{location="main.lua",workspace_index=1},{location="gfx/0.gfx#135",workspace_index=2},{location="sfx/0.sfx",workspace_index=4},{location="pal/0.pal",workspace_index=7}}]]
:: fonts/.info.pod
--[[pod,created="2026-01-30 07:12:02",modified="2026-02-19 21:34:53"]]
:: fonts/cozi.font
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTIxIDE5OjIyOjIwIixtb2RpZmllZD0iMjAyNi0w
MS0wNyAwNzoyODo0MSIscmV2aXNpb249MzRdXWx6NACxAwAAVwcAAPAYcHh1AAMoAAgAAAQFCgsA
AQOQD4APmA_ID-gPmQ_JD-APj3_ID4kvEAARiBgAEYkEAKSYD4gfmA-4L4gIGQDxsQAeD5gIH7gP
ifAwbz8gLUANDzMNQAwPDAxADAAMQCwwDzAPPA0JDzAgAw8PDQcDEA8_PwZAPzAPPgAPYw82DxwP
PggGCDAPGIAPDA8YUB8MIBpADwQKBLBCAAIAFXAKDx8KCwoQBA8ODwEPBggPBwQQDwkEAgEgAgUC
DwsFCgASUAgEMgQIAgQ4BAIQBA8VDw4PFQQwBA8OBGAUAjAPB4ACEBQSHwEADwYBDw0PCxEPBgAE
DjQPDgAOAQgEAg8BBwkA8jIIAQ4ABA4VBxQABwwPBygJAA4cCREOAAcYBCIADhEOEQ4ADhEPDhgO
MAIAAkAEABQCEAQCDAIEMAcABzACBAgEAk8A8BsAAgANDxEfHQ8NDA0ADhEHIQAJEQkRCQAOASwB
DgAPAwUhBQMABxwJHAcGAKAsAA0cDw0RDQAhKQDwFUIJAA04AQ4AEQUDBREAXAcADxEPGx8VLxEA
AQ8LDw0xAA5BDk8AQSwADiH6ALAJEQkDBQEADgEMDr8A8F0LVABRDgBBBQMALxEfFQ8bDxEAIQ4h
ACENGAkABwgEAhwHAA1SDQAcEhQADVgNAgWwCQACBHANIQ0AHAkhCSANLA0AGA0hDSAOAQcMDQAP
DBIHIhANIQ0IDhwJMQACAAMiCQAIAAYoAQ4cAQV4APAlA0IGIA8LHxUfESAJMSAOIQ4QCSEJHAAN
IQ0YEA8NAywgDQwOCAkAEgciBiAxDSAhBQMgH5kA9h8KIBEOERAxDQgOEAcIDgwHAA8wKA4YCmIA
DigKGA4gDg8VBiATFiBvfwAPVQ8qBADwCAAPQQ9jD38fXQ93Dz4ACx9jD3cLD0ELJwEWRAQA8BAA
DwQGD3wLDx8PGA8QAA8cDyYfXw9-Cw8cAA8iD3cfCgChCAAPKg8cDzYPd38C8AEqAB8cCw9dDxwf
FAAIDxwLLgCxKg86AAsPZw9jD2dkABELeADxBX8PYwsADxgPeCgHCQALD2MPaw9jHwDzCAgPFA8q
D10PKg8UCDAPVTALD3MPYw9zHAAxHA9-bwDxBCIQD38PIg8UCAQPIg9-AAsPdx8-APMDEA8KDwQA
D1APIBAPEQ8qD0QABwBxCw9rD3cPa0cAQQ9-AAUCAPQCb1UQD34PQg9SD0oPQg9_EAEMAEABEAEN
CgAfDQkA----aFAPSg0BAA==
:: fonts/p8_mod.font
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI2LTAxLTMwIDA3OjEyOjQzIixtb2RpZmllZD0iMjAyNi0w
MS0zMCAwNzoxNDozNCIscmV2aXNpb249Ml1dbHo0AHsFAACjBQAA8INweHUAAygACAAABAQIBhAD
8GpHMCdABwUHQAUCBUAFAAVAJTAEBgcGBCABAwcDASAHIUAkByAFBwIHAkACcAECUBMgFVACBQLA
IgACIBVQBQcFBwUgBwMGBwIgBQQCAQUgEwYFByACAVACIQIgAiQCIAUCBwIFMAIHAmACAUAHgAIg
BCIBIAclByADIgcgBwQHAQYA8QkGBAcgFQcUIAcBBwQHIBEHBQcgBzQgBwUJAPANBQcUMAIAAkAC
AAIBIAQCAQIEMAcABzABAgQCATwA8DQAAiACFQEGMAYFBwUwEwUHMAYRBjADFQMwBwMBBjAHAxEw
BgEFBzAVBwUwBxIHMAcSAzAFAxUwIQYwFxUwAyUwBhUDPADwFQEwAgUDBjADBQMFMAYBBAMwByIw
JQYwFQcCMBUXMAUSBTAFBxYA8B8EAQcgAyEDIAEiBCAGJAYgAgWQByACBFAHBQcVIAcFAwUHIAYh
BiADJQMgBwED3wCgAQMRIAYRBQYgFSIAAPcA8AIiAyAVAxUgMQcgFyUgAzUgBi0AgAUHESACFQMG
RQDwCxUgBgEHBAMgBzIgNQYgJQcCICUXIBUCFSAVIQHyFAcEAgEHIAYCAwIGIEIgAwIGAgMwBAcB
QAIFAjBPfyAPVQ8qBADyBiAPQQ9-H10PPiAOH2MPdw4gDxEPRAQA8DIgBA88DxwPHg8QIA8cDy4e
DxwgDzYeDxwIIA0PNg93DzYNIB0ODQ8UIA0OD38PKg86IA4PZw9jD2cOIA9-D10Pf1sA8BEgDzgY
Hw4gDg9jD2sPYw4gCA0ODQhAD1VADg9zD2MPcxIAoA9-Dg8iIA4NCA0pAPAKdx9jDjAFD1IPIEAP
EQ8qD0QwDg9rD3cPa1cA8CIADAAMIE9VIA8OBA8eDy0PJiAPER8hDyUCIA8MDx4fIA0gCA8eCA8k
DxogD04EDg9FIgBwIg9fHxIKIBkAsDwPEQYgDxAPDAIL1wDweCIPeh8iDxIgDx4PIAACDzwgCAkP
EAILICIPIg0gCA4ICwggDxIPPw8SAg0gCQ8QD34EDzggAgcPMgIDIA8PAg8ODxANIA4fQA8gDxgg
Dg8QGAEgCA84BAIJIAMHDxIPeA8YIA96D0ICCg9yIA8JDg9LD20PZiAPGg8nDyIPcwMgCQ9KH0kP
RmUAEToEAPJkGiAPIw9iHyINIAsACA8qD00wCw8SDyEPQCAPfQ95DxEPPQ9dIA4JCA8eDy4gBg8k
D34PJgEgDyQPTgQPRgkgCgkPWg9GDzAgDx4EBQ9EDzggDxQODyQYIA86D1YPUg8wCCAEDQQFBiAI
Ag4PIA0gHyIPJrwA8gIMDyQPcg8wIAQPNg8sDyYPZBMANEIPMK8AECMoAfAaDg9kDQ8oD3ggBAIG
DysPGUAPDgEIMAoPHw8SBDAEDw8PFQ8NMAQLBg-KAfAaIA8UBAIgDzAIDw4YIAgODyIPIAwgDigO
IAEPfgwPFA8SIAQODyQPIgNrAUAOCCAJDQDxAQEIIAQPfA8SAQggDi8gDiDkAPECJA8gASAGBw8m
AQsgDgcBDAU6AACNAVAPIg8kBxYA8AIPIg8tDzALIA8cCA4IBCAfKhYAMA8cAA0A8AcUDQ8kBCAI
DhgEMA0QDiAOBw8oAQ8skwDzDjAPXgggJwEPDiABHyQPRA9CIAIPHhINIA4XAQsgewFgMAgOCB8q
NgDRFAgBIAkADgAPHiAIBB4BQH4gD0BNACBoBnMBMQoECZkA8BMUIA0hDiAKAQoBCiAOAA4HDCAj
BwEgLxQPVA8yIBIPIg8SIAFhLyIOIA4FvQDwEgcJBwwgBhcBDw4wDxUBDwgGMAQKDxQEQAsPCAow
DQwBDXAAoGMBCCAIAQMECCA=
:: gfx/.info.pod
--[[pod,created="2024-03-24 00:48:06",modified="2026-02-19 21:34:53",stored="2024-03-24 00:48:06"]]
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2Iixtb2RpZmllZD0iMjAyNi0w
Mi0xOSAxMToyNzowOCIscmV2aXNpb249MTA0MzNdXWx6NAC4EgAAYlIAAPMle1swXT17Ym1wPXB4
dQBDIAgIBMAXQAcQFyAHEBcQByAXEAdAF8AsZmxhZ3M9MCxwYW5feAgA13k9MCx6b29tPTExfSxD
APYPEBAE8AgvOcAOBx6wDhceoA4nHpAOBw4XDpAOBx4HBgDiDgceYD4HLmAeNw6ADkcEAH8eJx6Q
TvAGcAALHTZvAPAKCj85kC4XDnAuNw5QLlcOUA5HHgcOUA4nPgYAQQcuEA4IADIOEC4IAP8TAB4n
DjAuBw4ADjcOIB4nDgAeFx4gDjcOED4wHhceoD7wCoEAHXITPzmgHhce3ADwBoAeBx4HHnAOBz4H
DmAeBz4HjgcGDgIAEgcGAGGOBz4HHmAfABFwKwASgBMBAnwAHwN8ABn0FxMOBP84Awf-OQMH-gAP
Oh7mHR5WDxJ2HR5WHGYdHlYsVh0eVjxGCgABFACfDHYdHuYdDv0VaAALHzloAABT-zdDR94CAC-_
Q0AAHwmoAACrAIgvJFYdHkZMRgUAAasAAiAAX-0BDv0CpwAhMUQn7qUAT_4n-kRAABn-BwgIBDAH
YBdQBwAHQAcAByAnMDdAF7BCAAsZN0IA8QMbBgQgLztQLlAuQB4PER4wHg0EAFMgHi0eEAQA-wAA
Hk0_TT5NLm0ebR5t-gxeAAscOF4Acv87DG8RHzsEAFMvO08RPwQAZR87AB4vEWYANSAeDX4AIEAu
kQAfIGoAGaAMDARATzlQHi86QgCYLg0eIA4NTg0OBgAgEC4YAEAAHh0O1ADfLU4QDi0eUB4NHnAu
cGoAGf8KBwgELzkADgAeUA5QDhAOIA4QHhBeMB5ADrAADCwxNEcAkSAPOUAeMF4QHkYAnw5QDlAe
AA4ALkcAHVLgTzkQTgIAH3A8ABqgDQ0EkA87DzkGgAYAIBZwBgAgJmAGACA2UAYAIEZABgAgVjAG
AFEWLzoWIAkAow86Hw4PJQ86BhAPALAPDg85HyUPJA85ABIAECYSABEvEAAADwD-AjYPOi8lHyQf
OVYOLyQOhi4WngIZ8QcwCQQPOQb-EhwGDzoPORb-EhoWDzoAEwBRGgYPOhAUAFEYFg86IBQAURgG
DzowFABRFhYPOkAUAP8AFgYPOlAPOfYYDzpg-hgwfgAZ8AQgCgQQ-zkMIA7POA86DsYOAA7fCQDx
E9YNDi84FgwmDCYMDQ5GHAYcNg0OHAYMBgwGLAYsDQ42DAYCABMmFgBKFhwWHBYAIxYcKgAiHBYS
AP8B3A0O1g0ADcwNDsYNIP0MEKUAIvElxg86Ds8SDgAO1g86Dt8SDzoOJh84Bi0GLQYPOg5PEhcM
FzwPOg4WDQYNBg0mDSYLDjwHDAIAIiwLFgBKHRYdFhYAIx0WKgAiFxwSAO-WCw7cCwALxgsOzAsg
_6kAG-8CDQ0E8CoPN7AOkE6QDrAO8Co9AAwPqwIyJy84qQImTzijAiVPOJ8CIU84nQIfOJ0CHfoI
OAoE8CgfIP8lJC8gDyXwJA4PIA7wJh4DADwO8ChUAMMuMTIzODA5NTIzODFgAKItMS4xMTQyODU3
BgACbwAaNW8ARAgEDyVXAAZgAAB1AG8kDi3_JB1oADdPLyQQHgIABBQ_eQAE3wAfYHcANKwFBQRg
ByAnAEdAUQAKhAEsMTY3ABAg9glvJyAXMAcAOwAdf0BHACcgB2A3AB1gAAcwFyAndAofIDsAHV9H
QEdARzUAGhAH4gB-QCcgRwBnYJ8CGc8HBQRgZwBHICdAByA4ABlBBQUEEIkBXxAHMAcQqwAbYAcE
EC86IEwD-wMADk0POQ5NDA5NDAAMLQwgLBCUCxoESgAAawY2DgAOYwYUDlwGEA5WBp8POQANLyQN
IC1eABthDAYEMBcgMwkxAAcQOQw1EAcACAATMBgAP0AXIAEBDh4wWQD-CghwBwAIYBcACAdgFwgA
B3AIBwAHYAgQF1BLABpRBQUEByCJABUgCAAPjQEaD98CFw_IAzQh8ASnAA83ABqlCwoEvzkvOg85
DwQA-xYfOQ86nzkPOm85EA4POi4NLhAODS4dHhAObQ4QTh0eUA4NHmAuyAca8QALCgQwLzlgHg86
DlAeHU5KADMeHS4SCpAOEG4Nng0eDQ4CAC8tvlkAHMrwCG85MA5POg4wDk0EAC9uwEsAGf8DBwcE
MAdAFzAnIDcwJ0AXUAcQPgAc7xAHUBdAJzA3ICcwF0AHIAEddb85LyUPOQ8EAIEfOQ8lnzkPJYUB
HyWFASMvMTCGAQMfJYYBLi8xMIcBBBYlfwEOhwEPTAAS8RkXFwTw_QHwBQEHAfAEARcB8AMBJwEA
AfAAATcBBwHgARcRJwHgEQcRHwASBx8AIPADCgBPBQHwDIYEGgBrAHKfMfACATcBBQD2AAABRwHg
ITcB0AFnAeBBB1gAH5dYAB4TbsMAAZ8AQgIRBxFMAAGzAEUEIfAEDQAQAxwAGALFAB9ubQAakBkZ
BPD-KgHwBz4AcAYBBxEAARDKAAAQAAAmAfAD0BFHAScBsAEHAUcRBxHAAVcRRgFgN0HwADEARQEQ
BYAAMwQBJ7AAPwcBMIwNGQ_uAQEkMeCrAVchBwHwAKwBBP4AHyISAiYBTwFtAQFHAfABVAEfVVYA
GvwpHx8E8B4F8EMF8AEF8AIPOkcO8AYOhw7wA8fwAefg9wFwBTAO9wEOMAVg9wMPP5AO9wMOkPcF
DYAEAAAZAKANQAUw9wMdEAVgMwD-Fw2w9wEdwOcd4McdwAUgDocOHQAFoAVADQ5HDi0gBYAFcG1Q
BfBwtREZDKwAEEasAKGGDvADxvAB5uD2rAAR9qwAEfasAIz2Aw6Q9gUNgAQAIg72rAAS9qwAEPas
AIH2AR3A5h3gxqwAFYasAB9GrAAq-CIH8EMH8AEH8AJvP-AGrvADzvAB7uD_AXAHMP4DMAdg-gMP
OpD_BA8hkP4FDzqA-gUNBAAQQCoAIB0QKwD-EQ2w-gEdwO4d4M4dwAcgrh0AB6AHQA1uLSAHgAdw
bVAHnwAeQeAH8A4DAB8kpAAPJwWQlQAPoQAPr-ABrh3wAw1uLcCbACAAygPzFRUH8AIHoAfwGU8-
8AKO4K6AByDOIAdg7pDuDzpw-gFw-gENYAQA-xgwBxD_AQ0AB1DuHXDuDZDOHaCuHcCOHaAHIA1O
LQAHgAdQTTAH8D_IBhlwGRkEsAfwCIQAP0AHQIYAMV-wAE3wRIMAGf8BCQcE8AVPOiBuEG4QbiBO
ANQDGtAJBwSgTz8gbhAOTw8OPwAfoD8AGt8cHAT-OggwDv84Bg85BwAA8QZe-QoPOQ79CgwO-ACd
DPAADi0sDi0IACwMEAkAuz4tDL4wDp0MDp0MBwAfvDcADGDwAA6d-gJmAAAEAGwsDv0GDDAFAB-8
5QkNDJ0I-wBXAGcwBwA3ADcABzBnAFcADR0AKAMfAUwBGo8MBQTwDQfwDjUAGo8LBQTwCwfwC2oA
Ho8JDypwDzLwCTkAHj8NDyqkAByvBwUEgCcwJzAngKcHDQ83ADUhFzDXCy8wFzsAHgB9DH9QB1AH
YCcgOwAaEAg7AFEwBzAXAAQAL3AnaQoblAcFBCcwBxAHIAQALycwAwQZBD8AIgAnBAAPPwAfrzcg
B1AnMAdQNyA5ACQvB1A5AB9PMEcQJzkAHwKjARAA6Q5PBzAnID4AIG8wJwAXACc_ACVFEAcgN6gB
D0AAIk8AVwAnQAAjECfZAhIwfwAPqwEbcAsGBAAnYAc7AZ_QB5AHIAdgJ2BAACIAeQEAZhAPRAAj
EjeDAAcEAB83QwAiAIYABAYAD0cAI2BHUAeQJ3ANAS9HUDsAIEAHkDdgBgAPOwAfEkBBAQ4-AA-D
ARogEBf3AD9gN1DFASoPRgArADwANFBHUAoAD4oAJgEGAA9IACYCUwIvN2AKAiOvAwUENwAXABcA
N_IHGjEDBQR6EwBwBQ85AB1PJxBHEDUAIC83EKMAHgKhAD83EAc5AB0-NxAnbgAfPzcQN0YBHzIn
EAcCAA_jAB4vAEduAB9PNwA3EKMAIR8AqhcehCcJBCYfOjYeAgB-Zg4POA85JgYACjVmHTYCADcm
HjYCAI8GDg84DSYODAQAAj8GHTY5AAQXZiYACAQACWkAD9cACxkz1gDwACoHBABPKABOAB4AHgA_
EAYA8hYvMBA9IB8yABwAHDAcABwAHjAeAB4QHRAdQB8qABsAG0ArEE4AEwChTRAfLAAaABpAKjoA
AygAkQAdEE8uADkgKRUAE04TAIAfNDAYMBgAGCYAFDAoAPwAHTAdMB0AHQBOMB4APQBNkgGgLTMu
MDg3MzAxNQYAFTLLGWQzLjczNjEBAB8yBwQBkhUJBPYGHzoWHgIAApABHwYGAAQXFgwADx4AWTMm
HRYCAC-2Bs4MGXgmHgQfOiYeAgAIbwAPBgARBwsADy8A-----9s5Bh0mAgAPdAUZoA8VBPYAvzom
Dq_5BUC99gG_CwATDQoAH6wJAAMfAKQSHEGALzkgRSUvIC7qEA0cNfcTn5BvOQD_CwBukDkAGs8N
BwTQrzkA-hcArtCqFRlQDQcEEI9nHyA-X2kfQA8-DzcLAEgPOQ5PBwAgAA0WAE8NII0QXQAhI184
fB8nXzh_HyVfOIAfJF84gh9PXzgvJGcAHQHhHxA3xAABKyAfOisgLB43KyAUOisgEjorIB86KyAi
vwcHBHBPN4BOgE5wOAAakBAKBBC-OiAOv6IBwN0POQ4dLzcNHA0sHQsAkgwNDA0MHQw9CwsAgxwN
HC0LDh0sFACf3QsAC70LILsQwQIZBHAAMJ8OHwYBVB8ODxefMSGjDxcPJScNBx0HHREAeh0HDQcN
Fw0QADIHDRcQABctLAARveIBbwy-JAwgvJAAGi8qBt0KK2pPLAA6ICrGCn8uMBkwGQAZxgoZD4EL
Cv8GDQcE4C8-gA4PNy5wTk84IE6ALvAFaxQaEA0vGEMeDyWAdQIxIE84dAIQcHICP4At4E0AGhAH
5CY0OFAOAgD-AEAvPyANDzctEE0QTSAtgBcqG3MNBIAeDyUgmAAREJYAEBCWAHQgLUAPOFAMAgAf
kFcAGkInGwS2iQ0t9glyDSH2CQQNI-YsMQ0s9gNpDUL2Ax02JAAGWQ0XxiAABAQAE8YnAAcpACf2
AyAAD0wARyMsHt0ABx0AAtcAH7ZaAhmQQBQE9gAfOnYeAgCN9g8OHzgPOVYGACf2Dg0ACRkAMQ8d
dgIAQ-YLHnYCAJn2BQ4fOA1WDhwEACf2BA0ABRUAEwU-AAdBACf2DyEAAAQAJ-YODQAABAAPdQAE
BiEAD3QASg_5AwwKhwKRPBUE9i2-Oia_AgABFggdFgYAIia9AgAi9i4nAAI0CDUWDqwEAAIgAAki
AAYdAA8hADwfLT0FGZBAGQT-OjH-OC4QJQMHAFkfOL83LwQAAhYATw83rz8IAAoQOQYrGb8EAC8f
OFkA-10EBwAvOS-nAhk-KAUEQwcAHwBDBwFgIE8sADsgQQcALgeXTR8uMBowGgAaKwcaPSkHD9cV
GSIQCVwIMU8Ob3AKMA4fJR8IYR84Lz8fOEEIATsIND84DxAAGx0gAAMQADIPPz8QADYNJw0gAG4A
DE8kbzhhCA8vBwwElgDAbzhPDg4ADi84Dz8vqwoxJScNuwgxHzgfEQAiLQcQAAQhACsNJxAAIwct
MAABjwAEIABvAAxvOE8klgAe3xELBCYXLz8HLhdWFy4GAA9eJwYnBicGAB8mdAAdVhYPPy8iBADD
Ng4vIg4tDi0ONg4tCABnLyMOLA4sEQAMCAAfLCAACh8WkgAaYR0JBP87DuMAAQYATwcuFx4OABcn
Jw4CAA8OAAkv-g6WAB2ATzsHPgeuB37ANoAHHhd_Bw4Hfus3AAIAAOA28AEnDgdetx4HDncOBw73
DQ7nCQBCLgcONyEAEB4hADAXbgcUADAeB15DAI8HjgdeB34HbokAGlINCQTfOCYCIR84-AAeHQYA
UicNJw0nBgAf3V4AGrEPCwT3AM8-Fw4vPLsBQRcOLzvcATMXDi0RAB8sEAALP873ANAAG3MNBN8-
LzsPBABTHz8vPA8EAB8fGABYL98-tgAb-wMLBN86Fi84Bi4WHzoWLgYuFh0GAAUQJggzCAYAD5IB
G3kfCwT3EA8-5gIAUgIPEAAsGScCAA8QAA4--g33ow8a8AYfCwRGJxYnhid2Nw8-Nw4XVicOB3Yt
A8EHDhceJxYnDgcOJ1YEAwACACIONyoDQQYnvhdVA1En-g0n7gkAIAYHXAMBJQARFzsDIScmPQBB
DhcOV2k7-wUHZicOBwY3Dgc2Jw43hic2J1YnZqoAGQHyAgVgAR8OCAANAxABDAgADvYCD2gDFAUC
AD-OFw4MAAwPZgAfAK47H-AyAP---------------------------2lQPTEwfX0=
:: label.qoi
b64$cW9pZgAAAeAAAAEOBAH_--Ho-f39-f39-f3T-qKIefk-wf7DAEz5P8H_ooh5zD-9-f39-BLE
P9cS0j-AEss-wBLWP-7DAEzZPxLLP8AS0D-_ooh5zj-9-f3OEsE-wBLBP8oSwT-IEj-IEsY-xxI-
Ej-Z-sMATD-N-qKIecU-xhLFP8cS0T8SwD8SyT8S2D-_wwBM2D-AEso-EtI--qKIec4--f39wBLB
P8ASwT-EEsE-wBLBP8USwj8SwT-IEsA-xxLGP8gSP8gSxj-I-sMATMA-0P6iiHk-Ej-WEtE-Ej-A
EsQ-wRLAPxLBPxLAPxLRP-7DAEzNP8ESPxLBPxLBPxLFP8ESwD8SwT8SwD8Syz-_ooh5zj-9-f3A
EsA-whLAP8QSwT-AEsE-xRLCPxLBP8gSPxI-xhLGP8QSxz-EEsI-wRI-yP7DAEw-Ej-L-qKIecE-
EsE-xhLFP8cS0T-AEj8Swz8Swj-CEj8SwD8S0T-_wwBMzD8Swj8SwT8SwT8SxD8Swj-CEj8SwD8S
yz-_ooh5xj8SxT-9-f3AEsA-whLAP8QSxj-FEsI-zBI-Ej-GEsY-xBLAP8MSwD-EEsI-wRI-yP7D
AEw-Ej-L-qKIeT8SP9oS0T8SwD8SxD-AEsE-EsI-wBLSP-7DAEzNP8ASwD8SPxI-EsE-EsU-wBLB
PxLCP8ASzD-_ooh5xT-BEsQ--f39wBLAP8ISwD-EEj8Swj8SP8USxT-HEsE-1hLAP8MSwD-EEj-B
EsI-xv7DAEzBP83_ooh5xT-GEsU-xxLRPxLAPxLGPxLAPxLBPxLAPxLRP-7DAEzPPxI-Ej8SPxLB
PxLHPxLAPxLBPxLAPxLLP-6iiHnGPxLFP-39-cASwD-CEsA-xBI-EsI-Ej-FEsU-xhLCP8gSxj-E
EsA-wxLAP8QSP8ESwj-F-sMATMI-zv6iiHnEP9YS0j-AEsE-EsA-wRLBPxLBPxLAPxLRP-7DAEzM
P8ESwT8SPxLBP8ESwD8SwD-BEsE-EsE-EsA-Ess--qKIec4--f39wBLBP8ASwT-EEsY-xRLFP8cS
wD-JEsA-whLAP8QSxz-EEsY-xv7DAEzAP_3_ooh5_z-_wwBM_z-_ooh5zj-9-f39-dwS_z-_wwBM
_z-_ooh5zj-9-f399v7a2tvQ-p_gpv52d339-f39-f392QKJe888Ff39-f39-f3ZAjvPPBXV-kBA
RMEVEcEVEcEV7BHBFRHBFRHBFewRwRURwRURwRXsEcEVEcEVERXuEcEVEcAVwBHBFewRwRURwBXA
EcEV7BHBFRHBFRHBFewRwRURwRURwBXOPMEVPMEVPBU8FcACO888FdURFREVERURFREVERXsERUR
FREVERURFREV7BEVERURFcMRFewRFREVERURFREV7hEVERXAERXCERXsERURFcARFcIRFewRFREV
ERXBERURFewRFREVERXCERXOPBXBPBXDPBXAAjvPPBXOERURFREVwBEVERURFREVEcEVwBEVERUR
Fd4RFREVERXAERURFREVERURwRXAERURFREV5REVERURwRXAEcAV5REVERURFcARFREVERURFRHB
FcARFREVERXeERURFREVwBEVERXAERXAEcEVwBEVERURFd4RFREVERXAERURFcARFcERwBXAERUR
FREV5REVERURwRURFREV7BEVERURwRXAERXOPMEVPMEVwDwVwQI7xj-BO8Q8FdURFREVERURFREV
ERXsERURFREVERXBERXsERURFcERFcERFewRFREVERURFREVERXsERURFcARFcARFe4RFREVwBEV
whEV7BEVERXBERURFREV7BEVERXBERXAERXQPBXBPBU8FcICO8Y--h43PD-AO8M8FdURwRURwRUR
wRXsEcEVEcEVwREV7BHBFRHBFRHBFewRwRURwRURwRXsEcEVEcEVEcEV7BHBFRHBFRHBFewRwRUR
wRURwRXsEcEVEcEVEcEVzTzBFTzBFTwVPBXAAjvGPwbAP8A7wjwV-f39-f39-dkCO8Y-BsE-wDvB
PBX9-f39-f392QI7xj8GPwbAPzvBPP4AAAD9-f39-f392QI7xj8GP8AGPzvBPDX_Q2J99jUT9jUT
9jX_iiTK0BPkNRP2NRP2NRP2NRP2NRXCAjvGPwY-wAY-O8E8NRP2NRP2NRP2NQ3QE_Q1E-Y1E-Y1
E-Y1E-Y1FcICO8Y-Bj8GP8A7wTw1E8L_9-CiwRPE-vGqbRPE-pPomsETLMETwv6O3NnBExrBE9A1
E-Y1E8I4wRPEFRPELMETLBPEGsETGhPSNQ3COMENxBXBDcATwCzBEyzBE8IawBPAGsET0DUTwTjB
E8UVE8QswRMswBPDGsATwBrBE9A1E8I4wRPEFcETwizBEyzAE8MawBPAGsET0DUTwjjBE8QVwRPC
LMETLMETwhrBExrBE9A1E8I4wRPEFRPELMETLBMsE8IawRMawRPQNf52d33CAjvDP8IGP8E7wjw1
E8E4E8f_8aptE8QsEywTLBMsE8QaExoTGhPQNRP2NRPBOBPHFRPELBMsEywTxBoTGhMaE9I1DcE4
DckVDcATwCwTLBPBLBPDGhPAGhPSNRPBOBPAOBM4wBPBFRPELBMsE8AsE8QaE8AaExoT0DUTwTgT
yRUTwiwTLBPALBPEGhPAGhMaE9A1E8E4E8cVE8QsEywTwSwTwhoTGhMaExoT0DUTwTgTxxUTxCwT
LBMsEywTwhoTGhMaExoT0DX_dnd9wgI7wj-ABsI-O8Q8NRPBOBPH-vGqbRMVE8IsEywTLBMsE8Ma
wBMaExoTx-6Uc7QTxjUTx-6xrW8Ty-5clWITyP48lZITyhwTxjUTwTgTOMATxBUTFRPCLBMsEyzB
E8IaExoTGsETxxwTxjUNwTgNxxXBDcATwCwTLBMswRPDGhPAGsATyBwTxjUTwTgTwDgTOMATwRUT
FRPCLBMsE8AsE8QaE8AaExoTxxwTxjUTwTgTOMATxBXBE8IsEywTwCwTxBoTwBoTGhPHHBPGNRPB
OBPHFcETwiwTLBPALMATwhoTGhMawRPHHBPGNRPBOBPHFRMVE8IsEywTLMETwhoTGhMawBPIHBPG
Nf52d33CAjvCPwbDPzvEPDUTwTgTx-7xqm3BE8IsEywTLBMsE8QaExoTGhPQNRP2NRPBOBPAOBPE
FcETwiwTLBMsEywTwhoTGhMaExoT0DUNwTgNxxUNwhPALBMsEywTxRoTwBoT0jUTwTgTwDgTxBXB
E8IsEywTwCwTxBoTwBoTGhPQNRPBOBPAOBPGFRPCLBMsE8AsE8QaE8AaExoT0DUTwTgTxxUTFRPC
LBMsE8EsE8IaExoTGhMaE9A1E8E4E8cVwRPCLBMsE8EsE8IaExoTGhMaE9A1-nZ3fcICO8I-BsM-
O8Q8NRPCOMETxv7xqm0TwizBEyzBE8IawRMawRPQNRP2NRPCOMETxhUTwizBEyzBE8IawRMawRPQ
NQ3COMENxBXBDcATwCzBEyzBE8IawRMawRPQNRPBOMETxxUTwizBEyzBE8IawRMawRPQNRPCOMET
xBXBE8IswRMswRPCGsETGsET0DUTwjjBE8QVwRPCLMETLMETwhrBExrBE9A1E8I4wRPGFRPCLMET
wSwTwhrBExrBE9A1-nZ3fcICO8I-wAbBP8A7xDw1E-Y1E-Y1E-Y1DdAT5DUT9jUT9jUT9jUT9jUV
wgI7wz-DO8U8NcM4Nf397Dg19jg19jg1-f3oFcICO888NcM4Nf397Dg19jg19jg1-f3oFcICO888
NcM4Nf3xOME1xP7xqm01xCzBNSzBNcIawTUawTXVODXYGsA1wBrBNdU4NfY4NfY4wTXEFTXPGsE1
GsE11TjBNcQVNc8awTUawTXR-nZ3fcICO888NcM4Nf3wODXH-vGqbTXELDUsNSw1xBo1GjXBGjXV
ODXZGjXAGjUaNdU4NfY4NfU4NccVNcYswTXEGjUaNcEaNdQ4NccVNcYswTXEGjUaNRo1GjXR-nZ3
fcICO888NcM4NdAgNcgQNcocNdAyNcsgNcgQNcocNco4NTjANcT_8aptNRU1wiw1LDUswTXCGjUa
NcAawDXHHDXLODXQIDXGGjXAGsE1xxw1yzg10CA1yBA1yhw1yzg10CA1yBA1yhw1yjg1xxU1FTXE
LME1xBo1GjXBGjXHHDXKODU4wDXEFTUVNcQswTXEGjUaNRrBNcccNcf_dnd9wgI7zzw1wzg1-fA4
NcA4NcT_8aptwTXCLDUsNcEsNcIaNRo1wRo11Tg12Ro1wBo1GjXVODX2ODX1ODXHFcE1xCzBNcQa
NRo1wRo11Dg1wDg1xBXBNcQswTXEGjUaNRo1GjXR-nZ3fcICO8ECwjvIPDXDODX98TjBNcb_8apt
NcIswTUswTXCGsE1GsE11Tg12BrBNRrBNdU4NfY4NfY4wTXGFTXNGsE1wRo11TjBNcYVNc0awTUa
NRo10f52d33CAjvAAsA8wALAO8c8NcM4Nf397Dg19jg19jg1-f3oFcICO8ACPALAPAI7xzw1wzg1
-f395zg19jg1-f3oFcICOwLAPALAPALAO8Y8NcM4Nf39-ec4NfY4Nf396BXCAjsCPALCPAI7xjw1
wzg1-fE4wTXE-vGqbTXPGsE1GjXXOME1xBXBNc0awDXAGsE11Tg19jg19jjBNcQVNc8awTUaNdc4
wTXEFcE1zRrBNRrBNdH_dnd9wgLBPALCPALGOzw1wzg1-fA4Ncf_8aptNcYswTXEGjUaNRo11jg1
yRU1xCzBNcUaNcAaNRo11Tg19jg19Tg1xxU1xizBNcQaNRo1GjXWODXHFTXGLME1xBo1GjUaNRo1
0f52d33CAsA8OwI7AjsCPAI7AjsCPAI7PDXDODXQIDXIEDXKHDXQMjXLIDXIEDXKHDXKODU4wDXE
-vGqbTUVNcQswTXEGjUaNRrBNcccNco4NccVwTXELME1xRo1wBo1GjXHHDXLODXQIDXIEDXKHDXL
ODXQIDXIEDXKHDXKODU4wDXEFTUVNcQswTXEGjUaNRrBNcccNco4NccVwTXELME1xBo1GjUawTXH
HDXH-nZ3fcICxzwCwjwCwDs8NcM4Nf3wODXAODXE-vGqbcE1xCzBNcQaNRo1GjUaNdQ4NccVNcYs
wTXFGjXAGjUaNdU4NfY4NfU4NcA4NcQVwTXELME1xBo1GjUaNRo11Dg1yRU1xCzBNcQaNRo1wRo1
0f52d33CAjvFAjwCwjwCO8A8NcM4Nf3xOME1xv7xqm01zRrBNRrBNdU4wTXEFcE1zRrBNRrBNdU4
NfY4NfY4wTXGFTXNGsE1GsE11TjBNcQVwTXNGsE1wRo10f52d33CAjvFAsA8AsA8AsA7wDw1wzg1
-f395zg19jg1-f3oFcICO8YCPALAPAI7wTw1-f3yODX2ODX2ODX9-egVwgI7xgLAPMACwDvBPDX9
-fI4NfY4NfY4Nf396BXCAjvHAsI7wjw1wzjBNcT_8aptwTXNGsE1GsE11TjBNcQVNcQswTUswTXC
GsE1wBrANcL_yqnqwDXABsE1BsE1xjjBNcQVNc8awTUawTXVODXYGsA1wBo1GjXVODX2ODX2OME1
xBXBNc0awTUawTXVOME1xBXBNc0awTUawTXR-nZ3fcICO888NcI4Ncf_8aptNcYswTXGGjUaNRo1
1Dg1xxU1xCw1LDUsNSw1who1GjUaNcQGNQY1BjUGNcEGNcU4NccVNcYswTXEGjUaNcEaNdU4Ndka
NcAaNRo11Tg19jg19Tg1xxU1xizBNcQaNRo1GjXWODXHFTXGLME1xBo1GjUaNRo10f52d33CAjvP
PDXCODXH-vGqbcE1xCzBNcQawTUaNRo1xxw1yjg1xxU1FTXCLDUsNSw1LDXCGjUaNRo1xAY1BjUG
NQY1BsE1xTg1OMA1xBU1FTXELME1xBo1GjXAGsA1xxw1yzg10CA1xho1wBrBNcccNcs4NdAgNcgQ
NcocNcs4NdAgNcgQNcocNco4NccVwTXELME1xBo1GjUawTXHHDXKODXHFcE1xCzBNcQaNRo1GsE1
xxw1x-52d33CAjvPPDXCODXJ-vGqbTXELME1xBo1wRo1GjXUODXHFcE1wiw1LDUsNSw1who1GjUa
NcQGNQY1BjUGNQY1xzg1wDg1xBXBNcQswTXEGjUaNcEaNdU4NdkaNcIaNdU4NfY4NfU4NckVNcQs
wTXEGjUaNcEaNdQ4NccVNRU1xCzBNcQaNRo1GjUaNdH_dnd9wgI7zzw1wzjBNcT_8aptwTXNGsE1
GsE11TjBNcYVNcIswTUswTXCGsE1wBrANcIGwDXABsE1BsE1xjjBNcYVNc0awTUawTXVODXYGsE1
wRo11Tg19jg19jjBNcQVwTXNGsE1GsE11TjBNcQVwTXNGsE1GsE10f52d33CAjvAPMs7wDw1-f3y
ODX2ODX2ODX9-egVwgI7wALLO8A8Nf4nOUr2NQ3COA3xNQ32NQ32NQ3COA3xNQ3COA3xNQ32NQ32
NRXCAjvPPDUN9jUNwjgN8TUN9jUN9jUNwjgN8TUNwjgN8TUN9jUN9jUVwgI7zzw1DcI4wQ3E-vGq
bQ3PGsENGsEN0DUNwjgN8TUNwjjBDcQVDc8awQ0aDdI1DcI4wQ3EFcENzRrBDRrBDdA1DcI4DfE1
DcI4DfE1DcI4wQ3EFcENzRrBDRoNGg3QNQ3COMENxBUNzxrBDRrBDdA1-nZ3fcICO888NQ3BOA3H
-vGqbQ3GLMENxhoNGg0aDdA1DcI4DfE1DcE4DccVDcYswQ3EGg0aDRoN0jUNwTgNyRUNxCzBDcYa
DRoNGg3QNQ3COA3xNQ3COA3xNQ3BOA3HFQ3GLMENxBoNGg0aDRoN0DUNwTgNxxUNxizBDcQaDRoN
wRoN0DX_dnd9wgI7zzw1DcE4DTjADcT_8aptDRUNxCzBDcQawQ0awQ3HHA3GNQ3COA3QIA3IEA3K
HA3GNQ3BOA04wA3EFQ0VDcQswQ3EGg0aDRrBDcccDcY1DcE4DccVwQ3ELMENxBrBDRoNGg3HHA3G
NQ3COA3QIA3IEA3KHA3GNQ3COA3QIA3IEA3KHA3GNQ3BOA3HFcENxCzBDcQaDRoNGsENxxwNxjUN
wTgNxxUNFQ3ELMENxBoNGg3BGg3HHA3GNf52d33CAjvB-l9XT8E7yTw1DcE4DcA4DcT_8aptwQ3E
LMENxBoNwRoNGg3QNQ3COA3xNQ3BOA3AOA3EFcENxCzBDcQaDRoNGg0aDdA1DcE4DccVDcYswQ3E
Gg3BGg0aDdA1DcI4DfE1DcI4DfE1DcE4DccVDRUNxCzBDcQaDRoNwRoN0DUNwTgNxxXBDcQswQ3E
Gg0aDcEaDdA1-nZ3fcICO8AuO8EuO8IuOy47wTw1DcI4wQ3G-vGqbQ3NGsENGsEN0DUNwjgN8TUN
wjjBDcYVDc0awQ0awQ3QNQ3COMENxBXBDc0awQ0awQ3QNQ3COA3xNQ3COA3xNQ3COMENxBXBDc0a
wQ3BGg3QNQ3COMENxhUNzRrBDcEaDdA1-nZ3fcICO8AuO8YuOy47wTw1DfY1DcI4DfE1DfY1DfY1
DcI4DfE1DcI4DfE1DfY1DfY1FcICO8AuO8YuwTvBPDXDODX2ODX98Tg19jg19jg1-f3oFcICO8Au
O8EuO8QuO8E8NcM4NfY4Nf3xODX2ODX2ODX9-egVwgI7wS7BO8UuO8E8NcM4NfY4NfY4wTXE-vGq
bTXPGsE1GsE11Tg12BrANcAawTXVODX2ODX2OME1xBU1zxrBNRrBNdU4wTXEFTXPGsE1GjXT-nZ3
fcICO888NcM4NfY4NfU4Ncf_8aptNcYswTXEGjUaNcEaNdU4NdkaNcAaNRo11Tg19jg19Tg1xxU1
xizBNcQaNRo1wRo11Dg1xxU1xizBNcQaNRo1GjXT-nZ3fcICO888NcM4NdAgNcgQNcocNcs4NdAg
NcgQNcocNco4NTjANcT_8aptNRU1xCzBNcQaNRo1wBrANcccNcs4NdAgNcYaNcAawTXHHDXLODXQ
IDXIEDXKHDXLODXQIDXIEDXKHDXKODXHFTUVNcQswTXEGjUaNcAawDXHHDXKODU4wDXEFTUVNcQs
wTXEGjUaNRrBNcccNcf_dnd9wgI7zzw1wzg19jg19Tg1wDg1xP7xqm3BNcQswTXEGjUaNcEaNdU4
NdkaNcAaNRo11Tg19jg19Tg1xxXBNcQswTXEGjUaNcEaNdQ4NcA4NcQVwTXELME1xBo1GjUaNRo1
0f52d33CAjvPPDXDODX2ODX2OME1xv7xqm01zRrBNRrBNdU4NdgawTUawTXVODX2ODX2OME1xhU1
zRrBNRrBNdU4wTXGFTXNGsE1GsE10f52d33CAjvPPDXDODX2ODX98Tg19jg19jg1-f3oFcICOzzB
OzzAO8E8wDs8wTs8NcM4Nf39-ec4NfY4Nf396BHCAjvAPDvAPDs8Ozw7wjw7wDw1wzg1-f395zg1
9jg1-f3oFcICO8A8O8A8Ozw7PME7wDw7wDw1wzg19jjBNcT_8aptwTXNGsE1GsE1wgbANcAGwTUG
wTXGOME1xBU1xCzBNSw1xBrBNRo11zjBNcQVwTXNGsA1wBrBNdU4NfY4NfY4wTXEFTXPGsE1GsE1
1TjBNcQVwTXNGsE1GsE10f52d33CAjvAPDvAPDs8O8E8O8A8O8A8NcM4NfU4Ncf_8aptNcYswTXE
GjUaNRo1GjXCBjUGNQY1BjXBBjXFODXHFTXELDUsNSw1xBo1GjUaNdY4NckVNcQswTXFGjXAGjUa
NdU4NfY4NfU4NccVNcYswTXEGjUaNcEaNdQ4NccVNcYswTXEGjUaNRo10-52d33CAjs8wTs8Ozw7
PMA7wTw7wDw1wzg10CA1yBA1yhw1yjg1x-7xqm3BNcQswTXEGjUaNRrBNcIGNQY1BjUGNQbBNcU4
NTjANcQVNRU1wiw1LDUswTXCGjUaNRrBNcccNco4NccVwTXELME1xRo1wBo1GjXHHDXLODXQIDXI
EDXKHDXLODXQIDXIEDXKHDXKODU4wDXEFTUVNcQswTXEGjUaNRrBNcccNco4NccVwTXELME1xBo1
GjUawTXHHDXH-nZ3fcICO888NcM4NfU4Ncn_8aptNcQswTXEGjUaNRo1GjXCBjUGNQY1BjUGNcc4
NcA4NcQVwTXCLDUsNSw1LDXCGjUaNRo1GjXUODXHFTXGLME1xRo1wBo1GjXVODX2ODX1ODXAODXE
FcE1xCzBNcQaNRo1GjXWODXJFTXELME1xBo1GjXBGjXR-nZ3fcICO888NcM4NfY4wTXE-vGqbcE1
zRrBNRo1GjXCBsA1wAbBNQbBNcY4wTXGFTXCLME1LME1whrBNRrBNdU4wTXEFcE1zRrBNRrBNdU4
NfY4NfY4wTXGFTXNGsE1GsE11TjBNcQVwTXNGsE1GsE10f52d33CAjvPPDXDODX9-f3nODX2ODX9
-egVwgI7wyDBOyDBO8M8Nf398jg19jg19jg1-f3oFcICO8MgOyA7IDsgO8M8Nf398jg19jg19jg1
-f3oFcICO8MgOyA7IDsgO8M8NcI4wTXF-vGqbTXPGsE1GsE11TjBNcQVNc8awTUawTXCBsA1wAbB
NQbBNcY4wTXEFTXELME1LME1whrBNRrBNdU4NdgawDXAGjUaNdU4NfY4NfY4wTXEFcE1zRrBNRrA
NdY4wTXEFcE1zRrBNRo1GjXR-nZ3fcICO8MgOyA7IDsgO8M8NcI4NcA4NTjANcH_8aptNcYswTXG
GjUaNRo11Dg1xxU1xizBNcQaNRo1GjUaNcIGNQY1BjUGNcEGNcU4NccVNcQsNSw1LDXEGjUaNcEa
NdU4NdkaNcAaNRo11Tg19jg19Tg1xxU1xizBNcQaNRo1wBo11Tg1xxU1xizBNcQaNRo1GjUaNdH_
dnd9wgI7wyDBOyDBO8M8NcI4NcA4NTjANcH_8aptNRU1xCzBNcQawTUawTXHHDXKODU4wDXEFTUV
NcQswTXEGjUaNRrBNcIGNQY1BjUGNQbBNcU4NTjANcQVNRU1wiw1LDUswTXCGjUaNcAawDXHHDXL
ODXQIDXGGjXAGsE1xxw1yzg10CA1yBA1yhw1yzg10CA1yBA1yhw1yjg1xxXBNcQswTXEGjUaNcAa
NcgcNco4NccVwTXELME1xBo1GjUawTXHHDXH-nZ3fcICO888NcI4NcA4NcT_8aptwTXELME1xBo1
wRo1GjXUODXAODXEFcE1xCzBNcQaNRo1GjUaNcIGNQY1BjUGNQY1xzg1wDg1xBXBNcIsNSw1wSw1
who1GjXBGjXVODXZGjXCGjXVODX2ODX1ODXJFTXELME1xBo1GjXAGjXVODXHFTUVNcQswTXEGjUa
NcEaNdH_dnd9wgI7zzw1wjjBNcf_8aptNc0awTUawTXVOME1xhU1zRrBNRo1GjXCBsA1wAbBNQbB
NcY4wTXGFTXCLME1LME1whrBNRrBNdU4NdgawTXBGjXVODX2ODX2OME1xBXBNc0awTUawTXVOME1
xBXBNc0awTXBGjXR-nZ3fcICO888Nf398jg19jg19jg1-f3oFcICO888NQ3COA3xNQ3COA3xNQ32
NQ32NQ3COA3xNQ3COA3xNQ32NQ32NRXCAjvPPDUNwjgN8TUNwjgN8TUN9jUN9jUNwjgN8TUNwjgN
8TUN9jUN9jUVwgI7wTw7PDvAPMA7PDvDPDUNwjgN8TUNwjgN8TUN9jUNwjjBDcT_8aptwQ3NGsEN
GsEN0DUNwjgN8TUNwjgN8TUNwjjBDcQVDcQswQ0swQ3CGsENGg3SNQ3COMENxBUNzxrBDRrBDdA1
-nZ3fcICO8E8Ozw7PDs8Ozw7wzw1DcI4DfE1DcI4DfE1DfY1DcE4Dcn_8aptDcQswQ3GGg0aDRoN
0DUNwjgN8TUNwjgN8TUNwTgNxxUNxCwNLA0sDcQaDRoNGg3SNQ3BOA3HFQ3GLMENxBoNGg3BGg3Q
Nf52d33CAjvBPDs8Ozw7PDs8O8M8NQ3COA3QIA3IEA3KHA3GNQ3COA3QIA3IEA3KHA3GNQ3HMg3L
IA3IEA3KHA3GNQ3BOA3H-vGqbcENxCzBDcQawQ0aDRoNxxwNxjUNwjgN0CANyBANyhwNxjUNwjgN
0CANyBANyhwNxjUNwTgNOMANxBUNFQ3CLA0sDSzBDcIaDRoNGsENxxwNxjUNwTgNxxUNFQ3ELMEN
xBoNGg3AGsANxxwNxjX_dnd9wgI7wTzBOzw7PDs8O8M8NQ3COA3xNQ3COA3xNQ32NQ3BOA3H-vGq
bQ3GLMENxBoNwRoNGg3QNQ3COA3xNQ3COA3xNQ3BOA3AOA3EFcENwiwNLA3BLA3CGg0aDRoNGg3Q
NQ3BOA3HFcENxCzBDcQaDRoNwRoN0DX_dnd9wgI7wjw7wDzAO8A8wTvBPDUNwjgN8TUNwjgN8TUN
9jUNwjjBDcT_8aptwQ3NGsENGsEN0DUNwjgN8TUNwjgN8TUNwjjBDcYVDcIswQ0swQ3CGsENGsEN
0DUNwjjBDcYVDc0awQ0awQ3QNf52d33CAjvPPDUNwjgN8TUNwjgN8TUN9jUN9jUNwjgN8TUNwjgN
8TUN9jUN9jUVwgI7zzw1wzg19jg1-fE4NfY4NfY4Nf396BXCAjvPPDXDODX2ODX98Tg19jg19jg1
-f3oFcICO8MQwTsQwTvDPDXDODX2ODX2OME1xP7xqm3BNcIswTUswTXCGsE1GsE1wgbANcAGwTUG
NQY1xjg12BrANcAawTXVODX2ODX2OME1xBU1xCzBNSw1xBrBNRrBNdU4wTXEFTXPGsE1GsE10f52
d33CAjvFEDsQOxA7wzw1wzg19jg19Tg1x-7xqm01xCw1LDUsNSw1who1GjUaNcQGNQY1BjUGNQY1
BjXGODXZGjXAGjUaNdU4NfY4NfU4NccVNcQsNSw1LDXEGjUaNcEaNdQ4NccVNcYswTXEGjUaNcEa
NdH_dnd9wgI7wxDBOxA7EDvDPDXDODXQIDXIEDXKHDXLODXQIDXIEDXKHDXKODXH-vGqbcE1wiw1
LDUsNSw1who1GjUawTXCBjUGNQY1BjUGwTXGODXQIDXGGjXAGsE1xxw1yzg10CA1yBA1yhw1yzg1
0CA1yBA1yhw1yjg1OMA1xBU1FTXCLDUsNSzBNcIaNRo1wBrANcccNco4NTjANcQVNRU1xCzBNcQa
NRo1GsE1xxw1x-52d33CAjvDEDvBEDsQO8M8NcM4NfY4NfU4Ncn_8aptNcIsNSw1LDUsNcIaNRo1
wRo1wgY1BjUGNQY1wQY1xjg12Ro1wBo1GjXVODX2ODX1ODXAODXEFcE1wiw1LDUsNSw1who1GjXB
GjXUODXAODXEFcE1xCzBNcQaNRo1GjXTEcICO8MQwTsQwTvDPDXDODX2ODX2OME1xBXBNcIswTUs
wTXCGsE1GsE1wgbANcAGwTXBBjXGODXYGsE1GsE11Tg19jg19jjBNcYVNcIswTUswTXCGsE1GsE1
1TjBNcYVNc0awTUawTXREcICO888NcM4NfY4Nf3xODX2ODX2ODX9-egRwgI7zzw1wzg1-f395zg1
9jg1-f3oEcICO888NcM4Nf39-ec4NfY4Nf396BHCAjvPPDXDODX1OME1xRU1zxrBNRrBNcIGwDXA
BsE1BsE1xjjBNcQVNc8awTUawTXCBsA1wAbBNQY1BjXGOME1xBXBNc0awDXAGsE11Tg19jg19jjB
NcQVNcQswTUswTXCGsE1GjXXOME1xBXBNc0awTUawDXSEcICO888NcM4NfU4NcA4NTjANcEVNcYs
wTXEGjUaNRo1GjXCBjUGNQY1BjXBBjXFODXHFTXGLME1xBo1GjUaNcQGNQY1BjUGNQY1BjXFODXJ
FTXELME1xRo1wBo1GjXVODX2ODX1ODXHFTXELDUsNSw1xBo1GjUaNdY4NccVNcYswTXEGjUaNcAa
NdIRwgI7PME7PDs8OzzBOzzBOzw1wzg10CA1yBA1yhw1yjg1wDg1OMA1wRU1FTXELME1xBo1GjUa
wTXCBjUGNQY1BjUGwTXFODU4wDXEFTUVNcQswTXEGjUaNRrBNcIGNQY1BjUGNQbBNcU4NccVwTXE
LME1xRo1wBo1GjXHHDXLODXQIDXIEDXKHDXLODXQIDXIEDXKHDXKODU4wDXEFTUVNcIsNSw1LME1
who1GjUawTXHHDXKODXHFcE1xCzBNcQaNRo1wBo1yBw1xxHCAjvAPDvAPDs8OzzBOzw7PDs8NcM4
NfU4NcA4NcQVwTXELME1xBo1GjUaNRo1wgY1BjUGNQY1BjXHODXAODXEFcE1xCzBNcQaNRo1wRo1
wgY1BjUGNQY1wQY1xTg1xxU1xizBNcUaNcAaNRo11Tg19jg19Tg1wDg1xBXBNcIsNSw1wSw1who1
GjUaNRo11Dg1yRU1xCzBNcQaNRo1wBo10hHCAjvAPDvAPDs8Ozw7PDs8wTs8NcM4NfU4wTXHFTXN
GsE1GjUaNcIGwDXABsE1BsE1xjjBNcYVNc0awTUawTXCBsA1wAbBNcEGNcY4wTXEFcE1zRrBNRrB
NdU4NfY4NfY4wTXGFTXCLME1LME1whrBNRrBNdU4wTXEFcE1zRrBNRrBNdERwgI7wDw7wDw7PDs8
Ozw7PDvBPDXDODX9-f3nODX2ODX9-egRwgI7PMA7wTzAOzw7PDs8O8E8NcM4NfY4NfY4NfY4NfY4
NfY4Nf396BHCAjvPPDXDODX2ODX2ODX2ODX2ODX2ODX9-egRwgI7zzw1wzg19jg19jg19jg12BrA
NcAaNRo11Tg19jg19jjBNcQVNcQswTUsNcQawTUawTX9zBHCAjvPPDXDODX2ODX2ODX2ODXZGjXA
GjUaNdU4NfY4NfU4NccVNcQsNSw1LDXEGjUaNcEaNf3MEcICO8MuwTsuwDvEPDXDODXQIDXIEDXK
HDXLODXQIDXIEDXKHDXLODXQIDXIEDXKHDXLODXQIDXGGjXAGsE1xxw1yzg10CA1yBA1yhw1yzg1
0CA1yBA1yhw1yjg1OMA1xBU1FTXCLDUsNSzBNcIaNRo1wBrANcccNdAyNcsgNcgQNcocNccRwgI7
wy47LjvALjvEPDXDODX2ODX2ODX2ODXZGjXCGjXVODX2ODX1ODXAODXEFcE1wiw1LDUsNSw1who1
GjXBGjX9zBHCAjvDLjsuO8AuO8Q8NcM4NfY4NfY4NfY4NdgawTXBGjXVODX2ODX2OME1xhU1wizB
NSzBNcIawTUawTX9zBHCAjvDLjsuO8AuO8Q8NcM4NfY4NfY4NfY4NfY4NfY4Nf396BHCAjvDLsE7
LsE7wzw1DfY1DcI4DfE1DcI4DfE1DfY1DfY1DcI4DfE1DfY1DfY1EcICO888NQ32NQ3COA3xNQ3C
OA3xNQ32NQ32NQ3COA3xNQ32NQ32NcMCO888NQ3COMENxBUNzxrBDRrBDdA1DcI4DfE1DcI4DfE1
DcI4wQ3EFcENzRrBDRrBDdA1DfY1DcI4DfE1DcI4wQ3EFQ3ELMENLMENwhrBDRoN0jUN9jURwgI7
zzw1DcE4DccVDcYswQ3GGg0aDRoN0DUNwjgN8TUNwjgN8TUNwTgNyRUNxCzBDcYaDRoNGg3QNQ32
NQ3COA3xNQ3BOA3HFQ3ELA0sDSwNxBoNGg0aDdI1DfY1EcICO888NQ3BOA3HFQ0VDcQswQ3FGsAN
Gg0aDcccDcY1DcI4DdAgDcgQDcocDcY1DcI4DdAgDcgQDcocDcY1DcE4DccVwQ3ELMENxBrBDRoN
Gg3HHA3GNQ3HMg3LIA3IEA3KHA3GNQ3COA3QIA3IEA3KHA3GNQ3BOA04wA3EFQ0VDcIsDSwNLMEN
whoNGg0awQ3HHA3GNQ3HMg3LIA3IEA3KHA3GNRHCAjvAPMs7wDw1DcE4DccVwQ3ELMENxhoNGg0a
DdA1DcI4DfE1DcI4DfE1DcE4DccVDcYswQ3EGg3BGg0aDdA1DfY1DcI4DfE1DcE4DcA4DcQVwQ3C
LA0sDcEsDcIaDRoNGg0aDdA1DfY1EcICO8ACyzvAPDUNwjjBDcYVDc0awQ0awQ3QNQ3COA3xNQ3C
OA3xNQ3COMENxBXBDc0awQ0awQ3QNQ32NQ3COA3xNQ3COMENxhUNwizBDSzBDcIawQ0awQ3QNQ32
NRHCAjvPPDUN9jUNwjgN8TUNwjgN8TUN9jUN9jUNwjgN8TUN9jUN9jURwgI7zzw1wzg19jg1-fE4
Nf3xODX9-egRwgI7zzw1wzg19jg1-fE4Nf3xODX9-egRwgI7zzw1wzg19jg19TjBNcUVNc8awTUa
wTXCBsA1wAbBNQY1BjXGODXYGsA1wBrBNf3QODX2OME1xBU1zxrBNRrBNf3MEcICOzzBOzzBOzzB
OzzBOzw1wzg19jg19Tg1wDg1OMA1wRU1xizBNcQaNRo1GjXEBjUGNQY1BjUGNQY1xjg12Ro1wBo1
GjX90Dg19Tg1xxU1xizBNcQaNRo1wRo1-cwRwgI7PDs8Ozw7PDvAPDvBPDvAPDXDODXQIDXIEDXK
HDXLODXQIDXIEDXKHDXKODXAODU4wDXBFTUVNcQswTXEGjUaNRrBNcIGNQY1BjUGNQbBNcY4NdAg
NcYaNcAawTXHHDXQMjXLIDXIEDXKHDXLODXQIDXIEDXKHDXKODU4wDXEFTUVNcQswTXEGjUaNcAa
wDXHHDXQMjXLIDXIEDXKHDXHEcICOzzBOzzBO8A8O8E8O8A8NcM4NfY4NfU4NcA4NcQVwTXELME1
xBo1GjXBGjXCBjUGNQY1BjXBBjXGODXZGjXAGjUaNf3QODX1ODXAODXEFcE1xCzBNcQaNRo1wRo1
-cwRwgI7PDvBPDs8O8A8O8E8O8A8NcM4NfY4NfU4wTXHFTXNGsE1GsE1wgbANcAGwTXBBjXGODXY
GsE1GsE1-dA4NfY4wTXGFTXNGsE1GsE1-cwRwgI7PDvBPDs8O8A8O8E8O8A8NcM4NfY4Nf3xODX9
8Tg1-f3oEcICO888NcM4NfY4NfY4Nf397Dg1-f3oEcICO888NcM4NfY4NfY4Nf397Dg1-f3oEcIC
O888NcM4NfY4NfY4NfY4wTXEFcE1zRrANcAawTX90Dg19jjBNcQVNc8awTUaNf3OEcICO8MuwTsu
wTvDPDXDODX2ODX2ODX1ODXJFTXELME1xRo1wBo1GjX90Dg19Tg1xxU1xizBNcQaNRo1GjX9zhHC
AjvDLjsuOy47xTw1wzg10CA1yBA1yhw1yzg10CA1yBA1yhw1yzg10CA1yBA1yhw1yjg1xxXBNcQs
wTXFGjXAGjUaNcccNdAyNcsgNcgQNcocNcs4NdAgNcgQNcocNco4NTjANcQVNRU1xCzBNcQaNRo1
GsE1xxw10DI1yyA1yBA1yhw1xxHCAjvDLjsuOy7BO8M8NcM4NfY4NfY4NfU4NccVNcYswTXFGjXA
GjUaNf3QODX1ODXAODXEFcE1xCzBNcQaNRo1GjUaNf3MEcICO8MuOy47wS47wzw1wzg19jg19jg1
9jjBNcQVwTXNGsE1GsE1-dA4NfY4wTXGFTXNGsE1GsE1-cwRwgI7wy7BOy7BO8M8NcM4NfY4NfY4
Nf397Dg1-f3oEcICO888Nf33ODX2ODX98Tg1-f3oEcICO888Nf33ODX2ODX98Tg1-f3oEcICO888
NcM4wTXEFcE1zRrBNRrBNdU4wTXEFTXPGsE1wBrANcIGwDXABsE1BsE1xjg19jg12BrANcAaNRo1
-dA4NfY4wTXEFTXPGsE1GsE1-cwRwgI7zzw1wjg1xxU1xizBNcYaNRo1GjXUODXHFTXGLME1xBo1
GjUaNcQGNQY1BjUGNcEGNcY4NfY4NdkaNcAaNRo1-dA4NfU4NccVNcYswTXEGjUaNcEaNf3MEcIC
O8M8O8M8O8M8NcI4NccVwTXELME1xBrBNRo1GjXHHDXKODXHFTUVNcQswTXEGjUaNRo1xAY1BjUG
NQY1BsE1xjg10CA1yBA1yhw1yzg10CA1xho1wBrBNcccNdAyNcsgNcgQNcocNcs4NdAgNcgQNcoc
Nco4NTjANcQVNRU1xCzBNcQaNRo1wBrANcccNdAyNcsgNcgQNcocNccRwgI7wjzAO8M8wDvCPDXC
ODXJFTXELME1xBo1wRo1GjXUODXHFcE1xCzBNcQaNRo1GjXEBjUGNQY1BjUGNcg4NfY4NdkaNcIa
Nf3QODX1ODXAODXEFcE1xCzBNcQaNRo1wRo1-cwRwgI7wTzBO8M8wTvBPDXDOME1xBXBNc0awTUa
wTXVOME1xhU1zRrBNcAawDXCBsA1wAbBNQbBNcY4NfY4NdgawTXBGjX90Dg19jjBNcYVNc0awTUa
wTX9zBHCAjvAPMI7wzzCO8A8Nf33ODX2ODX98Tg1-f3oEcICO8E8wTvDPME7wTw1E-Y1E8I4E-E1
E8I4E-E1E-Y1E-Y1E8I4E-E1E-Y1E-Y1EcICO8I8wDvDPMA7wjw1E-Y1E8I4E-E1E8I4E-E1E-Y1
E-Y1E8I4E-E1E-Y1E-Y1EcICO8M8O8M8O8M8NRPCOMETxBUTzxrBExrBE9A1E8I4E-E1E8I4E-E1
E8I4wRPEFcATzhrBExrBE9A1E8E4wRPFFRPPGsATwBrBE9A1E8I4E-E1E8I4wRPEFRPELMETLBPE
GsETGhPSNRP2NRHCAjvPPDUTwTgTxxUTxizBE8YaExoTGhPQNRPCOBPxNRPCOBPxNRPBOBPIFRPF
LMETxhoTGhMaE9A1E8E4E8A4E8QVE8YswRPFGhPAGhMaE9A1E8I4E-E1E8E4E8cVE8QsEywTLBPE
GhMaExoT0jUT9jURwgI7zzw1E8E4EzjAE8QVExUTxCzBE8QawRMawRPHHBPGNRPCOBPQIBPIEBPK
HBPGNRPCOBPQIBPIEBPKHBPGNRPBOBM4wBPFFRPFLMETxBrBExoTGhPHHBPGNRPBOBPAOBPEFRMV
E8QswRPFGhPAGhMaE8ccE8Y1E8I4E9AgE8gQE8ocE8Y1E8E4EzjAE8QVExUTwiwTLBMswRPCGhMa
ExrBE8ccE8Y1E8cyE8sgE8gQE8ocE8Y1EcICO888NRPBOBPAOBPEFcETxCzBE8QaE8EaExoT0DUT
wjgT8TUTwjgT8TUTwTgTwDgTxRUTxSzBE8QaE8EaExoT0DUTwTgTwDgTxBXBE8QswRPFGhPAGhMa
E9A1E8I4E-E1E8E4E8A4E8QVwRPCLBMsEywTLBPCGhMaExoTGhPQNRP2NRHCAjvPPDUTwjjBE8YV
E80awRMawRPQNRPCOBPxNRPCOBPxNRPCOMETxBXBE80awRMawRPQNRPBOMETxxUTzRrBExrBE9A1
E8I4E-E1E8I4wRPGFRPCLMETLMETwhrBExrBE9A1E-Y1EcICO888NRP2NRPCOBPxNRPCOBPxNRP2
NRP2NRPCOBPxNRP2NRP2NRHCAjvPPDXDODX2ODX2ODX2ODX2ODX2ODX9-egRwgI7zzw1wzg19jg1
9jg19jg19jg19jg1-f3oEcICO888NcM4NfY4NfY4NfY4NdgawDXAGsE11Tg19jg19jjBNcQVNcQs
wTUswTXCGsE1GsE1-cwRwgI7zzw1wzg19jg19jg19jg12Ro1wBo1GjXVODX2ODX1ODXHFTXELDUs
NSw1xBo1GjXBGjX9zBHCAjvPPDXDODXQIDXIEDXKHDXLODXQIDXIEDXKHDXLODXQIDXIEDXKHDXL
ODXQIDXGGjXAGsE1xxw1yzg10CA1yBA1yhw1yzg10CA1yBA1yhw1yjg1OMA1xBU1FTXCLDUsNSzB
NcIaNRo1wBrANcccNdAyNcsgNcgQNcocNccRwgI7zzw1wzg19jg19jg19jg12Ro1wBo1GjXVODX2
ODX1ODXAODXEFcE1wiw1LDXBLDXCGjUaNcEaNf3MEcICO888NcM4NfY4NfY4NfY4NdgawTUawTXV
ODX2ODX2OME1xhU1wizBNSzBNcIawTUawTX9zBHCAjvPPDXDODX2ODX2ODX2ODX2ODX2ODX9-egR
wgI7zzw1wzg1-f395zg19jg1-f3oEcICO888NcM4Nf39-ec4NfY4Nf396BHCAjvPPDXDODX2OME1
xBXBNc0awTUawTXCBsA1wAbBNQbBNcY4wTXEFTXPGsE1GsE1wgbANcAGwTUGNQY1xjjBNcQVwDXO
GsA1wBrBNdU4NfY4NfY4wTXEFTXPGsE1GjX90gI7zzw1wzg19Tg1xxU1xizBNcQaNRo1GjUaNcIG
NQY1BjUGNcEGNcU4NccVNcYswTXEGjUaNRo1xAY1BjUGNQY1BjUGNcU4NcgVNcUswTXFGjXAGjUa
NdU4NfY4NfU4NccVNcYswTXEGjUaNRo1-c4RwgI7zzw1wzg10CA1yBA1yhw1yjg1xxXBNcQswTXE
GjUaNRrBNcIGNQY1BjUGNQbBNcU4NccVNRU1xCzBNcQaNRo1GsE1wgY1BjUGNQY1BsE1xTg1OMA1
xRU1xSzBNcUaNcAaNRo1xxw1yzg10CA1yBA1yhw1yzg10CA1yBA1yhw1yjg1OMA1xBU1FTXELME1
xBo1GjUawTXHHDXQMjXLIDXIEDXKHDXHEcICO888NcM4NfU4NckVNcQswTXEGjUaNRo1GjXCBjUG
NQY1BjUGNcc4NccVwTXELME1xBo1GjXBGjXCBjUGNQY1BjXBBjXFODXAODXFFTXFLME1xRo1wBo1
GjXVODX2ODX1ODXAODXEFcE1xCzBNcQaNRo1GjUaNf3MEcICO888NcM4NfY4wTXEFcE1zRrBNRo1
GjXCBsA1wAbBNQbBNcY4wTXGFTXNGsE1GsE1wgbANcAGwTXBBjXGOME1xBXBNc0awTUawTXVODX2
ODX2OME1xhU1zRrBNRrBNf3MEcICO888NcM4Nf39-ec4NfY4Nf396BHCAjvPPDX99zg19jg19jg1
9jg1-f3oEcICO888Nf33ODX2ODX2ODX2ODX9-egRwgI7zzw1wjjBNcUVNc8awTUawTXVOME1xBU1
zxrBNRrBNcIGwDXABsE1BsE1xjg19jg12BrANcAaNRo11Tg19jg19jjBNcQVNc8awTUawTX9zBHC
AjvPPDXCODXAODXEFTXGLME1xho1GjUaNdQ4NccVNcYswTXEGjUaNRo1GjXCBjUGNQY1BjXBBjXG
ODX2ODXZGjXAGjUaNdU4NfY4NfU4NccVNcYswTXEGjUaNcEaNf3MEcICO888NcI4NcA4NcQVNRU1
xCzBNcQawTUawTXHHDXKODU4wDXEFTUVNcQswTXEGjUaNRrBNcIGNQY1BjUGNQbBNcY4NdAgNcgQ
NcocNcs4NdAgNcYaNcAawTXHHDXLODXQIDXIEDXKHDXLODXQIDXIEDXKHDXKODU4wDXEFTUVNcQs
wTXEGjUaNcAawDXHHDXQMjXLIDXIEDXKHDXHEcICO8A8yzvAPDXCODXAODXEFcE1xCzBNcQaNcEa
NRo11Dg1wDg1xBXBNcQswTXEGjUaNRo1GjXCBjUGNQY1BjUGNcg4NfY4NdkaNcIaNdU4NfY4NfU4
NcA4NcQVwTXELME1xBo1GjXBGjX9zBHCAjvAAss7wDw1wjjBNccVNc0awTUawTXVOME1xhU1zRrB
NRo1GjXCBsA1wAbBNQbBNcY4NfY4NdgawTXBGjXVODX2ODX2OME1xhU1zRrBNRrBNf3MEcICO888
Nf33ODX2ODX2ODX2ODX9-egRwgI7zzw1DcI4DfE1DcI4DfE1DcI4DfE1DfY1DcI4DfE1DcI4DfE1
DfY1DfY1EcICO888NQ3COA3xNQ3COA3xNQ3COA3xNQ32NQ3COA3xNQ3COA3xNQ32NQ32NRHCAjvP
PDUNwjgN8TUNwjgN8TUNwjgN8TUNwjjBDcQVwA3OGsENGsEN0DUNwjgN8TUNwjgN8TUNwjjBDcQV
Dc8awQ0aDdI1DfY1EcICO8I8xzvCPDUNwjgN8TUNwjgN8TUNwjgN8TUNwTgNyBUNxSzBDcYaDRoN
Gg3QNQ3COA3xNQ3COA3xNQ3BOA3HFQ3GLMENxBoNGg0aDdI1DfY1EcICO8E8-h43PMc8O8E8NQ3C
OA3QIA3IEA3KHA3GNQ3COA3QIA3IEA3KHA3GNQ3COA3QIA3IEA3KHA3GNQ3BOA04wA3FFQ3FLMEN
xBrBDRoNGg3HHA3GNQ3COA3QIA3IEA3KHA3GNQ3COA3QIA3IEA3KHA3GNQ3BOA04wA3EFQ0VDcQs
wQ3EGg0aDRrBDcccDcY1DccyDcsgDcgQDcocDcY1EcICO8A8Br_nwgYWwgYCO8A8NQ3COA3xNQ3C
OA3xNQ3COA3xNQ3BOA3AOA3FFQ3FLMENxBoNwRoNGg3QNQ3COA3xNQ3COA3xNQ3BOA3AOA3EFcEN
xCzBDcQaDRoNGg0aDdA1DfY1EcICO8A8BhbCBhbCBgI7wDw1DcI4DfE1DcI4DfE1DcI4DfE1DcI4
wQ3EFcENzRrBDRrBDdA1DcI4DfE1DcI4DfE1DcI4wQ3GFQ3NGsENGsEN0DUN9jURwgI7wDwGFsIG
FsIGAjvAPDUNwjgN8TUNwjgN8TUNwjgN8TUN9jUNwjgN8TUNwjgN8TUN9jUN9jURwgI7wDwGFsIG
FsIGAjvAPDXDODX2ODX98Tg19jg19jg1-f3oEcICO8A8BhbCBhbCBgI7wDw1wzg19jg1-fE4NfY4
NfY4Nf396BHCAjvAPAYWwgYWwgYCO8A8NcM4NfY4NfY4wTXEFcE1zRrBNRrBNcL_yqnqwDXABsE1
BjUGNcY4NdgawDXAGsE11Tg19jg19jjBNcQVNc8awTUawTX9zBHCAjvAPP4eNzwWwgYWwgYCO8A8
NcM4NfY4NfU4NccVNcYswTXEGjUaNRo1xP7Kqeo1BjUGNQY1BjUGNcY4NdkaNcAaNRo11Tg19jg1
9Tg1xxU1xizBNcQaNRo1wRo1-cwRwgI7wDz_Hjc8FsIGFsIGAjvAPDXDODXQIDXIEDXKHDXLODXQ
IDXIEDXKHDXKODXHFcE1xCzBNcQaNRo1GsE1wv7Kqeo1BjUGNQY1BsE1xjg10CA1xho1wBrBNccc
Ncs4NdAgNcgQNcocNcs4NdAgNcgQNcocNco4NTjANcQVNRU1xCzBNcQaNRo1wBrANcccNdAyNcsg
NcgQNcocNccRwgI7wDz_Hjc8FsIGFsIGAjvAPDXDODX2ODX1ODXJFTXELME1xBo1GjXBGjXC-sqp
6jUGNQY1BjXBBjXGODXZGjXAGjUaNdU4NfY4NfU4NcA4NcQVwTXELME1xBo1GjXBGjX9zBHCAjvA
PP4eNzwWwgYWwgYCO8A8NcM4NfY4NfY4wTXEFcE1zRrBNRrBNcL_yqnqwDXABsE1wQY1xjg12BrB
NRrBNdU4NfY4NfY4wTXGFTXNGsE1GsE1-cwRwgI7wDz_Hjc8FsIGFsIGAjvAPDXDODX2ODX98Tg1
9jg19jg1-f3oEcICO8A8BhbCBhbCBgI7wDw1wzg1-f395zg19jg1-f3oEcICO8A8BhbCBhbCBgI7
wDw1wzg1-f395zg19jg1-f3oEcICO8A8BhbCBhbCBgI7wDw1wzg19TjBNcUVNc8awTUawTXC-sqp
6sA1wAbBNQbBNcY4wTXEFTXPGsE1GsE1wgbANcAGwTUGNQY1xjjBNcQVwDXOGsA1wBrBNdU4NfY4
NfY4wTXEFTXELME1LDXEGsE1GjX9zhHCAjvAPP4eNzwWwgYWwgYCO8A8NcM4NfU4NcA4NcQVNcYs
wTXEGjUaNRo1GjXC-sqp6jUGNQY1BjXBBjXFODXHFTXGLME1xBo1GjUaNcQGNQY1BjUGNQY1BjXF
ODXIFTXFLME1xRo1wBo1GjXVODX2ODX1ODXHFTXELDUsNSw1xBo1GjUaNf3OEcICO8A8-h43PBbC
BhbCBgI7wDw1wzg10CA1yBA1yhw1yjg1wDg1xBU1FTXELME1xBo1GjUawTXC-sqp6jUGNQY1BjUG
wTXFODU4wDXEFTUVNcQswTXEGjUaNRrBNcIGNQY1BjUGNQbBNcU4NTjANcUVNcUswTXFGjXAGjUa
NcccNcs4NdAgNcgQNcocNcs4NdAgNcgQNcocNco4NTjANcQVNRU1wiw1LDUswTXCGjUaNRrBNccc
NdAyNcsgNcgQNcocNccRwgI7wDz_Hjc8FsIGFsIGAjvAPDXDODX1ODXAODXEFcE1xCzBNcQaNRo1
GjUaNcL_yqnqNQY1BjUGNQY1xzg1wDg1xBXBNcQswTXEGjUaNcEaNcIGNQY1BjUGNcEGNcU4NcA4
NcUVNcUswTXFGjXAGjUaNdU4NfY4NfU4NcA4NcQVwTXCLDUsNSw1LDXCGjUaNRo1GjX9zBHCAjvA
PP4eNzwWwgYWwgYCO8A8NcM4NfU4wTXHFTXNGsE1GjUaNcL_yqnqwDXABsE1BsE1xjjBNcYVNc0a
wTUawTXCBsA1wAbBNcEGNcY4wTXEFcE1zRrBNRrBNdU4NfY4NfY4wTXGFTXCLME1LME1whrBNRrB
Nf3MEcICO8A8-h43PBbCBhbCBgI7wDw1wzg1-f395zg19jg1-f3oEcICO8A8BhbCBhbCBgI7wDw1
wzg19jg19jg19jg19jg19jg1-f3oEcICO8A8BhbCBhbCBgI7wDw1wzg19jg19jg19jg19jg19jg1
-f3oEcICO8A8BhbCBhbCBgI7wDw1wzg19jg19jg19jg12BrANcAaNRo11Tg19jg19jjBNcQVNcQs
wTUswTXCGsE1GsE1-cwRwgI7wDwGFsIGFsIGAjvAPDXDODX2ODX2ODX2ODXZGjXAGjUaNdU4NfY4
NfU4NccVNcQsNSw1LDXEGjUaNcEaNf3MEcICO8A8BhbCBhbCBgI7wDw1wzg10CA1yBA1yhw1yzg1
0CA1yBA1yhw1yzg10CA1yBA1yhw1yzg10CA1xho1wBrBNcccNcs4NdAgNcgQNcocNcs4NdAgNcgQ
NcocNco4NTjANcQVNRU1wiw1LDUswTXCGjUaNcAawDXHHDXQMjXLIDXIEDXKHDXHEcICO8A8BhbC
BhbCBgI7wDw1wzg19jg19jg19jg12Ro1who11Tg19jg19Tg1wDg1xBXBNcIsNSw1wSw1who1GjXB
GjX9zBHCAjvAPAYWwgYWwgYCO8A8NcM4NfY4NfY4NfY4NdgawTXBGjXVODX2ODX2OME1xhU1wizB
NSzBNcIawTUawTX9zBHCAjvAPAYWwgYWwgYCO8A8NcM4NfY4NfY4NfY4NfY4NfY4Nf396BHCAjvA
PAYWwgYWwgYCO8A8NQ32NQ3COA3xNQ3COA3xNQ32NQ3COA3xNQ3COA3xNQ32NQ32NRHCAjvAPAYW
wgYWwgYCO8A8NQ32NQ3COA3xNQ3COA3xNQ32NQ3COA3xNQ3COA3xNQ32NQ32NRHCAjvAPAYWwgYW
wgYCO8A8NQ32NQ3COA3xNQ3COA3xNQ3COMENxBXADc4awQ0awQ3QNQ3COA3xNQ3COA3xNQ3COMEN
xBUNzxrBDRoN0jUN9jURwgI7wDwGFsIGFsIGAjvAPDUN9jUNwjgN8TUNwjgN8TUNwTgNyBUNxSzB
DcYaDRoNGg3QNQ3COA3xNQ3COA3xNQ3BOA3HFQ3GLMENxBoNGg0aDdI1DfY1wwI7wDwGFsIGFsIG
AjvAPAL9-f39-f392DwCO8A8BhbCBhbCBgI7wDwCO-39-f39-f3XPAI7wDwGFsIGFsIGAjvAPAI7
-f39-f39-dc8AjvAPAYWwgYWwgYCO8A8Ajv9-f39-f391zwCO8A8BhbCBhbCBgI7wDwCO-39-f39
-f3XPAI7wDwGFsIGFsIGAjvAPAI7wjz9-f39-f39zzvCPAI7wDwGFsIGFsIGAjvAPAI7wTwG-f39
-f39-c88O8E8AjvAPAYWwgYWwgYCO8A8AjvAPAb9-f39-f390QI7wDwCO8A8BhbCBhbCBgI7wDwC
O8A8BtoCwQYCBgIG-eECwQYCBgIG-eECwQYCBgIG-eECwQYCBgIG-eECwQYCBgIGwAI7wDwCO8A8
BhbCBhbCBgI7wDwCO8A8BtoCBv3nAgb95wIG-ecCBv3nAgbGAjvAPAI7wDwGFsIGFsIGAjvAPAI7
wDwG2gIG-ecCBv3nAgb95wIG-ecCBsYCO8A8AjvAPAYWwgYWwgYCO8A8AjvAPAbaAgbAAgb95AIG
wAIG-eQCBsACBv3kAgbAAgb95AIGwAIGwwI7wDwCO8A8BhbCBhbCBgI7wDwCO8A8BtoCBsACwAb9
4wIGwALABv3jAgbAAsAG-eMCBsACwAb94wIGwALABsICO8A8AjvAPAYWwgYWwgYCO8A8AjvAPAba
AsQG-eICxAb94gLEBv3iAsQG-eICxAbBAjvAPAI7wDwGFsIGFsIGAjvAPAI7wDwG3QLABv3mAsAG
-eYCwAb95gLABv3mAsAGwgI7wDwCO8A8BhbCBhbCBgI7wDwCO8A8Bt0CBv3nAgb95wIG-ecCBv3n
AgbDAjvAPAI7wDwGLMIGLMIGAjvAPAI7wDwG-f39-f39-dECO8A8AjvBAgbHAjvBPAI7wDwGwRbT
BsMW0wbDFtMGwxbTBsMW0wbD-gClodMGwxbTBsMW0wbDFtMGwxbTBsMW0wbDFtMGwxbTBsMW0wbD
FtMGwxbTBsMW0wbDFsYCO8A8AjvCAsc7wjwCO8A8BsAW1QbBFtUGwRbVBsEW1QbBFtUGwRXVBsEW
1QbBFtUGwRbVBsEW1QbBFtUGwRbVBsEW1QbBFtUGwRbVBsEW1QbBFtUGwRbHAjvAPAI7zzwCO8A8
BsAW1QbBFtUGwRbVBsEW1QbBFtUGwRXVBsEW1QbBFtUGwRbVBsEW1QbBFtUGwRbVBsEW1QbBFtUG
wRbVBsEW1QbBFtUGwRbHAjvAPAI7zzwCO8A8BsAWwgLBFgLBFsoGwRbCAsEWAsAWywbBFsICwRYC
wRbKBsEWwgLBFgLBFsoGwRbCAsEWAhYCFsoGwRXCAsEVAsEVygbBFsICwRYCFswGwRbCAsEWAsEW
ygbBFsICwRYCwRbKBsEWwgLBFgLBFsoGwRbCAsAWwALBFsoGwRbCAsAWwALAFssGwRbCAsAWwALB
FsoGwRbCAsAWwALBFsoGwRbCAsAWwAIWAhbKBsEWwgLAFsACwRbKBsEWwgLAFsACFswGwRbCAsAW
wALAO8A8AjvPPAI7wDwGwBbCAhYCFgIWAhbKBsEWwgIWAhbAAhbLBsEWwgIWAhbBAhbKBsEWwgIW
AhbBAhbKBsEWwgIWAhYCFgIWygbBFcICFQIVAhXMBsEWwgIWAhYCFswGwRbCAhYCFsECFsoGwRbC
AhYCFgIWAhbKBsEWwgIWAhYCFgIWygbBFsMCFsACFgIWygbBFsMCFsECFssGwRbDAhbCAhbKBsEW
wwIWwgIWygbBFsMCFsACFgIWygbBFsMCFsACFswGwRbDAhbAAhbMBsEWwwIWwQI7wDwCO888AjvA
PAbAFsICFgIWAhYCFsoGwRbCAhYCFsACFssGwRbCAhYCFgLBFsoGwRbCAhYCFsACwBbKBsEWwgIW
AhYCwRbKBsEVwgIVAhUCwRXKBsEWwgIWAhYCwRbKBsEWwgIWAhbBAhbKBsEWwgIWAhYCwRbKBsEW
wgIWAhYCwRbKBsEWwwIWwAIWAhbKBsEWwwIWwQIWywbBFsMCFsACwRbKBsEWwwIWwQLAFsoGwRbD
AhbAAsEWygbBFsMCFsACwRbKBsEWwwIWwALBFsoGwRbDAhbBAjvAPAI7wTzJO8E8AjvAPAbAFsIC
FgIWAhYCFsoGwRbCAhYCFsACFssGwRbCAhYCFgIWzAbBFsICFgIWwQIWygbBFsICFgIWwQIWygbB
FcICFQIVwQIVygbBFsICFgIWAhYCFsoGwRbCAhYCFsECFsoGwRbCAhYCFgIWAhbKBsEWwgIWAhbB
AhbKBsEWwwIWwAIWAhbKBsEWwwIWwQIWywbBFsMCFsACFswGwRbDAhbCAhbKBsEWwwIWwgIWygbB
FsMCFsICFsoGwRbDAhbAAhYCFsoGwRbDAhbBAjvAPAI7wDz_dU6XyTz_wsPHwDwCO8A8BsAWwgLB
FgLBFsoGwRbCAsEWAsEWygbBFsICwRYCwRbKBsEWwgLBFgLBFsoGwRbCAsEWwQIWygbBFcICwRUC
wRXKBsEWwgLBFgLBFsoGwRbCAsEWwQIWygbBFsICwRYCwRbKBsEWwgLBFsECFsoGwRbCAsEWAsEW
ygbBFsICwRYCwRbKBsEWwgLBFgLBFsoGwRbCAsEWAsEWygbBFsICwRbBAhbKBsEWwgLBFgLBFsoG
wRbCAsEWAsEWygbBFsICwRbAAjvAPAI7PP51TpfLAol7PAI7wDwGwBbVBsEW1QbBFtUGwRbVBsEW
1QbBFdUGwRbVBsEW1QbBFtUGwRbVBsEW1QbBFtUGwRbVBsEW1QbBFtUGwRbVBsEW1QbBFscCO8A8
Ajs8-nVOl8sCiXs8AjvAPAbAFv39xBXVFv39-f3wAjvAPAI7PP51TpfDP8E7wwKJezwCO8A8BsAW
wgYWBhYGFgIWAhYCFgYWBhbCBsEWwgIWAhYCFgIWAhYCFgIWAhbCBsEWwgIWAhYCFgIWAhYCFgIW
AhbCBsEWwgIWAhYCFgIWAhYCFgIWAhbCBsEWwgIWAhYCFgIWAhYCFgIWAhbCBsEVwgIVAhUCFQIV
AhUCFQIVAhXCBsEWwgIWAhYCFgIWAhYCFgIWBhbCBsEWwgIWAhYCFgIWAhYCFgIWBhbCBsEWwgIW
AhYCFgIWAhYCFgIWBhbCBsEWwgIWAhYCFgIWAhYCFgIWAhbCBsEWwgIWAhYCFgIWAhYCFgIWAhbC
BsEWwgIWAhYCFgIWAhYCFgIWAhbCBsEWwgIWAhYCFgIWAhYCFgIWAhbCBsEWwgIWAhYCFgIWAhYC
FgIWAhbCBsEWwgYWAhYCFgIWAhYCFgIWBhbCBsEWwgYWAhYCFgYWAhYCFgIWBhbCBsEWwgYWAhYC
FgYWAhYCFgIWAhbCBsEWwgIWAhYCwDvAPAI7PP51TpfCP8M7wgKJezwCO8A8BsAWwgYWBhYGFgIW
AhYCFgYWBhbCBsEWwgIWAhYCFgIWAhYCFgIWAhbCBsEWwgIWAhYCFgIWAhYCFgIWAhbCBsEWwgIW
AhYCFgIWAhYCFgIWAhbCBsEWwgIWAhYCFgIWAhYCFgIWAhbCBsEVwgIVAhUCFQIVAhUCFQIVAhXC
BsEWwgIWAhYCFgIWAhYCFgIWBhbCBsEWwgIWAhYCFgIWAhYCFgIWBhbCBsEWwgIWAhYCFgIWAhYC
FgIWBhbCBsEWwgIWAhYCFgIWAhYCFgIWAhbCBsEWwgIWAhYCFgIWAhYCFgIWAhbCBsEWwgIWAhYC
FgIWAhYCFgIWAhbCBsEWwgIWAhYCFgIWAhYCFgIWAhbCBsEWwgIWAhYCFgIWAhYCFgIWAhbCBsEW
wgYWAhYCFgIWAhYCFgIWBhbCBsEWwgYWAhYCFgYWAhYCFgIWBhbCBsEWwgYWAhYCFgYWAhYCFgIW
AhbCBsEWwgIWAhYCwDvAPAI7PP51TpfCP8M7wgKJezwCO8A8BsAW1QbBFtUGwRbVBsEW1QbBFtUG
wRXVBsEW1QbBFtUGwRbVBsEW1QbBFtUGwRbVBsEW1QbBFtUGwRbVBsEW1QbBFtUGwRbHAjvAPAI7
PP51TpfCP8M7wgKJezwCO8A8BsAW1QbBFtUGwRbVBsEW1QbBFtUGwRXVBsEW1QbBFtUGwRbVBsEW
1QbBFtUGwRbVBsEW1QbBFtUGwRbVBsEW1QbBFtUGwRbHAjvAPAI7PP51TpfDP8E7wwKJezwCO8A8
BsAW1QbBFtUGwRbVBsEW1QbBFtUGwRXVBsEW1QbBFtUGwRbVBsEW1QbBFtUGwRbVBsEW1QbBFtUG
wRbVBsEW1QbBFtUGwRbHAjvAPAI7PP51TpfLAol7PAI7wDwGwBbVBsEW1QbBFtUGwRbVBsEW1QbB
FdUGwRbVBsEW1QbBFtUGwRbVBsEW1QbBFtUGwRbVBsEW1QbBFtUGwRbVBsEW1QbBFscCO8A8Ajs8
-nVOl8sCiXs8AjvAPAbAFtUGwRbVBsEW1QbBFtUGwRbVBsEV1QbBFtUGwRbVBsEW1QbBFtUGwRbV
BsEW1QbBFtUGwRbVBsEW1QbBFtUGwRbVBsEWxwI7wDwCO8AC-nVOl8kCiXvAPAI7wDwGwRbTBsMW
0wbDFtMGwxbTBsMW0wbDFdMGwxbTBsMW0wbDFtMGwxbTBsMW0wbDFtMGwxbTBsMW0wbDFtMGwxbT
BsMW0wbDFsYCO8A8AjvBAsk7wTwCO8A8Bv39-f39-f3RAjvAPAI7zzwCO8A8Bv39-f39-f3RAjvA
PAI7zzwCO8A8Bv39-f39-f3RAjvAPAI7wTzJO8E8AjvBAgb9-f39-f39zwI7wTwCO8A8-nVOl8k8
-sLDx8A8AjvCAv39-f39-f3PO8I8Ajs8-nVOl8sCiXs8Ajv9-f39-f391zwCOzz_dU6Xwz87xQKJ
ezwCO-39-f39-f3XPAI7PP51TpfDP8A7xAKJezwCO-39-f39-f3XPAI7PP51TpfDP8E7wwKJezwC
O-39-f39-f3XPAI7PP51TpfDP8I7wgKJezwCO-51Tpfm-sLDxzz9-f39-f3sAjs8-nVOl8M-wTvD
Aol7PAI7-nVOl8ICwTsCwTsCwTsCwTsCwTsCwTsCwDvH-sLDx8A8-nZ3ff39-f39-esCOzz_dU6X
wz-AO8QCiXs8Ajv_dU6XwgI7AjsCOwI7wAI7wQI7wAI7wQI7AjsCOwI7xv7Cw8c8Ff39-f39-ewC
Ozz_dU6Xwz87xQKJezwCO-51TpfCAsE7AsE7wAI7wQI7wALAO8ACwDvAAjsCO8X_wsPHwDwVxxEV
whHAFcARwBURwRXWEcAVEcEVEcEVEcEVEcAV0xHAFRHBFREVwRHBFcARwBURwRXTEcAVwRHAFRHB
FRHBFdcRwRURwBXBEcAVEcEV0xEVERXAEcAVERXBERURFRHBFRHBFc8RwRURwRURwRURwRXAEcAV
EcEV0hHAFREVERXAEcAVEcEVEcAV1BEVwRHBFREVERURwRURFe4RwRXAEcAVERURFcMRwRURwRXB
Ajs8-nVOl8sCiXs8Ajv_dU6XwgI7wQI7AjvAAjvBAjvAAjvBAjsCOwI7AjvF-sLDxzwVyBEVwREV
ERURFREVERURFdURFcERFREVERXBERXBERURFdERFcERFcERFcERFcERFcIRFdQRFREVERURFcAR
FcARFdoRFcARFREVERXCERXUERURFREVERURFcERFREVEcEVERXRERXBERXBERXBERXBERXCERXS
ERXBERURFREVERURFREVERURFdMRFcERFcERFREVERXBERXuERURFREVERURFREVERXBERURFREV
ERXBAjvAAv51TpfJAol7wDwCO-51TpfCAjvBAjsCO8ACO8ECO8ACwTsCOwI7AjsCO8T_wsPHwDwV
yBEVwREVERURFREVEcEV1RHBFRHBFRHAFcARwBXAERURFdERwRURwBXAERXBEcAVwBEVwhEV1BEV
ERURFREVwBEVwBHAFdkRFcARFREVEcEVwBEV1BEVERURFREVERXBERURFREVERURwBXQEcAVwBHA
FcARwBXAEcAVwBEVwhEV0hEVwRHBFREVERURwBXAERURFdMRFcERwBXAERURFRHAFcARFe4RwBXA
ERURFREVERXDERURFREVERXBAjvBAsk7wTwCO-51Tpfj-sLDxzwVyREVwREVERURFREVERXZERUR
FcERFcERFcERFREV0xEVERXBERXBERXBERXCERXUERURFREVERXAERXAERXaERXAERURFcERFcAR
FdQRwRURFREVERXBERURFREVERURFdERFcERFcERFcERFcERFcIRFdIRFcERFREVERURFREVERUR
FREV0xEVwREVwRHBFREVwREV7hEVERURFREVEcEVERXBERURFREVERXBAjvPPAI75TwVyRHBFRHA
FcARwBXAERXXEcAVwBEVwRHBFRHBFRHAFdIRwBXAEcEVEcEVEcEVwBHAFcARFdQRFREVEcAVwREV
wBHBFdcRwRURFREVEcAVwREV1REVwBHAFcARwRXAEcAVERURFRHBFc8RwRURFcERFcERwRXAEcAV
wBEV0xHAFREVERURwBXAERURFRHAFdQRwRURwRXAERXAEcEVEcEV7BEVERURwBXAEcEVwxHBFRHB
FcE80QI85RX9-f39-f3vAAAAAAAAAAE=
:: map/.info.pod
--[[pod,created="2024-03-24 00:48:06",modified="2026-02-19 21:34:53",stored="2024-03-24 00:48:06"]]
:: pal/.info.pod
--[[pod,created="2024-04-10 04:52:51",modified="2026-02-19 21:34:53",stored="2024-04-10 04:52:51"]]
:: pal/0.pal
b64$LS1bW3BvZCxiZ19jb2xvcj0wLGJsYWNrZXN0X2NvbG9yPTAsY3JlYXRlZD0iMjAyNC0wNC0x
MCAwNDo1Mjo1MSIsaGlkZGVuPXtbMF09ZmFsc2UsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRy
dWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSxmYWxzZSx0cnVlLHRydWUsZmFs
c2UsZmFsc2UsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1
ZSx0cnVlLHRydWUsdHJ1ZSxmYWxzZSxmYWxzZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSxm
YWxzZSxmYWxzZSx0cnVlLHRydWUsdHJ1ZX0saGlkZGVuX3RvZ2dsZXM9e1swXT1mYWxzZSxmYWxz
ZSxmYWxzZSxmYWxzZX0saHVlX29mZnNldD0tMC40OTU4NDQ4NzUzNDYyNixpY29uPXVzZXJkYXRh
KCJ1OCIsMTYsMTYsIjAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMTA3MDcwNzA3
MDcwNzA3MDcwNjAxMDAwMDAwMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA2MDYwMTAwMDAwMDAwMDEw
NzA3MDcwNzA3MDcwNzA3MDYwNjA2MDEwMDAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNjA2MDYwNjAx
MDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDcw
NzA3MDcwMTAwMDAwMTA3MDcwNjA2MDEwMTBkMGQwMTAxMDcwNzAxMDAwMDAxMDcwNzA2MDYwMTAx
MGQwZDAxMDEwNzA3MDEwMDAwMDEwNzA3MDEwMTA3MDcwNjA2MGQwZDA3MDcwMTAwMDAwMTA3MDcw
MTAxMDcwNzA2MDYwZDBkMDcwNzAxMDAwMDAxMDcwNzBkMGQwMTAxMGQwZDA2MDYwNzA3MDEwMDAw
MDEwNzA3MGQwZDAxMDEwZDBkMDYwNjA3MDcwMTAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcw
NzAxMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDEwMTAxMDEwMTAxMDEwMTAx
MDEwMTAxMDEwMTAwIiksbG9ja2VkPXtbMF09dHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUs
dHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRy
dWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVl
LHRydWUsdHJ1ZSx0cnVlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlfSxtb2RpZmllZD0iMjAyNi0wMi0x
NSAxNzoyMDoxOCIsb2twYWxfdmVyc2lvbj0iMC4yLjEiLHBpY2tlcnNfbW9kZT0ibGluZWFyX2h1
ZSIscmV2aXNpb249MTYxMyx0ZXN0X2N1YmVfY29sb3JzPXtbMF09ezE1LDMxLDR9LHszMSw0LDIw
fSx7NCwyMCwyMX0sezEwLDksMjV9LHs5LDI1LDI0fSx7OCwyNCwyfSx7MjYsMTEsMjd9LHsxMSwy
NywzfSx7MjcsMywxOX0sezI4LDE3LDE5fSx7MjgsMTIsMTZ9LHsxMiwxNiwxfSx7NiwyOSwxM30s
ezI5LDEzLDE4fSx7MTMsMTgsMX0sezcsMjMsMTR9LHsyMywxNCwxM30sezE0LDMwLDE4fSx7Nyw2
LDIyfSx7NiwyMiw1fSx7MjIsNSwyMX0sezEsMSwxfSx7MSwxLDF9LHsxLDEsMX19LHRlc3RfbW9k
ZT0iY3ViZXMiLHRlc3RfcmFtcF9jb2xvcnM9dXNlcmRhdGEoInU4IiwxMCwyNywiMDAxODA4MTkw
OTBhMWEwYjFiMDAwNjAwMDAwMDAwMDAwMDAwMDMwMDE2MDAwMDAwMDAwMDAwMDAxMzAwMDUwMDAw
MDAwMDAwMDAwMDAxMDAwZDAwMDAwMDAwMDAwMDAwMTAwMDFkMDAwMDAwMDAwMDAwMDAxMTAwMTcw
MDAwMDAwMDAwMDAwMDBjMDAwZTAwMDAwMDAwMDAwMDAwMWMwMDFlMTIwMjE1MTQwNDFmMGYwNzAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDE0MDQxZjBmMDgxODAyMDAwMDE1MDUxNjA2MDcxNzBlMWUw
MDAwMDExMDExMGMxYzFkMGQxMjAwMDAxMzAzMWIwYjFhMGEwOTE5MDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwIiksd2hpdGVzdF9jb2xvcj03XV1sejQA4QEAABUCAAD1BXVzZXJk
YXRhKCJpMzIiLDY0LCIwAQDAMWQyYjUzMDA3ZTI1CADwFzAwODc1MTAwYWI1MjM2MDA1ZjU3NGYw
MGMyYzNjNzAwZmZmMWU4CABAMDA0ZAgAEWE2AGBmZmVjMjcKACBlNDgAQDI5YWQkAGA4Mzc2OWMg
ADE3N2E4AMBjY2FhMDAxYzVlYWMwAPAdYTVhMTAwNzU0ZTk3MDAxMjUzNTkwMDc0MmYyOTAwNDky
ZDM4MDBhMjg4NzlAAPADYWNjNTAwYzMwMDRjMDBlYjZiRgBgOTBlYzQyCgAgYjLAAKA2NGRmZjYw
MGJkiQAAlgBAMGRhYkAAVjg1NmQwAQBAODE0MbAA8A03Mzk0YTAwNDM2MjdkMDA5OTJjNzEwMGNh
MDA3yAAwYTI0DABAMTA2YcgA8B5iYzY2ODMwMGZhOWJiYTAwOWU5OTU0MDBmN2YwYTIwMDVjOTU2
MjAwOTNlODlYAPAFODkzOTEwMDg0ZGVkYjAwOTg2ZWJYAcBhYTllYTAwYWQ3NzQgATAxYWGgAEA1
MTg5WAB1ODRjMmY5MAEAEDQCAHA0MDA3Njc3qABBZGFkYVAA8gZmYTBhNjAwMWUzNzNjMDAzZjU2
NWGoASYwMAgAgDE2MTYxNiIp
:: sfx/.info.pod
--[[pod,created="2024-03-24 00:48:06",modified="2026-02-19 21:34:53",stored="2024-03-24 00:48:06"]]
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI2LTAyLTE5IDE0OjI5OjU5Iixtb2RpZmllZD0iMjAyNi0w
Mi0xOSAxNDozMTozOCIscmV2aXNpb249Mix3YXZlbWFrZXI9e2Jhcl9sZW5ndGg9MTYsYmVhdF9s
ZW5ndGg9NCxuZXdfdHJhY2tzX2xlbmd0aD0wLG5ld190cmFja3Nfc3BlZWQ9MTYsdmVyc2lvbj0i
MC4yLjEifV1dbHo0AGTXAADl-QAA-xhweHUAAygAgAQABA9AEAIOAAGgASACoA4ADxAADfDKAQID
QA8P8P8BAOvxA_YBEAYPMBABIAEgAfAADyIQAg4A_SMPISABMA_S8MMPKA--8MQBAA-4Cg--D4AP
9w8NAQAHCg8gMA90D2UPcw90DyAPdw90kEgARAIQAgxGAB8ORQAIb-AFARAGDDYA--------Qh--
AQCs8hPEDgANQB81DzcPOC86DzwfPRwfMR8zLzX--x0ACyAbEAsAAgCi_x8PIAspGxkLCQIAQPsf
8HA7AC-7sAgAHh--AQD-5fH---8_KAEPgAEIAwgGCAoIDQgPFwgPHwgPKAgPMggPPggPSwgPWQgP
aQgPeQgPiwgPnggPswgPyAgP3wgP9wgND4EPKw_BD0YPgQ9jL4EPoQ_BD8EPgQ-jD4EGD4IPKg_C
D08Pgg92D4IPng_CD8cPgg-xD4IPHQ_DD0kPgw93D4MPpg_DD9YPgw8ID4QPOw_ED24PhA_jD4QP
2g_EDxEPhQ9KD4UPgw_FD74PhQ-6D4UPOA_GD3YPhg_2D4YP9w_GDzkPhw98D4cPwA_HBg_ID0wP
iA_UD4gP3Q_IDycPiQ9yD4kPvw_JDwwPig9bD4oPqw_KD-wPig9OD4sPoQ_LD-UPiw9KD4wPoQ_M
D-kPjA9RD40Pqw_NBg_OD2IPjg_-D44PHg_PD30Pjw-dD48PPw_QD6EPkA8FD5EPag_RD88PkQ82
D5IPng_SBw_TD3EPkw-cD5MPSA_UD7UPlA8jD5UPkw_VAw_WD3QPlg-mD5YPWg_XD84Plw9DD5gP
uQ_YDzEPmQ_pD5kPIg_aD5wPmg8YD5sPlA_bDxEPnA_PD5wPDg_dD44PnQ8PD54PkQ_eDxQPnw_Y
D58PHA_gD6IPoA8pD6EPsA_hDzgPog-CD6IPTA_jD9cPow9jD6QP8A_kD34PpQ8MD6YPnA_mDywP
pw_9D6cPTw_oD_IPqA92D6kKD6oPoA_qDzYPqw-ND6sPZQ_sD-0PrA_XD60PMQ_uD8wPrg9oD68P
BQ_wD6IPsA4PsQ-fD7EPfg_yDx8Psw-AD7MPYg_0BA_1D6gPtQ9MD7YP8A_2D5YPtw88D7gP4w_4
D4oPuQ8zD7oP2w_6D4UPuw8vD7wP2g_8D4UPvQ8yD74P3g__D4wPvw86D8AP6A-AD5gPwQ9HD8IP
_A-CD6kPww9bD8QPDQ-FD78PxQ9zD8YPJw-HD9sPxw_QD8gPRQ-JD-sPyQ_yD8oPaQ-LDyEPzA-Z
D8wPkQ-ND0oPzgQPzw__D88PeA-QDzMP0Q-uD9EPqg-SD2cP0w8jD9QP4A-UD54P1Q9cD9YPGg-X
D9kP1w_YD9gPVw-ZDxcP2g-XD9oPmA-bD1kP3A8aD90P3A-dD54P3g9gD98PIg-gD_UP4A_pD_EP
bA-iDA-jD-TwAPH-MOQPfQ-lD0EP5gcP5w-MD_cPkQ-oD1cP6Q8dD_oP4w-qD6oP6w9wD_wPNw-t
D-4P7Q-FD_4PjQ-vD1QP8A8cD-EP4w-xD6sP8g9zD-MPOw-0BA-1D8wP9Q_VD-YPXQ-3DyYP_A-u
D-gPtw-5CA-6D0kP_w8SD-wP2w-8D6QP-Q9tD-4PNgsQD8gAD5EBD1oCDyMDD_wDD7UED34PBQ9H
Bg0HD9gHD6EPCA9pDwkPMgoP_goPww8LD4sPDA9TDw0PGw8OD_IPDg_qDw8PcQ0POQ8RAA8SD8cP
Eg_ODxMPVA8UDxsPFQ-hDxUPpw8WD20PFw8yDxgP9w8YD70PGQ_BDxoPRg8bCg8cD84PHA_SDx0P
VQ8eDxkPHw-cDx8PngkPYA8hHyIP5A8iD6UPIw9mDyQPJw8lD_cPJQ_nDyYPZg4A8JQoD_QPKA_i
DykPYA8qDx4PKw-bDysPmA8sD1QPLQ0PLg-LDy4Phg8vDgwP_gwPtA8xD20PMg8lDzMP3Q8zD5UP
NA9MDzUDDzYPuQ82D24PNw8jDzgP1w84D4sPOQ8-DzoP8Q86D6QPOw9VDzwGDz0Ptw89D2YPPg8W
Dz8PxA8-D3IOCQ9BD80PQQ95D0IPJA9DD88PQw95D0QPIw9FD8wPRQ905gABpwLx-wVHD2gPSA8O
D0kPsg9JD1YPSg-6D0oPnA9LDz4PTA-fD0wID00PHw9OD74PTg9cD08P_g9PD5YPUA8yD1EPzQ9R
D2cPUgEPUw_ZD1MPMQ9UD8gPVA9fD1UP9A9VD4gPVg8cD1cPrw9XD0EPWA-SD1gPYw9ZD-IPWQ_B
D1oPDg9bD5sPWw8nD1wPsg9cDz0PXQ-GD10PTg9eD9YPXg9cD18P4g9fD2cPYA-qD2APbQ9hD_8P
YQ9wD2IP8A9iD28PYw-tD2MPaw9kD_cPZA9iD2UP3A9lD1UPZg-OD2YPRQ9nD7sPZw8xD2gPpQ9o
DxgPaQ_KD2kP-A9pD2wPag-bD2oPSQ9rD7YPaw8iD2wPjQ9sD-cPbGoA8f8xyA9tDy8Pbg_VD24P
_g9uD10Pbw-AD28PIQ9wD4IPcA-hD3APPw9xD5wPcQ-4D3EPUw9yD60PcgYPcw9eD3MPtA9zCg90
D14PdA_xD3QDD3UPVA91D6QPdQ-yD3UOD3YPjA92D9gPdg8iD3cPaw93D7IPdw-5D3cPPg94D4MP
eA-GD3gPCA95D0kPeQ_ID3kPxw95BA96DgUPewUPtQUP7gUPJQ97D1sPew_QD3sPxA97D-cPew8o
D3wPWQ98D4gPfA_1D3wP4g98Dw4PfQ84D30PYQ99D4kPfQ_vD30P1Q99D-kPfQ8cD34PPg9_D14v
fg_cD34PuQ9_D9QPfg-vD34PCA9-CQsPNwsPTAsPYQsPdAsPhgsPlgsPpgsPtAsPwQsPzAsP1wsP
4AsP6AsP7wsP9QsP_QsP-AsP-gsP-wYAEfwSABH1HgAR6CoAQdcLD808ABG0SAARllQAEXRgABBN
bABRCQsPCAt_ABPVjgBTnC9_D1_mAACuABP5vgATsM4AE2HeAADmAFPjD3wPtv4AAAYBMSkPfBYB
8ADFD3sPkQ97D1wPew8mD3s9AfMCtgUPfAUPQQUPBQUPyA95D4lrAREJawECgwGTPw94D-oPdw_z
owEAqwEAswHzEo0Pdg9BD3YP8w91D6UPdQ9VD3UEAg_yD3QPXw90CgcPtQQC8SYHD3MPrg9yD1QP
cg-5D3EPnQ9xDgAP4g9wD4MPcA8iD3APwQ9vD14Pbw-7D24Plg9uDA0PyeUC8f-dbQ-4D2wPjg9s
DyMPbA_3D2sPSg9rD9wPag9tD2oP-Q9pD4sPaQ8ZD2kPpg9oDzIPaA_8D2cPRg9nD88PZg9XD2YP
3Q9lD2MPZQ-oD2QPbA9kD_8PYwAID-IPYgABD-EPYQ9vD2EP7A9gD2gPYA-jD18PXg9fD9cPXg9Q
D14Pxw9dDz4PXQ_0D1wPKQ9cD50PWw8QD1sPgg9aD-QPWQ9kD1kP1A9YD0MPWA_xD1cPHg9XD4oP
Vg-1D1UPYA9VD8oPVA8zD1QPmw9TDwIPUw9pD1IPzw9RDzQPUQ_YD1AP_w9PD14PTw-AD04PIQ9O
D4EPTQ-hD0wOBg_eD0sP_w9KD1gPSg_0D0kPDw9JD2oPSA-ED0cPHQ9HAg9GD80PRQ8kD0UPew9E
D9EPQw8mD0MFD0IPzg9BDyEPQQcOD8YPPw8XDz8PaA8_D7gPPQ8IDz0PVw88D6UPOw-zDzoOAw_N
DzkP2Q84DyUPOA9wDzcPug82BAkPTg81D5cPNA-fDzMPJw8zD28PMg_2DzEP-AwPQgwPiA8vD80P
Lg8RDy4PVg8tD5kPLA-dDysPIA8rAQ8qD6QPKQ-mDygPJw8oD2gPJw_pDyYP6Q8lDykPJQ9oDyQP
pw8jD_YPIg8kDyIBDyEPoA8gD90PHw8bDx9AAfGZlA8dD9APHA8MDxwPSA8bD4MPGg_-DxkP_Q8Y
DzQPGA9vDxcPqQ8WD_MPFQ8dDxUPVg8UD5APEw-JDxIPAg8SDzsPEQ9zDxAPrA8PD_QPDg8dDw4P
VQ8ND40PDA-FDwsP-AoPNAoPaw8JD6MPCA-aDwcPEg8HD0kPBg_ADwUPtwQP7g8DDyUPAw9cDwIP
kw8BD8ovAA84D-8Pbw-_D6YP-Q-dD-wPFA-8nwHxpYIP_g_5D-kP8A-4DygP_A9fD-cPlw-2D84P
9Q8GD-UPPQ-0Ag-zD60P8g-lD-EPHg-xD1YP8A_PD_8Pxw-uDwAP7g85D_0Pcg-sD6wP6w-lD_oP
Hw-qD1kP6Q_TD_gPzg-nDwkP5w9DD_YPfw-lD7oP5A-2D_MPMg-jDQ-iD6oP4Q-nD_APJA-gAQ-f
D6Af3g-dDxwP3Q9bD9wPmg-bD9kP2g8ZD9oPWQ-ZD5oP2A-bD9cPHNwC8WvWD6AP1Q-iD9QPJQ-U
D2gP0w_sD9IP8A-RDzUP0QUP0A-AD88PBg-PBg-OD5MPzQ-bD8wPIg-MD2sPyw_0D8oP-Q-JD0cP
yQ_SD8gP3Q-HDygPxwIPxg-BD8UPDw-FD1wPxA_rD8MP_g-CD0kPwg_ZD8EP6g-ADzwPwIoL8Rjg
D74PMw__D4cPvQ-cD7wPMQ_8D4cPuw-dD7oPNA_6D4wPuQ-lD7i3AvGZmA_3D-IPtg9ND7YPqQ_1
DwYPtQgPtA-CD7MPIA_zD4APsg-gD7EPQg_xD6MPsA8GD7APaQ_vD84Prg8zD64PmA_tD-8PrA9m
D6wPzg_rDzcPqw_hD6oPDA_qD3cPqQ-kD6gPUQ_oD78Ppw8tD6cPnQ_mDw4Ppg9-D6UP8Q_kD2QP
pA-YD6MPTQ_jD8MPogMLD7EPoQ8qD6EPow_gDx4PoA_ZD58PFQ_fOwxREA_eD4-jC-FGnQ_QD5wP
Eg_cD5UPmw8ZD5sPng_aDyMPmg_qD5kPMg_ZD7sPmA9ED5gPzw_XD1sPlw-nD5YCAAQAD5QPlQ8l
D5UPtg_UD0kPlA-dD5MPcg_TDwgPk2YA8Q03D5IP0A_RD2sPkQ8GD5ELD5AOBw-eD48Pfg_P4gzw
AcAPjggJDwcJD6wPjQ9SD40ODfMBCwwPSwwP9g_LCwoPTgoP-EANcVwPig8ND4pYDfAFcw_JDygP
iQ-eD4gPlQ_ID00PiA_IDXHBD4cPfQ_Hnw0Apw1xtw_GD3cPhr8Nk-sPhQ_-D4UPhN8NMRIPhe8N
U6QPhA9vBw4ADw5R1w_DD6dKBlGDD0oPgzcOE-JHDhOeVw4TUGcOAG8OE_N_DgCGDvELgg_BCA0P
Rw0PKw0PEA0P9w_AD98PgA-ID4D-AfEjng_ACgEPeQEPaQEPWQEPSwEPPgEPMwEPKAEPHwEPFwEP
EAEPCgEPBgEPAwEPAQEFAQUKAPNIBQEPCQEPDgEPFAEPGwEPIwEPLQEPNwEPQgEPTwEPXAEPawEP
ewEMAQ_eAQ_xAQ-FAQ-aAQ-wAQ8IDQ8gDQMND1QND3AND40ND6oND8kND_kNDwoPgg8sJw-zbnQP
gg_ZD4IPvw_CD_cPgg8PD4MPOQ_DD2QPgw_PD4MPvA_DD_oPgw8ZD4QPSQ_ED3oPhA_sD4QP3w_E
DxMPhQ9ID4UPfg_FD7UPhQ-uD4UPJw_GD2EPhg_dD4YP2Q_GDxcPhw9VD4cPlQ_HD9UPhw8XD4gP
WQ_ID50PiA-hMA-wOW4PiQ_1D4kP-g_JD0gPig_SD4oP3g_KDysKD3gKD8cKDxcMD2cMD7kMDwsP
jQ9fD40Psw_NDwkJD18JD7cJDw8Pjw9pD48Pw1YC8xYHD3oHD9cHDzYPkQ_VD5EP9Q_RD1YPkg_3
D5IPGg_TD34Pkw-jLg-xaq8PlA8WD5UPfg_VD_gPlQ9SAA_9AA8pD5cPlQ_XDwMPmA9yD5gP4Q_Y
D1EPmQ-DD5kPNQ_aD6gPmg8bD5sHBg8GD5wPfA_cD-MPnA9rD50P5A_dD14Png-YD54PVA_fD9AP
nw9ND6APyw_gD0kPoQ-JD6EPSQsPygsxD-Nrzw_jD1IPpA-WD6QPWw_lD_EPpQ9nD6YP7w_mD3cP
pw--D6cPiQ_oDxMPqQ_eD6kPKg_qD7YPqg9ED6sP0g_rD2APrA-wD6wBD60PEA_uCwIPNA_vD8cP
rw9aD7AP7g_wD4MPsQ8ZD7IPrw_yD0YPsw-dD7MPdg_0Dw45D-EYQg_2D9wPtg94D7cPFA_4D7AP
uA9ND7kP6w_5D4kPug8oD7sPyA_7qQjxJQkPvQ_qD70PTA__D_4Pvg_RD78PNQ-AD9kPwA99D8EP
Ig-CD8gPwg9uD8MPFQ-ED7wPxAjGBjHGD7QfDPECxw8HD8gPsQ-ID1wPyQ8HD8pAD-FAXg-LDwoP
zA_3D8wPZA-NDxIPzg-AD84Pbw-PDx4P0A-ND9APfQ-RDy0P0g-eD9IJD9MOD9QP8Q-UD6QP1Q9W
D9YPCQ-XD7wP1w9vD9gPI00P8xXZDA-aDg-bD-UP2w_rD9wPYA-dDxYP3g-ND94Pgw-fAw-gD-FE
D-JtYA-iDxgP4w-QD_MPiA-kD0EP5Q-6D_UPsw-mD2wP5w8mD_gP3w-oD5kP6Q9TD_oPDQ-rD8gP
6w_CD_wPPQ-tD-gP7Q_zD_4Pbg-vDyoP8A-lD-APoQ-xD10P8g8YD-MP1A-zBw-0D00P9Q8JD-YP
xQ-2D4IP9w8_D-gP_04P8BoPdA-6DzEP_w-tD-sPqg-8D2cP-Q8kD-4P4Q-_D54P-w9aDwAPFwUP
1P0R8EICD04PAw8LDwQPxw8ED4QPBQ9BDwYP-Q8GD7oPBw92DwgPMw8JD_8PCQ_rDwoPaA8LDyQP
DA-gDwwGDw0PVw8ODxMPDw-ODw8Pig8QD0UPEQ9mD-AOuw8SD3YPEw8wDxQP6w8UD6UPFQ9fDxYP
GQ8XD9J6A-AcGA9FDxkP-g8ZD7cPGg9wDxsPKA8cD_APHA_YDx0PUA8eDwcPHw__Dx8PdVoJ8XoP
IQ-iDyEPmA8iD00PIw8DDyQPuA8kD20PJQ8hDyYP1Q8mD4kPJw88DygP8A8oCw8pD1UPKg8HDysP
uQ8rD2oPLA8bDy0Pyw8tD3wPLg8rDy8P2w8vD4oPMA84DzEP5g8xD5QPMg9BDzMP7g8zBg80D0cP
NQ-yDzUPnQ82D0gPNw-yDzcGDzgPRbEIEDkJE-MJPQ87D_QPOwoPPA8xDz0P1w89D3wPPg8geg-x
CWgODwsPQQ_tD0EPTw9CD-APQg_RD0MPMa0K8ARED3APRQ8OD0YPrA9GD0kPRw-l4gXxEEgPHQ9J
D7cPSQ9SD0oP6w9KD4QPSw8cD0wPsw9MD0odC-MUTQ92D04PCw9PD58PTw8zD1APxg9QD1gPUQ-p
D1EPeg9SDwqED-FrKA9UD7YPVA9DD1UP0A9VD1wPVg-nD1YPcQ9XD-oPVw_DD1gPCw9ZD5MPWQ8Z
D1oPnw9aDyQPWw_oD1sPLA9cAgQPMA9dD7EPXQ8xD14PsQ9eDzAPXw_tD18PKg9gD6cPYA8iD2EP
nQ9hDxYPYg_PD2IPBwgPfwgP9QiHD-EW3w9kD1MPZQ-GD2UPOA9mD6kPZg8aD2cPiQ9nD-gPZw9m
D2gP0pwL8RJpD6kPaQ8TD2oPfQ9qD_UPag9MD2sPsw9rDxkPbA99D2yZEvETRA9tD6YPbQ8HD24P
Zw9uD8YPbg8kD28NAA-dAA85D3APk4wSAFkBAowP8f8n8w9xD0gPcg_dD3IP8Q9yD0MPcw_VD3MP
5Q9zDzUPdA_ED3QP0Q90Dx4PdQ9qD3UPtQ91D-4PdQ9HD3YPjw92D9UPdg8bD3cPYA93D6MPdw-m
D3cPJw94D2gPeA_oD3gP5g94DyQPeQ9gD3kGAQ-WAQ8PD3oPSA96D38Peg_1D3oP6g96Dx4Pew9S
D3sPhA97D7UPew-lD3sPEw98D0EPfA9uD3wPmg98D8QPfA-uD3wPFw99Dz4PfQ9lD30Pig99AgkP
0QkP9AkPFQ9_DzUPfg9UD34PcQ9_D44Pfg_qD34PxA9_D94Pfg-3D34PDg9-DyQPfw85D38PTg9-
D2EPfw9zD38Pgw9-D5MPfwsHD7AHD7wHD8gHD9IHD9sHD_QHD_sHD-EHD-YHD-kHD-wHD-4HBQcF
CgAg_AdjBHHtBw-lBw-cMQDxy8YHD7kHD6oHD5oHD4gHD3UHD2EHD0sHDzQHDxsHDwEHD_YPfg-J
D34Pqw9_D4wPfg9rD34PSA9_DyUPfg--CQ-ZCQ_xCQ_ICQ9dCQ8xCQ8ECQ-VD3wPpQ98D3MPfA4M
DwwMD9YPew_fD3sPZw97Dy0Pew-yD3oPtg96D3gPeg85D3oP_AEPtgEPcwEPLwEP6Q94CwMPWQMP
DwMPxA93AwoPKgoP2w92D4oPdg85D3YP5g91D5EPdQ88D3UP5Q90D40PdA8zD3QP2A9zDAQPHwQP
wQ9yD2EPcg8AIQKwcQ86D3EP1Q9wAAjFAvFCnwAPNQAPyg9uD14Pbg-wD20Pgg9tDxIPbQ_hD2wP
Lw9sD7sPaw9GD2sP0Q9qD1oPag-hD2kPaA9pD_4PaA9yD2gP9Q9nCg0P_A9mAwYP9w9lXSIT8YEP
8T3mD2MPXw9jD9cPYg9OD2IPxA9hDzkPYQ_sD2APHw9gD5APXw8BD18ID14P3w9dD0wPXQ_5D1wP
JA9cD44PWw-4D1oPYA9aD8cPWQ8tvwPzC1gP9w9XD1sPVw_9D1YPHg9WBw9VD98PVA89ew-xDvgP
Ug9UD1IPrw9RDwkPUQ9iD1APug9PDxIPTw9o0RPyOk0PEw9NDQ9MD7oPSw8MD0sPXg9KD64PSQUP
SA9ND0gPnA9HD_kPRg82D0YPgg9FD80PRA8XD0QPYQ9DD6oPQg-yD0EPOQ9BD4B2D5ELDz8PUA8_
D5QZBfNOPA8aDzwPXA87D50POg-eDzkPHg85D10POA_cDzcP2g82DxcPNg9UDzUPkQ80D8wPMw8H
DzMPQg8yDA8xD7YPMA-vDy8PJw8vD18PLg_WDy0PzQ8sDwQPLA86DysAcw-xCNkPKA8NDygPQQ8n
D3QPJg_nDyUP2Q8krgbzQT0PIw9uDyIPnw8hD88PIA--Dx8PLw8fD14PHg_NDx0PvA8cD_oPGw8Y
DxsPRg8aD3QPGQ_hDxgPzg8XD-sPFg8nDxYPUw8VBw8UD6sPEw-Xaw-wEy0PEQ9YDxAPgw8PD60P
Dg-YDw0PAg8NDywPDA9WDwsPgA_TGPAACQ-TDwgP-Q8HDyYPBw9QiQsQBW0H8hzLDwMP9Q8CDx4P
Ag9HDwEIDwAPmQ--D8IFD_sP-Q8UD-0PPQ-8DQ-7D5APZQ-xTuMP_A8MD-gPNg-3D18P9g_JD-UP
sw-0D90P8w8HD-MPMQ-yD1wP8Q_GD-APsQ-vD9wP7g8HD_4PMg-tD14P7A_KD_sPtQ-qD_IP6Q8O
D_kPOw-oD2gP5w_VD_YPwmUIs_QPHg-kD00P4w97Xw-zXNoP4A8KD_APOg-fD2oP3g_bD90PzA-c
BQ-bDzAP2w9iD9oPlQ-ZD8gP2A-8D9cPMA-XD2QP1g_ZD9UPzw-UDwQP1A87D9MPcg-SD6kP0Q-h
D9APGg-QD1MPzw_MD84Pxg-NDwEPzQ88D8wDWg-xNvEPyQ8uD8kPbA-ID6sPxw-qD8YPKg-GD2sP
xQ_sD8QP7g-DDzEPww90D8IPuA-BD-wPwA9CD8APiA_-D84Pvg8WD74PXhsa8xS8D-APuw87D7sP
hg_6D9IPuQ8eD7kPbA_4D7oPtw8JD7cPWVMPkfsPtA9ND7QPoFABEbIBF-ELnw_xD-UPsA9ND7AP
pQ_vBQ_uD1gPrg_zD63uAfInbA_sD8kPqw8oD6sPhw_qD_gPqQ9JD6kPrA_oDw8PqAQPpw-ZD6YP
Px_mD6UPDg_lAw_kD_IPRw-xGLoLDycLD5UPoQ8FD6EPdQ_gD_cPnw9ZD58PzQ_eD0IPng_3D50P
LosP8SicDx8PnA_ZD5sPFQ_bD5EPmg8OD5oPjQ_ZDw0PmQ_OD5gPEA_YD5MPlw8XD5cPnA_WDyMP
lg_rOhgzlQ__Qw-xCtYPkw9jD5MP8g_SD4IPkg8UD5IPpg_RDzr4G-HIkA9lD5AP-A_PD5UPjw8v
D48Pyg_OBgIPBAIPow_ND0MPjQ-kD4wPhw_MDysPjA-QD4sPdg_LDx4Piw-HD4oPcg_KDx0Pig-K
D4kDCQ8oCQ-ZD4gPiw_IDz4PiA-zD4cPqQ_HD2EPhw8ZD4cP0w_GD48Phg9MD4YPCg_GD8kPhQ_K
D4UPTA_FDxAPhQ-VD4QPmw_ED2IPhA8rD4QP9g_DD8EPgwIKD10KDywKBQ_CD9APgg_kD4IBDg9Q
Dg8oDg8BDg-cD4EPuA_BD5YPgQ91D4EPVQ_BDzfCGRGBTSHxHOUPgA-MD4APtQ_AD58PgA_LD4AD
DAYMD1YMD0cMDzoMDy4MDyMMDxoMDxKLBvEIBwwPAwwPAQwADAAMDwIMDwUMDwgMDw0fAPBgGAwP
HwwPKAwPMQwPOwwPRgwPUgwPXwwPbQwPfAwPjAwPnQwPrwwPwgwP1gwP6gwPAA_BDxcPgQ8uD4EP
Rw_BD2EPgQ97D4EPlw_BD7MPgQ-QD4EP7w_BDw4ODy4OD08OD3IOD5UOD7kOD94ODwQKrw7wDlIK
D3sKD6UKD9AKD-sKDygPhA9VD4QKBw_zBw-jlgTxGoUPRg_FAQgPrQgP4ggPGA_GD08Phg_HD4YP
vw_GD-kPhg8zD4cPbg_HrgLwAugPhw8mD4gPZQ_ID6UPiA-lMQ-hCQ9qCQ_tCQ-xCQ83D4qBCPEK
xA_KDwwPiw9VD4sPng_LD_kPiw80D4wPgbwD8T_MDxwPjQ9rD40Puw_NDwsCD10CD68CDwIPjw9X
D48PrA_PAA_QD1gPkA_vD5APCA_RD2EPkQ_7D5EPFg_SD3EPkg-OD5IPKw_TCQ0P6A06D-NyqQ_U
DwoPlQ9sD5UPzw_VDzMPlg_YD5YP-Q_WD2QPlw-LD5cPMg_YD5sPmA8ED5kPbg_ZD9kPmQ9FD5oP
sQ_aDx8Pmw_ND5sP_w_bD2sPnA-bD5wPTA_dD74PnQ8wD54PpA_eDxgPnw_MD58PAg_gAwQP7wQG
D6EP3w_hD1gPog-RdR7xIMcPow9DD6QPvw_kDz0PpQ_7D6UPOQ_mD7gPpg84D6cPuQ_nDzoPqA_8
D6gPPw_p3h3xDEYPqg-LD6oPUA_rD9YPqw9cD6wP4w_sD2sPrQIVUXwPrg8GCwHzGK8PGw_wD6YP
sA8yD7EPvw_xD0wPsg-aD7IPaA_zD-cPsw_HD7QPF08P8Us5D7YPyw_2D10Ptw-wD7cKD7gPFw_5
D6wPuQ9BD7oP1w_6D20Puw8DD7wPmg_8DzIPvQ-KD70PYw__D-wPvg_WD78PMA-AD8oPwAYPwQAP
wg_dD8IPOg-DD9dFBfMTxA8SD8UPsA-FD08Pxg-uD8YCD8cPLg-ID84PyA9vD8kPEFQP8CdUD8sP
9w-LD5oPzA89D80P4A-NCA-ODykPzw-OD88Pcw-QDxgP0Q__D9EPZA-SDwsP0w_yD9MfGPM6AA-V
D6kP1Q9RD9YP_Q-WD6IP1w9LD9gP9Q-YD58P2Q9JD9oP8w-aD50P2w9ID9wP8w-cD58P3Q9LD94P
9g-eD6MP3w9PD_AP-F8P8QJWD_IPAw-jD7EP4w9eD_QPDBoW8V-lD2kP5g8XD_cPxg-nD3UP6A8k
D_kP1A-pCg-qDzMP6w-iD_sPkg-sD0IP7Q-zD_0Pow-uD1QP7w8ED-APtQ-wBg-xDxcP8g-ID-IB
D-MPKg-0D9wP9A_ND-UPPw-2D-AP9g_iD-cPVA-4DwUP_WUP8CxpD-oPGw-7D80P_w9-D-wPMQ-9
D_MP-Q_VBQ9HD-8P_Q--D6sPAA9dAA8PDwIPwg8CD3QPAw8mDwQP1wEL8SAFDzsPBg-tDwYPnw8H
D1EPCA8CDwkPtA8JD2UPCg8XDwsPyA8LD3oPDA8rDw0P3MQX8wAODz4PDw-uDw8Pnw8QD1BtD-Es
sA8SD2APEw8QDxQPwA8UD3APFQ8fDxYPzg8WD34PFw8tDxgP2w8YD4oPGQ84DxoP5g8aD5QPGw9C
DxypH-M0nQ8dD0oPHg-3Dx4PpA8fD1APIA-9DyAPqA8hD1QPIg8ADyMPqw8jD1YPJA8ADyUPqw8l
D1UPJgULD6gPJw9RDygP_uUeMUsPKj0B8QaaDysPQQ8sD_gPLA_PDy0PNQ8uD9sDBfIhLwsPMA-L
DzAPbw8xDxMPMg_3DzIPWg8zD-0PMw_fDzQPQg81D_MPNQgPNgsPNw-Gdw8xBg85hAPzEkQPOg-i
DzoPgA87Dx0PPA_6DzwPVw89D-MPPQ_PDz4PKn0P8CVfD0AP_A9AD5EPQQ8qD0IPwg9CD1oPQw-x
D0MPiA9EDx4PRQ_0D0UPSQ9GD90PRg9xD0cP6wrzOZgPSA8qD0kPvA9JD00PSg-eD0oPbg9LBQwP
jQ9MDxsPTQ_pD00PNg9OD8MPTh9PD9oPTw9lD1AP7w9QAQ9RDwIPUg_LD1IPEoIP8Q4gD1QPpg9U
DysPVQ_wD1UPNA9WD7cPVg86D1cPvLkA8TRYD74PWA8_D1kPvQ9ZDzwPWg_6D1oPNw9bD7MPWw8v
D1wPqg9cDyUPXQ_fD10PGA9eD5APXg8ID18Pfw9fD-UPXw9qxCFxYA9TD2EPx0oM8gFiD6sPYg8c
D2MPjA9jD-wPFh-xFtkPZA9GD2UPsg9lDx4GCQYP8wYPXQ9nD8UPZw8tD2gPlA9oD-sFHPNIaQ-F
D2kPKQ9qD4wPag-uD2oPTw9rD7APaw8QD2wPbw9sD80PbA8rD20Phw9tD_MPbQ8_D24PmA9uD-EP
bg9JD28PoQ9vD-gPbw9ND3APog9wD-cPcA9Klg-xKe4PcQ8-D3IPjw9yD94Pcg8sD3MBDg-FDg8R
D3QPWw90D6UPdA-uD3QPNg91D30PdQ-DD3UPCQ92_RDwHZEPdg-TD3YPFQ93D1YPdw_WD3cP1Q93
DxMDD1ADD4wDD8gDDwIBDzwBD3UBxRTD4wEPGQ96D04Peg_ClQ-xOecPeg8ZD3sPSQ97AwcPpwcP
1AcAD3wPLA98D1cPfA_BD3wPqg98D9IPfA-5D3wPHw99D0QPfQ9oD30Piw99D60PfQ-OD30P72ke
8xx_DywPfg9KD34GDQ_CDQ_dDQ_2DQ-PDQ-nDQ-9DQ8TD38PKA9-DzwPfw9PlA-xGHIPfw_CD38P
kQ9-D58Pfw_sD38PuA9-D8MPfw-ND38P1w9-D98Pf-Ia0e0Pfw-yD38P9g9-D-pjBDB-BQQCAPMs
D-sED-gED-IED_sED_IED9cED8sED74ED64ED50ED4sED3cED2EED0kEDzAEDxYED-kND9wND7wN
D5u8F-EgLg0PBg0P3Q99D7MPfQ_GD30PWA99DykPfQ-4D3wPxQ98D5EPfA9bD3wPIw98D_o_EHJ0
Bw82Bw-3lw-RDgIPLwIP6gEPowEPWmUYocQDD3cDDygDD9gfGfMldw8zD3cP3g92D4cPdg8wD3YP
1g91BwoPHwoPwQ90D2IPdAAID58ODzsOD9YPcg9vD3IPB4wP8Q8yD3EPxg9wD1gPcA-pD28DCw8G
Cw_SD24PHQ9uD6eOIfESbQ_2D2wPOw9sD78Paw9CD2sPww9qD0MPag-CD2kPPw9pYhYRNvElsWcP
Jw9nD54GDxMG9ggT_ogP81HcD2MPSw9jD7kPYg8lD2IPkA9hD-oPYA9jD2APyw9fDzEPXw_WD14P
_i9dD74PXA8eD1wND1sP2w9aDzgPWg_UD1kP7w9YD0gPWA_gD1cP9w9WD04PVg_jD1UP9g9UD0l9
D-AE7A9SDzsPUg_KD1EP1w9QDyQPUL4TEbp3FfEuTg9MD00Pkw9MD9oPSw8gD0sPZA9KD6gPSQ-r
D0gPLA9ID20PRw_tD0YP7A9FDysPRQ9oD0QPpA9DD_APQsMFcFUPQQ_OD0B3D-EoBQ8_DzQPPg9q
Dz0Pnw88D9MPOw8HDzsfOg9sDzkPnQ84D84PNwUPNg8tDzYPWw81CQ80D7YPM1IdsQ8PMg86DzEP
ZQ8wBQzwArgPLg-hDy0PCQ8tDzEPLA9YfxoCaw-wD8oPKA-vDycPEw8nDzcPJg9aDyUPfQ8kD6AP
Iw-CDxIlMSEPBZcV8Q0gD0YPHwYPHg_FDx0PpQ8cD8QPGw-iDxoPAA8aTCWROw8YD1kPFw92FQqz
FQ_uDxQPyw8TD_ZjD-A7HQ8RDzgPEA9TDw8Pbg8OCQ8ND6MPDA_9DwsP1w8KD-EPCQ8LDwkPJQ8I
Dz4PBw9YDwYPcQ8FD4oPBA_kDwMPvQ8CD9YAD_8PAA9gD4EiD-8POwUPVFwmEfy-GxOgXQ_A0w-4
D_wP9w_uEfESIA-2DzoP9Q9UD-QPbg-zD4gP8g_jD-EPvQ-wD9gP7w-0gQdR7g8qD_2YARBihgPz
FOoPmw-pD7gP6A-VD_cP8w-mDxAP5g8vD_UPTQ-kD2wP4w_LVA-xBsoP4A-rD98PCw-fDy0P3g9O
D90PcGwp8RrbD7YP2h-ZD-0P2A8hD9gPRg-XD2wP1g_SD9UPuA-UD98P0w8HD9MPLz8lEdE9DPME
qw-PD9UPzgAMDywPzQ9ZD8wPhkoP0eIPyQ8RD8kPQQ-ID3LUCmDGD9UPxQ9CGfM5Ow-ED3APww_l
D8IP2g-BDxEPwQ9ID8APgQ_-D7oPvg-0D70PLg_9D2oPvA_mD7sP4w_6DyIPug9hD7kPoA_4D_EP
tw8jD7cGQQ-wHu4PtA8zD7QPeg_zD8EPsg8KD7IPUw_xD54PsA-pD68PNQ_vD4MPrg-RD60PIRwl
8yQPrA-DD6sPFg_rD2oPqg_-D6kPFQ_pD2wPqA-ED6cPHQ_nAw_mD9MPpQ8wD6UPjg_kD_09D-EF
rw_iDxEPogoPoQ-aD6APQA_gD6gNCfM8nw96D54P5Q_dD1IPnQ_-D5wPLg_cD54Pmw8QD5sPgg_a
D-YPmQ9sD5kP4g_YD1oPmA-TD5cPTg_XD8oPlg9HD5YPxQ_VD0UPlQ-HNg-xAs0Pkw9TD5MP2Q_S
D2EPkg-rfwYAMRnxCpEfkA8fD5APsA_PD0IPjw-VD44Pag_ODwCSD-EQjQ8xD40PzA_MD2gPjA8G
D4wPpQ_LD0UPiw-nD4oPi3YYUYoP1gkNLg-xMNMPiAQCDy0CD90Phw_OD4cPQQ_HD-UPhg_rD4YP
Yg_GDxsPhg-VD4UPkQ_FD04PhQ8ND4UMD4QPkA_ED1QPhEMd8w7gD4MPqA_DD3IPgw8_D4MPCw_D
D9oPgg_qD4IPfFse8FYlD4IP-A_BD9QPgQ_uD4EPig_BD2cPgQ9FD4EPJg_BDwgPgQ-rD4AP0Q_A
D7cPgA_gD4APig_AD3YPgA9jD4APUg_AD0IPgA81D4APKA_ADx4PgA8VD4APDg_ADwgPgA8ED4AA
AQIAAIEHcQQBDwcBDwsYBvAjFgEPHAEPJAEPLAEPNQEPPwEPSgEPVQEPYgELAQ0BD40BD50BD64B
D78BD9IBD_UBD-pKF-McgQ8lD4EPPA_BD1MPgQ9sD4EPhQ_BD6APgQ_7D4EP1w_BD-QPgQ8RD4IP
MHQeAI0n8RaRD4IPsw_CD9YPgg-5D4IPHg_DD0MPgw9pD4MPkA_DD7gPgw-hIQHxEoQPNQ_ED2AP
hA_MD4QPuQ_ED_cPhA8WD4UPRQ_FCgcPpl0q8BsLD4YPPg_GDggPqAgP3ggPFQ_HD00PhwcFD74F
D-gFDzMCCwIPrAIP6QJCD-EjZgkPpgkP5gkPKA_KD2oPig_tD4oP8Q_KDzUPiw96D4sPwA_LDwcP
jA9PD4wPmA_MD_FTERGNSSYRwd8LAOEV8R2OD6kPjg-3D44PRw_PD5cPjw-oD48POQ_QD4wPkA-f
D5APMw_RAgYP3QYPM9Ye8wCSD_IPkg86D5MPlA_TD_6IHvECpA_UDwAPlQ9cD5UPug_VDxguCfEG
lg-XD5YPNw_XD5gPlw-6D5cPXQ_YrCzxIiQPmQIDD_4DD1QPmg_6D5oPIg_bD4oPmw-yD5sPXA_c
D8YPnA8xD50PnA_dDwgPngp7CPMNUA_fD78Pnw8uD6AEDA8PD6EBAA-yAA9lD6IP2E8PscAPow81
D6QPqw_kLCvwBpgPpQ8QD6YCDQ8BD6cPeg_nD-QPp0wMMeoPqCga8CziD6kPXw_qD90Pqg9bD6sP
2Q_rD1gPrA-YD6wPWQ_tD9kPrQ9bD64P3Q_uD18Prw-jD68PZg_wD_oPsJ8i8wj0D7EPeg_yDwAP
swUODw8PtA_WD7QPH1EP8SIxD7YPuw_2D0UPtw-QD7cPXA_4D_cPuA90D7kPAA_6D44Pug8cD7sP
qg_7DzgPvA-HqgvzR70P5w_9D3gPvg8ID78Pmg_-DywPwA__D8APUQ-BD_QPwQ93D8IPCw-DD58P
ww80D8QPyQ-ED18PxQ-1D8UPiw-GDyIPxw_5D8cPUA-ID_gPyAEPyQ8ZXA-xVksPyw-lD8sPfw-M
DxkPzQ_0D80PTw-OD_sPzg_GD88PIg-QD78P0A9cD9EP_Q-RD5YP0g80D9MP0g-TD3AP1A8OD9UP
rQ-VD0wP1g-sD9YPiw-XDysP2A-MD9gPbA-ZDw0P2g_urAzxFtsP8Q-bD5IP3A80D90P1g-dD3kP
3g8cD98Pvw-fD2IP4A8FD_FmD-BoTA-iD-AP4g_UD_MPOQ-kD90P5A_CD_UPJw-mD8wP5g9xD_cP
Fw-oD7wP6A9iD_kPCA-qD64P6g9UD_sP_g-rAA-sD0cP7Q-uD_0PlQ-uDzwP7w-jD_8Pig-wDzEP
8Q-ZD-EBD-IPKA-zD88P8w93D-QPHw-1D8cjKpH2DxcP9w_-D-cpHBMPbg-wSV8P_g8ID-sPsA-7
D1gP-A8BD-0PqQ-9D1IP-g-6D-4Pow--D0sPAA-0DwAPnA8BD0QPAg-tDwIPlQ8DDz4PBA-mDwQP
jg8FDzcPBg-fDwYFDwcPLw8ID9fdKvMhDwkPJw8KD88PCg93DwsPHw8MD8YPDA9uDw0PFQ8OD70P
Dg9kDw8PCw8QD7IPEA9ZeA8xpw8SORnxCvQPEw_aDxQPQA8VD_YPFQ_MDxYPMg8XD9fSG3EYDyIP
GQ-HzBzxDBoPEQ8bD7UPGw9aDxwP-g8cD6IPHQ9GDx4P6YwYwR8PMA8gD9MPIAoPITkAAHcH8QJc
DyMP-g8jD58PJA9BDyUP4swF8QImDyMPJw-DDycPYw8oDwMPKYEP8QRCDyoP4A8qD38PKw8dDywP
uw8sJxrxMfYPLQ_TDy4PMA8vD8wPLw9pDzAPBA8xDAgPOw8yD9YPMg9wDzMPCg80D6QPNA89DzUP
1g81Cw82DwcPNw_fHzc8CvMbOA9kDzkP_w85Bg86DyYPOw_8DzsPUA88D_UPPA95Dz0PDA8_D58P
Pg8yhw-xRFYPQA-oD0APeQ9BDwkPQgMHDykPQw_4D0MPRw9ED9UPRA9jD0UP8A9FD30PRg8JD0cP
lQ9HDyEPSA_rD0gPNg9JD8AfSQ9KD9IPSg9bD0sP4g9LHR7xevEPTA93D00P-Q9ND4IPTg8HD08P
iw9PDw8PUA_SD1APFQ9RD5cPUQ8YD1IDCQ8aD1MDBA8ZD1QPlw9UDxYPVQ_TD1UPEA9WD4wPVg8I
D1cPhA9XD-4PVw94D1gP8g9YD2oPWQ-jD1kfWg-RD1oPSA9bD70PWw8zD1wPpw9cDxsPXQ_OD10P
AQ9e3ytR5A9eD1XsA7FfDzUPYA_jD2APEe0NAFkr8QZhD1gPYg-DD2IPLg9jD5gPYw8CD2SSD-Ew
0w9kDzoPZQACDwcPZg9sD2YP0Q9mDzUPZw_YD2cP_w9nD10PaA__D2gPHg9pD34PaQ-dD2kPOw9q
Aw0P9g0JWxRxaw8ID2wPYpIc8AFsDxQPbQ9sD20Pww9tDxkvNiPzDW4PFwsPawsPvQsPDw9wD2AP
cA_wD3APAA9xD06RD-EY6g9xDzYPcg_CD3IPzQ9yDxcPcw9gD3MPqQ9zD-APcw83D3QPfQ90LxSw
BwoPSwoPjgoP0QrhIaEEDg_SDg-RDg8QjwHzKHcPig93D8YPdw8BD3gPOw94D3QPeA_tD3gP5A94
DxsPeQ9RD3kFAQ_7AQ-vAQ8iD3oPVA96D4WZD-NB5Q96DxMPew9BD3sPbg97D5oPew-GD3sP8A97
DxoPfA9DD3wNDA_SDA_4DA-dDA8CD30PJg99D0kPfQ9rD30PjA99D6wPfQ-MD30P6g99Dwh9HvEW
QQ9_D10Pfg93D34PkA9_D6kPfg-BD34P2A9_D_4Pfg8DD38PGDADc38PPg9-D1CpD-MqcQ9-D4AP
fw_OD38PnA9-D6gPfw_0D38Pvw9-D8kPfw-SD38P2w9-D_IPfw-pD38P7g9-D-MPfw-3rQ9X-Q9-
D-4EABP7HADT8A9-D_gPfw-dD38P0fkPU7MPfw_ibAATeIAAkUcPfw8sD38PDzQA8QR_D88Pfg_s
D34PiA9_D2EPfg859R-hfg-iD30PtA99D4QPfQTwNpDqDA_yDAEMDz7CGOMPww97D4IPew9AD3sP
-FIf8wxuD3oPJA96D9kBD4wBDz0BD_wPeAMGD0UGD_5UEfAMPQ93D_EOD4QODyUOD8QKD2IKD-0P
dA_XD3QPKUHzAsYPcw9bD3MP7g9yD4APcg8PuQ-xPioPcQ_0D3APPQ9wD8ULD0oLD84Pbg9RD24P
0g9tD1EPbQ-OD2wPSg9sD8QPaw89D2sPtA0PKg0Png9pDxAPaQ_BD2gP8A9nD14PZw-KDANxZg_e
Ag8GArAP8QrRD2MPNA9jD5UPYg-2D2EPVQ9hD7IPYA8OvS7yA18PwQ9eDxkPXgsPXQ-ED1wPGK8P
8QS7D1oPCg9aH1kPpQ9YD-EPVw878gOwVg-MD1UPEg9VD1epD-EUBA-eCQ8fCQ9fD1EPng9QD9wP
Tw8YD08PVA9OD44PTQ-HD0xhBjE2D0vDAAB8J5HUD0gPBg9IDzg7M-IMRg_XD0UPxg9ED-MPQw8f
D0MPSg9CD3QPQQ_enw-xFQ-tDz4PFA8_DzkPPQ9eDzwPgg87D6UPOg-HDzkP6A84DwgPOFMPAGcf
8QxkDzUPgQ80D50PMw_5DzIP0w8xD_0PMA8HDzC_HlA3Dy4PTjcMcywPew8rD5CcD-EduA8oD8wP
Jw-eDyYP8Q8lDwIPJQ8THyQPIw80DyIPQw8hCQ8gD2EPHwsPHgy2G-MYHA_WDxsPow8aD68PGQ_6
DxgPxg8XD9APFg-bDxUP5Q8UD_8PEw-5kA-xIQsPEQ8UDxAPHA8PDyUPDg8tDw0PNQ8MDzwPCw9E
DwoPSw8JBA8ID1oPBw9hDwYPaOseEA5NG4ACD4MPAQ_KDxUaMf8Pl4gms-0PpQ-8D6sP_w_yhw-x
BsAP_A-HD-cPzw-2D9YP9Q-eD-QP5a8X8CXyD-UP8Q-_D-APBg-wDw8P7w8YD_4PIQ-tDysP7A81
D_sPPw-qD0kP6Q9UD_gPXw-nD2sPsSOz5Q_DD_QPkA-jD52AD-EyuQ-gD8cP3w-WD94P5Q-dD-UP
3A8GD9wPFw-bDygP2g87D9kPTQ-YD2EP1w90D9YPiQ-VD54P1A_0D9MPyg-SD_GGCfMI0A8SD9AP
Kw-PD0UPzg9fD80Pew-MD5d8D-EC0g-JD-APyA8PD8gPMA-HD1EzAwBhDvAvxA_5D8MP3Q-CDwMP
wg8pD8EPUA-AAQ_-D6IPvg-MD70P9w_8DyMPvA9QD7sPfg_6D64PuQ-eD7gPDw_4D0EBGgJzD-AK
3w_0DxYPtA9OD7MPhg_yD8EPsQ-8D7APONo48i_vD7UPrg-1D60PNg_tAQ_sD7wPqw8BD6sPRw_q
D48PqQ-YD6gPIg_oD20Ppw_6D6YPCA_mD1cPpQ_oD6QP_moP8CMfog-4AA9QAA_pD6APAw_gD18P
nw_8D54PGw_eD3sPnQ-cD5wPPw_cD6QPmw8KD5sPcnQv4QMPRQMPsQ_YDx8PmA_O6AHzAJYPcQ_W
D_QPlQ9aD5UP0V0P8SbDD5MPPw_TD7wPkg87D5IPvA_RDz4PkQ-CD5APSA_QD88Pjw9YD48P4g_O
D24Pjg-8D40PjK4h8xSND7APjA9ED4wP2w_LD3MPiw8ND4sPqA_KD0UPig-lD4kPhcot8SHMD4gP
cg_IDxoPiA-EBQsFDxwFD8sPhgwHDy8HD_MPhQMID1EIDwsID8cvhA9DD4T-KPMHxw_DD4wPgwQG
DxsGD_YPgg_yD4IPgEUP0yIPgg-1D4EPyw_BD6LJHRFXqAPwDYEPEg_BD-MPgA-WD4APug_AAA0P
iQ0Pcw0PXw1aI6E9DQ8vDQ8jDQ8Yxi3hCQ0PBA0PAQ0CDQINDwINANAHDQ8KDQ8PDQ8UDQ8ZZi2x
DycNDzANDzkND0JDAFBYDQ9kDco4EX95LfECnA0PrA0PvQ0Pzg0P4Q0P9A3DD-MXHA_BDzIPgQ9I
D4EPXw_BDgkPjwkPqAkPwgkP3QkP_AkPFQ_CDzIzD-AEbg_CD40Pgg_uD4IPzg_CD-APgiUV8QI2
Bg9aBg9_Bg_kBg-KBg-xBmUQ8ARBD4QPag_ED5QPhA_-D4QP6w_EYj3xAUQID3IID6AID88ID-8I
DzAaJhGUMibQ_gcPLwUPZAUPmgUP0HEL8wCID0APiA94D4gPsg_ID_ypLfEKYw_JD58PiQ-cD4kP
Gg_KD1kPig_YD4oP2LEa8DSLD1oPiw_cD4sP3w_LDyMPjA9nD4wPrA_MD-IPjA84D40Pfw_ND8cP
jQ8PD44PWQ_OD6MPjg-tD44POA_PD4QPjw-Rwi3xGg_QD2wPkA_7D5APCg_RD1oPkQ_rD5EP-A_R
D04PkgAKD-QKD0gPkw_dJyECQg-xAp8PlA-2D5QPTg_VD6cPlQ8A9TwRllEO8y4QD5cPaw_XD8gP
lw8lD5gGAQ-hAQ9AAw_gAw8AD5oPYQ_aD8IPmg8kD5sFCw-qCw9OD5wPsw_cDxgPnQ9_1i1RSw_e
D7JSA-MOnwYMD_0MD1cPoA-BD6APLAABAA8ED6IPcQ_iD95HD-Mcug_jDykPpAMEDwkPpQ96D6UP
6w_lD10Ppg-PD6YPQg_nD7YPpw8qD6gPnuAt8QKJD6kP-w_pD3UPqg-tD6oPZLosMasPVQwy8QKs
D0gPrQ-CD60PPQ_uD7gPrust8xywD68PLQ_wD6oPsA8oD7EPpg_xDyQPsg_jD7IPIw_zD6MPsw8j
D7QEAg8mUQ9RKg_2D62nJZG3Ag0POA_4D7yrBBG58Q7TTQ_6D9MPug9ZD7sP4fct8QzwD7wPeA_9
DwEPvg_KD74PFA_-D54Pvw8oD8CJPdM_D8EPyQ-BD1UPwg-h-y0w_w-DxgOBDxYPxQQODzJtMwD5
KhHHzgXTbw-IDwAPyQ_QD8kPIVYP0UMPyw-VD8sPZw-MD-qPE-EMzQ8gD84Psw-OD0YPzw-aD88P
bw-QDwMP0QEJDC4RwlgV8QbTD_4P0w_ED9QPGw-VD7EP1Q9ID9YwBtJ3D9cPDw-YD6cP2A8-Fi7x
Cw9wD9oPCQ-bD6IP2w87D9wP1Q-cD24P3Q8Iuh7zAN4PPQ-fD9gP3w9yD_APDVwP8QpED_IP3w-i
D3sP4w8XD_QPsw-kD08P5Q-siyEg5g9FPPFLwg-nD18P6A-8D_gDD_kPNw-qD9QP6g9yD_sPEA-s
D60P7A9MD_0P6g-tD4gP7g8mD_8OCA9jD-APAg-xAAcPQA-yD98P8g9_D-MPHQ-0D7wP9A9bD-UP
_g-1ChXxAjkP9w-ZD-cPeA-4DxgP_Q0KFCzxFPcP_g_WD-sPNg-8D9YP-A91D-0PFQ-_D7UP-g9V
D-8P9Q--VRLxFjQPAQ-UDwEPdA8CDxQPAw_zDwMPUw8ED-MPBA_TDwUPMg8GD9KMF-APBw8RDwgP
sA8ID1APCQgFD44PCg8uDwsPzQ8LD2wPezHxAA0Pqg8ND0kPDg-nDw4PhlkIcxAPww8QD2JnD-EG
ng8SDzwPEw-aDxMPeA8UDxYPFQ_z5A3zAhYP7g8WD4sPFw8oDxgOCw9iUy7zHpsPGg83DxsP0w8b
D28PHA8LDx0Ppg8dD0EPHg-dDx4PeA8fDxIPIA_tDyAPR1su8AZ8DyIPFg8jD68PIw9IDyQP4g8k
D3s_CcEPJg_sDyYPRA8nD9xdKDMoDwtuD9A5DyoP0A8qD2cPKw-9zCLxCQ8sDygPLQ__Dy0PUw8u
D_gPLg98Dy8PEccWAmwuEcxYGvE0MgcGD4QPMw8WDzQPqA80DzkPNQ-KDzUPWw82D_wPNg98DzcP
DA84D5sPOA8rDzkPuQ85D0gPOg-WDzoPZA87BwwPfnUJMT0Pl98ocz4Prg8_Dzp4D-MeTw9AD9kP
QA9iD0EP6w9BD3QPQg-9D0IPhQ9DDwwPRA_TD0QPGg9FD6APRQ8mhS5xMQ9HD7UPR2gAkb0PSA9A
D0kPwyEf8wJKD8gPSg9JD0sPyh9LD0wPy4wuEckaKvEATg-GD04PRA9PD8EPTw8_WirwB1APNg9R
D7EPUQ8sD1IPpg9SDyAPUwNBCvABVA_KD1QPAg9VD3kPVQ-wD6A98whWD9wPVg9RD1cPxg9XDzoP
WA_tD1gPIJousQQPWg92D1oP5w9a5SoRxiQB8whcD6QPXA8SD10PgA9dD_wPXQ9ZD14PxKQuUZoP
Xw8EvD3xAmAP1g9gDz4PYQ_mD2EPDQ9iexxx2Q9iDz8PY1xCEweOD-ESzQ9kDzAPZQ_RD2UP8g9l
D1IPZg_yD2YPEQ9nD3APZw-N5gFyaA_HD2gP47cusQMED-MED0wPag_ljDvwD2oPVA9rD6sPaw8B
D2wPVw9sD6sPbA8AD20CAQ_mAcEs8xZJD24Pmg9uD_oPbg86D28PiA9vD9YPbw8kL3APvA9wDwgP
cQ9SmA8AZBPzGi4Pcg92D3IPvQ9yDwQPcw9JD3MPjw9zD9MPcw8XD3QPWg90D5wPdA-dxy7yH14P
dQ_eD3UP3A91DxoPdg9YD3YPlA92D9APdg8LD3cPRQ93D38Pdw_4D3cP8A-PLvALXg94D5QPeA-J
D3gP-g94Bg95D2UPeQ_XD3kPPcMKCQ8pD3oPWQ96D4epD-AK4g96Dw4Pew86D3sPZQ97D48Pew_4
D3sP4ZE_s3wPMA98D1YvfA_g2i7zFOgPfA8KD30PLA99D00PfQEAD40AD6sAD8kAD_cADwMPfg8f
zw5xVA9_AQ0PhUgf8w20DQ-KDQ-gDQ-1DQUPfw8cD38PLg9-D0APfw9RIg-wDXAPfw0ID4wIAwgP
pQgPsQgPuwgPxQgPzggP1gitF-EL5QgP6wgP8AgP9AgP_AgP_wgP-QgP-ggOCA4NAPEe9QgP7ggP
5AgP2AgPyggPuQgPpggPkQgPeggPYQgPRQgPJwgPBwgP5Q0PwA0D7jYRRb4J8QHoAA_2AA_CAA9M
AA8UAA-ZrTXxCnwPXQ98DxwPfA-ZD3sPkw97D0sPew8CD3txD-ELaA96DxcPeg-FCQ9wCQ8aCQ-B
D3gPZg94BQuGORFJqAwRdm0Z8RAYD3YPrw91D0MPdQ-WD3QPZg90D-QPcw_AD3MPCw9zDDkTGW8P
8UQgD3EPoA9wDx4PcA_aD28PFQ9vD40Pbg8ED24LAQ-rD2wPWw9sD8oPaw83D2sPog9qDwsPag9z
BA-YD2gPPA9oD54PZw4PZg9cD2YPuA9lDxMPZWkPccMPYw8YD2NZErG_D2EPDg9hD1wPYJYX8Qf0
D14PPg9eD4YPXQ-MD1wPEA9cAg9b3QvwDNQPWQ8TD1kPTw9YD4oPVw-ED1YP-A9VBgcPZ2IP80UC
D80PUg4PUQ8tD1EPWw9QD4cPTw_yD04P3A9NDwQPTQ8rD0wPUA9LD3UPSg_XD0kPuQ9ID9kPRwoP
Rg8WD0YPMw9FD08PRAQPQw_CD0IPmg9BD7BZD7HbDz4P7g89DwAPPSwGUSIPOw8xDgWxOQ9MDzgP
WA83D2NBQ1A1D3cPNNI0IYcGqBtxkw8wD5gPLy4c058PLQ_iDywPow8rD6RQDxGk2SSRJw_gDyYP
ng8l0gkAZCvQkg8iD40PIQ_HDyAPgDgQ8RoeD3IPHQ9qDxwPYg8bD1kPGg9PDxkPRQ8YDzsPFw8w
DxYPJQ8VDxoPFDE1AAsF8Br1DxAP6Q8PD9wPDg-ODw0PwQ8MD7MPCw_lDwoPlwUPiQ8ID3oPBw9s
D6gj8AUFD04PBA8-DwMPMA8CDyEPAQ8SDyMKAJQHMf0P5n4tMPsPyEcPgAoPqw-4D5wPQRrxIvYP
gA-1D3IP9A9kD-MPVg-yD0kP8Q88D-APLw-vDyMP7g8XD_0PCw-sD-8P6g-0H_mbNjHnD9XmF7Pl
D8MP5A_6D_MPsjwP8QKjD_APnQ-fD5cP3g_SD90PjbULsNsPhg-aD4MP2Q_BTQMR14EDIdUIaxzx
ANMPgw-SD4YP0Q_KD9APj9gps84Pmw-ND6IPzA_rMA-xF74fyQ-ID9UPxw-iD8YP8A-FD-8PxA8P
D8QPIA-DBg-CD0YPwQ9adkMA0irxDL4Png_9D7cPvA-RD7sP7A_6DwgPug8mD7kPRckCUbcPhw_2
Jw8ATRnxQvMPsw8ZD7MPQg_yD2sPsQ_WD7APwg_vD_8Prg8eD64PTw_tD4EPrA_0D6sP6Q_qDx8P
qg9XD6kPkA_oD8sPpw8ID6cPRg_mD4UPpQ-GD6QFDIkeEZPzCTGhDyTuJHGgD7wPnw8KRDXxCJ4P
qw_dD-8PnA9UD5wPqw_bDwMPmw9eVhuhmQ8YD5kLD5gP2bkH05cPog_WBQMPcg_VD90aD-EAuA_T
DygPkw_bD5IPDw_S_h3xBv0PkA93D5AP8w_PD3EPjw-xD44PcyUc8AKNAA0PBQ0Pjw_MDxsPjA_p
DxlG8wCLD8sPig9fD4oP9Q_JD44PD-AfxA_ID2MPiA8DD4gPpg_HD0sPhw-yD4YPmw_GD0YPhg-z
D4UPow_FD1QPhQ8ID6hK8xSED3YPhA8wD4QP7A_DD6sPgw9sD4MPLg_DD-MPgg_7D4IPhBkPcR4P
gg-uD4FDIPEwlA_BD2sPgQ9ED4EPHw_BD-0PgA-cD4APvg_AD6IPgA_ID4APcQ_AD1sPgA9ID4AP
OA_ADykPgA8dD4APEg_AOjGTBQ_ADwIPgA8BBAASAmIeAKdAcQUBDw0BDxLcPCAdAVkeESvxPFA8
AQ9GAYgn8QBbAQ9mAQ9zIQ0BD5wBD6twFkHLAQ-ddhbxCAEPgQ8VD4EPKQ_BDz0PgQIHBAcBBw_X
4SRByAcP4gA1UxcPgg8zJA8A-DPxFooPgg_pD4IPyA_CD_gPgg8ID4MPKg_DD0wPgw9uD4MPkQ_D
D7V0H7GDD-8Pgw8lD4QPTGA28QCED5wPhA-ED4QP7g_EDxiCCfE2hQ9uD4UPmg_FD8cPhQ-1D4UP
Iw_GD1IPhgcOD7EOD_IODxQPhw9GD4cPeQ_HD6wPhw-gD4cPFQ_ID0sPiAcJD7gJD_8JOg-xN2AP
iQ_ZD4kP0w_JDw4Pig9JD4oOCg-CCg8AD4sPPQ_LD3wPiw_7D4sP_w_LDzwPjAAID78IDwEND0QN
CQ0PzA0PEQ_OD1eVS3GOD_QPjg8rXgjxC48PvA_PDwYPkA9PD5APmg_QD_UPkA8xD5EAEBCxGA_S
D2YPkg_1D5LwCwBQGVOlD5MP9jcPAPZL8QHuD5QPQS_VD_oPlQ8-Aw_VuknRQw_XD5sPlw-zD5cP
TAceMZgP-40h8TKZD7UPmQ8QD5oPbQ_aD8kPmg8nD5sPhQ_bD_MPmw9CD5wPog_cDwIPnQ9iD50P
xA_dDyUPng_HD54P6g_eD04Pn7Ix8w4WD6APew_gD_APoA9GD6EPrQ_hDxQPog97D6IP40YP8T61
D6MPHw_kD4kPpA-zD6QPXg_lD8oPpQ82D6YPow_mDxAPpwAMD_sMD1oPqA-JD6gPOA_pD6gPqQ8Z
D6oKCw-7Cw9tD6sP3w_rD1IPrJQy4DkvrQ8iD64Plw_uDw0P6SJRrw-5D69qGfEA5w_wD18PsQ-X
D7EPUA_y4EvzAkIPsw_8D7MPNg_0D7EPtA8sSA-wGyQPtg_gD7YPHQ_3D5oPtw8YD7gPlQ_4DxQP
uQ_TD7kPEg_6BgUPEQ_7Bj4GEbw8E-EQFA_9AwQPGA__D5sPvg8eD78PoQ_-DyUPwA_oD8APLRYU
8ADBDzYPwg_8D8IPQQ-DD8e6KvMbD8QP1A-ED1sPxQ-iD8UPag-GD-IPxg96D8cPAw-ICAEPFQ-J
D54PyQ8oTA_xPA-LD8cPyw9SD8wCNJFpD80P9A-ND4C6BvEQzw_ZD88PJg-QD7MP0A9BD9EPzg-R
D1wP0g-qD9IPeQE1MdQDB6g7gLUP1Q9FD9YHUh3xCNcP9Q-XD4UP2A8WD9kMCQ84D9oPyQ-aZCcR
7V0Z4NwPEQ-dD6MP3Q82D94Bzxez3w-uD98Pgg-gDxVOD7E8D_IP0A-iD2QP4yY1EY2TS7HlD7YP
5Q9LD_YP4A048R7nDwoP6A_gD_gPNQ-pD8sP6Q9hD_oP9w-qD40P6w8jD_wPuQ-sD08P7Q-mD_2Q
OdETD_8LAA9BD-AP1w-w3SrwCAYP8g_dD-IPNA-zD8sP8w9jD-QP_g-06kRxKQ-2D8EP9os3k-AP
9w_ID-gPH7oeAClLEecUGvEc_w8XD-wPrw-8D0cP-Q-fD-0Pdw-_Dw8P-wwKDz8PAA-XDwAPbw8B
DwcPAqMw8SM3DwMPzw8DD2cPBAoFAw8FDy4PBg-GDwYPXg8HD-YPBw_NDwgPJQ8JBAIPVA8KD_wP
CtwisRoPDA_yDwwPSQ8NdhAgdx8HIZGlDw8PPA8QD9NrGQFbD4EDCA8tDxMPw7cJ0RQABw_FDxUP
Gw8WD7ByCQASF3EXD3EPGA8GVQ-wCxkPMA8aD8UPGg9ZDxsP7g8bD4IPHA8WDx0LmC6RHg-RDx4P
ZQ8f_wDxCosPIA8eDyEPsQ8hD0MPIg-WDyIPaA8jD-rDE-MPJA4PJQ_vDyUPQA8mD9EPJg9iDycP
8g8nD4IPKA8TXg-xHjIPKg-BDyoPUQ8rD98PKw9uDywP-Q8sD4sPLQ8ZDy4Ppg8uDzQPLw-BDy8P
TpA2ETDiSwALN-EEfw8yDwoPMwMJDyEPNA_rDzQPNlpAcTUPSg82D9NCDtE3D_UPNw9uDzgP9g84
gwwA2B7zE40POgcPOw_bDzsPIQ88DAEPLQ89D7IPPQ83Dz4PvA8_D0BlDwAjD1HLD0APTvIC8AFB
D1MPQg-VD0IPVg9DD9cPEknxFkQP2A9ED1gPRQ-YD0UPVw9GD9YPRg9UD0cP0g9HD1APSA-ND0hb
D-EMxg9JD0IPSg__D0oPOQ9LD7QPSw8uD0wPqA9M8j7zIJsPTQcPTg_MD04FD08Pew9PD-IPTw9p
D1AP3w9QD1QPUQ-JD1EPPg9SD7IPUg8mfy7xHgwPVA9-D1QP8Q9UD2IPVQ-TD1UPRA9WD7QPVg8j
D1cPkw9XDwEPWA9vD1gP3WpJEVkWN-JWIw9aD48PWg-6D1oPZA9bD88PWw84D1wPoQ9cDwoPXQ9y
D10P2g9dD0EPXg_oD14PDg9fD3MPXw-YD18PPQ9gD6EPYAUPYQ9nD2EPyQ9hDysPYg_MD2IP7Q9i
D00PYw_tD2MPDA92D-EPyQ9kDyYPZQ_DD2UP3w9lDzsPZgMND-END0sPZw_kuEDxQ2cPVg9oD60P
aAUPaQ9bD2kPsQ9pDwcPag9bD2oPsA9qDwMPaw9XD2sPqQ9rD-sPaw9MD2wPnQ9sD_0PbA89D20P
jA9tD9oPbQ8oD24PdQ9uD8HZIRFv_QCxow9vD_0Pbw83D3BSDjDID3AuUCMPVoUP8RbiD3EPJw9y
D2wPcg_vD3IP8w9yDzUPcw93D3MPuA9zD-kPcw855x7xA3QPtw90D-UPdAkPdQ9vD3UPq3YE8QF1
DyIPdg9cD3YDBg-OBg8H2E1wdw91D3cPq2Ud8yUPdw8WD3gPSg94D34PeA_xD3gP4w94DxUPeQ9G
D3kGCg_mCg-UCg8DD3oPMA96D10Peg_KiA-xGuAPeg8KD3sPNA97D10Pew_FD3sPrA97D9MPew-5
D3sPHw98D0QPfA9oBwgAgTTxE3wP0A98D-EPfAgPfQ8yD30PUQ99D3APfQ_ND30Pqw99D8c7TfMM
fQ-_D30PGQ9_DzIPfg9LD34PZA9_D3sPfg_SQR-xCL4Pfg-TD34P5w9_D-sPfg8ND38PHw9-eQMX
QaMP028Pfw99D38Pig9-D5flHhOt8i7zFsEPfw-KD38P0w9-D9oPfw-hD38P5w9-D_wPfw-xD38P
9Q9-D-g5HwxNHwBNBVP0D38P6y4vAEkfEsBOL0EDBA99-S7zBEIEDyEED-4Pfg-XD34Prg9_D4JE
P8MjD34AD30PuQ99D4DfLzEGD332LgD-L-EAOw98D-MPewwCD1kCDwkCwg8xYA96kA3xAq0KD1AK
D-APeA_ND3gPKA94_iXxAFcPdw-qBgIGDwkGD5UPdbVC8wamD3QPKw90D60Pcw8tD3MPqg9yDyW5
D-EZEw9xD4cPcA-5D28PaA9vD9QPbg8-D24MD20PDQ9tD3APbA-RD2sPMF83M2oP59Mu8wWVD2gP
6Q9nDzsPZw_KDQ-YD2UPI7MP8wWzD2MP_A9iDzoPYgIPYQ_6D2AP9sMucWkPXg_gD10dVJMHD1wP
OA9bD2fALjG-D1jTU8MQD1cPNQ9WD1kPVQK3LvMGuQ9SD9YPUQ-xD1APCg9QDyIPTw84sC7zBV8P
TA9wD0sED0oPjQ9JD5kPSA_kpy7zBrUPRQ_8D0QPwA9DD8QPQg-GD0EPx6cPEcTaF6A9D7wBD7YP
Ow_vejkCmC7zBJIPNw_GDzYKDzUPaw80D1wJD0uQLhAoUhrzAC8PAA8uD_oPLA-UDysPvJwPMYsP
KJ4DEVaMJJElDx8PJA8BDyOALpDFDyAPpg8fD4aTBpEOD0QPHA8iDxt4LuDdDxgPug8XAw8WD3IP
FVkFAHMGgQIID9wPEA_1_EfRDg9oDw0PQA8MDxkPC2YuUMkPCA_h-yKgBg9QDwUPKAUP-1wu8AMP
AQ_tDwAPhQ--D1wP-gkP-Q9cShPizh7RkQ-4D2kP9w9BD-YPGcAeQvMPyg9NLvMFfA-wD1YADy8P
7g8KD_0P5A-rD8BFLnF3D_gPVA-nmEQRDhcYM_MPy4EPUIoP4A9rjFPQD94PLg-dDxEP3A-1DzUu
8wa_D9gPpA-XD4sP1g9zD9UPWw-UD0QtLvIGGg-RDwcP0A-0D84P4g-ND9IPzA-Cew8RDG4LkMgP
jw-HD4YPxgcDEwYdLvIGaw-CD2cPwQ9lD8APZA_-D2UPvg0PFC7zBm4Puw91D7oPfA_5D4UPuA_Q
D7cPnHMPsbkPtA-JD7MP3A_yij4QBdUMEbAELvIFUA_uD2wPrQ_LD6wPqg_rD8wPqgD7LcEBD6gP
ZQwPjw_mD7zaGlGkDxsPpGkP8waCD6IPuA_hD-APoA8qD6APZw_fD6XrLREo6QUAWhsA9jlymg9G
D5oPk_Mt8wMJCw_HD5cP3QMPNAMPjg_VD_tgD1GqD5MPDUgT8Q2SD9oPkQ9ED5EPsA_QDx8fkA_P
DwMPjwoPjg-xAlQzjQ-pxi1R6g_LD25lWbOKD34Pig8JD4oPl1gPcbsPiA9QD4hYOxGDEhIAxFkC
vS3zBAcPhg_uD4UPWA_FBQIPsw_ED2W0LfME0A_DD4kPgw9FD4MFBA-FD4IPiUwPERlpKQIePFCE
D4EPWDc3A6It8wbkD4APwg_AD6MPgA_HD4APbQ_AD1eaLdIxD4APIg_ADxYPgA8NLA8NRA8TAxgA
kwkPgA8MD4APEMYt8Q4aD4APIQ_ADycPgA8vD4APNw_ADz8PgA9JD4APU2QX8RyAD2gPgA90D4AP
gQ_AD44PgA_cD4APqg_AD7kPgA-JD4AP2Q_AD_oPgA-8Fi4zgQ8hGR8Aix7zFl0PgQ9yD4EPiA_B
D58PgQ_2D4EPzg_BD_cPgQ8AD4IPGg_CDzRyD9FrD4IPiA_CD6UPgg-C6wtQgg--D4K2Q-EIPwQP
YAQPgQQPowQPxQQP6QQPDQ_EDzHPI-AAhA98D4QPog_ED8kPhA-xZwHxEQIPQgIPawIPlQIPwAIP
6wIPFw_GD0MPhg9wD4YPng_GLjGR_w_GDysPhw9b4j4Ak0-RhwAHDyEPiA9VL4gPvf8xEYhvD-EV
XQ_JD5QPiQ-LD4kPAw_KAQgPdQgPrggP6QgPIw_LD18Piw_bfSsRiwUqUVIPjA_RMT-wF4wPDw_N
D08PjQ_QD40P0Q_NDxMPjg9VD44LBg-cBg8gD48PZA_PnCHxBQANDzYPkA98D5APxA_QDwwPkQ9U
LVsgkQ9-WfMKMQ_SD3wPkg-HD5IPEw_TD2APkw_tD5MP_nsP8CCXD5QP5g_UDzUPlQ_GD5UP1g_V
DygDCgMPzAMPHg_XD3IPlw-GD5cPGgsPbwsPxCsM8QiZD3EPmQ-ID5kPHw_aD3cPmg-QD5oPKTQx
8QSbD9wPmw83D5wPkg_cD_4PnA9KlkBxnQ8DD54PYbUd8RueDx0Pnw98D58P2w_fDzsPoA_cD6AP
-Q_gD14PoQ-AD6EPIg_iAg4P6A6AD-E6sA_jDxUPpA96D6QP3w_kD0UPpQ_sD6UPEw_mD3oPpg-i
D6YPSg_nD7MPpw8cD6gPhg_oD-APqA9aD6kPxQ_pDzAPqg_cD6oPCGAJ8SirD_IPqw9QD6wPvQ_s
DywPrQ_aD60PCg_uCgwP6QwPWQ_vD8oPrw87D7APrQ_wDx8PsQ_RD7EFY1fzCLIP6w_yD14Psw-T
D7MPRw_0D7wPtA8yjg8RHoBQ8QO2DwsPtwQJD-oJD3IPuA-rD7gwNvES3A_5D1YPug-QD7oPSg_7
D8QPuw8-D7wPug_8DzYPvQ_xPzNxvg_qD74PJ0c_8QS-DyEPwA_fD8APHQ-BD5wPwQ8aGFLxIsIP
GQ-DCwcPGA-ED5kPxA8ZD8UPmg-FDxsPxg_dD8YPHg-HD6APxw8jD8gPpQ-IDyh2QgAjQwKZD-EI
Ng-LD7oPyw8-D8wHAQ9IL80PUw-OD9mTJLDPD_UPzw9rD9AP8jpAsdEPAA-SD4cP0g8P_zKx0w8f
D9QPpw-UDzBgNPEc1Q9BD9YPyg-WD1QP1w-dD9cPZw-YD-EP2A97D9kPBQ-aD5AP2g8aD9sPpWsN
ALlS8w7cD0cP3Q-TD90PXg-eD_oP3g93D98PAw-gDQgPHKAP8Qo1D_IPwg-iD1AP4w-dD_MPag-k
D-gP5A_GXibxEuYOBg8wD_cPvg-nD0wP6A-bD_gPag-pD-gP6Q_HD_oPFuYg8QDrDzQP7A-ED_wP
Uw-tD_I0VLHuDwEP7w_RD_8PIWgGcfAPQQ-xD9HUVlHyD-EP8pAjoBIP9A4ADzIP9QejHhH2QlTw
DXQP9w8FD-gPlg-4DyYP_QkCD0gP_g-ZD-oPai8qE-EI-A8cD-0PrQ-9Dz4P-g-PD-4PYA--D-GF
BPAOAA8TDwEPpA8BDzUPAg-GDwIPVw8DD_cPAw94BQ-VPfECmg8FDysPBg_8DwYPTA8HD92xSjAI
D-47UfANCQ8fDwoPsA8KD0APCw-RDwsPYQ8MD-EPDA_BD44T8ggOD6EPDg8xDw8PwQ8PD1EPEA-h
DxAPcK4P8A0NDA8fDxMPrg8TDz0PFAEED1sPFQ-qDxUKDxYPtBTxDJYPFw8kDxgPsw8YD0EPGQ-P
DxkPXQ8aD_sPGn8r8QIGDxwPkw8cDyAPHQ_tDx0POl4CYB4PVA8fCI4fICAClB6xIQ8QDyIPnA8i
DyfxIQBcHvMUJA-JDyQPUw8lD94PJQ9oDyYP8w8mD3wPJw8GDygPkA8oDxm0D-AkKw8qD7QPKg89
DysPxQ8rD00PLA-VDywPXQ8tD_QPLQ9rDy4P8g8uCg8vD-8PLw_GDzAP5UcA2gTxAhcPMg_cDzIP
IQ8zD6YPMw8qkCKxNA8zDzUPtg81DzpbA-EINg9ADzcPwg83D0UPOA-HDzgPSA85D8o2D-EAOgEO
D00POw-NDzsPTQ88WUbzAkwPPQ-LDz0PSg8_D8gPPg9Hvg_xQg9AD78PQA88D0GuIhE1QlVxQg8s
D0MPp7IQMUQPneVIYEUPkQ9FD4YacYMPRg-8D0YjTFHtD0cPZLBA8RhID1MPSQ-JD0kPQA9KD7UP
Sg8rD0sPoA9LDxUPTA_JD0wP-Q9MD3EIOLFND1cPTg-JD04PO3cYkE8PHg9QDQAP--gR8wBRD98P
UQ9OD1IPvQ9SDyvFD-EJBw9UD3QPVA-hD1QPTQ9VD7kPVQ8kD1YNXyWRZA9XD84PVw83hDrxNVgP
CA9ZD3APWQ-YD1kPPw9aD6UPWg8LD1sPcQ9bD9YPWw87D1wPnw9cDwMPXQ9mD10PyQ9dDysPXg_N
D14P7w9eAA9fsRQRECku0WAPzw9gDy4PYQ_MD2ExE-IHRg9iD6MPYg--D2IPWw9jD7YPYw8QD8oP
8QDED2QPHQ9lD3YPZQ-OD2UCX-EEfQ9mD9MPZg8pD2cPfw9nD9QPZxZZAJQOEdAPEvAHaQ91D2kP
xw9pDxgPag9pD2oPuQ9qD9wu0VgPaw_nD2sP9Q9rD0O8JfM0bA-cD2wPKA9tD3QPbQ_-D20PCQ9u
D1MPbg_cD24P5Q9uDy0Pbw90D28Puw9vDwIPcA9ID3APjQ9wD9IPcA8WD3EPWdYP8W7fD3EPIQ9y
D2IPcg_jD3IP4w9yDyMPcw9iD3MPoA9zD94Pcw8bD3QPWA90D5QPdA-QD3QPCw91D0UPdQ9-D3UP
uA91D-EPdQ8pD3YPYA92D5cPdg-ND3YPAw93DzgPdw9sD3cPoA93D9MPdw8GD3gPOA94D2kPeA_a
D3gPy0tc8QF4DykKD1gKD4UKD7MKD98K6kGTNw96D2EPeg_M4Q-xJN4Peg8GD3sPLg97D1UPew98
D3sPoQ97D8cPew-rD3sPDw98DzIPfA9VD3wPdw98D5kPfJQL8Q7aD3wP_g98DxkPfQ83D30PVQ99
D3IPfQ_OD30PqukOg30IAw-6Aw8TwT6TRA9_D1sPfg9yYC7Tng9_D7MPfg-HD34P2ygv8QoAD38M
CQ8jCQ8zCQ9DCQ9SCQ9hCQ9vCQ98103xB5QJD6AJD6oJD7QJD74JD8cJD88JD9Z0KPAL4wkP6QkP
7gkP8gkP9gkCCQ-7CQ-9CQ-_CQUIABECGAAR5yJOgMcJD7MJD5spWgARPygfAMEk0MYPfg_XD34P
ZQ9_DzDuTlADD7wjDj1L8wZ8D6wPfA9hD3wMBA_-D3sPag97DxFzH8FXD3oP9QoPkAoPJwpvJpFO
D3gP3A93D2f7IHF2D3UPdg-3iBHxAHUP8w90D2wPdA-iD3MPVZtjM3IPM6wP8zYFD3EPaQ9wD8sP
bw8qD28Phg9uD98PbQ81D20PiQ9sD9oPaw8oD2sPcw9qD7sPaQ8BD2kPRA9oD4UPZw-CD2YP-Q9l
DzamD3CfD2MP0A9iHRNRKg9hD1NXEPEQXw_eD14PwA9dD98PXA-9D1sPFw9bDzAPWg9GD1kPWgkD
EFeAVlOHD1UPkp4PEaJYIzBRD6hADVFPD6cPTrYrsZ0PTA_VD0sPjA9KvQvzDnMPSA9jD0cPUg9G
Dz8PRQ8qD0QPFA9DD-wPQQ-ilg-wAKkPPg_KDz0Pag88D0gPO5wV8Q7-DzgP2Q83D7EPNg_IDzUP
XQ80DzEPMw8EDzIP1cwk8wAvD3QPLg9CDy0PDg8sD9qSD-EMbg8oDzYPJw-9DyUPww8kD4kPIw9N
DyIPEQ8hbwgQlUpXUR0PFw8cp2TwBpUPGQ9TDxgPEQ8XD84PFQ_KDxQPRowPAOI9AFMy8AEPDzIP
Dg-rDwwPpQ8LD14PF0UxCQ-QSipwBg9BDwUCD24sEQJ3AWEhDwAP2QUtHRFJIDbwBfsPuQIPcg-4
DyoP9w-jD-UPnA-0KU3xGA8P8g-KD-APhA-vDz8P7g-6D_wPtg-rD3MP6g8vD_kP7Q-nD6sP5otS
UykP5A-qfA9BbAgPL1UnIN0P41ZRew-bD0H_J-EE2Q-RD9cPmg-WD2QP1Q8vD9QP_wIuUdEPmA-Q
il8xOQ-O9SYT3-Ae0YoPyQ9iD8gPOw-HDxZ_GXHED9APww_vAC3xCMEPcw-AD1cPvw88D74PJA_9
Dw0PvA-4AF2zuQ-TD7gPww_3D7VwD-Eanw_0D5cPsw_RD7IPjQ_xD4sPsA_KD68PjA_uD5APrQ_W
D6wPnw_rD6nqVwBGC-MEqA-WD6cP6Q_mD-8PpQ8WD6UPMWwPsWwPog_OD6EPsQ_gnkfxAgAPnw8s
D54PWQ_dD4oPnA_8DzoRmuJFUWQPmQ_iyljzAJcPJA_XD2kPlg_xD5UP-GgPsZkPkw-sD5IPQg_S
u0yR9g_QD1QPkA_13ywAQw4AfBkRV70r8wiMDzkPjA_vD4sPJw_LD6MPig8iD4oPo2EPQLAPiA4O
R7GHD1kPhw-tD4YPhNkREYZ8ZzFcD4WDEYGnD4QPUQ_EBWo_cYMPYg_DDxh9IGGCD5APggD-QVPa
D4EPpIsO-yJCD4EPFg_BD_0PgA-HD4APpQ_AD4YPgA9qD4APUQ_ADzwPgA8qD4APGw_ADw8PgA8H
Tw8EEwUBPRMLKABTEw_ADxghPfEAJA_ADysPgA8yD4AOAQ9Cn1vwBFUBD18BD2oBD3YBBgEPjgEP
mwEAEVC3AQ-GAUZUUeYBD-YB7Q8AhWbTLA_BDz8PgQ9SD4EPZnIuk5APgQ_mD4EPvc89gesPgQ8E
Bg8cui3zD08GD2oGD4UGD6EGD70GD9oGD-cGDxUPgw8zD4MPUiU_sZIPgw_zD4MP1A_DY00AkRDx
EDwPhA9fD4QPgw_ED6gPhA-ND4QP8w_EDxoPhQ9BD4XTBDGQD4XyEVDiD4UPDLITA5hbUY0Phg_5
0gtjhgwPhw9AbkzxA50Phw-MD4cP-A_HDy0LD14LDfJjIfQLTw9wWw_JDQkPxAMGAItXEWViAjOK
D9R3TBFEcEWziw_3D4sP8Q_LDyz7LVOjD4wP339M8RhZD40Plw_ND9UPjQ8UD44PVA_OD5QPjg-U
D44PFQ0PVw0PmQ0P2w3-LQDhQ5GmD5AP6g_QDy8dVAKPTPAOAg_SD0kPkg_QD5IP2A_SDyEPkw9q
D5MPtA_TBQNWD7EDBA-fBA8rD5UPd8Exo5UMD5YPYA_WD66cTPMLTQ_XD50Plw-tD5cPPg_YDQoP
4QoPMw_ZD4ahTFEtD5oPgSEEABlJgZsBBw-WBw8tGyARnKZMUzMPnQ_LFi6RPQ_eD5cPng-xBGMx
nw_mCxwRoMYV8QK6D6APFw_hD3QPoQ-RD6EPL7ADM6IP7d4eEawfQ-IJpA9sD6QPzQ_kDy8PpQ_R
D6UP8w_lD1UPwkxBHA_nAfgmU0kPqA_uKy5TeQ_pD9-HTDGtD6rqUvMPfA_rD_UPqw9ND6wPtg_s
Dx8PrQkAD-MAD14Prg-JMC7zAqAPrw8LD7APeA_wD_UPsA9S1EzzDC0PsgcODwkPsw94D7MP5w_z
D1cPtA-HD7QPN2IP8w4ZD7YPig_2D-sPtg9tD7cP4A_3D1IPuA-FD7gPOONM8wAgD7oEBg8JD7sP
fQ_7D-NALlPeD7wPVOlMwEEPvg_4D74PLw_-CLo7UcAPlw-AQA0Aul_TAQ-CD3oPwg-0Ri4R6Ik5
s8QP3Q-ED1gPxQ-T_UxRyw-GD0ccHwCsFvEEyA_8D8gPOQ-JD7cPyQ80D8oOArVKEa5BWvMEzA_s
D8wPKw-ND6oPzQ8pD84PqQlNkakPzw8pD9APqho0M9EPrGRc8xiuD9IPMA-TDgUPNA-UD7YP1A85
D9UPuw-VDz4P1g-BD9YPRA-XD8gYTVPPD9gPU14u8wJbD9oP4A-aD2UP2w-pD9sPbiBN8wx5D90P
-g-dD4QP3g8KD98NAw8VD_APnA-gDyJ2D-IPLw-iD7YP4g89D_MPxA-jD0sP5A-SD_QPWg-lD_EP
Lk3xAvEP5g95D_cPAQ-oCQwPEQ-pk1wRItlrEeo1TfMMuw-rD0QP7A-ND_wPVg-tAwoPaA-uD-IP
7g97O01xjg-wDxcP8aFc8wIqD-IPtA-yDz4P8w-ID-MPUkVN0WYP9Q-wD-UPeg-2DwSYJgBla3P4
D6MP_A8tJR8RQqQvcfoPVg-7D_HHGzH8D-ZLFJH9DwsP-g_VD-66VbOqD-8PNQ8ACwEPSoUuU18P
Ag-pXU0R-t0kcAQPEw8FD52oF6MPBg4ADzwPBw-GZE1T2w8ID2XQXDF5Dwr6XKKNDwsPFw8MD6EP
bE2gtA8NDz4PDg-ID68ooA8P2w8PD2QPEAq9G-MPEQEPEgkUDxMPmw8TDyQPFA_sDxQPNQ8VD74P
FQ9GdU2RVw8XAwYPZw8YpzYTdpYuQIYPGg_WbPEGlA8bHxwPow8cDyoPHQ_wDx0PNw8evyFRRA8f
Agh-TVPWDyAPXJouUWcPIgoFogwR945JYCQBDyUPhfgf8AUPJg_NDyYPEQ8nD5UPJw8ZDygPnPBw
AowPECUNMmEfKg8rD63yXLMsD7EPLA8yDy0PtJNNUbYPLg837UdzLw84DzAPuKQuU7gPMQ83nE3y
FTYPMw_1HzMPNA4NDzAPNQ_tDzUPKw82D6gPNg8mDzcPog83CKkuAKVNsZMPOQ8PDzoPig864U4A
qU0x_g87ilkR73QqET2VAlFbDz4P1FhsAo8PcTwPQA_0D0A3ThGivhBgQg_QD0IA9jsDuE3RZg9E
D9sPRA9QD0UPxP4PAbkuUwgPRw_Sv01Rdw9ID_mwPVFJD8wPSfcPEa7bTvMASw_OD0sP-g9LD20P
TA-cwi4AnzIxJg9O4zNiAQ9PD24P001ARg9QDh858wRRD4gPUQ-zD1EPXQ9SD8cPUg8wlg8AJhsA
7y3zBtIPVA86D1UPoQ9VDwgPVg9uD1YP1OJN8wKfD1cPBA9YD2gPWA-MD1gPL9IuU-UPWQ9Y6k0x
Gw9baEtR3Q9bDz1habNcD-wPXA9bD10PuvJNANctE9PaLhGMFTKzXw9DD2APng9gD-n6TfMNrQ9h
AA9iD18PYg_3D2IPDw9jD2cPYw__D2MPFKEPAMUZUBUPZQ9qyRlAD2UEL-UrMWYPC2g_cGcPrg9n
D-8RY3NoD6APaA-vml1TjQ9pD9sPThF2X0vwA2oPDw9rD1oPaw_lD2sP8A9rD2BKIoQPF04ASW8S
XqpdMQoLDWs8kW4PwA9uDwUPbxxOcY4Pbw-RD2_nUPMCVw9wD5kPcA-bD3APHA9xD1ygD5HcD3EP
Gw9yD1mxFlByD9UPcv4uUU4Pcw_KSDkQc3wykzovdA_tD3QP5v0uU1YPdQ_NMU7zDvkPdQ8vD3YP
ZA92D5gPdg-MD3YP-w92DzIPdw9k5TxTxw93D-cFLwD8P-EAhg94D7QPeA-iD3gPDw951EDzDmgP
eQ_UD3kPvw95D_kPeQ8TD3oPPA96D2UPeg_Npw-zEtwPeg8DD3sPKQ97D04Pew9zD3sPlw97D7sP
ew-eD3sPAUZNAIwfU2UPfA_G_lwxxA98qGyhAQ99CAcPPAcPWGRNoY8HD6kHD8MHD92cXQDkPVMm
D34PPb0e8wJqD34Pfw9_D5QPfg_oD34PvBw_EeHsMwAacfMEfw8VD38PJg9-DzUPfw9ED38PU48f
8wJuD38Pew9-D4cPfw_SD38Pndg_U7EPfw_7jD4Xy5MfE_CJTgBnHxPv4D5f9g9-D-mXHwAT-a8f
E_-LH5PQD38Pug9-D6CFXgCAALE7D38PEQ9-D_MPfnpz8Qt6D34PQA9_DwIPfg_-Bw95Bw8uBw-g
D3wPjgEzMXwP3XYgM3sPHNYPMUsPerREkWsPeQ-1D3gPe7QwEXcAEfMQ9w92D24Pdg-hD3UMCQ_8
D3QPIw90D4cPcw-oD3IPRM8PMfMPcH5hUZMPbw-dQmAwbg9ofUbwC2wP5A9rDx0Paw9TD2oPhQ9p
D7QPaA-fD2cPwC5TLA9mD07GD1CHD2MPnyx08AEPYQ-FD2AP1A9fD98PXg-npFjxClwP7w9bD_8P
Wg-rD1kP5Q9YD9wPVw-QD1bQNhOvvw9QhA9SD2rtE-EmDA8wD08PDg9OD_oPTA-ED0sPmw9KD3AP
SQ9DD0gPEw9HD_EPRQ_tD0QPdg9DDz4PQg8DD0G3D7GHDz4PRg89DwMPPHN0MXgPOcYFMeUPNlNm
wUsND-wPMg_rDzEPWO1Dsy8Prg8tD1cPLA-_rw-xCUkPKA-sDyYPjg8lDy8PJA-PBQ9uDyEPC-tT
sR4PQw8dD94PGw94t0TQGQ_pBg9ADxYP1w8UC6UP8QAED5cPEA8rDw8Pvw8ND1KIVfIBCg93HwkP
CA_bAA8tDwUPv-o9geIBD3MP-w8EDTxR-A8nD-sfH-EGSw-4D90P9g9wD-UPAw-0D5YP8g8paE3x
FO8PUg-uD_cP7AcP6w8TD_oPqw-oD0MP5w-bD_UJD_QPDw-jkg9RRw-gD_SBZYHdBQ-cD8MP2ulS
EQgqSFHWD1IP1dtNkaEP0g9LD9EP9h5n8BXOD1IPzQ8CD8wPtAIPZw-JDx0PyA-UD8YPjQ-FD0cP
xA8EH8N0WsEPwA9GD78PCw__D9L5DlG7D2YPuo8-IAMPLxkCfw_QgA_0D1kPsw812C8AfUiRrw-X
D64PvQ_t2hoRkBJh8wiqD28PqQ9iD6gPWA_nD1EPpg9ND6UPTHYP8QJSD6IPWg_hD2QPoA9yD58P
gwIM8QCdD64PnA-ID5sP5g_aDwc7DPEFmQ9SD5gHD5cPqw_WD9wPlQ8RD5VtD-EMhQ_TD8QPkg8H
D5IPTQ_RD5cPkA-kD48PNQ_PAi7A4Q_NDz0PjQ_dD4wBUCgRi5EvQ0APig5kD5GiD4gPHw_ID6Ed
WvEQhw_vD4YPPA_GD80PhQ9iD4UP_w_ED5cPhA84D4QP3cd48BaDDzIPgw-jD4IPlw_CDAgPDQgP
zQ_BD5IPgQ9bD4EPKA_BD-kPISrQgA_nD4APhA_AD2UPgJkS8QYNCg8hCg8TCg8JCg8DCg8BCgYK
DwILACAFCmQhwQoKDw4KBAoPFgoPGysAICcKMxiANQoPPQoPRQrBa8FXCg9hCg9sCg93CgiRRICb
Cg_oCg_2Cq5C8R3TCg-iCg-yCg8CD4EPEw_BDyQPgQ82D4EPSQ_BD1wPgQ9vD4EPgw_BD5gPgfwv
U8MPgQ-ZiFtQBwgPHgjUCCBPCCx68QWDCA_dCA_4CA-TCA-vCA8MD4MPKQkY8B2DD2Qvgw_iD4MP
wg_DD_IPgw8DD4QPJA_ED0UPhA9oD4QPig_ED64PhA-RD8hc8QiEDxsPhQ9AD4UPZg_FAwsPswsP
2gsPAn0e8QqGD1QPhgcAD6cAD9EAD-wADygPhw9UD4cKk1vzCdsJDwkPiA83D4gPZg_ID5YPiA-G
D4gP9pYe8QJZD4kPiw_JD70PiQ-wD4kPJH0zkYoDBQ-BBQ-2BTEpUWMPiw_a9QHxJ4sPCQMPQQMP
egMPswMP7QMPKA_ND2IPjQ_eD40P2Q_NDxYPjg9SD44PkA_OD80Pjg8LD48PSkYC8QuPD8kPjw8J
D5APSQ_QBQIPzAIPDQ_RDAEPk7gQ8QAaD5IPXg_SD6MPkg-oD5JxSACwNGC6D5MGD5RJD-EAAg4P
2A4PIQ_VD2oPlQ_01AsAvwLxCZYODQ-fDQ8rD5cPdw_XD8QPlw8RD5gPX71usZgP_w_YD0oPmQ_a
nwzxHZkPOg_aBQQP2wQPLQ_bD38Pmw-RD5sPJA_cD3cPnA-KD5wPHg_dD3MPnQ-I2lgxng9zzCyA
ng8fD58Pdg9nX2GfDyUPoAelMjEuD6H3ArLhD6EPOw_iDQsP8UprMagPo0dS8QhgD6QPvQ_kDxoP
pQ94D6UP1Q_lDzQPpkNfEfKFFfEApw_xD6cPEQ_oD3EPqA-S0TnxAKkPlQ_pD-cPqQ9aD6oPvFcy
EatFMQBdFFFLD6wPrzsM8RCtD3kPrQ-fD60PRQ_uD6sPrg8SD68PeQ_vD_APrw9HkD2hsA8YD7EK
AA-pAOEpgbwPsg8mD7MClx6TZQ_0D9APtA88Vg9BFA_2CtgB8RlaD7cPxw_3DzUPuA_jD7gPEQ_5
CgwP7gwPXg_6D80Pug89D7sPrQ_7AGNRjg_8D-6COPEAvQ-hD70PUw__D8UPvg83m1FRvw8cD8BZ
b1ECD8EPds1wAG1FEcI0PVFHD8MPvJZhscQPpg-EDxwPxQ_SaFIRxr4X8QT1D8YPbA-HD_MPxw9a
D8gP0g-IMBtTwQ-JDzrHHvEaKw-LD6QPyw8dD8wNAQ8QD80PiQ-NDwMPzg9_D84P_A-OD3MPzw-t
D885GvEK5A-QD18P0Q-bD9EPVi-SD04P0w-LD9MPR9Yu8RLUD0EP1Q__D9UPOw-WDAYPNg-XD7QP
1w8yD9gPsA-YDy9AThHZtxaRqg-aDykP2w_o-EPxBNwPpw-cDyYP3Q_mD90PJg-eD6ZJRfMA3w_m
D98PJw-gD6cP4A8oYg8RKRcW8RriDywP4w_tD_MPLg-kD7AP5A8xD_UJDg81D_YPtw-mDzkP5w_7
D_cPPRJ88AroD0IP6Q-FD_kPRw-qD8oP6g9ND_sP0A-rKFbxEwYFD1kP7Q-cD_0PYA-uD_MP7g9m
D_8P6g-vD20P8A-xD-B3GhH5PiYx8g8AnhOx8w8ID-QPjA-0DxBae-MM9Q8ZD-YPnQ-2DyEP9w_m
D-cPKg-4D64P_A8zag_RPA-6D8AP_g9FcHzxEPsPTg-8D9IP-A9XD-0P2w-9D2AP-g4ED2kP-w-u
D-8iZzH3DwCnClEADwIPhaZcAFIlAD8aAAQI8RYEDxwPBQgHDyUPBg_pDwYPLQ8HD7IPBw82DwgP
uw8IDz8PCQ-D3UsxCg-LSyjxCAsP1A8LD1gPDA-cDwwPXw8ND_MPDQ9n6xcxDg9voReyDw92DxAP
_Q8QD33_HvEVD4MPEg8GDxMPiQ8TDwwPFA_PDxQPEg8VD5UPFQ8YDxYPmg8WXBgxnw8XPU2RpA8Y
DyYPGQ_onR7wCRoPqw8aDy0PGw_uDxsPMA8cAAsPMg8dCeFuER7wIfNCNg8fD7YPHw83DyAPtw8g
DzcPIQ_3DyEPNw8iD7cPIg82DyMPtg8jDzUPJA_0DyQPMw8lD7IPJQ8wDyYPrw8mDy0PJw_rDycP
KQ8oD6cPKA8lhw_RIA8qD50PKg8a4QRxKw8TDywPkCVmcS0PiA8tDwTZOvEALg-7Dy4Pdg8vD-EP
Lw9sFCHxEjAPYQ8xD9sPMQ9VDzIPzw8yD0kPMw-CDzMPOw80D7QPNMcPMKUPNb4AwQ0DDw4PNw_F
DzcP-bRLUTgP6w84EVzR2A85D04POg-EDzoPOXkp8QQ7DyQPPA_ZDzwPDg89D4IPPQ-2AhpzPg-e
Dz4PUZUPgTcPQA_qD0ALYljxAEEPAA9CD3EPQg-jD0IPU98pcUMPNA9ED6VVGhFF_gaR8w9FD2IP
Rg-RcRoAEyrxCkcPGw9ID4gPSA-1D0gPYg9JD84PSQ87D0rpI-ABEg9LD30PSw-oD0sPUw9MDwxw
ESfCCEBND-oPLi4gTgGWTmBPD5wPTw9vUvINaw9QD9IPUA85D1EPnw9RBw9SD2sPUg-QD1IPNZ0P
wQQMD2IPVA-FD1QPKL1ikFUP7g9VD1APVgUYgQ9XD3QPVw-U8iqQWA_VD1gP9A9YLCQgsg-ZT-EI
Wg9vD1oBBQ8qD1sPhg9bD_MPWw8-D1wEUzH2D1wMEDGsD12FMfEOYA9eD7kPXg8SD18Paw9fD8MP
Xw8bD2APcg9gD8nOafEQYQ92D2EPyw9hDyEPYg92D2IPyg9iDx4PYw9yD2MPxWk7Ap8P8Ay9D2QP
Dg9lD18PZQ_wD2UPAA9mD1APZggOD__kARFn-hYR2c1a8C1oD3MPaA-AD2gPDA9pD1cPaQ_jD2kP
7Q9pDzcPag_BD2oPyw9qDxMPaw9cD2sPpA9rD_sPaw8yD2wPeQ8xW_FsBw9tD0oPbQ_PD20P0-p_
sW4PWw9uD50Pbg-gK2nzFG8PZA9vD6UPbw-lD28PJQ9wD2UPcA_kD3AP4w9wDyEPcQ9frA8x2Q9x
SitxUQ9yD40Pcm1Y8QYCD3MPPA9zD3YPcw_vD3MP5w9zDx93ATF0D452YjF0D-pMTPAkdQ9lD3UP
mg91D84PdQ8BD3YPNA92D2cPdg_ZD3YPyw92D-wPdg8tD3cPXQ93D4wPdw_7bC3zKg93DxgPeA9G
D3gPcw94D58PeAEJD-cJDyIPeQ9ND3kPdw95CAIPygIP8gIPGg96D0IPeg9pD3oPj7MPUdsPeg--
Bk3xGHsPSA97D2sPew_OD3sPsA97D9IPew-0D3sPFA98DzUPfA9UD3wPdHYnIXwAbUcQ62pHAPFa
cX0PQA99D1umXgBXg-IcfQ_pD30Pwg99D9oPfQ-yD30PCQ9_DyAPfg83D34PTA9_D2IPfg92D34P
i2UfIAADNl0g1gPkQ5L5Aw8JD38PGQ80XpA3D38PRg9-DAsRffEibQsPegsPhQsPkAsPmwsPpQsP
rwsPuAsPwAsPyAsPzwsP1gsP3AsP4gsP5wsP7AsP8GQZ8QH3Cw-6Cw-8Cw-9CwQLBAsKEgAR63cK
ccMLD6gLD4ddAPEDNQsHCw-PAw_UAw9UAw8OAw-E708RffteQMUNDg0xOBOY4BAAhQ-APQ96D78C
Dz0CD7UJwlgATBERAFgRMHYPxP4uIx91JE5DEw9zBXgPEdyWYgAHYBFv4E8Tpw1OEfFXYGBrDyoP
ag-kLqNRD2gPXh9nDg9rbg8RaJBdAL8yUWEPRQ9g0y6AGQ9eBA9cD97fTREFyS4xaQ9Y2E0RCYAT
MFQPm1gGUVIPHw9Ryk0TlrkuAMJNca8PSg9cD0m6TQCyLhFStwQxQw_Rzx4CXQ8A9nwT8KJNUxEP
Og_dmk1zrx81DzQPuZwuE7qITTGzHywzPhEpxnIxjw8md00TdIsuAP1Ck8APHg8sDx0PloQuAO8i
ktAPFg83DxUPnRA_EQ5rZQJTTRKPdi4gDA-qeUEGDxUHXCIAbi7DNw8AD5cED-gP-A9YRw9BGg-4
DSllUfQPQA-zXS4AI00AumETzxtNEZshFxHoE01T1A-kDz9AD3AXD_APhg-eA01CDg-bH-hMk8MP
1g87D9UPtD0uE6zoTDCsD817bwC-HlM7D8kPxddME98uLhED0CgwwA8xyVkCJi4xCg_7v0w0VA_4
t0xQWQ_0DwsmXCMAAhQug-UPrQ_4D6wDnkwAB1wT5ZZMU5IPpQ9uJA_QMQ_iDxgPoQ8Du34C-S0A
gUwx2A_bex8T29hbEO4eAXOWDxMPlg8sGw9Taw_TD5FiTCLrD7lbEVjtajOOD9ZSTADjLRK4SkwA
SDsTxRUPw5APiAoPhw9vD4cP5tEtEeMbEkKFD-Qvxy1Asw_DDDVeM4IPob8tUwQPgg_9qh0iPw_3
LQAUTBGpRkwzgA9fry0TKygeEwtIHhcBBAAAEAATBHQeEwnPLQCrLVcUD4APGVweEyr3LQBDPRNA
Tz1xUA_ABQsPYzYEYXgLBgsPjzUEIKcLaoGgwgsP0AsP3gsP7RAEUw0PgQ8dnGoTQGUek2QPgQ93
D4EPi6otAIYuUcgPgQ-dTykRged5UyAPgg84ri0QaKF6AWBdM4IPtEhMACQ9IAQG_1-zDjwGD1gG
D3UGD5MGAAYP0AYP7wYPDg_EDy4PhA9PJXsRkUcBEYT8axP4KA-xED8PhQ9jD4UPiA_FD60PhQ-T
D4UP_Q_FDyAPhg9HD4aIIxOX4GrxGegPhg8SD4cPOw_HDgkPkQkPvAkP6AkPFA_ID0EPiA9uD4gP
mw_ID8qVOQI0D-MGVw_JD4YPiQ_3D4kP6A_JDxkPig9L92oAPiEx4w_KWUiTSg_LD38Piw_0-2rz
Ah8PjA9VL4wPww_MD-oPjA8yA2sxpA_NDkHxABcPjg9RD44PjA_OD8cPjg5rET4hRfEAjw_4D48P
9Q_PDzMPkA9xCGrxAJAP7g_QDy4PkQ9uD5EPrswqM5EPMB9rcLMPkg-2D5JVGXINBw-ABw8ERg-z
Bw_ND5QP0g_UDxgPlQ9eD5UPpQ_VD_wva9F7D5YPww_WDwwPlw9VRx4zlw-oN2vzBn0PmA-ID5gP
Ew_ZD18PmQ_rD5kP_D9r8QaSD5oP4A_aDy4Pmw99D5sPzA_bDxuBenGcD7sPnA8MmhgAkxJznQ--
D50PUU9r8AD2D54PSg_fD50Pnw-xD583RRGaKRFRRA_hD5q2MbOhD0YPog_dD6IP9KYeUaQPow-8
KGOzpA_uD6QPBw_lD2Foa7EVD6YPcA_mD8sPpsZxU4IPpw-ecGvxAJcPqA-0D6gPUg_pD68PqTtK
E2x4a1EqD6sPicFBsasPSQ_sD6kPrA8KIVdxrQ-MD60PLg4jUa4P8g_uiBUSuIhrIAMBnhQRRpFG
AN1ZE3WLa-ECQA_zD6YPsw8MD7QPcg_0D9meGgJjD-ABDw_2D3cPtg-gD7YPSA_3AGMI8Qu4BgQP
7QQPVw_5D8EPuQ8sD7oPlg_6DwEPu59rsdgPuw9ED7wBDA8cqBEzvQ-2pWvR0A__Dz4Pvw_sD78P
Gshw8ADAD-cPwA4PwQ-VD8EPRA-pf3HCDyMPwwcF7XQAPgkR5VxFAIIFscUPOA-GD6oPxg8ccQIx
xw8AggnzAMgP5Q-ID1gPyQ-LD8kPPmcPESbBa-IAyw8OD8wPgg-MD-cPzA9szWvzBw9WD84Pyw-O
D0APzw_2D88PLA-QD6LWa-IDjw-RDwUP0g0KD-MKD2oP0w-i22thD9EP1A9JqQCx1Q85D9YACw8q
D9fia1EbD9gPlBNzEdm0fVMAD9oPeeprMW0P28wV02EP3A-bD9wPVQ-dD9Dya-EAxQ-eD0AP3w_7
D98PNg-g3oATLXIP8QAkD_IICQ8cD_MPmA-jDxTYUwIAbFGJD_UPBa5Rs_YP-g-mD3sP5w-4CGxR
8g-oD2-XJfAV6Q9qD_oP5w-qD2UP6wkDD2AP7A-eD_wPXA-tD9oP7Q9XD_4L2Rsg7wrmNfAC8A-O
D-APTQ-xD8sP8Q9JD-IcbKEPRg-zD8UP8w9EVCBz9A9BD-UPwCVsANYB8wI8D-cPuw-3DzoP_A_5
D-gPOHYPkTYP_g_1D-oPNG5ycvsPMw-8D7I1bBABnBeR-g_vD-4PLg--sIExLA8APGzzBisPAQ_q
DwEPKQ8CD6gPAg8nDwMPpkVs8AOlDwQPJA8FD6MPBQ8iDwYPoQ9KMhEHTmwxHg8IpV-THA8JD5sP
CQ8ZDwoPmFZsgJYPCw8UDwwH8h_gDQ_QDw0fDg_ND6568QAPD4kPDw8IDxAPhg8QDwReYQJ8DxF_
mYsREgEbk-cPEw91DxQP8mps8wTtDxUPag8WD_cPFg9lDxcJDg9ecGzxAlgPGQ-VDxkPUQ8aD84P
Gg9K1zACeGxxvg8cDzoPHfBAkDIPHg_tDx4PKZpB4R8fDyAPmg8gDxUPIQ_QjxgzIg_FhmxReg8j
D-TOdREk4m0AuWcS245s8AIPzg8mD0cPJw-ADycPOQ8oAMMNAoIPMBsPKl1Tww8rD4IPKw-6DysP
cZxs8ANfDy0LCA9NDy4Pww8uDzoPLwFcAdEwD5sPMA8RDzEPhg8xpAFTcQ8yD_WpbDHODzP5DvED
tw80DQ81D54PNQ8RDzYPhQ82nXVxag83D90PNy45U8EPOA8zu2yxFg86D4gPOg-5DzrGWxHaBA8Q
PMNskQ0PPQ_aDz0PCfOJcz4P5w8_D1aEDxEz42QxQA8OMnpyQQ-pD0EPVtJsAFFDUZsPQw8H3Rpz
RA-eD0QPSdlscR4PRg_ID0axAjBcD0ffIgDMJADgbNEAD0kPaQ9JD9EPSQ84ylhQSg8HD0vobKEP
1Q9LDzsPTA_huzCCTQ9sD00P0Q-ybJGbD04P-w9OD2MyI-EBTw0PUA_ND1AGAg9SD1EPtI5Ps1IP
dw9SD9gPUg85KB9x_g9TD1kPVAUKkRgPVQ93D1ULCghtQJIPVgY9TQBqRzFXDwYmXQIObfMFGQ9Z
D3QPWQ-PD1kND1oPhA9aD90VbdGQD1sP6Q9bD0EPXA_Z7nYzXA9IHW1R9Q9dD0t1NLNeD-cPXg9M
D18PoSVt8wZJD2APnQ9gD-APYA9DD2EPlQ9hD_ctbUCKD2IPy3bTLA9jD3wPYw-MD2MPHJUPMLkP
ZDAigQoMD6MMD-AMXY1xiQ9mD9UPZpkh02wPZw_2D2cPAQ9oD0tFbRHdITHzAGkPbg9pD7YPaQ-_
D2kPRU1tkdIPag8YD2sPXZBLEWumWBMrVW3zBrIPbA-1D2wPOA9tD3oPbQ_8D20P-V1t8wZ_D24P
vg9uD-4Pbg89D28PfA9vD7plbXE1D3APcg9wckST6w9wDyYPcQ9inQ_R1w9xDxEPcg9K9icxcg_8
DEoBdW1hD2MPcw_auXGzcw8GD3QPPA90D3GAbdPZD3QPDQ91D0APdQ9z3Ioi1w_IbRE6CCDwCHYP
mg92D8oPdg-5D3YFD3cECQ_ECQAJRlvRCg94DzYPeA9hD3gPjAiC8yB4D_EPeA8LD3kPNA95D1wP
eQ_FD3kPrA95D9QPeQ-6D3kPIQ96D0YPeg9sD3oPkaUPMdkPerNc8wIfD3sPQg97D2QPew_GD3sP
pwMvcecPew8HD3yKMhFFuwECwD2gng98D7sPfA-XD8g9AvaMEynoPbBeD30JDg_QDg_oDmUH8QfY
DgYODwUPfg8bD34PMQ9_D0YPfg9abwECLz4TlWYf8wK6D34Pyw9_D90Pfg-tD34P-fU_AJhOEyt3
fQCyXRNU6h7yBm0Pfw95D38PhA9-D48Pfw_ZD38Po6E_oQ_1D38PvQ9-D8XxYwJuHxPZyT4X5E5e
CAU-Evr-bQ1yHxH0GYmRfw-OD38ABw_MfVfDLgcP9Q9_D7UPfg9tXk9wyg4Pbg4PC180AqFPYbkP
ew87D9AP8QUNCA_YD3kP-w94D18PeA_5CQ8MCTlQAElQMd4PdGlQQ0oPcwnKDzG9D3Aag8DrD24P
_Q9tDwEPbQ_hXfAE-g9qD-QPaQ-kD2gPzw9nD7MPZq5fAMQP8BpAD2MPDg9iD9gPYA_bD18PWg9e
DxQPXQ-ID1sJD1oPIg9ZD8cPVw9oBPF2EZs7UzBSD7zki5FPD8sPTR9MD8lNXQAcgeNHBQ9GD5UP
RA-_D0IPZLAPMSUPPrIrUdgPOg8sTFBgNw-MDzUPNIuQYA8yD6YPMA-q9W4zLQ9oqw-wCd4PJw8V
DyYPSg8kD34PIg_vDyAP3w8eD-gjcTkPGw9kDxnRC1K1DxUP3KMP0A8nDxAPSw8OD24PDA9IWFGy
DwgP1OqKsAQPFg8DDzYPAQ9X734z-Q_Yng_w2w-3D-wP9Q8fD-QnfZAMD-APig-uD6_nEePqD-4P
6A8nD_cPUQ-lDpQPUdoP3w8KOVbxFdwPcg-aD6gP2A-hCw8cD9UPWg-TD5oP0Q-cD88PIQ-OD2kP
zI8PMQEPyZ8k8Q2mD8UP-Q-DD1cPwg_0D8APFQ_-CA_9D_IPuw9O12sRuNQlAIgPoSUPtA_lD7IP
KQDLhVE-D64P0CaKAHYIEapVa5NED6cP7Q_lD5qCD-EKBQ_iD8IPoA_FD58PTA_eDxkPnQ-sD5sP
w_gLgJkPhA_YD20PzIkzlg9PfA-RSQ_TD08Pkg9bD5EPbT4sEY_fWVDID40P8whG8QEPjA9bD4sP
mQ_KD90PiQUB45DxBNEPhw8vD4cPlA_GDwAPhg9yD4VuWhFr2DswgwcD8HGyrg_CAgYP_Q_BD6jr
WgH7WvES4Q_AD6wPgAcED1gEDzkEDyAEDw8EDwQEDwEECgQKBA8DDQBxBgQPCQQPDBwAgBMEDxcE
DxwELUKhJwQPLQQPNAQPOz9C0EoED1MED1wEDAQPbwR1kfEEhAQPjwQPmgQPpgQPswQPwAQPzYkc
EeqPcQDpD5MXD4EPJw_BDzhuHhJbvWrwBQcND5IND6UND7kND80ND_IND-cNQYVBIgYPObMt8ARn
BgcGD5cGD68GD8kGD_IGD-wGo0DxBDIDD00DD2kDD4UDD6IDD78DD9y5MxMZih9TVw_ED3eaH-Ma
tw_ED9kPhA-6D4QPHA_FDz4PhQ9hL4UPqA_FD8wPhQ-xD4UPFg_GDzu0LRGImz4ghguGM-ETDyUP
hw9OD4cPdw_HD6APhw-KD4cP9A_HDx4PiA9KD4gPdSQdcIgPzQ_ID-pFDwDILhAD7msQ4K5r0YoP
Pw_KD28Pig_gD4pbIBECLXoxiw9m3gGziw-MD4sP-w_LDzPGLVGcD4wP0R9t0Y0PPA_ND3MPjQ_p
D42pIPMNGA_OAg4PiA4PwQ4P_g4PNA_PD24Pjw_oD48P48xb8ypaD5APlg_QD9IPkA8PD5EPTA_R
AQgPxwgPBg_SD0QPkg_ED5IPww_SDwMPkw9DD5MPhA_TD8UPkw_LHiEPiuFtcZQPEA_VD1OaiXGV
D9sPlQ8gbHqRlg_qD5YP7w_WCpBxfA_XD8IPl0QLALiQE5nAifEFKg_ZD3MPmQ_8D5kPBg_aAiUP
5QU9ClF7D5sPxyIq8wScD2APnA_tD5wP_g_cD0gPnQ_W5y1QMw_eBgpIZfAFIQ_fD3EPnw-BD58P
Eg_gD2MPoA_MfhEGlnoRobCN0-4PoQ9RD6IPpA_iD-hGD-EVoA_jD-UPow9KD6QPoA_kD-UPpA9L
D6UPog_lD-kPpQIPpg_n4zEA21-zAKcPrw_nDwcPqA9gD6gPuvYtkW0PqQ-HD6kPIvN08QCqD9gP
qg8zD6sPjw_rD_uRE7GsD6QPrA8AD60PXi0es60PGQ_uD3cPrg-VAS7zKZMPrw-yD68PUg_wAAwP
EQAPcgAP0gAPMw_yD5QPsg-2D7IPWA_zD7oPsw8cD7QPfg_0D_EPtA9ETQ-RCw_2D28Ptg-TD7YP
OEZCsbcPAQ_4D2cPuA-MsQQguQ9fmhH_jAkRuu88MTIPu0COMQAPvBAu8R-QD7wPOA_9D6APvQ8J
D74Pcg__D9sPvg9ED78Prg_-DxgPwAYED_wED1YvwQ8sywExwg8CHmcAMySxww9GD8QPsg-EDx6s
a1HFD-gPxbmGEdJdBqHHD60Pxw8bD8gBtwOTZg-JD9QPyQ9DVQ-xICEPywgHDwAPzA9wD8wP4A-M
Ag-NBAsPMQ-OD6EPzg8SD88DCQ-1CQ9mD9AP1w-QegsTuxouUZ8P0g8SblzzI9MP9w-TD2oP1A-d
D9QCD9UPww-VDzYP1g_qD9YPHg-XD5IP1w8GD9gPeg-YD_4P2A9jIy4RTMFxMdoPNpmKMdsPIBgk
MdwPC7ITAGAl8wrdD2wP3g-iD94PWA-fCQ4PRQ-gD7sP4A8yVw9xHw-iD5YP4ocdkYQP4w-7D_MP
c-g08QbkD2IP5Q-ZD_UPUQ-mD8kP5g9BD_cwbREx8oAz6A8hNS6REQ-qD4oP6g8CmThA6w-0D39W
Eey_RPMRXg-tD9cP7QIP7g-JD_4PQg-vD7sP7w81D-APrg-wDyc_LqAaD-IPlA-yDw0PNYCA8w8B
D-QPei_Dc-MO9Q-oD-UPYQ-2D9sP9g9VD-cJBQ9JD-gPww-4Dz1gD5ExD-oPqw-6DyXVczH7DxqI
NLH8Dw4P-Q_ID-0PAtRIsf4FCg9xD-8P6w--YxtT4A8AD1pILoBODwINDA9DDzd0gAMPNw8ED7EP
9zGRBQ_lDwUPHw8G5gNxEw8HD44fB_0FAI9sMwgPdU4uYGkPCg-jDwIoMAsP1hF-AFtFAFEAEQ3B
NfECNg8OD68PDg8pDw8Pog8PDxt7BHMQDw4PEQ_HZw-wEXkPEg-yDxIPaw8TD_MPEw9cDxQP1Q8U
D00PFQ-GDxUP2JnxBrYPFg8vDxcPpw8XDx8PGA_XDxgPD14u8CUZCgAPdg8aD_0PGg9lDxsP3A8b
D1MPHA-KDxwPQQ8dD7gPHQ8vDx4Ppg8eDxwPHw_TDx8PD2YggA-ydDMgD2xwLvEEVw8iCwYPQw8j
D7gPIw8tDyQPo1g_8QwlD4wPJQ8BDyYPdg8mD_oPJg9fDycP0w8nD0fWjTMoDy9xD5EWDyoPiQ8q
D-wyOTErD_ICe-AALA0BDzoPLQ_sDy0PHg8u_xQRDEk4ACZ1MS8PViplAoEuMKkPMbU-8QKKDzIP
_g8yD2oPMw-aDzMPSX0ZMTQPKJcFIDUP3SHAdQ82D_MPNg9SDzcEziMBiy5BDwkPOQqI8AHjDzkC
DzoPvQ86DykPOw_Ws4HxBDwPbg88D9kPPA9FDz0PsA89DxstBwDzGTM_D1p5D-EOLg9AD5gPQA8B
D0EPag9BD9MPQQ88D0IPpA9CDw2fWWBDD9wPQx85j8FEDxIPRQ95D0UOBx_VLoEPEQ9HD3cPRyFB
kUEPSA_mD0gPCgAt8xRJD9MPSQ82D0oPmg9KD-0PSg9gD0sPww9LDyUPTA_HD0wP6Z4u8QasD00P
DQ9OD20PTg-OD04PLg9PD46jUEBPD00Cd3IxCg9RMxsAihkxJQ9S4TVT4A9SDz1_D0D2D1MP_ofx
Bq4PVA8JD1UPZA9VD78PVQ8aD1YPdPITMVYPKMFk8QBXD9oPVw8zD1gPiw9YD_NOGwKuLuDqD1kP
QQ9aD5cPWg-tD0V98QZbD5kPWw-uD1sPQw9cD5cPXA-rD1w1G9GTD10P5g9dDzkPXg_LE0ICti4A
oAnxBtIPXw8jD2APdA9gD8QPYA8UD2EPY8JpsGEPAQ9iD08PYg_eTHfzAQ9iDzkPYw_GD2MP0g9j
Dx_LD-EGtg9kDwEPZQ9MD2UPlw9lD_EPZQ8rH1tgZg_9D2YPcDGxTg9nD5YPZw-eD2eoQDFsD2hX
gRP5zS6RhA9pD8kPaQ8NfSsRaokmINkPtVkRa8IfkaEPaw-jD2sPJI5tQGwPpg_wj3NsDycPbQ9n
f4wx5Q9tgRJRYQ9uD5_RMxBuvT_AVQ9vD5IPbwvGHfECcA9DD3APfg9wD7gPcA-yD3ByEhNklA-x
HdQPcQ8MD3IPQw9yD3oPcg_xD3IP5w9yDxwPcw9SD3MPhg9zD7sPcw-vD3MGpgGzdA_ID3QPuw90
D_3qLvEATw91D4APdQ_wD3UP4A91LSPxCT4Pdg9tD3YPmw92D8kPdg-2D3YPIw93AqI9QacJD9Lo
CVMnD3gPUTktcaQPeA-MD3hJLVMcD3kPRFktUZEPeQ_3YzRieQwPeg8neC1BAwUPknCcs9gFD-oF
DxsPew89eU4Aoi0AFGgxvQ97GDvxBPsPewAPfAgKD1QKD3EKD40KD6mYKRHgo5-zDhQPfQ8uD30P
Rw99D2APfQ94D30PkA99D6gPfQ_-05tR7A99DwG8gDN_DyslLgD9LkFnD34F-Wahnw0PsA0PwQ0P
0k4LM-INDFsuAIZOEy1rLhdIkQ8TbFttEYMvZjN-D5ebLlOpD38PsqsuE8LbbQC7LhHWflQCyy4I
Ay8f8pUPDBP8uQ8AvlQSvHyNIw9hnI2j3g0Pjg0PNQ0P0uWNY_8KAwoP5SKOQLYFDxAaPhF5XY7x
AOcJDxwJD0gPdg9rD3UPhXWjAMgoAoQPEJTudlADD2gPbsshMRoPbK8806oPaQ9nD2gPGw9nD8c-
HzEJD2OrRzEsD2DuRnExD10PqQ9bgnIRhf5NAS6MAHUPEOuZmxECKz8RtV1kADkzgUkPSw9HD3EH
RwsTr28P8QDYDz0P5g87D_8POQ-0CAHLB3AzD_gPMQ-d4YEzLQ_6ZQ8wiw8nTpoRT0gGESH-RLHi
DxwPuQ8aD44PGDqQQTIPFAxMawA0mBENpF6QNQ8JD-8PBg-JX1izDA9cDwAPJg-_D_9TD-EAhA-3
D08P9Q8aD-MP5w-wgHoAolpRVQ-qDygzZTPlD9JODxCFdxAx3Q9CJhYg2Q83fPMB8w-UDg-SD88P
0A-CD84PuUUP0bMPyA_2D8YPvQ-ED8oXe-IEwA-wD74PCg_9DyoPuw9PD7kPeT4PYA4Psw8aD6eg
8AKwD6MPrg-xD6wHD6sPoA_pD8hMU2kPpg-YNQ_xyg_hD04PoA-aD56WUnEHD5wPqQ_aoAUxBA_Y
ooUTfy0PERtEWTGRD9j9SQAxHFGOD7QPjRCaEsiZHhP-mR4RWqSYsIcP2g_GDygPhg9-6QARhEuX
AFuXETm_LiCCApd88wyBD40PgQ86D4EP8A_AD7EPgA97D4APTw_ADy1RHgDBPBYBBAAgDAa8HfEE
BgYPCAYPCwYPDgYPEgYPFgYPGtEdwCQGDyoGDzAGCAYPPbQOcE0GD1UGD17CDvMVD3AGBQYPhAYP
jwYPmgYPpgYPsgYPvgYPywYP2AYP5gYBBg8DKGsAG0xTMQ_BD0F1HpNjD4EPdA_BD4aVLbGrD4EP
vg_BD9IPgQtNMPoPgawPESTUD0FPBA9m5VHhlAQPrAQPxAQP3AQP9QRlmPECKA_DD0IPgw9dD4MP
eA_DD5OPWfMEgw-LD4MP6A_DDwUPhA8jD4QPQO08E32iW9O8D4QP3A_ED-wPhA8dPQ8xXw_Fd3qg
pA_FD8YPhQ-pD317EYYXGFBVD4YFACiQUMUAD_oAwwkQCOproAAND64ND9YND-_MjjGID1KBoABv
XQDWEDOID-yAHvEGUw_JD38PiQ_sD4kP2Q_JDwYPig80ihaRig_RD4oPwA_KLXcASFdxTw_LBgoP
sdQuURQPjA9GVRXwCYwPqw_MD94PjA8SD40PRg_NBQkPrwkP5OwZEY4pCBGF1itxjg-zD44PKp_T
cY8Pmg_PD9JfIjGQD0QPcxGQvk-wEfIPkA8tD5EPaA_RD6MPkQ4LDxsPkg9XD5IPlA_SD9EPil6Q
kw9ND5MKAw-K4wYCRQ_RiA_UD8gPlA8IwgKxlQ_KD5UPzA_VDw0XpJGWD5IPlg-VD5amCgAqCJGg
D5cP5A_XDygrEvEMmA_zD5gP_A_YDz4PmQ_FD5kPyw_ZDxIPmg9ZUxLQmg-pD5oPMQ_bBQIPw08L
MZwPVl1MUJwP6g_cnJVxBgwPywwPFjgI8QieD68Png-7D54PSA_fD5UPnw-jD58PMeUFcaAPzQ_g
DxzgB3GhD7oPoQ8KczFyog_qD6IP_1EPsAwHD_8HD0EPpAMBhnxwOA_lCgQP3vNCUKYACA-a-UEA
Y0Bxpw-ZD6cPLiM-EaigExEw4ozxKqkP3Q_pDzUPqg_MD6oP5A_qDzwPqw_UD6sP7A_rD0UPrA_e
D6wP_A_sD1EPrQ_rD60PBQ_uD2APriUj8QYWD68PcQ_vD8wPrw8oD7APhA_wD_CcChGx3Ypg9w_x
D1QvfXjzCLMPbg_zD8wPsw8rD7QPig_0D_kPtA9ITw9xCA_2D2gPtswEESnfIJG3D_oPtw9MD7ho
I1EPD7kPcUVCAFGm8Q66D5gPug-7D7oPXw_7D8IPuw8lD7wPiQ_8D_0PvIhIkLYPvQ8bD74GDQhl
8Q5KD78PsA_-DxYPwA98D8AP4g-AD0gPwQ_vD8EPFvgmUcIP5A-CzwrxLrMPww8bD8QPgw-ED_sP
xA9TD8UPvA-FDyUPxg_OD8YP9w-GD2APxw-KD8cPNA-ID54PyA8ID8kPcg-JD91enwJeD5EdD8sP
iA-LD-STg6DMD8sPzA83D80HoZtRzg97D84ooPEcVA-PD8EPzw8uD9ACDg8JD9EPdg-RD_QP0Q9S
D9IPwA-SDy4P0w_cD9MPCnMYMdQP56c5ABCBYNUPNA-WB9M0cdcPgg-XD-KZk-EC2A-SD9gPQg-Z
D7IP2Q8iD9ouUvEEAw-bD3QP2w-kD9sPVQ-cD8YP3O8bAP0BcBoP3goFD-3oOFHfD_AP34wLU8QP
4A82aA8A_4JRjQ-iDwBwSDHjD_VoC-EI5A-LD_QPPg-lD7EP5Q8kD_YPlw-mDwpbV1HnD-EP57uj
MdgP6BoMkcAP6Q80D_oPp7GSAM8kMOsPBMB18Qkv7A9gD_0P1Q-tD0kP7g0MDzIP7w_nD_-jidGQ
D-APBQ-xD3oP8Q-viJTwD-IP2Q-yD04P8w-DD-MPOA-0D60P9A8iD-UPlw-1DyqfcYIP9g-3D-YI
pxHiYZRz_A-MD-gPQnEP8CctD-oPog-6DxgP_w_ND-sPAw-8D3gP-AwDD2MP-Q-ZD-0PTw-_D8QP
-g86D-8Prw--DyUPAALdL_EBAAQP_wQPcQ8CD_YPAo5KkdIPAw9HDwQPvWNGkQUPqA8FDx0PBrAT
UQgPBw994pJRBw9oDwhcbZFTDwkPyA8JDz2FFwATj4ALD50PCw8SD39CIAwDSGlADQ-mDzJeUQ4O
Bg9E_QLwAA8PLg8QD6IPEA8XDxEKCURlYHQPEg-pD0hqcRMP0Q8TD0VvX-EGFA8tDxUPoR8VDxYP
iQ8WD-0PFg9wq23gFw9XDxgPyw8YDz4PGQ8KnZElDxoPmA8aDwtEGlAbD-APG0EcIQsHzpkAXzEA
7g4wnw8e-QgRg_Z88QQfD2cPIA-ZDyAPSg8hD7wPIQ8tnpTxCCIPEA8jD4EPIw-yDyMPYg8kD9MP
JA9ErRfxBiUPJA8mD5UPJg8FDycPdQ8nD_QPJ_IsU8QPKA8zeQ8REhImICoPOZwRXqRAkSsPOw8s
D6kPLAiM8S6FDy0P8w8tD2EPLg-ODy4PPA8vD6kPLw8WDzAPgw8wD-APMA9cDzEPyQ8xDzUPMg_h
DzIPDQ8zD3kPMw-kbZqANA_7DzQPJg_slfEGNQMFD2YPNg-RDzYPOw83D6UPNw8P7UrQOA-iDzgP
Sw85D7QPOWtO8QUADQwND1YPOw__DzsPJg88D44PPC4hYF0PPQ-EDy9OMT4PksScAF5oAoMPsSoP
QA_QD0AP9Q9A9B3xCsAPQQ8kD0IPiQ9CD_0PQg9RD0MPtQ9DDxlbO3FED_APRA9DUlLxCEUPCA9G
D2oPRg-MD0YPLg9HD5APRw-xCkmxSA_zD0gPFA9JD3S8IgBVEPEOSg_UD0oP9A9KD1MPSw_yD0sP
EA9MD28PTA-ND0zHTpGJD00P5g9ND0PPCWBOD-0PTg-raIG2D08JD1APbdh-8QBQDyMPUQ9_D1EP
2Q9RDzN9onNSD_cPUg9Akg8R8mEA4FQPow9UD-sPVA9TD1UPkXERAn1Z8QJWD7APVg8GD1cPXA9X
D7IPV9SGMV0PWEUVUQYPWQ9b1FJxWQ8CD1oPVhVTIFoDwZ3xBFsPoQ9bD-MPWw9ED1wPlg9cD_fi
XvAQXQ_ID10P2A9dDygPXg93D14Pxg9eDxUPXw9kD18PsopGMWAPTpcbMmAP6LhdsYEPYQ-ND2EP
GQ9iSquArw9iD-oPYg_ufTGOD2N8FBMhlg-wIrMPZAMED0QPZQ_MD2UP0w9lDxoPZg9hD2YPpw9m
D_0PZg8zD2cPeA9nD74PZw8CD2greREKpWtxEg9pD1UPaTpI8QDaD2kPGw9qD10Pag_eD2pulpEg
D2sPYA9rD6DxWMBrDx4PbA9dD2wPmw91S7FsDxcPbQ9VD20Pkkos8QhtDwoPbg9GD24Pgg9uD70P
bg-4D24PMlofMW8PppUFwG8PGA9wD1EPcA_JD3Kps3AP_A9wDy8PcQ9mnA-xA9IPcQ8ID3IPPS9y
D6cPcg-bD8erEUIFH3FzD6cPcw-ZiWvxBHQPPQ90D24PdA_eD3QPzw90D-4SS3F1D10PdQ_MHVkA
fSQxdQ8WujvxGnYPcA92D5wPdg-ID3YP9A92Dx8Pdw9KD3cPdA93D54Pdw-ID3cP8Q93rFGQQg94
D2oPeA_SkB3xEQ94D_APeA8HD3kPLQ95D1IPeQ94D3kPnQ95D8EPeQ-lq6ryAHoPLA96D08Peg9x
D3oPk0If8wwLDg-3Dg8YD3sPOA97D1cPew92D3sPlQ97D7ToLlPvD3sPDB_r8gpGD3wPYg98D30P
fA_YD3wPsw98D80PfA-noz4jDxo0XgCxMXFiD30OBw_RQI3SvgcP0wcP6QcP-gcPEq0_cQ0AD00A
D2AMGEGFAA_W2jgguADKryDYAEFt8wH3AA8GD38PFA9-DyIPfw8vJY1XSQ9-D1WxDwCtblCBD38K
DHRHUJ4MD6cMW5XxDbcMD78MD8YMD80MD9MMD9kMD94MD_MMD_gMD_ymIfEI8wwP9gwP_AwP_gwD
DA-9DA-_DAkMD-vXZRHLoZWwYQwPFgwPvAAPVABnPyFYB-1dESPqL8F7D7YOD_oPeQ8QD3niXQDI
jBEwsgEAojAjdAuEDwCejDEGD2-KLlM7D2wPw8IuAHGMEBM-EhEEWowS_rQuUR9dAA9bqy4xoA9X
-CgAcw9xig9RD28PT5wuAP2LEuuULgA-KREbPV0RP82LAJFiAIMuALiLQbYPMw2jQxEumIsAZg9h
Ew8nBw8kbS4wRg8faYsRAaRjURcPrg8UuR4AQIsRo2pUEQkpi1CKDwQLD4N-Qf8PbQNVDxEG3ZIR
9D8uAOGKEUbcHRHpyooRTc8KEeGyipFwD9wf2Q9GD9eSigAgLhGrLSgRzUUPEUHGaxHFES4xEQ-B
dR6Wag_8DyIPug-hPQ8QU4RXEa8LigADigD0LTEdD6dZTgA1D0B1D6EP1YkR5QeZEZxdLADdLVNO
D5cPxS0PAJWJMXYPkc4tEtV3iTAID4wePABdiQAkDxEtACwghw_2LVORD4UPznlbAAojE9qsLQA_
SxNnpC0Tt_2IE0JgLRYIEw8F8EsTBC8PABwAGwqYLRMYw2oTIkdbAF8PUzMPgA85nC0TR3cPElcE
LvACCAIPcQIPewIPhQIPjwIPmgKzG3CxAg_9Ag-JVohx4wIP8AIJAhtW4RsPgQ8qD4ENBg9JBg9a
4UsgewbbtfACngYPsAYPwwYLBg-pBg-9Bg_zJ4AlD4INDA9PDFFdcXsMD5EMD6gyA7PXDA-vDA8H
D4MPICQQADIWANJrU4YPgw_hl6cR195rANScM4QPLFQQE2YXTHChD4QPwA_Ep6chCQQoD1M9D4UP
Xa2nU58PhQ-BHUwxBA_GtadRSg_GD22BATGGD7UJKiCGCcknM4cPSSRMAMcQcbsPhw-iD4fnPBIx
y6exDAcPqwcP1AcP-QcyD3FRD4kPfA_JvqZA0g_JCWutAeg8Iw_DtC0A3KegDAoNCg9pCg_YCuGn
8QP3Cg8nD4wPVw_MBwMPuQMP6gM1TLFOD40GDg_zDg-nDogS0k4PjgwFD7cFD_wFDyG-mFAOCA-D
CJa08h8wD5APaA_QD58PkA-XD5APEA_RD0kPkQwCD7sCD-UCDy8Pkg9pD5IPpA_SD98PDahxVg_T
D5IPkzusEgsqDxEAczNRAQ_VD0BTJPMElQ_9D5UP-Q_VDzwPlg98D5YPvUxMkz4Plw_AD5cPwSyo
UEUPmAcE3pGTDg_ZD1EPmQ_VVExTHg_aD2M5qPEA7Q_aDzMPmw95D5sPvw_bQ6jBTA_cCwkP2wkP
Iw_dSKjxAbQPnQ-8D50PRQ_eCAEP2AFzClNsD58Pt2FMcE0PoAQND_TnRwAnJBGhWqhxFg_iD2MP
ojS3E-56HtOaD6MP6Q_jDzgPpA_HbKhRJg_lD3Yhb3OlDxcPpg9nbkyTCg_nD1sPpw_tfKgxUg_o
aH6B9w_oD0sPqQGoPwB2THGaD6oP7w_qiahRmQ_rD_5YGTKsD5mRqJEPRg_tCQMP8wPTR_CiD64P
_Q_uD1EPrwoGD0syAJ_oorMPsA8MD7EPZQ_ETACnqNBzD7IPzQ_yDygPswwFJ0JwOQ_0Cw4P8I5c
AjMPUQQPtg9h6Q4xtg8brSbzBLcP1Q_3DzMPuA_RD7gP7w_4D02QTJILD7oPag_6D8nJqEAHAg-o
PVoRvA2aUwkPvQ9pl0xTKw__D43WqHFQD78Psg_-nZcTdt6oUTsPwQEAn0wTZOSoEStqqhHDkg0A
PHMRvP1wcsUPhQ-FD_qnTPICDggPGg-HD38Pxw-lD8cPSw-7qBEXeaNzyQ-kD8kPSzcP4hkPyw_A
D8sP6A-LD08PC6nTHw-ND4cPzQ-vD80PWBOp0ykPzw_SD88P_w-PD2QbqcE3D9ENBA8KD9IPdA8h
qSMPSM6ZUxwP1A_HK6kRXK9xEdU_iBOdM6lTdA-XD_DHTBO3O6lRjw-ZD-u5OJHaD9QP2g9AD9uU
hzPcD4fNTABLqfAAzg-dDzsP3g_oD94PFg-fU6lhD-EP3w9fnC4AgaACRA8RF14EkeIP8w-iD2IP
42SpQD8P5AOntzPlD4tqqQDdTJPYD_YPRw-nD7ZyqdGVD_gPBA-pD3QP6QoGeKkiww-lTHGjD_sP
Eg-sgKkx8g-sSrbzANMP7Q9DD_4FDA8jD_8PlO1ME3WOqUBWD-EInpgz8g_olKmTiQ-zD-oP8w9r
80zxAk0P9Q_9D-UPLg-2D58P9g8RIzTzAPcP8w-3D2QP_A-VD-gPRkoP0ygP_g_aD-oPCw-7D3y1
qVFfD-wP0KdVM-0Psr2pAC9BEQaoJzH-BgfDqRHM8nRxAQ_uDwEPIJiQMQIPAwlNU_UPAw9W06lg
OQ8FD6oPsxkRBnEjANupIG4PaUcRBxNNE8LjqVGkDwkPFZafMwoP9_upk9gPCw9JDwwPuhtN4JsP
DQ8MDw4PfQ8OD_0P6y0AhxHzAA8PPw8QD68PEA8fDxEPkM4e0nAPEg-gDxIPUA8TD8AMqkENAg8Q
cGIxFQ-vhgwRFjBNsT4PFwMBDx0PGA_MUBAADFqRGQ-ZDxkPSA8aIaoSJjhNEA-CBRNyKaqxTg8d
D70PHQ8rDx4QBREHogkzHw-jw5oTvjmq05kPIQ8GDyIPcw8iD_BBqhG6PoszJA_U05oRbR8YICUP
EHtRsQ8mDx11BnEnD-UPJw9gVIUzKA83ZQ8ACJWTeA8qD_MPKg9OYqrTIw8sD40PLA-3DywPYWqq
ETVUdiAuDzoU0XIPLwkAD0QPMAMODxVqKhExdqoTT2ZNER_in9EzDAQPVg80D70PNA8kNpARNYWq
U1kPNg_-cE0RjHgCMTcPWPMiczgPIw85D4iWqpNSDzoPtw86Dxx6TZHkDzsPSA88D6z5bTE9D3OP
pdM9DzoPPg_dDz4HCg9iaw8RJ5qB8QpAD_oPQA9MD0EDBQ8OD0IPbw9CD9APQg8xHznxBEMLCA9R
D0QPsQ9EDxAPRQ9wD0X-hBEukxYzRg-ry6oTp45NU2IPSA-A1KpQeg9JD9aQmABLRALbqlNHD0sP
opVNIlkP46qxDg9ND2gPTQ-DD03hAQDrqlHQD04PKWs2AZ1NAAQ_EYtNYJFQDzsPUQ_SD1H6qtNA
D1IPlw9SD_0PUg9Ebg9R7w9TD0XQkADqnYFUCA9VD5gPVSsaEUCnBzNWD_etTQAnCDHfD1cuSQAZ
q9PVD1gPJg9ZD3gPWQ-IIasTabVNEQmHDxFbKasx9w9bYy_BlA9cD_IPXA5sijNdD8u8TRNkOquR
-Q9eD0kPXw_U0gQCQquRdQ9gD78PYA8JC1oRYUqrEubITVB3D2IPv1GrAW4vs2MPlg9jD90PYw8k
dw-TsQ9kD-YPZA88D2UPgWSr0wsPZg9PD2YPkw9mD9ZsqxFdLmfxAmcP4g9nDyQPaA9mD2gPpw9o
_qUiKS94qxPp3k1TaA9qD6eAq5EjD2sPYQ9rD59suCBrD7yOU1UPbA_R5k1ACQ9tD5CrAOkskrkP
bQ-zD20PLZirQA0GD9mIChFv7iAAbEfTuQ9vD-APbw8nD3APXaircMkPcA-_D3AGFBNofA-R0A9x
DwQPcg83D3IPamQN0XIPzw9yDwEPcwQCD2TGZRHFdQkAXDsRVV118AN0D7MPdA-hD3QPDw91Dz0P
dQ-JqxOXBU4AsQUxGw920avRcg92D50Pdg-HD3YLAderU0QPdw9tC04Tvt_r0w0PeA80D3gPWw94
D4Lnq5PND3gP8g94DxcTTvEEYA95D4QPeQ_nD3kPyg95D_0Pefqr0zEPeg9TD3oPdA96D5XDLjHV
D3r4UlAUD3sECTRdsHAJD40JD6sJD8gJy0oAG07xCR0PfA84D3wPUw98BgwPiAwPogwPvAwP1a1F
EweIPVI2D30PTjYeFAl5D1C8Bw-RB52-IfoHJk4TIiesE0fELkFsD34HHEnwAp8KD68KD78KD88K
D94KD_0KRqQAbT4TF5keALdtWj4Pfw9KgA-gAQMPgAMPigMPkwMPnAPFpqGtAw_1Aw_8Aw-DCBoR
0L0_oNsDD_ADD_UDD_l5RnELAw-0Aw-20T7B_wMP-AMP-QMP-gMFuCog3wPqO3BhAwUKD4IKbxlQ
RAcPgQyfIABZPgAMRxGNjU9Qdw8JAQ9CbSEtAmwPYfkPbw8-BhltEY24ITFoD4qiITFkDzoOjCFf
DVCqEVvSbDA1D1ZeDzELD1CybDFwD0ujbACbbBPEVg9xvA88D6cPOcNYQFwEDyjyDwJNDwBObABG
bAA_bAA3bAAvbAAobABHDwAabDAZDwsKbEAPKA8E-GsxBA-9QA8xQQ-23GsxVg-vzWsxdw-ovWsA
OA8RTGM9EdqfawCXa1MaD9EP4jIPY48PxwEPxGhrQb4GD7tQawCjLQBAawAfVBFswjgATxoAZQoC
Ig8h8A0DawD7ahBGkCxRmA80D5YYDzFyD5LOajEDD48tAUPqD4sKEQ8AoGoTwJBqE7OCajEED4MJ
D0CzD4EACggCUmoTMdsOHwHvWgQXB0JqEw-zWhMXK1slHw_bPIAAAw81Aw88A6s0cEkDD1EDD1n9
AXEPagMPcgMM1SxBjwMPmloCobADD7sDD8cDD9NOAhHtLwLQCAgPFggPJAgECA9CCKyJ8QFhCA9x
CA_CCA_TCA_kCA_2wMVA2ggP7d_bUYIPEw_CRHQTO5w8EWT2nzOCD49OagCyelHSD4IP6cllASBc
IA4F5azxAWEFD3oFD5QFD64FD8gFD_PIGQAtEPMCNA_ED1APhA9tD4QPiQ_ED6bOeZPhD4QP-w_E
Dx4ED6FcD4UJBw_bBw_7Mq8Q-YM3M4YPP2stYIQPhg_mD_6oMYYP7F03c4cPNA_HD1hbuFGiD4cP
x9tcMYcPEyY28wSID2APiA_HD4gPrw_ID9cPiA--Ox4xUA_Jpb4gog-hiiCJDwmsUSEPig9MfZHw
DYoPog_KD84Pig-6D4oPJw_LD1MPiwgCD64CD9wwJgAyiQKBLbGWD4wPxg_MD-UPjEdWkVYPjQ_H
D40PuPZsMY0PG-eOAJKQ8QqOD7IPjg-lD44PGQ_PD0wPjwMLD7ULD_kLii0xUw_QKj9Rvw_QD-XZ
RjGRD2OqqvEGkQ-RD5EPCQ_SD0EPkg96D5IPsg_ShqXRJQ_TD14Pkw_YD5MP049tASYPIAUBPEAQ
__ZAkZUPcw_VD7APlUCWkSoPlg9oD5YPpkmM8A6WDyMPlw9iD5cPoQ_XD_APlw8gD5gPYA_YDQYP
4ekJ8RSZD2MPmQ_lD5kP5w_ZDykPmg9rD5oPrg_aD-EPmg80D5sPd89P8wybD-8Pmw9ED5wPiA_c
D80PnA8TD50PWA_dD56lLZEqD54PcQ_eD7g2tfEDng9HD58Pjg_fD9YPnw8fDQ9nhiQQ_Q8oEaF6
x1HWD6EPINo1kaIPtg_iDwEPozIP8AaXD6MP4w_jAA_kDAoPyAoPFQ_lD2JYrCEPpQaP8ARLD6YP
mQ_mD_cPpg82D6cHBA-U3TlzqA9zD6gPw64tcWQPqQ_0D6nOC9FWD6oPqA_qD-kPqg9LcH7wCqsP
8A_rD0IPrA_VD6wP6A_sDzsPrQsOD_MWSGGuAgkP3wmwLbGJD68P3g_vDzMPsFtfEd_IQTCxAgg7
qvEFOA_yCwMP5wMPPg_zD5YPsw-tD7NSOJOeD7QP9g_0D081DwDCcfEGWg_2D7QPtg8ND7cPZw_3
D8IPtw8cW4TxBLgP0Q_4DywPuQ_HD7kP4w_5Dz5SmvMAug-2D7oPUg_7D68Puw8Lvy0RxSEUABI1
Ub0P3Q_9JRpxmQ__D-cPvrAosLMPvw8SD8APcQ-Amr3wAQAPwQ_OD8EP7g-BD04PwgmrCgLLLUHO
D8MAN23xCsQP8Q-ED1IPxQ_zD8UPFA-GD3YPxg-YD8ZtkfEsnA-HD-4Pxw9gD8gPww-IDyYPyQ_I
D8kP7A-JD08PygMBDxYPyw95D8sP3Q-LD0EPzA_lD8wPCQ-ND248cfMYzQ83D84PnA-ODwEPzw9m
D88Pyw-PDzAP0A_WD9AP_w-QD2EP0Q-H4y3xBpMP0g-5D9IPYA-TD8YP0w8tD9QPlCNicdQPYg-V
D8lSY-EE1g_YD9YP-w-WD2cP1w-PD9cPN4Fhc9gPBw-ZD2-sLRFAcCDxCNoPEQ-bD3kP2w-iD9sP
Sw-cD7QP3A8eQZ4x3Q-wLTnR3g-DD94PLQ-fD5YP3_ksIGoPJMgz4A8_Sg8REzqU0eIP6A-iD1IP
4w_9D_NVHFGSD_QP-cU18QjlD9MP5Q8_D_YPqQ-mDxQP5w_AD_cP6zMLU_gFBg8u-C0RBUOW8Qbq
D9wP6g9ID_sPtA-rDyAP7A_MD_xWoeBkD_0P0Q-tDz0P7g_pD7KJQO8Pgi8nVQAjkTPwDzQBLvEC
DQ-yD3oP8g-nD-IPVA-zD8GrHGD0D5oP9A-TNvEKdA-1D_EP9Q9OD-YPuw-2DygP9w_VD-cPA8cZ
AExUM-gPSlQP0SQP_g_SD-oP-w-6D2yAEPAA_w9HD-wPtA-8DyEP-QsNXLEAnDmA1w-_D0QP-whc
a7MAD4wPAA-5DwAPZxQusUEPAg_vDwIPHA8D9G8AbQBgZA8ED9EPjYNABQ_sDycG8QAGD4YPBg-z
DwYPYQ8HD86vF0AID6gPMJ4zCQ_CIC7RXA8KD8kPCg82DwsPo0yacQwPfQ8MD_kvskAND8MPehMR
DinLEQnQCvMEDw-iDw8PTg8QD7sPEA8nDxEPlFsP8QBsDxIP2A8SD0QPEwgKDx3sQvEIFA-0DxQP
YA8VD8wPFQ84DxYPow8WDw95hhEXHKvTUQ8YD70PGA8oDxkPk5VcMWkPGpIIUT8PGw_qEckRHNc4
8AXqDxwPVA8dD78PHQ8pDx4Pkw8eDQlX8wQfD9EPHw87DyAPpQ8gDw8PIQ94Ny6BSw8iD7QPIgfe
FfEAIw-wDyMPWQ8kD8EPJA8q8gUAmy-xBiUPYw8mD8wPJg80DycPnA8nDwQPKNZpU9MPKA87Yg8x
Cg8qTpYR2NGpMSsPpnwQALU6ALVPsSwPQA8tD6YPLQ8MIYmALg-YDy4PPgBgBVAJDzAPbm1fA0ku
8ACdDzEPAg8yD2YPMg-LDzKYMtGTDzMP9w8zD1sPNA_-F5UxNQ_GFn6xNQ9MDzYPrw82DxJCTRE3
hwMSOVMu8Q0NBA9fDzkPwQ85DyIPOg_EDzoP5Q86D0YPOw_naKURPFWH8wzIDzwPKA89D4gPPQYO
D0gPPg_nDz4PBg8-D2VrD-EMIw9AD4IPQA-gD0APPg9BD5wPQQ-6D0EPVw9CP73wBBIPQw9vD0MP
zA9DDykPRA_FD0Q0jgC4MaKZD0UP9Q9FD1APZi7xAAcPRw9iD0cPvA9HDxcPSPC48RzLD0gPJQ9J
D34PSQ-YD0kPMQ9KD4oPSg-jD0oPOw9LD5QPSw-sD0sPRA9MJhYT824u8QChD00P_A9ND08PTg_l
D04ZUCBRD1to8BVPD-wPTw9SD1APpw9QD-wfUA9RD6QPUQ-5D1EPTA9SD6APUg-tXxNHdg8ApW8R
P7dykVQP4w9UDzQPVTIn8QbXD1UPKA9WD3kPVg-JD1YPGg9XD2ozQ0BXDwkvGVcxWA-2N30Cei7x
AuEPWQ8uD1oPfA9aD8kPWg8WdGzxAFsPrw9bD-sPWw9HD1wPkwdK8AdcDykPXQ90D10Pvw9dDwkP
Xg9TD14PN78T5oIuEXkgmNFfDwoPYA9SD2APmg9gqr0RKUTKAP8V8QJhDQIPQw9iD4kPYg-PD2IP
FKDKAD0rc2MP4g9jDyd7DxGuPiMAn5fxFmUPdw9lD7oPZQ-8D2UPPg9mD4APZg-BD2YPAg9nD0MP
Zw_DD2fcCwCqKxFDKkeRaA-BD2gPAA9pkC5xfA9pD7oPaSd4ETX1DvEAag_uD2oP6w9qDyYPaw9i
uRfwA2sP2Q9rCg9sD04PbA_ID2wFCUNrIjQvkC6x3g9tDxYPbg9OD25ahBG8tKbgbg8pD28PXw9v
D5UPbwFtC-ABNA9wD2gPcA_dD3AP0A9wD3sPUzcPcQ9qfw8xzw9xDbkRMppOEXJLDDHFD3I-iPEC
JQ9zD1QPcw_ED3MPsw9zD_FjxiF0DlucIJgL7Jkx8gsHuYkRdVtrANe0McwPdWFrkCEPdg9LD3YL
CHLREcYdRlMXD3cPP4xrwI4Pdw_1D3cP2w93D30sAKIu000PeA9yD3gPlw94D7sAH-EdAw95DycP
eQ9KD3kPbQ95D48PeQ_xD3kP0w95D-QPeQ8VD3oPNg96D1YPeghzHkG1AA-Ur2TTEQ97Dy8Pew9M
D3sPaUQ_MaMPezNsUdsPew-2N2wRfAOsAAUfdGAPfAAED5NdKhHdXSoArAXxCiMPfQ86D30PUA99
D2cPfQQGD5IGD6cGD7vaSBHjamdTCg9_Dx2qbBNCti7wCGUPfggND4cND5cND6cND7cND8YND9UN
xsYQ8RgjUw0Pfw8as11TMw9-Dz_LDxNWiw9gaw9-D3UvMCoCt10Tmk0_F6u8LhHBFxgCRKwEUT4T
3p_cE_fALhPuwC4ANT4X98ddDMQuABwAE8N8APECzw0PDg0PHwYPAQQPtgAOD3kwEQDnTQDhTQCc
D1FKAw-OCcBNQV4PZwlkMgA8IlFeD7sPWpRNAOkeENyQHBFLdE0AbE0Agw8Apw0AVE0ATk0ARk0R
pOZEESUwTQAoTQAgTQJnuTAND1MLDhEDT5gAbQ8A7EwxBg-w3Ewxaw-mZQ8R9UiMEdi3TACvTCG0
AZ9MIQMFVpkAh0wAVQ8xwQ_xckwAa0wRuodbEaPdmABMTABETBP_Rw8ALUwAJUwxHQ_NX5hgKA_J
Aw_H-ktDH4QPUzUPE3vaSxNf-h0XAQQADy8PARMLL6cTEnV5GxkyHhIsKmoBzksA0D5xRQ_AD0wP
gIF5E1uHp9BrD4ALAgYCD4YCD5ACNh4RpHe1EbocE0HRAg-djaYh9gJrLUARD4EHN7cApsCwSgoP
WQoPaAoPeArWTBGZlTFBugoPzBQSEPAtWzGCDxWBgzeCDzxBDwAKExGNhntxgg_4D4IPzaDGMYIP
_h5GAnMtMD8Pg1HA8wgDDQ_IDQ_hDQ_6DQ-TDQ-tDQ8HD4QPIl1qEVdABBGElpcRq2qZ8QGED_QP
hA8BD4UHBA88BA9aZT1xlwQPtgQP1nYDExVkahNWdMcRmcy5cYYP3A_GDAB-jZFED4cPZw_HD4u0
XLOHD9MPhw-3D4cPHP5LsWcPiA_ND4gPsw_ImbgRANcXwYkPTg_JCA4Png4Px2FTkRgPig9BD4oP
a8QsMYoPv8448BeKDxQPiw9AD4sPaw_LD5cPiw-DD4sP7w_LDxwPjA9JD4wICQ_kCVsz8SgAD40P
Lw_ND10vjQ_8D40P7A_NDxwPjg9MD44GAQ_uAQ-fAQ8RD48PQw_PD3UPjw_nD48P2g_PgUeAQA_Q
CwUPqAVYu1ERD5EPRqLO8ASRD7APkQ-mD5EPHA_SD1IPkg4CxXpB9wIPLuMVspMPng_TD9cPkw8P
Pg8Beouxuw_UD-UPlA8vD5UxgPAMpA_VD98PlQ8aD5YPVQ_WD5EPlg-ND5YPCQ_XsZ6hDQoPwAoP
-QoPOwRC4ZgPtw_YD-YPmA81D5kLIlxB8wMPMydEMZoPs4oLkZoPNQ_bCAcPuHgUETws0LGcD8AP
nA8DD50PRilu8QadD80PnQ8RD54PVQ_eD5oPng-fD57CpNFpD58Prg_fD-QPnw86ZKrzEaAPxg_g
Dw0PoQ9UD6EHBA-jBA8rD6IPcw_iD7sPog8DQg8xlQ_jUpfAKA_kD3EPpA_7D6QPmjkRUKJAMaUP
5cZusaYPfA_mD8gPpg8TocLwHKcPrA_nD-gPpw9FD6gCDA-gDA8tD6kPew_pD8kPqQ8XD6oPZQ_q
D7QPqg_BUPEzUg_rBAAP8QAPQQ_sD5EPrA-hD6wPMQ_tD4IPrQ-TD60PJA_uD3UPrg-HD64PGQ_v
D2sPrw_9D68PDw_wD2IPsA_165ZxsQ9bD7EPrppwsbIPVg_yD6oPsg-_Fa0Rs9x6MfwPszVHEaeR
DGC0D1IPtQwTcwCyw-EXAAYPAQ_3D1gPtw_vD7cPBg_4D14PuAYBDw0PuQ9lD7kPvg_5Dxb-RfAB
ug-HD7oPIA_7D3kPuw-TD_6lEbwXbzHgD7z3OPEWlA_9D_4PvQ9JD74PpA__D-8Pvg9aD78JBQ8Q
D8APbA-AD8gPwKYLUYAPwQ-c3wrRwg_VD8IP8g-CD08Pw6qtEAnGCIEvxA8iD8UPgKNL8APFDzwP
xg_aD8YP_Q-GD1gPxwbYGvEByAsND9QNDzMPyQ_TD8kP8phCApEeURIPyw9ypltxyw8zD8wPlArW
kcwPVg-ND7cPzW6-8AJ5D84P2w-ODzwPzw_eD88PAC1zYQ-QD8QP0CeI8ReJD9EP6w-RD04P0g_x
D9IPEw-TCAoP2goPPQ-UD6AP1A8ED9UPZ-WZAIdxIdYCiBZAWw-XBZUMkNgPiA-YD_wP2J8pQQYE
DxrjZPEA2g-kD9oPSg-bD68P2w8UzWWA3A-fD9wPRQ_AqvEF3Q8QD94IDA-cDA9CD98PqA-fDw90
NzHgD9uEsQJOD0EPD_IIicTxAEQP4w_rD_MPEg-kD3kP5KFikUcP5Q_vD_UPFibDQOYP5Q9UJfEA
5w_0D_cPHA-oD4QP6A-s9YGR6Q_8D_kPJA-qc4Ax9A-qXTlRxQ-rDy3jT1HsD-4P7FkpAA5dcTcP
7g_gD_5gDpFyD_8P2g-vD0MtIZHwDxUP8Q9_D-FDLvEQUA-yD7kP8g8iD-MPiw-zD-QP8w9dD-QO
AQ8wD-UPmYfAAOktcfYP1Q-2Dz6cIXH3DxEP_A97qnsz_A9OVw8RIVcUgPoBCQ9dD-sO5T5x-A_a
D-wPBKpI8Qr9Bw0PQQ-_D6oP-g8UD-8Pfg--D_cP-w9RWasRAJ_D4I4PAQ-3DwEPYQ8CD8sPfltx
Aw_eDwMPB5EKcQQP2w8ED0QbMfEEBQ8XDwYPgQ8GD_oPBg9UDwcPvUXBEQhPvCD5D__aEQmZERE1
eZHRCg8IDwsPcQ8LD9oPC_mYIK0PHTIAXgnwAg0P6A8ND1EPDg_6Dw4PIw8Pk38QAcyIURAPxg8Q
o5kTl1wP8AFoDxIP0Q8SDzkPEw_iDxMPdjMxcw8UHgIxQw8VsCZREw8WD3uG0ZEWD0sPFw_zDxdA
wlCCDxgP6neogQ8ZD7kPGQ8hfKAxGg-v7QxxGw__DxsPJT0GsRwP8w8cD1oPHQ-AbR5gHg_ODx4B
S5XxAh8PwQ8fDycPIA_ODyABAw9aO34AT7OxIg_LDyIP8Q8iD1cjotAjDyEPJA_HDyQP7A8kAzwQ
BuUf8w0mD4APJg-kDyYPSQ8nD64PJw8SDygIBA-aBA8_YA8RBq8J8QIqD84PKg8xDysPlA8rD-gP
K-jHMb4PLJEu8QSEDy0P5g8tD0kPLg_rDy4PDg8vLSvxAtIPLw80DzAPlQ8wD-cPMA9ZCVcxMQ8b
HSpxMg-eDzIPPsy5ETMqnJFgDzQPwA80DyHRpCA1DxF_8QBADzYPoA82D-8PNg9fDzdpYBEdBRux
OA-bDzgfOQ_YDzmmnABea3GyDzoPEA87ZykQy5tF8QA8D4UPPAAMDz8PPQ_cDz0GQNJVDz4PsQ8_
Dw0PPw9pag8RA-WmsEAP1g9ADzEPQQ_MvkAhH0FPkPEAQg-2D0IPUA9DD6kPQw8DNi1BRAYJCinY
QEUPwA_eygAYuvEDRg-JD0YPIQ9HD3kPRw-QD0cEVzoxSA-WoLUA-N0RScW8ETDsJgBJBHFKDzEP
Sw_GmhNRSw8xD0zgwFHaD0wPLrCqUU0P1g9NPCAxfg9OzwRQJA9PD3d8FPEPD08PHA9QD28PUA-B
D1APEg9RD2QPUQYODwcPUg9YPSVzUg-5D1IPSWwPMekPUyYBsYgPVA-YD1QPJw9Vh9YRxNymcVYP
YA9WD66Il-EEVg9JD1cPlg9XD_MPVw8wD1gPfCBS8QJYDxQPWQ9gD1kPrA9ZD-cPWSu7cY0PWgcL
DyJBmPEEWw_1D1sP-w9bD0gPXA_RD1wP2pSsEV3JTBCzCwTAD10PQw9eD4oPXg-R-0_BL18PpQ9f
D_uDiCFgCHu4APQD8AdFD2EPig9hD84PYQ8SD2IPVg9iD5oPojkQYjgy02IPYw_lD2MP5w9jDylw
DxGsQBTxDmQPLg9lD24PZQ_vD2UP7w9lDy8PZg9uD2YPrQ9mEwUxKw9n-zrxBqcPZw-lD2cPIw9o
DQIPnQIP2gIPFnnW8AFpD44PaQ-KD2kPBQ9qD0APL3pRag_1D2ouWVEqD2sPY-BUsWsP1g9rDw4P
bA9HhizxDmwPtw9sD_4PbA8mD20PXQ9tD5QPbQ-KD20PAA9uVpjQbA9uD6EPbg-WD24PC6scQQ9v
D3MbLPMKbw-aD28PDg9wD0APcA9zD3APpQ9wBwEPCXPIE2x_D5HND3EP-Q9xDy1djZFyD4wPcg_7
D3Lyn-EAGA9zD0YPcw90D3MPoQ9zDWMQ_8eZEXQbfvEEgA90D6sPdAcFDwIPdQ8sD3UPVwXDcXUP
qg91D9TFn3N1DyYID04ogg-B7QgPFA93DzoPdw9h8kdzdw_sD3cP0hBt8xYbD3gPQA94D2QPeA_H
D3gPqw94D84PeA-xD3gPEw95DzUPeQ9Xhi5RmQ95D7qMFrN5D-sPeQ8bD3oPOjCcU3gPeg_XCR8R
03w0AjickSsPew9HD3sPY4xsACxHIXsG_WYQ7BYuMHwDDBiKcVMMD2wMD4SuLXG1DA-MDA-kwy3x
ABEPfQQJDz0JD1MJAikPknKzILoJgg6z4QkP9AkPBw9_Dxk2PhE9YQMRfjXaU28Pfg_AA6winw8Q
jPEEvQ9_D8wPfg-aD34P6A9_D-YPfg_sERACFXN-DykPfw80dZwcS5APAYVtEX9LbROQ4U0ToVA_
4rAPfw_3D38Pvg9-D8QPU20EVD4AGD4T4OlNE_jujAhYPg_YDwkT64AAAFQQYcUMBg96BMqgEXWH
DwCHLhE-ztwRZCRdAGsuEZtUYRBNUy4Bcw8ARC4ROu15ESkuLgCLXABjDwAXLkDWDwEPXA8AAS4R
mwiZMeEf2fAFQbQPygHeLhG8Qw8AtVsAsi0AOw8R5VapEZgzDxAfkQ4hjARBExGGPR0AJA8AWi0X
QhgPCBwPAE4tAI2IEwgcDwhOLQNPHlADCg8kCix-IC8KuNhxOgoPQAoPRwNq8QNVCg9cCg9kCg9s
Cg91CgkKD4bvfUCZCg_jAYYAdFwRw-MgQdoKD_a6VkP-Cg8MV3kApEsAnIjxAkMPgQ9RD4ENDg9v
Dg9_Dg_OFA6Arg4Pvw4P0A4ErTDzDg92xlcXD4IPKRoP02MPgg93D4IPiw_CD5-7WrDJD4IP3g_C
D-QPgoqTEAPH3NEPTgsPZQsMCw_UCw_sKhMR3ohf0RAPhA8qD4QPRA_ED15QIhGEWqexrw_ED8oP
hA-mD4RuZTEfD4XwBkFZD4UIWKdBsgcP0Ko6cQ0Phg8tD4ZLx-MWbA_GD4wPhg_sD4YPzQ_GD_4P
hg8PD4cPMQ_HD1MPhw91D4cPmGkt8xLeD4cPAQ_IDyUPiA9JD4gPbQ_ID5IPiA_3D4gP3A_IDwEi
DwD0NJN0D4kPmg_JD8EoW8AQD4oPOA_KDQUPiAXEL0HaBQ8EkJOgiw9XD4sOAA_sAHG7kQIPjA8t
D4wPWV238Q6MD7EPjA-dD4wPCg_NDzcPjQ9kD40Pkg_ND8APjTLiER2ec-EUjg96D44Pqg_OD9kP
jg8JD48POg_PD2oPjw_bD48PzA_PD-2bvACovfAFkA_TD5APxQ_QD-gPkA8rD5EPXg-lXVGRD8UP
kXuN8QAuD5IPYg_SD5cPkg-MD5LO2vMCOA_TD24Pkw_kD5MP2g_TDxE6D1F-D5QPt_YpEZRLdVFf
D5UPmK2qsJUPCg_WD0QPlgkG77qB8gYPLA_XD2e5m3GXD90Plw8ZUybxLJgPkQ_YD80PmA8JD5kP
Rg_ZCwEPwQEP-gEPPA_aD3oPmg_5D5oP9w_aDzYPmw91D5sPtQ_bD-QPmw80waFRnA_0D5yjfvEC
Ng_dD3cPnQ_4D50P_g_dDzyOgTGeD8AnCzGfD0UsqbGfD8wPnw8PD6APU1Y9YaAP2w_gA0Ru8QKh
D6kPoQ-vD6EPNA_iD3oPol2sEwZIDwCga-AS2Q_jAw_kD2gPpA_vD6QP9w_kDz8PpQ_HD6UPzw_l
DxgPLKPwCKYPqg_mD-MPpg89D6cPhg_nD9APpw8aqI3xEA_oD68PqA-6D6gPRQ_pD5EPqQ-cD6kE
D6oPdA_qD8Be2vEAqw9ZD6sPpQ_rD-IPqw8-jNkwrA-aVBVhrQgCD8QCyobRYQ_uD7APrg--D64P
TsE9YK8P7Q_vD5dHAOirUd0PsA8uK3LxEbEPzw_xAw_yD3EPsg-DD7IPFA_zD2YPsw_4D7MPCg_0
pd6Trw_0DwIPtQ9Vph5R_w_1D06JH7G2D-YPtg9KD7cPnlDb8Sy3D0cPuA_cD7gP8Q_4D0YPuQ_b
D7kP8A_5D0YPug_cD7oP8g_6D0gPuw_eD7sP9A_7D0sPvA_iD7wP_ZytgL0Ppw_9D-8Pcc-wBL4P
rg__DwYPvw9eD78Ptw_-Dw_dZUEvwA8ZZ9DxBMEPyw-BDyUPwg9_D8IP2A-CDzJBXvEKww-mD8MP
QA-ED5sPxA-1D8QPUA-FD6sPxeWX8QZhD8YPvA-GDxgPxw9zD8cPzw-HDysFf-MEyA-jD8gPQA-J
D5wPyQ-5D8kPVWUPUQ8Pyw9s8lvxAMsPJw-MD4QPzA-iD8wPP5AREc2sxlFZD84PuHYrcc8PdQ-P
D9NZaABR2-EA0A-wD9APTw-RD64P0Q8NtLEAKpDxFtIPLA-TD4wP0w-rD9MPSw-UD6wP1A8MD9UP
bA-VD8wP1Q8tD9ZNYfAO7g-WD08P1w_wD9cPEQ-YD3IP2A-TD9gPNQ-ZBgra7JFZD9oPuw-aDx0I
B1HbD_EP20dJMaUP3CuJEWlemnHdDy4P3g_R5xWR3g9WD98PuQ-f9SsAPAdT4g-gD0V3D1EMD_IP
b45cEeIHSjGaD_OFx9FhD_QPxQ-kDykP5Q_NfN7xFeUPVQ-mD7kP5g8dD_cODA-mDA9KD_gPrw-o
DxMP6Q94D_kP3F1ZkeoPpg-qDwoP6_NU8QzUD_sPOQ-sD54P7A8DD_0PaA-tD80P7Q8yD_5uYlH9
D_4PYs-ece8PLQ-wD5IM3-ED8A9dD-EPww-xBA-yD44P8g-z6eTh8w_-D-MPJA-0BQcP8Acn4dG8
D-UPIg-2D4cP9g-tsElR9w_5D-dFmZOFD-gP6w-4D1F9D1AdD-oLDWrbADjhADh9cRwP-A_CD-zz
RACSOrG0D-0PGw-_DgAMAOxk8QqzD-8PGQ8AD4APAA-mDwAPTA8BD7IPAQ8YcXVxAg-lDwIPS0KD
8AMDDxcPBA99DwQP4w8ED0kPBQ8o6REVfoYxBg-huBdxBw_uDwcPE4vkgAgP3w8ID0UPFNgwCQ8R
_HPwDA8KD90PCg9DDwsPqA8LDw4PDA90DwwKCQ8-D60mMQ0PCgcLAKy6MQ4PO7sEMQ8PBvxlURAP
0A8QR1sTm4QPMWUPEjQSUS8PEw_UgLIREzNWQcMPFARcjwDfEDEVD1YIE_EWDx8PFwsBD_gBD0wP
GC5v0RUPGQ95DxkP3Q8ZD0G6b3EaDwkPGw9tWBgxGw80aNgRHEQB8AlfDx0Pwg8dDyUPHg_JDx4P
7A8eD08PHw8X6kEVAw944SgRPavhcSEPAw8iD2XMuzEiDyrLmlEjD_4PI9fDEbIQfPAOJQ92DyUP
1w8lDzkPJg_aDyYP-A8mD10PJw__DyfEkHOABA-hBA9Ciw-RAw8qD2MPKg-EDyoPJPPOcSsP5A8r
D0SPKCAsD_ZwUWMPLQ-DJD7wAi4OCA-gCA8-Dy8Png8vD-0PIsjxADAPug8wDxkPMQ93DzEP1aqF
MTIPkQJAUTIPTQ8z1lHRCA80D2UPNA-CDzQPH9loMTUKEvLrMTYP7pBM8R43D6cPNw8CDzgPXg84
D7oPOA8VDzkPcQ85D8wPOQ8nDzoPgg86D90POg84Dzu3sfAH7A87D0cPPA_hDzwP_w88D1QPPQ_u
D7A4MT4PYfQjcz4PEw8-D2z7HhEdUVqxQA-ND0APJQ9BD32rb3FBDy0PQg_EpUfwBUIPMg9DD4kP
Qw-gD0MPNg9ED40PUxPRRA85D0UPjw9FD_QPRXcfsY8PRg-kD0YPOQ9HKr-xAuMPRw83D0gPjA9I
D_APSA80YjbxAEkP2w9JCA9KDgYP1AYPJ0F4cUsPzA9LDx7ElmBMD8IPTA9iT5FlD00Ptw9NDwjZ
PfEFTg_pD04NBQYPTw_aD08P6g9PDzp7J4FQCgcED1EPd10acFEPFA9SD2L8UmMPUgAMD0yWD7Dn
D1MPNA9UDgkPzesyAOWqYFUPsg9VAE0xsVYPlQ9WD_APVg8rqg0RV_yFcQoPWAkBD57GAhExPw3R
WQ-DD1kPDA9aCQMPnWArMS0PWyTJgbwPWw8DD1wGAxqB1wIPHQ9dD2PYSbFdD_4PXQ8zD14PeQbT
oF4PAg9fD0YPXw8PpPEIzg9fDxIPYAsID5gID9sIDx4PYQgND6PcQ3EmD2IPaA9ipnZR6g9iDysN
D7NjD6sPYw-rD2MPK48PAEaw8QXpD2QED2UPZg9lD6QPZQ-iD2UPIE_M4GYPmw9mD9gPZg8UD2cP
EeoRjWJ30WcPBA9oD0APaA97D2iiRBHxiFkxaQ9lEhiRaQ-YD2kPEg9q4LsRhGsMMWoP9LjbAHUA
ApYPQNMPaw8HHxFAYIsAFytxbA-jD2wPGCJPMW0Pg0eCoW0P7A9tDyAPbgmlCiC7BeTnUSEPbw9T
NWZAbw_4Dw5iMW8PG-8BEXACm1GuD3AP3p4Ec3EPPg9xD22XD3DLD3EP_g9xly4xVg9yPToxsg9y
z6-xAgwPcw84D3MPZQ9zD5EPcw_9aXoA9GrxKnQPPg90D2kPdA_TD3QPvQ90D_cPdA8QD3UPOg91
D2IPdQ_LD3UPsw91D9sPdQ8DD3YPKg92DAoPeKot8wjFCg-rCg8RD3cPNg93D1sPdw_AD3cPpCI_
UewPdw8QlDwxeA9Wgg8xeA_bTbGReA-fD3gPAA95BW3wEkIPeQ9jD3kPgw95D6MPeQ-DD3kP4g95
DwEPeg8gD3oPPkycQy96D5igD-EW0g96D_8Peg8LD3sPJw97D0MPew9eD3sPeQ97D5QPew_uD3sP
yBfWcXsP-A97DxVI3RF8MB8RX397EXy1ewCBGcC9D3wP1A98D_oPfA9om1EWD30PK_wDMX0PVuPb
s30Pfg99D5IPfQ_miJuxzA99D98PfQ-xD30TrHEVD34PJw9_mJ8AzCIRWQC98wB_D3kPfg_JD34P
mA9_D6flXJPED34P0g9_D9_cXTH6D35ePhMTD04AoF0TNpmcEkzHD1ANBw9qB219cX0HD4YHD48C
phGfVi9BrgcPtVwvEcIRphHO3j4g2AcnPhHhbi8R6RrbIPAHI9sR9izbkfoHD-sHD-0HAAIAIQ0H
zS4Rnd4REWSEDwB8DwLfHhESZA8RqgNXEcpPDwBHD6BJD5QED4kPUA_C
:: src/.info.pod
--[[pod,created="2024-04-07 08:14:00",modified="2026-02-19 21:34:53",stored="2024-04-07 08:14:00"]]
:: src/sfx/.info.pod
--[[pod,created="2026-02-01 20:27:30",modified="2026-02-19 21:34:53"]]
:: src/ui/.info.pod
--[[pod,created="2026-02-01 17:54:12",modified="2026-02-19 21:34:53"]]
:: src/wavetables/.info.pod
--[[pod,created="2026-01-25 09:38:05",modified="2026-02-19 21:34:53"]]
:: [eoc]
