picotron cartridge // www.picotron.net
version 2

:: gfx/
:: map/
:: sfx/
:: src/
:: main.lua
--[[pod_format="raw",created="2026-01-23 13:38:19",modified="2026-01-24 11:33:51",revision=774]]
include "src/lune.lua"
include "src/pfx6416.lua"
sfx = include "src/sfx.lua"
include "src/basic_waves.lua"
include "src/wavetable.lua"
include "src/phase_distortion.lua"


local function hexfmt(n)
	return string.format("%x", n)
end

wt = nil

function _init()
	--[[
	for i = 0, 3 do
		print("-- Wavetable " .. i )
		print("addr = " .. hexfmt(wt_address(i)))
		print("width = " .. wt_width(i))
		print("height = " .. wt_height(i))
		print("")
		local addr, width, height = sfx.node_wavetable_info(0, 1)
		print("addr = " .. hexfmt(addr))
		print("width = " .. width)
		print("height = " .. height)
	end
	]]
	wt = Wavetable.new(480, 64)
	wt:set_wavetable(cz_sawpulse)
end


wave = 0


function _update()
	if not wt then return end
	
	local _, _, _, _, wheel_y = mouse()
	if wheel_y > 0 and wave > 0 then
		wave -= 1
	elseif wheel_y < 0 and wave < wt.height then
		wave += 1
	end
	
	if keyp("1") then
		wt:set_wavetable(cz_saw1)
	end
	if keyp("2") then
		wt:set_wavetable(cz_saw2)
	end
	if keyp("3") then
		wt:set_wavetable(cz_saw3)
	end
	if keyp("4") then
		wt:set_wavetable(cz_saw4)
	end
	if keyp("5") then
		wt:set_wavetable(cz_square)
	end
	if keyp("6") then
		wt:set_wavetable(cz_sawpulse)
	end
end


function _draw()
	cls(13)
	if not wt then return end
	local oy <const> = 270 // 2
	rectfill(0, oy - 100, 479, oy + 100, 19)
	line(0, oy, 479, oy, 1)
	local last_y
	for i = 0, 479 do
		local sample = (i * wt.width) // 480
		local value = wt:get(wave, sample)
		local y = oy - math.floor(0.5 + 100 * value)
		if last_y then
			line(i, last_y, i, y, 27)
		end
		pset(i, y, 26)
		last_y = y
	end
	print(string.format("%d", wave), 4, oy - 110, 14)
end

:: src/basic_waves.lua
--[[pod_format="raw",created="2026-01-23 20:54:55",modified="2026-01-24 11:33:51",revision=438]]
function saw(x)
	return (1 - 2 * x)
end


:: src/lune.lua
--[[pod_format="raw",created="2025-03-19 09:08:58",modified="2026-01-24 11:33:51",revision=1099]]
--------------------------------------------------------------------------------------------


if env().argv[0] == "/system/apps/terminal.lua" then
	function log(str)
		local path = debug.getinfo(2).source
		if path[1] == "@" then path = path:sub(2, -1) end
		local line = debug.getinfo(2).currentline
		printh(path .. ":" .. line .. ": " .. (str or ""))
	end
else
	function log(_str) end
end


function error(msg, level, title)
	level = (level or 1) + 1
	local path = debug.getinfo(level).source
	local line = debug.getinfo(level).currentline
	local str = sub(path, 2) .. ":" .. string.format("%d", line) .. ": " .. msg
	send_message(3, { event = "report_error", content = "*" .. (title or "error") })
	send_message(3, { event = "report_error", content = str })
	send_message(3, { event = "report_error", content = debug.traceback("", level) })
end


function panic(msg, level, title)
	level = (level or 1) + 1
	error(msg, level, title or "panic")
	stop()
end


---------------------------------------------------------------------------------------------


_modules = {}


-- A 'require' function similar to standard Lua.
-- Idea from elgopher on the BBS
function require(name)
	if (_modules == nil) _modules = {}

	local cached = _modules[name]
	if (cached) return cached

	local filename = fullpath(name)
	local src = fetch(filename)
	if (type(src) != "string") panic("could not include " .. filename, 2)

	-- https://www.lua.org/manual/5.4/manual.html#pdf-load
	-- chunk name (for error reporting)
	-- mode ("t" for text only -- no binary chunk loading)
	-- _ENV upvalue
	-- @ is a special character that tells debugger the string is a filename
	local func, err = load(src, "@" .. filename, "t", _ENV)
	if (not func) panic("\n"..tostr(err), 2, "Syntax error:")

	local module = func()
	_modules[name] = module

	return module
end


----------------------------------------------------------------------------------------------


function structure(meta)
	meta.__index = meta
	meta.type = meta
	setmetatable(
		meta,
		{
			__call =
				function(mt, instance)
					setmetatable(instance, mt)
					return instance
				end,
		}
	)
	return meta
end


--------------------------------------------------------------------------------------------
:: src/pfx6416.lua
--[[pod_format="raw",created="2026-01-23 14:18:54",modified="2026-01-24 11:33:51",revision=748]]
local inst_data <const> = 0x040000
local wt_defs <const> = inst_data + 256 + 192 + 32


local function wt_base(wt_idx)
	return wt_defs + 4 * wt_idx
end


function wt_address(wt_idx)
	return peek2(wt_base(wt_idx)) * 256
end


function wt_width(wt_idx)
	return 1 << peek(wt_base(wt_idx) + 2)
end


function wt_height(wt_idx)
	return peek(wt_base(wt_idx) + 3)
end



:: src/phase_distortion.lua
--[[pod_format="raw",created="2026-01-23 20:31:27",modified="2026-01-24 11:33:51",revision=494]]
function wcos(x, w)
	return 0.5 + cos(x) / 2
end


function wsin(x, w)
	return 0.5 + sin(x) / 2
end


function wsaw(x, w)
	return 1 - x
end


function wtriangle(x, w)
	if x < 0.5 then
		if x < 0.25 then
			return 0.5 + (2 * x)
		else
			return 1.5 - (2 * x)
		end
	else
		if x < 0.75 then
			return 1.5 - (2 * x)
		else
			return (2 * x) - 1.5
		end
	end
end


--[[
	y = a * x + b
	0 = a * 0 + b
	b = 0
	py = a * px
	a = py / px
	1 = c * 1 + d
	d = 1 - c
	py = c * px + d
	py = c * px + 1 - c
	py - 1 = c * (px - 1)
	c = (py - 1) / (px - 1)
]]
local function bend(p0x, p0y, p1x, p1y)
	return function(x, w)
		local px = p0x + (p1x - p0x) * w
		local py = p0y + (p1y - p0y) * w
		
		local a <const> = py / px
		local c <const> = (py - 1) / (px - 1)
		local d <const> = 1 - c
		
		if x < px then
			return x * a
		else
			return x * c + d
		end
	end
end


local function distort(wfunc, bfunc)
	return function(x, w)
		return wfunc(bfunc(x, w), w)
	end
end


local function split(funcA, funcB)
	return function(x, w)
		if x < 0.5 then
			return funcA(2 * x, w)
		else
			return funcB(2 * x - 1, w)
		end
	end
end


local function doublebend(funcA, funcB)
	return function(x, w)
		if x < 0.5 then
			return funcA(2 * x, w) / 2
		else
			return 0.5 + funcB(2 * x - 1, w) / 2
		end
	end
end


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


cz_saw1 =
	distort(
		wcos,
		bend(0.5, 0.5, 1.0, 0.5)
	)


cz_saw2 =
	distort(
		function(x) return 1 - wsin(x) end,
		doublebend(
			bend(0.5, 0.5, 0.0, 0.5),
			bend(0.5, 0.5, 1.0, 0.5)
		)
	)


cz_saw3 =
	distort(
		wtriangle,
		doublebend(
			bend(0.5, 0.5, 0.0, 0.5),
			bend(0.5, 0.5, 1.0, 0.5)
		)
	)


cz_saw4 =
	distort(
		wsaw,
		doublebend(
			bend(0.5, 0.5, 1.0, 0.0),
			bend(0.5, 0.5, 0.0, 1.0)
		)
	)


cz_square =
	distort(
		wcos, 
		doublebend(
			bend(0.5, 0.5, 1.0, 0.0),
			bend(0.5, 0.5, 1.0, 0.0)
		)
	)
	
	
cz_sawpulse =
	split(
		distort(
			wcos,	
			bend(0.5, 0.5, 0.0, 0.5)
		),
		distort(
			wcos,
			doublebend(
				bend(0.5, 0.5, 0.0, 1.0),
				bend(0.5, 0.5, 1.0, 0.0)
			)
		)
	)
	
	

:: src/sfx.lua
--[[pod_format="raw",created="2024-04-07 08:22:05",modified="2026-01-24 11:33:51",revision=7539]]
local sfx = {}


local sfx_index = 0x030000
local sfx_instr = 0x040000
local sfx_track = 0x050000
local sfx_wave = 0xf00000 -- maybe not? (search discord)


local num_instrument = 0
local num_tracks = 0
local num_patterns = 0
local header_flags = 0
local insts_addr = 0
local tracks_addr = 0
local patterns_addr = 0


function sfx.read_header()
	num_instruments = peek2(sfx_index)
	num_tracks = peek2(sfx_index + 2)
	num_patterns = peek2(sfx_index + 4)
	header_flags = peek2(sfx_index + 6)
	-- unused: peek2(sfx_index + 8)
	insts_addr = peek4(sfx_index + 10)
	tracks_addr = peek4(sfx_index + 14)
	patterns_addr = peek4(sfx_index + 18)
	?header_flags
	?string.format("%x", insts_addr)
	?string.format("%x", tracks_addr)
	?string.format("%x", patterns_addr)
end


function sfx.play_or_pause()
	-- is `stat(464)` enough?
	if stat(464) == 0 then
		music(0)
	else
		note()
	end
end


function sfx.channel_is_muted(pattern, channel)
	local channel_mutes = peek(0x30100 + (pattern * 20) + 9)
	local muted = (channel_mutes & (1 << channel)) == 0
	return muted
end


function sfx.mute_channel(pattern, channel, mute)
	local channel_mutes = peek(0x30100 + (pattern * 20) + 9)
	channel_mutes &= ~(1 << channel)
	channel_mutes |= (mute and 0 or 1) << channel
	poke(0x30100 + (pattern * 20) + 9, channel_mutes)
end


function sfx.pattern_track(pattern, channel)
	return peek(0x30100 + pattern * 20 + channel)
end


function sfx.track_speed(track)
	return peek(0x50000 + (track * 328) + 2)
end


function sfx.set_track_speed(track, val)
	return poke(0x50000 + (track * 328) + 2, val)
end


function sfx.track_loop0(track)
	return peek(0x50000 + (track * 328) + 3)
end


function sfx.set_track_loop0(track, val)
	return poke(0x50000 + (track * 328) + 3, val)
end


function sfx.track_loop1(track)
	return peek(0x50000 + (track * 328) + 4)
end


function sfx.set_track_loop1(track, val)
	return poke(0x50000 + (track * 328) + 4, val)
end


-- Track notes -----------------------------------------------------------------------------


function sfx.track_pitch(track, step)
	return peek(0x50000 + 8 + (track * 328) + step)
end


function sfx.set_track_pitch(track, step, v)
	return poke(0x50000 + 8 + (track * 328) + step, v)
end


function sfx.track_instrument(track, step)
	return peek(0x50000 + 8 + (track * 328) + step + 64)
end


function sfx.set_track_instrument(track, step, v)
	return poke(0x50000 + 8 + (track * 328) + step + 64, v)
end


function sfx.track_volume(track, step)
	return peek(0x50000 + 8 + (track * 328) + step + (2 * 64))
end


function sfx.set_track_volume(track, step, v)
	return poke(0x50000 + 8 + (track * 328) + step + (2 * 64), v)
end


function sfx.track_fx(track, step)
	return peek(0x50000 + 8 + (track * 328) + step + (3 * 64))
end


function sfx.set_track_fx(track, step, v)
	return poke(0x50000 + 8 + (track * 328) + step + (3 * 64), v)
end


function sfx.track_fx_params(track, step)
	return peek(0x50000 + 8 + (track * 328) + step + (4 * 64))
end


function sfx.track_fx_param0(track, step)
	return peek(0x50000 + 8 + (track * 328) + step + (4 * 64)) >> 4
end


function sfx.track_fx_param1(track, step)
	return peek(0x50000 + 8 + (track * 328) + step + (4 * 64)) & 0xf
end


function sfx.set_track_fx_params(track, step, v)
	return poke(0x50000 + 8 + (track * 328) + step + (4 * 64), v)
end


function sfx.set_track_fx_param0(track, step, v)
	local previous = peek(0x50000 + 8 + (track * 328) + step + (4 * 64))
	return poke(0x50000 + 8 + (track * 328) + step + (4 * 64), (previous & 0x0f) | (v << 4))
end


function sfx.set_track_fx_param1(track, step, v)
	local previous = peek(0x50000 + 8 + (track * 328) + step + (4 * 64))
	return poke(0x50000 + 8 + (track * 328) + step + (4 * 64), (previous & 0xf0) | (v & 0x0f))
end


-- Pattern flow flags -----------------------------------------------------------------------


function sfx.pattern_loop_start(pattern)
	return (peek(0x30100 + (pattern * 20) + 8) & 0x01) != 0
end


function sfx.set_pattern_loop_start(pattern, bool)
	local old = peek(0x30100 + (pattern * 20) + 8)
	if bool then
		poke(0x30100 + (pattern * 20) + 8, old | 0x01)
	else
		poke(0x30100 + (pattern * 20) + 8, old & (~ 0x01))
	end
end


function sfx.pattern_loop_end(pattern)
	return (peek(0x30100 + (pattern * 20) + 8) & 0x02) != 0
end


function sfx.set_pattern_loop_end(pattern, bool)
	local old = peek(0x30100 + (pattern * 20) + 8)
	if bool then
		poke(0x30100 + (pattern * 20) + 8, old | 0x02)
	else
		poke(0x30100 + (pattern * 20) + 8, old & (~ 0x02))
	end
end


function sfx.pattern_loop_stop(pattern)
	return (peek(0x30100 + (pattern * 20) + 8) & 0x04) != 0
end


function sfx.set_pattern_loop_stop(pattern, bool)
	local old = peek(0x30100 + (pattern * 20) + 8)
	if bool then
		poke(0x30100 + (pattern * 20) + 8, old | 0x04)
	else
		poke(0x30100 + (pattern * 20) + 8, old & (~ 0x04))
	end
end


-------------------------------------------------------------------------------------------------
---------------------------------- The Synth ----------------------------------------------------
-------------------------------------------------------------------------------------------------


-- Instruments --------------------------------------------------------------------------


function sfx.instrument_flag(instrument, flag)
	local inst_addr = 0x40000 + instrument * 0x200
	local addr = inst_addr + 0x1df
	return (peek(addr) & flag) > 0
end


function sfx.set_instrument_flag(instrument, flag, value)
	local inst_addr = 0x40000 + instrument * 0x200
	local addr = inst_addr + 0x1df
	local other_flags = peek(addr) & (~ flag)
	if value then
		poke(addr, other_flags | flag)
	else
		poke(addr, other_flags)
	end
end


function sfx.toggle_instrument_flag(instrument, flag)
	local inst_addr = 0x40000 + instrument * 0x200
	local addr = inst_addr + 0x1df
	local previous = peek(addr)
	poke(addr, previous ^^ flag)
end


-- Node tree ----------------------------------------------------------------------------


sfx.nodes = {}
for n = 0, 7 do
	sfx.nodes[n] = {
		parent = nil, -- id of the parent
		children = {}, -- list of direct references to the children
		type = nil,
	}
end
	

local function depth_walk(root, pre_fun, post_fun, depth)
	if (not depth) depth = 0
	if depth > 8 then
		-- TODO: remove notification
		notify("*** Deep recursion: cycle in synth nodes? ***")
		return
	end
	if (pre_fun) pre_fun(root)
	for i = 1, #root.children do
		local child = root.children[i]
		if child.type != 0 then
			depth_walk(child, pre_fun, post_fun, depth + 1)
		end
	end
	if (post_fun) post_fun(root)
end


function sfx.refresh_nodes(instrument)
	for n = 0, 7 do
		sfx.nodes[n].id = n
		sfx.nodes[n].children = {}
		sfx.nodes[n].older_sibling = nil
		sfx.nodes[n].height = nil -- TODO: or 0?
		sfx.nodes[n].position = nil
	end
	sfx.root = sfx.nodes[0]
	sfx.root.free_nodes = 7
	--- printh("* refresh *")
	for n = 0, 7 do
		local type = sfx.node_type(instrument, n)
		local op = sfx.node_op(instrument, n)
		local parent_id = sfx.node_parent(instrument, n)
		--- printh("" .. parent_id .. " -> " .. n .. " type=" .. type .. " op=" .. op)
		sfx.nodes[n].parent = sfx.nodes[parent_id]
		sfx.nodes[n].type = type
		sfx.nodes[n].op = op
		sfx.nodes[n].last_child = function(self)
			if (#self.children == 0) return self
			return self.children[#self.children]:last_child()
		end
		if type != 0 and n != 0 then
			add(sfx.nodes[n].parent.children, sfx.nodes[n])
			sfx.root.free_nodes -= 1
		end
	end
	
	depth_walk(
		sfx.root,
		nil,
		function(node)
			if #node.children == 0 then
				node.height = 1
			else
				local h = 0
				for i = 1, #node.children do
					local child = node.children[i]
					if i > 1 then
						child.older_sibling = node.children[i - 1]
					end
					h += child.height
				end
				node.height = h
			end
		end
	)

	sfx.root.position = { row = 0, column = 0 }
	depth_walk(
		sfx.root,
		function(node)
			local row = node.position.row
			for i = 1, #node.children do
				node.children[i].position = {
					column = node.position.column + 1,
					row = row,
				}
				row += node.children[i].height
			end
		end,
		nil
	)
end


function sfx.add_node(instrument, parent_id, node_type, node_op, target_id, child_id)
	local parent = sfx.nodes[parent_id]
	
	if (not parent) notify("invalid parent (nil)"); return
	if (parent.type >= 8) notify("invalid parent (filter)"); return

	if target_id >= 8 then
		-- no room!
		return
	end	

	sfx.insert_node(instrument, target_id, parent_id, child_id)
	
	if node_type == 0x2 and node_op == 1 then
		-- FM mod osc
		sfx.set_node_type(instrument, target_id, node_type)
		sfx.set_node_op(instrument, target_id, node_op)
		sfx.set_node_param_val1(instrument, target_id, 0, 0x20) -- volume
		sfx.set_node_param_flags(instrument, target_id, 2, 0x02) -- not quantized, and relation + for tune
		sfx.set_node_param_flags(instrument, target_id, 3, 0x01) -- relation + for bend
	elseif node_type == 0x2 and node_op == 2 then
		-- Ring mod osc
		sfx.set_node_type(instrument, target_id, node_type)
		sfx.set_node_op(instrument, target_id, node_op)
		sfx.set_node_param_val1(instrument, target_id, 0, 0x20) -- volume
		sfx.set_node_param_flags(instrument, target_id, 2, 0x01) -- not quantized, and relation + for tune
		sfx.set_node_param_flags(instrument, target_id, 3, 0x01) -- relation + for bend
	elseif node_type == 0x2 then
		-- Osc
		sfx.set_node_type(instrument, target_id, node_type)
		sfx.set_node_op(instrument, target_id, node_op)
		sfx.set_node_param_val1(instrument, target_id, 0, 0x20) -- volume
		sfx.set_node_param_flags(instrument, target_id, 0, 0x02) -- relation * for volume
		sfx.set_node_param_flags(instrument, target_id, 1, 0x01) -- relation + for pan
		sfx.set_node_param_flags(instrument, target_id, 2, 0x21) -- quantized, and relation + for tune
		sfx.set_node_param_flags(instrument, target_id, 3, 0x01) -- relation + for bend
	elseif node_type == 0xa then
		sfx.set_node_type(instrument, target_id, node_type)
		sfx.set_node_param_val1(instrument, target_id, 3, 0x40) -- mix
	else
		sfx.set_node_type(instrument, target_id, node_type)
	end
	return target_id
end


-- Node configuration ------------------------------------------------------------------------


function sfx.delete_node(instrument, node_id)
	local deleted_node_parent = sfx.node_parent(instrument, node_id)
	local inst_addr = 0x40000 + instrument * 0x200
	-- move everything up
	for j = node_id, 7 do
		memcpy(inst_addr + j * 0x20, inst_addr + (j + 1) * 0x20, 0x20)
	end
	memset(inst_addr + 7 * 0x20, 0, 0x20)
	-- fix parents
	for j = 0, 6 do
		local parent = sfx.node_parent(instrument, j)
		if parent == node_id then
			sfx._set_node_parent(instrument, j, deleted_node_parent)
		elseif parent > node_id then
			sfx._set_node_parent(instrument, j, parent - 1)
		end
	end
end


function sfx.insert_node(instrument, node_id, parent_id, child_id)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node_id * 0x20
	-- move everything down
	for j = 7, node_id + 1, -1 do
		memcpy(inst_addr + j * 0x20, inst_addr + ( j - 1) * 0x20, 0x20)
	end
	memset(node_addr, 0, 0x20)
	-- fix parents
	poke(node_addr, parent_id)
	for j = 0, 7 do
		local parent = sfx.node_parent(instrument, j)
		if parent >= node_id then
			sfx._set_node_parent(instrument, j, parent + 1)
		end
	end
	if child_id then
		if child_id >= node_id then
			child_id += 1
		end
		if child_id <= 7 then
			sfx._set_node_parent(instrument, child_id, node_id)
		end
	end
end


function sfx.node_parent(instrument, node)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr + 0) & 0x7	
end

function sfx._set_node_parent(instrument, node, parent)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	local previous = peek(node_addr + 0)
	poke(node_addr + 0, (previous & ~0x7) | (parent & 0x7))
end

function sfx.node_op(instrument, node)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr) >> 4
end

function sfx.set_node_op(instrument, node, op)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	local previous = peek(node_addr)
	poke(node_addr, (previous & 0x0f) | (op << 4))
end

function sfx.node_type(instrument, node)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr + 1) & 0xf
end

function sfx.set_node_type(instrument, node, type)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	local previous = peek(node_addr + 1)
	poke(node_addr + 1, (previous & 0xf0) | (type & 0x0f))
end

function sfx.node_osc_wavetable(instrument, node)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr + 1) >> 4
end

function sfx.set_node_osc_wavetable(instrument, node, wt)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	local previous = peek(node_addr + 1)
	poke(node_addr + 1, (previous & 0x0f) | (wt << 4))
end

function sfx.node_flags(instrument, node)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr + 2)
end

function sfx.set_node_flags(instrument, node, flags)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 2, flags)
end

-- node_addr + 3 is unused

-- 0 <= p <= 7
function sfx.node_param(instrument, node, p)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	local flags,val1,val0,env = peek(node_addr + 4 + (4 * p), 4)
	return flags, val1, val0, env
end

function sfx.set_node_param_flags(instrument, node, p, flags)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 4 + (4 * p), flags)
end

function sfx.set_node_param_val1(instrument, node, p, val1)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 4 + (4 * p) + 1, val1)
end

function sfx.set_node_param_val0(instrument, node, p, val0)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 4 + (4 * p) + 2, val0)
end

function sfx.set_node_param_env(instrument, node, p, env)
	local inst_addr = 0x40000 + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 4 + (4 * p) + 3, env)
end

function sfx.node_wavetable_info(instrument, node)
	local inst_addr = 0x40000 + instrument * 0x200
	local wt_4defs_addr = inst_addr + 0x1e0 -- start of the 4 wt definitions
	local node_addr = inst_addr + node * 0x20
	local wt_index = (peek(node_addr+1)>>4)
	local wt_def_addr = wt_4defs_addr + wt_index * 4
	local addr0, addr1, width_bits, wt_height = peek(wt_def_addr,4)
	local dat_addr = (addr0 << 8) | (addr1 << 16)
	local wt_width = 1 << width_bits
	return dat_addr, wt_width, wt_height
end


-- Envelopes ---------------------------------------------------------------------------------


function sfx.env_type(instrument, env)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr)
end


function sfx.set_env_type(instrument, env, type)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr, type)
end


function sfx.env_flags(instrument, env)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 1)
end


function sfx.set_env_flags(instrument, env, flags)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 1, flags)
end


function sfx.env_speed(instrument, env)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 2)
end


function sfx.set_env_speed(instrument, env, val)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 2, val)
end


function sfx.env_loop0(instrument, env)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 3)
end


function sfx.set_env_loop0(instrument, env, val)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 3, val)
end


function sfx.env_loop1(instrument, env)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 4)
end


function sfx.set_env_loop1(instrument, env, val)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 4, val)
end


function sfx.env_start(instrument, env)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 5)
end


function sfx.set_env_start(instrument, env, val)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 5, val)
end


function sfx.env_param(instrument, env, param)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 8 + param)
end


function sfx.set_env_param(instrument, env, param, val)
	local inst_addr = 0x40000 + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 8 + param, val)
end


return sfx
:: src/wavetable.lua
--[[pod_format="raw",created="2026-01-23 13:43:16",modified="2026-01-24 11:33:51",revision=773]]
Wavetable = structure {
	-- width: Int -- number of samples in a wave
	-- height: Int -- number of waves in the wavetable
	-- samples: Array[Int]
}


function Wavetable.new(width, height)
	local samples = {}
	for i = 0, width * height do
		samples[i] = 0.0
	end
	return Wavetable {
		width = width,
		height = height,
		samples = samples,
	}
end


function Wavetable:get(wave, sample)
	assert(0 <= wave and wave <= self.height) -- TODO: should be < height?
	assert(0 <= sample and sample <= self.width) -- TODO: should be < width?
	return self.samples[wave * self.width + sample] or 0.0
end


function Wavetable:set(wave, sample, value)
	assert(0 <= wave and wave <= self.height) -- TODO: should be < height?
	assert(0 <= sample and sample <= self.width) -- TODO: should be < width?
	assert(-1.0 <= value and value <= 1.0)
	self.samples[wave * self.width + sample] = value
end


function Wavetable:set_wave(wave, func)
	local start = wave * self.width
	local length <const> = self.width
	for i = 0, self.width - 1 do
		local value = func(i / length)
		self.samples[start + i] = value
	end
end


function Wavetable:set_double_wave(wave, func1, func2)
	local start = wave * self.width
	local length <const> = self.width // 2
	for i = 0, length - 1 do
		local value = func1(i / length)
		self.samples[start + i] = value
	end
	for i = 0, length - 1 do
		local value = func2(i / length)
		self.samples[start + length + i] = value
	end
end


function Wavetable:set_wavetable(func)
	for wave = 0, self.height do
		local w = wave / self.height
		local wavefunc = function(x) return func(x, w) end
		self:set_wave(wave, wavefunc)
	end
end

:: .info.pod
--[[pod,created="2026-01-15 17:19:56",modified="2026-01-24 11:33:51",runtime=24,workspaces={{location="main.lua",workspace_index=1},{location="gfx/0.gfx",workspace_index=2},{location="map/0.map",workspace_index=3},{location="sfx/0.sfx",workspace_index=4}}]]
:: gfx/.info.pod
--[[pod,created="2026-01-15 17:19:56",modified="2026-01-24 11:33:51"]]
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAxLTE3IDEwOjM1OjQ4Iixtb2RpZmllZD0iMjAyNS0w
MS0xNyAxMDozNzo0NCIscmV2aXNpb249Ml1dbHo0AH4AAAASMQAA8yF7WzBdPXtibXA9cHh1AEMg
EBAE8FYHEAfAF9AXwAcQB-BWLGZsYWdzPTAscGFuX3gIAMt5PTAsem9vbT04fSw_AB-wMQD-----
-----------------------------------------------------------XUG09OH19
:: map/.info.pod
--[[pod,created="2026-01-15 17:19:56",modified="2026-01-24 11:33:51"]]
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAxLTE3IDEwOjM1OjQ4Iixtb2RpZmllZD0iMjAyNi0w
MS0yMyAxMzozODoxOSIscmV2aXNpb249Ml1dbHo0AEwAAABQAAAA8Rx7e2JtcD1weHUATIAgIAD-
AAD---8DLGhpZGRlbj1mYWxzZSxwYW5feD0wCADSeT0wLHRpbGVfaD0xNgoAEHcKAIB6b29tPTF9
fQ==
:: sfx/.info.pod
--[[pod,created="2026-01-15 17:19:56",modified="2026-01-24 11:33:51"]]
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA3LTMxIDA4OjMwOjI4Iixtb2RpZmllZD0iMjAyNi0w
MS0yNCAwOTo1MjoxNSIscmV2aXNpb249OF1dbHo0ALoAAAAaCgAA-zBweHUAAygAAAQABA9AEAIO
AAGgASACoA4ADxAADfDKAQIDQA8PkAQFBgdADJAICQoLQAyQDwwPDQ8ODEAM8P8BAOv8NqoBEAYP
MBABIAEgAfAAAhACDhABIA8gBhABMA8-kAEKIA82IA9-IA9YIAHwpw8oD--wxg-4Cg--D4AP9w8N
AfAJARAGDj8AjyEgATAPQPDDMAD------6Uf-wEArM-ID0AADxBA--_w8P8BAP-qUP----8p
:: sfx/1.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI2LTAxLTIzIDE0OjM4OjIyIixtb2RpZmllZD0iMjAyNi0w
MS0yNCAwOTo1MTozNyIscmV2aXNpb249N11dbHo0AAYBAADbFwAA-zBweHUAAygAAAQABA9AEAIO
AAGgASACoA4ADxAADfDKAQIDQA8PkAQFBgdADJAICQoLQAyQDwwPDQ8ODEAM8P8BAOv-YqoBEAYP
IBABIAEgAfAAAhACDhABIA8hIAEgBA_CD2wADxAPPWAJ8A8KIA_XIA9BIA_3IAzwhw8oD--AAhAI
DxwEEA--D9IPpg_GD3MPZg9TD0YPOQ8zDy0eLxrwnwIAD-gKD-8PgA-3Dw0B8AkBEAYOawAAUDAP
QPDDUwAv8MYwAP------nx--AQCs8gbID0AADxBADyb--y8A-S8PI-0v8HAUAC-9sAoA--------
------------fFD9sPD-OQ==
:: src/.info.pod
--[[pod,created="2026-01-23 13:39:49",modified="2026-01-24 11:33:51"]]
:: [eoc]
