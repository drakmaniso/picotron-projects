picotron cartridge // www.picotron.net
version 2

:: fonts/
:: gfx/
:: map/
:: pal/
:: sfx/
:: src/
:: src/sfx/
:: src/ui/
:: src/wavetables/
:: changelog.txt
--[[pod_format="raw",created="2026-01-31 19:58:41",icon=userdata("u8",16,16,"00000101010101010101010101000000000104040404040404040404040100000107010404040404040404040404010000010104040404040404040404040100000104040404040404040404040401000107010404040404040404040404010000010104040404040404040404040100000104040404040404040404040401000107010404040404040404040404010000010104040404040404040404040100000104040404040404040404040401000107010404040404040404040401010000010101010101010101010101070100000101070707070707070707070401000000010404040404040404040401000000000001010101010101010101000000"),modified="2026-02-16 14:12:04",revision=14214]]
Version 0.2.1, aka #wavemaker-???:

- Fixed: the number of patterns is now 128 like in the default tracker; this
  is hardcoded for now, since the info stored in sfx files is wrong (says 64).
- Fixed: the maximum number of tracks is now 255; the default tracker is
  supposed to support 384 tracks, only actually support 256, since there is
  only 1 byte reserved for track IDs in the file format... Also, the info
  stored in sfx files is wrong (says 512).
- Fixed: the modulation target of reversed knobs (filter LP and shaper cut) was
  not reversed.

Version 0.2.0, aka #wavemaker-7:

- Added: scrollbar for the tracker; it also shows the position of bar divisions
  and of the current selection.
- Changed: the DELETE key now doesn't jump to next row; use the "'" (single
  quote) key to delete and jump (aka rest).
- Changed: replaced the "create new track" dialog with a more comprehensive
  channel dialog, with allows to mute the current track, clone it, create a
  new empty track, or pick an existing one. The dialog is accessed by clicking
  on the channel header.
- Added: oscilloscope for the synth nodes.
- Changed: all the oscilloscopes are now synced on zero-crossings (thanks to
  abledbody on discord for the suggestion).
- Added: right-click a channel header to mute it.
- Added: double-click a channel header to enter a track number manually.
- Added: visualization for the shaper and the echo effects.
- Changed: a lot or UI polishing, especially in the synth part.
- Fixed: when music stopped playing by reaching the stop marker, the "follow
  played" status was not reset.

Version 0.1.1, aka #wavemaker-6:

- Fixed: opening the new track dialog was resetting the speed of whichever track
  was on this channel (thanks to cheez_itz_12oz on the discord for the bug
  report).

Version 0.1.0, aka #wavemaker-5:

- Added: level meter (in the panel), showing the level in dB of the audio output.
- Added: "+" button at the bottom of muted channels, to initialize a new track
  and assign it to the channel.
- Added: direct access to various tools at the bottom of the screen.
- Added: "pattern" tool, to view and reorder (via drag and drop) patterns.
- Added: "channels" tool, to quickly assign tracks to channels.
- Added: "loops" tool, to quickly change the loop boundaries of all channels.
- Added: "speeds" tool, to quickly change the speed of all channels.
- Added: "levels" tool, with an oscilloscope and a level meter for each channel.
- Changed: track headers are simplified; click to mute/unmute, right-click to
  change the track (or better, use the new "channels" tool).
- Changed: instruments have the "retrigger" flag on by default.
- Fixed: entering a one digit value + ENTER was editing the wrong rows. (thanks
  to cheez_itz_12oz on the discord for the bug report)

Version 0.0.7, aka #wavemaker-4:

- Added: crash protection mechanism: if the application crashes, a copy of
  the current file is saved with the suffix ".CRASH.sfx"
- Added: "enter" key to preview the note under the cursor and move to next
  step; also works with single-row selections, to preview chords.
- Added: shift+enter/delete/backspace to perform the corresponding action
  but with inserting or removing rows instead of overwriting.
- Added: key = (equal) to repeat the last entered value on instr, vol, and fx.
- Added: ctrl+E and ctrl+D to increase/decrase the selected part(s).
- Added: key ' (single quote) to enter a rest (same as delete).
- Added: shift+key to enter sustained notes with "retrigger" instruments
  (i.e. to enter only the pitch).
- Added: shift+digit to enter instrument with a single keystroke (first 16
  instruments only).
- Added: shift+digit to enter volume with a single keystroke (1 -> 08,
  9 -> 48, ... f -> 78).
- Added: right-click to move selection without collapsing it.
- Added: double-click to select a row, triple-click to select a beat,
  quadruple-click to select a column.
- Added: when playing a notes on the keyboard, its name is displayed (in place
  of the octave selector).
- Added: new isomorphic layout for playing notes on the keyboard, with a
  major third interval between rows.
- Added: configuration of the bar length and beat length in the track dialog.
- Changed: jump step now takes into account the selection length; makes it easy
  to enter a succession of sustained notes.
- Changed: continuation lines (on sustained notes) now take into account the
  retrigger flag of the instrument.
- Changed: continuation lines now take into account the cut and retrigger fx.
- Fixed: wrong value when entering only params in fx.
- Fixed: the cursor could sometimes leave the screen.
- Fixed: a crash when opening the settings dialog (a regression).

Version 0.0.6, aka #wavemaker-3:

- Fixed: crash when copying (a regression; thanks to Thelxinoe5 for the
  report).

Version 0.0.5, aka #wavemaker-2:

- Fixed: crash when clicking on empty and muted track, or muting a track
  containing the cursor (thanks to cheez_itz_12oz on the discord for the report).
- Added: colored border around the note editor in recording mode, for better
  awareness.

:: lune.lua
--[[pod_format="raw",created="2025-03-19 09:08:58",modified="2026-02-16 14:12:04",revision=26982]]
----------------------------------------------------------------------------------------------------
-- Logging and Errors
----------------------------------------------------------------------------------------------------


is_loaded_cart =
	env().argv[0] == "/ram/cart/main.lua"
	or env().argv[0] == "/system/apps/terminal.lua"


if is_loaded_cart then
	function log(str)
		local path = debug.getinfo(2).source
		if path[1] == "@" then path = path:sub(2, -1) end
		local line = debug.getinfo(2).currentline
		printh(path .. ":" .. line .. ": " .. (str or ""))
	end
else
	function log(_str) end
end


function error(msg, level, title)
	level = (level or 1) + 1
	-- TODO: check if debug.getinfo(level)
	local path = debug.getinfo(level).source
	local line = debug.getinfo(level).currentline
	local str = sub(path, 2) .. ":" .. string.format("%d", line) .. ": " .. msg
	send_message(3, { event = "report_error", content = "*" .. (title or "error") })
	send_message(3, { event = "report_error", content = str })
	send_message(3, { event = "report_error", content = debug.traceback("", level) })
end


function panic(msg, level, title)
	level = (level or 1) + 1
	error(msg, level, title or "panic")
	stop()
end


----------------------------------------------------------------------------------------------------
-- Require
----------------------------------------------------------------------------------------------------


_modules = {}


-- A 'require' function similar to standard Lua.
-- Idea from elgopher on the BBS
function require(name)
	if (_modules == nil) _modules = {}

	local cached = _modules[name]
	if (cached) return cached

	local filename = fullpath(name)
	local src = fetch(filename)
	if (type(src) != "string") panic("could not include " .. filename, 2)

	-- https://www.lua.org/manual/5.4/manual.html#pdf-load
	-- chunk name (for error reporting)
	-- mode ("t" for text only -- no binary chunk loading)
	-- _ENV upvalue
	-- @ is a special character that tells debugger the string is a filename
	local func, err = load(src, "@" .. filename, "t", _ENV)
	if (not func) panic("\n"..tostr(err), 2, "Syntax error:")

	local module = func()
	_modules[name] = module

	return module
end


----------------------------------------------------------------------------------------------------
-- Structure
----------------------------------------------------------------------------------------------------


function structure(meta)
	meta.__index = meta
	meta.type = meta
	setmetatable(
		meta,
		{
			__call =
				function(mt, instance)
					setmetatable(instance, mt)
					return instance
				end,
		}
	)
	return meta
end

:: main.lua
--[[pod_format="raw",created="2024-03-24 00:48:06",modified="2026-02-16 14:12:04",revision=35446]]
include "lune.lua"
include "src/waves.lua"
local app = require "src/app.lua"
local sfx = require "src/sfx/sfx.lua"
local file = require "src/file.lua"
local selection = require "src/selection.lua"
local settings = require "src/settings.lua"
local undo = require "src/undo.lua"
local ui = require "src/ui/ui.lua"
local ui_help = require "src/ui/help.lua"
local ui_routing = require "src/ui/routing.lua"
local ui_settings = require "src/ui/settings.lua"
local ui_synth = require "src/ui/synth.lua"
local ui_tracker = require "src/ui/tracker.lua"
local ui_visual = require "src/ui/visual.lua"


local tracker = nil


function call_protected(func)
	if is_loaded_cart then
		func()
	else
		local function err_handler(err)
			return err .. "\n" .. debug.traceback("", 0)
		end
		local ok, err = pcall(func, err_handler)
		if not ok then
			-- Save the crashed file
			local ud = userdata("u8", 0x40000)
			for i=0,0x3f do
				set(ud, i * 0x1000, peek(0x30000 + i * 0x1000, 0x1000))
			end
			local crashloc = pwf()
			if type(crashloc) ~= "string" then
				crashloc = env().argv[1]
			end
			if type(crashloc) ~= "string" then
				crashloc = "/ram/cart/sfx/0.sfx"
			end
			if crashloc:sub(-4, -1) == ".sfx" then
				crashloc = crashloc:sub(1, -5)
			end
			store(crashloc .. ".CRASH.sfx", ud)
			store(crashloc .. ".CRASH.txt", type(err) == "string" and err or pod(err))
			-- Report the error
			if type(err) == "string" then
				send_message(3, { event = "report_error", content = "*runtime error"})
				for s in err:gmatch("[^\n]+") do
					send_message(3, { event = "report_error", content = s })
				end
			else
				send_message(3, { event = "report_error", content = "*unknown runtime error"})
				send_message(3, { event = "report_error", content = pod(err) })
			end
		end
	end
end



function _init()
	log("-------------------------------------------------------------------------------")
	log("                                 WaveMaker")
	log("-------------------------------------------------------------------------------")
	log("Path: " .. pod(env().argv[0]))
	log("Opening: " .. pod(env().argv[1]))

	window {
		tabbed = true,
		-- capture_escapes = true, -- (done in tracker's update)
		icon = --[[pod_type="gfx"]]unpod("b64:bHo0AB4AAAAcAAAA8A1weHUAQyAICAQwB2AXUAcAB0AHAAcgJzA3QBew")
	}

	wrangle_working_file {
		save_state = file.save,
		load_state = file.load,
		untitled_filename = 
			is_loaded_cart and "/test/sfx/test.sfx" or "/ram/cart/sfx/sfx.0",
		--[[
		-- TODO: Not until I am 100% sure everything has undo checkpoints
		state_hint =
			function()
				return undo_stack and #undo_stack.undo_stack
			end
		--]]
	}
		
	on_event("drop_items", file.handle_drop_items)
	on_event("resize", function(msg) app.refresh_gui = true end)
	on_event("gained_focus", function(msg) app.window_focused = true end)
	on_event("lost_focus", function(msg) app.window_focused = false end)

--	menuitem() -- TODO: custrom open/save menu entries
	
	menuitem {
		id = "export",
		label = "\^:0000000000000000 Export Instruments",
		action =
			function()
				ui.chooser (
					{
						path = "/ram/cart/sfx/",
						intention = "select_file",
						title = "Export Instruments",
						prompt = "Export into:",
						verb = "Export",
						workspace = "current",
					},
					function(msg)
						file.export_into(msg.filename)
					end
				)
			end,
	}	
	menuitem { divider = true, id = "settings_divider", label = "" }
	menuitem {
		id = "settings",
		label = "\^:0000000000000000 Settings",
		action = function() ui_settings.open() end,
	}
	menuitem {
		id = "help",
		label = "\^:0000000000000000 Help",
		action = function() ui_help.open() end,
	}
		
	settings.load()
	
	--poke(0x4000, get(fetch("fonts/p8_mod.font")))
	fetch("fonts/p8_mod.font"):poke(0x4000)
	fetch("fonts/cozi.font"):poke(0x5600)
	
	poke4(0x5000, get(fetch("pal/0.pal")))
	
	for i = 0, 255 do
		local sprite = userdata("u8", 7, 5)
		set_draw_target(sprite)
		print(string.format("%02x", i), 0, 0, 7)
		set_spr(256 + i, sprite)
	end
	set_draw_target()
	
	--app.node = nil
	music(-1)
	selection.set(0, 0, selection.note)
	undo.init()
end


local previously_focused = nil


function _update()
	call_protected(
		function()
			-- Keyboard Focus
			local currently_focused = ui.head() and ui.head():get_keyboard_focus_element()
			if currently_focused ~= previously_focused then
				ui_visual.close()
			end
			previously_focused = currently_focused
			-- GUI Refresh
			if app.refresh_gui then
				generate_gui()
				app.refresh_gui = false
			end
			-- GUI Update
			ui.head():update_all()
			-- Keys
			if key("ctrl") then
				if keyp("z") then
					if key("shift") then
						undo.redo()
					else
						undo.undo()
					end
				end
				if keyp("y") then
					undo.redo()
				end
			end
		end
	)
end


local fpses = { [0] = 0, 0, 0, 0, 0, 0, 0, 0}
local fps_idx = 0
function _draw()
	call_protected(
		function()
			ui.head():draw_all()
			if app.view == "tracker" and app.is_editing then
				local width = get_display():width() - app.panel_width - 4
				local height = get_display():height() - 9 - 8
				if tracker and tracker.notegrids and tracker.notegrids[1] then
					height = tracker.notegrids[1].height
				end
				rrect(
					app.panel_width, 9, 
					width, height, 
					0, 36
				)
			end
			-- Show FPS when in dev
			if is_loaded_cart then
				fpses[fps_idx] = stat(1)
				fps_idx = (fps_idx + 1) % 8
				local fps = 0
				for v in all(fpses) do
					fps = max(fps, v)
				end
				fps = flr(0.5 + fps * 100.0)
				local y = app.view == "tracker" and 2 or 250
				print(string.format("%3.0f%%", fps), 463, y, 58)		
			end
		end
	)
end


function generate_gui()
	ui.create_head()
	local width <const> = get_display():width()
	local height <const> = get_display():height()
	if app.view == "tracker" then
		tracker = ui_tracker.attach(ui.head(), { x = 0, y = 0, width = width, height = height })
	elseif app.view == "synth" then
		ui_synth.attach(ui.head(), { x = 0, y = 0, width = width, height = height })
	end
end

:: manual.txt
--[[pod_format="raw",created="2024-04-14 09:49:39",icon=userdata("u8",16,16,"000001010101010101010101010000000001040404040404040404040401000001070104040404040404040404040100000101040404040f0f0f0404040401000001040404040f0f040f0f04040401000107010404040404040f0f040404010000010104040404040f0f040404040100000104040404040f0f0404040404010001070104040404040404040404040100000101040404040f0f04040404040100000104040404040404040404040401000107010404040404040404040401010000010101010101010101010101070100000101070707070707070707070401000000010404040404040404040401000000000001010101010101010101000000"),modified="2026-02-16 14:12:04",revision=25194]]
# WaveMaker

WaveMaker is an alternative to Picotron's default
tracker.

## Tracker

### Overview

The tracker has two modes: "playing" and "recording".
Switch between the two by hitting TAB, or clicking
the record button. Use the first mode to explore
melodies on the keyboard, and the second to enter
the notes in the track.

An important difference with the default tracker is
that parameters for the instrument, volume and fx
each have a single column. When the cursor is on one
of them, you have to type two digits (or a letter and
two digits for fx) to validate the entry and move to
the next row.

### Selections and Multi-Cursors

The way selection work is somewhat unconventional:
you can move the selections around with the arrow
keys, and if you type a note or a value for a
parameter, it will be entered in every selected row.

In other words, the selection behaves like a cursor.

You can double-click to select a row (i.e. the note
with its instrument, volume and fx), triple-click to
select a beat, and quadruple-click to select a
column. You can also do "sparse" selections using the
CTRL key, i.e. to select rows that are not contiguous.

Two important shortcuts are CTRL-E and CTRL-D,
which are used to increase the selected value(s). For
notes they will raise or lower the octave, for
instruments they will go to the next or previous one,
for volume they will increase or decrease it by step
of 8. If several parts are selected, only the
left-most part is affected.

### Jump Step

The jump step specifies how much the cursor move
after entering a note. It is displayed in the right
panel, under the default note volume.

The current selection also influences the distance
moved after entering a note: if multiple rows are
selected, the cursors will move down by the same
amount. This makes it easy to enter a succession
of long notes.

Most editing keys use the jump step when they move
around the cursor. The only exception are the keys
"Up" and "Down", which always move by a single row.

### Keybindings

```
	*** Edition ***
	 
	Tab: toggle recording on/off
	 
	Space: play from current pattern
	S-Space: play and follow playhead
	 
	S-Enter: insert rows
	 
	Backspace: jump upward and clear selected parts
	C-Backspace: jump upward and clear selected rows
	S-Backspace: remove selected rows
	
	Delete: clear selected parts
	C-Delete: clear selected rows
	S-Delete: remove selected rows
	
	': rest (clear selected parts and jump down)
	C-': rest (clear selected rows and jump down)
	 
	=: repeat last entered value
	
	C-E: Increase part(s) under cursor
	C-D: Decrease part(s) under cursor
	
	*** Movement ***
	 
	Left: move to previous part
	Right: move to next part
	 
	C-Left: move to previous channel
	C-Right: move to next channel

	Down: move to next row
	Up: move to previous row

	Enter: play current note and jump to next row
	C-Enter: play current note (without moving)
	 
	C-Down: move to next beat
	C-Up: move to previous beat
	 
	PageDown: move to next bar
	PageUp: move to previous bar
	 
	C-PageDown: move to next pattern (not yet implemented)
	C-PageUp: move to previous pattern (not yet implemented)
	 
	Home: move to start of current bar (or previous)
	End: move to the start of next bar
	 
	C-Home: move to start of the track (not yet implemented)
	C-End: move to end of the track (not yet implemented)

	*** Default Note and Jump Step ***
	
	A-O: enter default octave
	A-I: enter default instrument
	A-V: enter default volume
	A-J: enter jump step
	Insert: set jump step to 0 (toggle)
```

## Synth
...

:: src/actions.lua
--[[pod_format="raw",created="2026-02-04 10:08:37",modified="2026-02-16 14:12:04",revision=12111]]
local app = require "src/app.lua"
local selection = require "src/selection.lua"
local sfx = require "src/sfx/sfx.lua"
local undo = require "src/undo.lua"


local actions = {}

--[[
This module contains all the functions available for keybindings,
and only them.
--]]


-------------------------------------------------------------------------------
-- Locals
-------------------------------------------------------------------------------


local function clear_steps(track, step)
	sfx.set_track_row(track, step, sfx.empty_row())
end


local function clear_parts(track, step)
	if selection.has_part(selection.note) then
		sfx.set_track_pitch(track, step, 0xff)
	end
	if selection.has_part(selection.instrument) then
		sfx.set_track_instrument(track, step, 0xff)
	end
	if selection.has_part(selection.volume) then
		sfx.set_track_volume(track, step, 0xff)
	end
	if selection.has_part(selection.fx) then
		sfx.set_track_fx(track, step, 0x00)
		sfx.set_track_fx_params(track, step, 0x00)
	end
end


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

	
local function remove_steps(step, count)
	selection.for_each_channel(
		function(channel, track)
			local last = sfx.track_size(app.pattern, track) - 1
			for dest = step, last - count do
				local src = dest + count
				if src <= last then
					local row = sfx.track_row(track, src)
					sfx.set_track_row(track, dest, row)
				end
			end
			for s = last - count + 1, last do
				clear_steps(track, s)
			end
		end
	)
end


local function remove_selected_steps()
	selection.for_each_channel(
		function(channel, track)
			local size = sfx.track_size(app.pattern, track)
			local dest = 0
			for src = 0, size - 1 do
				if not selection.has_step(src) then
					local row = sfx.track_row(track, src)
					sfx.set_track_row(track, dest, row)
					dest += 1
				end
			end
			for step = dest, size - 1 do
				clear_steps(track, step)
			end
		end
	)
end


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


local function insert_steps(step, count)
	selection.for_each_channel(
		function(channel, track)
			local last = sfx.track_size(app.pattern, track) - 1
			for dest = last, step + count, -1 do
				local src = dest - count
				local row = sfx.track_row(track, src)
				sfx.set_track_row(track, dest, row)
			end
			for s = step, step + count - 1 do
				clear_steps(track, s)
			end
		end
	)
end


-------------------------------------------------------------------------------
-- Context
-------------------------------------------------------------------------------


function actions.play_or_pause(tracker)
	tracker:clear_edit()
	app.play_or_pause(nil)
end


function actions.follow_play_or_pause(tracker)
	tracker:clear_edit()
	app.play_or_pause("follow_playhead")
end


function actions.toggle_record_mode(tracker)
	tracker:clear_edit()
	app.is_editing = not app.is_editing
	if app.is_editing and sfx.music_is_playing() and app.follow_playhead then
		app.play_or_pause()
	end
end


function actions.toggle_jump_step(tracker)
	readtext(true)
	if app.jump_step == 0 and app.saved_jump_step then
		app.jump_step = app.saved_jump_step
	else
		app.saved_jump_step = app.jump_step
		app.jump_step = 0
	end
end


-------------------------------------------------------------------------------
-- Movement
-------------------------------------------------------------------------------


function actions.move_down(tracker)
	tracker:clear_edit()
	local moved = selection.move_step(1)
	if not moved then
		local min_step = selection.min_step()
		selection.move_step(0 - min_step)
	end
	tracker:show_cursor()
end


function actions.move_up(tracker)
	tracker:clear_edit()
	local moved = selection.move_step(-1)
	if not moved then
		local min_step = selection.min_step()
		local channel = selection.min_channel()
		local track = sfx.pattern_track(app.pattern, channel)
		local size = sfx.track_size(track)
		selection.move_step((size - 1) - min_step)
	end
	tracker:show_cursor()
end


function actions.move_to_next_beat(tracker)
	tracker:clear_edit()
	local moved = selection.move_step(app.beat_length)
	if not moved then
		local min_step = selection.min_step()
		local target = min_step % app.beat_length
		selection.move_step(target - min_step)
	end
	tracker:show_cursor()
end


function actions.move_to_previous_beat(tracker)
	tracker:clear_edit()
	local moved = selection.move_step(-1 * app.beat_length)
	if not moved then
		local min_step = selection.min_step()
		local channel = selection.min_channel()
		local track = sfx.pattern_track(app.pattern, channel)
		local size = sfx.track_size(track)
		local target = min_step
		while target + app.beat_length < size do
			target += app.beat_length
		end
		selection.move_step(target - min_step)
	end
	tracker:show_cursor()
end


function actions.move_to_next_bar(tracker)
	tracker:clear_edit()
	local moved = selection.move_step(1 * app.bar_length)
	if not moved then
		local min_step = selection.min_step()
		local target = min_step % app.bar_length
		selection.move_step(target - min_step)
	end
	tracker:show_cursor()
end


function actions.move_to_previous_bar(tracker)
	tracker:clear_edit()
	local moved = selection.move_step(-1 * app.bar_length)
	if not moved then
		local min_step = selection.min_step()
		local channel = selection.min_channel()
		local track = sfx.pattern_track(app.pattern, channel)
		local size = sfx.track_size(track)
		local target = min_step
		while target + app.bar_length < size do
			target += app.bar_length
		end
		selection.move_step(target - min_step)
	end
	tracker:show_cursor()
end

	
function actions.home(tracker)
	readtext(true)
	local step = selection.min_step()
	local channel = selection.min_channel()
	local bar_length = app.bar_length
	local target
	if step % bar_length == 0 then
		target = max(step - bar_length, 0)
	else
		target = (step // bar_length) * bar_length
	end
	if key("shift") then
		-- TODO: not yet implemented
		return
	end
	selection.move_step(target - step)
	tracker:show_cursor()
end


function actions.fin(tracker)
	readtext(true)
	local step = selection.min_step()
	local channel = selection.min_channel()
	local size = sfx.track_size(sfx.pattern_track(app.pattern, channel))
	local bar_length = app.bar_length
	local target
	if step % bar_length == 0 then
		target = min(step + bar_length, size - 1)
	else
		target = (step // bar_length) * bar_length + bar_length
	end
	if key("shift") then
		-- TODO: not yet implemented
		return
	end
	selection.move_step(target - step)
	tracker:show_cursor()
end

	
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


local function preview(tracker, jump)
	if tracker.str_instrument or tracker.str_volume or tracker.str_fx then return end
	local step = selection.min_step()
	if step then
		selection.for_each_channel(
			function(channel, track)
				local pitch = tracker:note_to_preview(track, step)
				local instr = tracker:instrument_to_preview(track, step)
				local vol = tracker:volume_to_preview(track, step)
				note(pitch, instr, vol,
					0x00, 0x00,
					8 + channel,
					false -- don't force retrigger
				)
			end
		)
		tracker.preview_timer = 16
		-- Now move down
		if jump == "jump" then
			local jump_step = selection.jump_step()
			local moved = selection.move_step(jump_step)
			if not moved then
				local min_step = selection.min_step()
				local target = min_step % jump_step
				selection.move_step(target - min_step)
			end
			tracker:show_cursor()
		end
	end
end


function actions.preview_row(tracker)
	preview(tracker, nil)
end


function actions.preview_row_and_jump_down(tracker)
	preview(tracker, "jump")
end

	
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


function actions.move_to_next_part(tracker)
	readtext(true)
	selection.move_to_next_part()
	tracker:show_cursor()
end


function actions.move_to_previous_part(tracker)
	readtext(true)
	selection.move_to_previous_part()
	tracker:show_cursor()
end


function actions.move_to_next_channel(tracker)
	readtext(true)
	selection.move_to_next_channel()
	tracker:show_cursor()
end


function actions.move_to_previous_channel(tracker)
	readtext(true)
	selection.move_to_previous_channel()
	tracker:show_cursor()
end


-------------------------------------------------------------------------------
-- Selection
-------------------------------------------------------------------------------


function actions.select_next_row(tracker)
	tracker:clear_edit()
	selection.grow_steps(1)
	tracker:show_cursor()
end


function actions.shrink_selection_rows(tracker)
	tracker:clear_edit()
	selection.shrink_steps(1)
	tracker:show_cursor()
end


function actions.select_next_beat(tracker)
	tracker:clear_edit()
	selection.grow_steps(app.beat_length)
	tracker:show_cursor()
end


function actions.select_next_bar(tracker)
	tracker:clear_edit()
	selection.grow_steps(app.bar_length)
	tracker:show_cursor()
end


function actions.select_next_part(tracker)
	tracker:clear_edit()
	selection.grow_parts()
	tracker:show_cursor()
end


function actions.shrink_selection_parts(tracker)
	tracker:clear_edit()
	selection.shrink_parts()
	tracker:show_cursor()
end


function actions.select_next_channel(tracker)
	tracker:clear_edit()
	selection.grow_channels()
	tracker:show_cursor()
end


function actions.shrink_selection_channels(tracker)
	tracker:clear_edit()
	selection.shrink_channels()
	tracker:show_cursor()
end


-------------------------------------------------------------------------------
-- Edition
-------------------------------------------------------------------------------


function actions.repeat_last_entry(tracker)
	if not app.is_editing then return end
	if tracker.str_instrument or tracker.str_volume or tracker.str_fx then return end
	undo.checkpoint()
	readtext(true)
	local sth_entered = false
	selection.for_each_channel_each_step(
		function(track, step)
			if selection.has_part(selection.note) and tracker.last_pitch_entered then
				sfx.set_track_pitch(track, step, tracker.last_pitch_entered)
				sth_entered = true
			end
			if selection.has_part(selection.instrument) and tracker.last_instrument_entered then
				sfx.set_track_instrument(track, step, tracker.last_instrument_entered)
				sth_entered = true
			end
			if selection.has_part(selection.volume) and tracker.last_volume_entered then
				sfx.set_track_volume(track, step, tracker.last_volume_entered)
				sth_entered = true
			end
			if selection.has_part(selection.fx) and tracker.last_fx_entered then
				sfx.set_track_fx(track, step, tracker.last_fx_entered)
				sth_entered = true
			end
			if selection.has_part(selection.fx) and tracker.last_fx_params_entered then
				sfx.set_track_fx_params(track, step, tracker.last_fx_params_entered)
				sth_entered = true
			end
		end
	)
	if sth_entered then
		selection.move_step(selection.jump_step())
		tracker:show_cursor()
	end
end

	
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


function actions.clear_parts(tracker)
	if tracker.str_instrument or tracker.str_volume or tracker.str_fx then return end
	undo.checkpoint()
	readtext(true)
	selection.for_each_channel_each_step(clear_parts)
	tracker:show_cursor()
end


function actions.clear_rows(tracker)
	if tracker.str_instrument or tracker.str_volume or tracker.str_fx then return end
	undo.checkpoint()
	readtext(true)
	selection.for_each_channel_each_step(clear_steps)
	tracker:show_cursor()
end


function actions.clear_parts_and_jump_down(tracker)
	if tracker.str_instrument or tracker.str_volume or tracker.str_fx then return end
	undo.checkpoint()
	readtext(true)
	selection.for_each_channel_each_step(clear_parts)
	local jump_step = selection.jump_step()
	local moved = selection.move_step(jump_step)
	if not moved then
		local min_step = selection.min_step()
		local target = min_step % jump_step
		selection.move_step(target - min_step)
	end
	tracker:show_cursor()
end


function actions.clear_rows_and_jump_down(tracker)
	if tracker.str_instrument or tracker.str_volume or tracker.str_fx then return end
	undo.checkpoint()
	readtext(true)
	selection.for_each_channel_each_step(clear_steps)
	local jump_step = selection.jump_step()
	local moved = selection.move_step(jump_step)
	if not moved then
		local min_step = selection.min_step()
		local target = min_step % jump_step
		selection.move_step(target - min_step)
	end
	tracker:show_cursor()
end


function actions.remove_rows(tracker)
	if tracker.str_instrument or tracker.str_volume or tracker.str_fx then return end
	undo.checkpoint()
	readtext(true)
	remove_selected_steps()
	tracker:show_cursor()
end

	
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

	
local function backspace(tracker, how, what)
	if tracker.str_instrument or tracker.str_volume or tracker.str_fx then return end
	undo.checkpoint()
	readtext(true)
	local should_proceed = true
	should_proceed = selection.move_step(-1 * selection.jump_step())
	if should_proceed then
		if how == "remove" then
			remove_steps(selection.min_step(), selection.jump_step())
		else
			local full_row = what == "rows"
			selection.for_each_channel_each_step(
				full_row and clear_steps or clear_parts
			)
		end
	end
	tracker:show_cursor()
	return nil
end


function actions.jump_up_and_clear_parts(tracker)
	backspace(tracker, "clear", "parts")
end


function actions.jump_up_and_clear_rows(tracker)
	backspace(tracker, "clear", "rows")
end


function actions.jump_up_and_remove_rows(tracker)
	backspace(tracker, "remove", "rows")
end

	
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


function actions.insert_rows(tracker)
	undo.checkpoint()
	readtext(true)
	insert_steps(selection.min_step(), selection.jump_step())
	selection.move_step(selection.jump_step())
end

	
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


function actions.increase_part(tracker)
	if selection.has_part(selection.note) then
		actions.increase_octave(tracker)
	elseif selection.has_part(selection.instrument) then
		actions.increase_instrument(tracker)
	elseif selection.has_part(selection.volume) then
		actions.increase_volume(tracker)
	end
end


function actions.decrease_part(tracker)
	if selection.has_part(selection.note) then
		actions.decrease_octave(tracker)
	elseif selection.has_part(selection.instrument) then
		actions.decrease_instrument(tracker)
	elseif selection.has_part(selection.volume) then
		actions.decrease_volume(tracker)
	end
end


function actions.increase_part_slightly(tracker)
	if selection.has_part(selection.note) then
		actions.increase_pitch(tracker)
	elseif selection.has_part(selection.instrument) then
		actions.increase_instrument(tracker)
	elseif selection.has_part(selection.volume) then
		actions.increase_volume_slightly(tracker)
	end
end


function actions.decrease_part_slightly(tracker)
	if selection.has_part(selection.note) then
		actions.decrease_pitch(tracker)
	elseif selection.has_part(selection.instrument) then
		actions.decrease_instrument(tracker)
	elseif selection.has_part(selection.volume) then
		actions.decrease_volume_slightly(tracker)
	end
end

	
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


function actions.increase_octave(tracker)
	undo.checkpoint()
	readtext(true)
	selection.for_each_channel_each_step(
		function(track, step)
			local pitch = sfx.track_pitch(track, step)
			if pitch ~= 0xff then
				local note = pitch % 12
				local octave = flr(pitch // 12)
				octave = mid(octave + 1, 0, 7)
				pitch = mid(note + 12 * octave, 0, 0xfe)
				sfx.set_track_pitch(track, step, pitch)
			end
		end
	)
end


function actions.decrease_octave(tracker)
	undo.checkpoint()
	readtext(true)
	selection.for_each_channel_each_step(
		function(track, step)
			local pitch = sfx.track_pitch(track, step)
			if pitch ~= 0xff then
				local note = pitch % 12
				local octave = flr(pitch // 12)
				octave = mid(octave - 1, 0, 7)
				pitch = mid(note + 12 * octave, 0, 0xfe)
				sfx.set_track_pitch(track, step, pitch)
			end
		end
	)
end


function actions.increase_pitch(tracker)
	undo.checkpoint()
	readtext(true)
	selection.for_each_channel_each_step(
		function(track, step)
			local pitch = sfx.track_pitch(track, step)
			if pitch ~= 0xff then
				pitch = mid(pitch + 1, 0, 0xfe)
				sfx.set_track_pitch(track, step, pitch)
			end
		end
	)
end


function actions.decrease_pitch(tracker)
	undo.checkpoint()
	readtext(true)
	selection.for_each_channel_each_step(
		function(track, step)
			local pitch = sfx.track_pitch(track, step)
			if pitch ~= 0xff then
				pitch = mid(pitch - 1, 0, 0xfe)
				sfx.set_track_pitch(track, step, pitch)
			end
		end
	)
end

	
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


function actions.increase_instrument(tracker)
	undo.checkpoint()
	readtext(true)
	selection.for_each_channel_each_step(
		function(track, step)
			local inst = sfx.track_instrument(track, step)
			if inst ~= 0xff then
				inst = mid(inst + 1, 0, sfx.num_instruments())
				sfx.set_track_instrument(track, step, inst)
			end
		end
	)
end


function actions.decrease_instrument(tracker)
	undo.checkpoint()
	readtext(true)
	selection.for_each_channel_each_step(
		function(track, step)
			local inst = sfx.track_instrument(track, step)
			if inst ~= 0xff then
				inst = mid(inst - 1, 0, sfx.num_instruments())
				sfx.set_track_instrument(track, step, inst)
			end
		end
	)
end

	
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


function actions.increase_volume(tracker)
	undo.checkpoint()
	readtext(true)
	selection.for_each_channel_each_step(
		function(track, step)
			local vol = sfx.track_volume(track, step)
			if vol ~= 0xff then
				vol = mid(vol + 8, 0, 0xfe)
				sfx.set_track_volume(track, step, vol)
			end
		end
	)
end


function actions.decrease_volume(tracker)
	undo.checkpoint()
	readtext(true)
	selection.for_each_channel_each_step(
		function(track, step)
			local vol = sfx.track_volume(track, step)
			if vol ~= 0xff then
				vol = mid(vol - 8, 0, 0xfe)
				sfx.set_track_volume(track, step, vol)
			end
		end
	)
end


function actions.increase_volume_slightly(tracker)
	undo.checkpoint()
	readtext(true)
	selection.for_each_channel_each_step(
		function(track, step)
			local vol = sfx.track_volume(track, step)
			if vol ~= 0xff then
				vol = mid(vol + 1, 0, 0xfe)
				sfx.set_track_volume(track, step, vol)
			end
		end
	)
end


function actions.decrease_volume_slightly(tracker)
	undo.checkpoint()
	readtext(true)
	selection.for_each_channel_each_step(
		function(track, step)
			local vol = sfx.track_volume(track, step)
			if vol ~= 0xff then
				vol = mid(vol - 1, 0, 0xfe)
				sfx.set_track_volume(track, step, vol)
			end
		end
	)
end

	
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


function actions.copy(tracker)
	set_clipboard(pod(selection.pack(), 0, { pod_type = "wavemaker notes" }))
	notify("copied notes")
end


function actions.cut(tracker)
	set_clipboard(pod(selection.pack(), 0, { pod_type = "wavemaker notes" }))
	actions.clear_parts(tracker) -- Note: this calls `undo:checkpoint()`
	notify("cut notes")
end


function actions.cut_and_remove_rows(tracker)
	set_clipboard(pod(selection.pack("rows"), 0, { pod_type = "wavemaker notes" }))
	actions.remove_rows(tracker) -- Note: this calls `undo:checkpoint()`
	notify("cut notes")
end


function actions.paste(tracker)
	local data, metadata = unpod(get_clipboard())
	if metadata and metadata.pod_type == "wavemaker notes" then
		undo.checkpoint()
		selection.unpack(data)
	end
end


function actions.insert_rows_and_paste(tracker)
	-- TODO: not yet implemented
	--[[
	local data, metadata = unpod(get_clipboard())
	if metadata and metadata.pod_type == "wavemaker notes" then
		undo.checkpoint()
		selection.unpack(data)
	end
	--]]
end
	
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
	

return actions
:: src/app.lua
--[[pod_format="raw",created="2024-04-12 08:11:00",modified="2026-02-16 14:12:04",revision=32251]]
local settings = require "src/settings.lua"
local sfx = require "src/sfx/sfx.lua"


local app = {}


----------------------------------------------------------------------------------------------------
-- Transient State
----------------------------------------------------------------------------------------------------

app.current_location = nil

app.window_focused = false -- TODO: remove?

app.refresh_gui = true

app.is_editing = false

app.was_in_text_field = false
	-- Used to stop interference between field entry
	-- and playing notes (eg when entering "2d" in
	-- default volume field).

app.capture_escapes = false
	-- Caches the state of `window { capture_escapes }`.

app.follow_playhead = false

app.saved_jump_step = nil


----------------------------------------------------------------------------------------------------
-- Global State
----------------------------------------------------------------------------------------------------


app.version = "?.?.?"
local metadata = fetch_metadata("/ram/cart")
if type(metadata) == "table" and type(metadata.version) == "string" then
	if metadata.version then
		app.version = metadata.version
	end
end


-- Shared State

app.pattern = 0
app.track = 0
app.instrument = 0

-- Synth State

app.node = nil -- selected in instrument editor
app.wt = 0 -- selected in instrument editor

-- Tracker State

app.base_note = 48
app.base_volume = 0x20
app.jump_step = 1

-- Metadata

app.new_tracks_speed = 16
app.new_tracks_length = 0
app.beat_length = 4
app.bar_length = 4 * app.beat_length

-- UI State

app.view = "synth" -- "tracker" or "synth"
app.detail = false -- TODO: remove?
app.toolrack_tab = nil
app.toolrack_track_scrollstart = 0
app.channel_oscillos_visible = true
app.row_height = 8
app.starting_row = 0
app.env_advanced = { [0] = false, false, false, false }
app.show_meter = true
app.meter_speed = 1 / 64


----------------------------------------------------------------------------------------------------
-- Constants
----------------------------------------------------------------------------------------------------


-- Meters Range


app.min_db = 40


-- Layout constants


app.panel_width = 19
app.track_header_height = 9
app.column_width = 57 -- 57

app.synth_width = 83
app.synth_height = 72
app.synth_gap = 5
app.mod_width = 57
app.mod_height = app.synth_height


----------------------------------------------------------------------------------------------------
-- Reverse Track Lookup
----------------------------------------------------------------------------------------------------


local track_patterns = {}


function app.update_track_patterns()
	track_patterns = {}
	for p = 0, sfx.num_patterns() do
		for c = 0, 7 do
			local muted = sfx.channel_is_muted(p, c)
			if not muted then
				local track = sfx.pattern_track(p, c)
				if not track_patterns[track] then
					track_patterns[track] = {}
				end
				add(track_patterns[track], { pattern = p, channel = c })
			end
		end
	end
end


function app.track_patterns(track)
	return track_patterns[track]
end


function app.set_pattern_track(pattern, channel, track)
	sfx.set_pattern_track(pattern, channel, track)
	app.update_track_patterns()
end


function app.mute_channel(pattern, channel, muted)
	sfx.mute_channel(pattern, channel, muted)
	app.update_track_patterns()
end


----------------------------------------------------------------------------------------------------
-- Helpers
----------------------------------------------------------------------------------------------------


function app.play_or_pause(mode)
	if sfx.music_is_playing() then
		music(-1)
		app.follow_playhead = false
	else
		if mode == "follow_playhead" then
			app.is_editing = false
			app.follow_playhead = true
		end
		music(app.pattern)
	end
end


----------------------------------------------------------------------------------------------------
-- Helpers
----------------------------------------------------------------------------------------------------


function app.draw_borders(x, y, width, height)
	pset(x, y, 58)
	line(x - 1, y + 1, x - 1, y + height - 2, 58)
	line(x + 1, y - 1, x + width - 2, y - 1, 58)
	pset(x + width - 1, y, 58)
	line(x + width, y + 1, x + width, y + height - 2, 57)
	pset(x + width - 1, y + height - 1, 57)
	line(x + 1, y + height, x + width - 2, y + height, 57)
	pset(x, y + height - 1, 57)
end


local fg_clip <const> = 8
local fg_high <const> = 51 -- 51, 25
local fg_mid <const> = 43 -- 43, 10
local fg_low <const> = 45 -- 45, 11


function app.draw_vert_meter(x, y, width, height, value)
	local target = flr(0.5 + y + height - 1 - value * (height - 1))
	local zone1 = flr(0.5 + y + height - 1 - 0.5 * (height - 1))
	local zone2 = flr(0.5 + y + height - 1 - 0.8 * (height - 1))
	rectfill(x, y, x + width - 1, y + height - 1, 60)
	if target > zone1 then
		rectfill(x, target, x + width - 1, y + height - 1, fg_low)
	elseif target > zone2 then
		rectfill(x, zone1, x + width - 1, y + height - 1, fg_low)
		rectfill(x, target, x + width - 1, zone1 - 1, fg_mid)
	else
		rectfill(x, zone1, x + width - 1, y + height - 1, fg_low)
		rectfill(x, zone2, x + width - 1, zone1 - 1, fg_mid)
		if value == 1 then
			rectfill(x, zone2 - 1, x + width - 1, target, fg_clip)
		else
			rectfill(x, zone2 - 1, x + width - 1, target, fg_high)
		end
	end
end


function app.draw_horiz_meter(x, y, width, height, value)
	local target = flr(0.5 + x + value * (width - 1))
	local zone1 = flr(0.5 + x + 0.5 * (width - 1))
	local zone2 = flr(0.5 + x + 0.8 * (width - 1))
	rectfill(x, y, x + width - 1, y + height - 1, 60)
	if target <= zone1 then
		rectfill(x, y, target, y + height - 1, fg_low)
	elseif target <= zone2 then
		rectfill(x, y, zone1, y + height - 1, fg_low)
		rectfill(zone1 + 1, y, target, y + height - 1, fg_mid)
	else
		rectfill(x, y, zone1, y + height - 1, fg_low)
		rectfill(zone1 + 1, y, zone2, y + height - 1, fg_mid)
		rectfill(zone2 + 1, y, target, y + height - 1, fg_high)
	end
end


----------------------------------------------------------------------------------------------------
-- Helpers
----------------------------------------------------------------------------------------------------


local last_pitch = nil
function app.pitched_key()
	if app.was_in_text_field then
		last_pitch = nil
		return nil, false
	end
	if key("ctrl") or key("alt") then
		last_pitch = nil
		return nil, false
	end
	local pitch = nil
	for i = 1, #settings.keys.pitched do
		local offset = settings.keys.pitched[i].offset
		for j = 0, #settings.keys.pitched[i] do
			local k = settings.keys.pitched[i][j]
			if key(k, true) then
				pitch = app.base_note + offset + j
				pitch = mid(pitch, 0, 0xfe)
			end
		end
	end
	local is_new = pitch and (pitch ~= last_pitch)
	last_pitch = pitch
	return pitch, is_new
end


function app.decimal_digit_key()
	if keyp("0") then return 0, "0"
	elseif keyp("1") then return 1, "1"
	elseif keyp("2") then return 2, "2"
	elseif keyp("3") then return 3, "3"
	elseif keyp("4") then return 4, "4"
	elseif keyp("5") then return 5, "5"
	elseif keyp("6") then return 6, "6"
	elseif keyp("7") then return 7, "7"
	elseif keyp("8") then return 8, "8"
	elseif keyp("9") then return 9, "9"
	end
	return nil
end


function app.hexadecimal_digit_key()
	if keyp("0") then return 0, "0"
	elseif keyp("1") then return 1, "1"
	elseif keyp("2") then return 2, "2"
	elseif keyp("3") then return 3, "3"
	elseif keyp("4") then return 4, "4"
	elseif keyp("5") then return 5, "5"
	elseif keyp("6") then return 6, "6"
	elseif keyp("7") then return 7, "7"
	elseif keyp("8") then return 8, "8"
	elseif keyp("9") then return 9, "9"
	elseif keyp("a") then return 0xa, "a"
	elseif keyp("b") then return 0xb, "b"
	elseif keyp("c") then return 0xc, "c"
	elseif keyp("d") then return 0xd, "d"
	elseif keyp("e") then return 0xe, "e"
	elseif keyp("f") then return 0xf, "f"
	end
	return nil
end


app.is_valid_fx = {
	["0"] = "\0", ["."] = "\0",
	["1"] = "s", s="s",
	["2"] = "v", v="v",
	["3"] = "-", ["-"] = "-", 
	["4"] = "<", ["<"] = "<", 
	["5"] = ">", [">"] = ">", 
	["6"] = "a", a = "a", A = "A",
	["7"] = "b", b = "b", B = "B",
	["8"] = "t", ["t"] = "t",
	["9"] = "+", ["+"] = "+",
	w = "w", 
	r = "r", c = "c", d = "d", 
	p = "p",
	f = "f", -- fade (0.2.1c)
	m = "m", M = "M", -- arp spd 1
	n = "n", N = "N", -- arp spd 2
	o = "o", O = "O", -- ornament (2-note arp w/ spd parameter)
}


function app.fx_key()
	for k, _ in pairs(app.is_valid_fx) do
		if keyp(k) then
			return k
		end
	end
	return nil
end


return app


:: src/file.lua
--[[pod_format="raw",created="2024-04-07 08:14:09",modified="2026-02-16 14:12:04",revision=26630]]
local app = require "src/app.lua"
local sfx = require "src/sfx/sfx.lua"
local undo = require "src/undo.lua"


local file = {}


file.default_filename = "/ram/cart/sfx/0.sfx"


-- `file.save` and `file.load` are direct copies of `sfx.p64` code to
-- ensure perfect compatibility.


function file.save()
	local ud = userdata("u8", 0x40000)
--	for i=0,0x3f do
--		set(ud, i * 0x1000, peek(0x30000 + i * 0x1000, 0x1000))
--	end
	ud:peek(0x30000)
	local metadata = file.save_metadata()
	return ud, metadata
end


function file.load(ud, metadata)
	if (type(ud)~="userdata") then
		init_data()
	else
		memset(0x30000, 0, 0x40000) -- in case stored short / legacy userdata
		ud:poke(0x30000)
		
	end
	-- TODO
	app.instrument = 0
	app.node = 0
	app.refresh_gui = true
	file.load_metadata(metadata)
	app.update_track_patterns()
	undo.init()
end


function file.export_into(filename)
	local target = fetch(filename)
	if type(target) ~= "userdata" then
		notify("unable to read file " .. pod(filename))
		return
	end
	
	-- TODO: only copy existing instruments
	target:peek(0x040000, 0x010000, 0xffff)
	-- TODO: where to put the wavetables?
	-- target:peek(0xf00000, 0xed0000, 0xfffff)
	
	store(filename, target)
	notify("all instruments exported into " .. pod(filename))
end


function file.handle_drop_items(msg)
	for i = 1, #msg.items do
		local item = msg.items[i]
		if item.pod_type == "file_reference" and item.attrib == "file" then
			local ext = item.fullpath:ext()
			if ext == "sfx" then
				local metadata = fetch_metadata(item.fullpath) or {} -- TODO
				send_message(pid(), {event = "open_file", filename = item.fullpath})
			else
				notify("wrong file extension")
				-- TODO: dialog for unknown file extensions?
				--current_filename = item.fullpath
				--send_message(pid(), {event = "open_file", filename = item.fullpath})
			end
		end
	end
end


-------------------------------------------------------------------------------
-- Metadata
-------------------------------------------------------------------------------


function file.save_metadata()
	return {
		wavemaker = {
			version = app.version,
			new_tracks_speed = app.new_tracks_speed,
			new_tracks_length = app.new_tracks_length,
			beat_length = app.beat_length,
			bar_length = app.bar_length,
		}
	}
end


function file.load_metadata(md)
	if not md then md = {} end
	if not md.wavemaker then md.wavemaker = {} end
	-- TODO: check `md.wavemaker.version` for futureness
	-- TODO: default values should be in a single place...
	app.new_tracks_speed = md.wavemaker.new_tracks_speed or 16
	app.new_tracks_length = md.wavemaker.new_tracks_length or 0
	app.beat_length = md.wavemaker.beat_length or 4
	app.bar_length = md.wavemaker.bar_length or 16
end


-------------------------------------------------------------------------------
-- Initialization
-------------------------------------------------------------------------------


function init_track(track)
	local size <const> = 64 -- TODO: support other sizes? how?
	sfx.set_track_size(track, size)
	sfx.set_track_speed(track, app.new_tracks_speed)
	sfx.set_track_loop0(track, app.new_tracks_length)
	sfx.set_track_loop1(track, 0)
	sfx.set_track_delay(track, 0)
	sfx.set_track_flags(track, 0)
	sfx.set_track_unused(track, 0)
	for step = 0, size - 1 do
		sfx.set_track_pitch(track, step, 0xff)
		sfx.set_track_instrument(track, step, 0xff)
		sfx.set_track_volume(track, step, 0xff)
		sfx.set_track_fx(track, step, 0x0)
		sfx.set_track_fx_params(track, step, 0x0)
	end
end


-- copied from "/system/apps/sfx.lua" in Picotron 0.2.2b

function __init_track(addr)
--	printh("init_track "..addr)
	poke2(addr, 64) -- len
	poke(addr+2,16) -- spd
	poke(addr+3,0)  -- loop0
	poke(addr+4,0)  -- loop1
	poke(addr+5,0)  -- delay
	poke(addr+6,0)  -- flags (0x1 mute)
	poke(addr+7,0)  -- unused
	
	-- pitch, inst, vol: not set (0xff)
	memset(addr+8, 0xff, 64*3)
	
	-- fx, fx_p: clear
	memset(addr+8+64*3, 0x0, 64*2)
end

function clear_pattern(i)
	local addr = 0x30100 + i*20
	memset(addr,0,20)
end

function clear_instrument(i)
	local addr = 0x40000 + i * 0x200
	
	memset(addr, 0, 0x200)
	
	-- node 0: root
	poke(addr + (0 * 32), -- node 0
	
			0,    -- parent (0x7)  op (0xf0)
			1,    -- kind (0x0f): 1 root  kind_p (0xf0): 0  -- wavetable_index
			0,    -- flags
			0,    -- unused extra
				
			-- MVALs:  kind/flags,  val0, val1, envelope_index
			
			0x2|0x4,0x30,0,0,  -- volume: mult. 0x40 is max (-0x40 to invert, 0x7f to overamp)
			0x1,0,0,0,     -- pan:   add. center
			0x1,0,0,0,     -- tune: +0 -- 0,48,0,0 absolute for middle c (c4) 261.6 Hz
			0x1,0,0,0,     -- bend: none
			-- following shouldn't be in root
			0x0,0,0,0,     -- wave: use wave 0 
			0x0,0,0,0      -- phase 
	)
	
	
	-- node 1: sine
	poke(addr + (1 * 32), -- instrument 0, node 1
	
			0,    -- parent (0x7)  op (0xf0)
			2,    -- kind (0x0f): 2 osc  kind_p (0xf0): 0  -- wavetable_index
			0,    -- flags
			0,    -- unused extra
				
			-- MVALs:  kind/flags,  val0, val1, envelope_index
			
			0x2,0x30,0,0,  -- volume: mult. 0x40 is max (-0x40 to invert, 0x7f to overamp)
			0x1,0,0,0,     -- pan:   add. center
			0x21,0,0,0,    -- tune: +0 -- 0,48,0,0 absolute for middle c (c4) 261.6 Hz
			               -- tune is quantized to semitones with 0x20
			0x1,0,0,0,     -- bend: none
			0x0,0x40,0,0,  -- wave: triangle
			0x0,0,0,0      -- phase 
	)
	
	
	-- wavetables
	poke(addr + 0x1e0,
		0x00, -- address (low)  in 256 byte increments
		0xf8, -- address (high) in 64k increments
		0x0a, -- samples (1 << n) 1024
		0xff,  -- wt_height 256(0); wave mval points at one of the entries
		
		-- white noise
		0x80,
		0xf7,
		0x0d, -- samples (1 << n) 8192
		0x01
	)

	-- envelope 0 inst 1
	
	poke(addr + 0x100,
		0,0,0,0, 0,0,0,0,
		0,40,255,0 -- adsr
	)
	
	poke(addr + 0x1df, 0x01)
end


function init_data()

	-- use 256k from 0x30000
	-- gives 399 SFX and managemable size for undo state comparisons
	-- if change this need, to adjust undo stack size and loader/saver
	
	memset(0x30000, 0, 0x40000)
	

	-- index (0x30000)
	
	-- first 3 values are almost metadata only -- not currently
	-- acted on anywhere. perhaps useful in future for deciding
	-- scope of copy/paste, and gui cues, but can be calculated
	-- from content.
	
	poke2(0x30000,
		64,  -- num_instruments
		512, -- num_tracks (64 patterns * 8 channels for default indexing)
		64,  -- num_patterns
		-- flags: 0x1 use default track indexing (base+0x20000, increments of 328 bytes)
		0x1
	)
	poke4(0x30010,
		0x10000, -- insts_addr      (I32)    relative address of instruments
		0x20000, -- tracks_addr     (I32)    relative address of track index
		0,       -- patterns_addr   (I32)    relative address of pattern data
		0        -- unused          (I32)    should be 0
	)
	poke2(0x30020,
		0,  -- tick len (0 for default -- custom vals not supported yet)
		64, -- default track length
		16 -- default track spd
	)
	
	-- default track speed (+3 unused)
	poke(0x30026, 16, 0, 0, 0) 
	
	-- pattern data: first 16 patterns
	-- want to keep default sfx file quite tiny
	-- .. should be ok to save a whole .sfx for just one inst / experiment
	-- later: interface to generate more default patterns
	
	for pp = 0,0 do
		local addr = 0x30100 + pp * 20
		for i = 0, 7 do
			if i < 4 then
				poke(addr+i, pp*8 + i)
			else
				poke(addr+i, 0)
			end
		end
		poke(addr+8, 0x0)  -- flow flags
		if pp == 0 then
			poke(addr+9, 0x0f) -- channel mask -- 8 channels
		else
			poke(addr+9, 0x00) -- channel mask -- 8 channels
		end
		poke(addr+10, 0,0) -- length (I16)
	end
	
	
	----------------------------------------------------------------------------
	-- single instrument at 0x40000 (instrument 0)
	
	clear_instrument(0)
	
	-- copy default instrument to 1..31
	for i=1,31 do
		memcpy(0x40000 + 0x200*i, 0x40000, 0x200)
	end
	
	
	--------------------------------------------------
	-- Track Data  0x50000
	--------------------------------------------------
	
	-- Default track size is 5 * 64 rows + 8 = 328 bytes
	
	-- header (8)
	
	for track = 0, 7 do
--		init_track(0x50000 + 328 * track)
		init_track(track)
	end
	
	-- copy to other tracks: 128k worth
	-- ** only first 399 are saved / undoable (0x20000\328) **
	-- 384 used in tracker
	--[[
	for i=1,398 do
		memcpy(0x50000 + i*328, 0x50000, 328)
	end
	]]

end


return file
:: src/selection.lua
--[[pod_format="raw",created="2026-01-27 06:45:26",modified="2026-02-16 14:12:04",revision=21388]]
local app = require "src/app.lua"
local sfx = require "src/sfx/sfx.lua"


local selection = {}

----------------------------------------------------------------------------------------------------
-- Locals
----------------------------------------------------------------------------------------------------


local channels = {}
local steps = {}
local parts = 0x0

local anchor_channel
local anchor_step
local anchor_part
local anchor_what
local channels_to_extend
local steps_to_extend
local parts_to_extend


-- Parts
selection.note = 1 << 0
selection.instrument = 1 << 1
selection.volume = 1 << 2
selection.fx = 1 << 3
selection.all_parts =
	selection.note | selection.instrument
	| selection.volume | selection.fx


local parts_before <const> = {
	[selection.note] = selection.note,
	[selection.instrument] = selection.note | selection.instrument,
	[selection.volume] = selection.note | selection.instrument | selection.volume,
	[selection.fx] = selection.note | selection.instrument | selection.volume | selection.fx,
}

local parts_after <const> = {
	[selection.note] = selection.note | selection.instrument | selection.volume | selection.fx,
	[selection.instrument] = selection.instrument | selection.volume | selection.fx,
	[selection.volume] = selection.volume | selection.fx,
	[selection.fx] = selection.fx,
}

local is_unique_part <const> = {
	[selection.note] = true,
	[selection.instrument] = true,
	[selection.volume] = true,
	[selection.fx] = true,
}


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


local function min_part_of(p)
	if p & selection.note ~= 0 then
		return selection.note
	elseif p & selection.instrument ~= 0 then
		return selection.instrument
	elseif p & selection.volume ~= 0 then
		return selection.volume
	elseif p & selection.fx ~= 0 then
		return selection.fx
	end
	return 0
end


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


local function channel_not_valid(channel)
	local track = sfx.pattern_track(app.pattern, channel)
	local size = sfx.track_size(track)
	return size < 1 or sfx.channel_is_muted(app.pattern, channel)
end


----------------------------------------------------------------------------------------------------
-- Creation
----------------------------------------------------------------------------------------------------


function selection.set(channel, step, part)
	if channel then
		channels = { [channel] = true }
	end
	if step then
		local track = sfx.pattern_track(app.pattern, channel)
		local step = mid(step, 0, sfx.track_size(track) - 1)
		steps = { [step] = true }
	end
	if part then
		parts = part
	end
end


function selection.extend(channel, step, part)
	if channel then
		channels[channel] = true
	end
	if step then
		local track = sfx.pattern_track(app.pattern, channel)
		local step = mid(step, 0, sfx.track_size(track) - 1)
		steps[step] = true
	end
	if part then
		parts = parts | part
	end
end


function selection.shrink_channels()
	if selection.channel_count() < 2 then
		return false
	end
	channels[selection.max_channel()] = nil
end


function selection.grow_channels()
	local current_channels = copy_channels()
	local changed = selection.move_to_next_channel()
	for c, v in pairs(current_channels) do
		channels[c] = v
	end
	return changed
end


function selection.grow_steps(delta)
	local current_steps = copy_steps()
	selection.move_step(delta)
	-- TODO: check limits
	for step, v in pairs(current_steps) do
		steps[step] = v
	end
end


function selection.shrink_steps(mode)
	if selection.step_count() < 2 then return end
	steps[selection.max_step()] = nil
end




function selection.shrink_parts()
	if selection.channel_count() > 1 then
		selection.shrink_channels()
	elseif parts == selection.note or parts == selection.instrument
		or parts == selection.volume or parts == selection.fx
	then
		return false
	elseif parts & selection.fx ~= 0 then
		parts ^^= selection.fx
	elseif parts & selection.volume ~= 0 then
		parts ^^= selection.volume
	elseif parts & selection.instrument ~= 0 then
		parts ^^= selection.instrument
	elseif parts & selection.note ~= 0 then
		-- impossible
	end
end


function selection.grow_parts()
	if parts & selection.fx ~= 0 then
		local channel_changed = selection.grow_channels()
		if channel_changed then
			parts |= selection.note
		end
	end
	if parts & selection.volume ~= 0 then
		parts |= selection.fx
	end
	if parts & selection.instrument ~= 0 then
		parts |= selection.volume
	end
	if parts & selection.note ~= 0 then
		parts |= selection.instrument
	end
end


function selection.set_anchor(channel, step, part, how, what)
	local track = sfx.pattern_track(app.pattern, channel)
	local step = mid(step, 0, sfx.track_size(track) - 1)
	if how == "extend" then
		channels_to_extend = channels
		steps_to_extend = steps
		parts_to_extend = parts
	else
		selection.set(channel, step, part)
		channels_to_extend = {}
		steps_to_extend = {}
		parts_to_extend = 0
	end
	anchor_channel = channel
	anchor_step = step
	anchor_part = part
	anchor_what = what
end


function selection.set_from_anchor_to(channel, step, part)
	if not anchor_channel or not anchor_step
		or not anchor_part
	then
		return
	end
	local track = sfx.pattern_track(app.pattern, channel)
	local size = sfx.track_size(track)
	local step = mid(step, 0, size - 1)
	-- Channels
	channels = {}
	for k, v in pairs(channels_to_extend) do channels[k] = v end
	local from = min(channel, anchor_channel)
	local to = max(channel, anchor_channel)
	for c = from, to do
		if not channel_not_valid(c) then
			channels[c] = true
		end
	end
	-- Steps
	steps = {}
	for k, v in pairs(steps_to_extend) do steps[k] = v end
	local from = min(step, anchor_step)
	local to = max(step, anchor_step)
	if anchor_what == "beat" then
		from = from - from % app.beat_length
		to = to - to % app.beat_length + app.beat_length - 1
	elseif anchor_what == "column" or anchor_what == "track" then
		from = 0
		to = size - 1
	end
	from = mid(from, 0, size - 1)
	to = mid(to, 0, size - 1)
	for c = from, to do
		steps[c] = true
	end
	-- Parts
	if 	channel == anchor_channel 
		and (anchor_what == "part" or anchor_what == "column")
	then
		local from = min(anchor_part, part)
		local to = max(anchor_part, part)
		local range_parts = parts_after[from] & parts_before[to]
		parts = parts_to_extend | range_parts
	elseif anchor_what == "column" then
		parts = anchor_part
	else
		parts = selection.all_parts
	end
end


function selection.clear_anchor()
	anchor_channel = nil
	anchor_step = nil
	anchor_part = nil
	channels_to_extend = {}
	steps_to_extend = {}
	parts_to_extend = 0
end


function selection.unset(channel, step, part)
	-- TODO: clear if one of the mask is empty
	if channel then
		channels[channel] = nil
	end
	if step then
		steps[step] = nil
	end
	if part then
		parts = parts & (~part)
	end
end


function selection.clear()
	local min_channel = selection.min_channel()
	local min_step = selection.min_step()
	channels = { [min_channel] = true }
	steps = { [min_step] = true }
	parts = selection.min_part()
end


function selection.sanitize()
	-- Remove muted channels
	for channel, _ in pairs(channels) do
		if channel_not_valid(channel) then
			channels[channel] = nil
		end
	end
	-- Check if there is still some selection
	for channel, cv in pairs(channels) do
		for step, sv in pairs(steps) do
			if cd and sv and channels[channel] and steps[step] then
				-- At least one cursor is not muted,
				-- nothing more to do
				return	
			end
		end
	end
	-- No selection: find the first unmuted channel
	for channel = 0, 7 do
		if not channel_not_valid(channel) then
			channels[channel] = true
			return
		end
	end
end


----------------------------------------------------------------------------------------------------
-- Movement
----------------------------------------------------------------------------------------------------


function selection.move_to_previous_channel()
	local first_channel = find_first_channel(0)
	if channels[first_channel] then
		return false
	end
	local new_channels = {}
	for c, v in pairs(channels) do
		local prev = find_last_channel(c - 1)
		if not prev then
			return false
		end
		new_channels[prev] = v
	end
	channels = new_channels
	return true
end


function selection.move_to_next_channel()
	local last_channel = find_last_channel()
	if channels[last_channel] then
		return false
	end
	local new_channels = {}
	for c, v in pairs(channels) do
		local next = find_first_channel(c + 1)
		if not next then
			return false
		end
		new_channels[next] = v
	end
	channels = new_channels
	return true
end


function selection.move_step(delta)
	local max_size = sfx.pattern_max_size(app.pattern) -- TODO: is this correct?
	local new_steps = {}
	for s, v in pairs(steps) do
		local step = s + delta
		if step < 0 or step >= max_size then
			return false
		end
		new_steps[step] = v
	end
	steps = new_steps
	return true
end


function selection.move_to_step(channel, step, part)
	-- Move channels
	local min_channel = selection.min_channel()
	local max_channel = selection.max_channel()
	local channel_delta = channel - min_channel
	channel_delta = mid(channel_delta, - min_channel, 7 - max_channel)
	while channel_delta < 0 do
		selection.move_to_previous_channel()
		channel_delta += 1
	end
	while channel_delta > 0 do
		selection.move_to_next_channel()
		channel_delta -= 1
	end
	-- Move steps
	local size = sfx.pattern_max_size(app.pattern)
	local min_step = selection.min_step()
	local max_step = selection.max_step()
	local step_delta = step - min_step
	step_delta = mid(step_delta, - min_step, size - 1 - max_step)
	selection.move_step(step_delta)
	-- Parts
	if is_unique_part[parts] then
		parts = part
	end
end


function selection.move_to_previous_part()
	-- TODO: should probably cache these in a table...
	if parts == 0 then
		return
	elseif parts == selection.note then
		local channel_changed = selection.move_to_previous_channel()
		if channel_changed then
			parts = selection.fx
		end
	elseif parts == selection.instrument then
		parts = selection.note
	elseif parts == selection.volume then
		parts = selection.instrument
	elseif parts == selection.fx then
		parts = selection.volume
	else -- multiple parts
		parts = selection.min_part()
	end
end


function selection.move_to_next_part()
	-- TODO: should probably cache these in a table...
	if parts == 0 then
		return
	elseif parts == selection.note then
		parts = selection.instrument
	elseif parts == selection.instrument then
		parts = selection.volume
	elseif parts == selection.volume then
		parts = selection.fx
	elseif parts == selection.fx then
		local channel_changed = selection.move_to_next_channel()
		if channel_changed then
			parts = selection.note
		end
	else -- multiple parts
		parts = selection.max_part()
	end
end


----------------------------------------------------------------------------------------------------
-- Querying
----------------------------------------------------------------------------------------------------


function selection.has_cursor()
	local has_channels = (next(channels) ~= nil)
	local has_steps = (next(steps) ~= nil)
	return has_channels and has_steps and parts ~= 0
end


function selection.has_selection()
	-- TODO: something more efficient? (called each frame in update)
	if parts ~= 0 and parts ~= selection.note and parts ~= selection.instrument
		and parts ~= selection.volume and parts ~= selection.fx
	then
		return true
	end
	return selection.channel_count() > 1
		or selection.step_count() > 1
end


function selection.has_channel(channel)
	return channels[channel] or false
end


function selection.channels()
	local result = {}
	for c, v in pairs(channels) do
		if v then
			add(result, c)
		end
	end
	return result
end


function selection.has_step(step)
	return steps[step] or false
end


function selection.channel_count()
	local count = 0
	for _, v in pairs(channels) do
		if v then
			count += 1
		end
	end
	return count
end


function selection.step_count()
	local count = 0
	for _, v in pairs(steps) do
		if v then
			count += 1
		end
	end
	return count
end


function selection.steps()
	local result = {}
	for c, v in pairs(steps) do
		if v then
			add(result, c)
		end
	end
	return result
end


function selection.has_part(part)
	return parts & part ~= 0
end


function selection.parts()
	return parts
end


function selection.min_channel()
	local min = 9
	for c, v in pairs(channels) do
		if v and c < min then
			min = c
		end
	end
	if min == 9 then
		return 0 -- safer than nil or false
	end
	return min
end


function selection.max_channel()
	local max = -1
	for c, v in pairs(channels) do
		if v and (c > max) then
			max = c
		end
	end
	if max == -1 then
		return 0 -- safer than nil or false
	end
	return max
end


function selection.unique_step()
	local step
	local count = 0
	for k, v in pairs(steps) do
		if v then
			step = k
			count += 1
		end
	end
	if count == 1 then
		return step
	end
end


function selection.min_step()
	local min = 999999 -- hmmm..
	for s, _ in pairs(steps) do
		if s < min then
			min = s
		end
	end
	if min == 999999 then
		return 0 -- safer than nil or false
	end
	return min
end


function selection.max_step()
	local max = -1
	for s, _ in pairs(steps) do
		if s > max then
			max = s
		end
	end
	if max == -1 then
		return 0 -- safer than nil or false
	end
	return max
end


function selection.max_step_span()
	local max_count = 0
	for s, v in pairs(steps) do
		if v then
			local count = 1
			local next_s = s + 1
			while steps[next_s] do
				count += 1
				next_s += 1
			end
			if count > max_count then
				max_count = count
			end
		end
	end
	return max_count
	--[[
	local max_count = 0
	local count = 0
	local prev_step
	local step_array = selection.steps()
	notify(pod(step_array))
	for s in all(step_array) do
		if not prev_step then
			if count > max_count then
				max_count = count
			end
			count = 1
		elseif s == prev_step + 1 then
			count += 1
		end
		prev_step = s
	end
	return max_count
	--]]
end


function selection.min_part()
	return min_part_of(parts)
end


function selection.max_part()
	if parts & selection.fx ~= 0 then
		return selection.fx
	elseif parts & selection.volume ~= 0 then
		return selection.volume
	elseif parts & selection.instrument ~= 0 then
		return selection.instrument
	elseif parts & selection.note ~= 0 then
		return selection.note
	end
	return 0
end


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


function selection.jump_step()
	local selection_span = selection.max_step_span()
	-- This seem convoluted, but is actually pretty intuitive.
	-- A jump step of 1 is actually the neutral position,
	-- other values are relative to it.
	if app.jump_step == 0 then
		return 0
	elseif selection_span == 1 then
		return app.jump_step
	elseif app.jump_step == 1 then
		return selection_span
	elseif selection_span > 1 then
		return selection_span + app.jump_step
	end
end


----------------------------------------------------------------------------------------------------
-- Iteration
----------------------------------------------------------------------------------------------------

	
function selection.for_each_channel(func)
	for channel in all(selection.channels()) do
		local track = sfx.pattern_track(app.pattern, channel)
		func(channel, track)
	end
end

	
function selection.for_each_channel_each_step(func)
	for channel in all(selection.channels()) do
		local track = sfx.pattern_track(app.pattern, channel)
		for step in all(selection.steps()) do
			func(track, step)
		end
	end
end


----------------------------------------------------------------------------------------------------
-- Copy / Pase
----------------------------------------------------------------------------------------------------


function selection.pack(mode)
	local result = {
		parts = mode == "rows" and selection.all_parts or parts,
		columns = {}
	}
	for channel = selection.min_channel(), selection.max_channel() do
		local rows = {}
		if channels[channel] then
			local track <const> = sfx.pattern_track(app.pattern, channel)
			local size <const> = sfx.track_size(track)
			for step = selection.min_step(), selection.max_step() do
				if step < size and steps[step] then
					local row = {
						pitch = sfx.track_pitch(track, step),
						instrument = sfx.track_instrument(track, step),
						volume = sfx.track_volume(track, step),
						fx = sfx.track_fx(track, step),
						fx_params = sfx.track_fx_params(track, step),
					}
					add(rows, row)
				else
					add(rows, {})
				end
			end
		end
		add(result.columns, rows)
	end
	return result
end


function selection.unpack(package)
	local starting_channel = selection.min_channel()
	local starting_step = selection.min_step()
	if not package.parts or not package.columns then return false end
	for c, column in ipairs(package.columns) do
		for s, row in ipairs(column) do
			local channel = starting_channel + c - 1
			local step = starting_step + s - 1
			if channel <= 7 then
				local track <const> = sfx.pattern_track(app.pattern, channel)
				if row.pitch and step < sfx.track_size(track) then
					if package.parts & selection.note ~= 0 then
						sfx.set_track_pitch(track, step, row.pitch)
					end
					if package.parts & selection.instrument ~= 0 then
						if not row.instrument then return false end
						sfx.set_track_instrument(track, step, row.instrument)
					end
					if package.parts & selection.volume ~= 0 then
						if not row.volume then return false end
						sfx.set_track_volume(track, step, row.volume)
					end
					if package.parts & selection.fx ~= 0 then
						if not row.fx or not row.fx_params then return false end
						sfx.set_track_fx(track, step, row.fx)
						sfx.set_track_fx_params(track, step, row.fx_params)
					end
				end
			end
		end
	end
	return true
end


----------------------------------------------------------------------------------------------------
-- Undo / Redo
----------------------------------------------------------------------------------------------------


function selection.state()
	return { channels = channels, steps = steps, parts = parts }
end


function selection.set_state(state)
	channels = state.channels
	steps = state.steps
	parts = state.parts
end


----------------------------------------------------------------------------------------------------
-- Helper Functions
----------------------------------------------------------------------------------------------------


function copy_channels()
	local result = {}
	for k, _ in pairs(channels) do
		result[k] = true
	end
	return result
end


function copy_steps()
	local result = {}
	for k, _ in pairs(steps) do
		result[k] = true
	end
	return result
end


function find_first_channel(channel)
	channel = channel or 0
	while channel_not_valid(channel) and channel <= 8 do
		channel += 1
	end
	if channel == 8 then
		return nil
	end
	return channel
end


function find_last_channel(channel)
	channel = channel or 7
	while channel_not_valid(channel) and channel >= -1 do
		channel -= 1
	end
	if channel == -1 then
		return nil
	end
	return channel
end


return selection
:: src/settings.lua
--[[pod_format="raw",created="2024-04-11 08:58:08",modified="2026-02-16 14:12:04",revision=27536]]
local settings = {}

local settings_folder = "/appdata/wavemaker/"
local settings_filepath = "/appdata/wavemaker/settings.pod"
local keys_filepath = "/appdata/wavemaker/keys.pod"


settings.piano_keys = { pitched = {
	{
		offset = -12,
		[0] = "z", "s", "x", "d", "c", "v", "g", "b", "h", "n", "j", "m",
		",", "l", ".", ";", "/"
	},
	{
		offset = 0,
		[0] = "q", "2", "w", "3", "e", "r", "5", "t", "6", "y", "7", "u",
		"i", "9", "o", "0", "p",
	}
}}


settings.guitar_keys = { pitched = {
	{
		offset = 0,
		[0] = "z", "x", "c", "v", "b", "n", "m", ",", ".", "/",
	},
	{
		offset = 5,
		[0] = "a", "s", "d", "f", "g", "h", "j", "k", "l", ";", "'",
	},
	{
	offset = 10,
		[0] = "q", "w", "e", "r", "t", "y", "u", "i", "o", "p", "[", "]", "\\",
	},
	{
	offset = 15,
		[0] = "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "-", "=",
	}
}}


settings.gl_two_handed_keys = { pitched = {
	{
		offset = 0,
		[0] = 
			"z", "x", "c", "v", "b", 
			"a", "s", "d", "f", "g",
			"q", "w", "e", "r", "t",
			"1", "2", "3", "4", "5",
	},
	{
		offset = 11,
		[0] = 
			"n", "m", ",", ".", "/", 
			"h", "j", "k", "l", ";",
			"y", "u", "i", "o", "p",
			"6", "7", "8", "9", "0",
	},
}}


settings.major_thirds_keys = { pitched = {
	{
		offset = 0,
		[0] =
			"z", "x", "c", "v",
			"a", "s", "d", "f",
			"q", "w", "e", "r",
			"1", "2", "3", "4",
	},
	{ offset = 12,
		[0] = "t",
	},
	{
		offset = 12,
		[0] =
			"m", ",", ".", "/",
			"j", "k", "l", ";",
			"u", "i", "o", "p",
			"7", "8", "9", "0",
	},
}}


settings.chromatic_keys = { pitched = {
	{
		offset = 0,
		[0] = "z", "x", "c", "v", "b", "n", "m", ",", ".", "/",
	},
	{
		offset = 10,
		[0] = "a", "s", "d", "f", "g", "h", "j", "k", "l", ";", "'",
	},
	{
	offset = 20,
		[0] = "q", "w", "e", "r", "t", "y", "u", "i", "o", "p", "[", "]", "\\",
	},
	{
	offset = 30,
		[0] = "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "-", "=",
	}
}}

settings.keys = {
	pitched = settings.piano_keys.pitched,
	play = "space",
	rest = "del",
}


settings.user = {
	pitched_layout = "piano-like",
	drag_sensitivity = 0.5,
	sustain_line_enabled = true,
	instrument_square_enabled = true,
	look_back = 4,
	look_ahead = 6,
}


function settings.load()
	mkdir(settings_folder)
	local user_keys = fetch(keys_filepath)
	if user_keys then
		for k, v in pairs(settings.keys) do
			if user_keys[k] then
				settings.keys[k] = user_keys[k]
			end
		end
	end
	local user_settings = fetch(settings_filepath)
	if user_settings then
		for k, v in pairs(settings.user) do
			if user_settings[k] then
				settings.user[k] = user_settings[k]
			end
		end
	end
end


function settings.change_keys(t)
	for k, v in pairs(t) do
		settings.keys[k] = v
	end
	store(keys_filepath, settings.keys)
end


function settings.change_user(t)
	for k, v in pairs(t) do
		settings.user[k] = v
	end
	store(settings_filepath, settings.user)
end


return settings
:: src/sfx/sfx.lua
--[[pod_format="raw",created="2024-04-07 08:22:05",modified="2026-02-16 14:12:04",revision=32022]]
local sfx = {}


----------------------------------------------------------------------------------------------------
-- Stat
----------------------------------------------------------------------------------------------------


function sfx.playing_channels()
	return stat(464)
end


function sfx.music_is_playing()
--	return stat(464) ~= 0
	return stat(466) ~= -1
end


function sfx.channel_is_playing(channel)
	local mask = 1 << channel
	return (stat(464) & mask) ~= 0
end


function sfx.playing_pattern()
	return stat(466)
end


function sfx.playing_lead_channel()
	return stat(467)
end


function sfx.playing_channel_row(channel)
	return stat(400 + channel, 9)
end

function sfx.playing_row()
	return sfx.playing_channel_row(sfx.playing_lead_channel())
end

--[[
--TODO:
stat(400 + c,  0) -- note is held (0 false 1 true)
stat(400 + c,  1) -- channel instrument
stat(400 + c,  2) -- channel vol
stat(400 + c,  3) -- channel pan
stat(400 + c,  4) -- channel pitch
stat(400 + c,  5) -- channel bend
stat(400 + c,  6) -- channel effect
stat(400 + c,  7) -- channel effect_p
stat(400 + c,  8) -- channel tick len
stat(400 + c,  9) -- channel row
stat(400 + c, 10) -- channel row tick
stat(400 + c, 11) -- channel sfx tick
stat(400 + c, 12) -- channel sfx index (-1 if none finished)
stat(400 + c, 13) -- channel last played sfx index 
--]]

----------------------------------------------------------------------------------------------------
-- Header
----------------------------------------------------------------------------------------------------


-- This should probably be configurable?
local baddr <const> = 0x30000


local function paddr()
	-- default 0x030100 = base + 0x000100
	return baddr + peek4(baddr + 0x18) + 0x100
end
local function saddr()
	-- default 0x040000 = base + 0x010000
	return baddr + peek4(baddr + 0x10)
end
local function taddr()
	-- default 0x050000 = base + 0x020000
	return baddr + peek4(baddr + 0x14)
end


local function defaddr()
	return peek(baddr + 0x6) & 0x01 ~= 0
end


function sfx.num_instruments()
	return peek2(baddr)
end


function sfx.num_tracks()
	if defaddr() then
		-- Since Picotron 0.1.0h the default tracker is supposed
		-- to support 384 tracks, but can only use 256, since in the
		-- file format there is only 1 byte to store track IDs.
		-- Also, the info stored at this address in sfx files says
		-- 512, which correspong to neither...
		return 256
	else
		return peek2(baddr + 0x2)
	end
end


function sfx.num_patterns()
	if defaddr() then
		return 128
	else
		return peek2(baddr + 0x4)
	end
end


sfx.default_addressing = defaddr


function sfx.instruments_address()
	return saddr()
end


function sfx.tracks_address()
	return taddr()
end


function sfx.patterns_address()
	return paddr()
end


function sfx.tick_length()
	return peek2(baddr + 0x20)
end


function sfx.set_tick_length(value)
	return poke2(baddr + 0x20, value)
end


function sfx.default_length()
	return peek2(baddr + 0x22)
end


function sfx.set_default_length(value)
	-- TODO: doesn't seem to work?
	return poke2(baddr + 0x22, value)
end


function sfx.default_speed()
	return peek2(baddr + 0x26)
end


function sfx.set_default_speed(value)
	-- TODO: doesn't seem to work?
	return poke2(baddr + 0x26, value)
end


----------------------------------------------------------------------------------------------------
-- Pattern Info
----------------------------------------------------------------------------------------------------


function sfx.pattern_length(pattern)
	return peek2(paddr() + (pattern * 20) + 10)
end


function sfx.set_pattern_length(pattern, value)
	poke2(paddr() + (pattern * 20) + 10, value)
end

function sfx.pattern_loop_start(pattern)
	return (peek(paddr() + (pattern * 20) + 8) & 0x01) != 0
end


function sfx.set_pattern_loop_start(pattern, bool)
	local old = peek(paddr() + (pattern * 20) + 8)
	if bool then
		poke(paddr() + (pattern * 20) + 8, old | 0x01)
	else
		poke(paddr() + (pattern * 20) + 8, old & (~ 0x01))
	end
end


function sfx.pattern_loop_end(pattern)
	return (peek(paddr() + (pattern * 20) + 8) & 0x02) != 0
end


function sfx.set_pattern_loop_end(pattern, bool)
	local old = peek(paddr() + (pattern * 20) + 8)
	if bool then
		poke(paddr() + (pattern * 20) + 8, old | 0x02)
	else
		poke(paddr() + (pattern * 20) + 8, old & (~ 0x02))
	end
end


function sfx.pattern_loop_stop(pattern)
	return (peek(paddr() + (pattern * 20) + 8) & 0x04) != 0
end


function sfx.set_pattern_loop_stop(pattern, bool)
	local old = peek(paddr() + (pattern * 20) + 8)
	if bool then
		poke(paddr() + (pattern * 20) + 8, old | 0x04)
	else
		poke(paddr() + (pattern * 20) + 8, old & (~ 0x04))
	end
end


function sfx.pattern_channels(pattern)
	return peek(paddr() + (pattern * 20) + 9)
end


function sfx.channel_is_muted(pattern, channel)
	local channel_mutes = peek(paddr() + (pattern * 20) + 9)
	local muted = (channel_mutes & (1 << channel)) == 0
	return muted
end


function sfx.mute_channel(pattern, channel, mute)
	local channel_mutes = peek(paddr() + (pattern * 20) + 9)
	channel_mutes &= ~(1 << channel)
	channel_mutes |= (mute and 0 or 1) << channel
	poke(paddr() + (pattern * 20) + 9, channel_mutes)
end


function sfx.pattern_track(pattern, channel)
	return peek(paddr() + pattern * 20 + channel)
end


function sfx.set_pattern_track(pattern, channel, track)
	poke(paddr() + pattern * 20 + channel, track)
end


function sfx.remove_pattern(pattern)
	local last_pattern = sfx.num_patterns() - 1
	local addr = paddr() + pattern * 20
	local size = (last_pattern - pattern) * 20
	memcpy(addr, addr + 20, size)
	local last_addr = paddr() + last_pattern * 20
	memset(last_addr, 0, 20)
end


function sfx.insert_pattern(pattern)
	local last_pattern = sfx.num_patterns() - 1
	local addr = paddr() + pattern * 20
	local size = (last_pattern - pattern) * 20
	memcpy(addr + 20, addr, size)
	memset(addr, 0, 20)
end


function sfx.copy_pattern(pattern)
	local addr = paddr() + pattern * 20
	local ud = userdata("u8", 20)
	ud:peek(addr)
	return ud
end


function sfx.paste_pattern(pattern, ud)
	local width, height, typ = ud:attribs()
	assert(width == 20 and height == 1 and typ == "u8")
	local addr = paddr() + pattern * 20
	ud:poke(addr)
end


----------------------------------------------------------------------------------------------------
-- Track Info
----------------------------------------------------------------------------------------------------


local function tstride()
	if defaddr() then
		return 328 -- i.e. 64 rows * 5 columns + 8 byte header
	else
		return 328 -- TODO: how to know the track size?
	end
end


function sfx.track_size(track)
	return peek2(taddr() + (track * tstride())) -- TODO
end


function sfx.set_track_size(track, value)
	poke2(taddr() + (track * tstride()), value)
end


function sfx.pattern_max_size(pattern)
	local max_length = 0
	for channel = 0, 7 do
		local track = sfx.pattern_track(pattern, channel)
		max_length = max(sfx.track_size(track), max_length)
	end
	return max_length
end


function sfx.track_speed(track)
	return peek(taddr() + (track * tstride()) + 2)
end


function sfx.set_track_speed(track, val)
	return poke(taddr() + (track * tstride()) + 2, val)
end


function sfx.track_loop0(track)
	return peek(taddr() + (track * tstride()) + 3)
end


function sfx.set_track_loop0(track, val)
	return poke(taddr() + (track * tstride()) + 3, val)
end


function sfx.track_loop1(track)
	return peek(taddr() + (track * tstride()) + 4)
end


function sfx.set_track_loop1(track, val)
	poke(taddr() + (track * tstride()) + 4, val)
end


function sfx.track_is_looping(track)
	local loop0 <const> = sfx.track_loop0(track)
	local loop1 <const> = sfx.track_loop1(track)
	return loop1 > loop0
end


function sfx.track_length(track)
	local loop0 <const> = sfx.track_loop0(track)
	local loop1 <const> = sfx.track_loop1(track)
	local length = max(loop0, loop1)
	if length == 0 then
		return sfx.default_length()
	end
	return length
end	


function sfx.track_delay(track)
	return peek(taddr() + (track * tstride()) + 5)
end


function sfx.set_track_delay(track, val)
	poke(taddr() + (track * tstride()) + 5, val)
end


function sfx.track_flags(track)
	return peek(taddr() + (track * tstride()) + 6)
end


function sfx.set_track_flags(track, flags)
	return poke(taddr() + (track * tstride()) + 6, flags)
end


function sfx.track_unused(track)
	return peek(taddr() + (track * tstride()) + 7)
end


function sfx.set_track_unused(track, flags)
	return poke(taddr() + (track * tstride()) + 7, flags)
end


----------------------------------------------------------------------------------------------------
-- Track Notes
----------------------------------------------------------------------------------------------------


function sfx.track_row(track, step)
	local row = userdata("u8", 5)
	row:peek(taddr() + 8 + (track * tstride()) + step + (0 * 64), 0, 1)
	row:peek(taddr() + 8 + (track * tstride()) + step + (1 * 64), 1, 1)
	row:peek(taddr() + 8 + (track * tstride()) + step + (2 * 64), 2, 1)
	row:peek(taddr() + 8 + (track * tstride()) + step + (3 * 64), 3, 1)
	row:peek(taddr() + 8 + (track * tstride()) + step + (4 * 64), 4, 1)
	return row
end


function sfx.set_track_row(track, step, row)
	row:poke(taddr() + 8 + (track * tstride()) + step + (0 * 64), 0, 1)
	row:poke(taddr() + 8 + (track * tstride()) + step + (1 * 64), 1, 1)
	row:poke(taddr() + 8 + (track * tstride()) + step + (2 * 64), 2, 1)
	row:poke(taddr() + 8 + (track * tstride()) + step + (3 * 64), 3, 1)
	row:poke(taddr() + 8 + (track * tstride()) + step + (4 * 64), 4, 1)
end


local empty_row_ud <const> = userdata("u8", 5, "ffffff0000")
function sfx.empty_row()
	return empty_row_ud
end


function sfx.track_pitch(track, step)
	return peek(taddr() + 8 + (track * tstride()) + step)
end


function sfx.set_track_pitch(track, step, v)
	return poke(taddr() + 8 + (track * tstride()) + step, v)
end


function sfx.track_instrument(track, step)
	return peek(taddr() + 8 + (track * tstride()) + step + 64)
end


function sfx.set_track_instrument(track, step, v)
	return poke(taddr() + 8 + (track * tstride()) + step + 64, v)
end


function sfx.track_volume(track, step)
	return peek(taddr() + 8 + (track * tstride()) + step + (2 * 64))
end


function sfx.set_track_volume(track, step, v)
	return poke(taddr() + 8 + (track * tstride()) + step + (2 * 64), v)
end


function sfx.track_fx(track, step)
	return peek(taddr() + 8 + (track * tstride()) + step + (3 * 64))
end


function sfx.set_track_fx(track, step, v)
	return poke(taddr() + 8 + (track * tstride()) + step + (3 * 64), v)
end


function sfx.track_fx_params(track, step)
	return peek(taddr() + 8 + (track * tstride()) + step + (4 * 64))
end


function sfx.track_fx_param0(track, step)
	return peek(taddr() + 8 + (track * tstride()) + step + (4 * 64)) >> 4
end


function sfx.track_fx_param1(track, step)
	return peek(taddr() + 8 + (track * tstride()) + step + (4 * 64)) & 0xf
end


function sfx.set_track_fx_params(track, step, v)
	return poke(taddr() + 8 + (track * tstride()) + step + (4 * 64), v)
end


function sfx.set_track_fx_param0(track, step, v)
	local previous = peek(taddr() + 8 + (track * tstride()) + step + (4 * 64))
	return poke(taddr() + 8 + (track * tstride()) + step + (4 * 64), (previous & 0x0f) | (v << 4))
end


function sfx.set_track_fx_param1(track, step, v)
	local previous = peek(taddr() + 8 + (track * tstride()) + step + (4 * 64))
	return poke(taddr() + 8 + (track * tstride()) + step + (4 * 64), (previous & 0xf0) | (v & 0x0f))
end


----------------------------------------------------------------------------------------------------
-- Synth: Instrument Info
----------------------------------------------------------------------------------------------------


function sfx.instrument_name(instrument)
	local inst_addr = saddr() + instrument * 0x200
	local length = 16
	for j = 15, 0, -1 do
		if peek(inst_addr + 496 + j) == 0 then
			length = j
		end
	end
	return chr(peek(inst_addr + 496, length))
end


function sfx.set_instrument_name(instrument, name)
	if type(name) ~= "string" then return end
	local inst_addr = saddr() + instrument * 0x200
	memset(inst_addr + 496, 0, 16)
	poke(inst_addr + 496, ord(name, 1, min(16, #name)))
end


function sfx.instrument_flag(instrument, flag)
	local inst_addr = saddr() + instrument * 0x200
	local addr = inst_addr + 0x1df
	return (peek(addr) & flag) > 0
end


function sfx.set_instrument_flag(instrument, flag, value)
	local inst_addr = saddr() + instrument * 0x200
	local addr = inst_addr + 0x1df
	local other_flags = peek(addr) & (~ flag)
	if value then
		poke(addr, other_flags | flag)
	else
		poke(addr, other_flags)
	end
end


function sfx.toggle_instrument_flag(instrument, flag)
	local inst_addr = saddr() + instrument * 0x200
	local addr = inst_addr + 0x1df
	local previous = peek(addr)
	poke(addr, previous ^^ flag)
end


function sfx.wavetable_info(instrument, wt_index)
	local inst_addr = saddr() + instrument * 0x200
	local wt_4defs_addr = inst_addr + 0x1e0 -- start of the 4 wt definitions
	local wt_def_addr = wt_4defs_addr + wt_index * 4
	local addr0, addr1, width_bits, wt_height = peek(wt_def_addr,4)
	local dat_addr = (addr0 << 8) | (addr1 << 16)
	local wt_width = 1 << width_bits
	return dat_addr, wt_width, wt_height
end


----------------------------------------------------------------------------------------------------
-- Synth: Node Tree
----------------------------------------------------------------------------------------------------


sfx.nodes = {}
for n = 0, 7 do
	sfx.nodes[n] = {
		parent = nil, -- id of the parent
		children = {}, -- list of direct references to the children
		type = nil,
	}
end
	

local function depth_walk(root, pre_fun, post_fun, depth)
	if (not depth) depth = 0
	if depth > 8 then
		-- TODO: remove notification
		notify("*** Deep recursion: cycle in synth nodes? ***")
		return
	end
	if (pre_fun) pre_fun(root)
	for i = 1, #root.children do
		local child = root.children[i]
		if child.type != 0 then
			depth_walk(child, pre_fun, post_fun, depth + 1)
		end
	end
	if (post_fun) post_fun(root)
end


function sfx.refresh_nodes(instrument)
	for n = 0, 7 do
		sfx.nodes[n].id = n
		sfx.nodes[n].children = {}
		sfx.nodes[n].older_sibling = nil
		sfx.nodes[n].height = nil -- TODO: or 0?
		sfx.nodes[n].position = nil
	end
	sfx.root = sfx.nodes[0]
	sfx.root.free_nodes = 7
	--- printh("* refresh *")
	for n = 0, 7 do
		local type = sfx.node_type(instrument, n)
		local op = sfx.node_op(instrument, n)
		local parent_id = sfx.node_parent(instrument, n)
		--- printh("" .. parent_id .. " -> " .. n .. " type=" .. type .. " op=" .. op)
		sfx.nodes[n].parent = sfx.nodes[parent_id]
		sfx.nodes[n].type = type
		sfx.nodes[n].op = op
		sfx.nodes[n].last_child = function(self)
			if (#self.children == 0) return self
			return self.children[#self.children]:last_child()
		end
		if type != 0 and n != 0 then
			add(sfx.nodes[n].parent.children, sfx.nodes[n])
			sfx.root.free_nodes -= 1
		end
	end
	
	depth_walk(
		sfx.root,
		nil,
		function(node)
			if #node.children == 0 then
				node.height = 1
			else
				local h = 0
				for i = 1, #node.children do
					local child = node.children[i]
					if i > 1 then
						child.older_sibling = node.children[i - 1]
					end
					h += child.height
				end
				node.height = h
			end
		end
	)

	sfx.root.position = { row = 0, column = 0 }
	depth_walk(
		sfx.root,
		function(node)
			local row = node.position.row
			for i = 1, #node.children do
				node.children[i].position = {
					column = node.position.column + 1,
					row = row,
				}
				row += node.children[i].height
			end
		end,
		nil
	)
end


function sfx.add_node(instrument, parent_id, node_type, node_op, target_id, child_id)
	local parent = sfx.nodes[parent_id]
	
	if (not parent) notify("invalid parent (nil)"); return
	if (parent.type >= 8) notify("invalid parent (filter)"); return

	if target_id >= 8 then
		-- no room!
		return
	end	

	sfx.insert_node(instrument, target_id, parent_id, child_id)
	
	if node_type == 0x2 and node_op == 1 then
		-- FM mod osc
		sfx.set_node_type(instrument, target_id, node_type)
		sfx.set_node_op(instrument, target_id, node_op)
		sfx.set_node_param_val1(instrument, target_id, 0, 0x20) -- volume
		sfx.set_node_param_flags(instrument, target_id, 2, 0x02) -- not quantized, and relation + for tune
		sfx.set_node_param_flags(instrument, target_id, 3, 0x01) -- relation + for bend
	elseif node_type == 0x2 and node_op == 2 then
		-- Ring mod osc
		sfx.set_node_type(instrument, target_id, node_type)
		sfx.set_node_op(instrument, target_id, node_op)
		sfx.set_node_param_val1(instrument, target_id, 0, 0x20) -- volume
		sfx.set_node_param_flags(instrument, target_id, 2, 0x01) -- not quantized, and relation + for tune
		sfx.set_node_param_flags(instrument, target_id, 3, 0x01) -- relation + for bend
	elseif node_type == 0x2 then
		-- Osc
		sfx.set_node_type(instrument, target_id, node_type)
		sfx.set_node_op(instrument, target_id, node_op)
		sfx.set_node_param_val1(instrument, target_id, 0, 0x30) -- volume
		sfx.set_node_param_flags(instrument, target_id, 0, 0x02) -- relation * for volume
		sfx.set_node_param_flags(instrument, target_id, 1, 0x01) -- relation + for pan
		sfx.set_node_param_flags(instrument, target_id, 2, 0x21) -- quantized, and relation + for tune
		sfx.set_node_param_flags(instrument, target_id, 3, 0x01) -- relation + for bend
	elseif node_type == 0xa then
		sfx.set_node_type(instrument, target_id, node_type)
		sfx.set_node_param_val1(instrument, target_id, 3, 0x40) -- mix
	else
		sfx.set_node_type(instrument, target_id, node_type)
	end
	return target_id
end


----------------------------------------------------------------------------------------------------
-- Synth: Node Configuration
----------------------------------------------------------------------------------------------------


function sfx.delete_node(instrument, node_id)
	local deleted_node_parent = sfx.node_parent(instrument, node_id)
	local inst_addr = saddr() + instrument * 0x200
	-- move everything up
	for j = node_id, 7 do
		memcpy(inst_addr + j * 0x20, inst_addr + (j + 1) * 0x20, 0x20)
	end
	memset(inst_addr + 7 * 0x20, 0, 0x20)
	-- fix parents
	for j = 0, 6 do
		local parent = sfx.node_parent(instrument, j)
		if parent == node_id then
			sfx._set_node_parent(instrument, j, deleted_node_parent)
		elseif parent > node_id then
			sfx._set_node_parent(instrument, j, parent - 1)
		end
	end
end


function sfx.insert_node(instrument, node_id, parent_id, child_id)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node_id * 0x20
	-- move everything down
	for j = 7, node_id + 1, -1 do
		memcpy(inst_addr + j * 0x20, inst_addr + ( j - 1) * 0x20, 0x20)
	end
	memset(node_addr, 0, 0x20)
	-- fix parents
	poke(node_addr, parent_id)
	for j = 0, 7 do
		local parent = sfx.node_parent(instrument, j)
		if parent >= node_id then
			sfx._set_node_parent(instrument, j, parent + 1)
		end
	end
	if child_id then
		if child_id >= node_id then
			child_id += 1
		end
		if child_id <= 7 then
			sfx._set_node_parent(instrument, child_id, node_id)
		end
	end
end


function sfx.node_parent(instrument, node)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr + 0) & 0x7	
end

function sfx._set_node_parent(instrument, node, parent)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	local previous = peek(node_addr + 0)
	poke(node_addr + 0, (previous & ~0x7) | (parent & 0x7))
end

function sfx.node_op(instrument, node)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr) >> 4
end

function sfx.set_node_op(instrument, node, op)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	local previous = peek(node_addr)
	poke(node_addr, (previous & 0x0f) | (op << 4))
end

function sfx.node_type(instrument, node)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr + 1) & 0xf
end

function sfx.set_node_type(instrument, node, type)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	local previous = peek(node_addr + 1)
	poke(node_addr + 1, (previous & 0xf0) | (type & 0x0f))
end

function sfx.node_osc_wavetable(instrument, node)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr + 1) >> 4
end

function sfx.set_node_osc_wavetable(instrument, node, wt)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	local previous = peek(node_addr + 1)
	poke(node_addr + 1, (previous & 0x0f) | (wt << 4))
end

function sfx.node_flags(instrument, node)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr + 2)
end

function sfx.set_node_flags(instrument, node, flags)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 2, flags)
end

-- node_addr + 3 is unused

-- 0 <= p <= 7
function sfx.node_param(instrument, node, p)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	local flags,val1,val0,env = peek(node_addr + 4 + (4 * p), 4)
	return flags, val1, val0, env
end


function sfx.param_scale(flags)
	local bits = 0
	if flags & 0xc0 == 0 then return 1 end
	if flags & 0x40 >  0 then
		bits += 2
	end
	if flags & 0x80 >  0 then
		bits += 2
	end
	return (flags & 0x20) > 0 and 1 / (1 << bits) or (1 << bits)
end


function sfx.set_node_param_flags(instrument, node, p, flags)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 4 + (4 * p), flags)
end

function sfx.set_node_param_val1(instrument, node, p, val1)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 4 + (4 * p) + 1, val1)
end

function sfx.set_node_param_val0(instrument, node, p, val0)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 4 + (4 * p) + 2, val0)
end

function sfx.set_node_param_env(instrument, node, p, env)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 4 + (4 * p) + 3, env)
end

function sfx.node_wavetable_info(instrument, node)
	local inst_addr = saddr() + instrument * 0x200
	local wt_4defs_addr = inst_addr + 0x1e0 -- start of the 4 wt definitions
	local node_addr = inst_addr + node * 0x20
	local wt_index = (peek(node_addr+1)>>4)
	local wt_def_addr = wt_4defs_addr + wt_index * 4
	local addr0, addr1, width_bits, wt_height = peek(wt_def_addr,4)
	local dat_addr = (addr0 << 8) | (addr1 << 16)
	local wt_width = 1 << width_bits
	return dat_addr, wt_width, wt_height
end

function sfx.node_wavetable_index(instrument, node)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	local wt_index = (peek(node_addr+1)>>4)
	return wt_index
end


----------------------------------------------------------------------------------------------------
-- Synth: Envelopes
----------------------------------------------------------------------------------------------------


function sfx.env_type(instrument, env)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr)
end


function sfx.set_env_type(instrument, env, type)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr, type)
end


function sfx.env_flags(instrument, env)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 1)
end


function sfx.set_env_flags(instrument, env, flags)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 1, flags)
end


function sfx.env_speed(instrument, env)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 2)
end


function sfx.set_env_speed(instrument, env, val)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 2, val)
end


function sfx.env_loop0(instrument, env)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 3)
end


function sfx.set_env_loop0(instrument, env, val)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 3, val)
end


function sfx.env_loop1(instrument, env)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 4)
end


function sfx.set_env_loop1(instrument, env, val)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 4, val)
end


function sfx.env_start(instrument, env)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 5)
end


function sfx.set_env_start(instrument, env, val)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 5, val)
end


function sfx.env_param(instrument, env, param)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 8 + param)
end


function sfx.set_env_param(instrument, env, param, val)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 8 + param, val)
end


return sfx
:: src/soft_wrap.lua
--[[pod_format="raw",created="2025-03-07 11:09:14",modified="2026-02-16 14:12:04",revision=8105]]
local soft_wrap = {}

-- Soft-wraps a very tiny subset of markdown.
function soft_wrap.parse(text, width, with_small_font, transform)
	local function prefix(s) if with_small_font then return "\014"..s else return s end end
	local space_width <const> = print(prefix(" "), -1000, -1000) + 1000
	local lines = {}
	local context = "default" -- "default", "paragraph", "list" or "code"
	local x = 0
	
	local function add_line_break()
		if #lines == 0 then
			return
		end
		if lines[#lines] ~= "" then
			add(lines, "")
		end
		x = 0
	end
	
	local function add_paragraph_break()
		if #lines == 0 then
			return
		end
		if lines[#lines] ~= "" then
			add(lines, "")
			add(lines, "")
		elseif #lines > 1 and lines[#lines - 1] ~= "" then
			add(lines, "")
		end
		x = 0
	end
	
	local function add_line(line)
		if lines[#lines] == "" then
			lines[#lines] = line
		elseif context == "code" and line == "" then
			add(lines, " ")
		else
			add(lines, line)
		end
		x = 0
	end

	local function add_word(word)
		local word = transform and transform(word) or word
		local dx = print(prefix(word), -1000, -1000) + 1000
		if lines[#lines] == "" then
			lines[#lines] = word
			x += dx
		elseif x + space_width + dx >= width then
			-- Start a new line
			add(lines, "")
			x = 0
			if context == "list" then
				lines[#lines] ..= "  "
				x += 2 * space_width
			end
			lines[#lines] ..= word
			x += dx
		else
			lines[#lines] ..= " " .. word
			x += space_width + dx
		end
	end
	
	for source_line in text:gmatch("([^\n]*)\n") do
		if context == "code" then
			if source_line:find("^```") then
				context = "default"
				indentation = 0
				add_paragraph_break()
			else
				source_line = transform and transform(source_line) or source_line
				add_line(source_line)
			end
			goto next_line
		end
		if source_line:find("^```") then
			context = "code"
			goto next_line
		end
		if source_line:find("^#+") then
			add_paragraph_break()
			add_line(source_line)
			add_paragraph_break()
			context = "default"
			goto next_line
		end
		if source_line:find("^%s*$") then
			add_paragraph_break()
			context = "default"
			goto next_line
		end
		if source_line:find("^%s*-") then
			add_line_break()
			context = "list"
		end
		for word in source_line:gmatch("[^%s]+") do
			add_word(word)
		end
		::next_line::
	end
	
	return lines
end


return soft_wrap
:: src/ui/envelopes.lua
--[[pod_format="raw",created="2024-04-14 20:24:26",modified="2026-02-16 14:12:04",revision=27841]]
local app = require "src/app.lua"
local sfx = require "src/sfx/sfx.lua"
local undo = require "src/undo.lua"
local ui = require "src/ui/ui.lua"
local ui_visual = require "src/ui/visual.lua"


local ui_envelopes = {}

	
-------------------------------------------------------------------------------
-- Envelope Panel
-------------------------------------------------------------------------------


local env_type_names = { [0] = "adsr", "lfo", "custom" }
local lfo_shape_names = { [0] = "sine", "tri", "saw", "isaw", "square", "pulse" }


function ui_envelopes.make_label(env_id)
	local env_type = sfx.env_type(app.instrument, env_id)
	return env_type_names[env_type] .. "\-f " .. env_id
end


function ui_envelopes.attach_panel(parent, el)
	el.width =
		el.large and (2 * app.mod_width + app.synth_gap + 4) 
		or app.mod_width + 5
	el.height = app.mod_height
	parent:attach(el)

	el:attach(ui.create_menu_button {
		x = 2, y = 1, 
		env_id = el.env_id,
		get_label = function()
			return ui_envelopes.make_label(el.env_id)
		end,
		fg = 7,
		highlight = 29,
		items = {
			{ label = "adsr", action = function() sfx.set_env_type(app.instrument, el.env_id, 0); app.refresh_gui = true end },
			{ label = "lfo", action = function() sfx.set_env_type(app.instrument, el.env_id, 1); app.refresh_gui = true end },
			{ label = "custom", action = function() sfx.set_env_type(app.instrument, el.env_id, 2); app.refresh_gui = true end },
		}
	})
	
	if not el.large then
		ui_envelopes.attach_advanced_button(el, { x = el.width - 17, y = 1 })
	end

	if el.large or not app.env_advanced[el.env_id] then 

		local env_type = sfx.env_type(app.instrument, el.env_id)	
		if env_type == 0 then
			-- ADSR ----------------------------------------------
			local labels = { [0] = "a", "d", "s", "r" }
			for i = 0, 3 do
				ui_envelopes.attach_slider(el, { x = 3 + 13 * i, y = 13, slider_height = 40, env_id = el.env_id, param = i, label = labels[i] })
			end
			
		elseif env_type == 1 then
			-- LFO -----------------------------------------------
			local items = {}
			for i = 0, #lfo_shape_names do
				add(items, { label = lfo_shape_names[i], action = function() sfx.set_env_param(app.instrument, el.env_id, 5, i) end })
			end
			--[[ not yet implemented?
			ui_envelopes.attach_menu_button(el, {
				x = 14, y = 12, 
				env_id = el.env_id,
				get_label = function()
					local shape = sfx.env_param(app.instrument, el.env_id, 5)
					return lfo_shape_names[shape] or "???"
				end,
				fg = 5,
				highlight = 29,
				items = items,
			})
			]]--
			ui_envelopes.attach_slider(el, { x = 8, y = 13, slider_height = 40, env_id = el.env_id, param = 4, label = "freq" })
			ui_envelopes.attach_slider(el, { x = 34, y = 13, slider_height = 40, env_id = el.env_id, param = 6, label = "phase" })
			

		else
			-- Custom -------------------------------------
			el:attach(ui.create_toggle {
				x = 4, y = 13,
				label = "lerp",
				fg = 56,
				get = function(self) return
					(sfx.env_flags(app.instrument, el.env_id) & 0x01) > 0
				end,
				set = function(self, v)
					local flags = sfx.env_flags(app.instrument, el.env_id)
					sfx.set_env_flags(app.instrument, el.env_id, (flags & ~0x01) | (v and 0x01 or 0x00))
				end,
			})
			ui_envelopes.attach_custom_editor(el, { x = 4, y = 21 })
			el:attach(ui.create_num_field {
				x = 4, y = 64,
				width = 56,
				label = "speed:",
				field_fg = 29,
				visible = function() return true end,
				get = function() return sfx.env_speed(app.instrument, el.env_id) end,
				set = function(v) sfx.set_env_speed(app.instrument, el.env_id, v) end,
			})
		end
	end
	
	if el.large or app.env_advanced[el.env_id] then
		el:attach(ui.create_toggle {
			x = el.width - app.mod_width + 4, y = 14,
			label = "loop",
			fg = 56,
			visible = function(self) return sfx.env_type(app.instrument, el.env_id) != 2 end,
			get = function(self) return
				(sfx.env_flags(app.instrument, el.env_id) & 0x10) > 0
			end,
			set = function(self, v)
				local flags = sfx.env_flags(app.instrument, el.env_id)
				sfx.set_env_flags(app.instrument, el.env_id, (flags & ~0x10) | (v and 0x10 or 0x00))
			end,
		})
		el:attach(ui.create_num_field {
			x = el.width - app.mod_width + 0, y = 24,
			label = "speed:",
			field_fg = 29,
			visible = function() return (sfx.env_flags(app.instrument, el.env_id) & 0x10 > 0) or (sfx.env_type(app.instrument, el.env_id) == 2) end,
			get = function() return sfx.env_speed(app.instrument, el.env_id) end,
			set = function(v) sfx.set_env_speed(app.instrument, el.env_id, v) end,
		})
		el:attach(ui.create_num_field {
			x = el.width - app.mod_width + 0, y = 34,
			label = "start:",
			field_fg = 28,
			onclick = function() if (not el.large) ui_visual.open_custom_envelope(el.env_id) end,
			onrelease = function() if (not el.large) ui_visual.close() end,
			visible = function() return (sfx.env_flags(app.instrument, el.env_id) & 0x10 > 0) or (sfx.env_type(app.instrument, el.env_id) == 2) end,
			get = function() return sfx.env_start(app.instrument, el.env_id) end,
			set = function(v) sfx.set_env_start(app.instrument, el.env_id, v) end,
		})
		el:attach(ui.create_toggle {
			x = el.width - app.mod_width + 4, y = 44,
			label = "rnd start",
			fg = 56,
			visible = function(self) return (sfx.env_flags(app.instrument, el.env_id) & 0x10 > 0) or (sfx.env_type(app.instrument, el.env_id) == 2) end,
			get = function(self) return
				(sfx.env_flags(app.instrument, el.env_id) & 0x08) > 0
			end,
			set = function(self, v)
				local flags = sfx.env_flags(app.instrument, el.env_id)
				sfx.set_env_flags(app.instrument, el.env_id, (flags & ~0x08) | (v and 0x08 or 0x00))
			end,
		})
		el:attach(ui.create_num_field {
				x = el.width - app.mod_width + 0, y = 54,
				label = "loop0:",
				field_fg = 26,
				onclick = function() if (not el.large) ui_visual.open_custom_envelope(el.env_id) end,
				onrelease = function() if (not el.large) ui_visual.close() end,
				visible = function() return (sfx.env_flags(app.instrument, el.env_id) & 0x10 > 0) or (sfx.env_type(app.instrument, el.env_id) == 2) end,
				get = function() return sfx.env_loop0(app.instrument, el.env_id) end,
				set = function(v) sfx.set_env_loop0(app.instrument, el.env_id, v) end,
		})
		el:attach(ui.create_num_field {
				x = el.width - app.mod_width + 0, y = 64,
				label = "loop1:",
				field_fg = 10,
				onclick = function() if (not el.large) ui_visual.open_custom_envelope(el.env_id) end,
				onrelease = function() if (not el.large) ui_visual.close() end,
				visible = function() return (sfx.env_flags(app.instrument, el.env_id) & 0x10 > 0) or (sfx.env_type(app.instrument, el.env_id) == 2) end,
				get = function() return sfx.env_loop1(app.instrument, el.env_id) end,
				set = function(v) sfx.set_env_loop1(app.instrument, el.env_id, v) end,
		})
	end
	
	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 8)
		if self.large then
			rectfill(1, 0, self.width - 2, 10, 18)
		else
			rectfill(1, 0, self.width - 19, 10, 18)
		end
	end
	
	function el:click()
		return true
	end
		
	return el
end


function ui_envelopes.attach_advanced_button(parent, el)
	el.width = 16
	el.height = 9
	el.cursor = "pointer"
	parent:attach(el)
	function el:draw()
--		spr(39, 1, 1)
		if app.env_advanced[parent.env_id] then
			spr(133, 0, 0)
		else
			spr(132, 0, 0)
		end
	end
	function el:tap()
		app.env_advanced[parent.env_id] = not app.env_advanced[parent.env_id]
		app.refresh_gui = true
	end
	return el
end

	
-------------------------------------------------------------------------------
-- Slider Widget
-------------------------------------------------------------------------------


function ui_envelopes.attach_slider(parent, el)
	el.width = 13
	el.height = el.slider_height + 20
	el.cursor = "dial"
	parent:attach(el)
	function el:draw()
		---rectfill(0, 0, self.width - 1, self.height - 1, 7)
		local oy = 9
		for i = 0, 8, 1 do
			local h = math.floor(0.5 + (i / 8) * (el.slider_height - 1))
			if i % 8 == 0 then
				line(0, oy + el.slider_height - 1 - h, 12, oy + el.slider_height - 1 - h, 7)
			elseif i % 4 == 0 then
				line(2, oy + el.slider_height - 1 - h, 10, oy + el.slider_height - 1 - h, 7)
			else
				line(4, oy + el.slider_height - 1 - h, 8, oy + el.slider_height - 1 - h, 7)
			end
		end
		local val = sfx.env_param(app.instrument, self.env_id, self.param)
		local h = math.floor(0.5 + (val / 255) * (el.slider_height - 1))
		spr(60, 2, oy + el.slider_height - 1 - h - 3)
		line(6, oy, 6, oy + el.slider_height - 1, 59)
		if (self.dragged) pal(15, 7)
		spr(61, 2, oy + el.slider_height - 1 - h - 3)
		pal(15, 15)
		clip()
		ui.print_centered(self.label, 4 + 3, 0, 56)
		ui.print_centered(tostr(val), 4 + 3, self.height - 7, self.dragged and 55 or 56)
	end
	--[[function el:update(msg)
		if (app.has_modal()) return
		local mx, my, mb = mouse()
		if mb != 0 then
			self.hovered = self.dragged != nil
		else
			self.hovered = self.sx <= mx and mx < self.sx + self.width
				and self.sy <= my and my < self.sy + self.height
		end
	end]]
	function el:click(msg)
		undo.checkpoint()
		self.cursor = 0
		self.dragged = true
	end
	function el:drag(msg)
		if self.dragged then
			local delta = ui.mouse_lock()
			local old = sfx.env_param(app.instrument, self.env_id, self.param)
			local new = old - delta
			new = mid(0, new, 255)
			sfx.set_env_param(app.instrument, self.env_id, self.param, new)
		end
	end
	function el:release(msg)
		ui.mouse_unlock()
		self.cursor = "dial"
		self.dragged = nil
	end
	return el
end


-------------------------------------------------------------------------------
-- Custom Envelopes Editor
-------------------------------------------------------------------------------


function ui_envelopes.attach_custom_editor(parent, el)
	el.width = 50
	el.height = 42
	el.cursor = "crosshair"
	parent:attach(el)
	el.env_id = parent.env_id
	el.draw = ui_visual.draw_custom_envelope
	function el:drag(msg)
		local param = mid(0, (msg.mx - 1) \ 3, 15)
		local val = ((self.height - 1 - msg.my) * 255) / (self.height - 2)
		local val = mid(0, math.floor(0.5 + val), 255)
		sfx.set_env_param(app.instrument, parent.env_id, param, val)
	end
	function el:update()
		local mx, my, mb = mouse()
		if
			self.sx <= mx and mx < self.sx + self.width
			and self.sy <= my and my < self.sy + self.height
		then
			local param = mid(0, (mx - self.sx - 1) \ 3, 15)
			self.selected = param
		else
			self.selected = nil
		end
	end
	return el
end


return ui_envelopes
:: src/ui/help.lua
--[[pod_format="raw",created="2026-02-11 10:17:11",modified="2026-02-16 14:12:04",revision=5356]]
local app = require "src/app.lua"
local ui = require "src/ui/ui.lua"
local soft_wrap = require "src/soft_wrap.lua"


local ui_help = {}


-------------------------------------------------------------------------------
-- Locals
-------------------------------------------------------------------------------


local function create_text_viewer(el)
	el.start = 1
	ui.head():new(el)
	
	local raw_text = el.file and fetch(el.file)
	raw_text = raw_text or [[(could not find "manual.txt")]]
	el.text = soft_wrap.parse(raw_text, el.width - 2, true, nil)
	
	function el:draw(msg)
		rrectfill(1, 1, self.width - 2, self.height - 2, 0, 7)
		local l = self.start
		local y = 0
		color(5)
		cursor(2, 2)
		while y < self.height - 2 and l <= #self.text do
--			if small_font then
--				print(string.lower(self.text[l]))
--				y += 6
--			else
				print("\014"..self.text[l])
				y += 11
--			end
			l += 1
		end
		app.draw_borders(1, 1, self.width - 2, self.height - 2)
	end
	
	function el:mousewheel(msg)
		local nb_lines = (self.height - 2) // 11
		self.start -= msg.wheel_y
		self.start = mid(self.start, 1, #self.text - nb_lines)
	end
	
	return el
end


-------------------------------------------------------------------------------
-- Help Dialog
-------------------------------------------------------------------------------


function ui_help.open()
	local el = { width = 300, height = 270 - 11 - 40 }
	ui.open_modal(el)
	
	el:attach(create_text_viewer {
		file = "manual.txt",
		x = 10, y = 22,
		width = el.width - 2 * 10,
		height = el.height - 44,
	})
	
	el:attach(ui.create_button {
		x = el.width // 2 - 14, y = el.height - 18,
		label = "close", fg = 5,
		action = function(self)
			ui.close_modal()
		end,
	})
	
	function el:draw()
		local width, height = self.width, self.height
		local xw, yh = self.width - 1, self.y - 1
		rrectfill(0, 0, width, height, 0, 6)
		local xw, yh = 0 + width - 2, 0 + height - 2
		line(0 + 1, yh, 0 + 1, 0 + 1, 57)
		line(0 + 2, yh, 0 + 2, 0 + 1, 57)
		line(0 + 1, 0 + 1, xw, 0 + 1, 57)
		line(0 + 1, 0 + 2, xw, 0 + 2, 57)
		line(xw, yh, xw, 0 + 1, 58)
		line(xw - 1, yh, xw - 1, 0 + 2, 58)
		line(0 + 1, yh, xw, yh, 58)
		line(0 + 2, yh - 1, xw, yh - 1, 58)
		rrect(0 + 0, 0 + 0, width, height, 0, 0)
		rrectfill(0 + 4, 0 + 4, width - 8, 11, 0, 55)
		ui.print_centered("help", 0 + width // 2, 0 + 7, 6)
	end
	
	function el:click()
		return true
	end
end


return ui_help

:: src/ui/menus.lua
--[[pod_format="raw",created="2024-04-20 10:41:15",modified="2026-02-16 14:12:04",revision=26824]]
local app = require "src/app.lua"
local sfx = require "src/sfx/sfx.lua"
local ui = require "src/ui/ui.lua"
local ui_envelopes = require "src/ui/envelopes.lua"


local ui_menus = {}


-------------------------------------------------------------------------------
-- Relationship Menu
-------------------------------------------------------------------------------


function ui_menus.open_relationship(self)
	local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
	local node_type = sfx.node_type(app.instrument, self.parent.node_id)
	
	if node_type == 0x2 and self.parent.param == 2 then
		ui.open_menu {
			x = self.sx - 10, y = self.sy + 7,
			width = 55,
			items = {
				{
					label = (flags & 0x03 == 0x00)
						and "\|f\^:1c225d5d5d221c00\|h set"
						or "\|f\^:1c22414141221c00\|h set",
					action = function()
						self.parent.min_val, self.parent.max_val = -128, 127
						local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
						-- set bit: replace parent
						sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, flags & ~0x3)
					 end,
				},
				{
					label = (flags & 0x03 == 0x01)
						and "\|f\^:1c225d5d5d221c00\|h add"
						or "\|f\^:1c22414141221c00\|h add",
					action = function()
						self.parent.min_val, self.parent.max_val = -128, 127
						local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
						-- set bit: add parent
						sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, (flags & ~0x3) | 0x1)
					 end,
				},
				{
					label = (flags & 0x03 == 0x02)
						and "\|f\^:1c225d5d5d221c00\|h multiply"
						or "\|f\^:1c22414141221c00\|h multiply",
					action = function()
						self.parent.min_val, self.parent.max_val = 0, 255
						local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
						-- set bit: mul parent
						sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, (flags & ~0x3) | 0x2)
					 end,
				},
				{ divider = true },
				{
					label = 
						(flags & 0x20 > 0)
							and "\|f\^:7f415d5d5d417f00\|h quantized"
							or "\|f\^:7f41414141417f00\|h quantized",
					action = function()
						local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
						sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, flags ^^ 0x20)
					 end,
				},
			}
		}
	elseif
		(node_type == 0x02 and self.parent.param == 0)
		or (node_type == 10 and self.parent.param == 3)
		or (node_type == 8 and self.parent.param == 2)
	then
		ui.open_menu {
			x = self.sx - 10, y = self.sy + 7,
			width = 52,
			items = {
				{
					label = (flags & 0x03 == 0x00)
						and "\|f\^:1c225d5d5d221c00\|h set"
						or "\|f\^:1c22414141221c00\|h set",
					action = function()
						local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
						-- set bit: replace parent
						sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, flags & ~0x3)
					 end,
				},
				{
					label = (flags & 0x03 == 0x02)
						and "\|f\^:1c225d5d5d221c00\|h multiply"
						or "\|f\^:1c22414141221c00\|h multiply",
					action = function()
						local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
						-- set bit: mul parent
						sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, (flags & ~0x3) | 0x2)
					 end,
				},
			}
		}
	elseif
		(node_type == 8 and self.parent.param ~= 2)
		or (node_type == 9)
		or (node_type == 10 and self.parent.param ~= 3)
	then
		-- no menu
	else
		ui.open_menu {
			x = self.sx - 10, y = self.sy + 7,
			width = 40,
			items = {
				{
					label = (flags & 0x03 == 0x00)
						and "\|f\^:1c225d5d5d221c00\|h set"
						or "\|f\^:1c22414141221c00\|h set",
					action = function()
						local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
						-- set bit: replace parent
						sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, flags & ~0x3)
					 end,
				},
				{
					label = (flags & 0x03 == 0x01)
						and "\|f\^:1c225d5d5d221c00\|h add"
						or "\|f\^:1c22414141221c00\|h add",
					action = function()
						local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
						-- set bit: add parent
						sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, (flags & ~0x3) | 0x1)
					 end,
				},
			}
		}
	end
end


-------------------------------------------------------------------------------
-- Multiplier Menu
-------------------------------------------------------------------------------


function ui_menus.open_multiplier(self)
	local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
	
	local mult_options = { 
		[0] = 
		{ label = "none", val = 0x00 | 0x00 },
		{ label = "*4", val = 0x00 | 0x40 },
		{ label = "/4", val = 0x20 | 0x40 },
		{ label = "*16", val = 0x00 | 0x80 },
		{ label = "/16", val = 0x20 | 0x80 },
		{ label = "*64", val = 0x00 | 0xc0 },
		{ label = "/64", val = 0x20 | 0xc0 },
	}
	local mult_menu_items = {}
	for i = 0, #mult_options do
		add(mult_menu_items, 
			{
				label = (env & 0xe0 == mult_options[i].val)
					and ("\|f\^:1c225d5d5d221c00\|h " .. mult_options[i].label)
					or ("\|f\^:1c22414141221c00\|h " .. mult_options[i].label),
				fg = i == 0 and 5 or 24,
				action = function()
					local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
					sfx.set_node_param_env(app.instrument, self.parent.node_id, self.parent.param, (env & ~0xe0) | mult_options[i].val)
				 end,
			}
		)
	end

	ui.open_menu {
		x = self.sx - 10, y = self.sy + 7,
		width = 36,
		items = mult_menu_items,
	}
end


-------------------------------------------------------------------------------
-- Envelope Menu
-------------------------------------------------------------------------------


function ui_menus.open_envelope(self)
	local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
	local has_env = flags & 0x04 > 0
	local has_free_run = flags & 0x08 > 0
	local has_random = flags & 0x10 > 0
	local env_id = env & 0x0f
	ui.open_menu {
		x = self.sx - 10, y = self.sy + 7,
		width = 51,
		items = {
			{
				label = (not has_env and not has_random)
					and "\|f\^:1c225d5d5d221c00\|h none"
					or "\|f\^:1c22414141221c00\|h none",
				fg = 5,
				action = function()
					local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
					sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, flags & ~(0x4 | 0x8 | 0x10))
				 end,
			},
			{
				label = (has_env and env_id == 0)
					and ("\|f\^:1c225d5d5d221c00\|h " .. ui_envelopes.make_label(0))
					or ("\|f\^:1c22414141221c00\|h " .. ui_envelopes.make_label(0)),
				fg = 18,
				action = function()
					local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
					sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, (flags & ~0x10) | 0x4)
					sfx.set_node_param_env(app.instrument, self.parent.node_id, self.parent.param, (env & 0xf0) | 0)
				 end,
			},
			{
				label = (has_env and env_id == 1)
					and ("\|f\^:1c225d5d5d221c00\|h " .. ui_envelopes.make_label(1))
					or ("\|f\^:1c22414141221c00\|h " .. ui_envelopes.make_label(1)),
				fg = 18,
				action = function()
					local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
					sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, (flags & ~0x10) | 0x4)
					sfx.set_node_param_env(app.instrument, self.parent.node_id, self.parent.param, (env & 0xf0) | 1)
				 end,
			},
			{
				label = (has_env and env_id == 2)
					and ("\|f\^:1c225d5d5d221c00\|h " .. ui_envelopes.make_label(2))
					or ("\|f\^:1c22414141221c00\|h " .. ui_envelopes.make_label(2)),
				fg = 18,
				action = function()
					local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
					sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, (flags & ~0x10) | 0x4)
					sfx.set_node_param_env(app.instrument, self.parent.node_id, self.parent.param, (env & 0xf0) | 2)
				end,
			},
			{
				label = (has_env and env_id == 3)
					and ("\|f\^:1c225d5d5d221c00\|h " .. ui_envelopes.make_label(3))
					or ("\|f\^:1c22414141221c00\|h " .. ui_envelopes.make_label(3)),
				fg = 18,
				action = function()
					local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
					sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, (flags & ~0x10) | 0x4)
					sfx.set_node_param_env(app.instrument, self.parent.node_id, self.parent.param, (env & 0xf0) | 3)
				end,
			},
			{
				label = has_random
						and "\|f\^:1c225d5d5d221c00\|h random"
						or "\|f\^:1c22414141221c00\|h random",
				fg = 30,
				action = function()
					local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
					sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, (flags & ~0x4) | 0x10)
				 end,
			},
			{
				divider = true,
			},
			{
				label = has_free_run
							and "\|f\^:7f415d5d5d417f00\|h free run"
							or "\|f\^:7f41414141417f00\|h free run",
				fg = 5,
				action = function()
					local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
					sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, flags ^^ 0x08)
				 end,
			},
		}
	}
end


return ui_menus
:: src/ui/nodes.lua
--[[pod_format="raw",created="2024-04-12 16:30:23",modified="2026-02-16 14:12:04",revision=33399]]
local app = require "src/app.lua"
local sfx = require "src/sfx/sfx.lua"
local ui = require "src/ui/ui.lua"
local ui_envelopes = require "src/ui/envelopes.lua"
local ui_params = require "src/ui/params.lua"
local ui_visual = require "src/ui/visual.lua"


local ui_nodes = {}


-------------------------------------------------------------------------------
-- Locals
-------------------------------------------------------------------------------


function instrument_flag_toggle(el)
	el.width = el.width or 41
	el.height = el.height or 9
	el.label = el.label or "---"
	el.cursor = "pointer"
	
	function el:draw()
		palt(59, true)
		pal(2, 0)
		pal(17, 18)
		if sfx.instrument_flag(app.instrument, el.flag) then
			spr(116, 0, 1)
		else
			spr(115, 0, 1)
		end
		pal(17, 17)
		pal(2, 2)
		palt(59, false)
		print(el.label, 16, 2, 56)
	end
	
	function el:tap()
		sfx.toggle_instrument_flag(app.instrument, el.flag)
	end
	
	return el
end


-------------------------------------------------------------------------------


function attach_mute_toggle(parent, el)
	el.x = 1
	el.y = 2
	el.width = 3 + 4 * #(el.label .. " " .. el.node_id) + 3
	el.height = 9
	el.cursor = "pointer"
	parent:attach(el)
	el.muted = (sfx.node_flags(app.instrument, el.node_id) & 0x2) > 0
	function el:draw()
		local label = self.label .. " " .. self.node_id
		print(label, 3, 1, 63)
		if self.muted then
			line(1, 3, 3 + 4 * #label, 3, 24)
		end
	end
	function el:click()
		return true -- don't pass to panel to avoid selection
	end
	function el:tap()
		self.muted = not self.muted
		local flags = sfx.node_flags(app.instrument, self.node_id)
		if self.muted then
			flags |= 0x2
		else
			flags &= ~0x2
		end
		sfx.set_node_flags(app.instrument, self.node_id, flags)
	end
	return el
end


-------------------------------------------------------------------------------


function attach_close_button(parent, el)
	el.x = parent.width - 10
	el.y = 3
	el.width = 12
	el.height = 9
	el.cursor = "pointer"
	parent:attach(el)
	function el:draw()
		pal(7, 63)
		spr(36, 0, 0)
		pal(7, 7)
	end
	function el:click()
		return true -- don't pass to panel to avoid selection
	end
	function el:tap()
		if app.node then
			if app.node == self.node_id then
				if #(sfx.nodes[app.node].children) > 0 then
					app.node = sfx.nodes[app.node].children[1].id
				else
					app.node = sfx.nodes[app.node].parent.id
				end
			end
		end
		sfx.delete_node(app.instrument, self.node_id)
		if app.node and app.node > self.node_id then
			app.node = max(0, self.node_id - 1)
		end
		app.refresh_gui = true
	end
	return el
end


-------------------------------------------------------------------------------
-- Node Panels
-------------------------------------------------------------------------------


function ui_nodes.attach_node_panel(parent, el)
	if app.node and app.node == el.node_id then
		el.width = 480 - 4 * app.mod_width - 6 * app.synth_gap + 2
		el.height = 2 * app.synth_height + app.synth_gap
	else
		el.width = app.synth_width
		el.height = app.synth_height
	end
	parent:attach(el)
	
	local type = sfx.node_type(app.instrument, el.node_id)
	if el.node_id == 0 then return ui_nodes.populate_root(parent, el)
	elseif type == 0 then return ui_nodes.populate_unused(parent, el)
	elseif type == 2 then
		local op = sfx.node_op(app.instrument, el.node_id)
		if op == 0 then return ui_nodes.populate_osc(parent, el)
		elseif op == 1 then return ui_nodes.populate_fm(parent, el)
		elseif op == 2 then return ui_nodes.populate_ring(parent, el)
		end
	elseif type == 8 then return ui_nodes.populate_filt(parent, el)
	elseif type == 9 then return ui_nodes.populate_echo(parent, el)
	elseif type == 10 then return ui_nodes.populate_shap(parent, el)
	end
	return ui_nodes.populate_unknown(parent, el)
end


-------------------------------------------------------------------------------
-- Unused slot
-------------------------------------------------------------------------------


function ui_nodes.populate_unused(parent, el)
	function el:draw()
		clip()
		local x, y = 21, 14
		pal(7, 58)
--		sspr(63, 0, 0, 7, 7, x, y, 10 * 4, 10 * 4)
		spr(62, 28, 24)
		pal(7, 7)
		if self.node_id == 7 then
			print("pfx6416", 52, 66, 58)
		end
	end
	return el
end


-------------------------------------------------------------------------------
-- Root Synth Node
-------------------------------------------------------------------------------


local instrument_name_field


function ui_nodes.populate_root(parent, el)
	local params = {
		[0] = { label = "vol", long_label = "volume", param = 0,
			min_val = 0, max_val = 64, init_val = 32, sensitivity = 0.25 },
		{ label = "pan", param = 1, min_val = -128, max_val = 127, },
		{ label = "tune", param = 2, min_val = -128, max_val = 127, },
		{ label = "bend", param = 3, min_val = -128, max_val = 127, },
	}
	for i = 0, #params do params[i].node_id = el.node_id end

	if el.large then
		el:attach(instrument_flag_toggle { x = 180, y = 1, label = "retrig", flag = 0x01 })
		ui_params.attach(el, 18, 30, params[0], { emphasis = true})
		ui_params.attach(el, 60, 30, params[1], { small = true })
		el:attach(instrument_flag_toggle { x = 62, y = 92, label = "wide", flag = 0x02 })
		params[2].x = 12; params[2].y = 110
		ui_params.attach_mini(el, params[2])
		params[3].x = 12; params[3].y = 120
		ui_params.attach_mini(el, params[3])
		
		ui_visual.attach_stereo_oscillo(el, {
			x = 114, y = 27, width = 104, height = 84,
			channel = nil,
		})

		-- TODO: replace with a custom field
		-- also: add the same field to the mini version
		instrument_name_field = el:attach_text_editor{
			x = 18, y = 2,
			width = 8 + 16 * 4, height = 7,
			margin_top = 1,
			bgcol = 7, fgcol = 59, curcol = 14,
			block_scrolling = true, max_lines = 1,
			key_callback = {
				enter = function () 
					if name == "---" then name = "" end
					sfx.set_instrument_name(app.instrument, name)
					instrument_name_field:set_keyboard_focus(false)
				end
			},
			update = function(self)
				self.cursor = "pointer"
				-- update in realtime -- don't need to press enter to change
				if (instrument_name_field:has_keyboard_focus()) then
					local name = instrument_name_field:get_text()[1]
					if name == "---" then name = "" end
					sfx.set_instrument_name(app.instrument, name)
				end
			end,
		}
		local name = sfx.instrument_name(app.instrument)
		if name == "" then name = "---" end
		instrument_name_field:set_text{ name }
	else
		ui_params.attach_mini(el, params[0])
		ui_params.attach_mini(el, params[1])
		ui_params.attach_mini(el, params[2])
		ui_params.attach_mini(el, params[3])
		el:attach(instrument_flag_toggle { x = 16, y = 53, label = "wide", flag = 0x02 })
		el:attach(instrument_flag_toggle { x = 42, y = 1, label = "retrig", flag = 0x01 })
	end
	function el:draw()
		if self.large then
			rrectfill(1, 0, self.width - 50, 11, 0, 7)
			rrect(16, -1, 8 + 16 * 4 + 4, 13, 5, 6)
			print(string.format("%02x", app.instrument), 4, 3, 44)
--			spr(108, 128, 2)
			spr(131, 128, 3)
			spr(129, 136, 119)
		else
			rrectfill(1, 0, 33, 11, 0, 7)
			print("inst ", 4, 3, 5)
			print(string.format("%02x", app.instrument), 24, 3, 44)
		end
	end
	function el:click() return true end
	function el:doubleclick() app.node = self.node_id; app.refresh_gui = true end
	return el
end


-------------------------------------------------------------------------------
-- Oscillator
-------------------------------------------------------------------------------



local wt_labels = { [0] = "wt0", "wt1", "wt2", "wt3" }
local wt_long_labels = { [0] = "wavetable 0", "wavetable 1", "wavetable 2", "wavetable 3" }
local osc_params = {
	[0] = { label = "vol", long_label = "volume", param = 0,
		min_val = 0, max_val = 64, init_val = 32, sensitivity = 0.25 },
	{ label = "pan", param = 1, min_val = -128, max_val = 127, },
	{ label = "tune", param = 2, min_val = -128, max_val = 127, },
	{ label = "bend", param = 3, min_val = -128, max_val = 127, },
	{ label = "", long_label = "wave", param = 4, min_val = 0, max_val = 255, },
	{ label = "phase", param = 5, min_val = -128, max_val = 127, },
}

function ui_nodes.populate_osc(parent, el)
	local params = unpod(pod(osc_params))
	
	for i = 0, #params do params[i].node_id = el.node_id end
	local flags, _, _, _ = sfx.node_param(app.instrument, el.node_id, 2)
	if flags & 0x03 == 0x02 then
		-- tune param in "multiply" relationship:
		-- change the min and max values
		params[2].min_val = 0
		params[2].max_val = 255
	end

	attach_mute_toggle(el, { label = "osc", node_id = el.node_id })
	attach_close_button(el, { node_id = el.node_id })
	if el.large then
		ui_params.attach(el, 18, 18, params[0], { emphasis = true})
		ui_params.attach(el, 60, 18, params[1], { small = true })
		ui_params.attach(el, 18, 86, params[2], { small = true })
		ui_params.attach(el, 60, 86, params[3], { small = true })
		local wave = ui_params.attach(el, 130, 86, params[4], { emphasis = true })
		ui_visual.attach_wavetable(el, wave, { x = 114, y = 16, width = 104, height = 58, fg = 47 })
		ui_params.attach(el, 172, 86, params[5], { small = true })
		el:attach(ui.create_menu_button {
			x = 142, y = 74,
			get_label = function()
				local wt = sfx.node_osc_wavetable(app.instrument, el.node_id)
				return wt_long_labels[wt] or "wt?"
			end,
			fg = 46,
			highlight = 15,
			items = {
				{ label = "wavetable 0", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 0) end },
				{ label = "wavetable 1", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 1) end },
				{ label = "wavetable 2", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 2) end },
				{ label = "wavetable 3", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 3) end },
			}
		})
	else
		-- closures are not copied by unpod/pod?
		params[4].onclick = function(self) ui_visual.open_wavetable(self, 47) end
		params[4].onrelease = function(self) ui_visual.close() end
		params[5].onclick = params[4].onclick
		params[5].onrelease = params[4].onrelease
		ui_params.attach_mini(el, params[0])
		ui_params.attach_mini(el, params[1])
		ui_params.attach_mini(el, params[2])
		ui_params.attach_mini(el, params[3])
		ui_params.attach_mini(el, params[4])
		ui_params.attach_mini(el, params[5])
		el:attach(ui.create_menu_button {
			x = 2, y = 53,
			get_label = function()
				local wt = sfx.node_osc_wavetable(app.instrument, el.node_id)
				return wt_labels[wt] or "wt?"
			end,
			fg = 46,
			highlight = 15,
			items = {
				{ label = "wt 0", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 0) end },
				{ label = "wt 1", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 1) end },
				{ label = "wt 2", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 2) end },
				{ label = "wt 3", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 3) end },
			}
		})
	end
	
	function el:click() return true end
	function el:doubleclick() app.node = self.node_id; app.refresh_gui = true end
		
	function el:draw()
		rrectfill(1, 0, self.width - 1, 11, 0, 17)
	end
	
	return el
end


-------------------------------------------------------------------------------
-- FM modulator
-------------------------------------------------------------------------------


function ui_nodes.populate_fm(parent, el)
	local params = unpod(pod(osc_params))
	-- closures are not copied by unpod/pod?
	params[4].onclick = function(self) ui_visual.open_wavetable(self, 45) end
	params[4].onrelease = function(self) ui_visual.close() end
	params[5].onclick = params[4].onclick
	params[5].onrelease = params[4].onrelease
	
	for i = 0, #params do params[i].node_id = el.node_id end
	local flags, _, _, _ = sfx.node_param(app.instrument, el.node_id, 2)
	if flags & 0x03 == 0x02 then
		-- tune param in "multiply" relationship:
		-- change the min and max values
		params[2].min_val = 0
		params[2].max_val = 255
	end

	attach_mute_toggle(el, { label = "fm", node_id = el.node_id })
	attach_close_button(el, { node_id = el.node_id })
	if el.large then
		ui_params.attach(el, 18, 18, params[0], { emphasis = true})
		ui_params.attach(el, 60, 18, params[1], { small = true })
		ui_params.attach(el, 18, 86, params[2], { small = true })
		ui_params.attach(el, 60, 86, params[3], { small = true })
		local wave = ui_params.attach(el, 130, 86, params[4], { emphasis = true })
		ui_visual.attach_wavetable(el, wave, { x = 114, y = 16, width = 104, height = 58, fg = 45 })
		ui_params.attach(el, 172, 86, params[5], { small = true })
		el:attach(ui.create_menu_button {
			x = 142, y = 74,
			get_label = function()
				local wt = sfx.node_osc_wavetable(app.instrument, el.node_id)
				return wt_long_labels[wt] or "wt?"
			end,
			fg = 44,
			highlight = 15,
			items = {
				{ label = "wavetable 0", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 0) end },
				{ label = "wavetable 1", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 1) end },
				{ label = "wavetable 2", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 2) end },
				{ label = "wavetable 3", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 3) end },
			}
		})
	else
		ui_params.attach_mini(el, params[0])
		ui_params.attach_mini(el, params[1])
		ui_params.attach_mini(el, params[2])
		ui_params.attach_mini(el, params[3])
		ui_params.attach_mini(el, params[4])
		ui_params.attach_mini(el, params[5])
		el:attach(ui.create_menu_button {
			x = 2, y = 53,
			get_label = function()
				local wt = sfx.node_osc_wavetable(app.instrument, el.node_id)
				return wt_labels[wt] or "wt?"
			end,
			fg = 44,
			highlight = 15,
			items = {
				{ label = "wt 0", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 0) end },
				{ label = "wt 1", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 1) end },
				{ label = "wt 2", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 2) end },
				{ label = "wt 3", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 3) end },
			}
		})
	end
	
	function el:click() return true end
	function el:doubleclick() app.node = self.node_id; app.refresh_gui = true end
		
	function el:draw()
		rrectfill(1, 0, self.width - 1, 11, 0, 27)
	end
	
	return el
end


-------------------------------------------------------------------------------
-- Ring mod
-------------------------------------------------------------------------------


function ui_nodes.populate_ring(parent, el)
	local params = unpod(pod(osc_params))
	-- closures are not copied by unpod/pod?
	params[4].onclick = function(self) ui_visual.open_wavetable(self, 51) end
	params[4].onrelease = function(self) ui_visual.close() end
	params[5].onclick = params[4].onclick
	params[5].onrelease = params[4].onrelease
	
	for i = 0, #params do params[i].node_id = el.node_id end
	local flags, _, _, _ = sfx.node_param(app.instrument, el.node_id, 2)
	if flags & 0x03 == 0x02 then
		-- tune param in "multiply" relationship:
		-- change the min and max values
		params[2].min_val = 0
		params[2].max_val = 255
	end

	attach_mute_toggle(el, { label = "ring", node_id = el.node_id })
	attach_close_button(el, { node_id = el.node_id })
	if el.large then
		ui_params.attach(el, 18, 18, params[0], { emphasis = true})
		ui_params.attach(el, 60, 18, params[1], { small = true })
		ui_params.attach(el, 18, 86, params[2], { small = true })
		ui_params.attach(el, 60, 86, params[3], { small = true })
		local wave = ui_params.attach(el, 130, 86, params[4], { emphasis = true })
		ui_visual.attach_wavetable(el, wave, { x = 114, y = 16, width = 104, height = 58, fg = 51 })
		ui_params.attach(el, 172, 86, params[5], { small = true })
		el:attach(ui.create_menu_button {
			x = 142, y = 74,
			get_label = function()
				local wt = sfx.node_osc_wavetable(app.instrument, el.node_id)
				return wt_long_labels[wt] or "wt?"
			end,
			fg = 50,
			highlight = 15,
			items = {
				{ label = "wavetable 0", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 0) end },
				{ label = "wavetable 1", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 1) end },
				{ label = "wavetable 2", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 2) end },
				{ label = "wavetable 3", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 3) end },
			}
		})
	else
		ui_params.attach_mini(el, params[0])
		ui_params.attach_mini(el, params[1])
		ui_params.attach_mini(el, params[2])
		ui_params.attach_mini(el, params[3])
		ui_params.attach_mini(el, params[4])
		ui_params.attach_mini(el, params[5])
		el:attach(ui.create_menu_button {
			x = 2, y = 53,
			get_label = function()
				local wt = sfx.node_osc_wavetable(app.instrument, el.node_id)
				return wt_labels[wt] or "wt?"
			end,
			fg = 50,
			highlight = 15,
			items = {
				{ label = "wt 0", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 0) end },
				{ label = "wt 1", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 1) end },
				{ label = "wt 2", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 2) end },
				{ label = "wt 3", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 3) end },
			}
		})
	end
	
	function el:click() return true end
	function el:doubleclick() app.node = self.node_id; app.refresh_gui = true end
		
	function el:draw()
		rrectfill(1, 0, self.width - 1, 11, 0, 22)
	end
	
	return el
end


-------------------------------------------------------------------------------
-- Filter
-------------------------------------------------------------------------------


function ui_nodes.populate_filt(parent, el)
	local params = {
		[0] =
		{ label = "lp", param = 0, min_val = 0, max_val = 255, },
		{ label = "hp", param = 1, min_val = 0, max_val = 255, },
		{ label = "res", param = 2, min_val = 0, max_val = 255, },
	}
	for i = 0, #params do params[i].node_id = el.node_id end
	
	attach_mute_toggle(el, { label = "filt", node_id = el.node_id })
	attach_close_button(el, { node_id = el.node_id })
	if el.large then
		ui_params.attach(el, 54, 84, params[1], {})
		ui_params.attach(el, 96, 84, params[0], { reversed = true })
		ui_params.attach(el, 138, 84, params[2], { small = true })
		ui_visual.attach_filter_display(el, { x = 25, y = 20, width = 176, height = 58 })
	else
		ui_params.attach_mini(el, params[0])
		ui_params.attach_mini(el, params[1])
		ui_params.attach_mini(el, params[2])
	end
	function el:draw()
		rrectfill(1, 0, self.width - 1, 11, 0, 14)
		spr(111, 29, 100)
		spr(111, 182, 100)
	end
	function el:click() return true end
	function el:doubleclick() app.node = self.node_id; app.refresh_gui = true end
	return el
end


-------------------------------------------------------------------------------
-- Delay
-------------------------------------------------------------------------------


function ui_nodes.populate_echo(parent, el)
	local params = {
		[0] =
		{ label = "delay", param = 0, min_val = 0, max_val = 255, },
		{ label = "vol", param = 1, min_val = 0, max_val = 255, },
	}
	for i = 0, #params do params[i].node_id = el.node_id end
	
	attach_mute_toggle(el, { label = "echo", node_id = el.node_id })
	attach_close_button(el, { node_id = el.node_id })
	if el.large then
		ui_params.attach(el, 75, 86, params[0], {})
		ui_params.attach(el, 117, 86, params[1], {})
		ui_visual.attach_delay_display(el, { x = 25, y = 20, width = 176, height = 58 })
	else
		ui_params.attach_mini(el, params[0])
		ui_params.attach_mini(el, params[1])
	end
	function el:draw()
		rrectfill(1, 0, self.width - 1, 11, 0, 31)
		spr(127, 20, 98)
		spr(127, 168, 98)
	end
	function el:click() return true end
	function el:doubleclick() app.node = self.node_id; app.refresh_gui = true end
	return el
end


-------------------------------------------------------------------------------
-- Waveshaper
-------------------------------------------------------------------------------


function ui_nodes.populate_shap(parent, el)
	local params = {
		[0] =
		{ label = "gain", param = 0, min_val = 0, max_val = 255, },
		{ label = "elbow", param = 1, min_val = 0, max_val = 255, },
		{ label = "cut", param = 2, min_val = 0, max_val = 255, },
		{ label = "mix", param = 3, min_val = 0, max_val = 64, sensitivity = 0.25 },
	}
	for i = 0, #params do params[i].node_id = el.node_id end
	
	attach_mute_toggle(el, { label = "shap", node_id = el.node_id })
	attach_close_button(el, { node_id = el.node_id })
	if el.large then
		ui_params.attach(el, 18, 86, params[0], {})
		ui_params.attach(el, 60, 86, params[2], { reversed = true })
		ui_params.attach(el, 102, 86, params[1], {})
		ui_params.attach(el, 160, 86, params[3], { small = true })
		ui_visual.attach_shaper_display(el, { x = 25, y = 20, width = 104, height = 58 })
	else
		ui_params.attach_mini(el, params[0])
		ui_params.attach_mini(el, params[1])
		ui_params.attach_mini(el, params[2])
		ui_params.attach_mini(el, params[3])
	end
	function el:draw()
		rrectfill(1, 0, self.width - 1, 11, 0, 9)
		spr(110, 159, 33)
	end
	function el:click() return true end
	function el:doubleclick() app.node = self.node_id; app.refresh_gui = true end
	return el
end


-------------------------------------------------------------------------------
-- Unknown
-------------------------------------------------------------------------------


function ui_nodes.populate_unknown(parent, el)
	local params = {
		[0] =
		{ label = "p0", param = 0, min_val = 0, max_val = 255, },
		{ label = "p1", param = 1, min_val = 0, max_val = 255, },
		{ label = "p2", param = 2, min_val = 0, max_val = 255, },
		{ label = "p3", param = 3, min_val = 0, max_val = 255, },
		{ label = "p4", param = 4, min_val = 0, max_val = 255, },
		{ label = "p5", param = 5, min_val = 0, max_val = 255, },
	}
	for i = 0, #params do params[i].node_id = el.node_id end
	
	attach_mute_toggle(el, { label = "???", node_id = el.node_id })
	attach_close_button(el, { node_id = el.node_id })
	ui_params.attach_mini(el, params[0])
	ui_params.attach_mini(el, params[1])
	ui_params.attach_mini(el, params[2])
	ui_params.attach_mini(el, params[3])
	ui_params.attach_mini(el, params[4])
	ui_params.attach_mini(el, params[5])
	function el:draw()
		rrectfill(1, 0, self.width - 1, 9, 0, 30)
	end
	function el:click() return true end
	function el:doubleclick() app.node = self.node_id; app.refresh_gui = true end
	return el
end


return ui_nodes
:: src/ui/notegrid.lua
--[[pod_format="raw",created="2026-01-26 13:53:28",modified="2026-02-16 14:12:04",revision=22971]]
local app = require "src/app.lua"
local selection = require "src/selection.lua"
local settings = require "src/settings.lua"
local sfx = require "src/sfx/sfx.lua"
local ui = require "src/ui/ui.lua"
local ui_trakdial = require "src/ui/trakdial.lua"
local undo = require "src/undo.lua"


local ui_notegrid = {}


-------------------------------------------------------------------------------
-- Locals
-------------------------------------------------------------------------------


local note_names <const> = {"c ","c\|f+","d ","d\|f+","e ","f ","f\|f+","g ","g\|f+","a ","a\|f+", "b "}
local note_names <const> = {"c ","c+","d ","d+","e ","f ","f+","g ","g+","a ","a+", "b "}


local w_note <const> = 11
local w_octave <const> = 7
local w_note_octave <const> = 11 + 7
local w_instrument <const> = 11
local w_volume <const> = 11
local w_fx <const> = 16


local x_note <const> = 0
local x_octave <const> = w_note
local x_instrument <const> = w_note + w_octave
local x_volume <const> = w_note + w_octave + w_instrument
local x_fx <const> = w_note + w_octave + w_instrument + w_volume


local fgd_note = 42
local fg_note = 43
local fgd_octave = 50
local fg_octave = 51
local fgd_inst = 44
local fg_inst = 45
local fgd_vol = 46
local fg_vol = 47
local fgd_fx = 48
local fg_fx = 49
local fg_greyed = 34


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


local function channel_not_valid(channel)
	local track = sfx.pattern_track(app.pattern, channel)
	local size = sfx.track_size(track)
	return size < 1 or sfx.channel_is_muted(app.pattern, channel)
end


-------------------------------------------------------------------------------
-- Channel Dialog
-------------------------------------------------------------------------------


local channel_dialog = nil
local channel_dialog_start = 0


local function init_first_empty_track(track)
	if sfx.track_size(track) ~= 0 then
		for t = 0, sfx.num_tracks() - 1 do
			if sfx.track_size(t) == 0 then
				track = t
				break
			end
		end
	end
	if sfx.track_size(track) == 0 then
		init_track(track)
		return track
	end
	return nil
end


local function create_channel_dialog(el)
	ui.head():new(el)
	
	el:attach(ui.create_toggle {
		x = 4, y = 4,
		off_spr = get_spr(115), on_spr = get_spr(116),
		get = function(self) return not sfx.channel_is_muted(app.pattern, el.channel) end,
		set =
			function(self)
				local muted = sfx.channel_is_muted(app.pattern, el.channel)
				app.mute_channel(app.pattern, el.channel, not muted)
				ui_notegrid.close_channel_dialog()
			end,
	})
	
	--[[
	el:attach(ui.create_field {
		x = 21, y = 4, width = 15,
		centered = true,
		to_str = function(self, v) return string.format("%03d", v) end,
		get = function(self) return sfx.pattern_track(app.pattern, el.channel) end,
		set =
			function(self, track)
				notify("***")
				app.set_pattern_track(app.pattern, el.channel, track)
			end,
		on_confirm = function(self) ui_notegrid.close_channel_dialog() end,
	})
	--]]
	
	el:attach(ui.create_list {
		x = 2, y = 13,
		width = el.width - 4, height = el.height - 70,
		cursor = "pointer",
		row_height = 9,
		nb_columns = 1,
		channel = el.channel,
		get_active = function(self) return sfx.pattern_track(app.pattern, self.channel) end,
		set_active =
			function(self, track)
				undo.checkpoint()
				if sfx.track_size(track) == 0 then
					init_track(track)
				end
				if sfx.channel_is_muted(app.pattern, self.channel) then
					sfx.mute_channel(app.pattern, self.channel, false)
				end
				app.set_pattern_track(app.pattern, self.channel, track)
			end,
		on_tap = function(self) ui_notegrid.close_channel_dialog() end,
		get_start = function(self) return channel_dialog_start end,
		set_start = function(self, start) channel_dialog_start = start end,
		get_max = function(self) return sfx.num_tracks() - 1 end,
		disabled = function(self) return sfx.channel_is_muted(app.pattern, self.channel) end,
		draw_item =
			function(self, track, x, y, w, h, has_pointer)
				local muted = sfx.channel_is_muted(app.pattern, self.channel)
				local active = sfx.pattern_track(app.pattern, self.channel)
				local size = sfx.track_size(track)
				if track == active then
					rrectfill(x, y, w, h, 0, muted and 19 or 17)
				elseif has_pointer then
					rrectfill(x, y, w, h, 0, 60)
				end
				local fg = size == 0 and (has_pointer and 59 or 60) or 57
				print(string.format("%03d", track), x + 3, y + 2, fg)
				local trk_patts = app.track_patterns(track)
				if trk_patts then
					if size > 0 then
						--print("\^:08047e0408000000", x + 15, y + 2, 58)
						print("\^:080c7e0c08000000", x + 15, y + 2, 58)
					end
					local x = 25
					for i = 1, #trk_patts do
						print(
							string.format("%02d", trk_patts[i].pattern),
							x, y + 2,
							trk_patts[i].channel == self.channel and 58 or 58 -- TODO: keep?
						)
						x += 12
					end
				end
			end
	})
	
	local oy = el.height - 35
	local x_button = app.column_width - 33 -- 14
	
	el:attach(ui.create_button {
		x = x_button, y = oy - 19, fg = 5,
		label = "clone",
		action =
			function(self)
				undo.checkpoint()
				local track = sfx.pattern_track(app.pattern, el.channel)
				track = init_first_empty_track(track)
				if track then
					local current_track = sfx.pattern_track(app.pattern, el.channel)
					for step = 0, sfx.track_size(track) - 1 do
						sfx.set_track_pitch(track, step, sfx.track_pitch(current_track, step))
						sfx.set_track_instrument(track, step, sfx.track_instrument(current_track, step))
						sfx.set_track_volume(track, step, sfx.track_volume(current_track, step))
						sfx.set_track_fx(track, step, sfx.track_fx(current_track, step))
						sfx.set_track_fx_params(track, step, sfx.track_fx_params(current_track, step))
					end
					sfx.set_track_speed(track, sfx.track_speed(current_track))
					sfx.set_track_loop0(track, sfx.track_loop0(current_track))
					sfx.set_track_loop1(track, sfx.track_loop1(current_track))
					sfx.mute_channel(app.pattern, el.channel, false)
					app.set_pattern_track(app.pattern, el.channel, track)
					ui_notegrid.close_channel_dialog()
				end
			end
	})
	
	el:attach(ui.create_horiz_divider {
		x = 0, y = oy - 5, -- 58,
		width = el.width - 1,
	})
	
	el:attach(ui.create_label {
		x = 4, y = oy, fg = 35,
		label = "length\-f:",
	})
	el:attach(ui.create_field {
		x = 4 + 32, y = oy - 1,
		width = 15, height = 7,
		get = function(self) return app.new_tracks_length end,
		set =
			function(self, value)
				local size = sfx.pattern_max_size(app.pattern) -- TODO: this is not corrent...
				value = mid(value, 0, size)
				app.new_tracks_length = value
			end,
	})
	
	el:attach(ui.create_label {
		channel = el.channel, fg = 36,
		x = 4, y = oy + 10,
		label = "speed\-f:",
	})
	el:attach(ui.create_field {
		x = 4 + 32, y = oy + 10 - 1,
		width = 15, height = 7,
		get = function(self) return app.new_tracks_speed end,
		set = 
			function(self, value)
				value = mid(value, 0, 255)
				app.new_tracks_speed = value
			end,
	})
	
	el:attach(ui.create_button {
		x = x_button, y = oy + 20, fg = 5,
		label = " new ",
		action =
			function(self)
				undo.checkpoint()
				local track = sfx.pattern_track(app.pattern, el.channel)
				track = init_first_empty_track(track)
				if track then
					sfx.mute_channel(app.pattern, el.channel, false)
					app.set_pattern_track(app.pattern, el.channel, track)
					ui_notegrid.close_channel_dialog()
				end
			end
	})
	
	function el:draw()
		rrectfill(0, 0, self.width, self.height, 0, 6)
		line(0, 0, 0, self.height - 1, 57)
		line(0, 0, self.width - 1, 0, 57)
		line(self.width - 1, self.height - 1, 0, self.height - 1, 58)
		line(self.width - 1, self.height - 1, self.width - 1, 0, 58)
	end
	function el:click()
		return true
	end
	function el:drag()
		return true
	end
	function el:tap()
		return true
	end
	function el:mousewheel()
		return true
	end
	return el
end


function ui_notegrid.close_channel_dialog()
	if channel_dialog then
		channel_dialog:detach()
	end
	channel_dialog = nil
end


-------------------------------------------------------------------------------
-- Note Grid
-------------------------------------------------------------------------------


function ui_notegrid.attach(parent, el)
	parent:attach(el)
	
	-- Private Fields
	local last_click_time = 0
	local click_counter = 0
	
	function el:draw(msg)
		local muted = sfx.channel_is_muted(app.pattern, self.channel)
		local track <const> = sfx.pattern_track(app.pattern, self.channel)
		local track_size <const> = sfx.track_size(track)
		if muted or track_size == 0 then
			return
		end
		local sustain_line_enabled = settings.user.sustain_line_enabled
		local inst_square_enabled = settings.user.instrument_square_enabled
		local pattern_is_playing <const> =
			sfx.playing_channels() != 0
			and sfx.playing_pattern() == app.pattern
		local channel_is_playing <const> = sfx.channel_is_playing(self.channel)
		local playing_channel_row <const> = sfx.playing_channel_row(self.channel)
		local track_length <const> = sfx.track_length(track)
		local track_loop0 <const> = sfx.track_loop0(track)
		local track_loop1 <const> = sfx.track_loop1(track)
		local track_is_looping <const> = sfx.track_is_looping(track)
		local start <const> = app.starting_row
		local nb_rows <const> = math.ceil(self.height / app.row_height)
		local selection_parts <const> = selection.parts()
		-- TODO: pattern_max_size
		-- Hot Loop for the Notes
		local prev_freq, prev_inst, prev_vol, prev_fx = 0xff, 0xff, 0xff, 0x00
		local last_int = 0xff
		local dy_text = math.ceil((app.row_height - 5) / 2)
		if app.row_height < 7 then dy_text = 0 end
		
		-----------------------------------------------------------------------------
		-- Hot Loop
		-----------------------------------------------------------------------------
		
		for row = 0, nb_rows - 1 do
			local step <const> = start + row
			local x <const> = 0
			local y <const> = 1 + row * app.row_height
			local y_text <const> = y + dy_text
			if step < 0 then
				goto continue
			elseif step >= track_size then
				--line(x, y, x + app.column_width - 2, y, 36)
				break
			end
			local is_greyed = step >= track_length
			local is_selected <const> = selection.has_channel(self.channel) 
				and selection.has_step(step)
			local step_is_playing <const> = playing_channel_row == step
			local step_in_bar = step % app.bar_length
			local step_in_beat = step_in_bar % app.beat_length
			if pattern_is_playing and channel_is_playing and step_is_playing then
				rrectfill(x, y, app.column_width - 1, app.row_height, 0, 36)
			elseif step_in_bar == 0 and (not is_greyed) then
				rrectfill(x, y, app.column_width - 1, app.row_height, 0, 35)
			elseif step_in_beat == 0 and (not is_greyed) then
				rrectfill(x, y, app.column_width - 1, app.row_height, 0, 34)
			end
			local freq <const> = sfx.track_pitch(track, step)
			local inst <const> = sfx.track_instrument(track, step)
			local vol <const> = sfx.track_volume(track, step)
			local fx <const> = sfx.track_fx(track, step)
			local fxp0 <const> = sfx.track_fx_param0(track, step)
			local fxp1 <const> = sfx.track_fx_param1(track, step)
			local note <const> = freq % 12
			local octave <const> = freq // 12
			-- Cursors and Selection
			-- TODO: only when the app.pattern is where the cursor is
			if is_selected and not app.follow_playhead then
				local selcol = app.is_editing and 37 or 38
				selcol = self.parent:has_keyboard_focus() and selcol or 39
				if selection_parts & selection.note ~= 0 then
					rrectfill(x_note, y, w_note_octave, app.row_height, 0, selcol)
				end
				if selection_parts & selection.instrument ~= 0 then
					local rr = self.parent.str_instrument and rrect or rrectfill
					rr(x_instrument, y, w_instrument, app.row_height, 0, selcol)
				end
				if selection_parts & selection.volume ~= 0 then
					local rr = self.parent.str_volume and rrect or rrectfill
					rr(x_volume, y, w_volume, app.row_height, 0, selcol)
				end
				if selection_parts & selection.fx ~= 0 then
					local rr = self.parent.str_fx and rrect or rrectfill
					rr(x_fx, y, w_fx, app.row_height, 0, selcol)
				end
			end
			-- Note and Octave
			local is_retrig_inst = sfx.instrument_flag(last_inst or inst, 0x01)
			local is_sustained
			if is_retrig_inst then
				is_sustained =
					inst == 0xff
					and fx ~= ord("r")
			else
				is_sustained =
					freq == prev_freq
					and (inst == last_inst or inst == 0xff)
					and fx ~= ord("r")
					and prev_fx ~= ord("c")
			end
			if freq != 0xff then
				if is_sustained and sustain_line_enabled then
					line(x + 4, y, x + 4, y + app.row_height - 1, is_greyed and fg_greyed or fg_note)
					if is_retrig_inst and freq ~= prev_freq then
						pal(7, is_greyed and fg_greyed or fg_note)
						spr(72 + note, x + 3 + 4, y_text)
						if octave <= 9 then
							pal(7, is_greyed and fg_greyed or fg_octave)
							spr(96 + min(octave, 10), x + 13 + 4, y_text)
						else
							-- TODO
						end
					end
				else
					pal(7, is_greyed and fg_greyed or fg_note)
					spr(72 + note, x + 3, y_text)
					if octave <= 9 then
						pal(7, is_greyed and fg_greyed or fg_octave)
						spr(96 + min(octave, 10), x + 13, y_text)
					else
						-- TODO
					end
				end
			else
				pal(7, is_greyed and fg_greyed or fgd_note)
				spr(65, x + 4, y_text)
			end
			-- Instrument
			if is_selected and self.parent.str_instrument then
				pal(7, self.parent.str_instrument_is_valid and 7 or 8)
				print(self.parent.str_instrument, x + 20, y_text, 7)
			elseif inst_square_enabled and inst == prev_inst and inst ~= 0xff then
				pal(7, is_greyed and fg_greyed or fg_inst)
				spr(69, x + 20, y_text)
			elseif inst != 0xff then
				local unchanged = false and inst == prev_inst
				local fg = (unchanged and fgd_inst or fg_inst)
				pal(7, is_greyed and fg_greyed or fg)
				spr(256 + inst, x + 20, y_text)
			else
				pal(7, is_greyed and fg_greyed or fgd_inst)
				spr(64, x + 20, y_text)
			end
			-- Volume
			if is_selected and self.parent.str_volume then
				pal(7, self.parent.str_volume_is_valid and 7 or 8)
				print(self.parent.str_volume, x + 31, y_text, 7)
			elseif false and vol == prev_vol and vol ~= 0xff then
				pal(7, is_greyed and fg_greyed or fg_vol)
				spr(69, x + 31, y_text)
			elseif vol != 0xff then
				local unchanged = false and vol == prev_vol
				local fg = (unchanged and fgd_vol or fg_vol)
				pal(7, is_greyed and fg_greyed or fg)
				spr(256 + vol, x + 31, y_text)
			else
				pal(7, is_greyed and fg_greyed or fgd_vol)
				spr(64, x + 31, y_text)
			end
			-- FX
			if is_selected and self.parent.str_fx then
				pal(7, 7)
				print(self.parent.str_fx, x + 42, y_text, self.parent.str_fx_is_valid and 7 or 8)
			elseif fx != 0x0 then
				print(chr(fx), x + 42, y_text, is_greyed and fg_greyed or fg_fx) -- TODO: replace with sprites
				pal(7, is_greyed and fg_greyed or fg_fx)
				spr(256 + ((fxp0 << 4) | fxp1), x + 46, y_text)
			else
				pal(7, is_greyed and fg_greyed or fgd_fx)
				spr(66, x + 42, y_text)
			end
			-- Loop Markers
			if track_is_looping then
				if step == track_length then
					spr(22, x, y - 8)
				end
				if step > 0 and step == track_loop0 then
					spr(21, x, y)
				end
			elseif step == track_length then
				line(x, y - 1, x + app.column_width - 2, y - 1, 37)
			end
			prev_fx = fx
			if inst ~= 0xff then
				prev_inst = inst
				last_inst = inst
				prev_vol = vol
			end
			prev_freq = freq
			pal(7, 7)
			::continue::
		end
		-----------------------------------------------------------------------------
		-- End of Hot Loop
		-----------------------------------------------------------------------------
	end
	
	function el:update(msg)
		local muted = sfx.channel_is_muted(app.pattern, self.channel)
		local track = sfx.pattern_track(app.pattern, self.channel)
		local size = sfx.track_size(track)
		if muted then
			return
		end
		local track = sfx.pattern_track(app.pattern, self.channel)
		if sfx.track_size(track) == 0 then
			return
		end
		local mx, my = mouse()
		mx -= self.sx
		my -= self.sy
		local has_pointer = 
			mx >= 0 and mx < self.width
			and my >= 0 and my < self.height
		if has_pointer and self.parent.is_selecting then
			local start <const> = app.starting_row
			local step <const> = app.starting_row + (msg.my - 1) // app.row_height
			local part <const> = self:x_to_part(mx)
			selection.set_from_anchor_to(self.channel, step, part)
		end
	end
	
	function el:click(msg)
		local muted = sfx.channel_is_muted(app.pattern, self.channel)
		if channel_dialog then
			ui_notegrid.close_channel_dialog()
		end
		if muted or app.follow_playhead then return end
		local track = sfx.pattern_track(app.pattern, self.channel)
		-- Check for double and triple click
		local t = time()
		if t - last_click_time < 0.25 then
			click_counter += 1
		else
			click_counter = 1
		end
		last_click_time = time()
		
		local step <const> = app.starting_row + (msg.my - 1) // app.row_height
		local part <const> = self:x_to_part(msg.mx)
		if msg.mb == 1 then
			self.parent:clear_edit()
			self.parent.is_selecting = true
			local how = key("ctrl") and "extend" or "set"
			local what =
				(click_counter == 1 and "part")
				or (click_counter == 2 and "row")
				or (click_counter == 3 and "beat")
				or (click_counter == 4 and "column")
				or "column"
			selection.set_anchor(self.channel, step, part, how, what)
		elseif msg.mb == 2 then
			self.parent:clear_edit()
			selection.move_to_step(self.channel, step, part)
		end
	end
	
	function el:drag(msg)
		local muted = sfx.channel_is_muted(app.pattern, self.channel)
		if muted or app.follow_playhead then return end
		if channel_dialog and channel_dialog.channel == self.channel then
			return
		end
		if msg.mb == 2 then
			local step <const> = app.starting_row + (msg.my - 1) // app.row_height
			local part <const> = self:x_to_part(msg.mx)
			self.parent:clear_edit()
			selection.move_to_step(self.channel, step, part)
		end
	end
	
	function el:release(msg)
		self.parent.is_selecting = false
		selection.clear_anchor()
	end
	
	function el:x_to_part(x)
		if x < x_instrument then
			return selection.note
		elseif x < x_volume then
			return selection.instrument
		elseif x < x_fx then
			return selection.volume
		else
			return selection.fx
		end
	end
	
	return el
end


-------------------------------------------------------------------------------
-- Channel Header
-------------------------------------------------------------------------------


function ui_notegrid.attach_header(parent, el)
	el.width = app.column_width
	el.height = app.track_header_height
	el.cursor = "pointer"
	el.blink_timer = 0
	parent:attach(el)
	
	function el:draw(msg)
		local muted <const> = sfx.channel_is_muted(app.pattern, self.channel)
		local track <const> = sfx.pattern_track(app.pattern, self.channel)
		local size <const> = sfx.track_size(track)
		local trk_patts <const> = app.track_patterns(track)
		-- Background is drawn by `tracker`
		if self:has_keyboard_focus() then
			rectfill(20, 1, 20 + 14, 7, 7)
			local x_cursor = print(self.str, 22, 2, self.str_is_valid and 55 or 8)
			if self.blink_timer % 32 > 16 then
				line(x_cursor, 1, x_cursor, 7, 14)
			end
		elseif muted or size == 0 then
			--print("\|e\-i.\-e.\-e.", 22, 2, 55)
			print(" + ", 22, 2, 55)
		else
			print(string.format("%03d", track), 22, 2, 55)
			if trk_patts and #trk_patts > 1 then
				pset(15, 4, 55) pset(17, 4, 55) pset(19, 4, 55)
				pset(35, 4, 55) pset(37, 4, 55) pset(39, 4, 55)
			end
		end
	end

	function el:update(msg)
		if self:has_keyboard_focus() then
			self.blink_timer += 1
			while peektext() do
				if #self.str < 3 then
					self.str = self.str .. readtext()
				else
					readtext()
				end
			end

			local val = tonum(self.str)
			self.str_is_valid = val ~= nil and val >= 0 and val < sfx.num_tracks() - 1

			if keyp("backspace") then
				self.str = sub(self.str, 1, -2)
			elseif keyp("escape") or (keyp("enter") and #self.str == 0) then
				self:set_keyboard_focus(false)
				app.was_in_text_field = true
			elseif keyp("enter") or (val and #self.str == 3) then
				if val then
					undo.checkpoint()
					track = mid(val, 0, sfx.num_tracks() - 1)
					sfx.mute_channel(app.pattern, self.channel, false)
					app.set_pattern_track(app.pattern, self.channel, track)
					ui_notegrid.close_channel_dialog()
				end
				self:set_keyboard_focus(false)
				app.was_in_text_field = true
			end
		end
	end
	
	function el:tap(msg)
		if self.last_tap and time() - self.last_tap < 0.4 then return end
		self.last_tap = time()
		local muted <const> = sfx.channel_is_muted(app.pattern, self.channel)
		local track = sfx.pattern_track(app.pattern, self.channel)
		local size <const> = sfx.track_size(track)
		if msg.last_mb == 1 and (not key("ctrl")) then
			local notegrid = self.parent.notegrids[self.channel]
			local has_dialog = channel_dialog and channel_dialog.channel == self.channel
			if channel_dialog then
				ui_notegrid.close_channel_dialog()
			end
			if notegrid and not has_dialog then
				channel_dialog = create_channel_dialog {
					channel = self.channel,
					x = 0, y = 1, width = app.column_width - 1,
					height = notegrid.height - 2,
				}
				notegrid:attach(channel_dialog)
			end
--		elseif size == 0 and not muted then
--			app.mute_channel(app.pattern, self.channel, true)
		elseif msg.last_mb == 2 then
			undo.checkpoint()
			local muted = sfx.channel_is_muted(app.pattern, self.channel)
			app.mute_channel(app.pattern, self.channel, not muted)
		end
	end
	
	function el:doubletap(msg)
		self:set_keyboard_focus(true)
		readtext(true)
		self.str = ""
	end
	
	function el:release(msg)
		self.clicked_prev = false
		self.clicked_next = false
	end

	return el
end


-------------------------------------------------------------------------------
-- Scrollbar
-------------------------------------------------------------------------------


function ui_notegrid.attach_scrollbar(parent, el)
	el.cursor = 1
	parent:attach(el)
	function el:draw(msg)
		local start <const> = app.starting_row
		local max_rows <const> = sfx.pattern_max_size(app.pattern)
		local nb_rows <const> = math.ceil(self.height / app.row_height)
		local scale = self.height / max_rows
		local y = start * scale
		local h = nb_rows * scale + 1
		rrectfill(0, 0, self.width, self.height, 0, 55)
		rrectfill(0, y, self.width, h, 0, 56)
		for r = app.bar_length, max_rows, app.bar_length do
			local y = r * scale
			line(0, y, 3, y, pget(0, y) == 55 and 0 or 55)
		end
		local following_playhead =	sfx.music_is_playing() and app.follow_playhead
		if selection.has_selection() and (not following_playhead) then
			selection.for_each_channel_each_step(
				function(_track, step)
					local y = step * scale
					rect(1, y, 2, y + scale - 1, app.is_editing and 37 or 38)
				end
			)
		end
		if sfx.music_is_playing() then
			local leading_channel = sfx.playing_lead_channel()
			local playing_step = sfx.playing_channel_row(leading_channel)
			local y = playing_step * scale
			line(0, y, 3, y, 36)
		end
	end
	function el:drag(msg)
		local start <const> = app.starting_row
		local max_rows <const> = sfx.pattern_max_size(app.pattern)
		local nb_rows <const> = math.ceil(self.height / app.row_height)
		local scale = self.height / max_rows
--		local y = start * scale
		local h = nb_rows * scale + 1
		local row = flr((msg.my - h / 2) / scale)
		app.starting_row = mid(row, 0, max_rows - nb_rows)
	end
	return el
end


return ui_notegrid
:: src/ui/panel.lua
--[[pod_format="raw",created="2026-02-01 19:17:43",modified="2026-02-16 14:12:04",revision=13752]]
local app = require "src/app.lua"
local selection = require "src/selection.lua"
local sfx = require "src/sfx/sfx.lua"
local ui = require "src/ui/ui.lua"
local ui_routing = require "src/ui/routing.lua"
local ui_panel = {}


----------------------------------------------------------------------------------------------------
-- View Selector
----------------------------------------------------------------------------------------------------


function ui_panel.attach_view_selector(parent, el)
	el.width = 19
	el.height = 34
	el.cursor = "pointer"
	parent:attach(el)
	
	function el:draw(msg)
		--rrectfill(0, 0, self.width, self.height, 0, 47)
		local clicked = msg.mb == 1
		if clicked and false then
			rrectfill(0, 0, self.width, self.height, 0, 58)
		end
		pal(7, app.view == "tracker" and 59 or 58)
		pal(57, app.view == "tracker" and 7 or 57)
		spr(1, 1, 0)
		pal(7, app.view == "synth" and 59 or 58)
		pal(57, app.view == "synth" and 7 or 57)
		spr(3, 1, 18)
		pal(7, 7)
		pal(57, 57)
	end
	
	function el:click(msg)
		if app.view == "synth" then
			app.view = "tracker"
		else
			app.view = "synth"
		end
		app.refresh_gui = true
	end
	
	return el
end


----------------------------------------------------------------------------------------------------
-- Octave Selector
----------------------------------------------------------------------------------------------------


function ui_panel.attach_octave_selector(parent, el)
	el.width = 19
	el.height = 10
	el.cursor = get_spr(50)
	el.blink_timer = 0
	parent:attach(el)
	
	el.drag_start = nil

	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 47)
		-- Base Note
		if self:has_keyboard_focus() then
			rrectfill(4, 2, 11, 7, 0, 7)
			local x_cursor = print(self.str or "", 6, 3, self.str_is_valid and 55 or 8)
			if self.blink_timer % 32 > 16 then
				line(x_cursor, 2, x_cursor, 8, 14)
			end
		else		
			local displayed_note = app.base_note
			if stat(408, 0) == 1 then
				displayed_note = stat(408, 4)
			end
			local note = flr(displayed_note % 12)
			local octave = flr(displayed_note / 12)
			
			local ox_note <const> = 3
			local fg <const> = 4
			pal(7, self.dragged and 7 or fg)
			spr(84 + note, ox_note, 2)
			local x_oct = ox_note + 9
			pal(7, 7)
			print(
				string.format("%1d", octave),
				x_oct, 2 + 1,
				self.dragged and 7 or fg
			)
		end
	end	

	function el:update()
		if self:has_keyboard_focus() then
			self.blink_timer += 1
			while peektext() do
				if #self.str < 3 then
					self.str = self.str .. readtext()
				else
					readtext()
				end
			end
			
			local char_to_note <const> = {
				["c"] = 0, ["c#"] = 1,
				["d"] = 2, ["d#"] = 3,
				["e"] = 4,
				["f"] = 5, ["f#"] = 6,
				["g"] = 7, ["g#"] = 8,
				["a"] = 9, ["a#"] = 10,
				["b"] = 11,
			}
			
			local key_str = self.str:sub(1, -2)
			local key = char_to_note[key_str]
			local oct_str = self.str[#self.str]
			local oct = oct_str and tonumber(oct_str) or nil
			self.str_is_valid = 
				char_to_note[self.str]
				or (oct and #self.str == 1)
				or (key and oct)

			if keyp("backspace") then
				self.str = sub(self.str, 1, -2)
			elseif keyp("escape") or (keyp("enter") and #self.str == 0) then
				self:set_keyboard_focus(false)
				app.was_in_text_field = true
			elseif keyp("enter") or (key and oct) or (oct and #self.str == 1) then
				if not key then
					key = app.base_note % 12
				end
				if key and oct then
					app.base_note = mid(key + 12 * oct, 0, 0xfe)
				end
				self:set_keyboard_focus(false)
				app.was_in_text_field = true
			end
		end
	end
	
	function el:click(msg)
		self.dragged = true
		self.key_mode = msg.mb == 2
		self.cursor = 0
	end
	
	function el:drag(msg)
		local delta = ui.mouse_lock(0.125)
		if self.key_mode then
			app.base_note = mid(0, app.base_note - delta, 12 * 7)
		else
			app.base_note = mid(0, app.base_note - (12 * delta), 12 * 7)
		end
	end
	
	function el:release(msg)
		ui.mouse_unlock()
		self.cursor = get_spr(50)
		self.dragged = nil
		self.key_mode = nil
	end
	
	function el:tap(msg)
		if msg.last_mb == 1 then
			self:set_keyboard_focus(true)
			readtext(true)
			self.str = ""
		end
	end

	function el:doubleclick(msg)
		app.base_note = 48
	end
	
	return el
end


----------------------------------------------------------------------------------------------------
-- Instrument Selector
----------------------------------------------------------------------------------------------------


function ui_panel.attach_instrument_selector(parent, el)
	el.width = 19
	el.height = 16
	el.cursor = get_spr(53)
	el.blink_timer = 0
	parent:attach(el)
	
	el.drag_start = nil

	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 47)
		print("inst", 2, 1, 58)
		if self:has_keyboard_focus() then
			rrectfill(4, 8, 11, 7, 0, 7)
			local x_cursor = print(self.str or "", 6, 9, self.str_is_valid and 55 or 8)
			if self.blink_timer % 32 > 16 then
				line(x_cursor, 8, x_cursor, 14, 14)
			end
		elseif app.instrument == 0xff and self.saved_instrument then
			pal(7, 44)
			spr(64, 6, 9)
			pal(7, 7)
		else
			local sprite = 256 + app.instrument
			pal(7, self.dragged and 7 or 44)
			spr(sprite, 6, 9)
			pal(7, 7)
		end
	end	

	function el:update()
		if self:has_keyboard_focus() then
			self.blink_timer += 1
			while peektext() do
				if #self.str < 2 then
					self.str = self.str .. readtext()
				else
					readtext()
				end
			end
			
			local val = tonumber(self.str, 16)
			self.str_is_valid = val ~= nil

			if keyp("backspace") then
				self.str = sub(self.str, 1, -2)
			elseif keyp("escape") or (keyp("enter") and #self.str == 0) then
				self:set_keyboard_focus(false)
				app.was_in_text_field = true
			elseif keyp("enter") or (val and #self.str == 2) then
				if val then
					app.instrument = mid(val, 0, 0xff)
				end
				self:set_keyboard_focus(false)
				app.was_in_text_field = true
			end
		end
	end
	
	function el:click(msg)
		-- TODO: replace with pull-down menus
		self.dragged = true
		self.cursor = 0
	end
	
	function el:drag(msg)
		if self.dragged then
			local delta = ui.mouse_lock(0.125)
			-- TODO: allow "ff"
			local instrument = mid(0, app.instrument - delta, 0xff)
			if instrument ~= app.instrument then
				app.instrument = instrument
				app.node = 0
				-- TODO: cannot refresh gui in real time (lose mouselock)
				-- instead, recreate just the router?
				self.need_refresh_gui = true
				ui_routing.clear_placement_buttons()
			end
		end
	end
	
	function el:tap(msg)
		if msg.last_mb == 1 then
			self:set_keyboard_focus(true)
			readtext(true)
			self.str = ""
		elseif msg.last_mb == 2 then
			if self.saved_instrument then
				app.instrument = self.saved_instrument
				self.saved_instrument = nil
			else
				self.saved_instrument = app.instrument
				app.instrument = 0xff
			end
		end
	end
	
	function el:release(msg)
		if self.need_refresh_gui then
			app.refresh_gui = true
		end
		ui.mouse_unlock()
		self.cursor = get_spr(53)
		self.dragged = nil
	end

	function el:doubleclick(msg)
		app.instrument = 0
	end
	
	function el:mousewheel(msg)
		-- TODO: allow "ff"
		app.instrument = mid(app.instrument + msg.wheel_y, 0, 0xff)
		-- TODO: only refresh router
		app.refresh_gui = true
	end
	
	return el
end


----------------------------------------------------------------------------------------------------
-- Volume Selector
----------------------------------------------------------------------------------------------------


function ui_panel.attach_volume_selector(parent, el)
	el.width = 19
	el.height = 16
	el.cursor = get_spr(53)
	el.blink_timer = 0
	parent:attach(el)
	
	el.drag_start = nil

	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 47)
		print("vol", 4, 1, 58)
		if self:has_keyboard_focus() then
			rrectfill(4, 8, 11, 7, 0, 7)
			local x_cursor = print(self.str or "", 6, 9, self.str_is_valid and 55 or 8)
			if self.blink_timer % 32 > 16 then
				line(x_cursor, 8, x_cursor, 14, 14)
			end
		else
			local sprite = 256 + app.base_volume
			pal(7, self.dragged and 7 or 46)
			spr(sprite, 6, 9)
			pal(7, 7)
		end
	end	

	function el:update()
		if self:has_keyboard_focus() then
			self.blink_timer += 1
			while peektext() do
				if #self.str < 2 then
					self.str = self.str .. readtext()
				else
					readtext()
				end
			end
			
			local val = tonumber(self.str, 16)
			self.str_is_valid = val ~= nil

			if keyp("backspace") then
				self.str = sub(self.str, 1, -2)
			elseif keyp("escape") or (keyp("enter") and #self.str == 0) then
				self:set_keyboard_focus(false)
				app.was_in_text_field = true
			elseif keyp("enter") or (val and #self.str == 2) then
				if val then
					app.base_volume = mid(val, 0, 0xff)
				end
				self:set_keyboard_focus(false)
				app.was_in_text_field = true
			end
		end
	end
	
	function el:click(msg)
		self.dragged = true
		self.cursor = 0
	end
	
	function el:drag(msg)
		if self.dragged then
			local delta = ui.mouse_lock(0.125)
			app.base_volume = mid(0, app.base_volume - delta, 0xff)
		end
	end
	
	function el:tap(msg)
		if msg.last_mb == 1 then
			self:set_keyboard_focus(true)
			readtext(true)
			self.str = ""
		end
	end
	
	function el:release(msg)
		if self.need_refresh_gui then
			readtext(true)
			app.refresh_gui = true
		end
		ui.mouse_unlock()
		self.cursor = get_spr(53)
		self.dragged = nil
	end

	function el:doubleclick(msg)
		app.instrument = 0
	end
	
	function el:mousewheel(msg)
		app.base_volume = mid(app.base_volume + msg.wheel_y * 0x8, 0, 0x60)
	end
	
	return el
end


----------------------------------------------------------------------------------------------------
-- Step Selector
----------------------------------------------------------------------------------------------------


function ui_panel.attach_step_selector(parent, el)
	el.width = 19
	el.height = 16
	el.cursor = get_spr(53)
	el.blink_timer = 0
	parent:attach(el)
	
	el.drag_start = nil

	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 47)
		print("jump", 2, 1, 58)
		if self:has_keyboard_focus() then
			rrectfill(4, 8, 11, 7, 0, 7)
			local x_cursor = print(self.str or "", 6, 9, self.str_is_valid and 55 or 8)
			if self.blink_timer % 32 > 16 then
				line(x_cursor, 8, x_cursor, 14, 14)
			end
		else
			local str = string.format("%02d", app.jump_step)
			print(str, 6, 9, self.dragged and 7 or 35)
		end
	end	

	function el:update()
		if self:has_keyboard_focus() then
			self.blink_timer += 1
			while peektext() do
				if #self.str < 2 then
					self.str = self.str .. readtext()
				else
					readtext()
				end
			end

			local val = tonumber(self.str)
			self.str_is_valid = val ~= nil

			if keyp("backspace") then
				self.str = sub(self.str, 1, -2)
			elseif keyp("escape") or (keyp("enter") and #self.str == 0) then
				self:set_keyboard_focus(false)
				app.was_in_text_field = true
			elseif keyp("enter") or (val and #self.str == 2) then
				if val then
					app.jump_step = mid(math.floor(val), 0, 99)
				end
				self:set_keyboard_focus(false)
				app.was_in_text_field = true
			end
		end
	end
	
	function el:click(msg)
		self.dragged = true
		self.cursor = 0
	end
	
	function el:drag(msg)
		if self.dragged then
			local delta = ui.mouse_lock(0.125)
			local val = math.floor(app.jump_step - delta)
			app.jump_step = mid(val, 0, 99)
		end
	end
	
	function el:tap(msg)
		self:set_keyboard_focus(true)
		readtext(true)
		self.str = ""
	end
	
	function el:release(msg)
		if self.need_refresh_gui then
			app.refresh_gui = true
		end
		ui.mouse_unlock()
		self.cursor = get_spr(53)
		self.dragged = nil
	end

	function el:doubleclick(msg)
		app.instrument = 0
	end
	
	function el:mousewheel(msg)
		app.jump_step = mid(app.jump_step + msg.wheel_y, 0, 99)
	end
	
	return el
end


----------------------------------------------------------------------------------------------------
-- Pattern Selector
----------------------------------------------------------------------------------------------------


function ui_panel.attach_pattern_selector(parent, el)
	el.width = 19
	el.height = 16
	parent:attach(el)
	
	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 49)
		ui.print_centered("patt", 10, 1, 58)
		ui.print_centered(string.format("%02d", app.pattern), 10, 9, 5) -- 12 or 19
	end
	
	function el:mousewheel(msg)
		app.pattern = mid(app.pattern + msg.wheel_y, 0, sfx.num_patterns() - 1)
	end
	
	return el
end


----------------------------------------------------------------------------------------------------
-- Pattern Arrows
----------------------------------------------------------------------------------------------------


function ui_panel.attach_pattern_arrows(parent, el)
	el.width = 19
	el.height = 13
	el.cursor = "pointer"
	parent:attach(el)
	
	function el:draw(msg)
		--rrectfill(0, 0, self.width, self.height, 0, 47)
		pal(7, self.clicked_prev and 13 or 58)
		spr(43, 2, 2)
		pal(7, self.clicked_next and 13 or 58)
		spr(44, 10, 2)
		pal(7, 7)
	end
	
	function el:click(msg)
		if msg.mx < 9 then
			self.clicked_prev = true
			app.pattern = mid(app.pattern - 1, 0, sfx.num_patterns() - 1)
		elseif msg.mx > 9 then
			self.clicked_next = true
			app.pattern = mid(app.pattern + 1, 0, sfx.num_patterns() - 1)
		end
	end
	
	function el:release(msg)
		self.clicked_prev = false
		self.clicked_next = false
	end
	
	return el
end


----------------------------------------------------------------------------------------------------
-- Pattern Flags
----------------------------------------------------------------------------------------------------


function ui_panel.attach_pattern_flags(parent, el)
	el.width = 22
	el.height = 10 + 2 * 11
	el.cursor = "pointer"
	parent:attach(el)
	
	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 43)
		ui.print_centered("loop", 12, 1, 58)
		pal(58, sfx.pattern_loop_start(app.pattern) and 37
			or (self.clicked_loop_start and 13 or 58))
		spr(40, 2, 10)
		pal(58, sfx.pattern_loop_end(app.pattern) and 37
			or (self.clicked_loop_end and 13 or 58))
		spr(41, 13, 10)
		pal(58, sfx.pattern_loop_stop(app.pattern) and 37
			or (self.clicked_loop_stop and 13 or 58))
		spr(42, 7, 10 + 11)
		pal(58, 58)
	end	
	
	function el:hover(msg)
		if msg.my < 10 then
			self.cursor = 1
		else
			self.cursor = "pointer"
		end
	end
	
	function el:click(msg)
		if msg.my < 10 then
			-- nothing
		elseif msg.my < 22 then
			if msg.mx < 12 then
				self.clicked_loop_start = true
			else
				self.clicked_loop_end = true
			end
		else
			self.clicked_loop_stop = true
		end
	end
	
	function el:tap(msg)
		if msg.my < 10 then
			-- nothing
		elseif msg.my < 22 then
			if msg.mx < 12 then
				local is_on = sfx.pattern_loop_start(app.pattern)
				sfx.set_pattern_loop_start(app.pattern, not is_on)
			else
				local is_on = sfx.pattern_loop_end(app.pattern)
				sfx.set_pattern_loop_end(app.pattern, not is_on)
			end
		else
			local is_on = sfx.pattern_loop_stop(app.pattern)
			sfx.set_pattern_loop_stop(app.pattern, not is_on)
		end
	end
	
	function el:release(msg)
		self.clicked_loop_start = false
		self.clicked_loop_end = false
		self.clicked_loop_stop = false
	end
	
	return el
end


----------------------------------------------------------------------------------------------------
-- Meters
----------------------------------------------------------------------------------------------------


local sample_scale <const> = 32767.0

local last_lpeak = 0
local last_rpeak = 0


function ui_panel.attach_meters(parent, el)
	el.width = 13
	el.height = 52
	parent:attach(el)
	function el:draw(msg)
		local hmet = self.height - 4
		--rrectfill(0, 0, self.width, self.height, 0, 47)
		rrectfill(1, 1, self.width - 2, self.height - 2, 0, 59)
		app.draw_borders(1, 1, self.width - 2, self.height - 2)
		if not app.show_meter then return end
		local ox, oy = 2, self.height - 3
		local n = stat(465, 0, 0x90000)
		local lpeak, rpeak = 0.0, 0.0
		for i = 0, n, 4 do
			local lsample = abs(peek2(0x90000 + i))
			lpeak = max(lpeak, lsample)
			local rsample = abs(peek2(0x90002 + i))
			rpeak = max(rpeak, rsample)
		end
		-- Convert to decibels
		lpeak = 20 * math.log(lpeak / sample_scale, 10)
		rpeak = 20 * math.log(rpeak / sample_scale, 10)
		-- Scale so that -40db = 0 and 0db = 1
		lpeak = 1 + lpeak / app.min_db
		lpeak = mid(lpeak, 0, 1)
		rpeak = 1 + rpeak / app.min_db
		rpeak = mid(rpeak, 0, 1)
		-- Slow down the fall
		lpeak = max(lpeak, last_lpeak - app.meter_speed)
		last_lpeak = lpeak
		rpeak = max(rpeak, last_rpeak - app.meter_speed)
		last_rpeak = rpeak
		app.draw_vert_meter(ox + 0, oy - hmet + 1, 4, hmet, lpeak)
		app.draw_vert_meter(ox + 5, oy - hmet + 1, 4, hmet, rpeak)
--		if lpeak == 1 then rrectfill(ox, oy - hmet + 1, 4, 0.2*hmet, 0, 8) end
--		if rpeak == 1 then rrectfill(ox + 5, oy - hmet + 1, 4, 0.2*hmet, 0, 8) end
	end
	function el:tap(msg)
		if msg.last_mb == 1 then
			app.show_meter = not app.show_meter
		end
	end
	return el
end


----------------------------------------------------------------------------------------------------
-- Record Button
----------------------------------------------------------------------------------------------------


function ui_panel.attach_edit_button(parent, el)
	el.width = 19
	el.height = 15
	el.cursor = "pointer"
	parent:attach(el)

	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 43)
		spr(app.is_editing and 7 or 6, 2, 1)
	end
	
	function el:click()
		app.is_editing = not app.is_editing
		if app.is_editing and sfx.music_is_playing() and app.follow_playhead then
			app.play_or_pause()
		end
	end
	
	return el
end


----------------------------------------------------------------------------------------------------
-- Play Button
----------------------------------------------------------------------------------------------------


function ui_panel.attach_play_button(parent, el)
	el.width = 19
	el.height = 16
	el.cursor = "pointer"
	parent:attach(el)

	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 45)
		spr(sfx.music_is_playing() and 5 or 4, 2, 1)
	end
	
	function el:click()
		app.play_or_pause("follow_playhead")
	end
	
	return el
end


return ui_panel
:: src/ui/params.lua
--[[pod_format="raw",created="2024-04-20 11:45:24",modified="2026-02-16 14:12:04",revision=28146]]
local app = require "src/app.lua"
local sfx = require "src/sfx/sfx.lua"
local undo = require "src/undo.lua"
local ui = require "src/ui/ui.lua"
local ui_menus = require "src/ui/menus.lua"


local ui_params = {}


-------------------------------------------------------------------------------
-- Local Functions
-------------------------------------------------------------------------------


local function attach_relationship(parent, el)
	el.width, el.height = 8, 7
	el.cursor = "pointer"
	parent:attach(el)
	function el:draw()
		local flags, _, _, _ = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
--		rectfill(2, 1, 6, 5, 57)
--		if self.mini then
--			spr(114, 2, 0)
--		else
			spr(112, 1, 0)
--		end
		if flags & 0x03 == 0x01 then
			print("\^:2070200000000000", -1, 2, 63)
		elseif flags & 0x03 == 0x02 then
			print("\^:5020500000000000", -1, 2, 63)
		elseif flags & 0x03 > 0 then
			print("?", 3, 1, 63)
		end
	end
	function el:tap()
		ui_menus.open_relationship(self)
	end
	return el
end


local function attach_multiplier(parent, el)
	el.width, el.height = 13, 7
	el.cursor = "pointer"
	parent:attach(el)
	function el:draw()
		local flags, _, _, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
		clip()
		if self.mini then
			rectfill(0, 2, 2, 4, 57)
			if (env & 0xc0 > 0) then
				rectfill(0, 0, 2, 6, 57)
				print("!", 0, 1, 24)
--			else
--				spr(114, -1, 0)
			end
			return
		end
		--rrectfill(0, 0, self.width, self.height, 0, 47)
		if (env & 0xc0 > 0) then
			local dx = 0
			str2 = (env & 0x20 == 0) and 
				"\^:5020500000000000" or  -- *
				"\^:4020100000000000"     -- /
			if env & 0xc0 == 0x40 then
				str2 = str2 .. "\-c\^:5070400000000000"
				dx = 2 
				spr(113, 0, 0)
			end -- 4
			if env & 0xc0 == 0x80 then
				str2 = str2 .. "\^:1372770000000000"
				dx = 6
				spr(114, 0, 0)
			end -- 16
			if env & 0xc0 == 0xc0 then
				str2 = str2 .. "\^:5177470000000000"
				dx = 6 
				spr(114, 0, 0)
			end -- 64
			clip()
--			rectfill(0, 0, 4 + dx, 6, 57)
			print(str2, -3, 2, 24)
		else
			spr(112, 0, 0)
		end
	end
	function el:tap()
		ui_menus.open_multiplier(self)
	end
	return el
end


local function attach_envelope(parent, el)
	el.width, el.height = 7, 7
	el.cursor = "pointer"
	parent:attach(el)
	function el:draw()
		local flags, _, _, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
		clip()
		if flags & 0x04 > 0 then
			local fg, bg = 7, 18
			if flags & 0x08 > 0 then
				fg, bg = bg, fg
			end
			line(1, 0, self.width - 1 - 1, 0, bg)
			rectfill(0, 1, self.width - 1 - 0, self.height - 1 - 1, bg)
			line(1, self.height - 1 - 0, self.width - 1 - 1, self.height - 1 - 0, bg)
--			line(2, 0, self.width - 3, 0, bg)
--			rectfill(1, 1, self.width - 2, self.height - 2, bg)
--			line(2, self.height - 1, self.width - 3, self.height - 1, bg)
			print(string.format("%x", env & 0x0f), 2, 1, fg)
		elseif flags & 0x10 > 0 then
			line(1, 0, self.width - 1 - 1, 0, 30)
			rectfill(0, 1, self.width - 1 - 0, self.height - 1 - 1, 30)
			line(1, self.height - 1 - 0, self.width - 1 - 1, self.height - 1 - 0, 30)
			print("r", 2, 1, 7)
		else
--			spr(112, 0, -1)
			line(2, 1, self.width - 1 - 2, 1, 57)
			rectfill(1, 2, self.width - 1 - 1, self.height - 1 - 2, 57)
			line(2, self.height - 1 - 1, self.width - 1 - 2, self.height - 1 - 1, 57)
		end
	end
	function el:tap()
		ui_menus.open_envelope(self)
	end
	return el
end


-------------------------------------------------------------------------------
-- Local Functions: Getters and Setters
-------------------------------------------------------------------------------


local function get_val1(self)
	local _, val1, _, _ = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
	if (self.parent.max_val < 128) then
		if (val1 >= 128) val1 -= 256
	end
	return val1
end


local function set_val1(self, val)
	val = mid(self.parent.min_val, val, self.parent.max_val)
	sfx.set_node_param_val1(app.instrument, self.parent.node_id, self.parent.param, val)
end


local function get_val0(self)
	local _, _, val0, _ = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
	if (self.parent.max_val < 128) then
		if (val0 >= 128) val0 -= 256
	end
	return val0
end


local function set_val0(self, val)
	val = mid(self.parent.min_val, val, self.parent.max_val)
	sfx.set_node_param_val0(app.instrument, self.parent.node_id, self.parent.param, val)
end


local function has_env(self)
	local flags, _, _, _ = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
	return flags & (0x4 | 0x10) > 0
end


local function smart_str(self, val)
	local flags, _, _, _ = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
	local node_type = sfx.node_type(app.instrument, self.parent.node_id)
	if node_type == 0x02 and self.parent.param == 0x02 and (flags & 0x03 == 0x02) then
		local num = 1 + val % 16
		local den = 1 + val \ 16
		return num .. "/" .. den
	end
	return tostr(val)
end


-------------------------------------------------------------------------------
-- Full Widget with Knob
-------------------------------------------------------------------------------


function ui_params.attach(parent, x, y, el, style)
	el.x, el.y = x, y
	el.small = small
	el.width, el.height = 35 + 6, 58
	el.small = style.small
	el.emphasis = style.emphasis
	parent:attach(el)
	el:attach(ui.create_knob {
		x = 2, y = 10,
		small = style.small,
		reversed = style.reversed,
		get = get_val1,
		set = set_val1,
		has_secondary = has_env,
		get_secondary = get_val0,
		set_secondary = set_val0,
	})
	attach_relationship(
		el,
		{
			x = -1, y = 41,
		}
	)
	el:attach(ui.create_field {
		x = 8, y = 41,
		centered = true,
		get = get_val1,
		set = set_val1,
		to_str = smart_str,
	})
	attach_multiplier(
		el,
		{
			x = 28, y = 41,
		}
	)
	el:attach(ui.create_field {
		x = 8, y = 51,
		fg = 18, centered = true,
		visible = has_env,
		get = get_val0,
		set = set_val0,
		to_str = smart_str,
	})
	attach_envelope(
		el,
		{
			x = 28, y = 51,
		}
	)
	
	function el:draw()
		--rectfill(0, 0, self.width - 1, self.height - 1, 43)
		if self.emphasis then
			rectfill(0, 0, self.width - 1 - 6, 8, 56)
		else
			rectfill(0, 0, self.width - 1 - 6, 8, 56)
		end
		ui.print_centered(
			el.long_label or el.label,
			(self.width - 6) // 2 + 1, 2,
			self.emphasis and 6 or 6
		)
	end	
	
	function el:click() return true end
	function el:doubleclick() return true end
	
	return el
end


-------------------------------------------------------------------------------
-- Mini Widget
-------------------------------------------------------------------------------


function ui_params.attach_mini(parent, el)
	el.x = el.x or 0
	el.y = el.y or (14 + 10 * el.param)
	el.width = parent.width
	el.height = 10
	parent:attach(el)
	attach_relationship(
		el,
		{
			x = 23, y = 0,
			mini = true,
		}
	)
	el:attach(ui.create_field {
		x = 24 + 7, y = 0,
		get = get_val1,
		set = set_val1,
		to_str = smart_str,
	})
	attach_multiplier(
		el,
		{
			x = 24 + 7 + 20, y = 0,
			mini = true,
		}
	)
	el:attach(ui.create_field {
		x = 24 + 7 + 20 + 4, y = 0,
		fg = 18,
		visible = has_env,
		get = get_val0,
		set = set_val0,
		to_str = smart_str,
	})
	attach_envelope(
		el,
		{
			x = 24 + 7 + 20 + 4 + 20, y = 0,
		}
	)
	function el:draw()
		print(self.label, 24 - (4 * #self.label), 1, 56)
		---print(self.label, 2, 1, 5)
	end
	
	function el:click() return true end
	function el:doubleclick() return true end
end


return ui_params
:: src/ui/routing.lua
--[[pod_format="raw",created="2024-04-13 06:33:13",modified="2026-02-16 14:12:04",revision=27771]]
local app = require "src/app.lua"
local sfx = require "src/sfx/sfx.lua"
local ui = require "src/ui/ui.lua"
local ui_visual = require "src/ui/visual.lua"
local undo = require "src/undo.lua"


local ui_routing = {}


-------------------------------------------------------------------------------
-- Locals
-------------------------------------------------------------------------------


local node_width <const> = 26
local node_height <const> = 16 -- TODO: if 7 vertical nodes, lower to 15?
local node_gap <const> = 14


local placement_buttons = {}


local function attach_placement_button(el)
	el.x -= 3
	el.y -= 3
	el.width = 7 -- TODO
	el.height = 7
	el.cursor = "pointer"
	app.routing_widget:attach(el)
	add(placement_buttons, el)
	function el:draw()
		local x, y = 3, 3
		rectfill(
			x - 2, y - 3, 
			x + 2, y + 3,
			24
		)
		rectfill(
			x - 3, y - 2,
			x + 3, y + 2,
			24
		)
		print("+", x - 1, y - 2, 7)
	end
	function el:click()
		return true -- ed_inst click() refreshes gui
	end
	function el:tap()
		ui_routing.clear_placement_buttons()
		undo.checkpoint()
		local new_node = sfx.add_node(app.instrument, self.parent_id,
			self.new_node_type, self.new_node_op, self.target_id, self.child_id)
		if app.node then
			app.node = new_node
		end
		app.refresh_gui = true
	end
	return el
end


local function attach_insert_between_parent(new_node_type, new_node_op, node, pos)
--	if (node == sfx.root) return
--	if (new_node_type >= 8) return
--	if new_node_type == 2 and new_node_op > 0 then
--		if (node.parent == sfx.root) return
--	end
	if node == sfx.root then return end
	attach_placement_button {
		parent_id = node.parent.id, target_id = node.id, child_id = node.id,
		new_node_type = new_node_type, new_node_op = new_node_op,
		x = pos.x - 2, y = pos.y + 4,
	}
end


local function attach_insert_top_child(new_node_type, new_node_op, node, pos)
--	if new_node_type >= 8 then
--		if (node == sfx.root) return
--		if (node.type >= 8) return
--	end
	if #node.children == 0 then
		-- add only child
		attach_placement_button {
			parent_id = node.id, target_id = node.id + 1,
			new_node_type = new_node_type, new_node_op = new_node_op,
			x = pos.x + node_width + 2, y = pos.y + 4,
		}
	else
		-- add above first child
		attach_placement_button {
			parent_id = node.id, target_id = node.id + 1,
			new_node_type = new_node_type, new_node_op = new_node_op,
			x = pos.x + node_width + node_gap + node_width \ 2, y = pos.y - 0,
		}
	end
end


local function attach_insert_sibling_below(new_node_type, new_node_op, node, pos)
	if (node == sfx.root) return
	attach_placement_button {
		parent_id = node.parent.id, target_id = node:last_child().id + 1,
		new_node_type = new_node_type, new_node_op = new_node_op,
		x = pos.x + node_width \ 2, y = pos.y + 8
	}
end


local function start_new_node(new_node_type, new_node_op, mode)
--	app.node = nil
--	app.refresh_gui = true
	for n = 0, 7 do
		local node = sfx.nodes[n]
		local pos = node.position
		if (not pos) break -- TODO: when does this occur?
		-- Coordinates from logical position
		pos.x = 4 + pos.column * (node_width + node_gap)
		pos.y = 4 + pos.row * node_height
		local ppos = node.parent.position
		ppos.x = 4 + ppos.column * (node_width + node_gap)
		ppos.y = 4 + ppos.row * node_height
		
		if mode == "anything-goes" then
			attach_insert_between_parent(new_node_type, new_node_op, node, pos)
			attach_insert_top_child(new_node_type, new_node_op, node, pos)
			attach_insert_sibling_below(new_node_type, new_node_op, node, pos)
			goto continue
		end
		
		if new_node_type == 2 and new_node_op > 0 then
			-- Modulators --
			if node != sfx.root and node.parent != sfx.root then
				-- insert between parent
				attach_placement_button {
					parent_id = node.parent.id, target_id = node.id, child_id = node.id,
					new_node_type = new_node_type, new_node_op = new_node_op,
					x = pos.x - 2, y = pos.y + 4,
				}
			end
			if node.type == 2 then -- and node.op == 0 then
				if #node.children == 0 then
					-- add only child
					attach_placement_button {
						parent_id = node.id, target_id = node.id + 1,
						new_node_type = new_node_type, new_node_op = new_node_op,
						x = pos.x + node_width + 2, y = pos.y + 4,
					}
				elseif node.children[1].type != 2 or node.children[1].op == 0 then
					-- add above first child
					attach_placement_button {
						parent_id = node.id, target_id = node.id + 1,
						new_node_type = new_node_type, new_node_op = new_node_op,
						x = pos.x + node_width + node_gap + node_width \ 2, y = pos.y - 0,
					}
				end
			end
			
		elseif new_node_type == 2 then
			-- Oscillators --
			if node != sfx.root and not (node.type == 2 and node.op > 0) then
				-- insert between parent
				attach_placement_button {
					parent_id = node.parent.id, target_id = node.id, child_id = node.id,
					new_node_type = new_node_type, new_node_op = new_node_op,
					x = pos.x - 2, y = pos.y + 4,
				}
			end
			if node != sfx.root then
				-- add sibling below
				attach_placement_button {
					parent_id = node.parent.id, target_id = node:last_child().id + 1,
					new_node_type = new_node_type, new_node_op = new_node_op,
					x = pos.x + node_width \ 2, y = pos.y + 8
				}
			end
			if node.type == 2 or node == sfx.root then
				if #node.children == 0 then
					-- add only child
					attach_placement_button {
						parent_id = node.id, target_id = node.id + 1,
						new_node_type = new_node_type, new_node_op = new_node_op,
						x = pos.x + node_width + 2, y = pos.y + 4,
					}
				elseif node.children[1].type != 2 	or node.children[1].op == 0 then
					-- add above first child
					attach_placement_button {
						parent_id = node.id, target_id = node.id + 1,
						new_node_type = new_node_type, new_node_op = new_node_op,
						x = pos.x + node_width + node_gap + node_width \ 2, y = pos.y - 0,
					}
				end
			end
			
		else
			-- Effects --
			if node != sfx.root then
				-- add sibling below
				attach_placement_button {
					parent_id = node.parent.id, target_id = node:last_child().id + 1,
					new_node_type = new_node_type, new_node_op = new_node_op,
					x = pos.x + node_width \ 2, y = pos.y + 8
				}
			end
			if 	node.type == 2 then
				if #node.children == 0 then
					-- add only child
					attach_placement_button {
						parent_id = node.id, target_id = node.id + 1,
						new_node_type = new_node_type, new_node_op = new_node_op,
						x = pos.x + node_width + 2, y = pos.y + 4,
					}
				elseif node.children[1].type != 2 or node.children[1].op == 0 then
					-- add above first child
					attach_placement_button {
						parent_id = node.id, target_id = node.id + 1,
						new_node_type = new_node_type, new_node_op = new_node_op,
						x = pos.x + node_width + node_gap + node_width \ 2, y = pos.y - 0,
					}
				end
			end
		end
		::continue::
	end -- for n = 0, 7
end


function ui_routing.clear_placement_buttons()
	local cleared_something = #placement_buttons > 0
	for i = 1, #placement_buttons do
		placement_buttons[i]:detach()
	end
	placement_buttons = {}
	return cleared_something
end


-- Routing display -------------------------------------------------------------


function ui_routing.attach(parent, el)
	parent:attach(el)
	ui_routing.attach_node_chooser(el, { x = el.width - 87, y = 58 })
	ui_visual.attach_node_oscillo(el, 8, {
		x = el.width - 87, y = 4,
		width = 81, height = 50,
		border = 60,
		horiz_scale = 2,
	})
	
	function el:draw()
		rectfill(0, 0, self.width, self.height, 59)
		-- Overview and Wavetable buttons
		for i, label in ipairs({"all","wt 0","wt 1","wt 2","wt 3"}) do
			local bg = (i == 1) and 7 or 60
			local fg = (i == 1) and 22 or 63
			rrectfill(4, 4 + i * node_height, node_width + 1, 9, 0, bg)
			print(label, 10 + (i==1 and 2 or 0), 4 + i * node_height + 2, fg)
			if app.node then
				-- nothing to do
			elseif
				(i == 1 and not app.wt)
				or (i == 2 and app.wt == 0)
				or (i == 3 and app.wt == 1)
				or (i == 4 and app.wt == 2)
				or (i == 5 and app.wt == 3)
			then
				rect(4 - 1, 4 + i * node_height - 1, 4 + node_width + 1, 4 + i * node_height + 8 + 1, 0)
				rect(4 - 2, 4 + i * node_height - 2, 4 + node_width + 2, 4 + i * node_height + 8 + 2, 24)
			end
		end
		-- Routing graph
		for n = 0, 7 do
			local node = sfx.nodes[n]
			local pos = node.position
			if (not pos) break -- TODO: when does this occur?
			-- Coordinates from logical position
			pos.x = 4 + pos.column * (node_width + node_gap)
			pos.y = 4 + pos.row * node_height
			local ppos = node.parent.position
			ppos.x = 4 + ppos.column * (node_width + node_gap)
			ppos.y = 4 + ppos.row * node_height

			if app.node == n then
				rect(pos.x - 2, pos.y - 2, pos.x + node_width + 2, pos.y + 8 + 2, 24)
				rect(pos.x - 1, pos.y - 1, pos.x + node_width + 1, pos.y + 8 + 1, 0)
			end
			
			if node.type >= 8 and node.older_sibling then
				-- Horizontal bracket
				local col = 6
				local x = pos.x + node_width \ 2
				local orig = node.older_sibling
				local depth = 0
				while #orig.children > 0 and depth < 8 do
					orig = orig.children[#orig.children]
					depth += 1
				end
				local orig_x = orig.position.x + node_width
				line(x - (node_width \ 2) - 3, pos.y - 4, x - (node_width \ 2) - 3 - 2, pos.y - 6, col)
				line(x - 3, pos.y - 4, x - (node_width \ 2) - 3, pos.y - 4, col)
				line(x, pos.y - 2, x - 2, pos.y - 4, col)
				line(x, pos.y - 2, x + 2, pos.y - 4, col)
				line(x + 3, pos.y - 4, orig_x + 3, pos.y - 4, col)
				line(orig_x + 3, pos.y - 4, orig_x + 3 + 2, pos.y - 6, col)
			elseif node != sfx.root then
				-- Arrow
				line(
					ppos.x + node_width + 7, ppos.y + 4,
					ppos.x + node_width + 1, ppos.y + 4,
					7
				)
				line(
					pos.x - 7, pos.y + 4,
					ppos.x + node_width + 7, ppos.y + 4,
					7
				)
				line(
					pos.x - 1, pos.y + 4,
					pos.x - 7, pos.y + 4,
					7
				)
				line(pos.x - 2, pos.y + 3, pos.x - 2, pos.y + 5, 7)
				line(pos.x - 3, pos.y + 2, pos.x - 3, pos.y + 6, 7)
			end
			
			-- Node boxes
			local str = "??? "
			local fg = 63
			local bg = 30
			if node == sfx.root then str = "main"; fg = 22; bg = 7
			elseif node.type == 2 then
				if node.op == 0 then str = "osc " .. n; bg = 17
				elseif node.op == 1 then str = "fm " .. n; bg = 27
				elseif node.op == 2 then str = "ring " .. n; bg = 22
				end
			elseif node.type == 8 then str = "filt " .. n; bg = 14
			elseif node.type == 9 then str = "echo " .. n; bg = 31
			elseif node.type == 10 then str = "shap " .. n; bg = 9
			end
			rectfill(pos.x, pos.y, pos.x + node_width, pos.y + 8, bg)
			ui.print_centered(str, pos.x + (node_width \ 2) + 1, pos.y + 2, fg)
			if sfx.node_flags(app.instrument, node.id) & 0x2 ~= 0 then
				line(pos.x + 2, pos.y + 4,
					pos.x + node_width - 2, pos.y + 4,
					8)
			end
		end
		clip()
		line()
		line(1, -1, 58)
		line(self.width - 2, -1, 58)
		line(self.width, 1, 58)
		line(self.width, self.height - 2, 57)
		line(self.width - 2, self.height, 57)
		line(1, self.height, 57)
		line(-1, self.height - 2, 57)
		line(-1, 1, 58)
		line(1, -1, 58)
		clip(self.sx, self.sy, self.width - 1, self.height - 1)
	end
	
	function el:hover(msg)
		self.cursor = 1
		if (#placement_buttons != 0) return
		for n = 0, 7 do
			local node = sfx.nodes[n]
			local pos = node.position
			if
				pos and pos.x and pos.x <= msg.mx and msg.mx <= pos.x + node_width
				and pos.y <= msg.my and msg.my <= pos.y + 10
			then
				self.cursor = "pointer"
			end
		end
		if msg.mx <= node_width + 4 then
			if (msg.my >= 4 + node_height and msg.my <= 4 + node_height + 10)
				or (msg.my >= 4 + 2 * node_height and msg.my <= 4 + 2 * node_height + 10)
				or (msg.my >= 4 + 3 * node_height and msg.my <= 4 + 3 * node_height + 10)
				or (msg.my >= 4 + 4 * node_height and msg.my <= 4 + 4 * node_height + 10)
				or (msg.my >= 4 + 5 * node_height and msg.my <= 4 + 5 * node_height + 10)
			then
				self.cursor = "pointer"
			end
		end
	end

	function el:click(msg)
		if #placement_buttons != 0 then
			ui_routing.clear_placement_buttons()
			return
		end
		for n = 0, 7 do
			local node = sfx.nodes[n]
			local pos = node.position
			if
				pos and pos.x and pos.x <= msg.mx and msg.mx <= pos.x + node_width
				and pos.y <= msg.my and msg.my <= pos.y + 10
			then
				if msg.mb == 1 then
					app.node = n
					app.refresh_gui = true
				else
					local flags = sfx.node_flags(app.instrument, node.id)
					flags ^^= 0x2
					sfx.set_node_flags(app.instrument, node.id, flags)
				end
				return true
			end
		end
		if msg.mx <= node_width + 4 then
			if msg.my >= 4 + node_height and msg.my <= 4 + node_height + 10 then
				app.node = nil
				app.wt = nil
				app.refresh_gui = true
				return true
			elseif msg.my >= 4 + 2 * node_height and msg.my <= 4 + 2 * node_height + 10 then
				app.node = nil
				app.wt = 0
				app.refresh_gui = true
				return true
			elseif msg.my >= 4 + 3 * node_height and msg.my <= 4 + 3 * node_height + 10 then
				app.node = nil
				app.wt = 1
				app.refresh_gui = true
				return true
			elseif msg.my >= 4 + 4 * node_height and msg.my <= 4 + 4 * node_height + 10 then
				app.node = nil
				app.wt = 2
				app.refresh_gui = true
				return true
			elseif msg.my >= 4 + 5 * node_height and msg.my <= 4 + 5 * node_height + 10 then
				app.node = nil
				app.wt = 3
				app.refresh_gui = true
				return true
			end
		end
	end
	
	return el
end


-- Node chooser ----------------------------------------------------------------


local node_choice = {
	[0] = {
		[0] = { label = "osc", color = 17, node_type = 0x2, node_op = 0x0 },
		{ label = "fm", color = 27, node_type = 0x2, node_op = 0x1 },
		{ label = "ring", color = 22, node_type = 0x2, node_op = 0x2 },
	},
	{
		[0] = { label = "filt", color = 14, node_type = 0x8, node_op = 0x0 },
		{ label = "echo", color = 31, node_type = 0x9, node_op = 0x0 },
		{ label = "shap", color = 9, node_type = 0x0a, node_op = 0x0 },
	},
}


function ui_routing.attach_node_chooser(parent, el)
	el.width = 118
	el.height = 50
	parent:attach(el)
	
	for i = 1, #placement_buttons do
		app.routing_widget:attach(placement_buttons[i])
	end

	function el:draw()
		--- rectfill(0, 0, self.width - 1, self.height - 1, 0)
		if #placement_buttons > 0 then
			print("choose position...", 4, 28, 22)
			return
		end
		if sfx.root.free_nodes == 0 then
			print("(8 nodes max)", 22, 28, 22)
			return
		end
		print("add module:", 4, 2, 57)
		local ox, oy = 4, 12
		for row = 0, #node_choice do
			for column = 0, #(node_choice[row]) do
				local x = ox + column * node_width
				local y = oy + row * (8 + 4)
				local col = node_choice[row][column].color
				rectfill(x, y, x + (node_width - 6), y + 8, col)
				ui.print_centered(
					node_choice[row][column].label,
					x + ((node_width - 6) \ 2) + 1,
					y + 2,
					63
				)
			end
		end
	end
	
	function el:hover(msg)
		self.cursor = 1
		if (#placement_buttons > 0) return
		if (sfx.root.free_nodes == 0) return
		local ox, oy = 4, 12
		for row = 0, #node_choice do
			for column = 0, #(node_choice[row]) do
				local x = ox + column * node_width
				local y = oy + row * (8 + 4)
				if
					x <= msg.mx and msg.mx <= x + (node_width - 6)
					and y <= msg.my and msg.my <= y + 8
				then
					self.cursor = "pointer"
				end
			end
		end
	end

	function el:click(msg)
		return true -- don't want to deselect the node!
	end
	
	function el:tap(msg)
		if #placement_buttons > 0 then
			ui_routing.clear_placement_buttons()
			return
		end
		if (sfx.root.free_nodes == 0) return
		local ox, oy = 4, 12
		for row = 0, #node_choice do
			for column = 0, #(node_choice[row]) do
				local x = ox + column * node_width
				local y = oy + row * (8 + 4)
				if
					x <= msg.mx and msg.mx <= x + (node_width - 6)
					and y <= msg.my and msg.my <= y + 8
				then
					start_new_node(
						node_choice[row][column].node_type,
						node_choice[row][column].node_op,
						msg.last_mb == 2 and "anything-goes"
					)
				end
			end
		end
	end
	

	return el
end


return ui_routing
:: src/ui/settings.lua
--[[pod_format="raw",created="2024-04-30 07:47:36",modified="2026-02-16 14:12:04",revision=25208]]
local settings = require "src/settings.lua"
local ui = require "src/ui/ui.lua"


local ui_settings = {}


-------------------------------------------------------------------------------
-- Settings Dialog
-------------------------------------------------------------------------------


function ui_settings.open()
	local el = { width = 480 - 300, height = 270 - 11 - 60 }
	ui.open_modal(el)
	el:attach(ui.create_label { x = 20, y = 30, label = "keys for playing notes", fg = 55})
	el:attach(ui.create_label { x = 20, y = 40, label = "- layout:", fg = 55})
	el:attach(ui.create_menu_button {
		x = 58, y = 40 - 2,
		bg = 7,
		get_label = function()
			return settings.user.pitched_layout
		end,
		fg = 59,
		highlight = 15,
		items = {
			{
				label = "piano",
				action = function()
					settings.change_keys(settings.piano_keys)
					settings.change_user { pitched_layout = "piano" }
				end
			},
			{
				label = "guitar",
				action = function()
					settings.change_keys(settings.guitar_keys)
					settings.change_user { pitched_layout = "guitar" }
				end
			},
			{
				label = "guitar (split)",
				action = function()
					settings.change_keys(settings.gl_two_handed_keys)
					settings.change_user { pitched_layout = "guitar (split)" }
				end
			},
			--[[
			{
				label = "major-thirds (split)",
				action = function()
					settings.change_keys(settings.major_thirds_keys)
					settings.change_user { pitched_layout = "major-thirds" }
				end
			},
			--]]
			{
				label = "chromatic",
				action = function()
					settings.change_keys(settings.chromatic_keys)
					settings.change_user { pitched_layout = "chromatic" }
				end
			},
		}		
	})
	
	el:attach(ui.create_label { x = 20, y = 60, label = "visuals:", fg = 55})
	el:attach(ui.create_toggle {
		x = 26, y = 72 - 1,
		label = "",
		fg = 55, check_fg = 18,
		get = function(self) return settings.user.sustain_line_enabled end,
		set = function(self, val) settings.change_user({ sustain_line_enabled = val }) end,
	})
	el:attach(ui.create_label {
		x = 44, y = 72,
		fg = 55,
		label = "sustain lines",
	})
	el:attach(ui.create_toggle {
		x = 26, y = 84 - 1,
		label = [[]],
		fg = 55, check_fg = 18,
		get = function(self) return settings.user.instrument_square_enabled end,
		set = function(self, val) settings.change_user({ instrument_square_enabled = val }) end,
	})
	el:attach(ui.create_label {
		x = 44, y = 84,
		fg = 55,
		label = "show unchanged instr. as \^:001c1c1c00000000",
	})
	
	el:attach(ui.create_label { x = 20, y = 140, label = "mouse movements (knobs, sliders, ...)", fg = 55})
	el:attach(ui.create_label { x = 20, y = 150, label = "- sensitivity:", fg = 55})
	el:attach_field {
		x = 78, y = 150 - 1,
		width = 30, height = 7,
		get = function() return settings.user.drag_sensitivity end,
		set = function(self, val)
			local v = mid(0.0, tonum(val), 8.0)
			if (v == 0) v = 0.5
			settings.change_user { drag_sensitivity = v }
		end
	}
	
	el:attach(ui.create_button {
		x = 140, y = el.height - 18,
		label = "close", fg = 5,
		action = function(self)
			ui.close_modal()
		end,
	})
	
	function el:draw()
		local width, height = self.width, self.height
		local xw, yh = self.width - 1, self.y - 1
		rrectfill(0, 0, width, height, 0, 6)
		local xw, yh = 0 + width - 2, 0 + height - 2
		line(0 + 1, yh, 0 + 1, 0 + 1, 57)
		line(0 + 2, yh, 0 + 2, 0 + 1, 57)
		line(0 + 1, 0 + 1, xw, 0 + 1, 57)
		line(0 + 2, 0 + 2, xw, 0 + 2, 57)
		line(xw, yh, xw, 0 + 1, 58)
		line(xw - 1, yh, xw - 1, 0 + 2, 58)
		line(0 + 1, yh, xw, yh, 58)
		line(0 + 2, yh - 1, xw, yh - 1, 58)
		rrect(0 + 0, 0 + 0, width, height, 0, 0)
		rrectfill(0 + 4, 0 + 4, width - 8, 11, 0, 55)
		ui.print_centered("settings", 0 + width // 2, 0 + 7, 6)
	end
	
	function el:click()
		return true
	end
end


return ui_settings

:: src/ui/synth.lua
--[[pod_format="raw",created="2024-04-10 15:43:44",modified="2026-02-16 14:12:04",revision=29940]]
local app = require "src/app.lua"
local settings = require "src/settings.lua"
local sfx = require "src/sfx/sfx.lua"
local ui = require "src/ui/ui.lua"
local ui_envelopes = require "src/ui/envelopes.lua"
local ui_nodes = require "src/ui/nodes.lua"
local ui_panel = require "src/ui/panel.lua"
local ui_routing = require "src/ui/routing.lua"
local ui_visual = require "src/ui/visual.lua"
local ui_wavetable = require "src/ui/wavetable.lua"


local ui_synth = {}


-------------------------------------------------------------------------------
-- Locals
-------------------------------------------------------------------------------


local instr_chooser = false


-------------------------------------------------------------------------------
-- Synth View
-------------------------------------------------------------------------------


function ui_synth.attach(parent, el)
--	el.width = 480 - (app.detail and app.detail_width or 0)
--	el.height = 270 - 11 -- TODO: remove - 16
	parent:attach(el)
	
	app.is_editing = false

	sfx.refresh_nodes(app.instrument)	

	local chooser_start = instr_chooser and instr_chooser.start or 0
	instr_chooser = ui_synth.attach_instr_chooser(el, {
		x = app.panel_width + 4 - 4, y = 4
	})
	instr_chooser.start = chooser_start
	
	app.routing_widget = ui_routing.attach(el, {
		x = app.panel_width + 90 - 4, y = 4,
		width = 356, height = 97,
	})

	ui_panel.attach_meters(el, { x = 464, y = 3 })
	
	ui_panel.attach_view_selector(el, { x = 0, y = 4 })
	ui_panel.attach_octave_selector(el, { x = 0, y = 45 })
	ui_panel.attach_instrument_selector(el, { x = 0, y = 57 })
	ui_panel.attach_volume_selector(el, { x = 0, y = 75 })
	
	local dx = app.synth_width + app.synth_gap
	local dy = app.synth_height + app.synth_gap
	local ox = (480 - (4 * dx) + app.synth_gap) \ 2
	local oy = 270 - 11 - (2 * app.synth_height) - app.synth_gap - 2
			
	if app.node then
		ui_nodes.attach_node_panel(
			el,
			{
				x = ox + app.mod_width + app.synth_gap, y = oy , 
				node_id = app.node,
				large = true,
			}
		)
		for row = 0, 1 do
			ui_envelopes.attach_panel(
				el,
				{
					x = 1, y = oy + row * dy, 
					env_id = row, large = true,
				}
			)
			ui_envelopes.attach_panel(
				el,
				{
					x = 480 - 2 * app.mod_width - 2 * app.synth_gap, y = oy + row * dy,
					env_id = 2 + row, large = true,
				}
			)
		end
	elseif not app.wt then
		local id = 0
		for row = 0, 1 do
			ui_envelopes.attach_panel(
				el,
				{
					x = 1, y = oy + row * dy, 
					env_id = row,
				}
			)
			for column = 0, 3 do
				ui_nodes.attach_node_panel(
					el,
					{
						x = ox + column * dx, y = oy + row * dy, 
						node_id = id
					}
				)
				id += 1
			end
			ui_envelopes.attach_panel(
				el,
				{
					x = 480 - app.mod_width - 4 - 2, y = oy + row * dy,
					env_id = 2 + row,
				}
			)
		end
	else -- A wavetable is selected
		ui_wavetable.attach(
			el,
			{
				x = 4, y = oy, 
			}
		)
	end

	function el:draw()
		local w <const> = self.width
		local h <const> = self.height
		cls(6)
		line(0, 0, w - 1, 0, 57)
		line(0, 0, 0, h - 1, 57)
		line(0, 106, w - 1, 106, 57)
		line(0, 105, w - 1, 105, 58)
		line(w - 1, 0, w - 1, h - 1, 58)
		line(0, h - 1, w - 1, h - 1, 58)
		-- divider
		line(3, 41, app.panel_width - 4, 41, 58)
		line(3, 42, app.panel_width - 4, 42, 57)
		if app.node then
			line(0, 183, 125, 183, 57)
			line(354, 183, 480, 183, 57)
			line(126, 106, 126, h - 1, 57)
			line(355, 106, 355, h - 1, 57)
			line(0, 182, 125, 182, 58)
			line(354, 182, 480, 182, 58)
			line(125, 106, 125, h - 1, 58)
			line(354, 106, 354, h - 1, 58)
		elseif not app.wt then
			line(0, 183, w - 1, 183, 57)
			line(64, 106, 64, h - 1, 57)
			line(152, 106, 152, h - 1, 57)
			line(240, 106, 240, h - 1, 57)
			line(328, 106, 328, h - 1, 57)
			line(416, 106, 416, h - 1, 57)
			line(0, 182, w - 1, 182, 58)
			line(63, 106, 63, h - 1, 58)
			line(151, 106, 151, h - 1, 58)
			line(239, 106, 239, h - 1, 58)
			line(327, 106, 327, h - 1, 58)
			line(415, 106, 415, h - 1, 58)
		end
	end	
	
	function el:update()
		-- Keys
		if ui.has_modal_or_menu() then return end
		if ui.head():get_keyboard_focus_element() then return end
		if app.was_in_text_field and not keyp() then
			return
		end
		app.was_in_text_field = false
		
		if keyp(settings.keys.play) and not currently_focused then
			app.play_or_pause(key("shift") and "follow_playhead" or nil)
		end

		local pitch, just_pressed = app.pitched_key()
		if pitch and not key("ctrl") then
			if just_pressed then
				note(pitch, app.instrument, app.base_volume,
					ord(" "), 0x00,
					8, -- channel 8 so it can play with pattern
					false -- don't force retrigger
				)
			end
		else
			note(0xff, 0xff, 0xff, 0xff, 0xff, 8)
		end
		
		if key("ctrl") and keyp("c") then
			local data = userdata("u8", 0x200)
			set(data, 0, peek(0x40000 + (app.instrument * 0x200), 0x200))
			set_clipboard(
				pod(
					{ instrument = data },
					7,
					{ pod_type = "instrument" }
				)
			)
			notify("copied instrument")
		end
		
		if key("ctrl") and keyp("v") then
			local data = unpod(get_clipboard())
			if data and type(data.instrument == "userdata") then
				poke(
					0x40000 + (app.instrument * 0x200),
					get(data.instrument, 0, 0x200)
				)
				app.refresh_gui = true
				app.node = 0
				notify("pasted instrument")
			else
				nodify("unable to paste instrument: invalid data in clipboard")
			end
		end
	end

	return el
end


-------------------------------------------------------------------------------
-- Instrument chooser
-------------------------------------------------------------------------------


function ui_synth.attach_instr_chooser(parent, el)
	el.width = 82
	el.height = 81
	el.start = 0
	parent:attach(el)
	
	local nb_rows <const> = 9
	local h_row <const> = 8

	function el:draw()
		rectfill(0, 0, self.width, self.height, 59)
		-- Rows
		for i = 0, nb_rows  do
			local instrument = self.start + i
			if instrument == app.instrument then
				rectfill(0, i * h_row, self.width, (i * h_row) + h_row, 4)
			end
			local name = sfx.instrument_name(instrument)
			if name == "" then name = "---" end
			print(string.format("%02x", instrument), 2, 2 + i * h_row, 45)
			print(":", 2 + 8, 2 + i * h_row, 58)
			print(name, 2 + 14, 2 + i * h_row, 57)
		end
		-- Border
		clip()
		line()
		line(1, -1, 58)
		line(self.width - 2, -1, 58)
		line(self.width, 1, 58)
		line(self.width, self.height - 2, 57)
		line(self.width - 2, self.height, 57)
		line(1, self.height, 57)
		line(-1, self.height - 2, 57)
		line(-1, 1, 58)
		line(1, -1, 58)
		clip(self.sx, self.sy, self.width, self.height)
	end
	
	function el:click(msg)
		app.instrument = self.start + (msg.my - 2) // h_row
		ui_routing.clear_placement_buttons()
		if app.node then
			app.node = 0
		end
		app.refresh_gui = true
--		return true
	end
	
	function el:mousewheel(msg)
		self.start -= msg.wheel_y
		self.start = mid(self.start, 0, sfx.num_instruments() - 1 - nb_rows)
	end

	return el
end


return ui_synth
:: src/ui/toolrack.lua
--[[pod_format="raw",created="2026-02-08 05:11:28",modified="2026-02-16 14:12:04",revision=9717]]
local app = require "src/app.lua"
local ui = require "src/ui/ui.lua"
local ui_visual = require "src/ui/visual.lua"
local selection = require "src/selection.lua"
local sfx = require "src/sfx/sfx.lua"
local undo = require "src/undo.lua"


local toolrack = {}


-------------------------------------------------------------------------------
-- LOCALS
-------------------------------------------------------------------------------


local function create_nyi(el)
	ui.head():new(el)
	function el:draw()
		local cx = self.width // 2
		local cy = self.height // 2
		ui.print_centered(
			"(the \""..self.name.."\" tool is not yet implemented)", 
			cx, cy,
			56
		)
	end
	return el
end


-------------------------------------------------------------------------------
-- Pattern Tool
-------------------------------------------------------------------------------


local patt_width <const> = 26
local function create_pattern_list(el)
	el.start = 0
	ui.head():new(el)
	function el:draw(msg)
		local max_pattern = sfx.num_patterns() - 1
		local playing_pattern = sfx.playing_pattern()
		--local playing_row = sfx.playing_row()
		--local row_width = patt_width // (app.bar_length // app.beat_length)
		rrectfill(1, 1, self.width - 2, self.height - 2, 0, 59)
		clip(self.sx + 1, self.sy + 1, self.width - 2, self.height - 2)
		local nb_cols = (self.width - 2) // patt_width
		for i = 0, nb_cols do
			local pattern = self.start + i
			if pattern > max_pattern then break end
			local channels = sfx.pattern_channels(pattern)
			local x = 1 + i * patt_width
			local y = 8
			if pattern == playing_pattern then
				rrectfill(x, 1, patt_width + 1, self.height - 2, 0, 36)
				--local px = row_width * ((playing_row % app.bar_length) // app.beat_length)
				--line(x + px, 0, x + px, self.height, 37)
			end
			local bg = pattern == app.pattern and 17 or 60
			rrectfill(x + 2, y + 4, patt_width - 3, 18, 1, bg)
			if pattern > 0 then
				line(x, y + 13, x + 1, y + 13, 60)
			end
			if pattern < max_pattern then
				line(x + patt_width - 1, y + 13, x + patt_width - 1, y + 13, 60)
			end
			local fg = channels == 0 and 59 or 57
			print(string.format("%02d", pattern), x + 6, y + 7, fg)
			for c = 0, 7 do
				local cx = x + 6 + 2 * c
				local cfg = (channels & (1 << c) == 0) and 59 or 57
				line(cx, y + 14, cx, y + 15, cfg)
			end
			local y = 3
			local pointer_over_these_toggles =
				msg.has_pointer and msg.my <= 11
				and msg.mx // patt_width == i
			local toggle_pointed_at = 
				(msg.mx - 1) % patt_width // (patt_width // 3)
			if sfx.pattern_loop_start(pattern) then
				spr(12, x + 2, y)
			elseif pointer_over_these_toggles and toggle_pointed_at == 0 then
				pal(57, 60)
				spr(12, x + 2, y)
				pal(57, 57)
			end
			if sfx.pattern_loop_stop(pattern) then
				spr(14, x + 2 + 8, y)
			elseif pointer_over_these_toggles and toggle_pointed_at == 1 then
				pal(57, 60)
				spr(14, x + 2 + 8, y)
				pal(57, 57)
			end
			if sfx.pattern_loop_end(pattern) then
				spr(13, x + 2 + 8 * 2, y)
			elseif pointer_over_these_toggles and toggle_pointed_at == 2 then
				pal(57, 60)
				spr(13, x + 2 + 8 * 2, y)
				pal(57, 57)
			end
		end
		if self.drop_point then
			local x = 1 + (self.drop_point - self.start) * patt_width
			line(x, 8, x, self.height - 3, 57)
		end
		-- Borders
		clip()
		line()
		line(0, self.height - 3, 58)
		line(0, 2, 58)
		line(2, 0, 58)
		line(self.width - 3, 0, 58)
		line(self.width - 1, 2, 58)
		line(self.width - 1, self.height - 3, 57)
		line(self.width - 3, self.height - 1, 57)
		line(2, self.height - 1, 57)
		line(1, self.height - 2, 57)
	end
	
	function el:hover(msg)
		local nb_cols = (self.width - 2) // patt_width
		local idx = self.start + (msg.mx - 1) // patt_width
		local local_x = msg.mx % patt_width
		if msg.my > 11 then
			self.cursor = 1 --"grab"
		else
			self.cursor = "pointer"
		end
	end
	
	function el:click(msg)
		local nb_cols = (self.width - 2) // patt_width
		local pattern = self.start + (msg.mx - 1) // patt_width
		if msg.my > 11 and (msg.mb == 1 or msg.mb == 2) then
			app.pattern = mid(pattern, 0, sfx.num_patterns() - 1)
		end
	end
	
	function el:drag(msg)
		if not (msg.my0 > 11) then return end
		self.cursor = "grab"
		local nb_cols = (self.width - 2) // patt_width
		local idx0 = self.start + msg.mx0 // patt_width
		local idx = self.start + (msg.mx + patt_width // 2) // patt_width
		if msg.mx < msg.mx0 - 6 or msg.mx > msg.mx0 + 6 then
			self.drop_point = idx
			self.dragged_pattern = idx0
			self.drag_duplicate = msg.mb == 2
		else
			self.drop_point = nil
			self.dragged_pattern = nil
			self.drag_duplicate = nil
		end
	end
	
	function el:release(msg)
		local num_patterns = sfx.num_patterns()
		if self.drop_point and self.drop_point >= 0 and self.drop_point < num_patterns then
			undo.checkpoint()
			local ud = sfx.copy_pattern(self.dragged_pattern)
			if self.drag_duplicate then
				sfx.insert_pattern(self.drop_point)
				sfx.paste_pattern(self.drop_point, ud)
				app.pattern = self.drop_point
			else
				sfx.remove_pattern(self.dragged_pattern)
				if self.drop_point > self.dragged_pattern then
					app.pattern = self.drop_point - 1
				else
					app.pattern = self.drop_point
				end
				sfx.insert_pattern(app.pattern)
				sfx.paste_pattern(app.pattern, ud)
			end
		end
		self.cursor = 1
		self.drop_point = nil
		self.dragged_pattern = nil
		self.drag_duplicate = nil
	end
	
	function el:tap(msg)
		if not (msg.my > 11) then
			local pattern = self.start + (msg.mx - 1) // patt_width
			if (msg.mx - 1) % patt_width <= patt_width // 3 then
				undo.checkpoint()
				local prev = sfx.pattern_loop_start(pattern)
				sfx.set_pattern_loop_start(pattern, not prev)
			elseif (msg.mx - 1) % patt_width <= 2 * (patt_width // 3) then
				undo.checkpoint()
				local prev = sfx.pattern_loop_stop(pattern)
				sfx.set_pattern_loop_stop(pattern, not prev)
			else
				undo.checkpoint()
				local prev = sfx.pattern_loop_end(pattern)
				sfx.set_pattern_loop_end(pattern, not prev)
			end
		end
	end
	
	function el:mousewheel(msg)
		local nb_cols = (self.width - 2) // patt_width
		self.start -= msg.wheel_y
		self.start = mid(self.start, 0, sfx.num_patterns() - nb_cols)
	end
	return el
end


local function generate_pattern_tool(parent)
	parent:attach(create_pattern_list {
		x = 3, y = 5,
		width = parent.width - 6, height = parent.height - 18,
	})
end


-------------------------------------------------------------------------------
-- Track Tool
-------------------------------------------------------------------------------


local function attach_track_strip(parent, el)
	el.width = app.column_width
	el.height = parent.height - 9
	parent:attach(el)
	
	local nb_rows = (el.height - 13) // 8
	el.track_list = ui.create_list {
		x = 2, y = 7,
		width = app.column_width - 4, height = el.height - 13,
		row_height = 8,
		nb_columns = 3,
--		start = sfx.pattern_track(app.pattern, el.channel) - nb_rows // 2,
--		overshoot = nb_rows // 2,
		channel = el.channel,
		get_active = function(self) return sfx.pattern_track(app.pattern, self.channel) end,
		set_active =
			function(self, idx)
				undo.checkpoint()
				if sfx.channel_is_muted(app.pattern, self.channel) then
					sfx.mute_channel(app.pattern, self.channel, false)
				end
				app.set_pattern_track(app.pattern, self.channel, idx)
			end,
		get_start = function(self) return app.toolrack_track_scrollstart end,
		set_start = function(self, start) app.toolrack_track_scrollstart = start end,
--		get_start = function(self) return self.start end,
--		set_start = function(self, start) self.start = start end,
		get_max = function(self) return sfx.num_tracks() - 1 end,
		disabled = function(self) return sfx.channel_is_muted(app.pattern, self.channel) end,
		draw_item =
			function(self, track, x, y, w, h)
				local muted = sfx.channel_is_muted(app.pattern, self.channel)
				local active = sfx.pattern_track(app.pattern, self.channel)
				local size = sfx.track_size(track)
				if track == active and not muted then
					rrectfill(x, y, w, h + 1, 0, 4)
				--[[
				elseif not muted then
					for c = 0, 7 do
						if sfx.pattern_track(app.pattern, c) == track then
							rrectfill(x, y, w, h, 0, 60)
							break
						end
					end
				--]]
				end
				local fg = size == 0 and 60 or (trach == active and 7 or 57)
				print(string.format("%03d", track), x + 3, y + 2, fg)
			end
		
	}
	el:attach(el.track_list)
	
	el.track_list:attach(ui.create_toggle {
		channel = el.channel,
		off_spr = get_spr(20), on_spr = get_spr(15),
		x = el.track_list.width - 13, y = el.track_list.height - 13,
		horiz_padding = 0,
		has_pointer =
			function(self, x, y)
				return x > 5 and y > 5
			end,
		get =
			function(self)
				return not sfx.channel_is_muted(app.pattern, self.channel)
			end,
		set =
			function(self)
				undo.checkpoint()
				local muted = sfx.channel_is_muted(app.pattern, self.channel)
				app.mute_channel(app.pattern, self.channel, not muted)
			end,
	})

	return el
end


local function generate_track_tool(parent)
	for channel = 0, 7 do
		attach_track_strip(parent, {
			channel = channel,
			x = channel * app.column_width, y = 0,
		})
	end
end


-------------------------------------------------------------------------------
-- Loop Tool
-------------------------------------------------------------------------------


local function attach_loop_strip(parent, el)
	el.width = app.column_width
	el.height = 26
	parent:attach(el)
	
	local ox = 4
	local oy = 6

	el.label_loop0 = ui.create_label {
		visible = function(self) return not sfx.channel_is_muted(app.pattern, el.channel) end,
		x = ox, y = oy + 0, fg = 35,
		label = "length\-f:  ",
	}
	el:attach(el.label_loop0)
	el:attach(ui.create_field {
		x = ox + 34, y = oy + 0 - 1,
		width = 15, height = 7,
		visible = function(self) return not sfx.channel_is_muted(app.pattern, el.channel) end,
		get = function(self) return sfx.track_loop0(sfx.pattern_track(app.pattern, el.channel)) end,
		set =
			function(self, value)
				value = mid(value, 0, sfx.track_size(sfx.pattern_track(app.pattern, el.channel)))
				sfx.set_track_loop0(sfx.pattern_track(app.pattern, el.channel), value)
			end,
	})
	
	el:attach(ui.create_label {
		visible = function(self) return not sfx.channel_is_muted(app.pattern, el.channel) end,
		x = ox, y = oy + 10, fg = 35,
		label = "loop \-fend\-f:",
	})
	el:attach(ui.create_field {
		x = ox + 34, y = oy + 10 - 1,
		width = 15, height = 7,
		visible = function(self) return not sfx.channel_is_muted(app.pattern, el.channel) end,
		get = function(self) return sfx.track_loop1(sfx.pattern_track(app.pattern, el.channel)) end,
		set =
			function(self, value)
				value = mid(value, 0, sfx.track_size(sfx.pattern_track(app.pattern, el.channel)))
				sfx.set_track_loop1(sfx.pattern_track(app.pattern, el.channel), value)
				if value > sfx.track_loop0(sfx.pattern_track(app.pattern, el.channel)) then
					self.parent.label_loop0.label = "l. \-fstart\-f:"
				else
					self.parent.label_loop0.label = "length\-f:"
				end
			end,
	})
	
	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 47)
		local track <const> = sfx.pattern_track(app.pattern, self.channel)
		local is_muted <const> = sfx.channel_is_muted(app.pattern, self.channel)
		-- Dividers
		local xh <const> = app.column_width - 1
		local yh <const> = self.height - 1
		if self.channel ~= 0 then
			line(0, 1, 0, yh - 1, 57)
		end
		if self.channel ~= 7 then
			line(xh, 1, xh, yh - 1, 58)
		end
	end

	return el
end


local function generate_loop_tool(parent)
	for channel = 0, 7 do
		attach_loop_strip(parent, {
			channel = channel,
			x = channel * app.column_width, y = 1,
		})
	end
	
	parent:attach(ui.create_horiz_divider {
		x = 3, y = parent.height - 26,
		width = parent.width - 6,
	})
	
	local ox = 4
	local oy = parent.height - 19

	parent:attach(ui.create_label {
		x = ox + 0, y = oy + 0, fg = 56,
		label = "pattern flags\-f:",
	})
	parent:attach(ui.create_toggle {
		off_spr = get_spr(40), on_spr = get_spr(45),
		x = ox + 60, y = oy - 3,
		width = 15, height = 7,
		get = function(self) return sfx.pattern_loop_start(app.pattern) end,
		set = 
			function(self, value)
				local v = sfx.pattern_loop_start(app.pattern)
				sfx.set_pattern_loop_start(app.pattern, not v)
			end,
	})
	parent:attach(ui.create_toggle {
		off_spr = get_spr(42), on_spr = get_spr(47),
		x = ox + 74, y = oy - 3,
		width = 15, height = 7,
		get = function(self) return sfx.pattern_loop_stop(app.pattern) end,
		set = 
			function(self, value)
				local v = sfx.pattern_loop_stop(app.pattern)
				sfx.set_pattern_loop_stop(app.pattern, not v)
			end,
	})
	parent:attach(ui.create_toggle {
		off_spr = get_spr(41), on_spr = get_spr(46),
		x = ox + 88, y = oy - 3,
		width = 15, height = 7,
		get = function(self) return sfx.pattern_loop_end(app.pattern) end,
		set = 
			function(self, value)
				local v = sfx.pattern_loop_end(app.pattern)
				sfx.set_pattern_loop_end(app.pattern, not v)
			end,
	})
end


-------------------------------------------------------------------------------
-- Speed Tool
-------------------------------------------------------------------------------


local function attach_speed_strip(parent, el)
	el.width = app.column_width
	el.height = 26
	parent:attach(el)
	
	local ox = 4
	local oy = 6
	
	el:attach(ui.create_label {
		channel = el.channel, fg = 36,
		x = ox, y = oy + 0,
		label = "speed\-f:",
		visible = function(self) return not sfx.channel_is_muted(app.pattern, el.channel) end,
	})
	el:attach(ui.create_field {
		x = ox + 34, y = oy + 0 - 1,
		width = 15, height = 7,
		visible = function(self) return not sfx.channel_is_muted(app.pattern, el.channel) end,
		get = function(self) return sfx.track_speed(sfx.pattern_track(app.pattern, el.channel)) end,
		set = 
			function(self, value)
				value = mid(value, 0, 255)
				sfx.set_track_speed(sfx.pattern_track(app.pattern, el.channel), value)
			end,
	})

	el:attach(ui.create_label {
		channel = el.channel, fg = 56,
		x = ox, y = oy + 10,
		label =
			function(self)
				local speed = sfx.track_speed(sfx.pattern_track(app.pattern, el.channel))
				if speed == 0 then
					speed = sfx.default_speed() -- TODO: this seem to be `16` hardcoded instead?
				end
				local tempo = 7168 / (speed * app.beat_length)
				local fmt = (tempo % 1 == 0) and "tempo\-f:   %3.0f" or "tempo: %5.01f"
				return string.format(fmt, tempo)
			end,
		visible = function(self) return not sfx.channel_is_muted(app.pattern, el.channel) end,
	})

	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 47)
		local track <const> = sfx.pattern_track(app.pattern, self.channel)
		local is_muted <const> = sfx.channel_is_muted(app.pattern, self.channel)
		-- Dividers
		local xh <const> = app.column_width - 1
		local yh <const> = self.height - 1
		if self.channel ~= 0 then
			line(0, 1, 0, yh - 1, 57)
		end
		if self.channel ~= 7 then
			line(xh, 1, xh, yh - 1, 58)
		end
	end

	return el
end


local function generate_speed_tool(parent)
	for channel = 0, 7 do
		attach_speed_strip(parent, {
			channel = channel,
			x = channel * app.column_width, y = 1,
		})
	end
	
	parent:attach(ui.create_horiz_divider {
		x = 3, y = parent.height - 26,
		width = parent.width - 6,
	})
	
	local ox = 4
	local oy = parent.height - 19

	parent:attach(ui.create_label {
		x = ox + 0, y = oy + 0, fg = 35,
		label = "beat length\-f:",
	})
	parent:attach(ui.create_field {
		x = ox + 0 + 49, y = oy + 0 - 1,
		width = 15, height = 7,
		get = function(self) return app.beat_length end,
		set = 
			function(self, value)
				local v = mid(0, flr(value), 64)
				app.beat_length = value
			end,
	})
		
	parent:attach(ui.create_label {
		x = ox + 80, y = oy + 0, fg = 35,
		label = "bar length\-f:",
	})
	parent:attach(ui.create_field {
		x = ox + 80 + 45, y = oy + 0 - 1,
		width = 15, height = 7,
		get = function(self) return app.bar_length end,
		set =
			function(self, value)
				local v = mid(0, flr(value), 64)
				app.bar_length = value
			end,
	})
	
	-- Default speed and default length doesn't seem to be implemented
	-- by Picotron.
	--[[
	local ox = 10
	
	parent:attach(ui.create_label {
		x = ox + 356, y = oy + 0, fg = 56,
		label = "default speed:",
	})
	parent:attach(ui.create_field {
		x = ox + 356 + 60, y = oy + 0 - 1,
		width = 15, height = 7,
		get = function(self) return sfx.default_speed() end,
		set = 
			function(self, value)
				local v = mid(0, flr(value), 255)
				sfx.set_default_speed(v)
			end,
	})
	--]]
end


-------------------------------------------------------------------------------
-- Select Tools
-------------------------------------------------------------------------------


local function generate_select_tool(parent)
	parent:attach(create_nyi {
		name = "selection",
		x = 0, y = 0,
		width = parent.width,
		height = parent.height - 9,
	})
end


-------------------------------------------------------------------------------
-- Note Tool
-------------------------------------------------------------------------------


local function generate_note_tool(parent)
	parent:attach(create_nyi {
		name = "note",
		x = 0, y = 0,
		width = parent.width,
		height = parent.height - 9,
	})
end


-------------------------------------------------------------------------------
-- Instrument Tool
-------------------------------------------------------------------------------


local function generate_instrument_tool(parent)
	parent:attach(create_nyi {
		name = "instrument",
		x = 0, y = 0,
		width = parent.width,
		height = parent.height - 9,
	})
end


-------------------------------------------------------------------------------
-- Volume Tool
-------------------------------------------------------------------------------


local function generate_volume_tool(parent)
	parent:attach(create_nyi {
		name = "volume",
		x = 0, y = 0,
		width = parent.width,
		height = parent.height - 9,
	})
end


-------------------------------------------------------------------------------
-- Effect Tool
-------------------------------------------------------------------------------


local function generate_effect_tool(parent)
	parent:attach(create_nyi {
		name = "effect",
		x = 0, y = 0,
		width = parent.width,
		height = parent.height - 9,
	})
end


-------------------------------------------------------------------------------
-- Chord Tools
-------------------------------------------------------------------------------


local function generate_chord_tool(parent)
	parent:attach(create_nyi {
		name = "chord",
		x = 0, y = 0,
		width = parent.width,
		height = parent.height - 9,
	})
end


-------------------------------------------------------------------------------
-- Mixer Tools
-------------------------------------------------------------------------------


local height_oscillo = 39

		
local sample_scale <const> = 26175.0

local function create_channel_oscillo(el)
	el.last_lpeak = 0
	el.last_rpeak = 0
	ui.head():new(el)
	function el:draw()
		local delta_channel = 0
		if not sfx.music_is_playing() then
			delta_channel = 8
		end
		--
		local n = stat(400 + self.channel + delta_channel, 19, 0x90000)
		local lpeak, rpeak = 0.0, 0.0
		local last_sgn = sgn(peek2(0x90000))
		local zero_crossing = 0
		for i = 0, n, 4 do
			local sleft = peek2(0x90000 + i)
			if zero_crossing == 0 then
				if last_sgn > 0 then
					last_sgn = sgn(sleft)
				elseif sgn(sleft) > last_sgn then
					zero_crossing = i
				end
			end
			sleft = abs(sleft)
			lpeak = max(lpeak, sleft)
			local sright = abs(peek2(0x90002 + i))
			rpeak = max(rpeak, sright)
			smax = max(smax, lpeak)
		end
		-- Convert to decibels
		lpeak = 20 * math.log(lpeak / sample_scale, 10)
		rpeak = 20 * math.log(rpeak / sample_scale, 10)
		-- Scale so that -40db = 0 and 0db = 1
		lpeak = 1 + lpeak / app.min_db
		lpeak = mid(lpeak, 0, 1)
		lpeak = max(lpeak, self.last_lpeak - app.meter_speed)
		self.last_lpeak = lpeak
		rpeak = 1 + rpeak / app.min_db
		rpeak = mid(rpeak, 0, 1)
		rpeak = max(rpeak, self.last_rpeak - app.meter_speed)
		self.last_rpeak = rpeak
		local lx = lpeak * (app.column_width - 9)
		local rx = rpeak * (app.column_width - 9)
		rrectfill(1, 1, app.column_width - 6, 9, 0, 59)
		app.draw_borders(1, 1, app.column_width - 6, 9, 0, 59)
		app.draw_horiz_meter(2, 2, app.column_width - 8, 3, lpeak)
		app.draw_horiz_meter(2, 6, app.column_width - 8, 3, rpeak)
		if app.channel_oscillos_visible then
			-- Oscilloscope
			ui_visual.draw_stereo_signal(1, 16, self.width - 2, height_oscillo, 
				0x90000, n, zero_crossing, 4)
			--[[
			rrectfill(1, oy, self.width - 2, height_oscillo, 0, 59)
			app.draw_borders(1, oy, self.width - 2, height_oscillo)
			local ymid = oy + height_oscillo // 2
			local last_y_left, last_y_right = ymid, ymid
			for x = 0, self.width - 3 do
				local y_left = flr(0.5 + ymid - peek2(0x90000 + zero_crossing + x * 16) / 1638)
				line(x, last_y_left, x + 1, y_left, fg_left)
				y_right = flr(0.5 + ymid - peek2(0x90002 + zero_crossing + x * 16) / 1638)
				local same_spot = (y_right == y_left)
				line(x, last_y_right, x + 1, y_right, same_spot and fg_both or fg_right)
				last_y_left, last_y_right = y_left, y_right
			end
			--]]
		end
	end
	return el
end


local function attach_mixer_strip(parent, el)
	el.width = app.column_width
	el.height = parent.height
	parent:attach(el)
	
	el:attach(create_channel_oscillo {
		channel = el.channel,
		x = 2, y = 5,
		width = el.width - 4, height = el.height - 13,
	})
	
	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 47)
		local track <const> = sfx.pattern_track(app.pattern, self.channel)
		local is_muted <const> = sfx.channel_is_muted(app.pattern, self.channel)
	end

	return el
end


local function generate_mixer_tool(parent)
	for channel = 0, 7 do
		attach_mixer_strip(parent, {
			channel = channel,
			x = channel * app.column_width, y = 0,
		})
	end
	parent:attach(ui.create_toggle {
		x = parent.width - 7, y = parent.height - 9 - 16,
		off_spr = get_spr(125), on_spr = get_spr(126),
		get = function(self) return app.channel_oscillos_visible end,
		set = function(self, v)
			app.channel_oscillos_visible = not app.channel_oscillos_visible
			app.refresh_gui = true
		end
	})
end


-------------------------------------------------------------------------------
-- Locals
-------------------------------------------------------------------------------


local toolrack_tab_width <const> = 40


local tabs = {
	[0] =
	{ name = "pattern", height = 45, generate = generate_pattern_tool }, 
--	{ name = "track", height = 110, generate = generate_track_tool }, 
	{ name = "loop", height = 45, generate = generate_loop_tool }, 
	{ name = "speed", height = 45, generate = generate_speed_tool }, 
	{ name = "select", height = 45, generate = generate_select_tool }, 
	{ name = "note", height = 45, generate = generate_note_tool }, 
	{ name = "inst", height = 45, generate = generate_instrument_tool }, 
	{ name = "volume", height = 45, generate = generate_volume_tool }, 
	{ name = "effect", height = 45, generate = generate_effect_tool }, 
	{ name = "chord", height = 45, generate = generate_chord_tool }, 
	{ name = "level", height = 66, generate = generate_mixer_tool }, 
}


-------------------------------------------------------------------------------
-- Tool-Rack
-------------------------------------------------------------------------------


function toolrack.attach_toolrack(parent, el)
	el.height = 8
	if app.toolrack_tab then
		if app.toolrack_tab == 9 then
			el.height += app.channel_oscillos_visible and 66 or 21
		else
			el.height += tabs[app.toolrack_tab].height
		end
	end
	el.y -= el.height
	parent:attach(el)
	if app.toolrack_tab then
		local generate = tabs[app.toolrack_tab].generate
		generate(el)
	end
	
	function el:draw()
		local right <const> = self.width - 1
		local bottom <const> = self.height - 1
		local tabwidth <const> = toolrack_tab_width
		-- Content
		if app.toolrack_tab then
			rrectfill(0, 0, self.width, self.height - 9, 0, 6)
			line(0, 0, right, 0, 57)
			line(0, 0, 0, bottom - 9, 57)
			line(right, 0, right, bottom - 9, 58)
			line(0, bottom - 8, right, bottom - 8, 58)
		end
		-- Tabs
		rectfill(0, bottom - 7, right, bottom, 56)
		for t = 0, #tabs do
			local x = t * tabwidth
			local dy = 0
			local fg = 55
			if t == app.toolrack_tab then
				dy = -2
				fg = 57
				spr(16, x - 4, bottom - 8)
				if t == 0 then
					line(x, bottom - 8, x, bottom, 57)
					line(x + 1, bottom - 8, x + 1, bottom - 2, 6)
				end
			end
			ui.print_centered(tabs[t].name, x + tabwidth // 2, bottom - 5 + dy, fg)
		end
		local step = selection.min_step()
		if sfx.music_is_playing() and app.follow_playhead then
			print("row\-f:", self.width - 26, bottom - 5, 55)
			print(string.format("%02d", sfx.playing_row()), self.width - 10, bottom - 5, 55)
		elseif step then
			print("row\-f:", self.width - 26, bottom - 5, 55)
			print(string.format("%02d", step), self.width - 10, bottom - 5, 55)
		end
	end
	
	
	function el:hover(msg)
		if msg.my > self.height - 1 - 8
			and msg.mx <= (#tabs + 1) * toolrack_tab_width
		then
			self.cursor = "pointer"
		else
			self.cursor = 1
		end
	end
	
	
	function el:click(msg)
		if msg.my >= self.height - 1 - 8 then
			local tab = msg.mx // toolrack_tab_width
			if tab == app.toolrack_tab then
				app.toolrack_tab = nil
			elseif tab <= #tabs then
				app.toolrack_tab = tab
			end
			app.refresh_gui = true
		end
	end
	
	
	function el:mousewheel(msg)
		return true
	end
	
	
	return el
end


return toolrack
:: src/ui/tracker.lua
--[[pod_format="raw",created="2026-01-26 12:39:34",modified="2026-02-16 14:12:04",revision=23102]]
local app = require "src/app.lua"
local actions = require "src/actions.lua"
local selection = require "src/selection.lua"
local settings = require "src/settings.lua"
local sfx = require "src/sfx/sfx.lua"
local undo = require "src/undo.lua"
local ui = require "src/ui/ui.lua"
local ui_notegrid = require "src/ui/notegrid.lua"
local ui_toolrack = require "src/ui/toolrack.lua"
local ui_panel = require "src/ui/panel.lua"

local ui_tracker = {}


-------------------------------------------------------------------------------
-- Locals
-------------------------------------------------------------------------------


local instr_chooser = false


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


local function create_overlay(el)
	ui.head():new(el)
	function el:draw(msg)
		if app.is_editing then
			rrect(0, 0, self.width, self.height, 0, 37)
		end
	end
	function el:click(msg) return false end
	function el:drag(msg) return false end
	function el:tap(msg) return false end
	return el
end


-------------------------------------------------------------------------------
-- Tracker Widget
-------------------------------------------------------------------------------


function ui_tracker.attach(parent, el)
	parent:attach(el)
	el:set_keyboard_focus(true)
	
	el.headers = {}
	el.notegrids = {}
	el.preview_timer = 0

	-- TODO: Doesn't seem to work?
	--sfx.set_pattern_length(app.pattern, 8)
	--notify("pattern length: " .. pod(sfx.pattern_length(app.pattern)))
		
	local y = app.track_header_height
	local h = el.height - app.track_header_height
	el.toolrack = ui_toolrack.attach_toolrack(el, {
		x = app.panel_width,
		y = el.height, -- set in `attach_toolrack`
		width = el.width - app.panel_width,
		height = 0, -- set in `attach_toolrack`
	})
	h -= el.toolrack.height
	for channel = 0, 7 do
		el.headers[channel] = ui_notegrid.attach_header(el, {
			x = app.panel_width + 1 + channel * app.column_width,
			y = 0,
			channel = channel,
		})
		el.notegrids[channel] = ui_notegrid.attach(el, {
			x = app.panel_width + 1 + channel * app.column_width, y = y,
			width = app.column_width, height = h,
			channel = channel,
		})
	end
	ui_notegrid.attach_scrollbar(el, {
		x = el.width - 4, y = y + 1,
		width = 4, height = h - 2,
	})
	
	ui_notegrid.close_channel_dialog()
	
	ui_panel.attach_view_selector(el, { x = 0, y = 4 })
	el.octave_selector = ui_panel.attach_octave_selector(el, { x = 0, y = 45 })
	el.instrument_selector = ui_panel.attach_instrument_selector(el, { x = 0, y = 57 })
	el.volume_selector = ui_panel.attach_volume_selector(el, { x = 0, y = 75 })
	el.step_selector = ui_panel.attach_step_selector(el, { x = 0, y = 93 })

	ui_panel.attach_pattern_selector(el, { x = 0, y = 116 })
	ui_panel.attach_pattern_arrows(el, { x = 0, y = 132 })
--	ui_panel.attach_pattern_flags(el, { x = 0, y = 145 })

	ui_panel.attach_meters(el, { x = 3, y = el.height - 86 })
	ui_panel.attach_edit_button(el, { x = 0, y = el.height - 31 })
	ui_panel.attach_play_button(el, { x = 0, y = el.height - 16 })

		
	------------------------------------------------------------------------------
	-- Draw
	------------------------------------------------------------------------------

	
	function el:draw()
		local w <const> = self.width
		local h <const> = self.height
		cls(32)
		-- panel
		rrectfill(0, 0, app.panel_width, h, 0, 6)
		line(0, 0, app.panel_width - 1, 0, 57)
		line(0, 0, 0, h - 1, 57)
		line(app.panel_width - 1, 0, app.panel_width - 1, h - 1, 58)
		line(0, h - 1, app.panel_width - 1, h - 1, 58)
		-- dividers
		line(3, 41, app.panel_width - 4, 41, 58)
		line(3, 42, app.panel_width - 4, 42, 57)
		line(3, 111, app.panel_width - 4, 111, 58)
		line(3, 112, app.panel_width - 4, 112, 57)
		line(3, el.height - 92, app.panel_width - 4, el.height - 92, 58)
		line(3, el.height - 91, app.panel_width - 4, el.height - 91, 57)
		-- channel headers
		rrectfill(app.panel_width, 0, self.width, app.track_header_height, 0, 56)
	end	

		
	------------------------------------------------------------------------------
	-- Update
	------------------------------------------------------------------------------
	
	
	function el:update()
		-- State queryied each frame
		local music_is_playing = sfx.music_is_playing()
		local pitch, pitch_just_pressed = app.pitched_key()
		local has_selection = selection.has_selection()
		local min_step = selection.min_step()
		if has_selection ~= app.capture_escapes then
			app.capture_escapes = has_selection
			window { capture_escapes = app.capture_escapes }
		end
		-- Stop playing previewed notes
		if (not pitch) and self.preview_timer == 0 then
			for channel = 8, 15 do
				note(0xff, 0xff, 0xff, 0x00, 0x00, channel)
			end
		end
		-- Preview
		if self.preview_timer > 0 then
			self.preview_timer -= 1
		end
		-- Handle auto-scroll while playing
		self:handle_playing_scroll()
		-- Various hacks related to keyboard focus
		if (not ui.head():get_keyboard_focus_element())
			and not (music_is_playing and app.follow_playhead)
		then
			readtext(true)
			self:clear_edit()
			self:set_keyboard_focus(true)
		end
		if keyp("space") then
			if key("shift") then
				actions.follow_play_or_pause(self)
			else
				actions.play_or_pause(self)
			end
		end
		
		if not self:has_keyboard_focus() then
			return
		end
		if app.was_in_text_field and not keyp() then
			return
		end
		app.was_in_text_field = false
		-- Keys
		selection.sanitize()
		
		-----------------------------------------------------------------------------
		-- Shift + Ctrl + Alt
		-----------------------------------------------------------------------------
		if key("shift") and key("ctrl") and key("alt") then
			-- currently unused
			
		-----------------------------------------------------------------------------
		-- Ctrl + Alt
		-----------------------------------------------------------------------------
		elseif key("ctrl") and key("alt") then
			-- currently unused
			
		-----------------------------------------------------------------------------
		-- Shift + Alt
		-----------------------------------------------------------------------------
		elseif key("shift") and key("alt") then
			
		-----------------------------------------------------------------------------
		-- Shift + Ctrl
		-----------------------------------------------------------------------------
		elseif key("shift") and key("ctrl") then
			-- Selection
			if keyp("down") then actions.select_next_beat(self) end
			if keyp("up") then actions.shrink_selection_rows(self) end
			if keyp("right") then actions.select_next_channel(self) end
			if keyp("left") then actions.shrink_selection_channels(self) end
			-- Edition
			if keyp("e") then actions.increase_part_slightly(self) end
			if keyp("d") then actions.decrease_part_slightly(self) end
			if keyp("x") then actions.cut_and_remove_rows(self) end
			
		-----------------------------------------------------------------------------
		-- Alt
		-----------------------------------------------------------------------------
		elseif key("alt") then
			-- TODO
			if keyp("o") then
				readtext(true)
				self.octave_selector.str = ""
				self.octave_selector:set_keyboard_focus(true)
				return
			end
			if keyp("i") then
				readtext(true)
				self.instrument_selector.str = ""
				self.instrument_selector:set_keyboard_focus(true)
				return
			end
			if key("v") then
				readtext(true)
				self.volume_selector.str = ""
				self.volume_selector:set_keyboard_focus(true)
				return
			end
			if keyp("j") then
				readtext(true)
				self.step_selector.str = ""
				self.step_selector:set_keyboard_focus(true)
				return
			end
			
		-----------------------------------------------------------------------------
		-- Ctrl
		-----------------------------------------------------------------------------
		elseif key("ctrl") then
			-- Movement
			if keyp("down") then actions.move_to_next_beat(self) end
			if keyp("up") then actions.move_to_previous_beat(self) end
			if keyp("right") then actions.move_to_next_channel(self) end
			if keyp("left") then actions.move_to_previous_channel(self) end
			-- Edition
			if keyp("delete") then actions.clear_rows(self) end
			if keyp("'") then actions.clear_rows_and_jump_down(self) end
			if keyp("backspace") then actions.jump_up_and_clear_rows(self) end
			if keyp("enter") then actions.preview_row(self) end
			if keyp("e") then actions.increase_part(self) end
			if keyp("d") then actions.decrease_part(self) end
			if keyp("c") then actions.copy(self) end
			if keyp("x") then actions.cut(self) end
			if keyp("v") then actions.paste(self) end
			-- TODO: create actions for these
			if keyp("t") then
				-- TODO: focus track selector
			end
			if keyp(",") then
				app.row_height = mid(app.row_height - 1, 6, 9)
			end
			if keyp(".") then
				app.row_height = mid(app.row_height + 1, 6, 9)
			end
			
		-----------------------------------------------------------------------------
		-- Shift
		-----------------------------------------------------------------------------
		elseif key("shift") then
			-- Context
			-- Selection
			if keyp("down") then actions.select_next_row(self) end
			if keyp("up") then actions.shrink_selection_rows(self) end
			if keyp("right") then actions.select_next_part(self) end
			if keyp("left") then actions.shrink_selection_parts(self) end
			if keyp("pagedown") then actions.select_next_bar(self) end
			if keyp("pageup") then actions.shrink_selection_rows(self) end
			-- Edition
			if keyp("delete") then actions.remove_rows(self) end
			if keyp("backspace") then actions.jump_up_and_remove_rows(self) end
			if keyp("enter") then actions.insert_rows(self) end
			
		-----------------------------------------------------------------------------
		-- No Modifiers
		-----------------------------------------------------------------------------
		else
			-- Context
			if keyp("tab") then actions.toggle_record_mode(self) end
			if keyp("insert") then actions.toggle_jump_step(self) end
			-- Movement
			if keyp("down") then actions.move_down(self) end
			if keyp("up") then actions.move_up(self) end
			if keyp("pagedown") then actions.move_to_next_bar(self) end
			if keyp("pageup") then actions.move_to_previous_bar(self) end
			if keyp("home") then actions.home(self) end
			if keyp("end") then actions.fin(self) end
			if keyp("right") then actions.move_to_next_part(self) end
			if keyp("left") then actions.move_to_previous_part(self) end
			-- Edition
			if keyp("=") then actions.repeat_last_entry(self) end
			if keyp("delete") then actions.clear_parts(self) end
			if keyp("'") then actions.clear_parts_and_jump_down(self) end
			if keyp("backspace") then actions.jump_up_and_clear_parts(self) end
			if keyp("enter") then actions.preview_row_and_jump_down(self) end
			-- Hardwired
			if keyp("escape") then
				if has_selection then
					selection.clear()
					window { capture_escapes = false }
				elseif app.toolrack_tab then
					app.toolrack_tab = nil
					-- TODO: how to handle `capture_escapes`?
				end
			end
		end
			
		-----------------------------------------------------------------------------
		-- Play Notes
		-----------------------------------------------------------------------------
		if pitch and pitch_just_pressed and not (app.is_editing and music_is_playing) then
			if selection.has_part(selection.note) or not app.is_editing then
				local track = sfx.pattern_track(app.pattern, selection.min_channel())
				local step = selection.min_step()
				local inst = self:instrument_to_use(track, step)
				if inst == 0xff then
					inst = self:current_instrument(track, step)
				end
				local vol = self:volume_to_use(track, step)
				if vol == 0xff then
					vol = self:current_volume(track, step)
				end
				note(pitch, inst, vol,
					0x00, 0x00,
					8, -- channel 8 so it can play with pattern
					false -- don't force retrigger
				)
			end
		elseif pitch then
			-- nothing
		elseif preview == 0 then
			note(0xff, 0xff, 0xff, 0x00, 0x00, 8)
		end
			
		-----------------------------------------------------------------------------
		-- Enter Notes
		-----------------------------------------------------------------------------
		if app.is_editing then
			if selection.has_part(selection.note) then
				if key("alt") then
					self:edit_octave(pitch, pitch_just_pressed)
				else
					self:edit_note(pitch, pitch_just_pressed, key("shift"))
				end
			elseif selection.parts() == selection.instrument then
				if key("shift") then
					self:edit_fast_instrument()
				else
					self:edit_instrument()
				end
			elseif selection.parts() == selection.volume then
				if key("shift") then
					self:edit_fast_volume()
				else
					self:edit_volume()
				end
			elseif selection.parts() == selection.fx then
				self:edit_fx()
			end
		end
	end
	
	function el:click(msg)
		self:set_keyboard_focus(true)
	end
	
	function el:mousewheel(msg)
		if msg.mx > app.panel_width then
			self:scroll_channels(msg.wheel_y)
		end
	end
	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
	
	function el:handle_playing_scroll()
		if not app.window_focused then
			return
		end
		if sfx.music_is_playing() and app.follow_playhead then
			self:set_keyboard_focus(false)
			if not self.was_playing then
				self:save_position()
			end
			local pattern = sfx.playing_pattern()
			local step = sfx.playing_row()
			if pattern and pattern >= 0 and step and step >= 0 then
				app.pattern = mid(sfx.playing_pattern(), 0, sfx.num_patterns() - 1)
				self:show_step(step, "centered")
			end
			self.was_playing = true
		else
			if self.was_playing then
				self:restore_position()
				app.follow_playhead = false
			end
			self.was_playing = false
		end
	end
	
	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
	
	
	function el:note_to_preview(track, step)
		local pitch = sfx.track_pitch(track, step)
		if pitch == 0xff or (not selection.has_part(selection.note)) then
			return 0xff
		end
		return pitch
	end
	
	
	function el:instrument_to_preview(track, step)
		local instr = sfx.track_instrument(track, step)
		local s = step
		while instr == 0xff and s > 1 do
			s -= 1
			instr = sfx.track_instrument(track, s)
		end
		return instr
	end
	
	
	function el:volume_to_preview(track, step)
		local volume = sfx.track_volume(track, step)
		local s = step
		while volume == 0xff and s > 1 do
			s -= 1
			volume = sfx.track_volume(track, s)
		end
		return volume
	end
	
	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
	
	
	function el:instrument_to_use(track, step)
		local instr = sfx.track_instrument(track, step)
		local last_instr = self:current_instrument(track, step)
		if instr == 0xff
			or (selection.has_part(selection.note)
				and selection.has_part(selection.instrument) )
		then
			instr = app.instrument
		end
		return instr
	end
	
	
	function el:volume_to_use(track, step)
		local vol = sfx.track_volume(track, step)
		if vol == 0xff
			or (selection.has_part(selection.note)
				and selection.has_part(selection.volume) )
		then
			vol = app.base_volume
		end
		return vol
	end
	
	
	function el:fx_to_use(track, step)
		local fx = sfx.track_fx(track, step)
		local fx_params = sfx.track_fx_params(track, step)
		if (selection.has_part(selection.note)
				and selection.has_part(selection.fx) )
		then
			fx = 0x00
			fx_params = 0x00
		end
		return fx, fx_params
	end
		
	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
	
	
	function el:clear_edit()
		readtext(true)
		self.str_instrument = nil
		self.str_volume = nil
		self.str_fx = nil
	end
		
	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

	
	function el:edit_note(pitch, pitch_just_pressed, only_note)
		if key("ctrl") or key("alt") then return end
		if not pitch_just_pressed then return end
		undo.checkpoint()
		selection.for_each_channel_each_step(
			function(track, step)
				sfx.set_track_pitch(track, step, pitch)
				if not only_note then
					sfx.set_track_instrument(track, step, self:instrument_to_use(track, step))
					sfx.set_track_volume(track, step, self:volume_to_use(track, step))
					local fx, fx_params = self:fx_to_use(track, step)
					sfx.set_track_fx(track, step, fx)
					sfx.set_track_fx_params(track, step, fx_params)
				end
			end
		)
		selection.move_step(selection.jump_step())
		self:show_cursor()
		self.last_pitch_entered = pitch
		return nil
	end
		
	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
	
	
	function el:edit_instrument()
		if key("ctrl") or key("alt") then return end
		if not self.str_instrument then
			if peektext() then
				undo.checkpoint()
				self.str_instrument = ""
				self:show_cursor()
			else
				return
			end
		end
		
		while peektext() do
			if #self.str_instrument < 2 then
				self.str_instrument ..= readtext()
			else
				readtext()
			end
		end
		
		local val = tonumber(self.str_instrument, 16)
		self.str_instrument_is_valid = val ~= nil

		if keyp("backspace") then
			self.str_instrument = sub(self.str_instrument, 1, -2)
		
		elseif keyp("escape") then
			self.str_instrument = nil
					
		elseif keyp("enter") and (not val) then
			self.str_instrument = nil

		elseif keyp("enter") or (val and #self.str_instrument == 2) then
			readtext(true)
			self.str_instrument = nil
			app.was_in_text_field = true
			selection.for_each_channel_each_step(
				function(track, step)
					sfx.set_track_instrument(track, step, val)
				end
			)
			selection.move_step(selection.jump_step())
			self:show_cursor()
			self.last_instrument_entered = val
		end
	end
		
	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
	
	
	function el:edit_volume()
		if key("ctrl") or key("alt") then return end
		if not self.str_volume then
			if peektext() then
				undo.checkpoint()
				self.str_volume = ""
				self:show_cursor()
			else
				return
			end
		end
		
		while peektext() do
			if #self.str_volume < 2 then
				self.str_volume ..= readtext()
			else
				readtext()
			end
		end
		
		local val = tonumber(self.str_volume, 16)
		self.str_volume_is_valid = val ~= nil

		if keyp("backspace") then
			self.str_volume = sub(self.str_volume, 1, -2)
		
		elseif keyp("escape") then
			self.str_volume = nil
			
		elseif keyp("enter") and (not val) then
			self.str_volume = nil
			
		elseif keyp("enter") or (val and #self.str_volume == 2) then
			readtext(true)
			self.str_volume = nil
			selection.for_each_channel_each_step(
				function(track, step)
					sfx.set_track_volume(track, step, val)
				end
			)
			selection.move_step(selection.jump_step())
			self:show_cursor()
			self.last_volume_entered = val
		end
	end
		
	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
	
	
	function el:edit_fx()
		if key("ctrl") or key("alt") then return end
		if not self.str_fx then
			if peektext() then
				undo.checkpoint()
				self.str_fx = ""
				self:show_cursor()
			else
				return
			end
		end
		
		while peektext() do
			if #self.str_fx < 3 then
				self.str_fx ..= readtext()
			else
				readtext()
			end
		end
		
		local fx = ord(app.is_valid_fx[self.str_fx[1]])
		local str_val = self.str_fx:sub(2, -1)
		local val = tonumber(str_val, 16)
		local only_val = tonumber(self.str_fx, 16)
		self.str_fx_is_valid =
			(fx and val)
			or (fx and #str_val == 0)
			or only_val
		if fx == 0 then
			val = 0
		end

		if keyp("backspace") then
			self.str_fx = sub(self.str_fx, 1, -2)
		
		elseif keyp("escape") then
			self.str_fx = nil
			
		elseif self.str_fx == "." then
			self.str_fx = nil
			if selection.step_count() == 1 then
				selection.move_step(selection.jump_step())
				self:show_cursor()
			end
			
		elseif keyp("enter") and (not self.str_fx_is_valid) then
			self.str_fx = nil
			
		elseif keyp("enter") or (fx and val and #self.str_fx == 3) then
			readtext(true)
			selection.for_each_channel_each_step(
				function(track, step)
					if fx and (#self.str_fx == 1 or #self.str_fx == 3) then
						sfx.set_track_fx(track, step, fx)
					elseif only_val then
						val = only_val
					end
					if val then
						sfx.set_track_fx_param0(track, step, val >> 4)
						sfx.set_track_fx_param1(track, step, val & 0x0f)
					end
					if #self.str_fx == 1 or #self.str_fx == 3 then
						self.last_fx_entered = fx
					else
						-- Cover the case or digits as valid fx
						self.last_fx_entered = nil
					end
					self.last_fx_params_entered = val
				end
			)
			self.str_fx = nil
			selection.move_step(selection.jump_step())
			self:show_cursor()
		end
	end
	
	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
	
	
	function el:edit_octave()
		if key("ctrl") or key("alt") then return end
		local digit = app.decimal_digit_key()
		if digit then
			undo.checkpoint()
			selection.for_each_channel_each_step(
				function(track, step)
					local pitch = sfx.track_pitch(track, step)
					if pitch ~= 0xff then
						pitch %= 12
						pitch += digit * 12
						sfx.set_track_pitch(track, step, pitch)
					end
				end
			)
			selection.move_step(selection.jump_step())
			self:show_cursor()
		end
	end
		
	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
	
	
	function el:edit_fast_instrument()
		if key("ctrl") or key("alt") then return end
		local digit = app.hexadecimal_digit_key()
		if digit then
			undo.checkpoint()
			readtext(true)
			selection.for_each_channel_each_step(
				function(track, step)
					sfx.set_track_instrument(track, step, digit)
				end
			)
			selection.move_step(selection.jump_step())
			self:show_cursor()
		end
	end
		
	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
	
	
	function el:edit_fast_volume()
		if key("ctrl") or key("alt") then return end
		local digit = app.hexadecimal_digit_key()
		if digit then
			undo.checkpoint()
			readtext(true)
			selection.for_each_channel_each_step(
				function(track, step)
					sfx.set_track_volume(track, step, digit * 8)
				end
			)
			selection.move_step(selection.jump_step())
			self:show_cursor()
		end
	end
	
	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
	
	
	function el:current_instrument(track, step)
		for s = step, 0, -1 do
			local inst = sfx.track_instrument(track, s)
			if inst ~= 0xff then
				return inst
			end
		end
		return 0xff
	end
	
	
	function el:current_volume(track, step)
		for s = step, 0, -1 do
			local inst = sfx.track_volume(track, s)
			if inst ~= 0xff then
				return inst
			end
		end
		return 0xff
	end

	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

	
	function el:save_position()
		self.saved_pattern = app.pattern
		self.saved_start = app.starting_row
	end
	
	
	function el:restore_position()
		if self.saved_pattern then
			app.pattern = mid(self.saved_pattern, 0, sfx.num_patterns() - 1)
		end
		app.starting_row = self.saved_start
		self:show_step(app.starting_row)
	end
		
	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
	
	
	function el:show_cursor(mode)
		mode = mode or "centered"
		-- TODO: improve heuristic
		local start = app.starting_row
		local nb_rows = flr(self.notegrids[1].height // app.row_height)
		local max_step = selection.max_step()
		local min_step = selection.min_step()
		local look_ahead = settings.user.look_ahead
		local look_back = settings.user.look_back
		if look_ahead >= nb_rows then
			look_ahead = nb_rows - 1
		end
		if look_ahead + look_back >= nb_rows then
			look_back = nb_rows - look_ahead - 1
		end
		if max_step < start + look_back then
				start = max_step - look_back
		elseif min_step >= start + nb_rows - look_ahead then
			start = min_step - nb_rows + 1 + look_ahead
		end
		local size = sfx.pattern_max_size(app.pattern)
		start = mid(start, 0, size - nb_rows + 1)
		app.starting_row = start
	end
	
	
	function el:show_step(step, mode)
		local start = app.starting_row
		local nb_rows = flr(self.notegrids[1].height // app.row_height)
		if mode == "centered" then
			start = step - nb_rows // 2
		else
			if step < start + settings.user.look_back then
				start = step - settings.user.look_back
			elseif step >= start + nb_rows - settings.user.look_ahead  then
				start = step - nb_rows + 1 + settings.user.look_ahead
			end
			local size = sfx.pattern_max_size(app.pattern)
			start = mid(start, 0, size - nb_rows + 1)
		end
		app.starting_row = start
	end

	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
	
	
	function el:scroll_channels(delta)
		local start = app.starting_row - delta
		app.starting_row = start
		self:scrolling_guardrail()
	end
	
	
	function el:scrolling_guardrail(mode)
		local nb_rows = flr(self.notegrids[1].height // app.row_height)
		local max_size = sfx.pattern_max_size(app.pattern)
		local min_step, max_step
		if mode == "overshoot" then -- TODO: add settings?
			min_step = - (nb_rows // 2)
			max_step = max_size - (nb_rows // 2)
		else
			min_step = 0
			max_step = max_size - nb_rows
		end
		app.starting_row = mid(app.starting_row, min_step, max_step)
	end

	return el
end


return ui_tracker
:: src/ui/trakdial.lua
--[[pod_format="raw",created="2026-01-27 14:07:26",modified="2026-02-16 14:12:04",revision=20551]]
local app = require "src/app.lua"
local ui = require "src/ui/ui.lua"
local sfx = require "src/sfx/sfx.lua"


local ui_trakdial = {}


-------------------------------------------------------------------------------
-- Locals
-------------------------------------------------------------------------------


local function draw_dialog_window(x, y, width, height, label)
	rrectfill(x, y, width, height, 0, 6)
	local xw, yh = x + width - 2, y + height - 2
	line(x + 1, yh, x + 1, y + 1, 57)
	line(x + 2, yh, x + 2, y + 1, 57)
	line(x + 1, y + 1, xw, y + 1, 57)
	line(x + 1, y + 2, xw, y + 2, 57)
	line(xw, yh, xw, y + 1, 58)
	line(xw - 1, yh, xw - 1, y + 2, 58)
	line(x + 1, yh, xw, yh, 58)
	line(x + 2, yh - 1, xw, yh - 1, 58)
	rrect(x + 0, y + 0, width, height, 0, 0)
--	rrectfill(x + 4, y + 4, width - 8, 11, 0, 5)
--	ui.print_centered(label, x + width // 2, y + 7, 5)
end


local function create_track_selector(el)
	el.width = 80
	el.height = 13
	ui.head():new(el)
	
	function el:draw(msg)
--		rrect(0, 0, self.width, self.height, 0, 47)
		if msg.has_pointer and msg.mx < 20 then
			rrectfill(2, 2, 17, 9, 0, 57)
		end
		if msg.has_pointer and msg.mx > self.width - 20 then
			rrectfill(self.width - 2 - 17, 2, 17, 9, 0, 57)
		end
		pal(7, self.previous_clicked and 13 or 58)
		spr(43, 7, 3)
		pal(7, self.next_clicked and 13 or 58)
		spr(44, self.width - 7 - 7, 3)
		pal(7, 7)
		ui.print_centered(string.format("track %03d", self.parent:track()),
			self.width // 2, 4, 5)
	end
	
	function el:hover(msg)
		if msg.mx < 20 then
			self.cursor = "pointer"
		elseif msg.mx > self.width - 20 then
			self.cursor = "pointer"
		else
			self.cursor = 1
		end
	end
	
	function el:click(msg)
		if msg.mx < 20 then
			self.previous_clicked = true
		elseif msg.mx > self.width - 20 then
			self.next_clicked = true
		end
	end
	
	function el:tap(msg)
		local track = self.parent:track()
		if msg.mx < 20 then
			track = mid(track - 1, 0, sfx.num_tracks() - 1)
			app.set_pattern_track(app.pattern, self.parent.channel, track)
		elseif msg.mx > self.width - 20 then
			track = mid(track + 1, 0, sfx.num_tracks() - 1)
			app.set_pattern_track(app.pattern, self.parent.channel, track)
		end
	end
	
	function el:release(msg)
		self.previous_clicked = false
		self.next_clicked = false
	end
	
	return el
end


-------------------------------------------------------------------------------
-- Track Dialog
-------------------------------------------------------------------------------


function ui_trakdial.create(el)
	ui.head():new(el)

	assert(el.tracker)
	el.w_win = 4 * app.column_width - 2 * 10
	el.h_win = 170
	el.y_win = (el.height - el.h_win) // 2
	if el.side == "left" then
		el.x_win = el.x_overlay - 4 * app.column_width + 10
	elseif el.side == "right" then
		el.x_win = el.x_overlay + app.column_width + 10
	end
	
	el:attach(create_track_selector {
		x = el.x_win + el.w_win // 2 - 40,
		y = el.y_win + 3,
	})
	
	local ox <const> = el.x_win + 10
	local oy <const> = el.y_win + 10
		
	el:attach(ui.create_label {
		x = ox, y = oy + 20,
		label = "speed:",
	})
	el:attach(ui.create_field {
		x = ox + 55, y = oy + 20 - 1,
		width = 15, height = 7,
		get = function(self) return sfx.track_speed(self.parent:track()) end,
		set = 
			function(self, value)
				value = mid(value, 0, 255)
				sfx.set_track_speed(self.parent:track(), value)
			end,
	})

	el.label_loop0 = ui.create_label {
		x = ox, y = oy + 40,
		label = "length:          ",
	}
	el:attach(el.label_loop0)
	el:attach(ui.create_field {
		x = ox + 55, y = oy + 40 - 1,
		width = 15, height = 7,
		get = function(self) return sfx.track_loop0(self.parent:track()) end,
		set =
			function(self, value)
				value = mid(value, 0, sfx.track_size(self.parent:track()))
				sfx.set_track_loop0(self.parent:track(), value)
			end,
	})
	
	el:attach(ui.create_label {
		x = ox, y = oy + 60,
		label = "loop end:",
	})
	el:attach(ui.create_field {
		x = ox + 55, y = oy + 60 - 1,
		width = 15, height = 7,
		get = function(self) return sfx.track_loop1(self.parent:track()) end,
		set =
			function(self, value)
				value = mid(value, 0, sfx.track_size(self.parent:track()))
				sfx.set_track_loop1(self.parent:track(), value)
				if value > sfx.track_loop0(self.parent:track()) then
					self.parent.label_loop0.label = "loop start:"
				else
					self.parent.label_loop0.label = "length:"
				end
			end,
	})

	oy += 20
		
	el:attach(ui.create_label {
		x = ox, y = oy + 80,
		label = "new tracks speed:",
	})
	el:attach(ui.create_field {
		x = ox + 75, y = oy + 80 - 1,
		width = 15, height = 7,
		get = function(self) return app.new_tracks_speed end,
		set =
			function(self, value)
				value = mid(value, 0, sfx.track_size(self.parent:track()))
				app.new_tracks_speed = value
			end,
	})
		
	el:attach(ui.create_label {
		x = ox, y = oy + 100,
		label = "new tracks length:",
	})
	el:attach(ui.create_field {
		x = ox + 75, y = oy + 100 - 1,
		width = 15, height = 7,
		get = function(self) return app.new_tracks_length end,
		set =
			function(self, value)
				value = mid(value, 0, sfx.track_size(self.parent:track()))
				app.new_tracks_length = value
			end,
	})
		
	--[[
	-- Not implemented yet? (as picotron 0.2.2b)
	el:attach(ui.create_label {
		x = ox, y = oy + 120,
		label = "tick length:",
	})
	el:attach_field {
		x = ox + 66, y = oy + 120 - 1,
		width = 15, height = 7,
		get = function(self) return sfx.tick_length() end,
		set = function(self, value) sfx.set_tick_length(value) end,
	}
	--]]
		
	el:attach(ui.create_label {
		x = ox + 110, y = oy + 80,
		label = "beat length:",
	})
	el:attach(ui.create_field {
		x = ox + 110 + 50, y = oy + 80 - 1,
		width = 15, height = 7,
		get = function(self) return app.beat_length end,
		set = 
			function(self, value)
				local v = mid(0, flr(value), 64)
				app.beat_length = value
			end,
	})
		
	el:attach(ui.create_label {
		x = ox + 110, y = oy + 100,
		label = "bar length:",
	})
	el:attach(ui.create_field {
		x = ox + 110 + 50, y = oy + 100 - 1,
		width = 15, height = 7,
		get = function(self) return app.bar_length end,
		set =
			function(self, value)
				local v = mid(0, flr(value), 64)
				app.bar_length = value
			end,
	})
		
	function el:track()
		return sfx.pattern_track(app.pattern, self.channel)
	end

	function el:draw()
		local nb_rows = flr(self.tracker.notegrids[1].height // app.row_height)
		local start = app.starting_row
		local x_numbers = self.side == "left"
			and (self.x_overlay - 11)
			or (self.x_overlay + app.column_width - 1)
		for i = 0, nb_rows do
			rrectfill(x_numbers, i * app.row_height, 11, app.row_height, 0, 58)
			print(string.format("%02d", i + start), x_numbers + 2, i * app.row_height + 2, 34)
		end
		if self.side == "left" then
			rrect(x_numbers, 0, app.column_width + 11, self.height, 0, 57)
		else
			rrect(self.x_overlay - 1, 0, app.column_width + 11, self.height, 0, 57)
		end
		draw_dialog_window(self.x_win, self.y_win, self.w_win, self.h_win,
			string.format("channel %d", self.channel))
		line(self.x_win + 3, self.y_win + 16,
			self.x_win + self.w_win - 1 * 3 - 1, self.y_win + 16, 58)
		line(self.x_win + 3, self.y_win + 16 + 1,
			self.x_win + self.w_win - 1 * 3 - 1, self.y_win + 16 + 1, 57)
		ui.print_centered("song settings", self.x_win + self.w_win // 2, self.y_win + 90, 5)
		line(self.x_win + 10, self.y_win + 90 + 2, self.x_win + 64, self.y_win + 90 + 2, 5)
		line(self.x_win + 140, self.y_win + 90 + 2, self.x_win + self.w_win - 10, self.y_win + 90 + 2, 5)
	end
	
	function el:click(msg)
		if msg.mx < self.x_win or msg.my < self.y_win
			or msg.mx > self.x_win + self.w_win
			or msg.my > self.y_win + self.h_win
		then
			return false
		end
		return true
	end
	
	function el:mousewheel(msg)
		self.tracker:scroll_channels(msg.wheel_y)
		return false
	end
	
	return el
end


return ui_trakdial
:: src/ui/ui.lua
--[[pod_format="raw",created="2024-04-23 10:25:40",modified="2026-02-16 14:12:04",revision=25732]]
local app = require "src/app.lua"
local settings = require "src/settings.lua"
local undo = require "src/undo.lua"


local ui = {}


----------------------------------------------------------------------------------------------------
-- Head
----------------------------------------------------------------------------------------------------


local head = false


function ui.create_head()
	head = create_gui()
end


function ui.head()
	return head
end


----------------------------------------------------------------------------------------------------
-- Misc
----------------------------------------------------------------------------------------------------


function ui.print_centered(s, x, y, col)
	local count = #s
	return print(s, x - ((count * 4) \ 2), y, col)
end


----------------------------------------------------------------------------------------------------
-- Mouse
----------------------------------------------------------------------------------------------------


function ui.mouse_lock(sensitivity, precise)
	local s = settings.user.drag_sensitivity
	if precise or key("shift") then
		s /= 4
	end
	s *= sensitivity or 1
	local dx, dy = mouselock(0x4|0x8, s, 0.0)
	if settings.user.drag_horizontal then -- TODO: remove?
		return -dx
	end
	return dy
end


function ui.mouse_unlock()
	mouselock(false)
end


----------------------------------------------------------------------------------------------------
-- Modal
----------------------------------------------------------------------------------------------------


local layer = false


function ui.open_modal(el)
	ui.close_modal()
	layer = ui.head():attach {
		x = 0, y = 0,
		width = ui.head().width, height = ui.head().height,
		draw = function(self)
			if self.dim_background then
				poke(0x550b, 0x3f)
				---fillp(0b0101101001011010)
				---fillp(0b0001001001001000)
				---fillp(0b1110110110110111)
				fillp(0b0011011011001001)
				rectfill(0, 0, self.width - 1, self.height - 1, 55)
				fillp()
				poke(0x550b, 0x00)
			end
		end,
		click = function(self)
			ui.close_modal()
		end,
		mousewheel = function(self)
			return false -- does not work?
		end
	}
	if not el.x then
		el.x = layer.width // 2 - el.width // 2
	end
	if not el.y then
		el.y = layer.height // 2 - el.height // 2
	end
	layer:attach(el)
	return el
end


function ui.has_modal()
	return layer
end


function ui.close_modal()
	if layer then
		layer:detach()
	end
	layer = false
end


function ui.has_modal_or_menu()
	return ui.has_modal() or ui.has_menu()
end


----------------------------------------------------------------------------------------------------
-- Chooser
----------------------------------------------------------------------------------------------------


function ui.chooser(options, callback)
	-- Copied from system 0.2.2b
	if (type(options) == "string") options = {path = options}
	if (type(options) ~= "table") options = {}

	options.path = fullpath(options.path or ".") -- can be relative to pwd; default to pwd()
	if (not options.path) return "could not resolve path"
	if (fstat(options.path) ~= "folder") return "path not found"

	local intention = options.intention or "choose_items"
	local intention_event = nil

	if (callback) intention_event = "_chooser_response_"..stat(333) -- unique id

	create_process("/system/apps/filenav.p64",{
		window_attribs = {autoclose = true, workspace = "current"},
		intention = intention,
		intention_event = intention_event,
		title = options.title, -- window title
		prompt = options.prompt, -- "Choose a File" (bottom left in intention pane)
		verb = options.verb, -- "Open" ~ (bottom right button in intention pane)
		path = options.path  -- starting path
	})

	if (callback) then
		-- create a unique, use-once handler 
		-- to do: mechanism to delete event handler when filenav never gets a chance to respond
		-- (but maybe too complex -- is harmless to have ~100 or so dormant event handlers sitting around)
		on_event(intention_event, function(msg)
			callback(msg)
			on_event(intention_event) -- delete
		end)
	end
	
end


----------------------------------------------------------------------------------------------------
-- Divider
----------------------------------------------------------------------------------------------------


function ui.create_horiz_divider(el)
	el.width = el.width or 15
	el.height = 2
	ui.head():new(el)
	function el:draw(msg)
		line(0, 0, self.width - 1, 0, 58)
		line(0, 1, self.width - 1, 1, 57)
	end
	return el
end


----------------------------------------------------------------------------------------------------
-- Label
----------------------------------------------------------------------------------------------------


function ui.create_label(el)
	local function get_str()
		local str = "---"
		if type(el.label) == "function" then
			str = el:label()
		elseif type(el.label) == "string" then
			str = el.label
		end
		return str
	end
	el.width = 4 * #(get_str()) + 4
	el.height = 5
	el.visible = el.visible or function() return true end
	ui.head():new(el)
	function el:draw()
		print(get_str(), 0, 0, el.fg or 5)
	end
	function el:update(el)
		if not self:visible() then
			self.hidden = true
			return
		end
		self.hidden = false
	end
	return el
end


-------------------------------------------------------------------------------
-- Button
-------------------------------------------------------------------------------


function ui.create_button(el)
	if not el.width then
		if el.label then
			el.width = 8 + (4 * #el.label)
		else
			el.width = 9
		end
	end
	el.height = el.height or 11
	el.fg = el.fg or 55
	el.bg = el.bg or 6
	el.bg_hi = el.bg_hi or 57
	el.bg_lo = el.bg_lo or 58
	el.border = el.border or 55
	el.cursor = "pointer"
	el.visible = el.visible or function() return true end
	function el:draw()
		rrect(0, 0, self.width, self.height, 2, self.border)
		if self.clicked then
			rrectfill(1, 1, self.width - 2, self.height - 2, 1, self.bg_lo)
		else
			rrectfill(1, 1, self.width - 2, self.height - 2, 1, self.bg)
			line(1, 2, 1, self.height - 3, self.bg_hi)
			line(2, 1, self.width - 3, 1, self.bg_hi)
			line(self.width - 2, 2, self.width - 2, self.height - 3, self.bg_lo)
			line(2, self.height - 2, self.width - 3, self.height - 2, self.bg_lo)
		end
		local label = self.get_label and self:get_label() or self.label
		if label then
			print(label, (self.width \ 2) - (2 * #label), 3, self.fg)
		end
	end
	function el:hover()
		return true
	end
	function el:click()
		self.clicked = true
		return true
	end
	function el:doubleclick()
		return true
	end
	function el:tap()
		if self.action then
			self:action()
		end
	end
	function el:release()
		self.clicked = false
		return true
	end
	function el:update(el)
		if not self:visible() then
			self.hidden = true
			return
		end
		self.hidden = false
	end
	return el
end


----------------------------------------------------------------------------------------------------
-- Checkbox
----------------------------------------------------------------------------------------------------


function ui.create_checkbox(el)
	el.label = el.label or ""
	el.width = 9 + 4 * #el.label
	el.height = 7
	el.cursor = "pointer"
	ui.head():new(el)
	el.visible = el.visible or function() return true end
	function el:draw()
--		rect(0, 0, 6, 6,  el.check_border or 59)
		if el.check_bg then
--			rectfill(1, 1, 5, 5, el.check_bg)
		end
		if self:get() then
--			rectfill(2, 2, 4, 4, el.check_fg or 17)
			spr(33, 0, 0)
		else
			spr(32, 0, 0)
		end
		print(el.label, 10, 1, el.fg or 5)
	end
	function el:tap()
		self:set(not self:get())
	end
	function el:update(el)
		if not self:visible() then
			self.hidden = true
			return
		end
		self.hidden = false
	end
	return el
end


----------------------------------------------------------------------------------------------------
-- Toggle
----------------------------------------------------------------------------------------------------


function ui.create_toggle(el)
	el.horiz_padding = el.horiz_padding or 0
	el.vert_padding = el.vert_padding or 0
	el.off_spr = el.off_spr or get_spr(115)
	el.on_spr = el.on_spr or get_spr(116)
 	el.width = el.off_spr:width() + 2 * el.horiz_padding
 	if type(el.label) == "string" then el.width += 4 + 4 * #el.label end
	el.height = el.off_spr:height() + 2 * el.vert_padding
	el.has_pointer = el.has_pointer or function() return true end
	el.cursor = "pointer"
	ui.head():new(el)
	if (not el.visible) el.visible = function() return true end
	function el:draw()
		if not self:visible() then return end
		local is_on = self:get() == true
		spr(is_on and self.on_spr or self.off_spr, el.horiz_padding, el.vert_padding)
		if type(el.label) == "string" then
			print(el.label, 16, 1, el.fg or 55)
		end
	end
	function el:click(msg)
		if self:has_pointer(msg.mx, msg.my) then return true end
	end
	function el:tap(msg)
		if not self:visible() then return end
		if not self:has_pointer(msg.mx, msg.my) then return end
		self:set(not self:get())
	end
	function el:hover(msg)
		if not self:visible() then return end
		if self:has_pointer(msg.mx, msg.my) then
			self.cursor = "pointer"
		else
			self.cursor = 1
		end
	end
	return el
end


----------------------------------------------------------------------------------------------------
-- Numeric Field
----------------------------------------------------------------------------------------------------


function ui.create_list(el)
	el.row_height = el.row_height or 9
	el.nb_columns = el.nb_columns or 1
	el.get_str = el.get_str or function(self, idx) return tostr(idx) end
	el.get_active = el.get_active or function(self) return nil end
	el.scrolled_to = el.scrolled_to or function(self) end
	el.get_start = el.get_start or function(self) return self.start end
	el.set_start = el.set_start or function(self, start) self.start = start end
	el.get_max = el.get_max or function(self) return 999 end
	el.disabled = el.disabled or function(self) return false end
	el.on_tap = el.on_tap or function(self) end
	el.start = el.start or 0
	el.overshoot = el.overshoot or 0
	ui.head():new(el)
	
	function el:draw(msg)
		rrectfill(1, 1, self.width - 2, self.height - 2, 0, 59)
		clip(self.sx + 1, self.sy + 1, self.width - 2, self.height - 2)
		local nb_rows = (self.height - 2) // self.row_height
		local column_width = (self.width - 2) // self.nb_columns
		local active_idx = self:get_active()
		local max = self:get_max()
		local first_row = 0
		local start = self:get_start()
		local bg_active = self:disabled() and 19 or 17
		if start < 0 then
			first_row = -start
		end
		for row = first_row, nb_rows do
			for col = 0, self.nb_columns - 1 do
				local idx = col + (start + row) * self.nb_columns
				if idx > max then break end
				local x = 1 + col * column_width
				local y = 1 + row * self.row_height
				local w = column_width
				if col == self.nb_columns - 1 then w += self.width % self.nb_columns end
				if self.draw_item then
					local hovered = msg.has_pointer and row == (msg.my - 2) // self.row_height
					self:draw_item(idx, x, y, w, self.row_height, hovered)
				else
					if idx == active_idx then
						rrectfill(x, y, w, self.row_height, 0, bg_active)
					end
					print(self:get_str(idx), x + 3, y + 2, 57)
				end
			end
		end
		if (active_idx // self.nb_columns) < start then
			pal(17, bg_active)
			spr(9, self.width // 2 - 13, 1)
			pal(17, 17)
		elseif (active_idx // self.nb_columns) > start + nb_rows then
			pal(17, bg_active)
			spr(10, self.width // 2 - 13, self.height - 7)
			pal(17, 17)
		end
		-- Borders
		clip()
		line()
		line(0, self.height - 3, 58)
		line(0, 2, 58)
		line(2, 0, 58)
		line(self.width - 3, 0, 58)
		line(self.width - 1, 2, 58)
		line(self.width - 1, self.height - 3, 57)
		line(self.width - 3, self.height - 1, 57)
		line(2, self.height - 1, 57)
		line(1, self.height - 2, 57)
	end
	
	function el:show_active()
		local active_row = self:get_active() // self.nb_columns
		local nb_rows = (self.height - 2) // self.row_height
		local start = self:get_start()
		if start > active_row then
			start = active_row
		elseif active_row > start + nb_rows - 1 then
			self:set_start(max(active_row - nb_rows + 1, 0))
		end
	end
	
	function el:center_active()
		local active_row = self:get_active() // self.nb_columns
		local nb_rows = (self.height - 2) // self.row_height
		self:set_start(active_row - nb_rows // 2)
	end
	
	function el:click(msg)
		local max = self:get_max()
		local row = (msg.my - 2) // self.row_height
		local column_width = (self.width - 2) // self.nb_columns
		local col = msg.mx // column_width
		local idx = col + (self:get_start() + row) * self.nb_columns
		if idx < 0 or idx > max then return end
		if msg.mb == 1 then
			self:set_active(idx)
		end
	end
	function el:tap(msg)
		local max = self:get_max()
		local row = (msg.my - 2) // self.row_height
		local column_width = (self.width - 2) // self.nb_columns
		local col = msg.mx // column_width
		local idx = col + (self:get_start() + row) * self.nb_columns
		if idx < 0 or idx > max then return end
		if msg.last_mb == 1 then
			self:on_tap(idx)
		end
	end
	
	function el:mousewheel(msg)
		local nb_rows = (self.height - 2) // self.row_height
		local start = self:get_start()
		local max_row = self:get_max() // self.nb_columns - nb_rows + 1
		start -= msg.wheel_y
		start = mid(start, 0 - self.overshoot, max_row + self.overshoot)
		self:set_start(start)
	end

	return el
end


----------------------------------------------------------------------------------------------------
-- Numeric Field
----------------------------------------------------------------------------------------------------


-- TODO: is this still used?
function ui.create_num_field(el)
	el.width = el.width or 62
	el.height = 12
	ui.head():new(el)
	el.visible = el.visible or function() return true end
	el.dragged = nil
	function el:draw()
		local label_fg = self.label_fg or 56
		local field_fg = self.field_fg or 22
		local dragged_fg = self.dragged_fg or 7
		local field_bg = self.field_bg or 59
		local dragged_bg = self.dragged_bg or 59
		if (not self.visible()) return
		local val = self.get()
		rectfill(self.width - 24, 0, self.width - 10, 6, self.dragged and dragged_bg or field_bg)
		print(el.label, 3, 1, label_fg)
		if val then
			print(string.format("%3d", val), self.width - 22, 1, self.dragged and dragged_fg or field_fg)
		else
			print("-", self.width - 4, 1, self.dragged and dragged_fg or field_fg)
		end
	end
	function el:hover(msg)
		if msg.mx >= self.width - 21 then
			--- self.cursor = "pointer"
			self.cursor = get_spr(50)
		else
			self.cursor = 1
		end
	end
	function el:click(msg)
		if (self.onclick) self.onclick(msg)
		if msg.mx >= self.width - 21 then
			self.dragged = true
			self.cursor = 0 -- TODO: capture mouse
		end
	end
	function el:drag(msg)
		if self.dragged then
			local _, delta = mouselock(true, key("shift") and 0.025 or 0.125, 0)
			new = mid(0, self.get() - delta, 0xff)
			self.set(new)
		end
	end
	function el:release(msg)
		self.dragged = nil
		mouselock(false)
		if (self.onrelease) self.onrelease(msg)
	end
	function el:update(el)
		if not self:visible() then
			self.hidden = true
			return
		end
		self.hidden = false
	end
	return el
end


----------------------------------------------------------------------------------------------------
-- Numeric Field (bis repetitae)
----------------------------------------------------------------------------------------------------


function ui.create_field(el)
	el.width = el.width or 4 * 4 + 3
	el.height = 7
	el.cursor = get_spr(53)
	ui.head():new(el)
	el.visible = el.visible or function(self) return true end
	el.on_confirm = el.on_confirm or function(self) end
	el.blink_timer = 0
	
	function el:draw()
		local fg = self.fg or (self.dragged and 63 or 55)
		local bg = self.dragged and 7 or 57
		if self:has_keyboard_focus() then
			fg = self.str_is_valid and 63 or 8
			bg = 7
		end
		rrectfill(0, 0, self.width, self.height, 1, bg)
		if (not self.visible) or self:visible() then
			local str
			if self:has_keyboard_focus() then
				str = self.str
			else
				local val = self:get()
				if self.to_str then
					str = self:to_str(val)
				else
					str = tostr(val)
				end
			end
			local x_cursor = 0
			if self.centered then
				x_cursor = ui.print_centered(str, self.width // 2 + 1, 1, fg)
			else
				x_cursor = print(str, self.width - 1 - 4*#str, 1, fg)
			end
			if self:has_keyboard_focus() and self.blink_timer % 32 > 16 then
				line(x_cursor, 0, x_cursor, 6, 14)
			end
		end
	end


	function el:update()
		if not self:visible() then
			self.hidden = true
			return
		end
		self.hidden = false
		if self:has_keyboard_focus() then
			self.blink_timer += 1
			while peektext() do
				if #self.str < 4 then
					self.str = self.str .. readtext()
				else
					readtext()
				end
			end
		end
		
		if not self.str then return end
		
		local val = tonum(self.str)
		self.str_is_valid = (val ~= nil) or self.str == "-"

		if keyp("backspace") then
			self.str = sub(self.str, 1, -2)
		elseif keyp("escape") or (keyp("enter") and #self.str == 0) then
			self.str = nil
 			self:set_keyboard_focus(false)
			app.was_in_text_field = true
		elseif keyp("enter") or not self:has_keyboard_focus() then
			if val then
				self:set(val)
				self:on_confirm()
			end
			self.str = nil
			self:set_keyboard_focus(false)
			app.was_in_text_field = true
		end
	end

	
	function el:click(msg)
		undo.checkpoint()
		if self.visible and (not self.visible(self)) then
			return true
		end
		self.cursor = 0
		self.dragged = true
		ui.mouse_lock(1.0, true)
		if self.onclick then
			self:onclick(msg)
		elseif self.parent.onclick then
			self.parent:onclick(msg)
		end
		return true
	end
	
	
	function el:doubleclick()
		return true
	end

	
	function el:tap()
		if self.visible and (not self.visible(self)) then
			return true
		end
		self:set_keyboard_focus(true)
		readtext(true)
		self.str = ""
	end	

	
	function el:drag(msg)
		local delta = ui.mouse_lock(1.0, true)
		local old = self:get()
		local new = old - delta
		self:set(new)
	end

	
	function el:release()
		self.cursor = get_spr(53)
		self.dragged = false
		ui.mouse_unlock()
		self.up_barrier = nil
		self.down_barrier = nil
		-- TODO: it would be nice to keep the visual modal open
		-- when the field has keyboard focus, but I didn't find
		-- a way to close the modal when the focus is lost...
		if self.onrelease then
			self:onrelease()
		elseif self.parent.onrelease then
			self.parent:onrelease()
		end
	end


	return el
end


----------------------------------------------------------------------------------------------------
-- Menu
----------------------------------------------------------------------------------------------------


local popup = false


function ui.create_menu_button(el)
	local label = el.get_label()
	local label_width = print(label, 0, -1000)
	el.width = label_width + 12
	el.height = 9
	el.cursor = "pointer"
	ui.head():new(el)
	el.opened = false
	function el:draw()
		if self.bg then
			rectfill(0, 0, self.width - 1, self.height - 1, self.bg)
		end
		local label = self:get_label()
		print(label, 2, 2, self.fg or 7)
		pal(7, self.fg or 7)
		spr(self.opened and 38 or 37, self.width - 7, 2)
		pal(7, 7)
	end
	function el:tap()
		self.opened = true
		ui.open_menu {
			x = self.sx, y = self.sy + 9,
			highlight = self.highlight,
			onclose = function()
				self.opened = false
				local label = el.get_label()
				self.width = (4 * #label) + 12
			end,
			items = self.items,
		}
	end
	return el
end


function ui.open_menu(menu)
	for i = 1, #menu.items do
		if menu.items[i].get_label then
			menu.items[i].label = menu.items[i].get_label()
		end
		if (not menu.items[i].label) menu.items[i].label = "---"
	end
	local entry_height = 9
	-- Calculate popup size
	if not menu.width then
		menu.width = 0
		for i = 1, #menu.items do
			menu.width = max(menu.width, #menu.items[i].label or 0)
		end
		menu.width = 8 + (4 * menu.width)
	end
	if not menu.height then
		menu.height = max(12, 4 + (#menu.items * entry_height))
	end
	if menu.y + menu.height > ui.head().height then
		menu.y = menu.y - 7 - menu.height
	end

	-- Modal layer	
	popup = ui.head():attach {
		x = 0, y = 0,
		width = ui.head().width, height = ui.head().height,
		draw = function(self)
			local ox, oy = menu.x, menu.y
			rectfill(ox, oy, ox + menu.width - 1, oy + menu.height - 1, menu.bg or 7)
			rect(ox, oy, ox + menu.width - 1, oy + menu.height - 1, menu.border or 55)
			for i = 1, #menu.items do
				local y = oy + 2 + (entry_height * (i - 1))
				if self.highlighted == i then
					rectfill(
						ox + 1, y,
						ox + menu.width - 2, y + entry_height - 1,
						menu.highlight or 15
					) 
				end
				print(
					menu.items[i].label,
					ox + 4, y + 2,
					menu.items[i].fg or menu.fg or 55
				)
			end
		end,
		hover = function(self)
			local ox, oy = menu.x, menu.y
			local mx, my, mb = mouse()
			if
				ox <= mx and mx < ox + menu.width
				and oy <= my and my < oy + menu.height
			then
				self.cursor = "pointer"
				self.highlighted = 1 + ((my - oy - 4) \ entry_height)
			else
				self.cursor = "pointer"
				self.highlighted = false
			end
		end,
		click = function(self)
			if popup then
				popup:detach()
			end
			popup = false
			if self.highlighted and menu.items[self.highlighted]
				and menu.items[self.highlighted].action
			then
				menu.items[self.highlighted].action()
			end
			if (menu.onclose) menu.onclose()
		end
	}
end


function ui.has_menu()
	return popup != false
end


----------------------------------------------------------------------------------------------------
-- Knob
----------------------------------------------------------------------------------------------------


function ui.create_knob(el)
	if el.small then
		el.x += 3
		el.y += 5
		el.width, el.height = 25, 25
		el.cx, el.cy, el.r = 12, 12, 7
		el.sprite = 58
	else
		el.width, el.height = 31, 31
		el.cx, el.cy, el.r = 15, 15, 9
		el.sprite = 56
	end
	if el.reversed then
		local prev_get, prev_set = el.get, el.set
		el.get = function(self) return 255 - prev_get(self) end
		el.set = function(self, v) prev_set(self, 255 - v) end
		local prev_get_sec, prev_set_sec = el.get_secondary, el.set_secondary
		el.get_secondary = function(self) return 255 - prev_get_sec(self) end
		el.set_secondary = function(self, v) prev_set_sec(self, 255 - v) end
	end
	el.cursor = "dial"
	ui.head():new(el)
	

	function el:draw()
		local target = self.min_val and self or self.parent
		local sprite = (target.min_val < 0)
			and (self.sprite + 1) or self.sprite
		spr(sprite, 0, 0)	
		local range = target.max_val - target.min_val
		-- primary value
		local val = self:get()
		local a = ((val - target.min_val) / range) * 0.75
		local x = self.cx + flr(0.5 + self.r * cos(0.625 - a))
		local y = self.cy + flr(0.5 + self.r * sin(0.625 - a))
		-- secondary value: arc and needle
		if self:has_secondary() then
			local val2 = self:get_secondary()
			local a2 = ((val2 - target.min_val) / range) * 0.75
			local r = self.small and 6 or 7.75
			local incr = 0.01 -- self.small and 0.01 or 0.01
			local function line_to(aa, col)
				local xx = self.cx + flr(0.5 + r * cos(0.625 - aa))
				local yy = self.cy + flr(0.5 + r * sin(0.625 - aa))
--				line(xx, yy, 18)
				line(self.cx, self.cy, xx, yy, 55)
			end
			local in_between =
				(a < a2) 
					and function(ai) return a < ai and ai < a2 end
					or function(ai) return a2 < ai and ai < a end
			line()
			line_to((a < a2) and a or a2)
			for ai = 0.0, 0.75, incr do
				if in_between(ai) then
					line_to(ai)
				end
			end
			line_to((a < a2) and a2 or a)
			local x2 = self.cx + flr(0.5 + (self.r - 2) * cos(0.625 - a2))
			local y2 = self.cy + flr(0.5 + (self.r - 2) * sin(0.625 - a2))
			line(self.cx, self.cy, x2, y2, self.dragged_secondary and 7 or 29)
--			circfill(x2, y2, 1.5, self.dragged_secondary and 7 or 29)
			circfill(self.cx, self.cy, self.small and 2 or 3, 32)
		end	
		-- primary needle
		local needle_col = self.dragged and 7 or 15
		if self.white then
			needle_col = self.dragged and 5 or 22
		end
		line(self.cx, self.cy, x, y, needle_col)
	end
	

	function el:click(msg)
		undo.checkpoint()
		local target = self.min_val and self or self.parent
		self.dragged = msg.mb == 1
		self.dragged_secondary = msg.mb == 2
		ui.mouse_lock(target.sensitivity)
		return true
	end
	

	function el:doubleclick(msg)
		local target = self.min_val and self or self.parent
		if msg.mb == 1 then
			self:set(target.init_val)
		elseif msg.mb == 2 then
			self:set_secondary(target.init_val)
		end
		return true
	end
	

	function el:drag(msg)
		local target = self.min_val and self or self.parent
		local delta = ui.mouse_lock(target.sensitivity)

		local old = self:get()
		local new = old - delta
		local old2, new2 = 0, 0
		if self:has_secondary() and msg.mb == 2 then
			old2 = self:get_secondary()
			new2 = old2 - delta
		end

		if delta < 0 then
			self.down_barrier = nil
			if self.up_barrier then
				self.up_barrier += delta
				if self.up_barrier <= 0 then
					self.up_barrier = nil
				else
					return
				end
			end
		elseif delta > 0 then
			self.up_barrier = nil
			if self.down_barrier then
				self.down_barrier -= delta
				if self.down_barrier <= 0 then
					self.down_barrier = nil
				else
					return
				end
			end
		end
		if old > 0 and new <= 0 then
			new = 0
			self.down_barrier = 24
		end
		if old < 0 and new >= 0 then
			new = 0
			self.up_barrier = 24
		end
		if old2 > 0 and new2 <= 0 then
			new2 = 0
			self.down_barrier = 24
		end
		if old2 < 0 and new2 >= 0 then
			new2 = 0
			self.up_barrier = 24
		end
		
		if msg.mb == 1 then
			self:set(new)
		elseif msg.mb == 2 then
			self:set_secondary(new2)
		end
	end
	

	function el:release(msg)
		self.dragged = false
		self.dragged_secondary = false
		ui.mouse_unlock()
		self.up_barrier = nil
		self.down_barrier = nil
	end
	

	return el
end


return ui
:: src/ui/visual.lua
--[[pod_format="raw",created="2024-04-16 18:22:58",modified="2026-02-16 14:12:04",revision=26456]]
local app = require "src/app.lua"
local sfx = require "src/sfx/sfx.lua"
local ui = require "src/ui/ui.lua"


local ui_visual = {}


-------------------------------------------------------------------------------
-- Locals
-------------------------------------------------------------------------------


local overlay = nil


-------------------------------------------------------------------------------


local function draw_wave(
		wt_addr, wt_width, wt_height,
		wave, phase,
		display_width, display_height,
		fg
)
	local oy = display_height \ 2
	local pos_addr = wt_addr + (wave * wt_height >> 8) * wt_width * 2
	local function pos_at(i)
		local sample = i / display_width
		sample += (phase / 256.0) % 1.0
		sample = flr(0.5 + sample * wt_width)
		local val = peek2(pos_addr + sample * 2)
		local h = flr(0.5 + ((val * display_height) / 72000))
		return h
	end
	local last_h = pos_at(0)
	for i = 0, (display_width - 1) do
		local h = pos_at(i)
		local dx = abs(h - last_h) > 3 and 0 or -1
		line(i + dx, oy - last_h, i, oy - h, fg)
 		last_h = h
	end
end


-------------------------------------------------------------------------------
-- Closing any Visual Modal
-------------------------------------------------------------------------------


function ui_visual.close()
	if overlay then
		overlay:detach()
		overlay = nil
	end
end


-------------------------------------------------------------------------------
-- Wavetable Visual and Widget
-------------------------------------------------------------------------------


function ui_visual.open_wavetable(target, fg)
	if (overlay) ui_visual.close()
	
	overlay = ui_visual.attach_wavetable(ui.head(), target, {
		x = 374, y = 8,
		width = 81, height = 50,
		border = 60,
		fg = fg
	})
end


function ui_visual.attach_wavetable(parent, target, el)
	parent:attach(el)
	function el:draw()
		rectfill(0, 0, self.width - 1, self.height - 1, 59)
		local wt_index = sfx.node_wavetable_index(app.instrument, target.node_id)
		local wt_addr, wt_width, wt_height = sfx.wavetable_info(app.instrument, wt_index)
		local _, wave1, wave0, _ = sfx.node_param(app.instrument, target.node_id, 4)
		local _, phase, _, _ = sfx.node_param(app.instrument, target.node_id, 5)
		-- Show val0 if there is an envelope
		local flags, _, _, _ = sfx.node_param(app.instrument, target.node_id, target.param)
		if flags & (0x04 | 0x10) > 0  then
			draw_wave(wt_addr, wt_width, wt_height, wave0, phase,
				self.width, self.height, 48)
		end
		-- Show val1
		draw_wave(wt_addr, wt_width, wt_height, wave1, phase,
			self.width, self.height, self.fg or 43)
		-- Border
		clip()
		if self.border then
			rrect(-1, -1, self.width + 2, self.height + 2, 2, self.border)
		else
			line()
			line(1, -1, 58)
			line(self.width - 2, -1, 58)
			line(self.width, 1, 58)
			line(self.width, self.height - 2, 57)
			line(self.width - 2, self.height, 57)
			line(1, self.height, 57)
			line(-1, self.height - 2, 57)
			line(-1, 1, 58)
			line(1, -1, 58)
		end
		clip(self.sx, self.sy, self.width, self.height)
	end
	return el
end


-------------------------------------------------------------------------------
-- Shaper Visual
-------------------------------------------------------------------------------


function ui_visual.attach_shaper_display(parent, el)
	parent:attach(el)
	function el:draw()
		rectfill(0, 0, self.width - 1, self.height - 1, 59)
	
		-- Adapted from the default tracker
		
		local _, gain, _, gain_scale  = sfx.node_param(app.instrument, parent.node_id, 0)
		gain = gain * 7.0 / 255.0
		gain = 1.0 + gain * sfx.param_scale(gain_scale)
		
		local _, elbow, _, elbow_scale = sfx.node_param(app.instrument, parent.node_id, 1)
		elbow /= 255.0
		log(elbow_flags)
		elbow *= sfx.param_scale(elbow_scale)
		
		local _, cut = sfx.node_param(app.instrument, parent.node_id, 2)
		cut = 1.0 - cut / 255.0
		local _, mix = sfx.node_param(app.instrument, parent.node_id, 3)
		local ww = self.width
		local hh = self.height
		
		
--		fillp(0x5555)
		line(0, hh - cut * hh, ww, hh - cut * hh, 60)
--		fillp()
		
		local elbow_y = cut
		local elbow_x = elbow_y / gain
		local slope = 0
		
		if (elbow_x == 1.0) then
			slope = 0
		elseif (elbow < 0.5) then
		
			local tt = elbow * 2
			local slope0 = (gain - elbow_y) / (1 - elbow_x)
			local slope1 = (1 - elbow_y) / (1 - elbow_x)
			slope = (1 - tt) * slope0 + (tt * slope1)
		else
			local tt = (elbow - .5)*2
			local slope0 = (1 - elbow_y) / (1 - elbow_x)
			slope = (1 - tt) * slope0
		end
		
		local last_xx, last_yy = 0, self.height
		for i = 0, self.width - 1, 1 do
			local tt = i / self.width
			local val = 0
			
			if tt < elbow_x then
				val = tt * gain
			else
				if elbow < 1 then
					val = elbow_y + (tt - elbow_x) * slope
				else
					-- foldback \m/
					local e2 = elbow - 1
					local h2 = elbow_y / 2
					--val = h2 + cos((tt-elbow_x)*e2) * h2
					-- 0.1.0h: linear reflection
					val = ((tt - elbow_x) * e2) % 1
					val = ((val < 0.5) and 1 - val * 4 or -1 + (val - 0.5) * 4)
					val = h2 + val * h2
				end
			end
			
			local xx = i
			local yy = self.height - val * self.height
		
			line(last_xx, last_yy, xx, yy, 9)
			last_xx, last_yy = xx, yy
		end
		
		clip()
		if self.border then
			rrect(-1, -1, self.width + 2, self.height + 2, 2, self.border)
		else
			app.draw_borders(0, 0, self.width, self.height)
		end
		clip(self.sx, self.sy, self.width, self.height)
	end
	return el
end


-------------------------------------------------------------------------------
-- Filter Visual
-------------------------------------------------------------------------------


function ui_visual.attach_filter_display(parent, el)
	parent:attach(el)
	function el:draw()
		rectfill(0, 0, self.width - 1, self.height - 1, 59)
	
		clip()
		if self.border then
			rrect(-1, -1, self.width + 2, self.height + 2, 2, self.border)
		else
			app.draw_borders(0, 0, self.width, self.height)
		end
		clip(self.sx, self.sy, self.width, self.height)
	end
	return el
end


-------------------------------------------------------------------------------
-- Delay Visual
-------------------------------------------------------------------------------


function ui_visual.attach_delay_display(parent, el)
	parent:attach(el)
	function el:draw()
		rectfill(0, 0, self.width - 1, self.height - 1, 59)
		
		local _, delay, _, delay_scale  = sfx.node_param(app.instrument, parent.node_id, 0)
		delay /= 255
		delay = delay * min(sfx.param_scale(delay_scale), 1.0)
		local _, vol, _, vol_scale  = sfx.node_param(app.instrument, parent.node_id, 1)
		vol /= 255
		vol = vol * min(sfx.param_scale(vol_scale), 1.0)
		
		local h = self.height - 16
		if delay == 0 then
			line(8, self.height - 8, 8, self.height - 8 - h, 31)
		else
			for x = 8, self.width - 9, max(flr(0.5 + delay * 70), 1) do
				local fg = h < 0.25 and 60 or 31
				line(x, self.height - 8, x, flr(0.5 + self.height - 8 - h), fg)
				h *= vol
			end
		end
	
		clip()
		if self.border then
			rrect(-1, -1, self.width + 2, self.height + 2, 2, self.border)
		else
			app.draw_borders(0, 0, self.width, self.height)
		end
		clip(self.sx, self.sy, self.width, self.height)
	end
	return el
end


-------------------------------------------------------------------------------
-- Oscilloscope Visual
-------------------------------------------------------------------------------


function ui_visual.attach_node_oscillo(parent, channel, el)
	parent:attach(el)
	el.frame_counter = 0
	function el:draw()
		local node_id = self.node_id or app.node or 0
		local horiz_scale = self.horiz_scale or 2
		local vert_scale = self.vert_scale or 1
		local bg, fg = self.bg or 59, self.fg or 49
		local node_kind = sfx.node_type(app.instrument, node_id)
		if node_id == 0 then
			-- Nothing to do, but no early return
		elseif node_kind == 2 then -- OSC
			local node_op = sfx.node_op(app.instrument, node_id)
			if node_op == 0 then
			elseif node_op == 1 or node_op == 2 then
				node_id = sfx.node_parent(app.instrument, node_id)
			end
		else
			node_id = 0
		end
		rectfill(0, 0, self.width - 1, self.height - 1, bg)
		print(tostr(node_id), 4, 4, 60)
		-- Oscilloscope
		local tick_addr = 0x200000 + node_id * 8192
		-- `tick_len` is never used by sfx.p64...
		-- but the second `stat` is necessary to get
		-- audio data into `tick_addr`
		local tick_len = stat(400 + channel, 8)
		self.frame_counter += 1
		if self.frame_counter % 1 == 0 then
			tick_len = stat(400 + channel, 20 + node_id, tick_addr)
		end
		local last_sgn = sgn(peek2(tick_addr))
		local zero_crossing = 0
		for i = 0, tick_len - horiz_scale * self.width, 2 do
			local sample = peek2(tick_addr + i)
			if zero_crossing == 0 then
				if last_sgn > 0 then
					last_sgn = sgn(sample)
				elseif sgn(sample) > last_sgn then
					zero_crossing = i
					break
				end
			end
		end
		local last_y = (self.height / 2) - (vert_scale * (peek2(tick_addr + zero_crossing) * self.height) / 72000)
		for x = 0, self.width - 1 do
			local sample = flr(x * horiz_scale) -- i.e. horizontal scaling of the waveform
			local val = peek2(tick_addr + zero_crossing + sample * 2)
			local y = (self.height / 2) - (vert_scale * (val * self.height) / 72000)
			local dx = abs(y - last_y) > 3 and 0 or -1
			line(x + dx, last_y, x, y, fg)
			last_y = y
		end

		-- Border
		clip()
		if self.border then
			rrect(-1, -1, self.width + 2, self.height + 2, 2, self.border)
		else
			line()
			line(1, -1, 58)
			line(self.width - 2, -1, 58)
			line(self.width, 1, 58)
			line(self.width, self.height - 2, 57)
			line(self.width - 2, self.height, 57)
			line(1, self.height, 57)
			line(-1, self.height - 2, 57)
			line(-1, 1, 58)
			line(1, -1, 58)
		end
		clip(self.sx, self.sy, self.width, self.height)
	end
	return el
end


-------------------------------------------------------------------------------
-- Stereo Oscillo
-------------------------------------------------------------------------------


local fg_left = 47 -- 37, 45
local fg_left_dim = 46
local fg_right = 41 -- 39, 41
local fg_right_dim = 40
local fg_both = 49 -- 38, 43
local fg_both_dim = 48

function ui_visual.draw_stereo_signal(x, y, width, height, addr, length, zero_crossing, hscale)
	rrectfill(x, y, width, height, 0, 59)
	local ymid = y + height // 2
	local vscale = (height - 0) // 2
	local function sample_to_y(sample)
		return flr(0.5 + ymid - (sample / 32768) * vscale)
	end
	local last_y_left = sample_to_y(peek2(0x90000 + zero_crossing))
	local last_y_right = sample_to_y(peek2(0x90002 + zero_crossing))
	for x = 0, width - 1 do
		local pos = zero_crossing + x * 4 * hscale
		local y_left = sample_to_y(peek2(0x90000 + pos))
		line(x, last_y_left, x + 1, y_left, fg_left)
		y_right = sample_to_y(peek2(0x90002 + pos))
		local same_spot = (y_right == y_left)
		line(x, last_y_right, x + 1, y_right, same_spot and fg_both or fg_right)
		last_y_left, last_y_right = y_left, y_right
	end
	clip()
	app.draw_borders(x, y, width, height)
end


function ui_visual.attach_stereo_oscillo(parent, el)
	el.horiz_scale = el.horiz_scale or 3
	el.frame_counter = 1
	parent:attach(el)
	function el:draw()
		local n
		if el.channel then
			n = stat(400 + el.channel, 19, 0x90000)
		else
			n = stat(465, 0, 0x90000)
		end
		local last_sgn = sgn(peek2(0x90000))
		local zero_crossing = 0
		for i = 0, 2 * n - self.horiz_scale * self.width, 4 do
			local sample = peek2(0x90000 + i)
			if zero_crossing == 0 then
				if last_sgn > 0 then
					last_sgn = sgn(sample)
				elseif sgn(sample) > last_sgn then
					zero_crossing = i
					break
				end
			end
		end
		ui_visual.draw_stereo_signal(0, 0, self.width, self.height,
			0x90000, n, zero_crossing, self.horiz_scale)
	end
	return el
end

-------------------------------------------------------------------------------
-- Custom Envelopes Visual and Widget
-------------------------------------------------------------------------------


function ui_visual.open_custom_envelope(env_id)
	if (overlay) ui_visual.close()
	
	local env_type = sfx.env_type(app.instrument, env_id)
	if (env_type != 2) return
	
	overlay = ui.head():attach {
		x = (480 \ 2) - (128 \ 2), y = 10,
		width = 128, height = 90,
		env_id = env_id,
	}
	
	function overlay:draw()
		ui_visual.draw_custom_envelope(overlay)
		rect(0, 0, self.width - 1, self.height - 1, 22)
	end
end


function ui_visual.draw_custom_envelope(self)
	local bar_width = self.width \ 16
	rectfill(1, 1, self.width - 2, self.height - 2, 59)
	local start = sfx.env_start(app.instrument, self.env_id)
	local loop0 = sfx.env_loop0(app.instrument, self.env_id)
	local loop1 = sfx.env_loop1(app.instrument, self.env_id)
	for i = 0, 15 do
		local val = sfx.env_param(app.instrument, self.env_id, i)
		local h = (val * (self.height - 2)) \ 255
		local col = (i % 2 == 0) and 29 or 18
		if loop0 <= i and i < loop1 then
			col = (i % 2 == 0) and 23 or 14
		end
		rectfill(
			1 + (bar_width * i), self.height - 1,
			bar_width + (bar_width * i), self.height - h - 1,
			col
		)
	end
	fillp(0b1111000011110000)
	poke(0x550b,0x3f)
	if start > 0 then
		local x = 1 + (bar_width * start)
		line(x, 1, x, self.height - 2, 28)
	end
	if loop0 > 0 then
		local x = 1 + (bar_width * loop0)
		line(x, 1, x, self.height - 2, 26)
	end
	if loop1 > 0 then
		local x = bar_width + (bar_width * (loop1 - 1))
		line(x, 1, x, self.height - 2, 10)
	end
	fillp()
	poke(0x550b,0x0)
	if self.selected then
		local val = sfx.env_param(app.instrument, self.env_id, self.selected)
		local str = tostr(val)
		print(str, self.width - 3 - (4 * #str), 3, 7)
	end
	rect(0, 0, self.width - 1, self.height - 1, 5)
end


return ui_visual
:: src/ui/wavetable.lua
--[[pod_format="raw",created="2026-01-25 09:41:43",modified="2026-02-16 14:12:04",revision=24682]]
local sfx = require "src/sfx/sfx.lua"
local Wavetable = require "src/wavetable.lua"
local ui = require "src/ui/ui.lua"


local ui_wavetable = {}


-------------------------------------------------------------------------------
-- Locals
-------------------------------------------------------------------------------


local wt = nil
local wave = 25


-------------------------------------------------------------------------------
-- Wavetable Temporary Widget
-------------------------------------------------------------------------------


function ui_wavetable.attach(parent, el)
	el.width = 480 - 2 * 4
	el.height = 270 - 11 - 100
	parent:attach(el)
	

	-- TODO	
	wt = Wavetable.new(256, 32)
	wt:set_wavetable(drakma_cosine2saw2reso)

	
	function el:update()
		if not wt then return end
		
		local _, _, _, _, wheel_y = mouse()
		if wheel_y > 0 and wave > 0 then
			wave -= 1
		elseif wheel_y < 0 and wave < wt.height - 1 then
			wave += 1
		end
	
		if key("alt") then
			if keyp("1") then
				wt:set_wavetable(cz_saw)
			end	
			if keyp("2") then
				wt:set_wavetable(cz_square)
			end	
			if keyp("3") then
				wt:set_wavetable(cz_pulse)
			end	
			if keyp("4") then
				wt:set_wavetable(cz_doublesine)
			end	
			if keyp("5") then
				wt:set_wavetable(cz_sawpulse)
			end	
			if keyp("6") then
				wt:set_wavetable(cz_reso1)
			end	
			if keyp("7") then
				wt:set_wavetable(cz_reso2)
			end	
			if keyp("8") then
				wt:set_wavetable(cz_reso3)
			end
			if keyp("9") then
				wt:set_wavetable(split(cz_saw, cz_reso1))
			end
			
			if keyp("q") then
				wt:set_wavetable(drakma_cosine2saw)
			end
			if keyp("w") then
				wt:set_wavetable(drakma_triangle2saw)
			end
			if keyp("e") then
				wt:set_wavetable(drakma_sine2saw)
			end
			if keyp("r") then
				wt:set_wavetable(drakma_square2saw)
			end
			if keyp("t") then
				wt:set_wavetable(drakma_cosine2saw2reso)
			end
			if keyp("a") then
				wt:set_wavetable(drakma_cosine2square)
			end
			if keyp("s") then
				wt:set_wavetable(drakma_triangle2square)
			end
			if keyp("d") then
				wt:set_wavetable(drakma_triangle2square2saw)
			end
			if keyp("f") then
				wt:set_wavetable(drakma_pulsewidth)
			end
			if keyp("g") then
				wt:set_wavetable(drakma_sawpulse)
			end
			if keyp("z") then
				wt:set_wavetable(drakma_saw2reso)
			end
			if keyp("x") then
				wt:set_wavetable(drakma_square2reso)
			end
			if keyp("c") then
				wt:set_wavetable(drakma_triangle2reso)
			end
			if keyp("v") then
				wt:set_wavetable(drakma_sawpulse2reso)
			end
			if keyp("b") then
				wt:set_wavetable(drakma_sawpulse2resoalt)
			end
		end
	end
	
	
	function el:draw()
		--print("(the wavetable editor is coming soon!)", 158, 70, 5)
		---[[
		print("num_instruments: "..sfx.num_instruments(), 4, 60, 58)
		print("num_tracks: "..sfx.num_tracks(), nil, nil, 58)
		print("num_patterns: "..sfx.num_patterns(), nil, nil, 58)
		print("patterns_address: "..string.format("%x",sfx.patterns_address()), nil, nil, 58)
		print("instruments_address: "..string.format("%x",sfx.instruments_address()), nil, nil, 58)
		print("tracks_address: "..string.format("%x",sfx.tracks_address()), nil, nil, 58)
		-- Temporary wavetable display		
		if not wt then return end
		local ox <const> = 270
		local oy <const> = el.height // 2
		rrectfill(ox, oy - 50, 200, 101, 0, 59)
		line(ox, oy, ox + 200 - 1, oy, 60)
		local last_y
		for i = 0, 199 do
			local sample = (i * wt.width) // 200
			local value = wt:get(wave, sample)
			local y = oy - math.floor(0.5 + 50 * value)
			if last_y then
				line(ox + i, last_y, ox + i, y, 27)
			end
			pset(ox + i, y, 26)
			last_y = y
		end
		print(string.format("%d", wave), ox + 4, oy - 60, 19)
		--]]
	end
end


return ui_wavetable
:: src/undo.lua
--[[pod_format="raw",created="2026-01-29 15:20:29",modified="2026-02-16 14:12:04",revision=17485]]
local app = require "src/app.lua"
local selection = require "src/selection.lua"


local undo = {}


local undo_stack


local count = 1
function undo.init()
	undo_stack = create_undo_stack(
		function()
--			notify("checkpoint "..count) count += 1
			return {
				sfx = userdata("u8", 0x40000):peek(0x30000),
				app = {
					-- Shared State
					pattern = app.pattern,
					track = app.track,
					instrument = app.instrument,
					-- Synth State
					node = app.node,
					wt = app.wt,
					-- Tracker State
					base_note = app.base_note,
					base_volume = app.base_volume,
					jump_step = app.jump_step,
					-- UI State
					view = app.view,
					detail = app.detail,
					track_header = app.track_header,
					toolrack_tab = app.toolrack_tab,
					row_height = app.row_height,
					starting_row = app.starting_row,
					env_advanced = app.env_advanced,
				},
				selection = selection.state(),
			}
		end,
		function(state)
			state.sfx:poke(0x30000)
			-- Shared State
			app.pattern = state.app.pattern
			app.track = state.app.track
			app.instrument = state.app.instrument
			-- Synth State
			app.node = state.app.node
			app.wt = state.app.wt
			-- Tracker State
			app.base_note = state.app.base_note
			app.base_volume = state.app.base_volume
			app.tracker_state = state.app.tracker_state
			-- UI State
			app.view = state.app.view
			app.detail = state.app.detail
			app.track_header = state.app.track_header
			app.toolrack_tab = state.app.toolrack_tab
			app.row_height = state.app.row_height
			app.starting_row = state.app.starting_row
			app.env_advanced = state.app.env_advanced
			-- Refresh
			app.refresh_gui = true
			-- Selection
			selection.set_state(state.selection)
		end,
		0x81 -- (0x1 binary  0x80 pxu rle)
	)
end


function undo.checkpoint()
	undo_stack:checkpoint()
end


function undo.undo()
	undo_stack:undo()
	app.update_track_patterns()
end


function undo.redo()
	undo_stack:redo()
	app.update_track_patterns()
end


return undo
:: src/waves.lua
--[[pod_format="raw",created="2026-01-23 20:54:55",modified="2026-02-16 14:12:04",revision=26336]]
----------------------------------------------------------------------------------------------------
-- Transforms
----------------------------------------------------------------------------------------------------


function nes_slope(func, coeff)
	local coeff = coeff or 2
	return function(x, w)
		local value = 2 * func(x, w) - 1
		if value > 0.0 then
			value -= x * coeff
		else
			value -= (1 - x) * coeff
		end
		value /= 1 + coeff
		local y = 0.5 + value / 2
		return y
	end
end


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


function bitcrunch(func, res)
	res = res and (res - 1) or 15
	return function(x, w)
		return math.floor(0.5 + res * func(x, w)) / res
	end
end


function phase(func, ph)
	return function(x, w)
		return func(x + ph, w)
	end
end


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


function split(funcA, funcB)
	return function(x, w)
		if x < 0.5 then
			return funcA(2 * x, w)
		else
			return funcB(2 * x - 1, w)
		end
	end
end


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


function mask(func1, func2)
	return function(x, w)
		return 1 - (1 - func1(x, w)) * (1 - func2(x, w))
	end
end


function multiply(func1, func2)
	return function(x, w)
		return func1(x, w) * func2(x, w)
	end
end


function multiply_bipolar(func1, func2)
	return function(x, w)
		local value1 = 2 * func1(x, w) - 1
		local value2 = 2 * func2(x, w) - 1
		return 0.5 + (value1 * value2) / 2
	end
end


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


function inverse(func)
	return function(x, w)
		return 1 - func(x, w)
	end
end


function reverse(func)
	return function(x, w)
		return func(x, 1 - w)
	end
end


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


function sequence(...)
	local funcs = {...}
	local count = #funcs
	return function(x, w)
		local idx = 1 + math.floor(0.5 + w * (count - 1))
		return funcs[idx](x, w * count % 1.000000000001) -- TODO
	end
end


----------------------------------------------------------------------------------------------------
-- Basic Waves
----------------------------------------------------------------------------------------------------


function w_cos(x, w)
	return 0.5 + cos(x) / 2
end


function w_sin(x, w)
	return 0.5 + sin(x) / 2
end


function w_saw(x, w)
	return x % 1.0
end


function w_triangle(x, w)
	x = x % 1.0
	if x < 0.5 then
		return 1 - (2 * x)
	else
		return (2 * x) - 1
	end
end


w_cotriangle = phase(w_triangle, 0.25)


function w_pulse50(x, w)
	x = x % 1.0
	if x < 0.5 then
		return 1
	else
		return 0
	end
end


w_square = w_pulse50


function w_pulse75(x, w)
	x = x % 1.0
	if x < 0.75 then
		return 1
	else
		return 0
	end
end


function w_pulse25(x, w)
	x = x % 1.0
	if x < 0.25 then
		return 1
	else
		return 0
	end
end


function w_pulse12(x, w)
	x = x % 1.0
	if x < 0.125 then
		return 1
	else
		return 0
	end
end


function w_pulse01(x, w)
	x = x % 1.0
	if x < 0.0078125 then
		return 1
	else
		return 0
	end
end


function w_trapeze(x, w)
	x = x % 1.0
	if x < 0.5 then
		return 0
	else
		return (2 * x) - 1
	end
end


w_triangle16 = bitcrunch(w_triangle, 16)


nes_triangle = nes_slope(phase(w_triangle16, 0.75), 1)


nes_pulse12 = nes_slope(w_pulse12, 1)
nes_pulse25 = nes_slope(w_pulse25, 1)
nes_pulse50 = nes_slope(w_pulse50, 1)
nes_pulse75 = nes_slope(w_pulse75, 1)


nes_waveforms = sequence(nes_triangle, nes_pulse75,
	nes_pulse50, nes_pulse25, nes_pulse12)


----------------------------------------------------------------------------------------------------
-- Phase Distortion
----------------------------------------------------------------------------------------------------


--[[
	y = a * x + b
	0 = a * 0 + b
	b = 0
	py = a * px
	a = py / px
	1 = c * 1 + d
	d = 1 - c
	py = c * px + d
	py = c * px + 1 - c
	py - 1 = c * (px - 1)
	c = (py - 1) / (px - 1)
]]
function bend(p0x, p0y, p1x, p1y)
	return function(x, w)
		local px = p0x + (p1x - p0x) * w
		local py = p0y + (p1y - p0y) * w
		
		local a <const> = py / px
		local c <const> = (py - 1) / (px - 1)
		local d <const> = 1 - c
		
		if x < px then
			return x * a
		else
			return x * c + d
		end
	end
end


function doublebend(funcA, funcB)
	return function(x, w)
		if x < 0.5 then
			return funcA(2 * x, w) / 2
		else
			return 0.5 + funcB(2 * x - 1, w) / 2
		end
	end
end


function distort(wfunc, bfunc)
	return function(x, w)
		return wfunc(bfunc(x, w), w)
	end
end


function reso(func)
	return function(x, w)
		local r = (15 * w) + 1
		return func((r * x) % 1, w)
	end
end


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


cz_saw =
	distort(
		w_cos,
		bend(0.5, 0.5, 0.0, 0.5)
	)


cz_square =
	distort(
		w_cos, 
		doublebend(
			bend(0.0, 0.0, 1.0, 0.0),
			bend(0.0, 0.0, 1.0, 0.0)
		)
	)


cz_pulse =
	distort(
		w_cos, 
		bend(0.0, 0.0, 0.99, 0.0)
	)


cz_doublesine =
	distort(
		split(w_cos, w_cos),
		bend(0.5, 0.5, 0.01, 0.5)
	)


cz_sawpulse =
	distort(
		w_cos,
		doublebend(
			bend(0.0, 0.0, 0.0, 0.0),
			bend(1.0, 1.0, 0.0, 1.0)
		)
	)


cz_reso1 =
	mask(
		reso(w_cos),
		w_saw
	)


cz_reso2 =
	mask(
		reso(w_cos),
		w_triangle
	)


cz_reso3 =
	mask(
		reso(w_cos),
		w_trapeze
	)


cz_saw_reso1 = split(cz_saw, cz_reso1)	

	
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


drakma_cosine2saw =
	distort(
		inverse(w_cos),
		bend(0.5, 0.5, 1.0, 0.5)
	)


drakma_triangle2saw =
	distort(
		inverse(w_triangle),
		bend(0.5, 0.5, 1.0, 0.5)
	)


drakma_sine2saw =
	distort(
		w_sin,
		doublebend(
			bend(0.5, 0.5, 0.0, 0.5),
			bend(0.5, 0.5, 1.0, 0.5)
		)
	)


drakma_square2saw =
	reverse(
		distort(
			w_saw,
			doublebend(
				bend(0.5, 0.5, 1.0, 0.0),
				bend(0.5, 0.5, 0.0, 0.99999)
			)
		)
	)


drakma_cosine2square =
	distort(
		phase(w_cos, 0.5), 
		doublebend(
			bend(0.5, 0.5, 1.0, 0.0),
			bend(0.5, 0.5, 1.0, 0.0)
		)
	)


drakma_triangle2square =
	distort(
		phase(w_triangle, 0.5),
		doublebend(
			bend(0.5, 0.5, 1.0, 0.0),
			bend(0.5, 0.5, 1.0, 0.0)
		)
	)


drakma_triangle2square2saw =
	sequence(drakma_triangle2square, drakma_square2saw)
	

drakma_pulsewidth =
	distort(
		w_square, 
		bend(0.5, 0.5, 1 - 0.001953, 0.5)
	)
	
	
drakma_sawpulse =
	split(
		distort(
			w_cos,	
			bend(0.5, 0.5, 0.0, 0.5)
		),
		distort(
			w_cos,
			doublebend(
				bend(0.5, 0.5, 0.0, 1.0),
				bend(0.5, 0.5, 1.0, 0.0)
			)
		)
	)

	
drakma_saw2reso =
	mask(
		reso(reverse(drakma_cosine2saw)),
		w_saw
	)

	
drakma_square2reso =
	mask(
		reso(reverse(drakma_cosine2square)),
		w_trapeze
	)

	
drakma_triangle2reso =
	mask(
		reso(w_triangle),
		w_triangle
	)


drakma_cosine2saw2reso = sequence(drakma_cosine2saw, drakma_saw2reso)

	
drakma_sawpulse2reso = mask(reso(w_cos), inverse(drakma_pulsewidth))

	
drakma_sawpulse2resoalt =
	mask(
		reso(reverse(cz_sawpulse)),
		distort(
			w_trapeze, 
			bend(0.5, 0.5, 1 - 0.001953, 0.5)
		)
	)

:: src/wavetable.lua
--[[pod_format="raw",created="2026-01-23 13:43:16",modified="2026-02-16 14:12:04",revision=26671]]
-- TODO: move into pfx

local Wavetable = structure {
	-- width: Int -- number of samples in a wave
	-- height: Int -- number of waves in the wavetable
	-- samples: Array[Int]
}


function Wavetable.new(width, height)
--	local samples = {}
--	for i = 0, width * height do
--		samples[i] = 0.0
--	end
	samples = userdata("i16", width, height)
	return Wavetable {
		width = width,
		height = height,
		samples = samples,
	}
end


function Wavetable:get(wave, sample)
	assert(0 <= wave and wave < self.height) -- TODO: should be < height?
--	assert(0 <= sample and sample < self.width) -- TODO: should be < width?
	local sample = sample % self.width
	local value = self.samples:get(sample, wave)
	return value / 0x7fff
end


function Wavetable:set(wave, sample, value)
	assert(0 <= wave and wave < self.height) -- TODO: should be < height?
	assert(0 <= sample and sample < self.width) -- TODO: should be < width?
	assert(-1.0 <= value and value <= 1.0)
	local sample = sample % self.width
	self.samples:set(sample, wave, value * 0x7fff)
end


function Wavetable:set_wave(wave, func)
	-- func: (x: Float) -> Float
	-- `x` is in [0,1] (instead of [0, pi])
	-- `result` is in [0, 1] (instead of [-1, +1])
	local start = wave * self.width
	local length <const> = self.width
	for i = 0, self.width - 1 do
		local value = 2 * func(i / length) - 1
		self:set(wave, i, value)
	end
end


function Wavetable:set_wavetable(func)
	-- func: (x: Float, w: Float) -> Float
	-- `x` is in [0,1] (instead of [0, pi])
	-- `w` is in [0,1] (0 = first wave of the wt, 1 = last wave)
	-- `result` is in [0, 1] (instead of [-1, +1])
	for wave = 0, self.height - 1 do
		local w = wave / (self.height - 1)
		local wavefunc = function(x) return func(x, w) end
		self:set_wave(wave, wavefunc)
	end
end


return Wavetable
:: todo.txt
--[[pod_format="raw",created="2024-04-10 20:46:30",icon=userdata("u8",16,16,"00000101010101010101010101000000000112121212121212121212120100000107011212121212121212121212010000010112121212121212121212120100000112121212121212121212121201000107011212121212121212121212010000010112121212121212121212120100000112121212121212121212121201000107011212121212121212121212010000010112121212121212121212120100000112121212121212121212121201000107011212121212121212121201010000010101010101010101010101070100000101070707070707070707071201000000011212121212121212121201000000000001010101010101010101000000"),modified="2026-02-16 14:12:04",revision=25041]]
# Things To Do

## Before Next Release

## Soonish

- add: shift-ctrl-V for insert and paste
- add: S-C-Enter to insert rows without moving.
- fix: num field entry for tuning in fm node (must support fractions).
- add: scroll-wheel support for synth knobs and fields.
- add: track config for beat and bar length.
- add: metadata (key...)
- add: drag channels left and right to reorder them.
- add: drag tracks (in track picker) to reorder them.
- fix: follow playhead for looping tracks and tracks with different speeds.
- add: contextual help for entering FXs (especially their parameters).
- add: group patterns together

## Whenever

- allow editing note, instr., vol, fx in a single go, then jump.
- related: chord mode (when selection span multiple channels).
- paginated scrolling mode, both for cursor movement and playhead
  following; configurable length: screen, beat or bar.
- enter key to preview block selection (plays all the steps in the
  selection).
- show next and previous pattern in notegrid?
- add different coloring: by instruments, scale, harmony, volume, (fx?).
- add "selection" tools in the tool-rack.
- add "edition" tools in the tool-rack.
- add "harmony" tools in the tool-rack.

## Longterm Roadmap

- improve track picker.
- add track editor.
- add wavetable creator.
- add wavetable importer.

:: .info.pod
--[[pod,author="drakmaniso",created="2024-04-16 13:35:13",icon=userdata("u8",16,16,"00000001010101010101010101000000000001070707070707070707070100000001071818181818181818181807010001071818181818180718181818180701010718181818181807071818181807010107181818181818071807181818070101071818181818180718071818180701010718181818070707181818181807010107181818070707071818181818070101071818181807071818181818180701010718181818181818181818181807010106071818181818181818181807060101060607070707070707070707060601000106060606060606060606060601000000010606060606060606060601000000000001010101010101010101000000"),lowcol_icon=false,modified="2026-02-16 14:12:04",notes="A music tracker (and instruments\neditor) for \".sfx\" files.",runtime=24,stored="2024-04-16 11:37:51",title="WaveMaker",version="0.2.1",workspaces={{location="main.lua",workspace_index=1},{location="gfx/0.gfx#132",workspace_index=2},{location="pal/0.pal",workspace_index=7}}]]
:: fonts/.info.pod
--[[pod,created="2026-01-30 07:12:02",modified="2026-02-16 14:12:04"]]
:: fonts/cozi.font
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTIxIDE5OjIyOjIwIixtb2RpZmllZD0iMjAyNi0w
MS0wNyAwNzoyODo0MSIscmV2aXNpb249MzRdXWx6NACxAwAAVwcAAPAYcHh1AAMoAAgAAAQFCgsA
AQOQD4APmA_ID-gPmQ_JD-APj3_ID4kvEAARiBgAEYkEAKSYD4gfmA-4L4gIGQDxsQAeD5gIH7gP
ifAwbz8gLUANDzMNQAwPDAxADAAMQCwwDzAPPA0JDzAgAw8PDQcDEA8_PwZAPzAPPgAPYw82DxwP
PggGCDAPGIAPDA8YUB8MIBpADwQKBLBCAAIAFXAKDx8KCwoQBA8ODwEPBggPBwQQDwkEAgEgAgUC
DwsFCgASUAgEMgQIAgQ4BAIQBA8VDw4PFQQwBA8OBGAUAjAPB4ACEBQSHwEADwYBDw0PCxEPBgAE
DjQPDgAOAQgEAg8BBwkA8jIIAQ4ABA4VBxQABwwPBygJAA4cCREOAAcYBCIADhEOEQ4ADhEPDhgO
MAIAAkAEABQCEAQCDAIEMAcABzACBAgEAk8A8BsAAgANDxEfHQ8NDA0ADhEHIQAJEQkRCQAOASwB
DgAPAwUhBQMABxwJHAcGAKAsAA0cDw0RDQAhKQDwFUIJAA04AQ4AEQUDBREAXAcADxEPGx8VLxEA
AQ8LDw0xAA5BDk8AQSwADiH6ALAJEQkDBQEADgEMDr8A8F0LVABRDgBBBQMALxEfFQ8bDxEAIQ4h
ACENGAkABwgEAhwHAA1SDQAcEhQADVgNAgWwCQACBHANIQ0AHAkhCSANLA0AGA0hDSAOAQcMDQAP
DBIHIhANIQ0IDhwJMQACAAMiCQAIAAYoAQ4cAQV4APAlA0IGIA8LHxUfESAJMSAOIQ4QCSEJHAAN
IQ0YEA8NAywgDQwOCAkAEgciBiAxDSAhBQMgH5kA9h8KIBEOERAxDQgOEAcIDgwHAA8wKA4YCmIA
DigKGA4gDg8VBiATFiBvfwAPVQ8qBADwCAAPQQ9jD38fXQ93Dz4ACx9jD3cLD0ELJwEWRAQA8BAA
DwQGD3wLDx8PGA8QAA8cDyYfXw9-Cw8cAA8iD3cfCgChCAAPKg8cDzYPd38C8AEqAB8cCw9dDxwf
FAAIDxwLLgCxKg86AAsPZw9jD2dkABELeADxBX8PYwsADxgPeCgHCQALD2MPaw9jHwDzCAgPFA8q
D10PKg8UCDAPVTALD3MPYw9zHAAxHA9-bwDxBCIQD38PIg8UCAQPIg9-AAsPdx8-APMDEA8KDwQA
D1APIBAPEQ8qD0QABwBxCw9rD3cPa0cAQQ9-AAUCAPQCb1UQD34PQg9SD0oPQg9_EAEMAEABEAEN
CgAfDQkA----aFAPSg0BAA==
:: fonts/p8_mod.font
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI2LTAxLTMwIDA3OjEyOjQzIixtb2RpZmllZD0iMjAyNi0w
MS0zMCAwNzoxNDozNCIscmV2aXNpb249Ml1dbHo0AHsFAACjBQAA8INweHUAAygACAAABAQIBhAD
8GpHMCdABwUHQAUCBUAFAAVAJTAEBgcGBCABAwcDASAHIUAkByAFBwIHAkACcAECUBMgFVACBQLA
IgACIBVQBQcFBwUgBwMGBwIgBQQCAQUgEwYFByACAVACIQIgAiQCIAUCBwIFMAIHAmACAUAHgAIg
BCIBIAclByADIgcgBwQHAQYA8QkGBAcgFQcUIAcBBwQHIBEHBQcgBzQgBwUJAPANBQcUMAIAAkAC
AAIBIAQCAQIEMAcABzABAgQCATwA8DQAAiACFQEGMAYFBwUwEwUHMAYRBjADFQMwBwMBBjAHAxEw
BgEFBzAVBwUwBxIHMAcSAzAFAxUwIQYwFxUwAyUwBhUDPADwFQEwAgUDBjADBQMFMAYBBAMwByIw
JQYwFQcCMBUXMAUSBTAFBxYA8B8EAQcgAyEDIAEiBCAGJAYgAgWQByACBFAHBQcVIAcFAwUHIAYh
BiADJQMgBwED3wCgAQMRIAYRBQYgFSIAAPcA8AIiAyAVAxUgMQcgFyUgAzUgBi0AgAUHESACFQMG
RQDwCxUgBgEHBAMgBzIgNQYgJQcCICUXIBUCFSAVIQHyFAcEAgEHIAYCAwIGIEIgAwIGAgMwBAcB
QAIFAjBPfyAPVQ8qBADyBiAPQQ9-H10PPiAOH2MPdw4gDxEPRAQA8DIgBA88DxwPHg8QIA8cDy4e
DxwgDzYeDxwIIA0PNg93DzYNIB0ODQ8UIA0OD38PKg86IA4PZw9jD2cOIA9-D10Pf1sA8BEgDzgY
Hw4gDg9jD2sPYw4gCA0ODQhAD1VADg9zD2MPcxIAoA9-Dg8iIA4NCA0pAPAKdx9jDjAFD1IPIEAP
EQ8qD0QwDg9rD3cPa1cA8CIADAAMIE9VIA8OBA8eDy0PJiAPER8hDyUCIA8MDx4fIA0gCA8eCA8k
DxogD04EDg9FIgBwIg9fHxIKIBkAsDwPEQYgDxAPDAIL1wDweCIPeh8iDxIgDx4PIAACDzwgCAkP
EAILICIPIg0gCA4ICwggDxIPPw8SAg0gCQ8QD34EDzggAgcPMgIDIA8PAg8ODxANIA4fQA8gDxgg
Dg8QGAEgCA84BAIJIAMHDxIPeA8YIA96D0ICCg9yIA8JDg9LD20PZiAPGg8nDyIPcwMgCQ9KH0kP
RmUAEToEAPJkGiAPIw9iHyINIAsACA8qD00wCw8SDyEPQCAPfQ95DxEPPQ9dIA4JCA8eDy4gBg8k
D34PJgEgDyQPTgQPRgkgCgkPWg9GDzAgDx4EBQ9EDzggDxQODyQYIA86D1YPUg8wCCAEDQQFBiAI
Ag4PIA0gHyIPJrwA8gIMDyQPcg8wIAQPNg8sDyYPZBMANEIPMK8AECMoAfAaDg9kDQ8oD3ggBAIG
DysPGUAPDgEIMAoPHw8SBDAEDw8PFQ8NMAQLBg-KAfAaIA8UBAIgDzAIDw4YIAgODyIPIAwgDigO
IAEPfgwPFA8SIAQODyQPIgNrAUAOCCAJDQDxAQEIIAQPfA8SAQggDi8gDiDkAPECJA8gASAGBw8m
AQsgDgcBDAU6AACNAVAPIg8kBxYA8AIPIg8tDzALIA8cCA4IBCAfKhYAMA8cAA0A8AcUDQ8kBCAI
DhgEMA0QDiAOBw8oAQ8skwDzDjAPXgggJwEPDiABHyQPRA9CIAIPHhINIA4XAQsgewFgMAgOCB8q
NgDRFAgBIAkADgAPHiAIBB4BQH4gD0BNACBoBnMBMQoECZkA8BMUIA0hDiAKAQoBCiAOAA4HDCAj
BwEgLxQPVA8yIBIPIg8SIAFhLyIOIA4FvQDwEgcJBwwgBhcBDw4wDxUBDwgGMAQKDxQEQAsPCAow
DQwBDXAAoGMBCCAIAQMECCA=
:: gfx/.info.pod
--[[pod,created="2024-03-24 00:48:06",modified="2026-02-16 14:12:04",stored="2024-03-24 00:48:06"]]
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2Iixtb2RpZmllZD0iMjAyNi0w
Mi0xNiAxMTo0OToxNiIscmV2aXNpb249MTAzMTVdXWx6NAClEAAAsk4AAPMle1swXT17Ym1wPXB4
dQBDIAgIBMAXQAcQFyAHEBcQByAXEAdAF8AsZmxhZ3M9MCxwYW5feAgA13k9MCx6b29tPTExfSxD
APYPEBAE8AgvOcAOBx6wDhceoA4nHpAOBw4XDpAOBx4HBgDiDgceYD4HLmAeNw6ADkcEAH8eJx6Q
TvAGcAALHTZvAPAKCj85kC4XDnAuNw5QLlcOUA5HHgcOUA4nPgYAQQcuEA4IADIOEC4IAP8TAB4n
DjAuBw4ADjcOIB4nDgAeFx4gDjcOED4wHhceoD7wCoEAHXITPzmgHhce3ADwBoAeBx4HHnAOBz4H
DmAeBz4HjgcGDgIAEgcGAGGOBz4HHmAfABFwKwASgBMBAnwAHwN8ABn0FA8NBBCvOiAOrxIOAA7N
DzkOTQdtDA5NF10MDk0nTQwOTTc9CgABFAAAHgCfzQwADK0MIKwQaQALHzdpAAMTEWkAb80MDj1H
PQUAAx-NZQAtFhJlAAG9AAtgAAEUAA9lAC4fJWUASP8HCAgEMAdgF1AHAAdABwAHICcwN0AXsEIA
GfEDGwYEIC87UC5QLkAeDxEeMB4NBABTIB4tHhAEAP8AAB5NPk0_TS5tHm0ebf4MXgALHDheAHL-
OwxvER87BABTLztPET8EAGUfOwAeLxFmADUgHg1_ACBALpEAHyBqABmgDAwEQE85UB4vOkIAmC4N
HiAODU4NDgYAIBAuGABAAB4dDtQA3y1OEA4tHlAeDR5wLnBqABn-CgcIBC85AA4AHlAOUA4QDiAO
EB4QXjAeQA6wAAwsMTRHAJEgDzlAHjBeEB5GAJ8OUA5QHgAOAC5HAB1S4E85EE4CAB9wPAAaoA0N
BJAPOw85BoAGACAWcAYAICZgBgAgNlAGACBGQAYAIFYwBgBRFi86FiAJAKMPOh8ODyUPOgYQDwCw
Dw4POR8lDyQPOQASABAmEgARLxAAAA8A-wI2DzovJR8kHzlWDi8kDoYuFp4CGfEHMAkEDzkG-xIc
Bg86DzkW-xIaFg86ABMAURoGDzoQFABRGBYPOiAUAFEYBg86MBQAURYWDzpAFAD-ABYGDzpQDzn2
GA86YP4YMH4AGfAEIAoEEP85DCAOzzgPOg7GDgAO3wkA8RPWDQ4vOBYMJgwmDA0ORhwGHDYNDhwG
DAYMBiwGLA0ONgwGAgATJhYAShYcFhwWACMWHCoAIhwWEgD-AdwNDtYNAA3MDQ7GDSD9DBClACJQ
xg86Ds-SBPEc1g86Dt8SDzoOJh84Bi0GLQYPOg5PEhcMFzwPOg4WDQYNBg0mDSYLDjwHDAIAIiwL
FgBKHRYdFhYAIx0WKgAiFxwSAO-WCw7cCwALxgsOzAsg_6kAG-8CDQ0E8CoPN7AOkE6QDrAO8Co9
AAwPqwIyJy84qQImTzijAiVPOJ8CIU84nQIfOJ0CHfoIOAoE8CgfIP8lJC8gDyXwJA4PIA7wJh4D
ADwO8ChUAMMuMTIzODA5NTIzODFgAKItMS4xMTQyODU3BgACbwAaNW8ARAgEDyVXAAZgAAB1AG8k
Di3_JB1oADdPLyQQHgIABBQ_eQAE3wAfYHcANKwFBQRgByAnAEdAUQAKhAEsMTY3ABAgPwpvJyAX
MAcAOwAdf0BHACcgB2A3AB1gAAcwFyAnvQofIDsAHV9HQEdARzUAGhAH4gB-QCcgRwBnYJ8CGc8H
BQRgZwBHICdAByA4ABlBBQUEEIkBXxAHMAcQqwAbYAcEEC86IEwDMAAOTScKvwwOTQwADC0MICwQ
3QsaBEoAAGsGNg4ADmMGFA5cBhAOVgafDzkADS8kDSAtXgAbYQwGBDAXIDMJMQAHEIIMNRAHAAgA
EzAYAD9AFyABAQ4eMFkA-woIcAcACGAXAAgHYBcIAAdwCAcAB2AIEBdQSwAaUQUFBAcgiQAVIAgA
D40BGg-fAhcPiAM0IfAEpwAPNwAapQsKBL85LzoPOQ8EAP8WHzkPOp85DzpvORAODzouDS4QDg0u
HR4QDm0OEE4dHlAODR5gLsgHGvEACwoEMC85YB4POg5QHh1OSgAzHh0uEgqQDhBuDZ4NHg0OAgAv
Lb5ZABzK8AhvOTAOTzoOMA5NBAAvbsBLABn-AwcHBDAHQBcwJyA3MCdAF1AHED4AHO8QB1AXQCcw
NyAnMBdAByABHXW-OS8lDzkPBACBHzkPJZ85DyWFAR8lhQEjLzEwhgEDHyWGAS4vMTCHAQQWJX8B
DocBD0wAEvEZFxcE8PkB8AUBBwHwBAEXAfADAScBAAHwAAE3AQcB4AEXEScB4BEHER8AEgcfACDw
AwoATwUB8AyGBBoAawBynzHwAgE3AQUA9gAAAUcB4CE3AdABZwHgQQdYAB_XWAAeE27DAAGfAEIC
EQcRTAABswBFBCHwBA0AEAMcABgCxQAfbm0AGpAZGQTw-yoB8Ac_AHAGAQcRAAEQygAAEAAAJgHw
A9ARRwEnAbABBwFHEQcRwAFXEUYBYDdB8AAxAEUBEAWAADMEASewAD8HATCMDRkPrgEBJDHgqwFX
IQcB8ACsAQT_AB8iEgImAU8BbQEBRwHwAVQBH1VWABr8KR8fBPAeBfBDBfABBfACDzpHDvAGDocO
8APH8AHn4PcBcAUwDvcBDjAFYPcDDz_QDvcDDpD3BQ2ABAAAGQCgDUAFMPcDHRAFYDMA-xcNsPcB
HcDnHeDHHcAFIA6HDh0ABaAFQA0ORw4tIAWABXBtUAXwcP4RGQysABBGrAChhg7wA8bwAebg9qwA
EfasABH2rACM9gMOkPYFDYAEACIO9qwAEvasABD2rACB9gEdwOYd4MasABWGrAAfRqwAKvwiB-BD
B-ABB-ACbz-wBq7wA87wAe7g-gFwBzD_AzAHYP4DDzqQ-gQPIZD_BQ86gP4FDQQAEEAqACAdECsA
-xENsP4BHcDuHeDOHcAHIK4dAAegB0ANbi0gB4AHcG1QB58AHkHgB-AOAwAfJKQADycFkJUAD6EA
D6-wAa4d8AMNbi3AmwAgAMoD8xUVB-ACB6AH8BlPP-ACjuCugAcgziAHYO6Q7g86cP4BcP4BDWAE
AP8YMAcQ-gENAAdQ7h1w7g2Qzh2grh3Ajh2gByANTi0AB4AHUE0wB-A-iAYZcBkZBLAH8AiEAD9A
B0CGADFf8ABN8ESDABn-AQkHBPAFTzogbhBuEG4gTgDUAxrQCQcEoE8-IG4QDk8PDj8AH6A-ABrf
HBwE-zoIMA7-OAYPOQcAAPEGXv0KDzkO-QoMDvwAnQzwAA4tLA4tCAAsDBAJALs_LQy_MA6dDA6d
DAcAH7w3AAxg8AAOnf4CZgAABABsLA79BgwwBQAf-OUJDQydCP8AVwBnMAcANwA3AAcwZwBXAA0d
ACgDHwFMARqPDAUE8A0H8A41ABqPCwUE8AsH8AtqAB6PCQ8qcA8y8Ak5AB4-DQ8qpAAcrwcFBIAn
MCcwJ4CnBw0PNwA1IRcw1wsvMBc7AB4AfQx-UAdQB2AnIDsAGhAIOwBRMAcwFwAEAC9wJ2kKG5QH
BQQnMAcQByAEAC8nMAMEGQQ-ACIAJwQADz8AH683IAdQJzAHUDcgOQAkLwdQOQAfTzBHECc5AB8C
owEQAOkOTwcwJyA_ACBvMCcAFwAnPgAlRRAHIDeoAQ9AACJPAFcAJ0AAIxAn2QISMH8AD6sBG3AL
BgQAJ2AHOwGfkAeQByAHYCdgQAAiAHkBAGYQD0QAIxI3gwAHBAAfN0MAIgCGAAQGAA9HACNgR1AH
kCdwDQEvR1A7ACBAB5A3YAYADzsAHxJAQQEOPwAPwwEaIBAX9wA-YDdQxQEqD0YAKwA8ADRQR1AK
AA_KACYBBgAPSAAmAlMCLzdgCgIjrwMFBDcAFwAXADfiBxoxAwUEehMAcAUPOQAdTycQRxA1ACAv
NxCjAB4CoQA-NxAHOQAdPzcQJ24AHz83EDdGAR8yJxAHAgAPowAeLwBHbgAfTzcANxCjACEfAKoX
HoQnCQQmHzo2HgIAf2YODzgPOSYGAAo1Zh02AgA3Jh42AgCPBg4POA0mDgwEAAI-Bh02OQAEF2Ym
AAgEAAlpAA-XAAsZM9YA8AAqBwQATygATgAeAB4APhAGAPIWLzAQPSAfMgAcABwwHAAcAB4wHgAe
EB0QHUAfKgAbABtAKxBOABMAoU0QHywAGgAaQCo6AAMoAJEAHRBPLgA5ICkVABNOEwCAHzQwGDAY
ABgmABQwKAD8AB0wHTAdAB0ATjAeAD0ATZIBoC0zLjA4NzMwMTUGABUyyxlkMy43MzYxAQAfMgcE
AZIVCQT2Bh86Fh4CAAKQAR8GBgAEFxYMAA8eAFkzJh0WAgAv9gbODBl4Jh4EHzomHgIACG8ADwYA
EQcLAA8vAP-----bOQYdJgIAD3QFGaAPFQT2AL86Jg6vuQVAvfYBvgsAEw0KAB_sCQADHwCkEhxB
gC85IEUlLyAu6hANHDX3E5_QbzkA-gsAbpA5ABrPDQcE0K85AP4XAK7QqhUZUA0HBBCPZx8gP19p
H0APPw83CwBIDzkOTwcAIAANFgBPDSCNEF0AISNfOHwfJ184fh8lXziAHyRfOIIfT184LyRnAB0B
4R8QN8QAASsgHzorICweNysgFDorIBI6KyAfOisgIr8HBwRwTzeAToBOcDgAGpAQCgQQvzogDr_i
AcDdDzkOHS83DRwNLB0LAJIMDQwNDB0MPQsLAIMcDRwtCw4dLBQAn90LAAu9CyC7EMECGQRwADCf
Dh8GAVQfDg8XnzEhow8XDyUnDQcdBx0RAHodBw0HDRcNEAAyBw0XEAAXLSwAEb3iAW8MvyQMILyQ
ABovKgbdCitqTywAOiAqxgp-LjAZMBkAGcYKGQ_BCwr-Bg0HBOAvP4AODzcucE5POCBOgC7wBWsU
GhANLxhDHg8lgHUCMSBPOHQCEHByAj_ALeBNABoQB_QmNDhQDgIA-wBALz8gDQ83LRBNEE0gLYAX
KhtzDQSAHg8lIJgAERCWABAQlgB0IC1ADzhQDAIAH5BXABpCJxsEtokNLfYJcg0h9gkEDSP2LDEN
LPYDaQ1C9gMdNiQABlkNF8YgAAQEABPGJwAHKQAn9gMgAA9MAEcjLB7dAAcdAALXAB_2WgIZkEAU
BPYAHzp2HgIAjfYPDh84DzlWBgAn9g4NAAkZADEPHXYCAEP2Cx52AgCZ9gUOHzgNVg4cBAAn9gQN
AAUVABMFPwAHQQAn9g8hAAAEACf2Dg0AAAQAD3UABAYhAA90AEoPuQMMCocCkTwVBPYtvzomvgIA
ARYIHRYGACImvQIAIvYuJwACNAg1Fg6sBAACIAAJIgAGHQAPIQA8Hy09BRmQQBkE-zox-zguECUD
BwBZHzi-Ny8EAAIWAE8PN68-CAAKEDkGKxm-BAAvHzhZAP9dBAcALzkv5wIZPygFBEMHAB8AQwcB
YCBPLAA7IEEHAC4Hl00fLjAaMBoAGisHGj0pBw-XFRkiEAlcCDFPDm9wCjAOHyUfCGEfOC8-HzhB
CAE7CDQ-OA8QABsdIAADEAAyDz8-EAA2DScNIABuAAxPJG84YQgPLwcMBJYAwG84Tw4OAA4vOA8-
L6sKMSUnDbsIMR84HxEAIi0HEAAEIQArDScQACMHLTAAAY8ABCAAbwAMbzhPJJYAH08QBPDwMgD-
-----------------------------8NQPTEwfX0=
:: label.qoi
b64$cW9pZgAAAeAAAAEOBAH_--Ho-f39-f39-f3T-qKIefk-wf7DAEz5P8H_ooh5zD-9-f39-BLE
P9cS0j-AEss-wBLWP-7DAEzZPxLLP8AS0D-_ooh5zj-9-f3OEsE-wBLBP8oSwT-IEj-IEsY-xxI-
Ej-Z-sMATD-N-qKIecU-xhLFP8cS0T8SwD8SyT8S2D-_wwBM2D-AEso-EtI--qKIec4--f39wBLB
P8ASwT-EEsE-wBLBP8USwj8SwT-IEsA-xxLGP8gSP8gSxj-I-sMATMA-0P6iiHk-Ej-WEtE-Ej-A
EsQ-wRLAPxLBPxLAPxLRP-7DAEzNP8ESPxLBPxLBPxLFP8ESwD8SwT8SwD8Syz-_ooh5zj-9-f3A
EsA-whLAP8QSwT-AEsE-xRLCPxLBP8gSPxI-xhLGP8QSxz-EEsI-wRI-yP7DAEw-Ej-L-qKIecE-
EsE-xhLFP8cS0T-AEj8Swz8Swj-CEj8SwD8S0T-_wwBMzD8Swj8SwT8SwT8SxD8Swj-CEj8SwD8S
yz-_ooh5xj8SxT-9-f3AEsA-whLAP8QSxj-FEsI-zBI-Ej-GEsY-xBLAP8MSwD-EEsI-wRI-yP7D
AEw-Ej-L-qKIeT8SP9oS0T8SwD8SxD-AEsE-EsI-wBLSP-7DAEzNP8ASwD8SPxI-EsE-EsU-wBLB
PxLCP8ASzD-_ooh5xT-BEsQ--f39wBLAP8ISwD-EEj8Swj8SP8USxT-HEsE-1hLAP8MSwD-EEj-B
EsI-xv7DAEzBP83_ooh5xT-GEsU-xxLRPxLAPxLGPxLAPxLBPxLAPxLRP-7DAEzPPxI-Ej8SPxLB
PxLHPxLAPxLBPxLAPxLLP-6iiHnGPxLFP-39-cASwD-CEsA-xBI-EsI-Ej-FEsU-xhLCP8gSxj-E
EsA-wxLAP8QSP8ESwj-F-sMATMI-zv6iiHnEP9YS0j-AEsE-EsA-wRLBPxLBPxLAPxLRP-7DAEzM
P8ESwT8SPxLBP8ESwD8SwD-BEsE-EsE-EsA-Ess--qKIec4--f39wBLBP8ASwT-EEsY-xRLFP8cS
wD-JEsA-whLAP8QSxz-EEsY-xv7DAEzAP_3_ooh5_z-_wwBM_z-_ooh5zj-9-f39-dwS_z-_wwBM
_z-_ooh5zj-9-f399v7a2tvQ-p_gpv52d339-f39-f392QKJe888Ff39-f39-f3ZAjvPPBXV-kBA
RMEVEcEVEcEV7BHBFRHBFRHBFewRwRURwRURwRXsEcEVEcEVERXuEcEVEcAVwBHBFewRwRURwBXA
EcEV7BHBFRHBFRHBFewRwRURwRURwBXOPMEVPMEVPBU8FcACO888FdURFREVERURFREVERXsERUR
FREVERURFREV7BEVERURFcMRFewRFREVERURFREV7hEVERXAERXCERXsERURFcARFcIRFewRFREV
ERXBERURFewRFREVERXCERXOPBXBPBXDPBXAAjvPPBXOERURFREVwBEVERURFREVEcEVwBEVERUR
Fd4RFREVERXAERURFREVERURwRXAERURFREV5REVERURwRXAEcAV5REVERURFcARFREVERURFRHB
FcARFREVERXeERURFREVwBEVERXAERXAEcEVwBEVERURFd4RFREVERXAERURFcARFcERwBXAERUR
FREV5REVERURwRURFREV7BEVERURwRXAERXOPMEVPMEVwDwVwQI7xj-BO8Q8FdURFREVERURFREV
ERXsERURFREVERXBERXsERURFcERFcERFewRFREVERURFREVERXsERURFcARFcARFe4RFREVwBEV
whEV7BEVERXBERURFREV7BEVERXBERXAERXQPBXBPBU8FcICO8Y--h43PD-AO8M8FdURwRURwRUR
wRXsEcEVEcEVwREV7BHBFRHBFRHBFewRwRURwRURwRXsEcEVEcEVEcEV7BHBFRHBFRHBFewRwRUR
wRURwRXsEcEVEcEVEcEVzTzBFTzBFTwVPBXAAjvGPwbAP8A7wjwV-f39-f39-dkCO8Y-BsE-wDvB
PBX9-f39-f392QI7xj8GPwbAPzvBPP4AAAD9-f39-f392QI7xj8GP8AGPzvBPDX_Q2J99jUT9jUT
9jX_iiTK0BPkNRP2NRP2NRP2NRP2NRXCAjvGPwY-wAY-O8E8NRP2NRP2NRP2NQ3QE_Q1E-Y1E-Y1
E-Y1E-Y1FcICO8Y-Bj8GP8A7wTw1E8L_9-CiwRPE-vGqbRPE-pPomsETLMETwv6O3NnBExrBE9A1
E-Y1E8I4wRPEFRPELMETLBPEGsETGhPSNQ3COMENxBXBDcATwCzBEyzBE8IawBPAGsET0DUTwTjB
E8UVE8QswRMswBPDGsATwBrBE9A1E8I4wRPEFcETwizBEyzAE8MawBPAGsET0DUTwjjBE8QVwRPC
LMETLMETwhrBExrBE9A1E8I4wRPEFRPELMETLBMsE8IawRMawRPQNf52d33CAjvDP8IGP8E7wjw1
E8E4E8f_8aptE8QsEywTLBMsE8QaExoTGhPQNRP2NRPBOBPHFRPELBMsEywTxBoTGhMaE9I1DcE4
DckVDcATwCwTLBPBLBPDGhPAGhPSNRPBOBPAOBM4wBPBFRPELBMsE8AsE8QaE8AaExoT0DUTwTgT
yRUTwiwTLBPALBPEGhPAGhMaE9A1E8E4E8cVE8QsEywTwSwTwhoTGhMaExoT0DUTwTgTxxUTxCwT
LBMsEywTwhoTGhMaExoT0DX_dnd9wgI7wj-ABsI-O8Q8NRPBOBPH-vGqbRMVE8IsEywTLBMsE8Ma
wBMaExoTx-6Uc7QTxjUTx-6xrW8Ty-5clWITyP48lZITyhwTxjUTwTgTOMATxBUTFRPCLBMsEyzB
E8IaExoTGsETxxwTxjUNwTgNxxXBDcATwCwTLBMswRPDGhPAGsATyBwTxjUTwTgTwDgTOMATwRUT
FRPCLBMsE8AsE8QaE8AaExoTxxwTxjUTwTgTOMATxBXBE8IsEywTwCwTxBoTwBoTGhPHHBPGNRPB
OBPHFcETwiwTLBPALMATwhoTGhMawRPHHBPGNRPBOBPHFRMVE8IsEywTLMETwhoTGhMawBPIHBPG
Nf52d33CAjvCPwbDPzvEPDUTwTgTx-7xqm3BE8IsEywTLBMsE8QaExoTGhPQNRP2NRPBOBPAOBPE
FcETwiwTLBMsEywTwhoTGhMaExoT0DUNwTgNxxUNwhPALBMsEywTxRoTwBoT0jUTwTgTwDgTxBXB
E8IsEywTwCwTxBoTwBoTGhPQNRPBOBPAOBPGFRPCLBMsE8AsE8QaE8AaExoT0DUTwTgTxxUTFRPC
LBMsE8EsE8IaExoTGhMaE9A1E8E4E8cVwRPCLBMsE8EsE8IaExoTGhMaE9A1-nZ3fcICO8I-BsM-
O8Q8NRPCOMETxv7xqm0TwizBEyzBE8IawRMawRPQNRP2NRPCOMETxhUTwizBEyzBE8IawRMawRPQ
NQ3COMENxBXBDcATwCzBEyzBE8IawRMawRPQNRPBOMETxxUTwizBEyzBE8IawRMawRPQNRPCOMET
xBXBE8IswRMswRPCGsETGsET0DUTwjjBE8QVwRPCLMETLMETwhrBExrBE9A1E8I4wRPGFRPCLMET
wSwTwhrBExrBE9A1-nZ3fcICO8I-wAbBP8A7xDw1E-Y1E-Y1E-Y1DdAT5DUT9jUT9jUT9jUT9jUV
wgI7wz-DO8U8NcM4Nf397Dg19jg19jg1-f3oFcICO888NcM4Nf397Dg19jg19jg1-f3oFcICO888
NcM4Nf3xOME1xP7xqm01xCzBNSzBNcIawTUawTXVODXYGsA1wBrBNdU4NfY4NfY4wTXEFTXPGsE1
GsE11TjBNcQVNc8awTUawTXR-nZ3fcICO888NcM4Nf3wODXH-vGqbTXELDUsNSw1xBo1GjXBGjXV
ODXZGjXAGjUaNdU4NfY4NfU4NccVNcYswTXEGjUaNcEaNdQ4NccVNcYswTXEGjUaNRo1GjXR-nZ3
fcICO888NcM4NdAgNcgQNcocNdAyNcsgNcgQNcocNco4NTjANcT_8aptNRU1wiw1LDUswTXCGjUa
NcAawDXHHDXLODXQIDXGGjXAGsE1xxw1yzg10CA1yBA1yhw1yzg10CA1yBA1yhw1yjg1xxU1FTXE
LME1xBo1GjXBGjXHHDXKODU4wDXEFTUVNcQswTXEGjUaNRrBNcccNcf_dnd9wgI7zzw1wzg1-fA4
NcA4NcT_8aptwTXCLDUsNcEsNcIaNRo1wRo11Tg12Ro1wBo1GjXVODX2ODX1ODXHFcE1xCzBNcQa
NRo1wRo11Dg1wDg1xBXBNcQswTXEGjUaNRo1GjXR-nZ3fcICO8ECwjvIPDXDODX98TjBNcb_8apt
NcIswTUswTXCGsE1GsE11Tg12BrBNRrBNdU4NfY4NfY4wTXGFTXNGsE1wRo11TjBNcYVNc0awTUa
NRo10f52d33CAjvAAsA8wALAO8c8NcM4Nf397Dg19jg19jg1-f3oFcICO8ACPALAPAI7xzw1wzg1
-f395zg19jg1-f3oFcICOwLAPALAPALAO8Y8NcM4Nf39-ec4NfY4Nf396BXCAjsCPALCPAI7xjw1
wzg1-fE4wTXE-vGqbTXPGsE1GjXXOME1xBXBNc0awDXAGsE11Tg19jg19jjBNcQVNc8awTUaNdc4
wTXEFcE1zRrBNRrBNdH_dnd9wgLBPALCPALGOzw1wzg1-fA4Ncf_8aptNcYswTXEGjUaNRo11jg1
yRU1xCzBNcUaNcAaNRo11Tg19jg19Tg1xxU1xizBNcQaNRo1GjXWODXHFTXGLME1xBo1GjUaNRo1
0f52d33CAsA8OwI7AjsCPAI7AjsCPAI7PDXDODXQIDXIEDXKHDXQMjXLIDXIEDXKHDXKODU4wDXE
-vGqbTUVNcQswTXEGjUaNRrBNcccNco4NccVwTXELME1xRo1wBo1GjXHHDXLODXQIDXIEDXKHDXL
ODXQIDXIEDXKHDXKODU4wDXEFTUVNcQswTXEGjUaNRrBNcccNco4NccVwTXELME1xBo1GjUawTXH
HDXH-nZ3fcICxzwCwjwCwDs8NcM4Nf3wODXAODXE-vGqbcE1xCzBNcQaNRo1GjUaNdQ4NccVNcYs
wTXFGjXAGjUaNdU4NfY4NfU4NcA4NcQVwTXELME1xBo1GjUaNRo11Dg1yRU1xCzBNcQaNRo1wRo1
0f52d33CAjvFAjwCwjwCO8A8NcM4Nf3xOME1xv7xqm01zRrBNRrBNdU4wTXEFcE1zRrBNRrBNdU4
NfY4NfY4wTXGFTXNGsE1GsE11TjBNcQVwTXNGsE1wRo10f52d33CAjvFAsA8AsA8AsA7wDw1wzg1
-f395zg19jg1-f3oFcICO8YCPALAPAI7wTw1-f3yODX2ODX2ODX9-egVwgI7xgLAPMACwDvBPDX9
-fI4NfY4NfY4Nf396BXCAjvHAsI7wjw1wzjBNcT_8aptwTXNGsE1GsE11TjBNcQVNcQswTUswTXC
GsE1wBrANcL_yqnqwDXABsE1BsE1xjjBNcQVNc8awTUawTXVODXYGsA1wBo1GjXVODX2ODX2OME1
xBXBNc0awTUawTXVOME1xBXBNc0awTUawTXR-nZ3fcICO888NcI4Ncf_8aptNcYswTXGGjUaNRo1
1Dg1xxU1xCw1LDUsNSw1who1GjUaNcQGNQY1BjUGNcEGNcU4NccVNcYswTXEGjUaNcEaNdU4Ndka
NcAaNRo11Tg19jg19Tg1xxU1xizBNcQaNRo1GjXWODXHFTXGLME1xBo1GjUaNRo10f52d33CAjvP
PDXCODXH-vGqbcE1xCzBNcQawTUaNRo1xxw1yjg1xxU1FTXCLDUsNSw1LDXCGjUaNRo1xAY1BjUG
NQY1BsE1xTg1OMA1xBU1FTXELME1xBo1GjXAGsA1xxw1yzg10CA1xho1wBrBNcccNcs4NdAgNcgQ
NcocNcs4NdAgNcgQNcocNco4NccVwTXELME1xBo1GjUawTXHHDXKODXHFcE1xCzBNcQaNRo1GsE1
xxw1x-52d33CAjvPPDXCODXJ-vGqbTXELME1xBo1wRo1GjXUODXHFcE1wiw1LDUsNSw1who1GjUa
NcQGNQY1BjUGNQY1xzg1wDg1xBXBNcQswTXEGjUaNcEaNdU4NdkaNcIaNdU4NfY4NfU4NckVNcQs
wTXEGjUaNcEaNdQ4NccVNRU1xCzBNcQaNRo1GjUaNdH_dnd9wgI7zzw1wzjBNcT_8aptwTXNGsE1
GsE11TjBNcYVNcIswTUswTXCGsE1wBrANcIGwDXABsE1BsE1xjjBNcYVNc0awTUawTXVODXYGsE1
wRo11Tg19jg19jjBNcQVwTXNGsE1GsE11TjBNcQVwTXNGsE1GsE10f52d33CAjvAPMs7wDw1-f3y
ODX2ODX2ODX9-egVwgI7wALLO8A8Nf4nOUr2NQ3COA3xNQ32NQ32NQ3COA3xNQ3COA3xNQ32NQ32
NRXCAjvPPDUN9jUNwjgN8TUN9jUN9jUNwjgN8TUNwjgN8TUN9jUN9jUVwgI7zzw1DcI4wQ3E-vGq
bQ3PGsENGsEN0DUNwjgN8TUNwjjBDcQVDc8awQ0aDdI1DcI4wQ3EFcENzRrBDRrBDdA1DcI4DfE1
DcI4DfE1DcI4wQ3EFcENzRrBDRoNGg3QNQ3COMENxBUNzxrBDRrBDdA1-nZ3fcICO888NQ3BOA3H
-vGqbQ3GLMENxhoNGg0aDdA1DcI4DfE1DcE4DccVDcYswQ3EGg0aDRoN0jUNwTgNyRUNxCzBDcYa
DRoNGg3QNQ3COA3xNQ3COA3xNQ3BOA3HFQ3GLMENxBoNGg0aDRoN0DUNwTgNxxUNxizBDcQaDRoN
wRoN0DX_dnd9wgI7zzw1DcE4DTjADcT_8aptDRUNxCzBDcQawQ0awQ3HHA3GNQ3COA3QIA3IEA3K
HA3GNQ3BOA04wA3EFQ0VDcQswQ3EGg0aDRrBDcccDcY1DcE4DccVwQ3ELMENxBrBDRoNGg3HHA3G
NQ3COA3QIA3IEA3KHA3GNQ3COA3QIA3IEA3KHA3GNQ3BOA3HFcENxCzBDcQaDRoNGsENxxwNxjUN
wTgNxxUNFQ3ELMENxBoNGg3BGg3HHA3GNf52d33CAjvB-l9XT8E7yTw1DcE4DcA4DcT_8aptwQ3E
LMENxBoNwRoNGg3QNQ3COA3xNQ3BOA3AOA3EFcENxCzBDcQaDRoNGg0aDdA1DcE4DccVDcYswQ3E
Gg3BGg0aDdA1DcI4DfE1DcI4DfE1DcE4DccVDRUNxCzBDcQaDRoNwRoN0DUNwTgNxxXBDcQswQ3E
Gg0aDcEaDdA1-nZ3fcICO8AuO8EuO8IuOy47wTw1DcI4wQ3G-vGqbQ3NGsENGsEN0DUNwjgN8TUN
wjjBDcYVDc0awQ0awQ3QNQ3COMENxBXBDc0awQ0awQ3QNQ3COA3xNQ3COA3xNQ3COMENxBXBDc0a
wQ3BGg3QNQ3COMENxhUNzRrBDcEaDdA1-nZ3fcICO8AuO8YuOy47wTw1DfY1DcI4DfE1DfY1DfY1
DcI4DfE1DcI4DfE1DfY1DfY1FcICO8AuO8YuwTvBPDXDODX2ODX98Tg19jg19jg1-f3oFcICO8Au
O8EuO8QuO8E8NcM4NfY4Nf3xODX2ODX2ODX9-egVwgI7wS7BO8UuO8E8NcM4NfY4NfY4wTXE-vGq
bTXPGsE1GsE11Tg12BrANcAawTXVODX2ODX2OME1xBU1zxrBNRrBNdU4wTXEFTXPGsE1GjXT-nZ3
fcICO888NcM4NfY4NfU4Ncf_8aptNcYswTXEGjUaNcEaNdU4NdkaNcAaNRo11Tg19jg19Tg1xxU1
xizBNcQaNRo1wRo11Dg1xxU1xizBNcQaNRo1GjXT-nZ3fcICO888NcM4NdAgNcgQNcocNcs4NdAg
NcgQNcocNco4NTjANcT_8aptNRU1xCzBNcQaNRo1wBrANcccNcs4NdAgNcYaNcAawTXHHDXLODXQ
IDXIEDXKHDXLODXQIDXIEDXKHDXKODXHFTUVNcQswTXEGjUaNcAawDXHHDXKODU4wDXEFTUVNcQs
wTXEGjUaNRrBNcccNcf_dnd9wgI7zzw1wzg19jg19Tg1wDg1xP7xqm3BNcQswTXEGjUaNcEaNdU4
NdkaNcAaNRo11Tg19jg19Tg1xxXBNcQswTXEGjUaNcEaNdQ4NcA4NcQVwTXELME1xBo1GjUaNRo1
0f52d33CAjvPPDXDODX2ODX2OME1xv7xqm01zRrBNRrBNdU4NdgawTUawTXVODX2ODX2OME1xhU1
zRrBNRrBNdU4wTXGFTXNGsE1GsE10f52d33CAjvPPDXDODX2ODX98Tg19jg19jg1-f3oFcICOzzB
OzzAO8E8wDs8wTs8NcM4Nf39-ec4NfY4Nf396BHCAjvAPDvAPDs8Ozw7wjw7wDw1wzg1-f395zg1
9jg1-f3oFcICO8A8O8A8Ozw7PME7wDw7wDw1wzg19jjBNcT_8aptwTXNGsE1GsE1wgbANcAGwTUG
wTXGOME1xBU1xCzBNSw1xBrBNRo11zjBNcQVwTXNGsA1wBrBNdU4NfY4NfY4wTXEFTXPGsE1GsE1
1TjBNcQVwTXNGsE1GsE10f52d33CAjvAPDvAPDs8O8E8O8A8O8A8NcM4NfU4Ncf_8aptNcYswTXE
GjUaNRo1GjXCBjUGNQY1BjXBBjXFODXHFTXELDUsNSw1xBo1GjUaNdY4NckVNcQswTXFGjXAGjUa
NdU4NfY4NfU4NccVNcYswTXEGjUaNcEaNdQ4NccVNcYswTXEGjUaNRo10-52d33CAjs8wTs8Ozw7
PMA7wTw7wDw1wzg10CA1yBA1yhw1yjg1x-7xqm3BNcQswTXEGjUaNRrBNcIGNQY1BjUGNQbBNcU4
NTjANcQVNRU1wiw1LDUswTXCGjUaNRrBNcccNco4NccVwTXELME1xRo1wBo1GjXHHDXLODXQIDXI
EDXKHDXLODXQIDXIEDXKHDXKODU4wDXEFTUVNcQswTXEGjUaNRrBNcccNco4NccVwTXELME1xBo1
GjUawTXHHDXH-nZ3fcICO888NcM4NfU4Ncn_8aptNcQswTXEGjUaNRo1GjXCBjUGNQY1BjUGNcc4
NcA4NcQVwTXCLDUsNSw1LDXCGjUaNRo1GjXUODXHFTXGLME1xRo1wBo1GjXVODX2ODX1ODXAODXE
FcE1xCzBNcQaNRo1GjXWODXJFTXELME1xBo1GjXBGjXR-nZ3fcICO888NcM4NfY4wTXE-vGqbcE1
zRrBNRo1GjXCBsA1wAbBNQbBNcY4wTXGFTXCLME1LME1whrBNRrBNdU4wTXEFcE1zRrBNRrBNdU4
NfY4NfY4wTXGFTXNGsE1GsE11TjBNcQVwTXNGsE1GsE10f52d33CAjvPPDXDODX9-f3nODX2ODX9
-egVwgI7wyDBOyDBO8M8Nf398jg19jg19jg1-f3oFcICO8MgOyA7IDsgO8M8Nf398jg19jg19jg1
-f3oFcICO8MgOyA7IDsgO8M8NcI4wTXF-vGqbTXPGsE1GsE11TjBNcQVNc8awTUawTXCBsA1wAbB
NQbBNcY4wTXEFTXELME1LME1whrBNRrBNdU4NdgawDXAGjUaNdU4NfY4NfY4wTXEFcE1zRrBNRrA
NdY4wTXEFcE1zRrBNRo1GjXR-nZ3fcICO8MgOyA7IDsgO8M8NcI4NcA4NTjANcH_8aptNcYswTXG
GjUaNRo11Dg1xxU1xizBNcQaNRo1GjUaNcIGNQY1BjUGNcEGNcU4NccVNcQsNSw1LDXEGjUaNcEa
NdU4NdkaNcAaNRo11Tg19jg19Tg1xxU1xizBNcQaNRo1wBo11Tg1xxU1xizBNcQaNRo1GjUaNdH_
dnd9wgI7wyDBOyDBO8M8NcI4NcA4NTjANcH_8aptNRU1xCzBNcQawTUawTXHHDXKODU4wDXEFTUV
NcQswTXEGjUaNRrBNcIGNQY1BjUGNQbBNcU4NTjANcQVNRU1wiw1LDUswTXCGjUaNcAawDXHHDXL
ODXQIDXGGjXAGsE1xxw1yzg10CA1yBA1yhw1yzg10CA1yBA1yhw1yjg1xxXBNcQswTXEGjUaNcAa
NcgcNco4NccVwTXELME1xBo1GjUawTXHHDXH-nZ3fcICO888NcI4NcA4NcT_8aptwTXELME1xBo1
wRo1GjXUODXAODXEFcE1xCzBNcQaNRo1GjUaNcIGNQY1BjUGNQY1xzg1wDg1xBXBNcIsNSw1wSw1
who1GjXBGjXVODXZGjXCGjXVODX2ODX1ODXJFTXELME1xBo1GjXAGjXVODXHFTUVNcQswTXEGjUa
NcEaNdH_dnd9wgI7zzw1wjjBNcf_8aptNc0awTUawTXVOME1xhU1zRrBNRo1GjXCBsA1wAbBNQbB
NcY4wTXGFTXCLME1LME1whrBNRrBNdU4NdgawTXBGjXVODX2ODX2OME1xBXBNc0awTUawTXVOME1
xBXBNc0awTXBGjXR-nZ3fcICO888Nf398jg19jg19jg1-f3oFcICO888NQ3COA3xNQ3COA3xNQ32
NQ32NQ3COA3xNQ3COA3xNQ32NQ32NRXCAjvPPDUNwjgN8TUNwjgN8TUN9jUN9jUNwjgN8TUNwjgN
8TUN9jUN9jUVwgI7wTw7PDvAPMA7PDvDPDUNwjgN8TUNwjgN8TUN9jUNwjjBDcT_8aptwQ3NGsEN
GsEN0DUNwjgN8TUNwjgN8TUNwjjBDcQVDcQswQ0swQ3CGsENGg3SNQ3COMENxBUNzxrBDRrBDdA1
-nZ3fcICO8E8Ozw7PDs8Ozw7wzw1DcI4DfE1DcI4DfE1DfY1DcE4Dcn_8aptDcQswQ3GGg0aDRoN
0DUNwjgN8TUNwjgN8TUNwTgNxxUNxCwNLA0sDcQaDRoNGg3SNQ3BOA3HFQ3GLMENxBoNGg3BGg3Q
Nf52d33CAjvBPDs8Ozw7PDs8O8M8NQ3COA3QIA3IEA3KHA3GNQ3COA3QIA3IEA3KHA3GNQ3HMg3L
IA3IEA3KHA3GNQ3BOA3H-vGqbcENxCzBDcQawQ0aDRoNxxwNxjUNwjgN0CANyBANyhwNxjUNwjgN
0CANyBANyhwNxjUNwTgNOMANxBUNFQ3CLA0sDSzBDcIaDRoNGsENxxwNxjUNwTgNxxUNFQ3ELMEN
xBoNGg3AGsANxxwNxjX_dnd9wgI7wTzBOzw7PDs8O8M8NQ3COA3xNQ3COA3xNQ32NQ3BOA3H-vGq
bQ3GLMENxBoNwRoNGg3QNQ3COA3xNQ3COA3xNQ3BOA3AOA3EFcENwiwNLA3BLA3CGg0aDRoNGg3Q
NQ3BOA3HFcENxCzBDcQaDRoNwRoN0DX_dnd9wgI7wjw7wDzAO8A8wTvBPDUNwjgN8TUNwjgN8TUN
9jUNwjjBDcT_8aptwQ3NGsENGsEN0DUNwjgN8TUNwjgN8TUNwjjBDcYVDcIswQ0swQ3CGsENGsEN
0DUNwjjBDcYVDc0awQ0awQ3QNf52d33CAjvPPDUNwjgN8TUNwjgN8TUN9jUN9jUNwjgN8TUNwjgN
8TUN9jUN9jUVwgI7zzw1wzg19jg1-fE4NfY4NfY4Nf396BXCAjvPPDXDODX2ODX98Tg19jg19jg1
-f3oFcICO8MQwTsQwTvDPDXDODX2ODX2OME1xP7xqm3BNcIswTUswTXCGsE1GsE1wgbANcAGwTUG
NQY1xjg12BrANcAawTXVODX2ODX2OME1xBU1xCzBNSw1xBrBNRrBNdU4wTXEFTXPGsE1GsE10f52
d33CAjvFEDsQOxA7wzw1wzg19jg19Tg1x-7xqm01xCw1LDUsNSw1who1GjUaNcQGNQY1BjUGNQY1
BjXGODXZGjXAGjUaNdU4NfY4NfU4NccVNcQsNSw1LDXEGjUaNcEaNdQ4NccVNcYswTXEGjUaNcEa
NdH_dnd9wgI7wxDBOxA7EDvDPDXDODXQIDXIEDXKHDXLODXQIDXIEDXKHDXKODXH-vGqbcE1wiw1
LDUsNSw1who1GjUawTXCBjUGNQY1BjUGwTXGODXQIDXGGjXAGsE1xxw1yzg10CA1yBA1yhw1yzg1
0CA1yBA1yhw1yjg1OMA1xBU1FTXCLDUsNSzBNcIaNRo1wBrANcccNco4NTjANcQVNRU1xCzBNcQa
NRo1GsE1xxw1x-52d33CAjvDEDvBEDsQO8M8NcM4NfY4NfU4Ncn_8aptNcIsNSw1LDUsNcIaNRo1
wRo1wgY1BjUGNQY1wQY1xjg12Ro1wBo1GjXVODX2ODX1ODXAODXEFcE1wiw1LDUsNSw1who1GjXB
GjXUODXAODXEFcE1xCzBNcQaNRo1GjXTEcICO8MQwTsQwTvDPDXDODX2ODX2OME1xBXBNcIswTUs
wTXCGsE1GsE1wgbANcAGwTXBBjXGODXYGsE1GsE11Tg19jg19jjBNcYVNcIswTUswTXCGsE1GsE1
1TjBNcYVNc0awTUawTXREcICO888NcM4NfY4Nf3xODX2ODX2ODX9-egRwgI7zzw1wzg1-f395zg1
9jg1-f3oEcICO888NcM4Nf39-ec4NfY4Nf396BHCAjvPPDXDODX1OME1xRU1zxrBNRrBNcIGwDXA
BsE1BsE1xjjBNcQVNc8awTUawTXCBsA1wAbBNQY1BjXGOME1xBXBNc0awDXAGsE11Tg19jg19jjB
NcQVNcQswTUswTXCGsE1GjXXOME1xBXBNc0awTUawDXSEcICO888NcM4NfU4NcA4NTjANcEVNcYs
wTXEGjUaNRo1GjXCBjUGNQY1BjXBBjXFODXHFTXGLME1xBo1GjUaNcQGNQY1BjUGNQY1BjXFODXJ
FTXELME1xRo1wBo1GjXVODX2ODX1ODXHFTXELDUsNSw1xBo1GjUaNdY4NccVNcYswTXEGjUaNcAa
NdIRwgI7PME7PDs8OzzBOzzBOzw1wzg10CA1yBA1yhw1yjg1wDg1OMA1wRU1FTXELME1xBo1GjUa
wTXCBjUGNQY1BjUGwTXFODU4wDXEFTUVNcQswTXEGjUaNRrBNcIGNQY1BjUGNQbBNcU4NccVwTXE
LME1xRo1wBo1GjXHHDXLODXQIDXIEDXKHDXLODXQIDXIEDXKHDXKODU4wDXEFTUVNcIsNSw1LME1
who1GjUawTXHHDXKODXHFcE1xCzBNcQaNRo1wBo1yBw1xxHCAjvAPDvAPDs8OzzBOzw7PDs8NcM4
NfU4NcA4NcQVwTXELME1xBo1GjUaNRo1wgY1BjUGNQY1BjXHODXAODXEFcE1xCzBNcQaNRo1wRo1
wgY1BjUGNQY1wQY1xTg1xxU1xizBNcUaNcAaNRo11Tg19jg19Tg1wDg1xBXBNcIsNSw1wSw1who1
GjUaNRo11Dg1yRU1xCzBNcQaNRo1wBo10hHCAjvAPDvAPDs8Ozw7PDs8wTs8NcM4NfU4wTXHFTXN
GsE1GjUaNcIGwDXABsE1BsE1xjjBNcYVNc0awTUawTXCBsA1wAbBNcEGNcY4wTXEFcE1zRrBNRrB
NdU4NfY4NfY4wTXGFTXCLME1LME1whrBNRrBNdU4wTXEFcE1zRrBNRrBNdERwgI7wDw7wDw7PDs8
Ozw7PDvBPDXDODX9-f3nODX2ODX9-egRwgI7PMA7wTzAOzw7PDs8O8E8NcM4NfY4NfY4NfY4NfY4
NfY4Nf396BHCAjvPPDXDODX2ODX2ODX2ODX2ODX2ODX9-egRwgI7zzw1wzg19jg19jg19jg12BrA
NcAaNRo11Tg19jg19jjBNcQVNcQswTUsNcQawTUawTX9zBHCAjvPPDXDODX2ODX2ODX2ODXZGjXA
GjUaNdU4NfY4NfU4NccVNcQsNSw1LDXEGjUaNcEaNf3MEcICO8MuwTsuwDvEPDXDODXQIDXIEDXK
HDXLODXQIDXIEDXKHDXLODXQIDXIEDXKHDXLODXQIDXGGjXAGsE1xxw1yzg10CA1yBA1yhw1yzg1
0CA1yBA1yhw1yjg1OMA1xBU1FTXCLDUsNSzBNcIaNRo1wBrANcccNdAyNcsgNcgQNcocNccRwgI7
wy47LjvALjvEPDXDODX2ODX2ODX2ODXZGjXCGjXVODX2ODX1ODXAODXEFcE1wiw1LDUsNSw1who1
GjXBGjX9zBHCAjvDLjsuO8AuO8Q8NcM4NfY4NfY4NfY4NdgawTXBGjXVODX2ODX2OME1xhU1wizB
NSzBNcIawTUawTX9zBHCAjvDLjsuO8AuO8Q8NcM4NfY4NfY4NfY4NfY4NfY4Nf396BHCAjvDLsE7
LsE7wzw1DfY1DcI4DfE1DcI4DfE1DfY1DfY1DcI4DfE1DfY1DfY1EcICO888NQ32NQ3COA3xNQ3C
OA3xNQ32NQ32NQ3COA3xNQ32NQ32NcMCO888NQ3COMENxBUNzxrBDRrBDdA1DcI4DfE1DcI4DfE1
DcI4wQ3EFcENzRrBDRrBDdA1DfY1DcI4DfE1DcI4wQ3EFQ3ELMENLMENwhrBDRoN0jUN9jURwgI7
zzw1DcE4DccVDcYswQ3GGg0aDRoN0DUNwjgN8TUNwjgN8TUNwTgNyRUNxCzBDcYaDRoNGg3QNQ32
NQ3COA3xNQ3BOA3HFQ3ELA0sDSwNxBoNGg0aDdI1DfY1EcICO888NQ3BOA3HFQ0VDcQswQ3FGsAN
Gg0aDcccDcY1DcI4DdAgDcgQDcocDcY1DcI4DdAgDcgQDcocDcY1DcE4DccVwQ3ELMENxBrBDRoN
Gg3HHA3GNQ3HMg3LIA3IEA3KHA3GNQ3COA3QIA3IEA3KHA3GNQ3BOA04wA3EFQ0VDcIsDSwNLMEN
whoNGg0awQ3HHA3GNQ3HMg3LIA3IEA3KHA3GNRHCAjvAPMs7wDw1DcE4DccVwQ3ELMENxhoNGg0a
DdA1DcI4DfE1DcI4DfE1DcE4DccVDcYswQ3EGg3BGg0aDdA1DfY1DcI4DfE1DcE4DcA4DcQVwQ3C
LA0sDcEsDcIaDRoNGg0aDdA1DfY1EcICO8ACyzvAPDUNwjjBDcYVDc0awQ0awQ3QNQ3COA3xNQ3C
OA3xNQ3COMENxBXBDc0awQ0awQ3QNQ32NQ3COA3xNQ3COMENxhUNwizBDSzBDcIawQ0awQ3QNQ32
NRHCAjvPPDUN9jUNwjgN8TUNwjgN8TUN9jUN9jUNwjgN8TUN9jUN9jURwgI7zzw1wzg19jg1-fE4
Nf3xODX9-egRwgI7zzw1wzg19jg1-fE4Nf3xODX9-egRwgI7zzw1wzg19jg19TjBNcUVNc8awTUa
wTXCBsA1wAbBNQY1BjXGODXYGsA1wBrBNf3QODX2OME1xBU1zxrBNRrBNf3MEcICOzzBOzzBOzzB
OzzBOzw1wzg19jg19Tg1wDg1OMA1wRU1xizBNcQaNRo1GjXEBjUGNQY1BjUGNQY1xjg12Ro1wBo1
GjX90Dg19Tg1xxU1xizBNcQaNRo1wRo1-cwRwgI7PDs8Ozw7PDvAPDvBPDvAPDXDODXQIDXIEDXK
HDXLODXQIDXIEDXKHDXKODXAODU4wDXBFTUVNcQswTXEGjUaNRrBNcIGNQY1BjUGNQbBNcY4NdAg
NcYaNcAawTXHHDXQMjXLIDXIEDXKHDXLODXQIDXIEDXKHDXKODU4wDXEFTUVNcQswTXEGjUaNcAa
wDXHHDXQMjXLIDXIEDXKHDXHEcICOzzBOzzBO8A8O8E8O8A8NcM4NfY4NfU4NcA4NcQVwTXELME1
xBo1GjXBGjXCBjUGNQY1BjXBBjXGODXZGjXAGjUaNf3QODX1ODXAODXEFcE1xCzBNcQaNRo1wRo1
-cwRwgI7PDvBPDs8O8A8O8E8O8A8NcM4NfY4NfU4wTXHFTXNGsE1GsE1wgbANcAGwTXBBjXGODXY
GsE1GsE1-dA4NfY4wTXGFTXNGsE1GsE1-cwRwgI7PDvBPDs8O8A8O8E8O8A8NcM4NfY4Nf3xODX9
8Tg1-f3oEcICO888NcM4NfY4NfY4Nf397Dg1-f3oEcICO888NcM4NfY4NfY4Nf397Dg1-f3oEcIC
O888NcM4NfY4NfY4NfY4wTXEFcE1zRrANcAawTX90Dg19jjBNcQVNc8awTUaNf3OEcICO8MuwTsu
wTvDPDXDODX2ODX2ODX1ODXJFTXELME1xRo1wBo1GjX90Dg19Tg1xxU1xizBNcQaNRo1GjX9zhHC
AjvDLjsuOy47xTw1wzg10CA1yBA1yhw1yzg10CA1yBA1yhw1yzg10CA1yBA1yhw1yjg1xxXBNcQs
wTXFGjXAGjUaNcccNdAyNcsgNcgQNcocNcs4NdAgNcgQNcocNco4NTjANcQVNRU1xCzBNcQaNRo1
GsE1xxw10DI1yyA1yBA1yhw1xxHCAjvDLjsuOy7BO8M8NcM4NfY4NfY4NfU4NccVNcYswTXFGjXA
GjUaNf3QODX1ODXAODXEFcE1xCzBNcQaNRo1GjUaNf3MEcICO8MuOy47wS47wzw1wzg19jg19jg1
9jjBNcQVwTXNGsE1GsE1-dA4NfY4wTXGFTXNGsE1GsE1-cwRwgI7wy7BOy7BO8M8NcM4NfY4NfY4
Nf397Dg1-f3oEcICO888Nf33ODX2ODX98Tg1-f3oEcICO888Nf33ODX2ODX98Tg1-f3oEcICO888
NcM4wTXEFcE1zRrBNRrBNdU4wTXEFTXPGsE1wBrANcIGwDXABsE1BsE1xjg19jg12BrANcAaNRo1
-dA4NfY4wTXEFTXPGsE1GsE1-cwRwgI7zzw1wjg1xxU1xizBNcYaNRo1GjXUODXHFTXGLME1xBo1
GjUaNcQGNQY1BjUGNcEGNcY4NfY4NdkaNcAaNRo1-dA4NfU4NccVNcYswTXEGjUaNcEaNf3MEcIC
O8M8O8M8O8M8NcI4NccVwTXELME1xBrBNRo1GjXHHDXKODXHFTUVNcQswTXEGjUaNRo1xAY1BjUG
NQY1BsE1xjg10CA1yBA1yhw1yzg10CA1xho1wBrBNcccNdAyNcsgNcgQNcocNcs4NdAgNcgQNcoc
Nco4NTjANcQVNRU1xCzBNcQaNRo1wBrANcccNdAyNcsgNcgQNcocNccRwgI7wjzAO8M8wDvCPDXC
ODXJFTXELME1xBo1wRo1GjXUODXHFcE1xCzBNcQaNRo1GjXEBjUGNQY1BjUGNcg4NfY4NdkaNcIa
Nf3QODX1ODXAODXEFcE1xCzBNcQaNRo1wRo1-cwRwgI7wTzBO8M8wTvBPDXDOME1xBXBNc0awTUa
wTXVOME1xhU1zRrBNcAawDXCBsA1wAbBNQbBNcY4NfY4NdgawTXBGjX90Dg19jjBNcYVNc0awTUa
wTX9zBHCAjvAPMI7wzzCO8A8Nf33ODX2ODX98Tg1-f3oEcICO8E8wTvDPME7wTw1E-Y1E8I4E-E1
E8I4E-E1E-Y1E-Y1E8I4E-E1E-Y1E-Y1EcICO8I8wDvDPMA7wjw1E-Y1E8I4E-E1E8I4E-E1E-Y1
E-Y1E8I4E-E1E-Y1E-Y1EcICO8M8O8M8O8M8NRPCOMETxBUTzxrBExrBE9A1E8I4E-E1E8I4E-E1
E8I4wRPEFcATzhrBExrBE9A1E8E4wRPFFRPPGsATwBrBE9A1E8I4E-E1E8I4wRPEFRPELMETLBPE
GsETGhPSNRP2NRHCAjvPPDUTwTgTxxUTxizBE8YaExoTGhPQNRPCOBPxNRPCOBPxNRPBOBPIFRPF
LMETxhoTGhMaE9A1E8E4E8A4E8QVE8YswRPFGhPAGhMaE9A1E8I4E-E1E8E4E8cVE8QsEywTLBPE
GhMaExoT0jUT9jURwgI7zzw1E8E4EzjAE8QVExUTxCzBE8QawRMawRPHHBPGNRPCOBPQIBPIEBPK
HBPGNRPCOBPQIBPIEBPKHBPGNRPBOBM4wBPFFRPFLMETxBrBExoTGhPHHBPGNRPBOBPAOBPEFRMV
E8QswRPFGhPAGhMaE8ccE8Y1E8I4E9AgE8gQE8ocE8Y1E8E4EzjAE8QVExUTwiwTLBMswRPCGhMa
ExrBE8ccE8Y1E8cyE8sgE8gQE8ocE8Y1EcICO888NRPBOBPAOBPEFcETxCzBE8QaE8EaExoT0DUT
wjgT8TUTwjgT8TUTwTgTwDgTxRUTxSzBE8QaE8EaExoT0DUTwTgTwDgTxBXBE8QswRPFGhPAGhMa
E9A1E8I4E-E1E8E4E8A4E8QVwRPCLBMsEywTLBPCGhMaExoTGhPQNRP2NRHCAjvPPDUTwjjBE8YV
E80awRMawRPQNRPCOBPxNRPCOBPxNRPCOMETxBXBE80awRMawRPQNRPBOMETxxUTzRrBExrBE9A1
E8I4E-E1E8I4wRPGFRPCLMETLMETwhrBExrBE9A1E-Y1EcICO888NRP2NRPCOBPxNRPCOBPxNRP2
NRP2NRPCOBPxNRP2NRP2NRHCAjvPPDXDODX2ODX2ODX2ODX2ODX2ODX9-egRwgI7zzw1wzg19jg1
9jg19jg19jg19jg1-f3oEcICO888NcM4NfY4NfY4NfY4NdgawDXAGsE11Tg19jg19jjBNcQVNcQs
wTUswTXCGsE1GsE1-cwRwgI7zzw1wzg19jg19jg19jg12Ro1wBo1GjXVODX2ODX1ODXHFTXELDUs
NSw1xBo1GjXBGjX9zBHCAjvPPDXDODXQIDXIEDXKHDXLODXQIDXIEDXKHDXLODXQIDXIEDXKHDXL
ODXQIDXGGjXAGsE1xxw1yzg10CA1yBA1yhw1yzg10CA1yBA1yhw1yjg1OMA1xBU1FTXCLDUsNSzB
NcIaNRo1wBrANcccNdAyNcsgNcgQNcocNccRwgI7zzw1wzg19jg19jg19jg12Ro1wBo1GjXVODX2
ODX1ODXAODXEFcE1wiw1LDXBLDXCGjUaNcEaNf3MEcICO888NcM4NfY4NfY4NfY4NdgawTUawTXV
ODX2ODX2OME1xhU1wizBNSzBNcIawTUawTX9zBHCAjvPPDXDODX2ODX2ODX2ODX2ODX2ODX9-egR
wgI7zzw1wzg1-f395zg19jg1-f3oEcICO888NcM4Nf39-ec4NfY4Nf396BHCAjvPPDXDODX2OME1
xBXBNc0awTUawTXCBsA1wAbBNQbBNcY4wTXEFTXPGsE1GsE1wgbANcAGwTUGNQY1xjjBNcQVwDXO
GsA1wBrBNdU4NfY4NfY4wTXEFTXPGsE1GjX90gI7zzw1wzg19Tg1xxU1xizBNcQaNRo1GjUaNcIG
NQY1BjUGNcEGNcU4NccVNcYswTXEGjUaNRo1xAY1BjUGNQY1BjUGNcU4NcgVNcUswTXFGjXAGjUa
NdU4NfY4NfU4NccVNcYswTXEGjUaNRo1-c4RwgI7zzw1wzg10CA1yBA1yhw1yjg1xxXBNcQswTXE
GjUaNRrBNcIGNQY1BjUGNQbBNcU4NccVNRU1xCzBNcQaNRo1GsE1wgY1BjUGNQY1BsE1xTg1OMA1
xRU1xSzBNcUaNcAaNRo1xxw1yzg10CA1yBA1yhw1yzg10CA1yBA1yhw1yjg1OMA1xBU1FTXELME1
xBo1GjUawTXHHDXQMjXLIDXIEDXKHDXHEcICO888NcM4NfU4NckVNcQswTXEGjUaNRo1GjXCBjUG
NQY1BjUGNcc4NccVwTXELME1xBo1GjXBGjXCBjUGNQY1BjXBBjXFODXAODXFFTXFLME1xRo1wBo1
GjXVODX2ODX1ODXAODXEFcE1xCzBNcQaNRo1GjUaNf3MEcICO888NcM4NfY4wTXEFcE1zRrBNRo1
GjXCBsA1wAbBNQbBNcY4wTXGFTXNGsE1GsE1wgbANcAGwTXBBjXGOME1xBXBNc0awTUawTXVODX2
ODX2OME1xhU1zRrBNRrBNf3MEcICO888NcM4Nf39-ec4NfY4Nf396BHCAjvPPDX99zg19jg19jg1
9jg1-f3oEcICO888Nf33ODX2ODX2ODX2ODX9-egRwgI7zzw1wjjBNcUVNc8awTUawTXVOME1xBU1
zxrBNRrBNcIGwDXABsE1BsE1xjg19jg12BrANcAaNRo11Tg19jg19jjBNcQVNc8awTUawTX9zBHC
AjvPPDXCODXAODXEFTXGLME1xho1GjUaNdQ4NccVNcYswTXEGjUaNRo1GjXCBjUGNQY1BjXBBjXG
ODX2ODXZGjXAGjUaNdU4NfY4NfU4NccVNcYswTXEGjUaNcEaNf3MEcICO888NcI4NcA4NcQVNRU1
xCzBNcQawTUawTXHHDXKODU4wDXEFTUVNcQswTXEGjUaNRrBNcIGNQY1BjUGNQbBNcY4NdAgNcgQ
NcocNcs4NdAgNcYaNcAawTXHHDXLODXQIDXIEDXKHDXLODXQIDXIEDXKHDXKODU4wDXEFTUVNcQs
wTXEGjUaNcAawDXHHDXQMjXLIDXIEDXKHDXHEcICO8A8yzvAPDXCODXAODXEFcE1xCzBNcQaNcEa
NRo11Dg1wDg1xBXBNcQswTXEGjUaNRo1GjXCBjUGNQY1BjUGNcg4NfY4NdkaNcIaNdU4NfY4NfU4
NcA4NcQVwTXELME1xBo1GjXBGjX9zBHCAjvAAss7wDw1wjjBNccVNc0awTUawTXVOME1xhU1zRrB
NRo1GjXCBsA1wAbBNQbBNcY4NfY4NdgawTXBGjXVODX2ODX2OME1xhU1zRrBNRrBNf3MEcICO888
Nf33ODX2ODX2ODX2ODX9-egRwgI7zzw1DcI4DfE1DcI4DfE1DcI4DfE1DfY1DcI4DfE1DcI4DfE1
DfY1DfY1EcICO888NQ3COA3xNQ3COA3xNQ3COA3xNQ32NQ3COA3xNQ3COA3xNQ32NQ32NRHCAjvP
PDUNwjgN8TUNwjgN8TUNwjgN8TUNwjjBDcQVwA3OGsENGsEN0DUNwjgN8TUNwjgN8TUNwjjBDcQV
Dc8awQ0aDdI1DfY1EcICO8I8xzvCPDUNwjgN8TUNwjgN8TUNwjgN8TUNwTgNyBUNxSzBDcYaDRoN
Gg3QNQ3COA3xNQ3COA3xNQ3BOA3HFQ3GLMENxBoNGg0aDdI1DfY1EcICO8E8-h43PMc8O8E8NQ3C
OA3QIA3IEA3KHA3GNQ3COA3QIA3IEA3KHA3GNQ3COA3QIA3IEA3KHA3GNQ3BOA04wA3FFQ3FLMEN
xBrBDRoNGg3HHA3GNQ3COA3QIA3IEA3KHA3GNQ3COA3QIA3IEA3KHA3GNQ3BOA04wA3EFQ0VDcQs
wQ3EGg0aDRrBDcccDcY1DccyDcsgDcgQDcocDcY1EcICO8A8Br_nwgYWwgYCO8A8NQ3COA3xNQ3C
OA3xNQ3COA3xNQ3BOA3AOA3FFQ3FLMENxBoNwRoNGg3QNQ3COA3xNQ3COA3xNQ3BOA3AOA3EFcEN
xCzBDcQaDRoNGg0aDdA1DfY1EcICO8A8BhbCBhbCBgI7wDw1DcI4DfE1DcI4DfE1DcI4DfE1DcI4
wQ3EFcENzRrBDRrBDdA1DcI4DfE1DcI4DfE1DcI4wQ3GFQ3NGsENGsEN0DUN9jURwgI7wDwGFsIG
FsIGAjvAPDUNwjgN8TUNwjgN8TUNwjgN8TUN9jUNwjgN8TUNwjgN8TUN9jUN9jURwgI7wDwGFsIG
FsIGAjvAPDXDODX2ODX98Tg19jg19jg1-f3oEcICO8A8BhbCBhbCBgI7wDw1wzg19jg1-fE4NfY4
NfY4Nf396BHCAjvAPAYWwgYWwgYCO8A8NcM4NfY4NfY4wTXEFcE1zRrBNRrBNcL_yqnqwDXABsE1
BjUGNcY4NdgawDXAGsE11Tg19jg19jjBNcQVNc8awTUawTX9zBHCAjvAPP4eNzwWwgYWwgYCO8A8
NcM4NfY4NfU4NccVNcYswTXEGjUaNRo1xP7Kqeo1BjUGNQY1BjUGNcY4NdkaNcAaNRo11Tg19jg1
9Tg1xxU1xizBNcQaNRo1wRo1-cwRwgI7wDz_Hjc8FsIGFsIGAjvAPDXDODXQIDXIEDXKHDXLODXQ
IDXIEDXKHDXKODXHFcE1xCzBNcQaNRo1GsE1wv7Kqeo1BjUGNQY1BsE1xjg10CA1xho1wBrBNccc
Ncs4NdAgNcgQNcocNcs4NdAgNcgQNcocNco4NTjANcQVNRU1xCzBNcQaNRo1wBrANcccNdAyNcsg
NcgQNcocNccRwgI7wDz_Hjc8FsIGFsIGAjvAPDXDODX2ODX1ODXJFTXELME1xBo1GjXBGjXC-sqp
6jUGNQY1BjXBBjXGODXZGjXAGjUaNdU4NfY4NfU4NcA4NcQVwTXELME1xBo1GjXBGjX9zBHCAjvA
PP4eNzwWwgYWwgYCO8A8NcM4NfY4NfY4wTXEFcE1zRrBNRrBNcL_yqnqwDXABsE1wQY1xjg12BrB
NRrBNdU4NfY4NfY4wTXGFTXNGsE1GsE1-cwRwgI7wDz_Hjc8FsIGFsIGAjvAPDXDODX2ODX98Tg1
9jg19jg1-f3oEcICO8A8BhbCBhbCBgI7wDw1wzg1-f395zg19jg1-f3oEcICO8A8BhbCBhbCBgI7
wDw1wzg1-f395zg19jg1-f3oEcICO8A8BhbCBhbCBgI7wDw1wzg19TjBNcUVNc8awTUawTXC-sqp
6sA1wAbBNQbBNcY4wTXEFTXPGsE1GsE1wgbANcAGwTUGNQY1xjjBNcQVwDXOGsA1wBrBNdU4NfY4
NfY4wTXEFTXELME1LDXEGsE1GjX9zhHCAjvAPP4eNzwWwgYWwgYCO8A8NcM4NfU4NcA4NcQVNcYs
wTXEGjUaNRo1GjXC-sqp6jUGNQY1BjXBBjXFODXHFTXGLME1xBo1GjUaNcQGNQY1BjUGNQY1BjXF
ODXIFTXFLME1xRo1wBo1GjXVODX2ODX1ODXHFTXELDUsNSw1xBo1GjUaNf3OEcICO8A8-h43PBbC
BhbCBgI7wDw1wzg10CA1yBA1yhw1yjg1wDg1xBU1FTXELME1xBo1GjUawTXC-sqp6jUGNQY1BjUG
wTXFODU4wDXEFTUVNcQswTXEGjUaNRrBNcIGNQY1BjUGNQbBNcU4NTjANcUVNcUswTXFGjXAGjUa
NcccNcs4NdAgNcgQNcocNcs4NdAgNcgQNcocNco4NTjANcQVNRU1wiw1LDUswTXCGjUaNRrBNccc
NdAyNcsgNcgQNcocNccRwgI7wDz_Hjc8FsIGFsIGAjvAPDXDODX1ODXAODXEFcE1xCzBNcQaNRo1
GjUaNcL_yqnqNQY1BjUGNQY1xzg1wDg1xBXBNcQswTXEGjUaNcEaNcIGNQY1BjUGNcEGNcU4NcA4
NcUVNcUswTXFGjXAGjUaNdU4NfY4NfU4NcA4NcQVwTXCLDUsNSw1LDXCGjUaNRo1GjX9zBHCAjvA
PP4eNzwWwgYWwgYCO8A8NcM4NfU4wTXHFTXNGsE1GjUaNcL_yqnqwDXABsE1BsE1xjjBNcYVNc0a
wTUawTXCBsA1wAbBNcEGNcY4wTXEFcE1zRrBNRrBNdU4NfY4NfY4wTXGFTXCLME1LME1whrBNRrB
Nf3MEcICO8A8-h43PBbCBhbCBgI7wDw1wzg1-f395zg19jg1-f3oEcICO8A8BhbCBhbCBgI7wDw1
wzg19jg19jg19jg19jg19jg1-f3oEcICO8A8BhbCBhbCBgI7wDw1wzg19jg19jg19jg19jg19jg1
-f3oEcICO8A8BhbCBhbCBgI7wDw1wzg19jg19jg19jg12BrANcAaNRo11Tg19jg19jjBNcQVNcQs
wTUswTXCGsE1GsE1-cwRwgI7wDwGFsIGFsIGAjvAPDXDODX2ODX2ODX2ODXZGjXAGjUaNdU4NfY4
NfU4NccVNcQsNSw1LDXEGjUaNcEaNf3MEcICO8A8BhbCBhbCBgI7wDw1wzg10CA1yBA1yhw1yzg1
0CA1yBA1yhw1yzg10CA1yBA1yhw1yzg10CA1xho1wBrBNcccNcs4NdAgNcgQNcocNcs4NdAgNcgQ
NcocNco4NTjANcQVNRU1wiw1LDUswTXCGjUaNcAawDXHHDXQMjXLIDXIEDXKHDXHEcICO8A8BhbC
BhbCBgI7wDw1wzg19jg19jg19jg12Ro1who11Tg19jg19Tg1wDg1xBXBNcIsNSw1wSw1who1GjXB
GjX9zBHCAjvAPAYWwgYWwgYCO8A8NcM4NfY4NfY4NfY4NdgawTXBGjXVODX2ODX2OME1xhU1wizB
NSzBNcIawTUawTX9zBHCAjvAPAYWwgYWwgYCO8A8NcM4NfY4NfY4NfY4NfY4NfY4Nf396BHCAjvA
PAYWwgYWwgYCO8A8NQ32NQ3COA3xNQ3COA3xNQ32NQ3COA3xNQ3COA3xNQ32NQ32NRHCAjvAPAYW
wgYWwgYCO8A8NQ32NQ3COA3xNQ3COA3xNQ32NQ3COA3xNQ3COA3xNQ32NQ32NRHCAjvAPAYWwgYW
wgYCO8A8NQ32NQ3COA3xNQ3COA3xNQ3COMENxBXADc4awQ0awQ3QNQ3COA3xNQ3COA3xNQ3COMEN
xBUNzxrBDRoN0jUN9jURwgI7wDwGFsIGFsIGAjvAPDUN9jUNwjgN8TUNwjgN8TUNwTgNyBUNxSzB
DcYaDRoNGg3QNQ3COA3xNQ3COA3xNQ3BOA3HFQ3GLMENxBoNGg0aDdI1DfY1wwI7wDwGFsIGFsIG
AjvAPAL9-f39-f392DwCO8A8BhbCBhbCBgI7wDwCO-39-f39-f3XPAI7wDwGFsIGFsIGAjvAPAI7
-f39-f39-dc8AjvAPAYWwgYWwgYCO8A8Ajv9-f39-f391zwCO8A8BhbCBhbCBgI7wDwCO-39-f39
-f3XPAI7wDwGFsIGFsIGAjvAPAI7wjz9-f39-f39zzvCPAI7wDwGFsIGFsIGAjvAPAI7wTwG-f39
-f39-c88O8E8AjvAPAYWwgYWwgYCO8A8AjvAPAb9-f39-f390QI7wDwCO8A8BhbCBhbCBgI7wDwC
O8A8BtoCwQYCBgIG-eECwQYCBgIG-eECwQYCBgIG-eECwQYCBgIG-eECwQYCBgIGwAI7wDwCO8A8
BhbCBhbCBgI7wDwCO8A8BtoCBv3nAgb95wIG-ecCBv3nAgbGAjvAPAI7wDwGFsIGFsIGAjvAPAI7
wDwG2gIG-ecCBv3nAgb95wIG-ecCBsYCO8A8AjvAPAYWwgYWwgYCO8A8AjvAPAbaAgbAAgb95AIG
wAIG-eQCBsACBv3kAgbAAgb95AIGwAIGwwI7wDwCO8A8BhbCBhbCBgI7wDwCO8A8BtoCBsACwAb9
4wIGwALABv3jAgbAAsAG-eMCBsACwAb94wIGwALABsICO8A8AjvAPAYWwgYWwgYCO8A8AjvAPAba
AsQG-eICxAb94gLEBv3iAsQG-eICxAbBAjvAPAI7wDwGFsIGFsIGAjvAPAI7wDwG3QLABv3mAsAG
-eYCwAb95gLABv3mAsAGwgI7wDwCO8A8BhbCBhbCBgI7wDwCO8A8Bt0CBv3nAgb95wIG-ecCBv3n
AgbDAjvAPAI7wDwGLMIGLMIGAjvAPAI7wDwG-f39-f39-dECO8A8AjvBAgbHAjvBPAI7wDwGwRbT
BsMW0wbDFtMGwxbTBsMW0wbD-gClodMGwxbTBsMW0wbDFtMGwxbTBsMW0wbDFtMGwxbTBsMW0wbD
FtMGwxbTBsMW0wbDFsYCO8A8AjvCAsc7wjwCO8A8BsAW1QbBFtUGwRbVBsEW1QbBFtUGwRXVBsEW
1QbBFtUGwRbVBsEW1QbBFtUGwRbVBsEW1QbBFtUGwRbVBsEW1QbBFtUGwRbHAjvAPAI7zzwCO8A8
BsAW1QbBFtUGwRbVBsEW1QbBFtUGwRXVBsEW1QbBFtUGwRbVBsEW1QbBFtUGwRbVBsEW1QbBFtUG
wRbVBsEW1QbBFtUGwRbHAjvAPAI7zzwCO8A8BsAWwgLBFgLBFsoGwRbCAsEWAsAWywbBFsICwRYC
wRbKBsEWwgLBFgLBFsoGwRbCAsEWAhYCFsoGwRXCAsEVAsEVygbBFsICwRYCFswGwRbCAsEWAsEW
ygbBFsICwRYCwRbKBsEWwgLBFgLBFsoGwRbCAsAWwALBFsoGwRbCAsAWwALAFssGwRbCAsAWwALB
FsoGwRbCAsAWwALBFsoGwRbCAsAWwAIWAhbKBsEWwgLAFsACwRbKBsEWwgLAFsACFswGwRbCAsAW
wALAO8A8AjvPPAI7wDwGwBbCAhYCFgIWAhbKBsEWwgIWAhbAAhbLBsEWwgIWAhbBAhbKBsEWwgIW
AhbBAhbKBsEWwgIWAhYCFgIWygbBFcICFQIVAhXMBsEWwgIWAhYCFswGwRbCAhYCFsECFsoGwRbC
AhYCFgIWAhbKBsEWwgIWAhYCFgIWygbBFsMCFsACFgIWygbBFsMCFsECFssGwRbDAhbCAhbKBsEW
wwIWwgIWygbBFsMCFsACFgIWygbBFsMCFsACFswGwRbDAhbAAhbMBsEWwwIWwQI7wDwCO888AjvA
PAbAFsICFgIWAhYCFsoGwRbCAhYCFsACFssGwRbCAhYCFgLBFsoGwRbCAhYCFsACwBbKBsEWwgIW
AhYCwRbKBsEVwgIVAhUCwRXKBsEWwgIWAhYCwRbKBsEWwgIWAhbBAhbKBsEWwgIWAhYCwRbKBsEW
wgIWAhYCwRbKBsEWwwIWwAIWAhbKBsEWwwIWwQIWywbBFsMCFsACwRbKBsEWwwIWwQLAFsoGwRbD
AhbAAsEWygbBFsMCFsACwRbKBsEWwwIWwALBFsoGwRbDAhbBAjvAPAI7wTzJO8E8AjvAPAbAFsIC
FgIWAhYCFsoGwRbCAhYCFsACFssGwRbCAhYCFgIWzAbBFsICFgIWwQIWygbBFsICFgIWwQIWygbB
FcICFQIVwQIVygbBFsICFgIWAhYCFsoGwRbCAhYCFsECFsoGwRbCAhYCFgIWAhbKBsEWwgIWAhbB
AhbKBsEWwwIWwAIWAhbKBsEWwwIWwQIWywbBFsMCFsACFswGwRbDAhbCAhbKBsEWwwIWwgIWygbB
FsMCFsICFsoGwRbDAhbAAhYCFsoGwRbDAhbBAjvAPAI7wDz_dU6XyTz_wsPHwDwCO8A8BsAWwgLB
FgLBFsoGwRbCAsEWAsEWygbBFsICwRYCwRbKBsEWwgLBFgLBFsoGwRbCAsEWwQIWygbBFcICwRUC
wRXKBsEWwgLBFgLBFsoGwRbCAsEWwQIWygbBFsICwRYCwRbKBsEWwgLBFsECFsoGwRbCAsEWAsEW
ygbBFsICwRYCwRbKBsEWwgLBFgLBFsoGwRbCAsEWAsEWygbBFsICwRbBAhbKBsEWwgLBFgLBFsoG
wRbCAsEWAsEWygbBFsICwRbAAjvAPAI7PP51TpfLAol7PAI7wDwGwBbVBsEW1QbBFtUGwRbVBsEW
1QbBFdUGwRbVBsEW1QbBFtUGwRbVBsEW1QbBFtUGwRbVBsEW1QbBFtUGwRbVBsEW1QbBFscCO8A8
Ajs8-nVOl8sCiXs8AjvAPAbAFv39xBXVFv39-f3wAjvAPAI7PP51TpfDP8E7wwKJezwCO8A8BsAW
wgYWBhYGFgIWAhYCFgYWBhbCBsEWwgIWAhYCFgIWAhYCFgIWAhbCBsEWwgIWAhYCFgIWAhYCFgIW
AhbCBsEWwgIWAhYCFgIWAhYCFgIWAhbCBsEWwgIWAhYCFgIWAhYCFgIWAhbCBsEVwgIVAhUCFQIV
AhUCFQIVAhXCBsEWwgIWAhYCFgIWAhYCFgIWBhbCBsEWwgIWAhYCFgIWAhYCFgIWBhbCBsEWwgIW
AhYCFgIWAhYCFgIWBhbCBsEWwgIWAhYCFgIWAhYCFgIWAhbCBsEWwgIWAhYCFgIWAhYCFgIWAhbC
BsEWwgIWAhYCFgIWAhYCFgIWAhbCBsEWwgIWAhYCFgIWAhYCFgIWAhbCBsEWwgIWAhYCFgIWAhYC
FgIWAhbCBsEWwgYWAhYCFgIWAhYCFgIWBhbCBsEWwgYWAhYCFgYWAhYCFgIWBhbCBsEWwgYWAhYC
FgYWAhYCFgIWAhbCBsEWwgIWAhYCwDvAPAI7PP51TpfCP8M7wgKJezwCO8A8BsAWwgYWBhYGFgIW
AhYCFgYWBhbCBsEWwgIWAhYCFgIWAhYCFgIWAhbCBsEWwgIWAhYCFgIWAhYCFgIWAhbCBsEWwgIW
AhYCFgIWAhYCFgIWAhbCBsEWwgIWAhYCFgIWAhYCFgIWAhbCBsEVwgIVAhUCFQIVAhUCFQIVAhXC
BsEWwgIWAhYCFgIWAhYCFgIWBhbCBsEWwgIWAhYCFgIWAhYCFgIWBhbCBsEWwgIWAhYCFgIWAhYC
FgIWBhbCBsEWwgIWAhYCFgIWAhYCFgIWAhbCBsEWwgIWAhYCFgIWAhYCFgIWAhbCBsEWwgIWAhYC
FgIWAhYCFgIWAhbCBsEWwgIWAhYCFgIWAhYCFgIWAhbCBsEWwgIWAhYCFgIWAhYCFgIWAhbCBsEW
wgYWAhYCFgIWAhYCFgIWBhbCBsEWwgYWAhYCFgYWAhYCFgIWBhbCBsEWwgYWAhYCFgYWAhYCFgIW
AhbCBsEWwgIWAhYCwDvAPAI7PP51TpfCP8M7wgKJezwCO8A8BsAW1QbBFtUGwRbVBsEW1QbBFtUG
wRXVBsEW1QbBFtUGwRbVBsEW1QbBFtUGwRbVBsEW1QbBFtUGwRbVBsEW1QbBFtUGwRbHAjvAPAI7
PP51TpfCP8M7wgKJezwCO8A8BsAW1QbBFtUGwRbVBsEW1QbBFtUGwRXVBsEW1QbBFtUGwRbVBsEW
1QbBFtUGwRbVBsEW1QbBFtUGwRbVBsEW1QbBFtUGwRbHAjvAPAI7PP51TpfDP8E7wwKJezwCO8A8
BsAW1QbBFtUGwRbVBsEW1QbBFtUGwRXVBsEW1QbBFtUGwRbVBsEW1QbBFtUGwRbVBsEW1QbBFtUG
wRbVBsEW1QbBFtUGwRbHAjvAPAI7PP51TpfLAol7PAI7wDwGwBbVBsEW1QbBFtUGwRbVBsEW1QbB
FdUGwRbVBsEW1QbBFtUGwRbVBsEW1QbBFtUGwRbVBsEW1QbBFtUGwRbVBsEW1QbBFscCO8A8Ajs8
-nVOl8sCiXs8AjvAPAbAFtUGwRbVBsEW1QbBFtUGwRbVBsEV1QbBFtUGwRbVBsEW1QbBFtUGwRbV
BsEW1QbBFtUGwRbVBsEW1QbBFtUGwRbVBsEWxwI7wDwCO8AC-nVOl8kCiXvAPAI7wDwGwRbTBsMW
0wbDFtMGwxbTBsMW0wbDFdMGwxbTBsMW0wbDFtMGwxbTBsMW0wbDFtMGwxbTBsMW0wbDFtMGwxbT
BsMW0wbDFsYCO8A8AjvBAsk7wTwCO8A8Bv39-f39-f3RAjvAPAI7zzwCO8A8Bv39-f39-f3RAjvA
PAI7zzwCO8A8Bv39-f39-f3RAjvAPAI7wTzJO8E8AjvBAgb9-f39-f39zwI7wTwCO8A8-nVOl8k8
-sLDx8A8AjvCAv39-f39-f3PO8I8Ajs8-nVOl8sCiXs8Ajv9-f39-f391zwCOzz_dU6Xwz87xQKJ
ezwCO-39-f39-f3XPAI7PP51TpfDP8A7xAKJezwCO-39-f39-f3XPAI7PP51TpfDP8E7wwKJezwC
O-39-f39-f3XPAI7PP51TpfDP8I7wgKJezwCO-51Tpfm-sLDxzz9-f39-f3sAjs8-nVOl8M-wTvD
Aol7PAI7-nVOl8ICwTsCwTsCwTsCwTsCwTsCwTsCwDvH-sLDx8A8-nZ3ff39-f39-esCOzz_dU6X
wz-AO8QCiXs8Ajv_dU6XwgI7AjsCOwI7wAI7wQI7wAI7wQI7AjsCOwI7xv7Cw8c8Ff39-f39-ewC
Ozz_dU6Xwz87xQKJezwCO-51TpfCAsE7AsE7wAI7wQI7wALAO8ACwDvAAjsCO8X_wsPHwDwVxxEV
whHAFcARwBURwRXWEcAVEcEVEcEVEcEVEcAV0xHAFRHBFREVwRHBFcARwBURwRXTEcAVwRHAFRHB
FRHBFdcRwRURwBXBEcAVEcEV0xEVERXAEcAVERXBERURFRHBFRHBFc8RwRURwRURwRURwRXAEcAV
EcEV0hHAFREVERXAEcAVEcEVEcAV1BEVwRHBFREVERURwRURFe4RwRXAEcAVERURFcMRwRURwRXB
Ajs8-nVOl8sCiXs8Ajv_dU6XwgI7wQI7AjvAAjvBAjvAAjvBAjsCOwI7AjvF-sLDxzwVyBEVwREV
ERURFREVERURFdURFcERFREVERXBERXBERURFdERFcERFcERFcERFcERFcIRFdQRFREVERURFcAR
FcARFdoRFcARFREVERXCERXUERURFREVERURFcERFREVEcEVERXRERXBERXBERXBERXBERXCERXS
ERXBERURFREVERURFREVERURFdMRFcERFcERFREVERXBERXuERURFREVERURFREVERXBERURFREV
ERXBAjvAAv51TpfJAol7wDwCO-51TpfCAjvBAjsCO8ACO8ECO8ACwTsCOwI7AjsCO8T_wsPHwDwV
yBEVwREVERURFREVEcEV1RHBFRHBFRHAFcARwBXAERURFdERwRURwBXAERXBEcAVwBEVwhEV1BEV
ERURFREVwBEVwBHAFdkRFcARFREVEcEVwBEV1BEVERURFREVERXBERURFREVERURwBXQEcAVwBHA
FcARwBXAEcAVwBEVwhEV0hEVwRHBFREVERURwBXAERURFdMRFcERwBXAERURFRHAFcARFe4RwBXA
ERURFREVERXDERURFREVERXBAjvBAsk7wTwCO-51Tpfj-sLDxzwVyREVwREVERURFREVERXZERUR
FcERFcERFcERFREV0xEVERXBERXBERXBERXCERXUERURFREVERXAERXAERXaERXAERURFcERFcAR
FdQRwRURFREVERXBERURFREVERURFdERFcERFcERFcERFcERFcIRFdIRFcERFREVERURFREVERUR
FREV0xEVwREVwRHBFREVwREV7hEVERURFREVEcEVERXBERURFREVERXBAjvPPAI75TwVyRHBFRHA
FcARwBXAERXXEcAVwBEVwRHBFRHBFRHAFdIRwBXAEcEVEcEVEcEVwBHAFcARFdQRFREVEcAVwREV
wBHBFdcRwRURFREVEcAVwREV1REVwBHAFcARwRXAEcAVERURFRHBFc8RwRURFcERFcERwRXAEcAV
wBEV0xHAFREVERURwBXAERURFRHAFdQRwRURwRXAERXAEcEVEcEV7BEVERURwBXAEcEVwxHBFRHB
FcE80QI85RX9-f39-f3vAAAAAAAAAAE=
:: map/.info.pod
--[[pod,created="2024-03-24 00:48:06",modified="2026-02-16 14:12:04",stored="2024-03-24 00:48:06"]]
:: pal/.info.pod
--[[pod,created="2024-04-10 04:52:51",modified="2026-02-16 14:12:04",stored="2024-04-10 04:52:51"]]
:: pal/0.pal
b64$LS1bW3BvZCxiZ19jb2xvcj0wLGJsYWNrZXN0X2NvbG9yPTAsY3JlYXRlZD0iMjAyNC0wNC0x
MCAwNDo1Mjo1MSIsaGlkZGVuPXtbMF09ZmFsc2UsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRy
dWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSxmYWxzZSx0cnVlLHRydWUsZmFs
c2UsZmFsc2UsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1
ZSx0cnVlLHRydWUsdHJ1ZSxmYWxzZSxmYWxzZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSxm
YWxzZSxmYWxzZSx0cnVlLHRydWUsdHJ1ZX0saGlkZGVuX3RvZ2dsZXM9e1swXT1mYWxzZSxmYWxz
ZSxmYWxzZSxmYWxzZX0saHVlX29mZnNldD0tMC40OTU4NDQ4NzUzNDYyNixpY29uPXVzZXJkYXRh
KCJ1OCIsMTYsMTYsIjAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMTA3MDcwNzA3
MDcwNzA3MDcwNjAxMDAwMDAwMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA2MDYwMTAwMDAwMDAwMDEw
NzA3MDcwNzA3MDcwNzA3MDYwNjA2MDEwMDAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNjA2MDYwNjAx
MDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDcw
NzA3MDcwMTAwMDAwMTA3MDcwNjA2MDEwMTBkMGQwMTAxMDcwNzAxMDAwMDAxMDcwNzA2MDYwMTAx
MGQwZDAxMDEwNzA3MDEwMDAwMDEwNzA3MDEwMTA3MDcwNjA2MGQwZDA3MDcwMTAwMDAwMTA3MDcw
MTAxMDcwNzA2MDYwZDBkMDcwNzAxMDAwMDAxMDcwNzBkMGQwMTAxMGQwZDA2MDYwNzA3MDEwMDAw
MDEwNzA3MGQwZDAxMDEwZDBkMDYwNjA3MDcwMTAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcw
NzAxMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDEwMTAxMDEwMTAxMDEwMTAx
MDEwMTAxMDEwMTAwIiksbG9ja2VkPXtbMF09dHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUs
dHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRy
dWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVl
LHRydWUsdHJ1ZSx0cnVlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlfSxtb2RpZmllZD0iMjAyNi0wMi0x
NSAxNzoyMDoxOCIsb2twYWxfdmVyc2lvbj0iMC4yLjEiLHBpY2tlcnNfbW9kZT0ibGluZWFyX2h1
ZSIscmV2aXNpb249MTYxMyx0ZXN0X2N1YmVfY29sb3JzPXtbMF09ezE1LDMxLDR9LHszMSw0LDIw
fSx7NCwyMCwyMX0sezEwLDksMjV9LHs5LDI1LDI0fSx7OCwyNCwyfSx7MjYsMTEsMjd9LHsxMSwy
NywzfSx7MjcsMywxOX0sezI4LDE3LDE5fSx7MjgsMTIsMTZ9LHsxMiwxNiwxfSx7NiwyOSwxM30s
ezI5LDEzLDE4fSx7MTMsMTgsMX0sezcsMjMsMTR9LHsyMywxNCwxM30sezE0LDMwLDE4fSx7Nyw2
LDIyfSx7NiwyMiw1fSx7MjIsNSwyMX0sezEsMSwxfSx7MSwxLDF9LHsxLDEsMX19LHRlc3RfbW9k
ZT0iY3ViZXMiLHRlc3RfcmFtcF9jb2xvcnM9dXNlcmRhdGEoInU4IiwxMCwyNywiMDAxODA4MTkw
OTBhMWEwYjFiMDAwNjAwMDAwMDAwMDAwMDAwMDMwMDE2MDAwMDAwMDAwMDAwMDAxMzAwMDUwMDAw
MDAwMDAwMDAwMDAxMDAwZDAwMDAwMDAwMDAwMDAwMTAwMDFkMDAwMDAwMDAwMDAwMDAxMTAwMTcw
MDAwMDAwMDAwMDAwMDBjMDAwZTAwMDAwMDAwMDAwMDAwMWMwMDFlMTIwMjE1MTQwNDFmMGYwNzAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDE0MDQxZjBmMDgxODAyMDAwMDE1MDUxNjA2MDcxNzBlMWUw
MDAwMDExMDExMGMxYzFkMGQxMjAwMDAxMzAzMWIwYjFhMGEwOTE5MDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwIiksd2hpdGVzdF9jb2xvcj03XV1sejQA4QEAABUCAAD1BXVzZXJk
YXRhKCJpMzIiLDY0LCIwAQDAMWQyYjUzMDA3ZTI1CADwFzAwODc1MTAwYWI1MjM2MDA1ZjU3NGYw
MGMyYzNjNzAwZmZmMWU4CABAMDA0ZAgAEWE2AGBmZmVjMjcKACBlNDgAQDI5YWQkAGA4Mzc2OWMg
ADE3N2E4AMBjY2FhMDAxYzVlYWMwAPAdYTVhMTAwNzU0ZTk3MDAxMjUzNTkwMDc0MmYyOTAwNDky
ZDM4MDBhMjg4NzlAAPADYWNjNTAwYzMwMDRjMDBlYjZiRgBgOTBlYzQyCgAgYjLAAKA2NGRmZjYw
MGJkiQAAlgBAMGRhYkAAVjg1NmQwAQBAODE0MbAA8A03Mzk0YTAwNDM2MjdkMDA5OTJjNzEwMGNh
MDA3yAAwYTI0DABAMTA2YcgA8B5iYzY2ODMwMGZhOWJiYTAwOWU5OTU0MDBmN2YwYTIwMDVjOTU2
MjAwOTNlODlYAPAFODkzOTEwMDg0ZGVkYjAwOTg2ZWJYAcBhYTllYTAwYWQ3NzQgATAxYWGgAEA1
MTg5WAB1ODRjMmY5MAEAEDQCAHA0MDA3Njc3qABBZGFkYVAA8gZmYTBhNjAwMWUzNzNjMDAzZjU2
NWGoASYwMAgAgDE2MTYxNiIp
:: sfx/.info.pod
--[[pod,created="2024-03-24 00:48:06",modified="2026-02-16 14:12:04",stored="2024-03-24 00:48:06"]]
:: src/.info.pod
--[[pod,created="2024-04-07 08:14:00",modified="2026-02-16 14:12:04",stored="2024-04-07 08:14:00"]]
:: src/sfx/.info.pod
--[[pod,created="2026-02-01 20:27:30",modified="2026-02-16 14:12:04"]]
:: src/ui/.info.pod
--[[pod,created="2026-02-01 17:54:12",modified="2026-02-16 14:12:04"]]
:: src/wavetables/.info.pod
--[[pod,created="2026-01-25 09:38:05",modified="2026-02-16 14:12:04"]]
:: [eoc]
