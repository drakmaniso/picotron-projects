picotron cartridge // www.picotron.net
version 2

:: fonts/
:: gfx/
:: map/
:: pal/
:: sfx/
:: src/
:: src/wavetables/
:: main.lua
--[[pod_format="raw",created="2024-03-24 00:48:06",modified="2026-01-30 18:48:07",revision=20148]]
include "src/lune.lua"
--include "src/misc.lua"
include "src/waves.lua"
local app = require "src/app.lua"
local sfx = require "src/sfx.lua"
local file = require "src/file.lua"
local selection = require "src/selection.lua"
local settings = require "src/settings.lua"
local undo = require "src/undo.lua"
local ui = require "src/ui.lua"
local ui_routing = require "src/ui_routing.lua"
local ui_settings = require "src/ui_settings.lua"
local ui_synth = require "src/ui_synth.lua"
local ui_tracker = require "src/ui_tracker.lua"
local ui_visual = require "src/ui_visual.lua"


function _init()
	window {
		tabbed = true,
--		icon = --[[pod_type="gfx"]]unpod("b64:bHo0AB4AAAAcAAAA8A1weHUAQyAICATAF0AHEBcgBxAXEAcgFxAHQBfA")
		icon = --[[pod_type="gfx"]]unpod("b64:bHo0AB4AAAAcAAAA8A1weHUAQyAICAQwB2AXUAcAB0AHAAcgJzA3QBew")
	}

	wrangle_working_file(
		file.save,
		file.load,
		file.default_filename
	)
		
	on_event("drop_items", file.handle_drop_items)
	on_event("resize", function(msg) app.refresh_gui = true end)
	on_event("gained_focus", function(msg) app.window_focused = true end)
	on_event("lost_focus", function(msg) app.window_focused = false end)

	menuitem {
		id = "export",
		label = "\^:0000000000000000 Export Instruments",
		action =
			function()
				ui.chooser (
					{
						path = "/ram/cart/sfx/",
						intention = "select_file",
						title = "Export Instruments",
						prompt = "Export into:",
						verb = "Export",
						workspace = "current",
					},
					function(msg)
						file.export_into(msg.filename)
					end
				)
			end,
	}	
	menuitem { divider = true, id = "settings_divider", label = "" }
	menuitem {
		id = "settings",
		label = "\^:0000000000000000 Settings",
		action = function() ui_settings.open() end,
	}	
		
	settings.load()
	
	poke(0x4000, get(fetch("fonts/p8_mod.font")))
	
	poke4(0x5000, get(fetch("pal/0.pal")))
	
	for i = 0, 255 do
		local sprite = userdata("u8", 7, 5)
		set_draw_target(sprite)
		print(string.format("%02x", i), 0, 0, 7)
		set_spr(256 + i, sprite)
	end
	set_draw_target()
	
	--app.node = nil
	music(-1)
	selection.set(0, 0, selection.note)
	undo.init()
end


local previously_focused = nil


function _update()
	-- Keyboard Focus
	local currently_focused = ui.head() and ui.head():get_keyboard_focus_element()
	if currently_focused ~= previously_focused then
		ui_visual.close()
	end
	previously_focused = currently_focused
	-- GUI Refresh
	if app.refresh_gui then
		generate_gui()
		app.refresh_gui = false
	end
	ui.head():update_all()
	-- Keys
	if key("ctrl") then
		if keyp("z") then
			if key("shift") then
				undo.redo()
			else
				undo.undo()
			end
		end
		if keyp("y") then
			undo.redo()
		end
	end
end


local fps_prev = 0
function _draw()
	ui.head():draw_all()
	--print(string.format("\014% 3.0f", stat(0) / (1024 * 1024)) .. "MB", 459, 246, 57)
	fps = flr(0.5 + stat(1) * 100.0)
	print(string.format("%3.0f%%", max(fps, prev_fps)),
		463, true and 4 or 250, 57)
	prev_fps = fps
end


function generate_gui()
	ui.create_head()
	local width <const> = get_display():width()
	local height <const> = get_display():height()
	if app.view == "tracker" then
		ui_tracker.attach(ui.head(), { x = 0, y = 0, width = width, height = height })
	elseif app.view == "synth" then
		ui_synth.attach(ui.head(), { x = 0, y = 0, width = width, height = height })
	end
end


----------------------------------------------------------------------------------------------------
-- View Selector
----------------------------------------------------------------------------------------------------


function attach_view_selector(parent, el)
	el.width = 22
	el.height = 34
	el.cursor = "pointer"
	parent:attach(el)
	
	function el:draw(msg)
		--rrectfill(0, 0, self.width, self.height, 0, 47)
		local clicked = msg.mb == 1
		if clicked and false then
			rrectfill(0, 0, self.width, self.height, 0, 58)
		end
		pal(7, app.view == "tracker" and 59 or 58)
		pal(57, app.view == "tracker" and 7 or 57)
		spr(1, 3, 0)
		pal(7, app.view == "synth" and 59 or 58)
		pal(57, app.view == "synth" and 7 or 57)
		spr(3, 3, 18)
		pal(7, 7)
		pal(57, 57)
	end
	
	function el:click(msg)
		if app.view == "synth" then
			app.view = "tracker"
		else
			app.view = "synth"
		end
		app.refresh_gui = true
	end
	
	return el
end


----------------------------------------------------------------------------------------------------
-- Octave Selector
----------------------------------------------------------------------------------------------------


function attach_octave_selector(parent, el)
	el.width = 22
	el.height = 10
	el.cursor = get_spr(50)
	parent:attach(el)
	
	el.drag_start = nil

	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 47)
		-- Base Note
		local note = app.base_note % 12
		local octave = app.base_note \ 12
		local is_sharp = (note == 1) or (note == 3) or (note == 6)
			or (note == 8) or (note == 10)
		local ox_note <const> = is_sharp and 3 or 3 + 4
		local fg <const> = 5
		pal(7, self.dragged and 7 or fg)
		spr(84 + note, ox_note, 2)
		local x_oct = ox_note + (is_sharp and 12 or 6)
		pal(7, 7)
		print(
			"\014" .. string.format("%1x", octave),
			x_oct, 2 + 1,
			self.dragged and 7 or fg
		)
	end	
	
	function el:click(msg)
		self.dragged = true
		self.cursor = 0
	end
	
	function el:drag(msg)
		local delta = ui.mouselock(0.125)
		app.base_note = mid(0, app.base_note - (12 * delta), 120)
	end
	
	function el:release(msg)
		ui.mouseunlock()
		self.cursor = get_spr(50)
		self.dragged = nil
	end

	function el:doubleclick(msg)
		app.base_note = 48
	end
	
	return el
end


----------------------------------------------------------------------------------------------------
-- Instrument Selector
----------------------------------------------------------------------------------------------------


function attach_instrument_selector(parent, el)
	el.width = 22
	el.height = 16
	el.cursor = get_spr(53)
	parent:attach(el)
	
	el.drag_start = nil

	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 47)
		print("\014inst", 4, 1, 58)
		if self:has_keyboard_focus() then
			rrectfill(6, 7, 11, 9, 0, 59)
			print(self.str or "", 8, 9, 7)
		else
			local sprite = app.instrument_disabled and 64 or (256 + app.instrument)
			pal(7, self.dragged and 7 or 44)
			spr(sprite, 8, 9)
			pal(7, 7)
		end
	end	

	function el:update()
		if self:has_keyboard_focus() then
			while peektext() do
				if #self.str < 2 then
					self.str = self.str .. readtext()
				else
					readtext()
				end
			end

			if keyp("backspace") then
				self.str = sub(self.str, 1, -2)
			end
			
			if keyp("enter") or #self.str == 2 then
				local val = tonumber(self.str, 16)
				if val then
					app.instrument = mid(val, 0, 0xff)
				end
				self:set_keyboard_focus(false)
				app.was_in_text_field = true
			end
		end
	end
	
	function el:click(msg)
		-- TODO: replace with pull-down menus
		self.dragged = true
		self.cursor = 0
	end
	
	function el:drag(msg)
		if self.dragged then
			local delta = ui.mouselock(0.125)
			-- TODO: allow "ff"
			local instrument = mid(0, app.instrument - delta, 0xff)
			if instrument ~= app.instrument then
				app.instrument = instrument
				app.node = 0
				-- TODO: cannot refresh gui in real time (lose mouselock)
				-- instead, recreate just the router?
				self.need_refresh_gui = true
				ui_routing.clear_placement_buttons()
			end
		end
	end
	
	function el:tap(msg)
		if msg.last_mb == 1 then
			self:set_keyboard_focus(true)
			readtext(true)
			self.str = ""
		elseif msg.last_mb == 2 then
			app.instrument_disabled = not app.instrument_disabled
		end
	end
	
	function el:release(msg)
		if self.need_refresh_gui then
			app.refresh_gui = true
		end
		ui.mouseunlock()
		self.cursor = get_spr(53)
		self.dragged = nil
	end

	function el:doubleclick(msg)
		app.instrument = 0
	end
	
	function el:mousewheel(msg)
		-- TODO: allow "ff"
		app.instrument = mid(app.instrument + msg.wheel_y, 0, 0xff)
		-- TODO: only refresh router
		app.refresh_gui = true
	end
	
	return el
end


----------------------------------------------------------------------------------------------------
-- Volume Selector
----------------------------------------------------------------------------------------------------


function attach_volume_selector(parent, el)
	el.width = 22
	el.height = 16
	el.cursor = get_spr(53)
	parent:attach(el)
	
	el.drag_start = nil

	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 47)
		print("\014vol", 6, 1, 58)
		if self:has_keyboard_focus() then
			rrectfill(6, 7, 11, 9, 0, 59)
			print(self.str or "", 8, 9, 7)
		else
			local sprite = app.base_volume_disabled and 64 or (256 + app.base_volume)
			pal(7, self.dragged and 7 or 46)
			spr(sprite, 8, 9)
			pal(7, 7)
		end
	end	

	function el:update()
		if self:has_keyboard_focus() then
			while peektext() do
				if #self.str < 2 then
					self.str = self.str .. readtext()
				else
					readtext()
				end
			end

			if keyp("backspace") then
				self.str = sub(self.str, 1, -2)
			end
			
			if keyp("enter") or #self.str == 2 then
				local val = tonumber(self.str, 16)
				if val then
					app.base_volume = mid(val, 0, 0xff)
				end
				self:set_keyboard_focus(false)
				app.was_in_text_field = true
			end
		end
	end
	
	function el:click(msg)
		self.dragged = true
		self.cursor = 0
	end
	
	function el:drag(msg)
		if self.dragged then
			local delta = ui.mouselock(0.125)
			app.base_volume = mid(0, app.base_volume - delta, 0xff)
		end
	end
	
	function el:tap(msg)
		if msg.last_mb == 1 then
			self:set_keyboard_focus(true)
			readtext(true)
			self.str = ""
		elseif msg.last_mb == 2 then
			app.base_volume_disabled = not app.base_volume_disabled
		end
	end
	
	function el:release(msg)
		if self.need_refresh_gui then
			readtext(true)
			app.refresh_gui = true
		end
		ui.mouseunlock()
		self.cursor = get_spr(53)
		self.dragged = nil
	end

	function el:doubleclick(msg)
		app.instrument = 0
	end
	
	function el:mousewheel(msg)
		app.base_volume = mid(app.base_volume + msg.wheel_y, 0, 0xff)
	end
	
	return el
end


----------------------------------------------------------------------------------------------------
-- Step Selector
----------------------------------------------------------------------------------------------------


function attach_step_selector(parent, el)
	el.width = 22
	el.height = 16
	el.cursor = get_spr(53)
	parent:attach(el)
	
	el.drag_start = nil

	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 47)
		print("\014step", 4, 1, 58)
		if self:has_keyboard_focus() then
			rrectfill(6, 7, 11, 9, 0, 59)
			print(self.str or "", 8, 9, 7)
		else
			local str = string.format("%02d", app.jump_step)
			print(str, 8, 9, self.dragged and 7 or 5)
		end
	end	

	function el:update()
		if self:has_keyboard_focus() then
			while peektext() do
				if #self.str < 2 then
					self.str = self.str .. readtext()
				else
					readtext()
				end
			end

			if keyp("backspace") then
				self.str = sub(self.str, 1, -2)
			end
			
			if keyp("enter") or #self.str == 2 then
				local val = tonumber(self.str)
				if val then
					app.jump_step = mid(math.floor(val), 0, 99)
				end
				self:set_keyboard_focus(false)
				app.was_in_text_field = true
			end
		end
	end
	
	function el:click(msg)
		self.dragged = true
		self.cursor = 0
	end
	
	function el:drag(msg)
		if self.dragged then
			local delta = ui.mouselock(0.125)
			local val = math.floor(app.jump_step - delta)
			app.jump_step = mid(val, 0, 99)
		end
	end
	
	function el:tap(msg)
		self:set_keyboard_focus(true)
		readtext(true)
		self.str = ""
	end
	
	function el:release(msg)
		if self.need_refresh_gui then
			app.refresh_gui = true
		end
		ui.mouseunlock()
		self.cursor = get_spr(53)
		self.dragged = nil
	end

	function el:doubleclick(msg)
		app.instrument = 0
	end
	
	function el:mousewheel(msg)
		app.jump_step = mid(app.jump_step + msg.wheel_y, 0, 99)
	end
	
	return el
end

:: manual.txt
--[[pod_format="raw",created="2024-04-14 09:49:39",modified="2026-01-30 18:48:07",revision=9875]]
# WaveMaker

## Tracker

### Multi-cursors

### Keybindings

Note: not everything is implemented yet.

```
  
  TAB: toggle edit mode
  
  SPACE: play from current pattern (don't follow playhed)
  S-SPACE: play from current pattern (follow playhead)
  C-SPACE: play from current bar (don't follow playhed)
  A-SPACE: play from current beat??? (don't follow playhed)
  
  *** Vertical Movement ***
  
  DOWN: move to next step
  UP: move to previous step
  ENTER: play current note and move to next step
  C-ENTER: play current note without moving
  S-ENTER: ???
  C-S-ENTER: ???
  
  C-DOWN: move to next bar
  C-UP: move to previous bar
  
  PAGEDOWN: move to next pattern
  PAGEUP: move to previous pattern
  
  HOME: move to start of the track
  END: move to end of the track
  C-HOME: move to start of the bar (or the song?)
  C-END: move to end of the bar (or the song?)
  
  *** Horizontal Movement ***
  
  C-RIGHT: move to next channel
  C-LEFT: move to previous channel
```


## Synth
:: src/app.lua
--[[pod_format="raw",created="2024-04-12 08:11:00",modified="2026-01-30 18:48:07",revision=16953]]
local settings = require "src/settings.lua"
local sfx = require "src/sfx.lua"


local app = {}


----------------------------------------------------------------------------------------------------
-- Transient State
----------------------------------------------------------------------------------------------------


app.window_focused = false

app.refresh_gui = true

app.is_editing = false

app.was_in_text_field = false
	-- used to stop interference between field entry
	-- and playing notes (eg when entering "2d" in
	-- default volume field)

app.follow_playhead = false


----------------------------------------------------------------------------------------------------
-- Global State
----------------------------------------------------------------------------------------------------


-- Shared State

app.pattern = 0
app.track = 0
app.instrument = 0

-- Synth State

app.node = nil -- selected in instrument editor
app.wt = 0 -- selected in instrument editor

-- Tracker State

app.base_note = 48
app.base_volume = 0x2f
app.jump_step = 1

-- UI State

app.view = "tracker" -- "tracker" or "synth"
app.detail = false
app.track_headers_visible = true
app.inspector_visible = false
app.height_row = 8
app.env_advanced = { [0] = false, false, false, false }


----------------------------------------------------------------------------------------------------
-- Constants
----------------------------------------------------------------------------------------------------


-- Colors

app.editor_bg = 62

-- Layout constants

app.height_header = 13
app.width_column = 57 -- 57
app.height_inspector = 27

app.synth_width = 83
app.synth_height = 72
app.synth_gap = 5
app.mod_width = 57
app.mod_height = app.synth_height


----------------------------------------------------------------------------------------------------
-- Helpers
----------------------------------------------------------------------------------------------------


function app.play_or_pause(mode)
	if sfx.music_is_playing() then
		music(-1)
		app.follow_playhead = false
	else
		if mode == "follow_playhead" then
			app.follow_playhead = true
		end
		music(app.pattern)
	end
end


----------------------------------------------------------------------------------------------------
-- Helpers
----------------------------------------------------------------------------------------------------

local last_pitch = nil
function app.pitched_key()
	if app.was_in_text_field then
		last_pitch = nil
		return nil, false
	end
	if key("ctrl") or key("alt") then
		last_pitch = nil
		return nil, false
	end
	local pitch = nil
	for i = 1, #settings.keys.pitched do
		local offset = settings.keys.pitched[i].offset
		for j = 0, #settings.keys.pitched[i] do
			local k = settings.keys.pitched[i][j]
			if key(k, true) then
				pitch = app.base_note + offset + j
				pitch += key("shift") and 12 or 0
				pitch = mid(pitch, 0, 0xfe)
			end
		end
	end
	local is_new = pitch and (pitch ~= last_pitch)
	last_pitch = pitch
	return pitch, is_new
end


function app.decimal_digit_key()
	if keyp("0") then return 0, "0"
	elseif keyp("1") then return 1, "1"
	elseif keyp("2") then return 2, "2"
	elseif keyp("3") then return 3, "3"
	elseif keyp("4") then return 4, "4"
	elseif keyp("5") then return 5, "5"
	elseif keyp("6") then return 6, "6"
	elseif keyp("7") then return 7, "7"
	elseif keyp("8") then return 8, "8"
	elseif keyp("9") then return 9, "9"
	end
	return nil
end


function app.hex_digit_key()
	if keyp("0") then return 0, "0"
	elseif keyp("1") then return 1, "1"
	elseif keyp("2") then return 2, "2"
	elseif keyp("3") then return 3, "3"
	elseif keyp("4") then return 4, "4"
	elseif keyp("5") then return 5, "5"
	elseif keyp("6") then return 6, "6"
	elseif keyp("7") then return 7, "7"
	elseif keyp("8") then return 8, "8"
	elseif keyp("9") then return 9, "9"
	elseif keyp("a") then return 0xa, "a"
	elseif keyp("b") then return 0xb, "b"
	elseif keyp("c") then return 0xc, "c"
	elseif keyp("d") then return 0xd, "d"
	elseif keyp("e") then return 0xe, "e"
	elseif keyp("f") then return 0xf, "f"
	end
	return nil
end


app.is_valid_fx = {
	["0"] = "\0", ["."] = "\0",
	["1"] = "s", s="s",
	["2"] = "v", v="v",
	["3"] = "-", ["-"] = "-", 
	["4"] = "<", ["<"] = "<", 
	["5"] = ">", [">"] = ">", 
	["6"] = "a", a = "a", A = "A",
	["7"] = "b", b = "b", B = "B",
	["8"] = "t", ["t"] = "t",
	["9"] = "+", ["+"] = "+",
	w = "w", 
	r = "r", c = "c", d = "d", 
	p = "p",
	f = "f", -- fade (0.2.1c)
	m = "m", M = "M", -- arp spd 1
	n = "n", N = "N", -- arp spd 2
	o = "o", O = "O" -- ornament (2-note arp w/ spd parameter)
}


function app.fx_key()
	for k, _ in pairs(app.is_valid_fx) do
		if keyp(k) then
			return k
		end
	end
	return nil
end


return app


:: src/file.lua
--[[pod_format="raw",created="2024-04-07 08:14:09",modified="2026-01-30 18:48:07",revision=11332]]
local app = require "src/app.lua"
local sfx = require "src/sfx.lua"


local file = {}


file.default_filename = "/ram/cart/sfx/0.sfxi"


-- `file.save` and `file.load` are direct copies of `sfx.p64` code to
-- ensure perfect compatibility.


function file.save()
	local ud = userdata("u8", 0x40000)
	for i=0,0x3f do
		set(ud, i * 0x1000, peek(0x30000 + i * 0x1000, 0x1000))
	end
	return ud
end


function file.load(ud)
	if (type(ud)~="userdata") then
		init_data()
	else
		for i=0,0x3f do
			poke(0x30000 + i * 0x1000, get(ud, i * 0x1000, 0x1000))
		end
	end
	-- TODO
	app.instrument = 0
	app.node = 0
	app.refresh_gui = true
---			init_undo()
end


function file.export_into(filename)
	local target = fetch(filename)
	if type(target) ~= "userdata" then
		notify("unable to read file " .. pod(filename))
		return
	end
	
	-- TODO: only copy existing instruments
	target:peek(0x040000, 0x010000, 0xffff)
	-- TODO: where to put the wavetables?
	-- target:peek(0xf00000, 0xed0000, 0xfffff)
	
	store(filename, target)
	notify("all instruments exported into " .. pod(filename))
end


function file.handle_drop_items(msg)
	for i = 1, #msg.items do
		local item = msg.items[i]
		if item.pod_type == "file_reference" and item.attrib == "file" then
			local ext = item.fullpath:ext()
			if ext == "sfx" then
				local metadata = fetch_metadata(item.fullpath) or {} -- TODO
				send_message(pid(), {event = "open_file", filename = item.fullpath})
			else
				notify("wrong file extension")
				-- TODO: dialog for unknown file extensions?
				--current_filename = item.fullpath
				--send_message(pid(), {event = "open_file", filename = item.fullpath})
			end
		end
	end
end


-- Initialisation ----------------------------------------------------------------


function init_track(track)
	local size <const> = 64 -- TODO: support other sizes
	sfx.set_track_size(track, size)
	sfx.set_track_speed(track, 16)
	sfx.set_track_loop0(track, 0)
	sfx.set_track_loop1(track, 0)
	sfx.set_track_delay(track, 0)
	sfx.set_track_flags(track, 0)
	sfx.set_track_unused(track, 0)
	for step = 0, size - 1 do
		sfx.set_track_pitch(track, step, 0xff)
		sfx.set_track_instrument(track, step, 0xff)
		sfx.set_track_volume(track, step, 0xff)
		sfx.set_track_fx(track, step, 0x0)
		sfx.set_track_fx_params(track, step, 0x0)
	end
end


-- copied from "/system/apps/sfx.lua" in Picotron 0.2.2b

function __init_track(addr)
--	printh("init_track "..addr)
	poke2(addr, 64) -- len
	poke(addr+2,16) -- spd
	poke(addr+3,0)  -- loop0
	poke(addr+4,0)  -- loop1
	poke(addr+5,0)  -- delay
	poke(addr+6,0)  -- flags (0x1 mute)
	poke(addr+7,0)  -- unused
	
	-- pitch, inst, vol: not set (0xff)
	memset(addr+8, 0xff, 64*3)
	
	-- fx, fx_p: clear
	memset(addr+8+64*3, 0x0, 64*2)
end

function clear_pattern(i)
	local addr = 0x30100 + i*20
	memset(addr,0,20)
end

function clear_instrument(i)
	local addr = 0x40000 + i * 0x200
	
	memset(addr, 0, 0x200)
	
	-- node 0: root
	poke(addr + (0 * 32), -- node 0
	
			0,    -- parent (0x7)  op (0xf0)
			1,    -- kind (0x0f): 1 root  kind_p (0xf0): 0  -- wavetable_index
			0,    -- flags
			0,    -- unused extra
				
			-- MVALs:  kind/flags,  val0, val1, envelope_index
			
			0x2|0x4,0x30,0,0,  -- volume: mult. 0x40 is max (-0x40 to invert, 0x7f to overamp)
			0x1,0,0,0,     -- pan:   add. center
			0x1,0,0,0,     -- tune: +0 -- 0,48,0,0 absolute for middle c (c4) 261.6 Hz
			0x1,0,0,0,     -- bend: none
			-- following shouldn't be in root
			0x0,0,0,0,     -- wave: use wave 0 
			0x0,0,0,0      -- phase 
	)
	
	
	-- node 1: sine
	poke(addr + (1 * 32), -- instrument 0, node 1
	
			0,    -- parent (0x7)  op (0xf0)
			2,    -- kind (0x0f): 2 osc  kind_p (0xf0): 0  -- wavetable_index
			0,    -- flags
			0,    -- unused extra
				
			-- MVALs:  kind/flags,  val0, val1, envelope_index
			
			0x2,0x30,0,0,  -- volume: mult. 0x40 is max (-0x40 to invert, 0x7f to overamp)
			0x1,0,0,0,     -- pan:   add. center
			0x21,0,0,0,    -- tune: +0 -- 0,48,0,0 absolute for middle c (c4) 261.6 Hz
			               -- tune is quantized to semitones with 0x20
			0x1,0,0,0,     -- bend: none
			0x0,0x40,0,0,  -- wave: triangle
			0x0,0,0,0      -- phase 
	)
	
	
	-- wavetables
	poke(addr + 0x1e0,
		0x00, -- address (low)  in 256 byte increments
		0xf8, -- address (high) in 64k increments
		0x0a, -- samples (1 << n) 1024
		0xff,  -- wt_height 256(0); wave mval points at one of the entries
		
		-- white noise
		0x80,
		0xf7,
		0x0d, -- samples (1 << n) 8192
		0x01
	)

	-- envelope 0 inst 1
	
	poke(addr + 0x100,
		0,0,0,0, 0,0,0,0,
		0,40,255,0 -- adsr
	)
end


function init_data()

	-- use 256k from 0x30000
	-- gives 399 SFX and managemable size for undo state comparisons
	-- if change this need, to adjust undo stack size and loader/saver
	
	memset(0x30000, 0, 0x40000)
	

	-- index (0x30000)
	
	-- first 3 values are almost metadata only -- not currently
	-- acted on anywhere. perhaps useful in future for deciding
	-- scope of copy/paste, and gui cues, but can be calculated
	-- from content.
	
	poke2(0x30000,
		64,  -- num_instruments
		512, -- num_tracks (64 patterns * 8 channels for default indexing)
		64,  -- num_patterns
		-- flags: 0x1 use default track indexing (base+0x20000, increments of 328 bytes)
		0x1
	)
	poke4(0x30010,
		0x10000, -- insts_addr      (I32)    relative address of instruments
		0x20000, -- tracks_addr     (I32)    relative address of track index
		0,       -- patterns_addr   (I32)    relative address of pattern data
		0        -- unused          (I32)    should be 0
	)
	poke2(0x30020,
		0,  -- tick len (0 for default -- custom vals not supported yet)
		64, -- default track length
		16 -- default track spd
	)
	
	-- default track speed (+3 unused)
	poke(0x30026, 16, 0, 0, 0) 
	
	-- pattern data: first 16 patterns
	-- want to keep default sfx file quite tiny
	-- .. should be ok to save a whole .sfx for just one inst / experiment
	-- later: interface to generate more default patterns
	
	for pp = 0,3 do
		local addr = 0x30100 + pp * 20
		for i = 0, 7 do
			poke(addr+i, pp*8 + i)
		end
		poke(addr+8, 0x0)  -- flow flags
		poke(addr+9, 0xff) -- channel mask -- 8 channels
		poke(addr+10, 0,0) -- length (I16)
		
	end
	
	
	----------------------------------------------------------------------------
	-- single instrument at 0x40000 (instrument 0)
	
	clear_instrument(0)
	
	-- copy default instrument to 1..31
	for i=1,31 do
		memcpy(0x40000 + 0x200*i, 0x40000, 0x200)
	end
	
	
	--------------------------------------------------
	-- Track Data  0x50000
	--------------------------------------------------
	
	-- Default track size is 5 * 64 rows + 8 = 328 bytes
	
	-- header (8)
	
	for track = 0, 7 do
--		init_track(0x50000 + 328 * track)
		init_track(track)
	end
	
	-- copy to other tracks: 128k worth
	-- ** only first 399 are saved / undoable (0x20000\328) **
	-- 384 used in tracker
	--[[
	for i=1,398 do
		memcpy(0x50000 + i*328, 0x50000, 328)
	end
	]]

end


return file
:: src/lune.lua
--[[pod_format="raw",created="2025-03-19 09:08:58",modified="2026-01-30 18:48:07",revision=11684]]
----------------------------------------------------------------------------------------------------
-- Logging and Errors
----------------------------------------------------------------------------------------------------


if env().argv[0] == "/system/apps/terminal.lua" then
	function log(str)
		local path = debug.getinfo(2).source
		if path[1] == "@" then path = path:sub(2, -1) end
		local line = debug.getinfo(2).currentline
		printh(path .. ":" .. line .. ": " .. (str or ""))
	end
else
	function log(_str) end
end


function error(msg, level, title)
	level = (level or 1) + 1
	local path = debug.getinfo(level).source
	local line = debug.getinfo(level).currentline
	local str = sub(path, 2) .. ":" .. string.format("%d", line) .. ": " .. msg
	send_message(3, { event = "report_error", content = "*" .. (title or "error") })
	send_message(3, { event = "report_error", content = str })
	send_message(3, { event = "report_error", content = debug.traceback("", level) })
end


function panic(msg, level, title)
	level = (level or 1) + 1
	error(msg, level, title or "panic")
	stop()
end


----------------------------------------------------------------------------------------------------
-- Require
----------------------------------------------------------------------------------------------------


_modules = {}


-- A 'require' function similar to standard Lua.
-- Idea from elgopher on the BBS
function require(name)
	if (_modules == nil) _modules = {}

	local cached = _modules[name]
	if (cached) return cached

	local filename = fullpath(name)
	local src = fetch(filename)
	if (type(src) != "string") panic("could not include " .. filename, 2)

	-- https://www.lua.org/manual/5.4/manual.html#pdf-load
	-- chunk name (for error reporting)
	-- mode ("t" for text only -- no binary chunk loading)
	-- _ENV upvalue
	-- @ is a special character that tells debugger the string is a filename
	local func, err = load(src, "@" .. filename, "t", _ENV)
	if (not func) panic("\n"..tostr(err), 2, "Syntax error:")

	local module = func()
	_modules[name] = module

	return module
end


----------------------------------------------------------------------------------------------------
-- Structure
----------------------------------------------------------------------------------------------------


function structure(meta)
	meta.__index = meta
	meta.type = meta
	setmetatable(
		meta,
		{
			__call =
				function(mt, instance)
					setmetatable(instance, mt)
					return instance
				end,
		}
	)
	return meta
end

:: src/misc.lua
--[[pod_format="raw",created="2024-04-07 07:42:45",modified="2026-01-30 18:48:07",revision=10977]]
-- Table utility functions --------------------------------------------------------


function table_deep_copy(t, already)
	if (not already) already = {}
	if type(t) == "table" then
		if already and already[t] then
			return already[t]
		end
		local new = {}
		already[t] = new
		for k, v in pairs(t) do
			new[k] = table_deep_copy(v, already)
		end
		return new
	else
		return t
	end
end


function tostrrec(t)
	if type(t) != "table" then
		return tostr(t)
	end
	
	local s = nil
	for k, v in pairs(t) do
		if not(s) then
			s = "{ "
		else
			s ..= ", "
		end
		s ..= tostr(k) .. " = " .. tostrrec(v)
	end
	s ..= " }"

	return s
end


-- Char utilities -----------------------------------------------------------------


function keyp_num()
	if (keyp("9")) return 9
	if (keyp("8")) return 8
	if (keyp("7")) return 7
	if (keyp("6")) return 6
	if (keyp("5")) return 5
	if (keyp("4")) return 4
	if (keyp("3")) return 3
	if (keyp("2")) return 2
	if (keyp("1")) return 1
	if (keyp("0")) return 0
	return nil
end


function keyp_hex()
	if (keyp("f")) return 0xf
	if (keyp("e")) return 0xe
	if (keyp("d")) return 0xd
	if (keyp("c")) return 0xc
	if (keyp("b")) return 0xb
	if (keyp("a")) return 0xa
	if (keyp("9")) return 0x9
	if (keyp("8")) return 0x8
	if (keyp("7")) return 0x7
	if (keyp("6")) return 0x6
	if (keyp("5")) return 0x5
	if (keyp("4")) return 0x4
	if (keyp("3")) return 0x3
	if (keyp("2")) return 0x2
	if (keyp("1")) return 0x1
	if (keyp("0")) return 0x0
	return nil
end

function is_num_char(c)
	if (not c) return
	return ("0" <= c) and (c <= "9")
end


function is_hexa_char(c)
	if (not c) return
	local is_num = ("0" <= c) and (c <= "9")
	local is_hex_alpha = ("a" <= c) and (c <= "f")
	return is_num or is_hex_alpha
end


function p8_centered_print(s, x, y, col)
	local count = #s
	print(s, x - ((count * 4) \ 2), y, col)
end



-- Drawing -------------------------------------------------------------------------


-- From Sophie on the discord
function get_drawspace()
    return {
        cam_x=peek4(0x5510),
        cam_y=peek4(0x5514),
        clip_l=peek2(0x5528),
        clip_t=peek2(0x552a),
        clip_r=peek2(0x552c),
        clip_b=peek2(0x552e),
    }
end


function set_drawspace(drawspace)
    poke4(0x5510,drawspace.cam_x)
    poke4(0x5514,drawspace.cam_y)
    poke2(0x5528,drawspace.clip_l)
    poke2(0x552a,drawspace.clip_t)
    poke2(0x552c,drawspace.clip_r)
    poke2(0x552e,drawspace.clip_b)
end

:: src/selection.lua
--[[pod_format="raw",created="2026-01-27 06:45:26",modified="2026-01-30 18:48:07",revision=6090]]
local app = require "src/app.lua"
local sfx = require "src/sfx.lua"


local selection = {}


local channels = {}
local steps = {}
local parts = 0x0


-- Parts
selection.note = 1 << 0
selection.octave = 1 << 1
selection.instrument = 1 << 2
selection.volume = 1 << 3
selection.fx = 1 << 4


local parts_before <const> = {
	[selection.note] = selection.note,
	[selection.octave] = selection.note | selection.octave,
	[selection.instrument] = selection.note | selection.octave
		| selection.instrument,
	[selection.volume] = selection.note | selection.octave
		| selection.instrument | selection.volume,
	[selection.fx] = selection.note | selection.octave
		| selection.instrument | selection.volume | selection.fx,
}
local parts_after <const> = {
	[selection.note] = selection.note | selection.octave
		| selection.instrument | selection.volume | selection.fx,
	[selection.octave] = selection.octave | selection.instrument
		| selection.volume | selection.fx,
	[selection.instrument] = selection.instrument | selection.volume
		| selection.fx,
	[selection.volume] = selection.volume | selection.fx,
	[selection.fx] = selection.fx,
}


----------------------------------------------------------------------------------------------------
-- Creation
----------------------------------------------------------------------------------------------------


function selection.set(channel, step, part)
	if channel then
		channels = { [channel] = true }
	end
	if step then
		steps = { [step] = true }
	end
	if part then
		parts = part
	end
end


function selection.extend(channel, step, part)
	if channel then
		channels[channel] = true
	end
	if step then
		steps[step] = true
	end
	if part then
		parts = parts | part
	end
end


function selection.set_anchor(channel, step, part, mode)
	if mode == "extend" then
		channels_to_extend = channels
		steps_to_extend = steps
		parts_to_extend = parts
	else
		selection.set(channel, step, part)
		channels_to_extend = {}
		steps_to_extend = {}
		parts_to_extend = 0
	end
	anchor_channel = channel
	anchor_step = step
	anchor_part = part
end


function selection.set_anchor_extend(channel, step, part)
	selection.set_anchor(channel, step, part, "extend")
end


function selection.set_from_anchor_to(channel, step, part)
	-- Channels
	if anchor_channel then
		channels = {}
		for k, _ in pairs(channels_to_extend) do channels[k] = true end
		local from = min(channel, anchor_channel)
		local to = max(channel, anchor_channel)
		for c = from, to do
			if not sfx.channel_is_muted(app.pattern, c) then
				channels[c] = true
			end
		end
	end
	-- Steps
	if anchor_step then
		steps = {}
		for k, _ in pairs(steps_to_extend) do steps[k] = true end
		local from = min(step, anchor_step)
		local to = max(step, anchor_step)
		for c = from, to do
			steps[c] = true
		end
	end
	-- Parts
	if anchor_part and channel == anchor_channel then
		local from = min(anchor_part, part)
		local to = max(anchor_part, part)
		local range_parts = parts_after[from] & parts_before[to]
		parts = parts_to_extend | range_parts
	end
end


function selection.clear_anchor()
	anchor_channel = nil
	anchor_step = nil
	anchor_part = nil
	channels_to_extend = {}
	steps_to_extend = {}
	parts_to_extend = 0
end


function selection.unset(channel, step, part)
	-- TODO: clear if one of the mask is empty
	if channel then
		channels[channel] = nil
	end
	if step then
		steps[step] = nil
	end
	if part then
		parts = parts & (~part)
	end
end


function selection.clear()
	channels = {}
	steps = {}
	parts = 0
end


----------------------------------------------------------------------------------------------------
-- Movement
----------------------------------------------------------------------------------------------------


function selection.move_step(delta)
	local max_size = sfx.pattern_max_size(app.pattern) -- TODO: is this correct?
	local new_steps = {}
	for s, _ in pairs(steps) do
		local step = s + delta
		if step < 0 or step >= max_size then
			return false
		end
		new_steps[step] = true
	end
	steps = new_steps
	return true
end


function selection.move_to_previous_channel()
	local first_channel = find_first_channel(0)
	if channels[first_channel] then
		return false
	end
	local new_channels = {}
	for c, _ in pairs(channels) do
		local prev = find_last_channel(c - 1)
		if not prev then
			return false
		end
		new_channels[prev] = true
	end
	channels = new_channels
	return true
end


function selection.move_to_next_channel()
	local last_channel = find_last_channel()
	if channels[last_channel] then
		return false
	end
	local new_channels = {}
	for c, _ in pairs(channels) do
		local next = find_first_channel(c + 1)
		if not next then
			return false
		end
		new_channels[next] = true
	end
	channels = new_channels
	return true
end


function selection.move_to_previous_part()
	-- TODO: should probably cache these in a table...
	-- First, if there is only one part selected
	if parts == selection.note then
		local channel_changed = selection.move_to_previous_channel()
		if channel_changed then
			parts = selection.fx
		end
	elseif parts == selection.octave then
		parts = selection.note
	elseif parts == selection.instrument then
		parts = selection.octave
	elseif parts == selection.volume then
		parts = selection.instrument
	elseif parts == selection.fx then
		parts = selection.volume
	else
		selection.move_to_previous_channel()
		-- Now, handle the case of multiple parts
		--[[
		steps = { [selection.min_step()] = true }
		channels = { [selection.min_channel()] = true }
		if parts & selection.note ~= 0 then
			parts = selection.note
		elseif parts & selection.octave ~= 0 then
			parts = selection.octave
		elseif parts & selection.instrument ~= 0 then
			parts = selection.instrument
		elseif parts & selection.volume ~= 0 then
			parts = selection.volume
		elseif parts & selection.fx ~= 0 then
			parts = selection.fx
		end
		--]]
	end
end


function selection.move_to_next_part()
	-- TODO: should probably cache these in a table...
	-- First, if there is only one part selected
	if parts == selection.note then
		parts = selection.octave
	elseif parts == selection.octave then
		parts = selection.instrument
	elseif parts == selection.instrument then
		parts = selection.volume
	elseif parts == selection.volume then
		parts = selection.fx
	elseif parts == selection.fx then
		local channel_changed = selection.move_to_next_channel()
		if channel_changed then
			parts = selection.note
		end
	else
		-- Now, handle the case of multiple parts
		selection.move_to_next_channel()
		--[[
		steps = { [selection.max_step()] = true }
		channels = { [selection.max_channel()] = true }
		if parts & selection.fx ~= 0 then
			parts = selection.fx
		elseif parts & selection.volume ~= 0 then
			parts = selection.volume
		elseif parts & selection.instrument ~= 0 then
			parts = selection.instrument
		elseif parts & selection.octave ~= 0 then
			parts = selection.octave
		elseif parts & selection.note ~= 0 then
			parts = selection.note
		end
		--]]
	end
end


----------------------------------------------------------------------------------------------------
-- Querying
----------------------------------------------------------------------------------------------------


function selection.has_cursor()
	local has_channels = (next(channels) ~= nil)
	local has_steps = (next(steps) ~= nil)
	return has_channels and has_steps and parts ~= 0
end


function selection.has_channel(channel)
	return channels[channel] or false
end


function selection.channels()
	local result = {}
	for c, _ in pairs(channels) do
		add(result, c)
	end
	return result
end


function selection.has_step(step)
	return steps[step] or false
end


function selection.has_exactly_one_step()
	-- TODO: is there a better way?
	local count = 0
	for _, _ in pairs(steps) do
		count += 1
		if count > 1 then
			return false
		end
	end
	return count == 1
end


function selection.steps()
	local result = {}
	for c, _ in pairs(steps) do
		add(result, c)
	end
	return result
end


function selection.has_part(part)
	return parts & part ~= 0
end


function selection.parts()
	return parts
end


function selection.min_channel()
	local min = 9
	for s, _ in pairs(channels) do
		if s < min then
			min = s
		end
	end
	if min == 9 then
		return false
	end
	return min
end


function selection.max_channel()
	local max = -1
	for s, _ in pairs(channels) do
		if s > max then
			max = s
		end
	end
	if max == -1 then
		return false
	end
	return max
end


function selection.min_step()
	local min = 999999 -- hmmm..
	for s, _ in pairs(steps) do
		if s < min then
			min = s
		end
	end
	if min == 999999 then
		return false
	end
	return min
end


function selection.max_step()
	local max = -1
	for s, _ in pairs(steps) do
		if s > max then
			max = s
		end
	end
	if max == -1 then
		return false
	end
	return max
end


----------------------------------------------------------------------------------------------------
-- Iteration
----------------------------------------------------------------------------------------------------

	
function selection.for_each_channel_each_step(func)
	for channel in all(selection.channels()) do
		local track = sfx.pattern_track(app.pattern, channel)
		for step in all(selection.steps()) do
			func(track, step)
		end
	end
end


----------------------------------------------------------------------------------------------------
-- Copy / Pase
----------------------------------------------------------------------------------------------------


function selection.pack()
	local result = { parts = parts, columns = {}}
	for channel = selection.min_channel(), selection.max_channel() do
		local rows = {}
		if channels[channel] then
			local track <const> = sfx.pattern_track(app.pattern, channel)
			for step = selection.min_step(), selection.max_step() do
				if steps[step] then
					local row = {
						pitch = sfx.track_pitch(track, step),
						instrument = sfx.track_instrument(track, step),
						volume = sfx.track_volume(track, step),
						fx = sfx.track_fx(track, step),
						fx_params = sfx.track_fx_params(track, step),
					}
					add(rows, row)
				else
					add(rows, {})
				end
			end
		end
		add(result.columns, rows)
	end
	return result
end


function selection.unpack(package)
	local starting_channel = selection.min_channel()
	local starting_step = selection.min_step()
	if not package.parts or not package.columns then return false end
	for c, column in ipairs(package.columns) do
		for s, row in ipairs(column) do
			local channel = starting_channel + c - 1
			local step = starting_step + s - 1
			if channel <= 7 then
				local track <const> = sfx.pattern_track(app.pattern, channel)
				if row.pitch and step < sfx.track_size(track) then
					if package.parts & selection.note ~= 0 then
						sfx.set_track_pitch(track, step, row.pitch)
					end
					-- TODO: octave
					if package.parts & selection.instrument ~= 0 then
						if not row.instrument then return false end
						sfx.set_track_instrument(track, step, row.instrument)
					end
					if package.parts & selection.volume ~= 0 then
						if not row.volume then return false end
						sfx.set_track_volume(track, step, row.volume)
					end
					if package.parts & selection.fx ~= 0 then
						if not row.fx or not row.fx_params then return false end
						sfx.set_track_fx(track, step, row.fx)
						sfx.set_track_fx_params(track, step, row.fx_params)
					end
				end
			end
		end
	end
	return true
end


----------------------------------------------------------------------------------------------------
-- Undo / Redo
----------------------------------------------------------------------------------------------------


function selection.state()
	return { channels = channels, steps = steps, parts = parts }
end


function selection.set_state(state)
	channels = state.channels
	steps = state.steps
	parts = state.parts
end


----------------------------------------------------------------------------------------------------
-- Helper Functions
----------------------------------------------------------------------------------------------------


function copy_steps()
	local result = {}
	for k, _ in pairs(steps) do
		result[k] = true
	end
	return result
end


function find_first_channel(channel)
	channel = channel or 0
	while sfx.channel_is_muted(app.pattern, channel) and channel <= 8 do
		channel += 1
	end
	if channel == 8 then
		return nil
	end
	return channel
end


function find_last_channel(channel)
	channel = channel or 7
	while sfx.channel_is_muted(app.pattern, channel) and channel >= -1 do
		channel -= 1
	end
	if channel == -1 then
		return nil
	end
	return channel
end


return selection
:: src/settings.lua
--[[pod_format="raw",created="2024-04-11 08:58:08",modified="2026-01-30 18:48:07",revision=12238]]
local settings = {}

local settings_folder = "/appdata/wavemaker/"
local settings_filepath = "/appdata/wavemaker/settings.pod"
local keys_filepath = "/appdata/wavemaker/keys.pod"


settings.piano_keys = { pitched = {
	{
		offset = -12,
		[0] = "z", "s", "x", "d", "c", "v", "g", "b", "h", "n", "j", "m",
		",", "l", ".", ";", "/"
	},
	{
		offset = 0,
		[0] = "q", "2", "w", "3", "e", "r", "5", "t", "6", "y", "7", "u",
		"i", "9", "o", "0", "p", "[", "=", "]",
	}
}}


settings.isomorphic_keys = { pitched = {
	{
		offset = 0,
		[0] = "z", "x", "c", "v", "b", "n", "m", ",", ".", "/",
	},
	{
		offset = 5,
		[0] = "a", "s", "d", "f", "g", "h", "j", "k", "l", ";", "'",
	},
	{
	offset = 10,
		[0] = "q", "w", "e", "r", "t", "y", "u", "i", "o", "p", "[", "]", "\\",
	},
	{
	offset = 15,
		[0] = "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "-", "=",
	}
}}


settings.chromatic_keys = { pitched = {
	{
		offset = 0,
		[0] = "z", "x", "c", "v", "b", "n", "m", ",", ".", "/",
	},
	{
		offset = 10,
		[0] = "a", "s", "d", "f", "g", "h", "j", "k", "l", ";", "'",
	},
	{
	offset = 20,
		[0] = "q", "w", "e", "r", "t", "y", "u", "i", "o", "p", "[", "]", "\\",
	},
	{
	offset = 30,
		[0] = "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "-", "=",
	}
}}

settings.keys = {
	pitched = settings.piano_keys.pitched,
	play = "space",
	rest = "del",
}


settings.user = {
	pitched_layout = "piano-like",
	drag_horizontal = false,
	drag_sensitivity = 0.5,
	drag_sensitivity_precise = 0.125,
}


function settings.load()
	mkdir(settings_folder)
	local user_keys = fetch(keys_filepath)
	if user_keys then
		for k, v in pairs(settings.keys) do
			if user_keys[k] then
				settings.keys[k] = user_keys[k]
			end
		end
	end
	local user_settings = fetch(settings_filepath)
	if user_settings then
		for k, v in pairs(settings.user) do
			if user_settings[k] then
				settings.user[k] = user_settings[k]
			end
		end
	end
end


function settings.change_keys(t)
	for k, v in pairs(t) do
		settings.keys[k] = v
	end
	store(keys_filepath, settings.keys)
end


function settings.change_user(t)
	for k, v in pairs(t) do
		settings.user[k] = v
	end
	store(settings_filepath, settings.user)
end


return settings
:: src/sfx.lua
--[[pod_format="raw",created="2024-04-07 08:22:05",modified="2026-01-30 18:48:07",revision=16724]]
local sfx = {}


----------------------------------------------------------------------------------------------------
-- Stat
----------------------------------------------------------------------------------------------------


function sfx.playing_channels()
	return stat(464)
end


function sfx.music_is_playing()
--	return stat(464) ~= 0
	return stat(466) ~= -1
end


function sfx.is_channel_playing(channel)
	local mask = 1 << channel
	return (stat(464) & mask) ~= 0
end


function sfx.playing_pattern()
	return stat(466)
end


function sfx.playing_lead_channel()
	return stat(467)
end


function sfx.playing_channel_row(channel)
	return stat(400 + channel, 9)
end

function sfx.playing_row()
	return sfx.playing_channel_row(sfx.playing_lead_channel())
end

--[[
--TODO:
stat(400 + c,  0) -- note is held (0 false 1 true)
stat(400 + c,  1) -- channel instrument
stat(400 + c,  2) -- channel vol
stat(400 + c,  3) -- channel pan
stat(400 + c,  4) -- channel pitch
stat(400 + c,  5) -- channel bend
stat(400 + c,  6) -- channel effect
stat(400 + c,  7) -- channel effect_p
stat(400 + c,  8) -- channel tick len
stat(400 + c,  9) -- channel row
stat(400 + c, 10) -- channel row tick
stat(400 + c, 11) -- channel sfx tick
stat(400 + c, 12) -- channel sfx index (-1 if none finished)
stat(400 + c, 13) -- channel last played sfx index 
--]]

----------------------------------------------------------------------------------------------------
-- Header
----------------------------------------------------------------------------------------------------


-- This should probably be configurable?
local addr <const> = 0x30000


local function paddr()
	-- default 0x030100 = base + 0x000100
	return addr + peek4(addr + 0x18) + 0x100
end
local function saddr()
	-- default 0x040000 = base + 0x010000
	return addr + peek4(addr + 0x10)
end
local function taddr()
	-- default 0x050000 = base + 0x020000
	return addr + peek4(addr + 0x14)
end


function sfx.num_instruments()
	return peek2(addr)
end


function sfx.num_tracks()
	return peek2(addr + 0x2)
end


function sfx.num_patterns()
	return peek2(addr + 0x4)
end


function sfx.instruments_address()
	return saddr()
end


function sfx.tracks_address()
	return taddr()
end


function sfx.patterns_address()
	return paddr()
end


function sfx.tick_length()
	return peek2(addr + 0x20)
end


function sfx.set_tick_length(value)
	return poke2(addr + 0x20, value)
end


function sfx.default_length()
	return peek2(addr + 0x22)
end


function sfx.set_default_length(value)
	return poke2(addr + 0x22, value)
end


function sfx.default_speed()
	return peek(addr + 0x24)
end


function sfx.set_default_speed(value)
	return poke(addr + 0x24, value)
end


----------------------------------------------------------------------------------------------------
-- Pattern Info
----------------------------------------------------------------------------------------------------


function sfx.pattern_length(pattern)
	return peek2(paddr() + (pattern * 20) + 10)
end


function sfx.set_pattern_length(pattern, value)
	poke2(paddr() + (pattern * 20) + 10, value)
end

function sfx.pattern_loop_start(pattern)
	return (peek(paddr() + (pattern * 20) + 8) & 0x01) != 0
end


function sfx.set_pattern_loop_start(pattern, bool)
	local old = peek(paddr() + (pattern * 20) + 8)
	if bool then
		poke(paddr() + (pattern * 20) + 8, old | 0x01)
	else
		poke(paddr() + (pattern * 20) + 8, old & (~ 0x01))
	end
end


function sfx.pattern_loop_end(pattern)
	return (peek(paddr() + (pattern * 20) + 8) & 0x02) != 0
end


function sfx.set_pattern_loop_end(pattern, bool)
	local old = peek(paddr() + (pattern * 20) + 8)
	if bool then
		poke(paddr() + (pattern * 20) + 8, old | 0x02)
	else
		poke(paddr() + (pattern * 20) + 8, old & (~ 0x02))
	end
end


function sfx.pattern_loop_stop(pattern)
	return (peek(paddr() + (pattern * 20) + 8) & 0x04) != 0
end


function sfx.set_pattern_loop_stop(pattern, bool)
	local old = peek(paddr() + (pattern * 20) + 8)
	if bool then
		poke(paddr() + (pattern * 20) + 8, old | 0x04)
	else
		poke(paddr() + (pattern * 20) + 8, old & (~ 0x04))
	end
end


function sfx.channel_is_muted(pattern, channel)
	local channel_mutes = peek(paddr() + (pattern * 20) + 9)
	local muted = (channel_mutes & (1 << channel)) == 0
	return muted
end


function sfx.mute_channel(pattern, channel, mute)
	local channel_mutes = peek(paddr() + (pattern * 20) + 9)
	channel_mutes &= ~(1 << channel)
	channel_mutes |= (mute and 0 or 1) << channel
	poke(paddr() + (pattern * 20) + 9, channel_mutes)
end


function sfx.pattern_track(pattern, channel)
	return peek(paddr() + pattern * 20 + channel)
end


function sfx.set_pattern_track(pattern, channel, track)
	poke(paddr() + pattern * 20 + channel, track)
end


----------------------------------------------------------------------------------------------------
-- Track Info
----------------------------------------------------------------------------------------------------


local default_track_size = 64 * 5 + 8 -- 328, default indexing


function sfx.track_size(track)
	return peek2(taddr() + (track * default_track_size)) -- TODO
end


function sfx.set_track_size(track, value)
	poke2(taddr() + (track * default_track_size), value)
end


function sfx.pattern_max_size(pattern)
	local max_length = 0
	for channel = 0, 7 do
		local track = sfx.pattern_track(pattern, channel)
		max_length = max(sfx.track_size(track), max_length)
	end
	return max_length
end


function sfx.track_speed(track)
	return peek(taddr() + (track * default_track_size) + 2)
end


function sfx.set_track_speed(track, val)
	return poke(taddr() + (track * default_track_size) + 2, val)
end


function sfx.track_loop0(track)
	return peek(taddr() + (track * default_track_size) + 3)
end


function sfx.set_track_loop0(track, val)
	return poke(taddr() + (track * default_track_size) + 3, val)
end


function sfx.track_loop1(track)
	return peek(taddr() + (track * default_track_size) + 4)
end


function sfx.set_track_loop1(track, val)
	poke(taddr() + (track * default_track_size) + 4, val)
end


function sfx.track_is_looping(track)
	local loop0 <const> = sfx.track_loop0(track)
	local loop1 <const> = sfx.track_loop1(track)
	return loop1 > loop0
end


function sfx.track_length(track)
	local loop0 <const> = sfx.track_loop0(track)
	local loop1 <const> = sfx.track_loop1(track)
	local length = max(loop0, loop1)
	if length == 0 then
		return sfx.default_length()
	end
	return length
end	


function sfx.track_delay(track)
	return peek(taddr() + (track * default_track_size) + 5)
end


function sfx.set_track_delay(track, val)
	poke(taddr() + (track * default_track_size) + 5, val)
end


function sfx.track_flags(track)
	return peek(taddr() + (track * default_track_size) + 6)
end


function sfx.set_track_flags(track, flags)
	return poke(taddr() + (track * default_track_size) + 6, flags)
end


function sfx.track_unused(track)
	return peek(taddr() + (track * default_track_size) + 7)
end


function sfx.set_track_unused(track, flags)
	return poke(taddr() + (track * default_track_size) + 7, flags)
end


----------------------------------------------------------------------------------------------------
-- Track Notes
----------------------------------------------------------------------------------------------------


function sfx.track_pitch(track, step)
	return peek(taddr() + 8 + (track * default_track_size) + step)
end


function sfx.set_track_pitch(track, step, v)
	return poke(taddr() + 8 + (track * default_track_size) + step, v)
end


function sfx.track_instrument(track, step)
	return peek(taddr() + 8 + (track * default_track_size) + step + 64)
end


function sfx.set_track_instrument(track, step, v)
	return poke(taddr() + 8 + (track * default_track_size) + step + 64, v)
end


function sfx.track_volume(track, step)
	return peek(taddr() + 8 + (track * default_track_size) + step + (2 * 64))
end


function sfx.set_track_volume(track, step, v)
	return poke(taddr() + 8 + (track * default_track_size) + step + (2 * 64), v)
end


function sfx.track_fx(track, step)
	return peek(taddr() + 8 + (track * default_track_size) + step + (3 * 64))
end


function sfx.set_track_fx(track, step, v)
	return poke(taddr() + 8 + (track * default_track_size) + step + (3 * 64), v)
end


function sfx.track_fx_params(track, step)
	return peek(taddr() + 8 + (track * default_track_size) + step + (4 * 64))
end


function sfx.track_fx_param0(track, step)
	return peek(taddr() + 8 + (track * default_track_size) + step + (4 * 64)) >> 4
end


function sfx.track_fx_param1(track, step)
	return peek(taddr() + 8 + (track * default_track_size) + step + (4 * 64)) & 0xf
end


function sfx.set_track_fx_params(track, step, v)
	return poke(taddr() + 8 + (track * default_track_size) + step + (4 * 64), v)
end


function sfx.set_track_fx_param0(track, step, v)
	local previous = peek(taddr() + 8 + (track * default_track_size) + step + (4 * 64))
	return poke(taddr() + 8 + (track * default_track_size) + step + (4 * 64), (previous & 0x0f) | (v << 4))
end


function sfx.set_track_fx_param1(track, step, v)
	local previous = peek(taddr() + 8 + (track * default_track_size) + step + (4 * 64))
	return poke(taddr() + 8 + (track * default_track_size) + step + (4 * 64), (previous & 0xf0) | (v & 0x0f))
end


----------------------------------------------------------------------------------------------------
-- Synth: Instrument Info
----------------------------------------------------------------------------------------------------


function sfx.instrument_name(instrument)
	local inst_addr = saddr() + instrument * 0x200
	local length = 16
	for j = 15, 0, -1 do
		if peek(inst_addr + 496 + j) == 0 then
			length = j
		end
	end
	return chr(peek(inst_addr + 496, length))
end


function sfx.set_instrument_name(instrument, name)
	local inst_addr = saddr() + instrument * 0x200
	memset(inst_addr + 496, 0, 16)
	poke(inst_addr + 496, ord(name, 1, min(16, #name)))
end


function sfx.instrument_flag(instrument, flag)
	local inst_addr = saddr() + instrument * 0x200
	local addr = inst_addr + 0x1df
	return (peek(addr) & flag) > 0
end


function sfx.set_instrument_flag(instrument, flag, value)
	local inst_addr = saddr() + instrument * 0x200
	local addr = inst_addr + 0x1df
	local other_flags = peek(addr) & (~ flag)
	if value then
		poke(addr, other_flags | flag)
	else
		poke(addr, other_flags)
	end
end


function sfx.toggle_instrument_flag(instrument, flag)
	local inst_addr = saddr() + instrument * 0x200
	local addr = inst_addr + 0x1df
	local previous = peek(addr)
	poke(addr, previous ^^ flag)
end


function sfx.wavetable_info(instrument, wt_index)
	local inst_addr = saddr() + instrument * 0x200
	local wt_4defs_addr = inst_addr + 0x1e0 -- start of the 4 wt definitions
	local wt_def_addr = wt_4defs_addr + wt_index * 4
	local addr0, addr1, width_bits, wt_height = peek(wt_def_addr,4)
	local dat_addr = (addr0 << 8) | (addr1 << 16)
	local wt_width = 1 << width_bits
	return dat_addr, wt_width, wt_height
end


----------------------------------------------------------------------------------------------------
-- Synth: Node Tree
----------------------------------------------------------------------------------------------------


sfx.nodes = {}
for n = 0, 7 do
	sfx.nodes[n] = {
		parent = nil, -- id of the parent
		children = {}, -- list of direct references to the children
		type = nil,
	}
end
	

local function depth_walk(root, pre_fun, post_fun, depth)
	if (not depth) depth = 0
	if depth > 8 then
		-- TODO: remove notification
		notify("*** Deep recursion: cycle in synth nodes? ***")
		return
	end
	if (pre_fun) pre_fun(root)
	for i = 1, #root.children do
		local child = root.children[i]
		if child.type != 0 then
			depth_walk(child, pre_fun, post_fun, depth + 1)
		end
	end
	if (post_fun) post_fun(root)
end


function sfx.refresh_nodes(instrument)
	for n = 0, 7 do
		sfx.nodes[n].id = n
		sfx.nodes[n].children = {}
		sfx.nodes[n].older_sibling = nil
		sfx.nodes[n].height = nil -- TODO: or 0?
		sfx.nodes[n].position = nil
	end
	sfx.root = sfx.nodes[0]
	sfx.root.free_nodes = 7
	--- printh("* refresh *")
	for n = 0, 7 do
		local type = sfx.node_type(instrument, n)
		local op = sfx.node_op(instrument, n)
		local parent_id = sfx.node_parent(instrument, n)
		--- printh("" .. parent_id .. " -> " .. n .. " type=" .. type .. " op=" .. op)
		sfx.nodes[n].parent = sfx.nodes[parent_id]
		sfx.nodes[n].type = type
		sfx.nodes[n].op = op
		sfx.nodes[n].last_child = function(self)
			if (#self.children == 0) return self
			return self.children[#self.children]:last_child()
		end
		if type != 0 and n != 0 then
			add(sfx.nodes[n].parent.children, sfx.nodes[n])
			sfx.root.free_nodes -= 1
		end
	end
	
	depth_walk(
		sfx.root,
		nil,
		function(node)
			if #node.children == 0 then
				node.height = 1
			else
				local h = 0
				for i = 1, #node.children do
					local child = node.children[i]
					if i > 1 then
						child.older_sibling = node.children[i - 1]
					end
					h += child.height
				end
				node.height = h
			end
		end
	)

	sfx.root.position = { row = 0, column = 0 }
	depth_walk(
		sfx.root,
		function(node)
			local row = node.position.row
			for i = 1, #node.children do
				node.children[i].position = {
					column = node.position.column + 1,
					row = row,
				}
				row += node.children[i].height
			end
		end,
		nil
	)
end


function sfx.add_node(instrument, parent_id, node_type, node_op, target_id, child_id)
	local parent = sfx.nodes[parent_id]
	
	if (not parent) notify("invalid parent (nil)"); return
	if (parent.type >= 8) notify("invalid parent (filter)"); return

	if target_id >= 8 then
		-- no room!
		return
	end	

	sfx.insert_node(instrument, target_id, parent_id, child_id)
	
	if node_type == 0x2 and node_op == 1 then
		-- FM mod osc
		sfx.set_node_type(instrument, target_id, node_type)
		sfx.set_node_op(instrument, target_id, node_op)
		sfx.set_node_param_val1(instrument, target_id, 0, 0x20) -- volume
		sfx.set_node_param_flags(instrument, target_id, 2, 0x02) -- not quantized, and relation + for tune
		sfx.set_node_param_flags(instrument, target_id, 3, 0x01) -- relation + for bend
	elseif node_type == 0x2 and node_op == 2 then
		-- Ring mod osc
		sfx.set_node_type(instrument, target_id, node_type)
		sfx.set_node_op(instrument, target_id, node_op)
		sfx.set_node_param_val1(instrument, target_id, 0, 0x20) -- volume
		sfx.set_node_param_flags(instrument, target_id, 2, 0x01) -- not quantized, and relation + for tune
		sfx.set_node_param_flags(instrument, target_id, 3, 0x01) -- relation + for bend
	elseif node_type == 0x2 then
		-- Osc
		sfx.set_node_type(instrument, target_id, node_type)
		sfx.set_node_op(instrument, target_id, node_op)
		sfx.set_node_param_val1(instrument, target_id, 0, 0x20) -- volume
		sfx.set_node_param_flags(instrument, target_id, 0, 0x02) -- relation * for volume
		sfx.set_node_param_flags(instrument, target_id, 1, 0x01) -- relation + for pan
		sfx.set_node_param_flags(instrument, target_id, 2, 0x21) -- quantized, and relation + for tune
		sfx.set_node_param_flags(instrument, target_id, 3, 0x01) -- relation + for bend
	elseif node_type == 0xa then
		sfx.set_node_type(instrument, target_id, node_type)
		sfx.set_node_param_val1(instrument, target_id, 3, 0x40) -- mix
	else
		sfx.set_node_type(instrument, target_id, node_type)
	end
	return target_id
end


----------------------------------------------------------------------------------------------------
-- Synth: Node Configuration
----------------------------------------------------------------------------------------------------


function sfx.delete_node(instrument, node_id)
	local deleted_node_parent = sfx.node_parent(instrument, node_id)
	local inst_addr = saddr() + instrument * 0x200
	-- move everything up
	for j = node_id, 7 do
		memcpy(inst_addr + j * 0x20, inst_addr + (j + 1) * 0x20, 0x20)
	end
	memset(inst_addr + 7 * 0x20, 0, 0x20)
	-- fix parents
	for j = 0, 6 do
		local parent = sfx.node_parent(instrument, j)
		if parent == node_id then
			sfx._set_node_parent(instrument, j, deleted_node_parent)
		elseif parent > node_id then
			sfx._set_node_parent(instrument, j, parent - 1)
		end
	end
end


function sfx.insert_node(instrument, node_id, parent_id, child_id)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node_id * 0x20
	-- move everything down
	for j = 7, node_id + 1, -1 do
		memcpy(inst_addr + j * 0x20, inst_addr + ( j - 1) * 0x20, 0x20)
	end
	memset(node_addr, 0, 0x20)
	-- fix parents
	poke(node_addr, parent_id)
	for j = 0, 7 do
		local parent = sfx.node_parent(instrument, j)
		if parent >= node_id then
			sfx._set_node_parent(instrument, j, parent + 1)
		end
	end
	if child_id then
		if child_id >= node_id then
			child_id += 1
		end
		if child_id <= 7 then
			sfx._set_node_parent(instrument, child_id, node_id)
		end
	end
end


function sfx.node_parent(instrument, node)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr + 0) & 0x7	
end

function sfx._set_node_parent(instrument, node, parent)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	local previous = peek(node_addr + 0)
	poke(node_addr + 0, (previous & ~0x7) | (parent & 0x7))
end

function sfx.node_op(instrument, node)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr) >> 4
end

function sfx.set_node_op(instrument, node, op)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	local previous = peek(node_addr)
	poke(node_addr, (previous & 0x0f) | (op << 4))
end

function sfx.node_type(instrument, node)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr + 1) & 0xf
end

function sfx.set_node_type(instrument, node, type)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	local previous = peek(node_addr + 1)
	poke(node_addr + 1, (previous & 0xf0) | (type & 0x0f))
end

function sfx.node_osc_wavetable(instrument, node)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr + 1) >> 4
end

function sfx.set_node_osc_wavetable(instrument, node, wt)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	local previous = peek(node_addr + 1)
	poke(node_addr + 1, (previous & 0x0f) | (wt << 4))
end

function sfx.node_flags(instrument, node)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	return peek(node_addr + 2)
end

function sfx.set_node_flags(instrument, node, flags)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 2, flags)
end

-- node_addr + 3 is unused

-- 0 <= p <= 7
function sfx.node_param(instrument, node, p)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	local flags,val1,val0,env = peek(node_addr + 4 + (4 * p), 4)
	return flags, val1, val0, env
end

function sfx.set_node_param_flags(instrument, node, p, flags)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 4 + (4 * p), flags)
end

function sfx.set_node_param_val1(instrument, node, p, val1)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 4 + (4 * p) + 1, val1)
end

function sfx.set_node_param_val0(instrument, node, p, val0)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 4 + (4 * p) + 2, val0)
end

function sfx.set_node_param_env(instrument, node, p, env)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	poke(node_addr + 4 + (4 * p) + 3, env)
end

function sfx.node_wavetable_info(instrument, node)
	local inst_addr = saddr() + instrument * 0x200
	local wt_4defs_addr = inst_addr + 0x1e0 -- start of the 4 wt definitions
	local node_addr = inst_addr + node * 0x20
	local wt_index = (peek(node_addr+1)>>4)
	local wt_def_addr = wt_4defs_addr + wt_index * 4
	local addr0, addr1, width_bits, wt_height = peek(wt_def_addr,4)
	local dat_addr = (addr0 << 8) | (addr1 << 16)
	local wt_width = 1 << width_bits
	return dat_addr, wt_width, wt_height
end

function sfx.node_wavetable_index(instrument, node)
	local inst_addr = saddr() + instrument * 0x200
	local node_addr = inst_addr + node * 0x20
	local wt_index = (peek(node_addr+1)>>4)
	return wt_index
end


----------------------------------------------------------------------------------------------------
-- Synth: Envelopes
----------------------------------------------------------------------------------------------------


function sfx.env_type(instrument, env)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr)
end


function sfx.set_env_type(instrument, env, type)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr, type)
end


function sfx.env_flags(instrument, env)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 1)
end


function sfx.set_env_flags(instrument, env, flags)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 1, flags)
end


function sfx.env_speed(instrument, env)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 2)
end


function sfx.set_env_speed(instrument, env, val)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 2, val)
end


function sfx.env_loop0(instrument, env)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 3)
end


function sfx.set_env_loop0(instrument, env, val)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 3, val)
end


function sfx.env_loop1(instrument, env)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 4)
end


function sfx.set_env_loop1(instrument, env, val)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 4, val)
end


function sfx.env_start(instrument, env)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 5)
end


function sfx.set_env_start(instrument, env, val)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 5, val)
end


function sfx.env_param(instrument, env, param)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return peek(env_addr + 8 + param)
end


function sfx.set_env_param(instrument, env, param, val)
	local inst_addr = saddr() + instrument * 0x200
	local env_addr = inst_addr + 256 + env * 24
	return poke(env_addr + 8 + param, val)
end


return sfx
:: src/ui.lua
--[[pod_format="raw",created="2024-04-23 10:25:40",modified="2026-01-30 18:48:07",revision=10434]]
local app = require "src/app.lua"
local settings = require "src/settings.lua"
local undo = require "src/undo.lua"


local ui = {}


----------------------------------------------------------------------------------------------------
-- Head
----------------------------------------------------------------------------------------------------


local head = false


function ui.create_head()
	head = create_gui()
end


function ui.head()
	return head
end


----------------------------------------------------------------------------------------------------
-- Misc
----------------------------------------------------------------------------------------------------


function ui.print_centered(s, x, y, col)
	local count = #s
	print(s, x - ((count * 4) \ 2), y, col)
end


----------------------------------------------------------------------------------------------------
-- Mouse
----------------------------------------------------------------------------------------------------


function ui.mouselock(sensitivity, precise)
	local s = settings.user.drag_sensitivity
	if precise or key("shift") then
		s = settings.user.drag_sensitivity_precise
	end
	s *= sensitivity or 1
	local dx, dy = mouselock(0x4|0x8, s, 0.0)
	if settings.user.drag_horizontal then
		return -dx
	end
	return dy
end


function ui.mouseunlock()
	mouselock(false)
end


----------------------------------------------------------------------------------------------------
-- Modal
----------------------------------------------------------------------------------------------------


local layer = false


function ui.open_modal(el)
	layer = ui.head():attach {
		x = 0, y = 0,
		width = ui.head().width, height = ui.head().height,
		draw = function(self)
			if self.dim_background then
				poke(0x550b, 0x3f)
				---fillp(0b0101101001011010)
				---fillp(0b0001001001001000)
				---fillp(0b1110110110110111)
				fillp(0b0011011011001001)
				rectfill(0, 0, self.width - 1, self.height - 1, 61)
				fillp()
				poke(0x550b, 0x00)
			end
		end,
		click = function(self)
			ui.close_modal()
		end
	}
	if not el.x then
		el.x = layer.width // 2 - el.width // 2
	end
	if not el.y then
		el.y = layer.height // 2 - el.height // 2
	end
	layer:attach(el)
	return el
end


function ui.has_modal()
	return layer
end


function ui.close_modal()
	if layer then
		layer:detach()
	end
	layer = false
end


function ui.has_modal_or_menu()
	return ui.has_modal() or ui.has_menu()
end


----------------------------------------------------------------------------------------------------
-- Chooser
----------------------------------------------------------------------------------------------------


function ui.chooser(options, callback)
	-- Copied from system 0.2.2b
	if (type(options) == "string") options = {path = options}
	if (type(options) ~= "table") options = {}

	options.path = fullpath(options.path or ".") -- can be relative to pwd; default to pwd()
	if (not options.path) return "could not resolve path"
	if (fstat(options.path) ~= "folder") return "path not found"

	local intention = options.intention or "choose_items"
	local intention_event = nil

	if (callback) intention_event = "_chooser_response_"..stat(333) -- unique id

	create_process("/system/apps/filenav.p64",{
		window_attribs = {autoclose = true, workspace = "current"},
		intention = intention,
		intention_event = intention_event,
		title = options.title, -- window title
		prompt = options.prompt, -- "Choose a File" (bottom left in intention pane)
		verb = options.verb, -- "Open" ~ (bottom right button in intention pane)
		path = options.path  -- starting path
	})

	if (callback) then
		-- create a unique, use-once handler 
		-- to do: mechanism to delete event handler when filenav never gets a chance to respond
		-- (but maybe too complex -- is harmless to have ~100 or so dormant event handlers sitting around)
		on_event(intention_event, function(msg)
			callback(msg)
			on_event(intention_event) -- delete
		end)
	end
	
end


----------------------------------------------------------------------------------------------------
-- Label
----------------------------------------------------------------------------------------------------


function ui.create_label(el)
	el.width = 4 * #el.label + 4
	el.height = 5
	ui.head():new(el)
	function el:draw()
		print(el.label, 0, 0, el.fg or 5)
	end
	return el
end


----------------------------------------------------------------------------------------------------
-- Checkbox
----------------------------------------------------------------------------------------------------


function ui.create_checkbox(el)
	el.width = 9 + (4 * #el.label or "")
	el.height = 7
	el.cursor = "pointer"
	ui.head():new(el)
	if (not el.visible) el.visible = function() return true end
	function el:draw()
		if (not self:visible()) return
		rect(0, 0, 6, 6,  el.check_border or 59)
		if el.check_bg then
			rectfill(1, 1, 5, 5, el.check_bg)
		end
		if self.get() then
			rectfill(2, 2, 4, 4, el.check_fg or 17)
		end
		print(el.label, 10, 1, el.fg or 5)
	end
	function el:tap()
		if (not self:visible()) return
		self.set(not self.get())
	end
	return el
end


----------------------------------------------------------------------------------------------------
-- Numeric Field
----------------------------------------------------------------------------------------------------


function ui.create_num_field(el)
	el.width = el.width or 62
	el.height = 12
	ui.head():new(el)
	if (not el.visible) el.visible = function() return true end
	el.dragged = nil
	function el:draw()
		local label_fg = self.label_fg or 5
		local field_fg = self.field_fg or 22
		local dragged_fg = self.dragged_fg or 7
		local field_bg = self.field_bg or 59
		local dragged_bg = self.dragged_bg or 59
		if (not self.visible()) return
		local val = self.get()
		rectfill(self.width - 24, 0, self.width - 10, 6, self.dragged and dragged_bg or field_bg)
		print(el.label, 3, 1, label_fg)
		if val then
			print(string.format("%3d", val), self.width - 22, 1, self.dragged and dragged_fg or field_fg)
		else
			print("-", self.width - 4, 1, self.dragged and dragged_fg or field_fg)
		end
	end
	function el:hover(msg)
		if msg.mx >= self.width - 21 then
			--- self.cursor = "pointer"
			self.cursor = get_spr(50)
		else
			self.cursor = 1
		end
	end
	function el:click(msg)
		if (not self.visible()) return
		if (self.onclick) self.onclick(msg)
		if msg.mx >= self.width - 21 then
			self.dragged = true
			self.cursor = 0 -- TODO: capture mouse
		end
	end
	function el:drag(msg)
		if (not el.visible()) return
		if self.dragged then
			local _, delta = mouselock(true, key("shift") and 0.025 or 0.125, 0)
			new = mid(0, self.get() - delta, 0xff)
			self.set(new)
		end
	end
	function el:release(msg)
		self.dragged = nil
		mouselock(false)
		if (self.onrelease) self.onrelease(msg)
	end
	return el
end


----------------------------------------------------------------------------------------------------
-- Menu
----------------------------------------------------------------------------------------------------


local popup = false


function ui.create_menu_button(el)
	local label = el.get_label()
	el.width = (4 * #label) + 12
	el.height = 9
	el.cursor = "pointer"
	ui.head():new(el)
	el.opened = false
	function el:draw()
		if self.bg then
			rectfill(0, 0, self.width - 1, self.height - 1, self.bg)
		end
		local label = self:get_label()
		print(label, 2, 2, self.fg or 7)
		pal(7, self.fg or 7)
		spr(self.opened and 38 or 37, self.width - 7, 2)
		pal(7, 7)
	end
	function el:tap()
		self.opened = true
		ui.open_menu {
			x = self.sx, y = self.sy + 9,
			highlight = self.highlight,
			onclose = function()
				self.opened = false
				local label = el.get_label()
				self.width = (4 * #label) + 12
			end,
			items = self.items,
		}
	end
	return el
end


function ui.open_menu(menu)
	for i = 1, #menu.items do
		if menu.items[i].get_label then
			menu.items[i].label = menu.items[i].get_label()
		end
		if (not menu.items[i].label) menu.items[i].label = "---"
	end
	local entry_height = 9
	-- Calculate popup size
	if not menu.width then
		menu.width = 0
		for i = 1, #menu.items do
			menu.width = max(menu.width, #menu.items[i].label or 0)
		end
		menu.width = 8 + (4 * menu.width)
	end
	if not menu.height then
		menu.height = max(12, 4 + (#menu.items * entry_height))
	end
	if menu.y + menu.height > ui.head().height then
		menu.y = menu.y - 7 - menu.height
	end

	-- Modal layer	
	popup = ui.head():attach {
		x = 0, y = 0,
		width = ui.head().width, height = ui.head().height,
		draw = function(self)
			local ox, oy = menu.x, menu.y
			rectfill(ox, oy, ox + menu.width - 1, oy + menu.height - 1, menu.bg or 7)
			rect(ox, oy, ox + menu.width - 1, oy + menu.height - 1, menu.border or 5)
			for i = 1, #menu.items do
				local y = oy + 2 + (entry_height * (i - 1))
				if self.highlighted == i then
					rectfill(
						ox + 1, y,
						ox + menu.width - 2, y + entry_height - 1,
						menu.highlight or 15
					) 
				end
				print(
					menu.items[i].label,
					ox + 4, y + 2,
					menu.items[i].fg or menu.fg or 62
				)
			end
		end,
		hover = function(self)
			local ox, oy = menu.x, menu.y
			local mx, my, mb = mouse()
			if
				ox <= mx and mx < ox + menu.width
				and oy <= my and my < oy + menu.height
			then
				self.cursor = "pointer"
				self.highlighted = 1 + ((my - oy - 4) \ entry_height)
			else
				self.cursor = "pointer"
				self.highlighted = false
			end
		end,
		click = function(self)
			if popup then
				popup:detach()
			end
			popup = false
			if self.highlighted and menu.items[self.highlighted]
				and menu.items[self.highlighted].action
			then
				menu.items[self.highlighted].action()
			end
			if (menu.onclose) menu.onclose()
		end
	}
end


function ui.has_menu()
	return popup != false
end


----------------------------------------------------------------------------------------------------
-- Knob
----------------------------------------------------------------------------------------------------


function ui.create_knob(el)
	if el.small then
		el.x += 3
		el.y += 5
		el.width, el.height = 25, 25
		el.cx, el.cy, el.r = 12, 12, 7
		el.sprite = 58
	else
		el.width, el.height = 31, 31
		el.cx, el.cy, el.r = 15, 15, 9
		el.sprite = 56
	end
	el.cursor = get_spr(50)
	ui.head():new(el)
	

	function el:draw()
		local target = self.min_val and self or self.parent
		local sprite = (target.min_val < 0)
			and (self.sprite + 1) or self.sprite
		spr(sprite, 0, 0)	
		local range = target.max_val - target.min_val
		-- primary value
		local val = self:get()
		local a = ((val - target.min_val) / range) * 0.75
		local x = self.cx + flr(0.5 + self.r * cos(0.625 - a))
		local y = self.cy + flr(0.5 + self.r * sin(0.625 - a))
		-- secondary value: arc and needle
		if self:has_secondary() then
			local val2 = self:get_secondary()
			local a2 = ((val2 - target.min_val) / range) * 0.75
			local r = self.small and 6 or 7.75
			local incr = self.small and 0.01 or 0.01
			local function line_to(aa, col)
				local xx = self.cx + flr(0.5 + r * cos(0.625 - aa))
				local yy = self.cy + flr(0.5 + r * sin(0.625 - aa))
				line(self.cx, self.cy, xx, yy, 18)
			end
			local in_between =
				(a < a2) 
					and function(ai) return a < ai and ai < a2 end
					or function(ai) return a2 < ai and ai < a end
			line()
			line_to((a < a2) and a or a2)
			for ai = 0.0, 0.75, incr do
				if in_between(ai) then
					line_to(ai)
				end
			end
			line_to((a < a2) and a2 or a)
			local x2 = self.cx + flr(0.5 + (self.r - 1) * cos(0.625 - a2))
			local y2 = self.cy + flr(0.5 + (self.r - 1) * sin(0.625 - a2))
			line(self.cx, self.cy, x2, y2, self.dragged_secondary and 7 or 29)
		end	
		-- primary needle
		local needle_col = self.dragged and 7 or 15
		if self.white then
			needle_col = self.dragged and 5 or 22
		end
		line(self.cx, self.cy, x, y, needle_col)
	end
	

	function el:click(msg)
		undo.checkpoint()
		local target = self.min_val and self or self.parent
		self.cursor = 0
		self.dragged = msg.mb == 1
		self.dragged_secondary = msg.mb == 2
		ui.mouselock(target.sensitivity)
		return true
	end
	

	function el:doubleclick(msg)
		local target = self.min_val and self or self.parent
		if msg.mb == 1 then
			self:set(target.init_val)
		elseif msg.mb == 2 then
			self:set_secondary(target.init_val)
		end
		return true
	end
	

	function el:drag(msg)
		local target = self.min_val and self or self.parent
		local delta = ui.mouselock(target.sensitivity)

		local old = self:get()
		local new = old - delta
		local old2, new2 = 0, 0
		if self:has_secondary() and msg.mb == 2 then
			old2 = self:get_secondary()
			new2 = old2 - delta
		end

		if delta < 0 then
			self.down_barrier = nil
			if self.up_barrier then
				self.up_barrier += delta
				if self.up_barrier <= 0 then
					self.up_barrier = nil
				else
					return
				end
			end
		elseif delta > 0 then
			self.up_barrier = nil
			if self.down_barrier then
				self.down_barrier -= delta
				if self.down_barrier <= 0 then
					self.down_barrier = nil
				else
					return
				end
			end
		end
		if old > 0 and new <= 0 then
			new = 0
			self.down_barrier = 24
		end
		if old < 0 and new >= 0 then
			new = 0
			self.up_barrier = 24
		end
		if old2 > 0 and new2 <= 0 then
			new2 = 0
			self.down_barrier = 24
		end
		if old2 < 0 and new2 >= 0 then
			new2 = 0
			self.up_barrier = 24
		end
		
		if msg.mb == 1 then
			self:set(new)
		elseif msg.mb == 2 then
			self:set_secondary(new2)
		end
	end
	

	function el:release(msg)
		self.cursor = get_spr(50)
		self.dragged = false
		self.dragged_secondary = false
		ui.mouseunlock()
		self.up_barrier = nil
		self.down_barrier = nil
	end
	

	return el
end


return ui
:: src/ui_envelopes.lua
--[[pod_format="raw",created="2024-04-14 20:24:26",modified="2026-01-30 18:48:07",revision=12543]]
local app = require "src/app.lua"
local sfx = require "src/sfx.lua"
local undo = require "src/undo.lua"
local ui = require "src/ui.lua"
local ui_visual = require "src/ui_visual.lua"


local ui_envelopes = {}

	

-- Envelope panel -----------------------------------------------------------


local env_type_names = { [0] = "adsr", "lfo", "custom" }
local lfo_shape_names = { [0] = "sine", "tri", "saw", "isaw", "square", "pulse" }


function ui_envelopes.make_label(env_id)
	local env_type = sfx.env_type(app.instrument, env_id)
	return env_type_names[env_type] .. " " .. env_id
end


function ui_envelopes.attach_panel(parent, el)
	el.width = el.large and (2 * app.mod_width + app.synth_gap) or app.mod_width
	if not el.large and el.x > 200 then
		-- TODO: clean this up...
		el.width += 1
	end
	el.height = app.mod_height
	parent:attach(el)

	el:attach(ui.create_menu_button {
		x = 2, y = 0, 
		env_id = el.env_id,
		get_label = function()
			return ui_envelopes.make_label(el.env_id)
		end,
		fg = 7,
		highlight = 29,
		items = {
			{ label = "adsr", action = function() sfx.set_env_type(app.instrument, el.env_id, 0); app.refresh_gui = true end },
			{ label = "lfo", action = function() sfx.set_env_type(app.instrument, el.env_id, 1); app.refresh_gui = true end },
			{ label = "custom", action = function() sfx.set_env_type(app.instrument, el.env_id, 2); app.refresh_gui = true end },
		}
	})
	
	if not el.large then
		ui_envelopes.attach_advanced_button(el, { x = el.width - 12, y = 0 })
	end

	if not app.env_advanced[el.env_id] then 

		local env_type = sfx.env_type(app.instrument, el.env_id)	
		if env_type == 0 then
			-- ADSR ----------------------------------------------
			local labels = { [0] = "a", "d", "s", "r" }
			for i = 0, 3 do
				ui_envelopes.attach_slider(el, { x = 3 + 13 * i, y = 12, slider_height = 40, env_id = el.env_id, param = i, label = labels[i] })
			end
			
		elseif env_type == 1 then
			-- LFO -----------------------------------------------
			local items = {}
			for i = 0, #lfo_shape_names do
				add(items, { label = lfo_shape_names[i], action = function() sfx.set_env_param(app.instrument, el.env_id, 5, i) end })
			end
			--[[ not yet implemented?
			ui_envelopes.attach_menu_button(el, {
				x = 14, y = 12, 
				env_id = el.env_id,
				get_label = function()
					local shape = sfx.env_param(app.instrument, el.env_id, 5)
					return lfo_shape_names[shape] or "???"
				end,
				fg = 5,
				highlight = 29,
				items = items,
			})
			]]--
			ui_envelopes.attach_slider(el, { x = 8, y = 12, slider_height = 40, env_id = el.env_id, param = 4, label = "freq" })
			ui_envelopes.attach_slider(el, { x = 34, y = 12, slider_height = 40, env_id = el.env_id, param = 6, label = "phase" })
			

		else
			-- Custom -------------------------------------
			el:attach(ui.create_checkbox {
				x = 4, y = 12,
				label = "lerp",
				check_fg = 18,
				get = function() return
					(sfx.env_flags(app.instrument, el.env_id) & 0x01) > 0
				end,
				set = function(v)
					local flags = sfx.env_flags(app.instrument, el.env_id)
					sfx.set_env_flags(app.instrument, el.env_id, (flags & ~0x01) | (v and 0x01 or 0x00))
				end,
			})
			ui_envelopes.attach_custom_editor(el, { x = 4, y = 20 })
			el:attach(ui.create_num_field {
				x = 4, y = 63,
				width = 56,
				label = "speed:",
				field_fg = 29,
				visible = function() return true end,
				get = function() return sfx.env_speed(app.instrument, el.env_id) end,
				set = function(v) sfx.set_env_speed(app.instrument, el.env_id, v) end,
			})
		end
	end
	
	if el.large or app.env_advanced[el.env_id] then
		el:attach(ui.create_checkbox {
			x = el.width - app.mod_width + 4, y = 12,
			label = "loop",
			check_fg = 18,
			visible = function() return sfx.env_type(app.instrument, el.env_id) != 2 end,
			get = function() return
				(sfx.env_flags(app.instrument, el.env_id) & 0x10) > 0
			end,
			set = function(v)
				local flags = sfx.env_flags(app.instrument, el.env_id)
				sfx.set_env_flags(app.instrument, el.env_id, (flags & ~0x10) | (v and 0x10 or 0x00))
			end,
		})
		el:attach(ui.create_num_field {
			x = el.width - app.mod_width + 0, y = 22,
			label = "speed:",
			field_fg = 29,
			visible = function() return (sfx.env_flags(app.instrument, el.env_id) & 0x10 > 0) or (sfx.env_type(app.instrument, el.env_id) == 2) end,
			get = function() return sfx.env_speed(app.instrument, el.env_id) end,
			set = function(v) sfx.set_env_speed(app.instrument, el.env_id, v) end,
		})
		el:attach(ui.create_num_field {
			x = el.width - app.mod_width + 0, y = 32,
			label = "start:",
			field_fg = 28,
			onclick = function() if (not el.large) ui_visual.open_custom_envelope(el.env_id) end,
			onrelease = function() if (not el.large) ui_visual.close() end,
			visible = function() return (sfx.env_flags(app.instrument, el.env_id) & 0x10 > 0) or (sfx.env_type(app.instrument, el.env_id) == 2) end,
			get = function() return sfx.env_start(app.instrument, el.env_id) end,
			set = function(v) sfx.set_env_start(app.instrument, el.env_id, v) end,
		})
		el:attach(ui.create_checkbox {
			x = el.width - app.mod_width + 4, y = 42,
			label = "rnd start",
			check_fg = 18,
			visible = function() return (sfx.env_flags(app.instrument, el.env_id) & 0x10 > 0) or (sfx.env_type(app.instrument, el.env_id) == 2) end,
			get = function() return
				(sfx.env_flags(app.instrument, el.env_id) & 0x08) > 0
			end,
			set = function(v)
				local flags = sfx.env_flags(app.instrument, el.env_id)
				sfx.set_env_flags(app.instrument, el.env_id, (flags & ~0x08) | (v and 0x08 or 0x00))
			end,
		})
		el:attach(ui.create_num_field {
				x = el.width - app.mod_width + 0, y = 52,
				label = "loop0:",
				field_fg = 26,
				onclick = function() if (not el.large) ui_visual.open_custom_envelope(el.env_id) end,
				onrelease = function() if (not el.large) ui_visual.close() end,
				visible = function() return (sfx.env_flags(app.instrument, el.env_id) & 0x10 > 0) or (sfx.env_type(app.instrument, el.env_id) == 2) end,
				get = function() return sfx.env_loop0(app.instrument, el.env_id) end,
				set = function(v) sfx.set_env_loop0(app.instrument, el.env_id, v) end,
		})
		el:attach(ui.create_num_field {
				x = el.width - app.mod_width + 0, y = 62,
				label = "loop1:",
				field_fg = 10,
				onclick = function() if (not el.large) ui_visual.open_custom_envelope(el.env_id) end,
				onrelease = function() if (not el.large) ui_visual.close() end,
				visible = function() return (sfx.env_flags(app.instrument, el.env_id) & 0x10 > 0) or (sfx.env_type(app.instrument, el.env_id) == 2) end,
				get = function() return sfx.env_loop1(app.instrument, el.env_id) end,
				set = function(v) sfx.set_env_loop1(app.instrument, el.env_id, v) end,
		})
	end
	
	function el:draw()
		rectfill(0, 0, self.width, 8, 18)
		---rectfill(0, 9, self.width, self.height, 6)
		ui_envelopes.draw_corners(self)
	end
	
	function el:click()
		return true
	end
		
	return el
end

	
function ui_envelopes.draw_corners(el)
	pset(0, 0, 6)
	pset(el.width - 1, 0, 6)
	pset(0, 8, 6)
	pset(el.width - 1, 8, 6)
end


function ui_envelopes.attach_slider(parent, el)
	el.width = 13
	el.height = el.slider_height + 20
	el.cursor = get_spr(50)
	parent:attach(el)
	function el:draw()
		---rectfill(0, 0, self.width - 1, self.height - 1, 7)
		local oy = 9
		for i = 0, 8, 1 do
			local h = math.floor(0.5 + (i / 8) * (el.slider_height - 1))
			if i % 8 == 0 then
				line(0, oy + el.slider_height - 1 - h, 12, oy + el.slider_height - 1 - h, 7)
			elseif i % 4 == 0 then
				line(2, oy + el.slider_height - 1 - h, 10, oy + el.slider_height - 1 - h, 7)
			else
				line(4, oy + el.slider_height - 1 - h, 8, oy + el.slider_height - 1 - h, 7)
			end
		end
		local val = sfx.env_param(app.instrument, self.env_id, self.param)
		local h = math.floor(0.5 + (val / 255) * (el.slider_height - 1))
		spr(60, 2, oy + el.slider_height - 1 - h - 3)
		line(6, oy, 6, oy + el.slider_height - 1, 59)
		if (self.dragged) pal(15, 7)
		spr(61, 2, oy + el.slider_height - 1 - h - 3)
		pal(15, 15)
		clip()
		ui.print_centered(self.label, 4 + 3, 0, 5)
		ui.print_centered(tostr(val), 4 + 3, self.height - 7, self.dragged and 59 or 58)
	end
	--[[function el:update(msg)
		if (app.has_modal()) return
		local mx, my, mb = mouse()
		if mb != 0 then
			self.hovered = self.dragged != nil
		else
			self.hovered = self.sx <= mx and mx < self.sx + self.width
				and self.sy <= my and my < self.sy + self.height
		end
	end]]
	function el:click(msg)
		undo.checkpoint()
		self.cursor = 0
		self.dragged = true
	end
	function el:drag(msg)
		if self.dragged then
			local delta = ui.mouselock()
			local old = sfx.env_param(app.instrument, self.env_id, self.param)
			local new = old - delta
			new = mid(0, new, 255)
			sfx.set_env_param(app.instrument, self.env_id, self.param, new)
		end
	end
	function el:release(msg)
		ui.mouseunlock()
		self.cursor = get_spr(50)
		self.dragged = nil
	end
	return el
end


function ui_envelopes.attach_advanced_button(parent, el)
	el.width = 10
	el.height = 10
	el.cursor = "pointer"
	parent:attach(el)
	function el:draw()
		spr(39, 1, 1)
	end
	function el:tap()
		app.env_advanced[parent.env_id] = not app.env_advanced[parent.env_id]
		app.refresh_gui = true
	end
	return el
end


-- Custrom envelopes ------------------------------------------------------------


function ui_envelopes.attach_custom_editor(parent, el)
	el.width = 50
	el.height = 42
	el.cursor = "crosshair"
	parent:attach(el)
	el.env_id = parent.env_id
	el.draw = ui_visual.draw_custom_envelope
	function el:drag(msg)
		local param = mid(0, (msg.mx - 1) \ 3, 15)
		local val = ((self.height - 1 - msg.my) * 255) / (self.height - 2)
		local val = mid(0, math.floor(0.5 + val), 255)
		sfx.set_env_param(app.instrument, parent.env_id, param, val)
	end
	function el:update()
		local mx, my, mb = mouse()
		if
			self.sx <= mx and mx < self.sx + self.width
			and self.sy <= my and my < self.sy + self.height
		then
			local param = mid(0, (mx - self.sx - 1) \ 3, 15)
			self.selected = param
		else
			self.selected = nil
		end
	end
	return el
end


return ui_envelopes
:: src/ui_menus.lua
--[[pod_format="raw",created="2024-04-20 10:41:15",modified="2026-01-30 18:48:07",revision=11526]]
local app = require "src/app.lua"
local sfx = require "src/sfx.lua"
local ui = require "src/ui.lua"
local ui_envelopes = require "src/ui_envelopes.lua"


local ui_menus = {}


-- Relationship menu -----------------------------------------------------


function ui_menus.open_relationship(self)
	local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
	local node_type = sfx.node_type(app.instrument, self.parent.node_id)
	
	if node_type == 0x2 and self.parent.param == 2 then
		ui.open_menu {
			x = self.sx - 10, y = self.sy + 7,
			width = 55,
			items = {
				{
					label = (flags & 0x03 == 0x00)
						and "\|f\^:1c225d5d5d221c00\|h set"
						or "\|f\^:1c22414141221c00\|h set",
					action = function()
						self.parent.min_val, self.parent.max_val = -128, 127
						local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
						-- set bit: replace parent
						sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, flags & ~0x3)
					 end,
				},
				{
					label = (flags & 0x03 == 0x01)
						and "\|f\^:1c225d5d5d221c00\|h add"
						or "\|f\^:1c22414141221c00\|h add",
					action = function()
						self.parent.min_val, self.parent.max_val = -128, 127
						local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
						-- set bit: add parent
						sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, (flags & ~0x3) | 0x1)
					 end,
				},
				{
					label = (flags & 0x03 == 0x02)
						and "\|f\^:1c225d5d5d221c00\|h multiply"
						or "\|f\^:1c22414141221c00\|h multiply",
					action = function()
						self.parent.min_val, self.parent.max_val = 0, 255
						local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
						-- set bit: mul parent
						sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, (flags & ~0x3) | 0x2)
					 end,
				},
				{ divider = true },
				{
					label = 
						(flags & 0x20 > 0)
							and "\|f\^:7f415d5d5d417f00\|h quantized"
							or "\|f\^:7f41414141417f00\|h quantized",
					action = function()
						local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
						sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, flags ^^ 0x20)
					 end,
				},
			}
		}
	elseif
		(node_type == 0x02 and self.parent.param == 0)
		or (node_type == 10 and self.parent.param == 3)
		or (node_type == 8 and self.parent.param == 2)
	then
		ui.open_menu {
			x = self.sx - 10, y = self.sy + 7,
			width = 52,
			items = {
				{
					label = (flags & 0x03 == 0x00)
						and "\|f\^:1c225d5d5d221c00\|h set"
						or "\|f\^:1c22414141221c00\|h set",
					action = function()
						local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
						-- set bit: replace parent
						sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, flags & ~0x3)
					 end,
				},
				{
					label = (flags & 0x03 == 0x02)
						and "\|f\^:1c225d5d5d221c00\|h multiply"
						or "\|f\^:1c22414141221c00\|h multiply",
					action = function()
						local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
						-- set bit: mul parent
						sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, (flags & ~0x3) | 0x2)
					 end,
				},
			}
		}
	elseif
		(node_type == 8 and self.parent.param ~= 2)
		or (node_type == 9)
		or (node_type == 10 and self.parent.param ~= 3)
	then
		-- no menu
	else
		ui.open_menu {
			x = self.sx - 10, y = self.sy + 7,
			width = 40,
			items = {
				{
					label = (flags & 0x03 == 0x00)
						and "\|f\^:1c225d5d5d221c00\|h set"
						or "\|f\^:1c22414141221c00\|h set",
					action = function()
						local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
						-- set bit: replace parent
						sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, flags & ~0x3)
					 end,
				},
				{
					label = (flags & 0x03 == 0x01)
						and "\|f\^:1c225d5d5d221c00\|h add"
						or "\|f\^:1c22414141221c00\|h add",
					action = function()
						local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
						-- set bit: add parent
						sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, (flags & ~0x3) | 0x1)
					 end,
				},
			}
		}
	end
end


-- Multiplier menu -------------------------------------------------------------


function ui_menus.open_multiplier(self)
	local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
	
	local mult_options = { 
		[0] = 
		{ label = "none", val = 0x00 | 0x00 },
		{ label = "*4", val = 0x00 | 0x40 },
		{ label = "/4", val = 0x20 | 0x40 },
		{ label = "*16", val = 0x00 | 0x80 },
		{ label = "/16", val = 0x20 | 0x80 },
		{ label = "*64", val = 0x00 | 0xc0 },
		{ label = "/64", val = 0x20 | 0xc0 },
	}
	local mult_menu_items = {}
	for i = 0, #mult_options do
		add(mult_menu_items, 
			{
				label = (env & 0xe0 == mult_options[i].val)
					and ("\|f\^:1c225d5d5d221c00\|h " .. mult_options[i].label)
					or ("\|f\^:1c22414141221c00\|h " .. mult_options[i].label),
				fg = i == 0 and 5 or 24,
				action = function()
					local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
					sfx.set_node_param_env(app.instrument, self.parent.node_id, self.parent.param, (env & ~0xe0) | mult_options[i].val)
				 end,
			}
		)
	end

	ui.open_menu {
		x = self.sx - 10, y = self.sy + 7,
		width = 36,
		items = mult_menu_items,
	}
end


-- Envelope menu ------------------------------------------------------------------


function ui_menus.open_envelope(self)
	local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
	local has_env = flags & 0x04 > 0
	local has_free_run = flags & 0x08 > 0
	local has_random = flags & 0x10 > 0
	local env_id = env & 0x0f
	ui.open_menu {
		x = self.sx - 10, y = self.sy + 7,
		width = 51,
		items = {
			{
				label = (not has_env and not has_random)
					and "\|f\^:1c225d5d5d221c00\|h none"
					or "\|f\^:1c22414141221c00\|h none",
				fg = 5,
				action = function()
					local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
					sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, flags & ~(0x4 | 0x8 | 0x10))
				 end,
			},
			{
				label = (has_env and env_id == 0)
					and ("\|f\^:1c225d5d5d221c00\|h " .. ui_envelopes.make_label(0))
					or ("\|f\^:1c22414141221c00\|h " .. ui_envelopes.make_label(0)),
				fg = 18,
				action = function()
					local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
					sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, (flags & ~0x10) | 0x4)
					sfx.set_node_param_env(app.instrument, self.parent.node_id, self.parent.param, (env & 0xf0) | 0)
				 end,
			},
			{
				label = (has_env and env_id == 1)
					and ("\|f\^:1c225d5d5d221c00\|h " .. ui_envelopes.make_label(1))
					or ("\|f\^:1c22414141221c00\|h " .. ui_envelopes.make_label(1)),
				fg = 18,
				action = function()
					local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
					sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, (flags & ~0x10) | 0x4)
					sfx.set_node_param_env(app.instrument, self.parent.node_id, self.parent.param, (env & 0xf0) | 1)
				 end,
			},
			{
				label = (has_env and env_id == 2)
					and ("\|f\^:1c225d5d5d221c00\|h " .. ui_envelopes.make_label(2))
					or ("\|f\^:1c22414141221c00\|h " .. ui_envelopes.make_label(2)),
				fg = 18,
				action = function()
					local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
					sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, (flags & ~0x10) | 0x4)
					sfx.set_node_param_env(app.instrument, self.parent.node_id, self.parent.param, (env & 0xf0) | 2)
				end,
			},
			{
				label = (has_env and env_id == 3)
					and ("\|f\^:1c225d5d5d221c00\|h " .. ui_envelopes.make_label(3))
					or ("\|f\^:1c22414141221c00\|h " .. ui_envelopes.make_label(3)),
				fg = 18,
				action = function()
					local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
					sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, (flags & ~0x10) | 0x4)
					sfx.set_node_param_env(app.instrument, self.parent.node_id, self.parent.param, (env & 0xf0) | 3)
				end,
			},
			{
				label = has_random
						and "\|f\^:1c225d5d5d221c00\|h random"
						or "\|f\^:1c22414141221c00\|h random",
				fg = 30,
				action = function()
					local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
					sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, (flags & ~0x4) | 0x10)
				 end,
			},
			{
				divider = true,
			},
			{
				label = has_free_run
							and "\|f\^:7f415d5d5d417f00\|h free run"
							or "\|f\^:7f41414141417f00\|h free run",
				fg = 5,
				action = function()
					local flags, val1, val0, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
					sfx.set_node_param_flags(app.instrument, self.parent.node_id, self.parent.param, flags ^^ 0x08)
				 end,
			},
		}
	}
end


return ui_menus
:: src/ui_nodes.lua
--[[pod_format="raw",created="2024-04-12 16:30:23",modified="2026-01-30 18:48:07",revision=18101]]
local app = require "src/app.lua"
local sfx = require "src/sfx.lua"
local ui = require "src/ui.lua"
local ui_envelopes = require "src/ui_envelopes.lua"
local ui_params = require "src/ui_params.lua"
local ui_visual = require "src/ui_visual.lua"


local ui_nodes = {}


-- Node panels --------------------------------------------------------------------


function ui_nodes.attach_node_panel(parent, el)
	if app.node and app.node == el.node_id then
		el.width = 480 - 4 * app.mod_width - 6 * app.synth_gap + 2
		el.height = 2 * app.synth_height + app.synth_gap
	else
		el.width = app.synth_width
		el.height = app.synth_height
	end
	parent:attach(el)
	
	local type = sfx.node_type(app.instrument, el.node_id)
	if el.node_id == 0 then return ui_nodes.populate_root(parent, el)
	elseif type == 0 then return ui_nodes.populate_unused(parent, el)
	elseif type == 2 then
		local op = sfx.node_op(app.instrument, el.node_id)
		if op == 0 then return ui_nodes.populate_osc(parent, el)
		elseif op == 1 then return ui_nodes.populate_fm(parent, el)
		elseif op == 2 then return ui_nodes.populate_ring(parent, el)
		end
	elseif type == 8 then return ui_nodes.populate_filt(parent, el)
	elseif type == 9 then return ui_nodes.populate_echo(parent, el)
	elseif type == 10 then return ui_nodes.populate_shap(parent, el)
	end
	return ui_nodes.populate_unknown(parent, el)
end


-- Unused slot -------------------------------------------------------------------------------


function ui_nodes.populate_unused(parent, el)
	function el:draw()
		clip()
		local x, y = 19, 14
		pal(7, 57)
		sspr(63, 0, 0, 7, 7, x, y, x + (7 * 4), y + (7 * 4))
--		spr(62, x, y)
		pal(7, 7)
		if self.node_id == 7 then
			print("pfx6416", 52, 63, 22)
		end
	end
	return el
end


-- Root Synth Node ---------------------------------------------------------------------------


local instrument_name_field


function ui_nodes.populate_root(parent, el)
	local params = {
		[0] = { label = "vol", long_label = "volume", param = 0,
			min_val = 0, max_val = 64, init_val = 32, sensitivity = 0.25 },
		{ label = "pan", param = 1, min_val = -128, max_val = 127, },
		{ label = "tune", param = 2, min_val = -128, max_val = 127, },
		{ label = "bend", param = 3, min_val = -128, max_val = 127, },
	}
	for i = 0, #params do params[i].node_id = el.node_id end

	if el.large then
		ui_params.attach(el, 30, 84, params[0], { emphasis = true})
		ui_params.attach(el, 70, 84, params[1], { small = true })
		params[2].x, params[2].y = 112, 125
		ui_params.attach_mini(el, params[2])
		params[3].x, params[3].y = 112, 135
		ui_params.attach_mini(el, params[3])
--		ui_params.attach(el, 130, 84, params[2], { small = true })
--		ui_params.attach(el, 170, 84, params[3], { small = true })
		el:attach(ui_nodes.instrument_flag_toggle { x = 120, y = 84, label = "wide", flag = 0x02 })
		el:attach(ui_nodes.instrument_flag_toggle { x = 160, y = 84, label = "retrig", flag = 0x01 })
		ui_visual.attach_oscilloscope(el, 8, { x = 20, y = 14, width = 184, height = 66 })

		-- TODO: replace with a custom field
		-- also: add the same field to the mini version
		instrument_name_field = el:attach_text_editor{
			x = 63, y = 1,
			width = 72, height = 7,
			bgcol = 58, fgcol = 59, curcol = 2,
			block_scrolling = true, max_lines = 1,
			margin_top = 1,
			key_callback = {
				enter = function () 
					sfx.set_instrument_name(app.instrument, instrument_name_field:get_text()[1])
					instrument_name_field:set_keyboard_focus(false)
				end
			},
			update = function(self)
				-- update in realtime -- don't need to press enter to change
				if (instrument_name_field:has_keyboard_focus()) then
					sfx.set_instrument_name(app.instrument, instrument_name_field:get_text()[1])
				end
			end
		}
		instrument_name_field:set_text{sfx.instrument_name(app.instrument)}
	else
		ui_params.attach_mini(el, params[0])
		ui_params.attach_mini(el, params[1])
		ui_params.attach_mini(el, params[2])
		ui_params.attach_mini(el, params[3])
		--- slider.attach(el, { label = "p0", param = 4, node_id = el.node_id } )
		--- slider.attach(el, { label = "p1", param = 5, node_id = el.node_id } )
		el:attach(ui_nodes.instrument_flag_toggle { x = 5, y = 51, label = "wide", flag = 0x02 })
		el:attach(ui_nodes.instrument_flag_toggle { x = 45, y = 51, label = "retrig", flag = 0x01 })
	end
	function el:draw()
		rectfill(0, 0, self.width, 8, 7)
		ui_nodes.draw_corners(self)
		print("instrument ", 4, 2, 22)
		print(string.format("%02x", app.instrument), 50, 2, 44)
		print(":", 58, 2, 58)
	end
	function el:click() return true end
	function el:doubleclick() app.node = self.node_id; app.refresh_gui = true end
	return el
end


-- Oscillator -------------------------------------------------------------------


local wt_labels = { [0] = "wt0", "wt1", "wt2", "wt3" }
local wt_long_labels = { [0] = "wavetable 0", "wavetable 1", "wavetable 2", "wavetable 3" }
local osc_params = {
	[0] = { label = "vol", long_label = "volume", param = 0,
		min_val = 0, max_val = 64, init_val = 32, sensitivity = 0.25 },
	{ label = "pan", param = 1, min_val = -128, max_val = 127, },
	{ label = "tune", param = 2, min_val = -128, max_val = 127, },
	{ label = "bend", param = 3, min_val = -128, max_val = 127, },
	{ label = "", long_label = "wave", param = 4, min_val = 0, max_val = 255, },
	{ label = "phase", param = 5, min_val = -128, max_val = 127, },
}

function ui_nodes.populate_osc(parent, el)
	local params = unpod(pod(osc_params))
	-- closures are not copied by unpod/pod?
	params[4].onclick = function(self) ui_visual.open_wavetable(self) end
	params[4].onrelease = function(self) ui_visual.close() end
	params[5].onclick = params[4].onclick
	params[5].onrelease = params[4].onrelease
	
	for i = 0, #params do params[i].node_id = el.node_id end
	local flags, _, _, _ = sfx.node_param(app.instrument, el.node_id, 2)
	if flags & 0x03 == 0x02 then
		-- tune param in "multiply" relationship:
		-- change the min and max values
		params[2].min_val = 0
		params[2].max_val = 255
	end

	ui_nodes.attach_mute_toggle(el, { label = "osc", node_id = el.node_id })
	ui_nodes.attach_close_button(el, { node_id = el.node_id })
	if el.large then
		ui_params.attach(el, 20, 16, params[0], { emphasis = true})
		ui_params.attach(el, 60, 16, params[1], { small = true })
		ui_params.attach(el, 20, 84, params[2], { small = true })
		ui_params.attach(el, 60, 84, params[3], { small = true })
		local wave = ui_params.attach(el, 130, 84, params[4], { emphasis = true })
		ui_visual.attach_wavetable(el, wave, { x = 114, y = 14, width = 104, height = 58 })
		ui_params.attach(el, 170, 84, params[5], { small = true })
		el:attach(ui.create_menu_button {
			x = 142, y = 72,
			get_label = function()
				local wt = sfx.node_osc_wavetable(app.instrument, el.node_id)
				return wt_long_labels[wt] or "wt?"
			end,
			fg = 5,
			highlight = 15,
			items = {
				{ label = "wavetable 0", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 0) end },
				{ label = "wavetable 1", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 1) end },
				{ label = "wavetable 2", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 2) end },
				{ label = "wavetable 3", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 3) end },
			}
		})
	else
		ui_params.attach_mini(el, params[0])
		ui_params.attach_mini(el, params[1])
		ui_params.attach_mini(el, params[2])
		ui_params.attach_mini(el, params[3])
		ui_params.attach_mini(el, params[4])
		ui_params.attach_mini(el, params[5])
		el:attach(ui.create_menu_button {
			x = 2, y = 51,
			get_label = function()
				local wt = sfx.node_osc_wavetable(app.instrument, el.node_id)
				return wt_labels[wt] or "wt?"
			end,
			fg = 5,
			highlight = 15,
			items = {
				{ label = "wt 0", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 0) end },
				{ label = "wt 1", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 1) end },
				{ label = "wt 2", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 2) end },
				{ label = "wt 3", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 3) end },
			}
		})
	end
	
	function el:click() return true end
	function el:doubleclick() app.node = self.node_id; app.refresh_gui = true end
		
	function el:draw()
		rectfill(0, 0, self.width, 8, 17)
		ui_nodes.draw_corners(self)
	end
	
	return el
end


-- FM modulator -------------------------------------------------------------------


function ui_nodes.populate_fm(parent, el)
	local params = unpod(pod(osc_params))
	-- closures are not copied by unpod/pod?
	params[4].onclick = function(self) ui_visual.open_wavetable(self) end
	params[4].onrelease = function(self) ui_visual.close() end
	params[5].onclick = params[4].onclick
	params[5].onrelease = params[4].onrelease
	
	for i = 0, #params do params[i].node_id = el.node_id end
	local flags, _, _, _ = sfx.node_param(app.instrument, el.node_id, 2)
	if flags & 0x03 == 0x02 then
		-- tune param in "multiply" relationship:
		-- change the min and max values
		params[2].min_val = 0
		params[2].max_val = 255
	end

	ui_nodes.attach_mute_toggle(el, { label = "fm", node_id = el.node_id })
	ui_nodes.attach_close_button(el, { node_id = el.node_id })
	if el.large then
		ui_params.attach(el, 20, 16, params[0], { emphasis = true})
		ui_params.attach(el, 60, 16, params[1], { small = true })
		ui_params.attach(el, 20, 84, params[2], { small = true })
		ui_params.attach(el, 60, 84, params[3], { small = true })
		local wave = ui_params.attach(el, 130, 84, params[4], { emphasis = true })
		ui_visual.attach_wavetable(el, wave, { x = 114, y = 14, width = 104, height = 58 })
		ui_params.attach(el, 170, 84, params[5], { small = true })
		el:attach(ui.create_menu_button {
			x = 142, y = 72,
			get_label = function()
				local wt = sfx.node_osc_wavetable(app.instrument, el.node_id)
				return wt_long_labels[wt] or "wt?"
			end,
			fg = 5,
			highlight = 15,
			items = {
				{ label = "wavetable 0", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 0) end },
				{ label = "wavetable 1", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 1) end },
				{ label = "wavetable 2", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 2) end },
				{ label = "wavetable 3", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 3) end },
			}
		})
	else
		ui_params.attach_mini(el, params[0])
		ui_params.attach_mini(el, params[1])
		ui_params.attach_mini(el, params[2])
		ui_params.attach_mini(el, params[3])
		ui_params.attach_mini(el, params[4])
		ui_params.attach_mini(el, params[5])
		el:attach(ui.create_menu_button {
			x = 2, y = 51,
			get_label = function()
				local wt = sfx.node_osc_wavetable(app.instrument, el.node_id)
				return wt_labels[wt] or "wt?"
			end,
			fg = 5,
			highlight = 15,
			items = {
				{ label = "wt 0", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 0) end },
				{ label = "wt 1", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 1) end },
				{ label = "wt 2", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 2) end },
				{ label = "wt 3", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 3) end },
			}
		})
	end
	
	function el:click() return true end
	function el:doubleclick() app.node = self.node_id; app.refresh_gui = true end
		
	function el:draw()
		rectfill(0, 0, self.width, 9, 27)
		ui_nodes.draw_corners(self)
	end
	
	return el
end


-- Ring mod -------------------------------------------------------------------


function ui_nodes.populate_ring(parent, el)
	local params = unpod(pod(osc_params))
	-- closures are not copied by unpod/pod?
	params[4].onclick = function(self) ui_visual.open_wavetable(self) end
	params[4].onrelease = function(self) ui_visual.close() end
	params[5].onclick = params[4].onclick
	params[5].onrelease = params[4].onrelease
	
	for i = 0, #params do params[i].node_id = el.node_id end
	local flags, _, _, _ = sfx.node_param(app.instrument, el.node_id, 2)
	if flags & 0x03 == 0x02 then
		-- tune param in "multiply" relationship:
		-- change the min and max values
		params[2].min_val = 0
		params[2].max_val = 255
	end

	ui_nodes.attach_mute_toggle(el, { label = "ring", node_id = el.node_id })
	ui_nodes.attach_close_button(el, { node_id = el.node_id })
	if el.large then
		ui_params.attach(el, 20, 16, params[0], { emphasis = true})
		ui_params.attach(el, 60, 16, params[1], { small = true })
		ui_params.attach(el, 20, 84, params[2], { small = true })
		ui_params.attach(el, 60, 84, params[3], { small = true })
		local wave = ui_params.attach(el, 130, 84, params[4], { emphasis = true })
		ui_visual.attach_wavetable(el, wave, { x = 114, y = 14, width = 104, height = 58 })
		ui_params.attach(el, 170, 84, params[5], { small = true })
		el:attach(ui.create_menu_button {
			x = 142, y = 72,
			get_label = function()
				local wt = sfx.node_osc_wavetable(app.instrument, el.node_id)
				return wt_long_labels[wt] or "wt?"
			end,
			fg = 5,
			highlight = 15,
			items = {
				{ label = "wavetable 0", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 0) end },
				{ label = "wavetable 1", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 1) end },
				{ label = "wavetable 2", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 2) end },
				{ label = "wavetable 3", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 3) end },
			}
		})
	else
		ui_params.attach_mini(el, params[0])
		ui_params.attach_mini(el, params[1])
		ui_params.attach_mini(el, params[2])
		ui_params.attach_mini(el, params[3])
		ui_params.attach_mini(el, params[4])
		ui_params.attach_mini(el, params[5])
		el:attach(ui.create_menu_button {
			x = 2, y = 51,
			get_label = function()
				local wt = sfx.node_osc_wavetable(app.instrument, el.node_id)
				return wt_labels[wt] or "wt?"
			end,
			fg = 5,
			highlight = 15,
			items = {
				{ label = "wt 0", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 0) end },
				{ label = "wt 1", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 1) end },
				{ label = "wt 2", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 2) end },
				{ label = "wt 3", action = function() sfx.set_node_osc_wavetable(app.instrument, el.node_id, 3) end },
			}
		})
	end
	
	function el:click() return true end
	function el:doubleclick() app.node = self.node_id; app.refresh_gui = true end
		
	function el:draw()
		rectfill(0, 0, self.width, 9, 22)
		ui_nodes.draw_corners(self)
	end
	
	return el
end


-- Filter ----------------------------------------------------------------------


function ui_nodes.populate_filt(parent, el)
	local params = {
		[0] =
		{ label = "low", param = 0, min_val = 0, max_val = 255, },
		{ label = "high", param = 1, min_val = 0, max_val = 255, },
		{ label = "res", param = 2, min_val = 0, max_val = 255, },
	}
	for i = 0, #params do params[i].node_id = el.node_id end
	
	ui_nodes.attach_mute_toggle(el, { label = "filt", node_id = el.node_id })
	ui_nodes.attach_close_button(el, { node_id = el.node_id })
	if el.large then
		ui_params.attach(el, 34, 50, params[0], {})
		ui_params.attach(el, 94, 50, params[2], {})
		ui_params.attach(el, 154, 50, params[1], {})
	else
		ui_params.attach_mini(el, params[0])
		ui_params.attach_mini(el, params[2])
		ui_params.attach_mini(el, params[1])
	end
	function el:draw()
		rectfill(0, 0, self.width, 9, 14)
		ui_nodes.draw_corners(self)
	end
	function el:click() return true end
	function el:doubleclick() app.node = self.node_id; app.refresh_gui = true end
	return el
end


-- Delay --------------------------------------------------------------------------


function ui_nodes.populate_echo(parent, el)
	local params = {
		[0] =
		{ label = "delay", param = 0, min_val = 0, max_val = 255, },
		{ label = "vol", param = 1, min_val = 0, max_val = 255, },
	}
	for i = 0, #params do params[i].node_id = el.node_id end
	
	ui_nodes.attach_mute_toggle(el, { label = "echo", node_id = el.node_id })
	ui_nodes.attach_close_button(el, { node_id = el.node_id })
	if el.large then
		ui_params.attach(el, 59, 84, params[0], {})
		ui_params.attach(el, 130, 84, params[1], {})
	else
		ui_params.attach_mini(el, params[0])
		ui_params.attach_mini(el, params[1])
	end
	function el:draw()
		rectfill(0, 0, self.width, 9, 31)
		ui_nodes.draw_corners(self)
	end
	function el:click() return true end
	function el:doubleclick() app.node = self.node_id; app.refresh_gui = true end
	return el
end


-- Waveshaper ------------------------------------------------------------------


function ui_nodes.populate_shap(parent, el)
	local params = {
		[0] =
		{ label = "gain", param = 0, min_val = 0, max_val = 255, },
		{ label = "elbow", param = 1, min_val = 0, max_val = 255, },
		{ label = "cut", param = 2, min_val = 0, max_val = 255, },
		{ label = "mix", param = 3, min_val = 0, max_val = 64, sensitivity = 0.25 },
	}
	for i = 0, #params do params[i].node_id = el.node_id end
	
	ui_nodes.attach_mute_toggle(el, { label = "shap", node_id = el.node_id })
	ui_nodes.attach_close_button(el, { node_id = el.node_id })
	if el.large then
		ui_params.attach(el, 20, 84, params[0], {})
		ui_params.attach(el, 60, 84, params[3], { small = true })
		ui_params.attach(el, 130, 84, params[2], {})
		ui_params.attach(el, 170, 84, params[1], {})
		local oscillo_id = sfx.nodes[el.node_id].parent.id
		ui_visual.attach_oscilloscope(el, 8, { x = 11, y = 16, width = 92, height = 60, node_id = oscillo_id })
	else
		ui_params.attach_mini(el, params[0])
		ui_params.attach_mini(el, params[1])
		ui_params.attach_mini(el, params[2])
		ui_params.attach_mini(el, params[3])
	end
	function el:draw()
		rectfill(0, 0, self.width, 9, 9)
		ui_nodes.draw_corners(self)
	end
	function el:click() return true end
	function el:doubleclick() app.node = self.node_id; app.refresh_gui = true end
	return el
end


-- Unknown --------------------------------------------------------------------------


function ui_nodes.populate_unknown(parent, el)
	local params = {
		[0] =
		{ label = "p0", param = 0, min_val = 0, max_val = 255, },
		{ label = "p1", param = 1, min_val = 0, max_val = 255, },
		{ label = "p2", param = 2, min_val = 0, max_val = 255, },
		{ label = "p3", param = 3, min_val = 0, max_val = 255, },
		{ label = "p4", param = 4, min_val = 0, max_val = 255, },
		{ label = "p5", param = 5, min_val = 0, max_val = 255, },
	}
	for i = 0, #params do params[i].node_id = el.node_id end
	
	ui_nodes.attach_mute_toggle(el, { label = "???", node_id = el.node_id })
	ui_nodes.attach_close_button(el, { node_id = el.node_id })
	ui_params.attach_mini(el, params[0])
	ui_params.attach_mini(el, params[1])
	ui_params.attach_mini(el, params[2])
	ui_params.attach_mini(el, params[3])
	ui_params.attach_mini(el, params[4])
	ui_params.attach_mini(el, params[5])
	function el:draw()
		rectfill(0, 0, self.width, self.height, 30)
		ui_nodes.draw_corners(self)
	end
	function el:click() return true end
	function el:doubleclick() app.node = self.node_id; app.refresh_gui = true end
	return el
end


-------------------------------------------------------------------------------------------------


function ui_nodes.instrument_flag_toggle(el)
	el.width = el.width or 35
	el.height = el.height or 9
	el.label = el.label or "---"
	el.cursor = "pointer"
	
	function el:draw()
		palt(59, true)
		pal(2, 0)
		pal(17, 18)
		if sfx.instrument_flag(app.instrument, el.flag) then
			spr(33, 0, 1)
		else
			spr(32, 0, 1)
		end
		pal(17, 17)
		pal(2, 2)
		palt(59, false)
		print(el.label, 10, 2, 5)
	end
	
	function el:tap()
		sfx.toggle_instrument_flag(app.instrument, el.flag)
	end
	
	return el
end


------------------------------------------------------------------------------------------------	


function ui_nodes.draw_corners(el)
--[[
	if app.node and app.node == el.node_id then 
		clip()
		rect(-1, -1, el.width, el.height, 24)
		pset(-1, -1, app.editor_bg)
		pset(el.width, -1, app.editor_bg)
		pset(-1, el.height, app.editor_bg)
		pset(el.width, el.height, app.editor_bg)
		col = 24
	end
--]]
	pset(0, 0, 6)
	pset(el.width - 1, 0, 6)
	pset(0, 8, 6)
	pset(el.width - 1, 8, 6)
end


-- Title bar widgets -------------------------------------------------------------


function ui_nodes.attach_mute_toggle(parent, el)
	el.x = 1
	el.y = 1
	el.width = 3 + 4 * #(el.label .. " " .. el.node_id) + 3
	el.height = 9
	el.cursor = "pointer"
	parent:attach(el)
	el.muted = (sfx.node_flags(app.instrument, el.node_id) & 0x2) > 0
	function el:draw()
		local label = self.label .. " " .. self.node_id
		print(label, 3, 1, 63)
		if self.muted then
			line(1, 3, 3 + 4 * #label, 3, 24)
		end
	end
	function el:click()
		return true -- don't pass to panel to avoid selection
	end
	function el:tap()
		self.muted = not self.muted
		local flags = sfx.node_flags(app.instrument, self.node_id)
		if self.muted then
			flags |= 0x2
		else
			flags &= ~0x2
		end
		sfx.set_node_flags(app.instrument, self.node_id, flags)
	end
	return el
end


function ui_nodes.attach_close_button(parent, el)
	el.x = parent.width - 10
	el.y = 2
	el.width = 12
	el.height = 9
	el.cursor = "pointer"
	parent:attach(el)
	function el:draw()
		pal(7, 63)
		spr(36, 0, 0)
		pal(7, 7)
	end
	function el:click()
		return true -- don't pass to panel to avoid selection
	end
	function el:tap()
		if app.node then
			if app.node == self.node_id then
				if #(sfx.nodes[app.node].children) > 0 then
					app.node = sfx.nodes[app.node].children[1].id
				else
					app.node = sfx.nodes[app.node].parent.id
				end
			end
		end
		sfx.delete_node(app.instrument, self.node_id)
		if app.node and app.node > self.node_id then
			app.node = max(0, self.node_id - 1)
		end
		app.refresh_gui = true
	end
	return el
end


return ui_nodes
:: src/ui_notegrid.lua
--[[pod_format="raw",created="2026-01-26 13:53:28",modified="2026-01-30 18:48:07",revision=7673]]
local app = require "src/app.lua"
local selection = require "src/selection.lua"
local sfx = require "src/sfx.lua"
local ui = require "src/ui.lua"
local ui_trakdial = require "src/ui_trakdial.lua"


local ui_notegrid = {}


local note_names <const> = {"c ","c\|f+","d ","d\|f+","e ","f ","f\|f+","g ","g\|f+","a ","a\|f+", "b "}
local note_names <const> = {"c ","c+","d ","d+","e ","f ","f+","g ","g+","a ","a+", "b "}
local hex_0 <const> = {}
for i = 0, 15 do
	hex_0[i] = string.format("%1x", i)
end
local hex_00 <const> = {}
for i = 0, 255 do
	hex_00[i] = string.format("%02x", i)
end


----------------------------------------------------------------------------------------------------
-- Note Grid
----------------------------------------------------------------------------------------------------


local w_note <const> = 11
local w_octave <const> = 7
local w_instrument <const> = 11
local w_volume <const> = 11
local w_fx <const> = 16


local x_note <const> = 0
local x_octave <const> = w_note
local x_instrument <const> = w_note + w_octave
local x_volume <const> = w_note + w_octave + w_instrument
local x_fx <const> = w_note + w_octave + w_instrument + w_volume


local fgd_note = 42
local fg_note = 43
local fgd_octave = 50
local fg_octave = 51
local fgd_inst = 44
local fg_inst = 45
local fgd_vol = 46
local fg_vol = 47
local fgd_fx = 48
local fg_fx = 49


function ui_notegrid.attach(parent, el)
	el.length_beat = 4
	el.length_bar = 4 * el.length_beat
	el.start = 0
	parent:attach(el)
	
	function el:draw()
		if sfx.channel_is_muted(app.pattern, self.channel) then
			return
		end
		local pattern_is_playing <const> =
			sfx.playing_channels() != 0
			and sfx.playing_pattern() == app.pattern
		local track <const> = sfx.pattern_track(app.pattern, self.channel)
		local track_length <const> = sfx.track_length(track)
		local track_loop0 <const> = sfx.track_loop0(track)
		local track_loop1 <const> = sfx.track_loop1(track)
		local track_is_looping <const> = sfx.track_is_looping(track)
		local start <const> = self.start
		local nb_rows <const> = math.ceil(self.height / app.height_row)
		local selection_parts <const> = selection.parts()
		local track_size <const> = sfx.track_size(track)
		if sfx.track_size(track) == 0 then
			local x = app.width_column // 2
			local y = self.height // 2
			ui.print_centered("click", x, y, 52)
			ui.print_centered("to create", x, y + 8, 52)
			ui.print_centered("new track", x, y + 16, 52)
			return
		end
		-- TODO: pattern_max_size
		-- Hot Loop for the Notes
		-- local current_inst = 0xff -- TODO: unused, remove?
		-- local current_vol = 0xff
		for row = 0, nb_rows - 1 do
			local step <const> = start + row
			local x <const> = 0
			local y <const> = row * app.height_row
			local y_text <const> = y + math.ceil((app.height_row - 5) / 2)
			if step < 0 then
				goto continue
			elseif step >= track_size then
				--line(x, y, x + app.width_column - 2, y, 36)
				break
			end
			local is_greyed = step >= track_length
			local is_selected <const> =
				selection.has_channel(self.channel) 
				and selection.has_step(step)
			local step_is_playing <const> =
				sfx.playing_channel_row(self.channel) == step
			if pattern_is_playing and step_is_playing then
				rrectfill(x, y, app.width_column - 1, app.height_row, 0, 36)
			elseif step % self.length_bar == 0 then
				rrectfill(x, y, app.width_column - 1, app.height_row, 0, 35)
--				rrectfill(x, y, app.width_column - 1, app.height_row, 0, 34)
--				line(x, y, app.width_column - 2, y, 35)
--				line(x, y + app.height_row - 1, app.width_column - 2, y + app.height_row - 1, 35)
			elseif step % self.length_beat == 0 then
				rrectfill(x, y, app.width_column - 1, app.height_row, 0, 34)
			end
			local freq <const> = sfx.track_pitch(track, step)
			local inst <const> = sfx.track_instrument(track, step)
			local vol <const> = sfx.track_volume(track, step)
			local fx <const> = sfx.track_fx(track, step)
			local fxp0 <const> = sfx.track_fx_param0(track, step)
			local fxp1 <const> = sfx.track_fx_param1(track, step)
			local note <const> = freq % 12
			local octave <const> = freq // 12
			-- Cursors and Selection
			-- TODO: only when the app.pattern is where the cursor is
			if is_selected then
				local rectfunc = self.parent:has_keyboard_focus() and rrectfill or rrect
				local selcol = app.is_editing and 37 or 38
				if selection_parts & selection.note ~= 0 then
					rectfunc(x_note, y, w_note, app.height_row, 0, selcol)
				end
				if selection_parts & selection.octave ~= 0 then
					rectfunc(x_octave, y, w_octave, app.height_row, 0, selcol)
				end
				if selection_parts & selection.instrument ~= 0 then
					rectfunc(x_instrument, y, w_instrument, app.height_row, 0, selcol)
				end
				if selection_parts & selection.volume ~= 0 then
					rectfunc(x_volume, y, w_volume, app.height_row, 0, selcol)
				end
				if selection_parts & selection.fx ~= 0 then
					rectfunc(x_fx, y, w_fx, app.height_row, 0, selcol)
				end
			end
			-- Note and Octave
			if freq != 0xff then
				pal(7, is_greyed and 52 or fg_note)
				spr(72 + note, x + 3, y_text)
				if octave <= 9 then
					pal(7, is_greyed and 52 or fg_octave)
					spr(96 + min(octave, 10), x + 13, y_text)
				else
					-- TODO
				end
			else
				pal(7, is_greyed and 52 or fgd_note)
				spr(65, x + 4, y_text)
				pal(7, is_greyed and 52 or fgd_octave)
				spr(65, x + 13, y_text)
			end
			-- Instrument
			if is_selected and self.parent.str_instrument then
				pal(7, 7)
				print(self.parent.str_instrument, x + 20, y_text, 7)
			elseif inst != 0xff then
				local fg = fg_inst -- (inst ~= current_instt) and fg_inst or 52
				pal(7, is_greyed and 52 or fg)
				spr(256 + inst, x + 20, y_text)
			else
				pal(7, is_greyed and 52 or fgd_inst)
				spr(64, x + 20, y_text)
			end
			-- Volume
			if is_selected and self.parent.str_volume then
				pal(7, 7)
				print(self.parent.str_volume, x + 31, y_text, 7)
			elseif vol != 0xff then
				local fg = fg_vol -- (vol ~= current_vol) and fg_vol or 52
				pal(7, is_greyed and 52 or fg)
				spr(256 + vol, x + 31, y_text)
			else
				pal(7, is_greyed and 52 or fgd_vol)
				spr(64, x + 31, y_text)
			end
			-- FX
			if is_selected and self.parent.str_fx then
				local is_valid = app.is_valid_fx[self.parent.str_fx[1]]
				pal(7, 7)
				print(self.parent.str_fx, x + 42, y_text, is_valid and 7 or 8)
			elseif fx != 0x0 then
				print(chr(fx), x + 42, y_text, is_greyed and 52 or fg_fx) -- TODO: replace with sprites
				pal(7, is_greyed and 52 or fg_fx)
				spr(256 + ((fxp0 << 4) | fxp1), x + 46, y_text)
			else
				pal(7, is_greyed and 52 or fgd_fx)
				spr(66, x + 42, y_text)
			end
			-- Loop Markers
			if track_is_looping then
				if step == track_length then
					spr(22, x, y - 8)
				end
				if step > 0 and step == track_loop0 then
					spr(21, x, y)
				end
			elseif step == track_length then
				line(x, y - 1, x + app.width_column - 2, y - 1, 52)
			end
			if inst ~= 0xff then current_instt = inst end
			if vol ~= 0xff then current_vol = vol end
			pal(7, 7)
			::continue::
		end
	end
	
	function el:update(msg)
		local mx, my = mouse()
		mx -= self.sx
		my -= self.sy
		local has_pointer = 
			mx >= 0 and mx < self.width
			and my >= 0 and my < self.height
		if has_pointer and self.parent.is_selecting then
			local row <const> = msg.my // app.height_row
			if msg.mx < x_octave then
				selection.set_from_anchor_to(self.channel, self.start + row, selection.note)
			elseif msg.mx < x_instrument then
				selection.set_from_anchor_to(self.channel, self.start + row, selection.octave)
			elseif msg.mx < x_volume then
				selection.set_from_anchor_to(self.channel, self.start + row, selection.instrument)
			elseif msg.mx < x_fx then
				selection.set_from_anchor_to(self.channel, self.start + row, selection.volume)
			else
				selection.set_from_anchor_to(self.channel, self.start + row, selection.fx)
			end
		end
	end
	
	function el:click(msg)
		local track = sfx.pattern_track(app.pattern, self.channel)
		if sfx.track_size(track) == 0 then
			notify("initialized track " .. track)
			init_track(track)
			return
		end
		self.parent:clear_edit()
		self.parent.is_selecting = true
		local action = key("ctrl") and selection.set_anchor_extend or selection.set_anchor
		local row <const> = msg.my // app.height_row
		if msg.mx < x_octave then
			action(self.channel, self.start + row, selection.note)
		elseif msg.mx < x_instrument then
			action(self.channel, self.start + row, selection.octave)
		elseif msg.mx < x_volume then
			action(self.channel, self.start + row, selection.instrument)
		elseif msg.mx < x_fx then
			action(self.channel, self.start + row, selection.volume)
		else
			action(self.channel, self.start + row, selection.fx)
		end
	end
	
	function el:hover(msg)
	end
	
	el.drag = el.hover
	
	function el:release(msg)
		self.parent.is_selecting = false
		selection.clear_anchor()
	end
	
	function el:mousewheel(msg)
		self.parent:scroll_channels(msg.wheel_y)
	end
	
	return el
end


-- Unused, kept for reference
function render_row(x, y, note, octave, inst, vol, fx, fxp0, fxp2)
	-- First method, naive printing: horrible performance	

--				print(note_names[note+1],  x + 4, y_text , 43)
--					print (tostr(freq \ 12), x +  13, y_text, 42)
--					print("?", x + 13, y_text, 58)
--				print("\|e.", x + 4, y_text, 42)
--				print("\|e.", x + 13, y_text, 42)
--				print(hex_00[inst], x + 20, y_text, 45)
--				print("\|e..", x + 20, y_text, 44)
--				print(hex_00[vol], x + 31, y_text, 47)
--				print("\|e..", x + 31, y_text, 46)
--				print(hex_00[(fxp0 << 4) | fxp1], x + 46, y_text, 48)
--				print("\|e...", x + 42, y_text, 48)

	-- Second method, using the same technique as Zep's sfx

--	local render = string.format("\f{%s\-h%s\-f %s\-f %s\-f %s%s",
--		note_names[note+1], octave < 10 and tostr(octave) or "?" ,
--		hex_00[inst], hex_00[vol],
--		fx > 32 and chr(fx) or "?", hex_00[(fxp0 << 4) | fxp1])
--	print(render, x + 4, y + 2, 7)
end


----------------------------------------------------------------------------------------------------
-- Track Header
----------------------------------------------------------------------------------------------------


-- TODO: should be in separate module


function ui_notegrid.attach_header(parent, el)
	el.width = app.width_column
	el.height = app.height_header
	el.cursor = "pointer"
	parent:attach(el)
	
	function el:draw()
		local track <const> = sfx.pattern_track(app.pattern, self.channel)
		-- Header
		rrectfill(0, 0, self.width, app.height_header, 0, 6)
		local is_muted <const> = sfx.channel_is_muted(app.pattern, self.channel)
		spr(is_muted and 46 or 47, 4, 3)
		if not is_muted then
			if self:has_keyboard_focus() then
				rectfill(20, 2, 20 + 14, 2 + 8, 59)
				ui.print_centered(self.str, 22 + 5, 4, 7)
			else
				print(string.format("%03d", track), 22, 4, 5)
			end
			pal(7, self.clicked_trackdial and 13 or 58)
			spr(28, self.width - 10, 4)
			pal(7, 7)
		end
		local xh <const> = self.width - 1
		local yh <const> = app.height_header - 1
		line(0, 0, xh, 0, 57)
		line(0, yh, xh, yh, 58)
		if self.channel == 0 then
			line(0, 0, 0, yh - 1, 57)
		else
			line(0, 2, 0, yh - 2, 57)
		end
		if self.channel == 7 then
			line(xh, 0, xh, yh - 1, 58)
		else
			line(xh, 2, xh, yh - 2, 58)
		end
	end

	function el:update()
		if self:has_keyboard_focus() then
			while peektext() do
				if #self.str < 3 then
					self.str = self.str .. readtext()
				else
					readtext()
				end
			end

			if keyp("backspace") then
				self.str = sub(self.str, 1, -2)
			end
			
			if keyp("enter") or #self.str == 3 then
				local val = tonum(self.str)
				if val then
					local track = sfx.pattern_track(app.pattern, self.channel)
					track = mid(val, 0, sfx.num_tracks() - 1)
					sfx.set_pattern_track(app.pattern, self.channel, track)
				end
				self:set_keyboard_focus(false)
				app.was_in_text_field = true
			end
		end
	end
	
	function el:hover(msg)
		local is_muted <const> = sfx.channel_is_muted(app.pattern, self.channel)
		if msg.mx < 14 then
			self.cursor = "pointer"
		elseif msg.mx > self.width - 14 and not is_muted then
			self.cursor = "pointer"
		elseif not is_muted then
			self.cursor = get_spr(53)
		end
	end
	
	function el:click(msg)
		if msg.mx > self.width - 14 then
			self.clicked_trackdial = true
		end
	end
	
	function el:tap(msg)
		local is_muted <const> = sfx.channel_is_muted(app.pattern, self.channel)
		if msg.mx < 14 then
			local is_muted = sfx.channel_is_muted(app.pattern, self.channel)
			sfx.mute_channel(app.pattern, self.channel, not is_muted)
			if not is_muted then
				selection.unset(self.channel)
			end
		elseif msg.mx > self.width - 14 and not is_muted then
			self.clicked_trackdial = true
			ui.open_modal(ui_trakdial.create { channel = self.channel })
		else
			self:set_keyboard_focus(true)
			readtext(true)
			self.str = ""
		end
	end
	
	function el:release(msg)
		ui.mouseunlock()
		self.clicked_trackdial = false
	end
	
	function el:mousewheel(msg)
		local track = sfx.pattern_track(app.pattern, self.channel)
		track = mid(track + msg.wheel_y, 0, sfx.num_tracks())
		sfx.set_pattern_track(app.pattern, self.channel, track)
	end

	return el
end


----------------------------------------------------------------------------------------------------
-- Tool-Rack
----------------------------------------------------------------------------------------------------


-- TODO: should be in separate module


function ui_notegrid.attach_inspector(parent, el)
	parent:attach(el)
	function el:draw()
		rrectfill(0, 0, self.width, self.height, 0, 6)
--		print("info", 5, 3, 5)
--		print("select", 5, 11, 5)
--		print("notes", 5, 19, 5)
--		print("info", 38, 3, 5)
--		print("select", 38, 11, 5)
--		print("notes", 38, 19, 5)
		print("(the inspector panel is not yet implemented)", 152, 11, 58)
		-- Divider
		local xh <const> = self.width - 1
		local yh <const> = self.height - 1
		line(65, 2, 65, yh - 2, 58)
		line(66, 2, 66, yh - 2, 57)
		-- Borders
		line(0, 0, xh, 0, 57)
		line(0, yh, xh, yh, 58)
		line(0, 0, 0, yh - 1, 57)
		line(xh, 0, xh, yh - 1, 58)
	end
	return el
end


return ui_notegrid
:: src/ui_params.lua
--[[pod_format="raw",created="2024-04-20 11:45:24",modified="2026-01-30 18:48:07",revision=12848]]
local app = require "src/app.lua"
local sfx = require "src/sfx.lua"
local undo = require "src/undo.lua"
local ui = require "src/ui.lua"
local ui_menus = require "src/ui_menus.lua"


local ui_params = {}


-- Field ----------------------------------------------------------------------


local function attach_field(parent, el)
	el.width = 4 * 4 + 3
	el.height = 7
	parent:attach(el)
	
	function el:draw()
		local fg = self.dragged and 7 or (self.fg or 59)
		local bg = 58
		if self:has_keyboard_focus() then
			fg, bg = 7, 59
		end
		rectfill(0, 0, self.width - 1, self.height - 1, bg)
		if (not self.visible) or self.visible(self) then
			local str
			if self:has_keyboard_focus() then
				str = self.str
			else
				local val = self:get()
				if self.to_str then
					str = self:to_str(val)
				else
					str = tostr(val)
				end
			end
			if #str > 4 then
				print(str, 0, 1, fg)
			elseif self.centered then
				ui.print_centered(str, 10, 1, fg)
			else
				print(str, 2 + 4*4 - 4*#str, 1, fg)
			end
		end
	end


	function el:update()
		if self:has_keyboard_focus() then
			while peektext() do
				if #self.str < 255 then -- TODO
					self.str = self.str .. readtext()
				else
					readtext()
				end
			end

			if keyp("backspace") then
				self.str = sub(self.str, 1, -2)
			end
			
			if keyp("enter") or #self.str == 3 then
				local val = tonum(self.str)
				if val then
					self:set(val)
				end
				self:set_keyboard_focus(false)
				app.was_in_text_field = true
			end
		end
	end

	
	function el:click(msg)
		undo.checkpoint()
		if self.visible and (not self.visible(self)) then
			return true
		end
		self.cursor = 0
		self.dragged = true
		ui.mouselock(1.0, true)
		if self.onclick then
			self:onclick(msg)
		elseif self.parent.onclick then
			self.parent:onclick(msg)
		end
		return true
	end
	
	
	function el:doubleclick()
		return true
	end

	
	function el:tap()
		if self.visible and (not self.visible(self)) then
			return true
		end
		self:set_keyboard_focus(true)
		readtext(true)
		self.str = ""
	end	

	
	function el:drag(msg)
		local delta = ui.mouselock(1.0, true)
		local old = self:get()
		local new = old - delta
		self:set(new)
	end

	
	function el:release()
		self.cursor = 1
		self.dragged = false
		ui.mouseunlock()
		self.up_barrier = nil
		self.down_barrier = nil
		-- TODO: it would be nice to keep the visual modal open
		-- when the field has keyboard focus, but I didn't find
		-- a way to close the modal when the focus is lost...
		if self.onrelease then
			self:onrelease()
		elseif self.parent.onrelease then
			self.parent:onrelease()
		end
	end


	return el
end


local function attach_relationship(parent, el)
	el.width, el.height = 7, 7
	el.cursor = "pointer"
	parent:attach(el)
	function el:draw()
		local flags, _, _, _ = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
		---rectfill(0, 0, self.width - 1, self.height - 1, 58)
		if flags & 0x03 == 0x01 then
			print("\^:2070200000000000", -1, 2, 60)
		elseif flags & 0x03 == 0x02 then
			print("\^:5020500000000000", -1, 2, 60)
		elseif flags & 0x03 > 0 then
			print("?", 3, 1, 60)
		else
			pset(4, 3, 58)
		end
	end
	function el:tap()
		ui_menus.open_relationship(self)
	end
	return el
end


local function attach_multiplier(parent, el)
	el.width, el.height = 7, 7
	el.cursor = "pointer"
	parent:attach(el)
	function el:draw()
		local flags, _, _, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
		--rectfill(0, 0, self.width - 1, self.height - 1, 58)
		if self.mini then
			if (env & 0xc0 > 0) then
				print("!", 0, 1, 24)
			else
				pset(1, 3, 58)
			end
			return
		end
		if (env & 0xc0 > 0) then
			str2 = (env & 0x20 == 0) and 
				"\^:5020500000000000" or  -- *
				"\^:4020100000000000"     -- /
			if (env & 0xc0 == 0x40) str2 = str2 .. "\-c\^:5070400000000000" -- 4
			if (env & 0xc0 == 0x80) str2 = str2 .. "\^:1372770000000000" -- 16
			if (env & 0xc0 == 0xc0) str2 = str2 .. "\^:5177470000000000" -- 64
			clip()
			print(str2, -4, 2, 24)
		else
			pset(2, 3, 58)
		end
	end
	function el:tap()
		ui_menus.open_multiplier(self)
	end
	return el
end


local function attach_envelope(parent, el)
	el.width, el.height = 7, 7
	el.cursor = "pointer"
	parent:attach(el)
	function el:draw()
		---rectfill(0, 0, self.width - 1, self.height - 1, 7)
		local flags, _, _, env = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
		if flags & 0x04 > 0 then
			local fg, bg = 7, 18
			if flags & 0x08 > 0 then
				fg, bg = bg, fg
			end
			line(1, 0, self.width - 1 - 1, 0, bg)
			rectfill(0, 1, self.width - 1 - 0, self.height - 1 - 1, bg)
			line(1, self.height - 1 - 0, self.width - 1 - 1, self.height - 1 - 0, bg)
			print(string.format("%x", env & 0x0f), 2, 1, fg)
		elseif flags & 0x10 > 0 then
			line(1, 0, self.width - 1 - 1, 0, 30)
			rectfill(0, 1, self.width - 1 - 0, self.height - 1 - 1, 30)
			line(1, self.height - 1 - 0, self.width - 1 - 1, self.height - 1 - 0, 30)
			print("r", 2, 1, 7)
		else
			line(2, 1, self.width - 1 - 2, 1, 58)
			rectfill(1, 2, self.width - 1 - 1, self.height - 1 - 2, 58)
			line(2, self.height - 1 - 1, self.width - 1 - 2, self.height - 1 - 1, 58)
		end
	end
	function el:tap()
		ui_menus.open_envelope(self)
	end
	return el
end


-- Getters and setters ------------------------------------------------------


local function get_val1(self)
	local _, val1, _, _ = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
	if (self.parent.max_val < 128) then
		if (val1 >= 128) val1 -= 256
	end
	return val1
end


local function set_val1(self, val)
	val = mid(self.parent.min_val, val, self.parent.max_val)
	sfx.set_node_param_val1(app.instrument, self.parent.node_id, self.parent.param, val)
end


local function get_val0(self)
	local _, _, val0, _ = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
	if (self.parent.max_val < 128) then
		if (val0 >= 128) val0 -= 256
	end
	return val0
end


local function set_val0(self, val)
	val = mid(self.parent.min_val, val, self.parent.max_val)
	sfx.set_node_param_val0(app.instrument, self.parent.node_id, self.parent.param, val)
end


local function has_env(self)
	local flags, _, _, _ = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
	return flags & (0x4 | 0x10) > 0
end


local function smart_str(self, val)
	local flags, _, _, _ = sfx.node_param(app.instrument, self.parent.node_id, self.parent.param)
	local node_type = sfx.node_type(app.instrument, self.parent.node_id)
	if node_type == 0x02 and self.parent.param == 0x02 and (flags & 0x03 == 0x02) then
		local num = 1 + val % 16
		local den = 1 + val \ 16
		return num .. "/" .. den
	end
	return tostr(val)
end


-- The widget -----------------------------------------------------------------


function ui_params.attach(parent, x, y, el, style)
	el.x, el.y = x, y
	el.small = small
	el.width, el.height = 35, 58
	el.small = style.small
	el.emphasis = style.emphasis
	parent:attach(el)
	el:attach(ui.create_knob {
		x = 2, y = 10,
		small = style.small,
		get = get_val1,
		set = set_val1,
		has_secondary = has_env,
		get_secondary = get_val0,
		set_secondary = set_val0,
	})
	attach_relationship(
		el,
		{
			x = 0, y = 41,
		}
	)
	attach_field(
		el,
		{
			x = 8, y = 41,
			centered = true,
			get = get_val1,
			set = set_val1,
			to_str = smart_str,
		}
	)
	attach_multiplier(
		el,
		{
			x = 28, y = 41,
		}
	)
	attach_field(
		el,
		{
			x = 8, y = 51,
			fg = 18, centered = true,
			visible = has_env,
			get = get_val0,
			set = set_val0,
			to_str = smart_str,
		}
	)
	attach_envelope(
		el,
		{
			x = 28, y = 51,
		}
	)
	
	function el:draw()
		---rectfill(0, 0, self.width - 1, self.height - 1, 7)
		if self.emphasis then
			rectfill(0, 0, self.width - 1, 8, 5)
		else
			rectfill(0, 0, self.width - 1, 8, 5)
		end
		ui.print_centered(
			el.long_label or el.label,
			(self.width \ 2) + 1, 2,
			self.emphasis and 6 or 6
		)
	end	
	
	function el:click() return true end
	function el:doubleclick() return true end
	
	return el
end


-- Mini widget ---------------------------------------------------------------------


function ui_params.attach_mini(parent, el)
	el.x = el.x or 0
	el.y = el.y or (12 + 10 * el.param)
	el.width = parent.width
	el.height = 10
	parent:attach(el)
	attach_relationship(
		el,
		{
			x = 24, y = 0,
		}
	)
	attach_field(
		el,
		{
			x = 24 + 7, y = 0,
			get = get_val1,
			set = set_val1,
			to_str = smart_str,
		}
	)
	attach_multiplier(
		el,
		{
			x = 24 + 7 + 20, y = 0,
			mini = true,
		}
	)
	attach_field(
		el,
		{
			x = 24 + 7 + 20 + 4, y = 0,
			fg = 18,
			visible = has_env,
			get = get_val0,
			set = set_val0,
			to_str = smart_str,
		}
	)
	attach_envelope(
		el,
		{
			x = 24 + 7 + 20 + 4 + 20, y = 0,
		}
	)
	function el:draw()
		print(self.label, 24 - (4 * #self.label), 1, 5)
		---print(self.label, 2, 1, 5)
	end
	
	function el:click() return true end
	function el:doubleclick() return true end
end


return ui_params
:: src/ui_routing.lua
--[[pod_format="raw",created="2024-04-13 06:33:13",modified="2026-01-30 18:48:07",revision=12473]]
local app = require "src/app.lua"
local sfx = require "src/sfx.lua"
local ui = require "src/ui.lua"


local ui_routing = {}


-- Locals ------------------------------------------------------------------------


local node_width = 26
local node_height = 16 -- TODO: if 7 vertical nodes, lower to 14
local node_gap = 14


local placement_buttons = {}


local function attach_placement_button(el)
	el.x -= 3
	el.y -= 3
	el.width = 7 -- TODO
	el.height = 7
	el.cursor = "pointer"
	app.routing_widget:attach(el)
	add(placement_buttons, el)
	function el:draw()
		local x, y = 3, 3
		rectfill(
			x - 2, y - 3, 
			x + 2, y + 3,
			24
		)
		rectfill(
			x - 3, y - 2,
			x + 3, y + 2,
			24
		)
		print("+", x - 1, y - 2, 7)
	end
	function el:click()
		return true -- (ed_inst click() refreshes gui)
	end
	function el:tap()
		ui_routing.clear_placement_buttons()
		local new_node = sfx.add_node(app.instrument, self.parent_id,
			self.new_node_type, self.new_node_op, self.target_id, self.child_id)
		if app.node then
			app.node = new_node
		end
		app.refresh_gui = true
	end
	return el
end


local function attach_insert_between_parent(new_node_type, new_node_op, node, pos)
	if (node == sfx.root) return
	if (new_node_type >= 8) return
	if new_node_type == 2 and new_node_op > 0 then
		if (node.parent == sfx.root) return
	end
	attach_placement_button {
		parent_id = node.parent.id, target_id = node.id, child_id = node.id,
		new_node_type = new_node_type, new_node_op = new_node_op,
		x = pos.x - 2, y = pos.y + 4,
	}
end


local function attach_insert_top_child(new_node_type, new_node_op, node, pos)
	if new_node_type >= 8 then
		if (node == sfx.root) return
		if (node.type >= 8) return
	end
	if #node.children == 0 then
		-- add only child
		attach_placement_button {
			parent_id = node.id, target_id = node.id + 1,
			new_node_type = new_node_type, new_node_op = new_node_op,
			x = pos.x + node_width + 2, y = pos.y + 4,
		}
	else
		-- add above first child
		attach_placement_button {
			parent_id = node.id, target_id = node.id + 1,
			new_node_type = new_node_type, new_node_op = new_node_op,
			x = pos.x + node_width + node_gap + node_width \ 2, y = pos.y - 0,
		}
	end
end


local function attach_insert_sibling_below(new_node_type, new_node_op, node, pos)
	if (node == sfx.root) return
	attach_placement_button {
		parent_id = node.parent.id, target_id = node:last_child().id + 1,
		new_node_type = new_node_type, new_node_op = new_node_op,
		x = pos.x + node_width \ 2, y = pos.y + 8
	}
end


local function start_new_node(new_node_type, new_node_op)
--	app.node = nil
--	app.refresh_gui = true
	for n = 0, 7 do
		local node = sfx.nodes[n]
		local pos = node.position
		if (not pos) break -- TODO: when does this occur?
		-- Coordinates from logical position
		pos.x = 4 + pos.column * (node_width + node_gap)
		pos.y = 4 + pos.row * node_height
		local ppos = node.parent.position
		ppos.x = 4 + ppos.column * (node_width + node_gap)
		ppos.y = 4 + ppos.row * node_height
		
		--[[
		attach_insert_between_parent(new_node_type, new_node_op, node, pos)
		attach_insert_top_child(new_node_type, new_node_op, node, pos)
		attach_insert_sibling_below(new_node_type, new_node_op, node, pos)
		--]]
		---[[
		if new_node_type == 2 and new_node_op > 0 then
			-- Modulators --
			if node != sfx.root and node.parent != sfx.root then
				-- insert between parent
				attach_placement_button {
					parent_id = node.parent.id, target_id = node.id, child_id = node.id,
					new_node_type = new_node_type, new_node_op = new_node_op,
					x = pos.x - 2, y = pos.y + 4,
				}
			end
			if node.type == 2 and node.op == 0 then
				if #node.children == 0 then
					-- add only child
					attach_placement_button {
						parent_id = node.id, target_id = node.id + 1,
						new_node_type = new_node_type, new_node_op = new_node_op,
						x = pos.x + node_width + 2, y = pos.y + 4,
					}
				elseif node.children[1].type != 2 or node.children[1].op == 0 then
					-- add above first child
					attach_placement_button {
						parent_id = node.id, target_id = node.id + 1,
						new_node_type = new_node_type, new_node_op = new_node_op,
						x = pos.x + node_width + node_gap + node_width \ 2, y = pos.y - 0,
					}
				end
			end
			
		elseif new_node_type == 2 then
			-- Oscillators --
			if node != sfx.root and not (node.type == 2 and node.op > 0) then
				-- insert between parent
				attach_placement_button {
					parent_id = node.parent.id, target_id = node.id, child_id = node.id,
					new_node_type = new_node_type, new_node_op = new_node_op,
					x = pos.x - 2, y = pos.y + 4,
				}
			end
			if node != sfx.root then
				-- add sibling below
				attach_placement_button {
					parent_id = node.parent.id, target_id = node:last_child().id + 1,
					new_node_type = new_node_type, new_node_op = new_node_op,
					x = pos.x + node_width \ 2, y = pos.y + 8
				}
			end
			if node.type == 2 or node == sfx.root then
				if #node.children == 0 then
					-- add only child
					attach_placement_button {
						parent_id = node.id, target_id = node.id + 1,
						new_node_type = new_node_type, new_node_op = new_node_op,
						x = pos.x + node_width + 2, y = pos.y + 4,
					}
				elseif node.children[1].type != 2 	or node.children[1].op == 0 then
					-- add above first child
					attach_placement_button {
						parent_id = node.id, target_id = node.id + 1,
						new_node_type = new_node_type, new_node_op = new_node_op,
						x = pos.x + node_width + node_gap + node_width \ 2, y = pos.y - 0,
					}
				end
			end
			
		else
			-- Effects --
			if node != sfx.root then
				-- add sibling below
				attach_placement_button {
					parent_id = node.parent.id, target_id = node:last_child().id + 1,
					new_node_type = new_node_type, new_node_op = new_node_op,
					x = pos.x + node_width \ 2, y = pos.y + 8
				}
			end
			if 	node.type == 2 then
				if #node.children == 0 then
					-- add only child
					attach_placement_button {
						parent_id = node.id, target_id = node.id + 1,
						new_node_type = new_node_type, new_node_op = new_node_op,
						x = pos.x + node_width + 2, y = pos.y + 4,
					}
				elseif node.children[1].type != 2 or node.children[1].op == 0 then
					-- add above first child
					attach_placement_button {
						parent_id = node.id, target_id = node.id + 1,
						new_node_type = new_node_type, new_node_op = new_node_op,
						x = pos.x + node_width + node_gap + node_width \ 2, y = pos.y - 0,
					}
				end
			end
		end
		--]]
	end
end


function ui_routing.clear_placement_buttons()
	local cleared_something = #placement_buttons > 0
	for i = 1, #placement_buttons do
		placement_buttons[i]:detach()
	end
	placement_buttons = {}
	return cleared_something
end


-- Routing display -------------------------------------------------------------


function ui_routing.attach(parent, el)
	el.width = 366
	el.height = 97
	parent:attach(el)
	ui_routing.attach_node_chooser(el, { x = el.width - 87, y = 56 })
	
	function el:draw()
		rectfill(0, 0, self.width, self.height, 59)
--		pset(0, 0, 6)
--		pset(self.width - 1, 0, 6)
--		pset(0, self.height - 1, 6)
--		pset(self.width - 1, self.height - 1, 6)
		-- Overview and Wavetable buttons
		for i, label in ipairs({"all","wt 0","wt 1","wt 2","wt 3"}) do
			local bg = (i == 1) and 7 or 58
			local fg = (i == 1) and 22 or 5
			rrectfill(4, 4 + i * node_height, node_width + 1, 9, 0, bg)
			print(label, 10 + (i==1 and 2 or 0), 4 + i * node_height + 2, fg)
			if app.node then
				-- nothing to do
			elseif
				(i == 1 and not app.wt)
				or (i == 2 and app.wt == 0)
				or (i == 3 and app.wt == 1)
				or (i == 4 and app.wt == 2)
				or (i == 5 and app.wt == 3)
			then
				rect(4 - 1, 4 + i * node_height - 1, 4 + node_width + 1, 4 + i * node_height + 8 + 1, 0)
				rect(4 - 2, 4 + i * node_height - 2, 4 + node_width + 2, 4 + i * node_height + 8 + 2, 24)
			end
		end
		-- Routing graph
		for n = 0, 7 do
			local node = sfx.nodes[n]
			local pos = node.position
			if (not pos) break -- TODO: when does this occur?
			-- Coordinates from logical position
			pos.x = 4 + pos.column * (node_width + node_gap)
			pos.y = 4 + pos.row * node_height
			local ppos = node.parent.position
			ppos.x = 4 + ppos.column * (node_width + node_gap)
			ppos.y = 4 + ppos.row * node_height

			if app.node == n then
				rect(pos.x - 2, pos.y - 2, pos.x + node_width + 2, pos.y + 8 + 2, 24)
				rect(pos.x - 1, pos.y - 1, pos.x + node_width + 1, pos.y + 8 + 1, 0)
			end
			
			if node.type >= 8 and node.older_sibling then
				-- Horizontal bracket
				local col = 6
				local x = pos.x + node_width \ 2
				local orig = node.older_sibling
				local depth = 0
				while #orig.children > 0 and depth < 8 do
					orig = orig.children[#orig.children]
					depth += 1
				end
				local orig_x = orig.position.x + node_width
				line(x - (node_width \ 2) - 3, pos.y - 4, x - (node_width \ 2) - 3 - 2, pos.y - 6, col)
				line(x - 3, pos.y - 4, x - (node_width \ 2) - 3, pos.y - 4, col)
				line(x, pos.y - 2, x - 2, pos.y - 4, col)
				line(x, pos.y - 2, x + 2, pos.y - 4, col)
				line(x + 3, pos.y - 4, orig_x + 3, pos.y - 4, col)
				line(orig_x + 3, pos.y - 4, orig_x + 3 + 2, pos.y - 6, col)
			elseif node != sfx.root then
				-- Arrow
				line(
					ppos.x + node_width + 7, ppos.y + 4,
					ppos.x + node_width + 1, ppos.y + 4,
					7
				)
				line(
					pos.x - 7, pos.y + 4,
					ppos.x + node_width + 7, ppos.y + 4,
					7
				)
				line(
					pos.x - 1, pos.y + 4,
					pos.x - 7, pos.y + 4,
					7
				)
				line(pos.x - 2, pos.y + 3, pos.x - 2, pos.y + 5, 7)
				line(pos.x - 3, pos.y + 2, pos.x - 3, pos.y + 6, 7)
			end
			
			-- Node boxes
			local str = "??? "
			local fg = 63
			local bg = 30
			if node == sfx.root then str = "inst"; fg = 22; bg = 7
			elseif node.type == 2 then
				if node.op == 0 then str = "osc " .. n; bg = 17
				elseif node.op == 1 then str = "fm " .. n; bg = 27
				elseif node.op == 2 then str = "ring " .. n; bg = 22
				end
			elseif node.type == 8 then str = "filt " .. n; bg = 14
			elseif node.type == 9 then str = "echo " .. n; bg = 31
			elseif node.type == 10 then str = "shap " .. n; bg = 9
			end
			rectfill(pos.x, pos.y, pos.x + node_width, pos.y + 8, bg)
			ui.print_centered(str, pos.x + (node_width \ 2) + 1, pos.y + 2, fg)
		end
		clip()
		line()
		line(1, -1, 58)
		line(self.width - 2, -1, 58)
		line(self.width, 1, 58)
		line(self.width, self.height - 2, 57)
		line(self.width - 2, self.height, 57)
		line(1, self.height, 57)
		line(-1, self.height - 2, 57)
		line(-1, 1, 58)
		line(1, -1, 58)
		clip(self.sx, self.sy, self.width - 1, self.height - 1)
	end
	
	function el:hover(msg)
		self.cursor = 1
		if (#placement_buttons != 0) return
		for n = 0, 7 do
			local node = sfx.nodes[n]
			local pos = node.position
			if
				pos and pos.x and pos.x <= msg.mx and msg.mx <= pos.x + node_width
				and pos.y <= msg.my and msg.my <= pos.y + 10
			then
				self.cursor = "pointer"
			end
		end
		if msg.mx <= node_width + 4 then
			if (msg.my >= 4 + node_height and msg.my <= 4 + node_height + 10)
				or (msg.my >= 4 + 2 * node_height and msg.my <= 4 + 2 * node_height + 10)
				or (msg.my >= 4 + 3 * node_height and msg.my <= 4 + 3 * node_height + 10)
				or (msg.my >= 4 + 4 * node_height and msg.my <= 4 + 4 * node_height + 10)
				or (msg.my >= 4 + 5 * node_height and msg.my <= 4 + 5 * node_height + 10)
			then
				self.cursor = "pointer"
			end
		end
	end

	function el:click(msg)
		if #placement_buttons != 0 then
			ui_routing.clear_placement_buttons()
			return
		end
		for n = 0, 7 do
			local node = sfx.nodes[n]
			local pos = node.position
			if
				pos and pos.x and pos.x <= msg.mx and msg.mx <= pos.x + node_width
				and pos.y <= msg.my and msg.my <= pos.y + 10
			then
				app.node = n
				app.refresh_gui = true
				return true
			end
		end
		if msg.mx <= node_width + 4 then
			if msg.my >= 4 + node_height and msg.my <= 4 + node_height + 10 then
				app.node = nil
				app.wt = nil
				app.refresh_gui = true
				return true
			elseif msg.my >= 4 + 2 * node_height and msg.my <= 4 + 2 * node_height + 10 then
				app.node = nil
				app.wt = 0
				app.refresh_gui = true
				return true
			elseif msg.my >= 4 + 3 * node_height and msg.my <= 4 + 3 * node_height + 10 then
				app.node = nil
				app.wt = 1
				app.refresh_gui = true
				return true
			elseif msg.my >= 4 + 4 * node_height and msg.my <= 4 + 4 * node_height + 10 then
				app.node = nil
				app.wt = 2
				app.refresh_gui = true
				return true
			elseif msg.my >= 4 + 5 * node_height and msg.my <= 4 + 5 * node_height + 10 then
				app.node = nil
				app.wt = 3
				app.refresh_gui = true
				return true
			end
		end
	end
	
	return el
end


-- Node chooser ----------------------------------------------------------------


local node_choice = {
	[0] = {
		[0] = { label = "osc", color = 17, node_type = 0x2, node_op = 0x0 },
		{ label = "fm", color = 27, node_type = 0x2, node_op = 0x1 },
		{ label = "ring", color = 22, node_type = 0x2, node_op = 0x2 },
	},
	{
		[0] = { label = "filt", color = 14, node_type = 0x8, node_op = 0x0 },
		{ label = "echo", color = 31, node_type = 0x9, node_op = 0x0 },
		{ label = "shap", color = 9, node_type = 0x0a, node_op = 0x0 },
	},
}


function ui_routing.attach_node_chooser(parent, el)
	el.width = 118
	el.height = 50
	parent:attach(el)
	
	for i = 1, #placement_buttons do
		app.routing_widget:attach(placement_buttons[i])
	end

	function el:draw()
		--- rectfill(0, 0, self.width - 1, self.height - 1, 0)
		if #placement_buttons > 0 then
			print("choose position...", 4, 28, 22)
			return
		end
		if sfx.root.free_nodes == 0 then
			print("(8 nodes max)", 22, 28, 22)
			return
		end
		print("add module:", 4, 2, 22)
		local ox, oy = 4, 12
		for row = 0, #node_choice do
			for column = 0, #(node_choice[row]) do
				local x = ox + column * node_width
				local y = oy + row * (8 + 4)
				local col = node_choice[row][column].color
				rectfill(x, y, x + (node_width - 6), y + 8, col)
				ui.print_centered(
					node_choice[row][column].label,
					x + ((node_width - 6) \ 2) + 1,
					y + 2,
					63
				)
			end
		end
	end
	
	function el:hover(msg)
		self.cursor = 1
		if (#placement_buttons > 0) return
		if (sfx.root.free_nodes == 0) return
		local ox, oy = 4, 12
		for row = 0, #node_choice do
			for column = 0, #(node_choice[row]) do
				local x = ox + column * node_width
				local y = oy + row * (8 + 4)
				if
					x <= msg.mx and msg.mx <= x + (node_width - 6)
					and y <= msg.my and msg.my <= y + 8
				then
					self.cursor = "pointer"
				end
			end
		end
	end

	function el:click(msg)
		return true -- don't want to deselect the node!
	end
	
	function el:tap(msg)
		if #placement_buttons > 0 then
			ui_routing.clear_placement_buttons()
			return
		end
		if (sfx.root.free_nodes == 0) return
		local ox, oy = 4, 12
		for row = 0, #node_choice do
			for column = 0, #(node_choice[row]) do
				local x = ox + column * node_width
				local y = oy + row * (8 + 4)
				if
					x <= msg.mx and msg.mx <= x + (node_width - 6)
					and y <= msg.my and msg.my <= y + 8
				then
					start_new_node(
						node_choice[row][column].node_type,
						node_choice[row][column].node_op
					)
				end
			end
		end
	end
	

	return el
end


return ui_routing
:: src/ui_settings.lua
--[[pod_format="raw",created="2024-04-30 07:47:36",modified="2026-01-30 18:48:07",revision=9910]]
local settings = require "src/settings.lua"
local ui = require "src/ui.lua"


local ui_settings = {}


local function create_button(el)
	if not el.width then
		if el.label then
			el.width = 8 + (4 * #el.label)
		else
			el.width = 9
		end
	end
	if not el.height then
		el.height = 9
	end
	if not el.fg then
		el.fg = 5
	end
	if not el.bg then
		el.bg = 7
	end
	el.cursor = "pointer"
	function el:draw()
		rectfill(1, 0, self.width - 2, 0, self.bg)
		rectfill(0, 1, self.width - 1, self.height - 2, self.bg)
		rectfill(1, self.height - 1, self.width - 2, self.height - 1, self.bg)
		local label = self.get_label and self:get_label() or self.label
		if label then
			print(label, (self.width \ 2) - (2 * #label), 2, self.fg)
		end
	end
	function el:hover()
		return true
	end
	function el:click()
		return true
	end
	function el:doubleclick()
		return true
	end
	function el:tap()
		if self.action then
			self:action()
		end
	end
	return el
end


function ui_settings.open()
	local el = { width = 480 - 300, height = 270 - 11 - 60 }
	ui.open_modal(el)
	el:attach(ui.create_label { x = 20, y = 30, label = "keys for playing notes", fg = 5})
	el:attach(ui.create_label { x = 20, y = 50, label = "- layout:", fg = 5})
	el:attach(ui.create_menu_button {
		x = 58, y = 50 - 2,
		bg = 7,
		get_label = function()
			return settings.user.pitched_layout
		end,
		fg = 59,
		highlight = 15,
		items = {
			{
				label = "piano-like",
				action = function()
					settings.change_keys(settings.piano_keys)
					settings.change_user { pitched_layout = "piano-like" }
				end
			},
			{
				label = "guitar-like",
				action = function()
					settings.change_keys(settings.isomorphic_keys)
					settings.change_user { pitched_layout = "guitar-like" }
				end
			},
			{
				label = "chromatic",
				action = function()
					settings.change_keys(settings.chromatic_keys)
					settings.change_user { pitched_layout = "chromatic" }
				end
			},
		}		
	})
	el:attach(ui.create_label { x = 20, y = 90, label = "mouse movements (knobs, sliders, ...)", fg = 5})
	el:attach(ui.create_label { x = 20, y = 110, label = "- direction:", fg = 5})
	el:attach(ui.create_menu_button {
		x = 70, y = 110 - 2,
		bg = 7,
		get_label = function()
			return settings.user.drag_horizontal and "horizontal" or "vertical"
		end,
		fg = 59,
		highlight = 15,
		items = {
			{
				label = "vertical",
				action = function()
					settings.change_user { drag_horizontal = false }
				end
			},
			{
				label = "horizontal",
				action = function()
					settings.change_user { drag_horizontal = true }
				end
			},
		}		
	})	
	el:attach(ui.create_label { x = 20, y = 130, label = "- sensitivity:", fg = 5})
	el:attach_field {
		x = 78, y = 130 - 1,
		width = 30, height = 7,
		get = function() return settings.user.drag_sensitivity end,
		set = function(self, val)
			local v = mid(0.0, tonum(val), 8.0)
			if (v == 0) v = 0.5
			settings.change_user { drag_sensitivity = v }
		end
	}
	el:attach(ui.create_label { x = 20, y = 150, label = "- precise sensitivity:", fg = 5})
	el:attach_field {
		x = 110, y = 150 - 1,
		width = 30, height = 7,
		get = function() return settings.user.drag_sensitivity_precise end,
		set = function(self, val)
			local v = mid(0.0, tonum(val), 8.0)
			if (v == 0) v = 0.125
			settings.change_user { drag_sensitivity_precise = v }
		end
	}
	
	el:attach(create_button {
		x = 140, y = el.height - 16,
		label = "close",
		action = function(self)
			ui.close_modal()
		end,
	})
	
	function el:draw()
		draw_dialog_window(self.width, self.height, "settings")
	end
	
	function el:click()
		return true
	end
end


return ui_settings
:: src/ui_synth.lua
--[[pod_format="raw",created="2024-04-10 15:43:44",modified="2026-01-30 18:48:07",revision=14642]]
local app = require "src/app.lua"
local settings = require "src/settings.lua"
local sfx = require "src/sfx.lua"
local ui = require "src/ui.lua"
local ui_envelopes = require "src/ui_envelopes.lua"
local ui_nodes = require "src/ui_nodes.lua"
local ui_routing = require "src/ui_routing.lua"
local ui_visual = require "src/ui_visual.lua"
local ui_wavetable = require "src/ui_wavetable.lua"


local ui_synth = {}

local instr_chooser = false

local width_panel <const> = 24


function ui_synth.attach(parent, el)
--	el.width = 480 - (app.detail and app.detail_width or 0)
--	el.height = 270 - 11 -- TODO: remove - 16
	parent:attach(el)
	
	app.is_editing = false

	sfx.refresh_nodes(app.instrument)	

	local chooser_start = instr_chooser and instr_chooser.start or 0
	instr_chooser = ui_synth.attach_instr_chooser(el, { x = width_panel + 4 - 4, y = 4 })
	instr_chooser.start = chooser_start
	
	app.routing_widget = ui_routing.attach(el, { x = width_panel + 90 - 4, y = 4 })
	--TODO: ui_visual.attach_oscilloscope(el, 8, { node_id = 0, horiz_scale = 1, vert_scale = 2, fg1 = 19, fg2 = 19, x = 90, y = 4, width = 385, height = 97 })

	attach_view_selector(el, { x = 0, y = 4 })
	attach_octave_selector(el, { x = 0, y = 45 })
	attach_instrument_selector(el, { x = 0, y = 57 })
	attach_volume_selector(el, { x = 0, y = 75 })
	
	local dx = app.synth_width + app.synth_gap
	local dy = app.synth_height + app.synth_gap
	local ox = (480 - (4 * dx) + app.synth_gap) \ 2
	local oy = 270 - 11 - (2 * app.synth_height) - app.synth_gap - 2
			
	if app.node then
		ui_nodes.attach_node_panel(
			el,
			{
				x = ox + app.mod_width + app.synth_gap, y = oy , 
				node_id = app.node,
				large = true,
			}
		)
		for row = 0, 1 do
			ui_envelopes.attach_panel(
				el,
				{
					x = 4, y = oy + row * dy, 
					env_id = row, large = true,
				}
			)
			ui_envelopes.attach_panel(
				el,
				{
					x = 480 - 2 * app.mod_width - 2 * app.synth_gap + 1, y = oy + row * dy,
					env_id = 2 + row, large = true,
				}
			)
		end
	elseif not app.wt then
		local id = 0
		for row = 0, 1 do
			ui_envelopes.attach_panel(
				el,
				{
					x = 4, y = oy + row * dy, 
					env_id = row,
				}
			)
			for column = 0, 3 do
				ui_nodes.attach_node_panel(
					el,
					{
						x = ox + column * dx, y = oy + row * dy, 
						node_id = id
					}
				)
				id += 1
			end
			ui_envelopes.attach_panel(
				el,
				{
					x = 480 - app.mod_width - 4 - 1, y = oy + row * dy,
					env_id = 2 + row,
				}
			)
		end
	else -- A wavetable is selected
		ui_wavetable.attach(
			el,
			{
				x = 4, y = oy, 
			}
		)
	end

	function el:draw()
		local w <const> = self.width
		local h <const> = self.height
		cls(6)
		line(0, 0, w - 1, 0, 57)
		line(0, 0, 0, h - 1, 57)
		line(0, 106, w - 1, 106, 57)
		line(0, 105, w - 1, 105, 58)
		line(w - 1, 0, w - 1, h - 1, 58)
		line(0, h - 1, w - 1, h - 1, 58)
		-- divider
		line(3, 41, width_panel - 4, 41, 58)
		line(3, 42, width_panel - 4, 42, 57)
		if app.node then
			line(0, 183, 125, 183, 57)
			line(354, 183, 480, 183, 57)
			line(126, 106, 126, h - 1, 57)
			line(355, 106, 355, h - 1, 57)
			line(0, 182, 125, 182, 58)
			line(354, 182, 480, 182, 58)
			line(125, 106, 125, h - 1, 58)
			line(354, 106, 354, h - 1, 58)
		elseif not app.wt then
			line(0, 183, w - 1, 183, 57)
			line(64, 106, 64, h - 1, 57)
			line(152, 106, 152, h - 1, 57)
			line(240, 106, 240, h - 1, 57)
			line(328, 106, 328, h - 1, 57)
			line(416, 106, 416, h - 1, 57)
			line(0, 182, w - 1, 182, 58)
			line(63, 106, 63, h - 1, 58)
			line(151, 106, 151, h - 1, 58)
			line(239, 106, 239, h - 1, 58)
			line(327, 106, 327, h - 1, 58)
			line(415, 106, 415, h - 1, 58)
		end
	end	
	
	function el:update()
		-- Keys
		if ui.has_modal_or_menu() then return end
		if ui.head():get_keyboard_focus_element() then return end
		if app.was_in_text_field and not keyp() then
			return
		end
		app.was_in_text_field = false
		
		if keyp(settings.keys.play) and not currently_focused then
			app.play_or_pause(key("shift") and "follow_playhead" or nil)
		end

		local pitch, just_pressed = app.pitched_key()
		if pitch and not key("ctrl") then
			if just_pressed then
				note(pitch, app.instrument, app.base_volume,
					ord(" "), 0x00,
					8, -- channel 8 so it can play with pattern
					false -- don't force retrigger
				)
			end
		else
			note(0xff, 0xff, 0xff, 0xff, 0xff, 8)
		end
		
		if key("ctrl") and keyp("c") then
			local data = userdata("u8", 0x200)
			set(data, 0, peek(0x40000 + (app.instrument * 0x200), 0x200))
			set_clipboard(
				pod(
					{ instrument = data },
					7,
					{ pod_type = "instrument" }
				)
			)
			notify("copied instrument")
		end
		
		if key("ctrl") and keyp("v") then
			local data = unpod(get_clipboard())
			if data and type(data.instrument == "userdata") then
				poke(
					0x40000 + (app.instrument * 0x200),
					get(data.instrument, 0, 0x200)
				)
				app.refresh_gui = true
				app.node = 0
				notify("pasted instrument")
			else
				nodify("unable to paste instrument: invalid data in clipboard")
			end
		end
	end

	return el
end


-- Instrument chooser --------------------------------------------------------------


function ui_synth.attach_instr_chooser(parent, el)
	el.width = 80
	el.height = 81
	el.cursor = "pointer"
	el.start = 0
	parent:attach(el)
	
	local nb_rows <const> = 9
	local h_row <const> = 8

	function el:draw()
		rectfill(0, 0, self.width, self.height, 59)
		-- Rows
		for i = 0, nb_rows  do
			local instrument = self.start + i
			if instrument == app.instrument then
				rectfill(0, i * h_row, self.width, (i * h_row) + h_row, 4)
			end
			local name = sfx.instrument_name(instrument)
			if name == "" then name = "---" end
			print(string.format("%02x", instrument), 2, 2 + i * h_row, 45)
			print(":", 2 + 8, 2 + i * h_row, 58)
			print(name, 2 + 14, 2 + i * h_row, 57)
		end
		-- Border
		clip()
		line()
		line(1, -1, 58)
		line(self.width - 2, -1, 58)
		line(self.width, 1, 58)
		line(self.width, self.height - 2, 57)
		line(self.width - 2, self.height, 57)
		line(1, self.height, 57)
		line(-1, self.height - 2, 57)
		line(-1, 1, 58)
		line(1, -1, 58)
		clip(self.sx, self.sy, self.width, self.height)
	end
	
	function el:click(msg)
		app.instrument = self.start + (msg.my - 2) // h_row
		ui_routing.clear_placement_buttons()
		if app.node then
			app.node = 0
		end
		app.refresh_gui = true
--		return true
	end
	
	function el:mousewheel(msg)
		self.start -= msg.wheel_y
		self.start = mid(self.start, 0, sfx.num_instruments() - 1 - nb_rows)
	end

	return el
end


return ui_synth
:: src/ui_tracker.lua
--[[pod_format="raw",created="2026-01-26 12:39:34",modified="2026-01-30 18:48:07",revision=7804]]
local app = require "src/app.lua"
local selection = require "src/selection.lua"
local settings = require "src/settings.lua"
local sfx = require "src/sfx.lua"
local undo = require "src/undo.lua"
local ui = require "src/ui.lua"
local ui_notegrid = require "src/ui_notegrid.lua"

local ui_tracker = {}

local instr_chooser = false

local last_pitch = 0xff -- last pitch played on the keyboard

local width_panel <const> = 24


function ui_tracker.attach(parent, el)
	parent:attach(el)
	el:set_keyboard_focus(true)
	
	el.headers = {}
	el.notegrids = {}

	--sfx.set_pattern_length(app.pattern, 8)
	--notify("pattern length: " .. pod(sfx.pattern_length(app.pattern)))
		
	for channel = 0, 7 do
		local y = 0
		local h = el.height
		if app.track_headers_visible then
			el.headers[channel] = ui_notegrid.attach_header(el, {
				x = width_panel + channel * app.width_column,
				y = 0,
				channel = channel,
			})
			y += el.headers[channel].height
			h -= el.headers[channel].height
		end
		if app.inspector_visible then
			el.inspector = ui_notegrid.attach_inspector(el, {
				x = width_panel,
				y = el.height - app.height_inspector,
				width = el.width - width_panel,
				height = app.height_inspector,
			})
			h -= app.height_inspector
		end
		el.notegrids[channel] = ui_notegrid.attach(el, {
			x = width_panel + channel * app.width_column, y = y,
			width = app.width_column, height = h,
			channel = channel,
		})
	end
	
	attach_view_selector(el, { x = 0, y = 4 })
	attach_octave_selector(el, { x = 0, y = 45 })
	attach_instrument_selector(el, { x = 0, y = 57 })
	attach_volume_selector(el, { x = 0, y = 75 })
	attach_step_selector(el, { x = 0, y = 93 })

	attach_pattern_selector(el, { x = 0, y = 116 })
	attach_pattern_arrows(el, { x = 0, y = 132 })
	attach_pattern_flags(el, { x = 0, y = 153 })

	attach_row_counter(el, { x = 1, y = el.height - 68 })
	attach_inspector_button(el, { x = 1, y = el.height - 51 })
	attach_edit_button(el, { x = 0, y = el.height - 35 })
	attach_play_button(el, { x = 0, y = el.height - 18 })

	function el:draw()
		local w <const> = self.width
		local h <const> = self.height
		cls(32)
		rrectfill(0, 0, width_panel, h, 0, 6)
		line(0, 0, width_panel - 1, 0, 57)
		line(0, 0, 0, h - 1, 57)
		line(width_panel - 1, 0, width_panel - 1, h - 1, 58)
		line(0, h - 1, width_panel - 1, h - 1, 58)
		-- dividers
		line(3, 41, width_panel - 4, 41, 58)
		line(3, 42, width_panel - 4, 42, 57)
		line(3, 111, width_panel - 4, 111, 58)
		line(3, 112, width_panel - 4, 112, 57)
		line(3, el.height - 73, width_panel - 4, el.height - 73, 58)
		line(3, el.height - 72, width_panel - 4, el.height - 72, 57)
	end	

	function el:update()
		if not ui.head():get_keyboard_focus_element() then
			self:set_keyboard_focus(true)
			self:clear_edit()
			keyp(true)
			return
		end
		if not self:has_keyboard_focus() then
			return
		end
		if app.was_in_text_field and not keyp() then
			return
		end
		app.was_in_text_field = false
		-- Playing
		if keyp(settings.keys.play) then
			-- Needs to be before editing
			self:clear_edit()
			app.play_or_pause(key("shift") and "follow_playhead" or nil)
		end
		-- Hangle Playing Scrolling
		self:handle_playing_scroll()
		if sfx.music_is_playing() then
			return
		end
		-- Movement
		local min_channel = selection.min_channel()
		local length_bar = self.notegrids[min_channel].length_bar
		local length_beat = self.notegrids[min_channel].length_beat
		if keyp("up") then
			self:clear_edit()
			local moved = selection.move_step(key("ctrl") and -1 * length_beat or -1)
			if not moved and app.pattern > 0 then
				app.pattern -= 1
				selection.set(nil, sfx.pattern_max_size(app.pattern) - 1, nil)
					 -- TODO: replace with move_to
			end
			if not selection.has_cursor() then
				selection.set(0, 0, selection.note) -- TODO: something better
			end
			self:show_cursor()
		end
		if keyp("down") then
			self:clear_edit()
			local moved = selection.move_step(key("ctrl") and length_beat or 1)
			if not moved and app.pattern < sfx.num_patterns() - 1 then
				app.pattern += 1
				selection.set(nil, 0, nil) -- TODO: replace with move_to
			end
			if not selection.has_cursor() then
				selection.set(0, 0, selection.note) -- TODO: something better
			end
			self:show_cursor()
		end
		if keyp("left") then
			self:clear_edit()
			if key("ctrl") then
				selection.move_to_previous_channel()
			else
				selection.move_to_previous_part()
			end
			if not selection.has_cursor() then
				selection.set(0, 0, selection.note) -- TODO: something better
			end
			self:show_cursor()
		end
		if keyp("right") then
			self:clear_edit()
			if key("ctrl") then
				selection.move_to_next_channel()
			else
				selection.move_to_next_part()
			end
			if not selection.has_cursor() then
				selection.set(0, 0, selection.note) -- TODO: something better
			end
			self:show_cursor()
		end
		-- Editing
		if keyp("tab") then
			self:clear_edit()
			app.is_editing = not app.is_editing
		end
		local pitch, pitch_just_pressed = app.pitched_key()
		if pitch and pitch_just_pressed then
			if selection.has_part(selection.note)
				or not app.is_editing
			then
				local track = sfx.pattern_track(app.pattern, selection.min_channel())
				local step = selection.min_step()
				local inst = self:instrument_to_use(track, step)
				if inst == 0xff then
					inst = self:current_instrument(track, step)
				end
				local vol = self:volume_to_use(track, step)
				if vol == 0xff then
					vol = self:current_volume(track, step)
				end
				note(pitch, inst, vol,
					0x00, 0x00,
					8, -- channel 8 so it can play with pattern
					false -- don't force retrigger
				)
			end
		elseif pitch then
			-- nothing
		else
			note(0xff, 0xff, 0xff, 0xff, 0xff, 8)
		end
		if app.is_editing then
			if selection.has_part(selection.note) then
				self:edit_note(pitch, pitch_just_pressed)
			elseif selection.parts() == selection.octave then
				self:edit_octave()
			elseif selection.parts() == selection.instrument then
				self:edit_instrument()
			elseif selection.parts() == selection.volume then
				self:edit_volume()
			elseif selection.parts() == selection.fx then
				self:edit_fx()
			end
		end
		if keyp("delete") then
			self:delete()
		end
		if keyp("backspace") then
			self:backspace()
		end
		-- Misc
		if key("ctrl") then
			if keyp("c") then
				set_clipboard(pod(selection.pack(), 0, { pod_type = "wavemaker notes" }))
				notify("copied notes")
			end
			if keyp("x") then
				set_clipboard(pod(selection.pack(), 0, { pod_type = "wavemaker notes" }))
				self:delete()
				notify("cut notes")
			end
			if keyp("v") then
				local data, metadata = unpod(get_clipboard())
				if metadata and metadata.pod_type == "wavemaker notes" then
					undo.checkpoint()
					selection.unpack(data)
				end
			end
			if keyp("h") then
				app.track_headers_visible = not app.track_headers_visible
				app.refresh_gui = true
			end
			if keyp(",") then
				app.height_row = mid(app.height_row - 1, 7, 9)
			end
			if keyp(".") then
				app.height_row = mid(app.height_row + 1, 7, 9)
			end
		end
		if key("alt") then
			if keyp("h") then
				app.track_headers_visible = not app.track_headers_visible
				app.refresh_gui = true
			end
			if keyp("r") then
				app.inspector_visible = not app.inspector_visible
				app.refresh_gui = true
			end
		end
	end
	
	function el:click(msg)
		self:set_keyboard_focus(true)
	end
	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
	
	function el:handle_playing_scroll()
		if not app.window_focused then
			return
		end
		if sfx.music_is_playing() and app.follow_playhead then
			if not self.was_playing then
				self:save_position()
			end
			local pattern = sfx.playing_pattern()
			local step = sfx.playing_row()
			if pattern and pattern >= 0 and step and step >= 0 then
				app.pattern = mid(sfx.playing_pattern(), 0, sfx.num_patterns() - 1)
				self:show_step(step, "centered")
			end
			self.was_playing = true
		else
			if self.was_playing then
				self:restore_position()
			end
			self.was_playing = false
		end
	end
	
	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
	
	
	function el:clear_edit()
		readtext(true)
		self.str_instrument = nil
		self.str_volume = nil
		self.str_fx = nil
	end

	
	function el:edit_note(pitch, pitch_just_pressed)
		if pitch_just_pressed and not key("ctrl") and not key("alt") then
			undo.checkpoint()
			selection.for_each_channel_each_step(
				function(track, step)
					sfx.set_track_pitch(track, step, pitch)
					sfx.set_track_instrument(track, step, self:instrument_to_use(track, step))
					sfx.set_track_volume(track, step, self:volume_to_use(track, step))
				end
			)
			if selection.has_exactly_one_step() then
				selection.move_step(app.jump_step)
			end
		end
		return nil
	end
	
	
	function el:instrument_to_use(track, step)
		local instr = sfx.track_instrument(track, step)
		if instr == 0xff or selection.has_part(selection.instrument) then
			instr = app.instrument_disabled and 0xff or app.instrument
		end
		return instr
	end
	
	
	function el:volume_to_use(track, step)
		local vol = sfx.track_volume(track, step)
		if vol == 0xff or selection.has_part(selection.volume) then
			vol = app.base_volume_disabled and 0xff or app.base_volume
		end
		return vol
	end
	
	
	function el:edit_octave()
		local digit = app.decimal_digit_key()
		if digit then
			undo.checkpoint()
			selection.for_each_channel_each_step(
				function(track, step)
					local pitch = sfx.track_pitch(track, step)
					pitch %= 12
					pitch += digit * 12
					sfx.set_track_pitch(track, step, pitch)
				end
			)
			if selection.has_exactly_one_step() then
				selection.move_step(app.jump_step)
			end
		end
	end
	
	
	function el:edit_instrument()
		if not self.str_instrument and peektext() then
			undo.checkpoint()
			self.str_instrument = ""
		end
		if self.str_instrument then
			while peektext() do
				if #self.str_instrument < 2 then
					self.str_instrument ..= readtext()
				else
					readtext()
				end
			end

			if keyp("backspace") then
				self.str_instrument = sub(self.str_instrument, 1, -2)
			end
			
			if keyp("enter") and #self.str_instrument == 0 then
				self.str_instrument = nil
			elseif keyp("enter") or #self.str_instrument == 2 then
				local val = tonumber(self.str_instrument, 16)
				self.str_instrument = nil
				if val then
					selection.for_each_channel_each_step(
						function(track, step)
							sfx.set_track_instrument(track, step, val)
						end
					)
					if selection.has_exactly_one_step() then
						selection.move_step(app.jump_step)
					end
				end
			end
		end
	end
	
	
	function el:edit_volume()
		if not self.str_volume and peektext() then
			undo.checkpoint()
			self.str_volume = ""
		end
		if self.str_volume then
			while peektext() do
				if #self.str_volume < 2 then
					self.str_volume ..= readtext()
				else
					readtext()
				end
			end

			if keyp("backspace") then
				self.str_volume = sub(self.str_volume, 1, -2)
			end
			
			if keyp("enter") and #self.str_volume == 0 then
				self.str_volume = nil
			elseif keyp("enter") or #self.str_volume == 2 then
				local val = tonumber(self.str_volume, 16)
				self.str_volume = nil
				if val then
					selection.for_each_channel_each_step(
						function(track, step)
							sfx.set_track_volume(track, step, val)
						end
					)
					if selection.has_exactly_one_step() then
						selection.move_step(app.jump_step)
					end
				end
			end
		end
	end
	
	
	function el:edit_fx()
		if not self.str_fx and peektext() then
			undo.checkpoint()
			self.str_fx = ""
		end
		if self.str_fx then
			while peektext() do
				if #self.str_fx < 3 then
					self.str_fx ..= readtext()
				else
					readtext()
				end
			end

			if keyp("backspace") then
				self.str_fx = sub(self.str_fx, 1, -2)
			end
			
			if keyp("enter") and #self.str_fx == 0 then
				self.str_fx = nil
			elseif keyp("enter") or #self.str_fx == 3 then
				local fx = ord(app.is_valid_fx[self.str_fx[1]])
				local val = tonumber(self.str_fx:sub(2, -1), 16)
				if fx == 0 then
					val = 0
				end
				self.str_fx = nil
				if fx and val then
					selection.for_each_channel_each_step(
						function(track, step)
							sfx.set_track_fx(track, step, fx)
							sfx.set_track_fx_param0(track, step, val >> 4)
							sfx.set_track_fx_param1(track, step, val & 0x0f)
						end
					)
					if selection.has_exactly_one_step() then
						selection.move_step(app.jump_step)
					end
				end
			end
		end
	end

	
	function el:delete()
		undo.checkpoint()
		selection.for_each_channel_each_step(
			function(track, step)
				sfx.set_track_pitch(track, step, 0xff)
				sfx.set_track_instrument(track, step, 0xff)
				sfx.set_track_volume(track, step, 0xff)
				sfx.set_track_fx(track, step, 0x00)
				sfx.set_track_fx_params(track, step, 0x00)
			end
		)
		if selection.has_exactly_one_step() then
			selection.move_step(app.jump_step)
		end
		return nil
	end

	
	function el:backspace()
		local should_proceed = true
		if selection.has_exactly_one_step() then
			should_proceed = selection.move_step(-1)
		end
		if should_proceed then
			undo.checkpoint()
			selection.for_each_channel_each_step(
				function(track, step)
					if selection.has_part(selection.note) then
						sfx.set_track_pitch(track, step, 0xff)
					end
					if selection.has_part(selection.instrument) then
						sfx.set_track_instrument(track, step, 0xff)
					end
					if selection.has_part(selection.volume) then
						sfx.set_track_volume(track, step, 0xff)
					end
					if selection.has_part(selection.fx) then
						sfx.set_track_fx(track, step, 0x00)
						sfx.set_track_fx_params(track, step, 0x00)
					end
				end
			)
		end
		return nil
	end
	
	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
	
	
	function el:current_instrument(track, step)
		for s = step, 0, -1 do
			local inst = sfx.track_instrument(track, s)
			if inst ~= 0xff then
				return inst
			end
		end
		return 0xff
	end
	
	
	function el:current_volume(track, step)
		for s = step, 0, -1 do
			local inst = sfx.track_volume(track, s)
			if inst ~= 0xff then
				return inst
			end
		end
		return 0xff
	end

	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

	
	function el:save_position()
		self.saved_pattern = app.pattern
		for channel = 0, 7 do
			self.notegrids[channel].saved_start = self.notegrids[channel].start
		end
	end
	
	
	function el:restore_position()
		if self.saved_pattern then
			app.pattern = mid(self.saved_pattern, 0, sfx.num_patterns() - 1)
		end
		for channel = 0, 7 do
			local start = self.notegrids[channel].saved_start
			if start then
				self.notegrids[channel].start = start
			end
		end
		self:show_step(self.notegrids[1].start)
	end
	
	
	function el:show_cursor(mode)
		mode = mode
		-- TODO: should use `max_step` when moving down
		local step = selection.min_step()
		if step then
			self:show_step(step, mode)
		end
		local step = selection.max_step()
		if step then
			self:show_step(step, mode)
		end
	end
	
	
	function el:show_step(step, mode)
		local start = self.notegrids[1].start
		local nb_rows = flr(self.notegrids[1].height // app.height_row)
		if mode == "centered" then
			start = step - nb_rows // 2
		else
			if step < start then
				start = step
			elseif step >= start + nb_rows then
				start = step - nb_rows + 1
			end
		end
		for channel = 0, 7 do
			self.notegrids[channel].start = start
		end
	end

	
	-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
	
	
	function el:scroll_channels(delta)
		local start = self.notegrids[1].start - delta
		for channel = 0, 7 do
			self.notegrids[channel].start = start
		end
		self:scrolling_guardrail()
	end
	
	
	function el:scrolling_guardrail(mode)
		local nb_rows = flr(self.notegrids[1].height // app.height_row)
		local max_size = sfx.pattern_max_size(app.pattern)
		local min_step, max_step
		if mode == "overshoot" then -- TODO: add settings?
			min_step = - (nb_rows // 2)
			max_step = max_size - (nb_rows // 2)
		else
			min_step = 0
			max_step = max_size - nb_rows
		end
		for channel = 0, 7 do
			local notegrid = self.notegrids[channel]
			notegrid.start = mid(notegrid.start, min_step, max_step)
		end
	end

	return el
end


----------------------------------------------------------------------------------------------------
-- Pattern Selector
----------------------------------------------------------------------------------------------------


function attach_pattern_selector(parent, el)
	el.width = 22
	el.height = 16
--	el.cursor = "pointer"
	parent:attach(el)
	
	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 49)
		ui.print_centered("patt", 12, 1, 58)
		ui.print_centered(string.format("%02d", app.pattern), 12, 9, 5) -- 12 or 19
		pal(7, self.clicked_prev and 13 or 58)
		pal(7, self.clicked_next and 13 or 58)
		pal(7, 7)
	end
		
	function el:click(msg)
		if msg.my < 10 then
			-- nothing
		elseif msg.my < 25 then
			self.clicked_prev = true
			app.pattern = mid(app.pattern - 1, 0, sfx.num_patterns() - 1)
		elseif msg.my > 25 then
			self.clicked_next = true
			app.pattern = mid(app.pattern + 1, 0, sfx.num_patterns() - 1)
		end
	end
	
	function el:release(msg)
		self.clicked_prev = false
		self.clicked_next = false
	end
	
	function el:mousewheel(msg)
		app.pattern = mid(app.pattern + msg.wheel_y, 0, sfx.num_patterns() - 1)
	end
	
	return el
end


----------------------------------------------------------------------------------------------------
-- Pattern Arrows
----------------------------------------------------------------------------------------------------


function attach_pattern_arrows(parent, el)
	el.width = 22
	el.height = 21
	el.cursor = "pointer"
	parent:attach(el)
	
	function el:draw(msg)
		--rrectfill(0, 0, self.width, self.height, 0, 47) line(0, 9+1, self.width, 9+1, 7)
		if false and msg.has_pointer and msg.my < 9 then
			rrectfill(3, 0, self.width - 4, 10, 0, 57)
		elseif false and msg.has_pointer and msg.my > 9 then
			rrectfill(3, 11, self.width - 4, 10, 0, 57)
		end
		pal(7, self.clicked_prev and 13 or 58)
		spr(29, 8, 4)
		pal(7, self.clicked_next and 13 or 58)
		spr(30, 8, 12)
		pal(7, 7)
	end
	
	function el:click(msg)
		if msg.my < 9 then
			self.clicked_prev = true
			app.pattern = mid(app.pattern - 1, 0, sfx.num_patterns() - 1)
		elseif msg.my > 9 then
			self.clicked_next = true
			app.pattern = mid(app.pattern + 1, 0, sfx.num_patterns() - 1)
		end
	end
	
	function el:release(msg)
		self.clicked_prev = false
		self.clicked_next = false
	end
	
	return el
end


----------------------------------------------------------------------------------------------------
-- Pattern Flags
----------------------------------------------------------------------------------------------------


function attach_pattern_flags(parent, el)
	el.width = 22
	el.height = 10 + 2 * 11
	el.cursor = "pointer"
	parent:attach(el)
	
	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 43)
		ui.print_centered("loop", 12, 1, 58)
		pal(58, sfx.pattern_loop_start(app.pattern) and 37
			or (self.clicked_loop_start and 13 or 58))
		spr(40, 2, 10)
		pal(58, sfx.pattern_loop_end(app.pattern) and 37
			or (self.clicked_loop_end and 13 or 58))
		spr(41, 13, 10)
		pal(58, sfx.pattern_loop_stop(app.pattern) and 37
			or (self.clicked_loop_stop and 13 or 58))
		spr(42, 7, 10 + 11)
		pal(58, 58)
	end	
	
	function el:hover(msg)
		if msg.my < 10 then
			self.cursor = 1
		else
			self.cursor = "pointer"
		end
	end
	
	function el:click(msg)
		if msg.my < 10 then
			-- nothing
		elseif msg.my < 22 then
			if msg.mx < 12 then
				self.clicked_loop_start = true
			else
				self.clicked_loop_end = true
			end
		else
			self.clicked_loop_stop = true
		end
	end
	
	function el:tap(msg)
		if msg.my < 10 then
			-- nothing
		elseif msg.my < 22 then
			if msg.mx < 12 then
				local is_on = sfx.pattern_loop_start(app.pattern)
				sfx.set_pattern_loop_start(app.pattern, not is_on)
			else
				local is_on = sfx.pattern_loop_end(app.pattern)
				sfx.set_pattern_loop_end(app.pattern, not is_on)
			end
		else
			local is_on = sfx.pattern_loop_stop(app.pattern)
			sfx.set_pattern_loop_stop(app.pattern, not is_on)
		end
	end
	
	function el:release(msg)
		self.clicked_loop_start = false
		self.clicked_loop_end = false
		self.clicked_loop_stop = false
	end
	
	return el
end


----------------------------------------------------------------------------------------------------
-- Row Counter
----------------------------------------------------------------------------------------------------


function attach_row_counter(parent, el)
	el.width = 20
	el.height = 16
	parent:attach(el)

	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 43)
		local step = selection.min_step()
		if sfx.music_is_playing() then
			ui.print_centered("row", 11, 1, 58)
			ui.print_centered(string.format("%02d", sfx.playing_row()), 11, 10, 5)
		elseif step then
			ui.print_centered("row", 11, 1, 58)
			ui.print_centered(string.format("%02d", step), 11, 10, 5)
		end
	end
	
	return el
end


----------------------------------------------------------------------------------------------------
-- Inspector Button
----------------------------------------------------------------------------------------------------


function attach_inspector_button(parent, el)
	el.width = 20
	el.height = 16
	parent:attach(el)
	
	el.cursor = "pointer"

	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 47)
		pal(58, app.inspector_visible and 37 or 5)
		spr(45, 5, 2)
		pal(58, 58)
	end	
	
	function el:click(msg)
		app.inspector_visible = not app.inspector_visible
		app.refresh_gui = true
	end
	
	return el
end


----------------------------------------------------------------------------------------------------
-- Record Button
----------------------------------------------------------------------------------------------------


function attach_edit_button(parent, el)
	el.width = 22
	el.height = 17
	el.cursor = "pointer"
	parent:attach(el)

	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 43)
		spr(app.is_editing and 7 or 6, 3, 1)
	end
	
	function el:click()
		app.is_editing = not app.is_editing
	end
	
	return el
end


----------------------------------------------------------------------------------------------------
-- Play Button
----------------------------------------------------------------------------------------------------


function attach_play_button(parent, el)
	el.width = 22
	el.height = 18
	el.cursor = "pointer"
	parent:attach(el)

	function el:draw()
		--rrectfill(0, 0, self.width, self.height, 0, 45)
		spr(sfx.music_is_playing() and 5 or 4, 3, 1)
	end
	
	function el:click()
		app.play_or_pause("follow_playhead")
	end
	
	return el
end


return ui_tracker
:: src/ui_trakdial.lua
--[[pod_format="raw",created="2026-01-27 14:07:26",modified="2026-01-30 18:48:07",revision=5253]]
local app = require "src/app.lua"
local ui = require "src/ui.lua"
local sfx = require "src/sfx.lua"


local ui_trakdial = {}


function ui_trakdial.create(el)
	el.width = 173
	el.height = 134 -- 72
	ui.head():new(el)
	
	local ox <const> = 10
	local oy <const> = 10
		
	el:attach(ui.create_label {
		x = ox, y = oy + 20,
		label = "speed:",
	})
	el:attach_field {
		x = ox + 46, y = oy + 20 - 1,
		width = 15, height = 7,
		get = function(self) return sfx.track_speed(self.parent:track()) end,
		set = function(self, value) sfx.set_track_speed(self.parent:track(), value) end,
	}

	el:attach(ui.create_label {
		x = ox, y = oy + 40,
		label = "length:",
	})
	el:attach_field {
		x = ox + 46, y = oy + 40 - 1,
		width = 15, height = 7,
		get = function(self) return sfx.track_loop0(self.parent:track()) end,
		set = function(self, value) sfx.set_track_loop0(self.parent:track(), value) end,
	}

	el:attach(ui.create_label {
		x = ox + 90, y = oy + 40,
		label = "loop end:",
	})
	el:attach_field {
		x = ox + 90 + 46, y = oy + 40 - 1,
		width = 15, height = 7,
		get = function(self) return sfx.track_loop1(self.parent:track()) end,
		set = function(self, value) sfx.set_track_loop1(self.parent:track(), value) end,
	}
		
	el:attach(ui.create_label {
		x = ox, y = oy + 80,
		label = "default speed:",
	})
	el:attach_field {
		x = ox + 66, y = oy + 80 - 1,
		width = 15, height = 7,
		get = function(self) return sfx.default_speed() end,
		set = function(self, value) sfx.set_default_speed(value) end,
	}
		
	el:attach(ui.create_label {
		x = ox, y = oy + 100,
		label = "default length:",
	})
	el:attach_field {
		x = ox + 66, y = oy + 100 - 1,
		width = 15, height = 7,
		get = function(self) return sfx.default_length() end,
		set = function(self, value) sfx.set_default_length(value) end,
	}
		
	--[[
	-- Not implemented yet? (as picotron 0.2.2b)
	el:attach(ui.create_label {
		x = ox, y = oy + 120,
		label = "tick length:",
	})
	el:attach_field {
		x = ox + 66, y = oy + 120 - 1,
		width = 15, height = 7,
		get = function(self) return sfx.tick_length() end,
		set = function(self, value) sfx.set_tick_length(value) end,
	}
	--]]
		
	function el:track()
		return sfx.pattern_track(app.pattern, self.channel)
	end

	function el:draw()
		draw_dialog_window(self.width, self.height,
			string.format("track %03d", self:track()))
		ui.print_centered("song settings", self.width // 2, 70, 5)
		line(10, 70 + 2, 56, 70 + 2, 5)
		line(114, 70 + 2, self.width - 10, 70 + 2, 5)
	end
	
	function el:click()
		return true
	end
	
	return el
end


function draw_dialog_window(width, height, label)
	rrectfill(0, 0, width, height, 0, 6)
	local xw, yh = width - 2, height - 2
	line(1, yh, 1, 1, 57)
	line(2, yh, 2, 1, 57)
	line(1, 1, xw, 1, 57)
	line(1, 2, xw, 2, 57)
	line(xw, yh, xw, 1, 58)
	line(xw - 1, yh, xw - 1, 2, 58)
	line(1, yh, xw, yh, 58)
	line(2, yh - 1, xw, yh - 1, 58)
	rrect(0, 0, width, height, 0, 0)
	rrectfill(4, 4, width - 8, 11, 0, 5)
	ui.print_centered(label, width // 2, 7, 6)
end


return ui_trakdial
:: src/ui_visual.lua
--[[pod_format="raw",created="2024-04-16 18:22:58",modified="2026-01-30 18:48:07",revision=11158]]
local app = require "src/app.lua"
local sfx = require "src/sfx.lua"
local ui = require "src/ui.lua"


local ui_visual = {}


local overlay = nil


function ui_visual.close()
	if overlay then
		overlay:detach()
		overlay = nil
	end
end


-- Wavetables ----------------------------------------------------------------


function ui_visual.open_wavetable(target)
	if (overlay) ui_visual.close()
	
	overlay = ui_visual.attach_wavetable(ui.head(), target, {
		x = 110, y = 4,
		width = 366, height = 97,
	})
end


local function draw_wave(
		wt_addr, wt_width, wt_height,
		wave, phase,
		display_width, display_height,
		col1, col2
)
	local oy = display_height \ 2
	local pos_addr = wt_addr + (wave * wt_height >> 8) * wt_width * 2
	local last_h = nil
	for i = 0, (display_width - 1) do
		local sample = i / display_width
		sample += (phase / 256.0) % 1.0
		sample = flr(0.5 + sample * wt_width)
		local val = peek2(pos_addr + sample * 2)
		local h = flr(0.5 + ((val * display_height) / 72000))
		if last_h then
			line(i, oy - last_h, i, oy - h, col2)
		end
		pset(i, oy - h, col1)
 		last_h = h
	end
end


function ui_visual.attach_wavetable(parent, target, el)
	parent:attach(el)
	function el:draw()
		rectfill(0, 0, self.width - 1, self.height - 1, 59)
		local wt_index = sfx.node_wavetable_index(app.instrument, target.node_id)
		local wt_addr, wt_width, wt_height = sfx.wavetable_info(app.instrument, wt_index)
		local _, wave1, wave0, _ = sfx.node_param(app.instrument, target.node_id, 4)
		local _, phase, _, _ = sfx.node_param(app.instrument, target.node_id, 5)
		-- Show val0 if there is an envelope
		local flags, _, _, _ = sfx.node_param(app.instrument, target.node_id, target.param)
		if flags & (0x04 | 0x10) > 0  then
			draw_wave(wt_addr, wt_width, wt_height, wave0, phase,
				self.width, self.height, 60, 60)
		end
		-- Show val1
		draw_wave(wt_addr, wt_width, wt_height, wave1, phase,
			self.width, self.height, 17, 19)
		-- Border
		clip()
		line()
		line(1, -1, 58)
		line(self.width - 2, -1, 58)
		line(self.width, 1, 58)
		line(self.width, self.height - 2, 57)
		line(self.width - 2, self.height, 57)
		line(1, self.height, 57)
		line(-1, self.height - 2, 57)
		line(-1, 1, 58)
		line(1, -1, 58)
		clip(self.sx, self.sy, self.width, self.height)
	end
	return el
end


-- Oscilloscope ---------------------------------------------------------------


function ui_visual.attach_oscilloscope(parent, channel, el)
	parent:attach(el)
	el.frame_counter = 0
	function el:draw()
		local node_id = self.node_id or app.node or 0
		local horiz_scale = self.horiz_scale or 2
		local vert_scale = self.vert_scale or 1
		local bg, fg1, fg2, border = self.bg or 59, self.fg1 or 11, self.fg2 or 3, self.border or 22
		if self.compact then
			bg, fg1, fg2, border = 62, 27, 3, 61
		end
		rectfill(0, 0, self.width - 1, self.height - 1, bg)
		-- Oscilloscope
		local tick_addr = 0x200000 + node_id * 8192

		-- `tick_len` is never used by sfx.p64...
		-- but the second `stat` is necessary to get
		-- audio data into `tick_addr`
		local tick_len = stat(400 + channel, 8)
		self.frame_counter += 1
		if self.frame_counter % 6 == 0 then
			tick_len = stat(400 + channel, 20 + node_id, tick_addr)
		end
		
		local last_y = nil
		for x = 0, self.width - 1 do
			local sample = flr(x * horiz_scale) -- i.e. horizontal scaling of the waveform
			local val = peek2(tick_addr + sample * 2)
			local y = (self.height / 2) - (vert_scale * (val * self.height) / 72000)
			if last_y then
				line(x, last_y, x, y, fg2)
			end
			pset(x, y, fg1)
			last_y = y
		end

		-- Border
		clip()
		line()
		line(1, -1, 58)
		line(self.width - 2, -1, 58)
		line(self.width, 1, 58)
		line(self.width, self.height - 2, 57)
		line(self.width - 2, self.height, 57)
		line(1, self.height, 57)
		line(-1, self.height - 2, 57)
		line(-1, 1, 58)
		line(1, -1, 58)
		clip(self.sx, self.sy, self.width, self.height)
	end
	return el
end


-- Custom envelopes ----------------------------------------------------




function ui_visual.open_custom_envelope(env_id)
	if (overlay) ui_visual.close()
	
	local env_type = sfx.env_type(app.instrument, env_id)
	if (env_type != 2) return
	
	overlay = ui.head():attach {
		x = (480 \ 2) - (128 \ 2), y = 10,
		width = 128, height = 90,
		env_id = env_id,
	}
	
	function overlay:draw()
		ui_visual.draw_custom_envelope(overlay)
		rect(0, 0, self.width - 1, self.height - 1, 22)
	end
end


function ui_visual.draw_custom_envelope(self)
	local bar_width = self.width \ 16
	rectfill(1, 1, self.width - 2, self.height - 2, 59)
	local start = sfx.env_start(app.instrument, self.env_id)
	local loop0 = sfx.env_loop0(app.instrument, self.env_id)
	local loop1 = sfx.env_loop1(app.instrument, self.env_id)
	for i = 0, 15 do
		local val = sfx.env_param(app.instrument, self.env_id, i)
		local h = (val * (self.height - 2)) \ 255
		local col = (i % 2 == 0) and 29 or 18
		if loop0 <= i and i < loop1 then
			col = (i % 2 == 0) and 23 or 14
		end
		rectfill(
			1 + (bar_width * i), self.height - 1,
			bar_width + (bar_width * i), self.height - h - 1,
			col
		)
	end
	fillp(0b1111000011110000)
	poke(0x550b,0x3f)
	if start > 0 then
		local x = 1 + (bar_width * start)
		line(x, 1, x, self.height - 2, 28)
	end
	if loop0 > 0 then
		local x = 1 + (bar_width * loop0)
		line(x, 1, x, self.height - 2, 26)
	end
	if loop1 > 0 then
		local x = bar_width + (bar_width * (loop1 - 1))
		line(x, 1, x, self.height - 2, 10)
	end
	fillp()
	poke(0x550b,0x0)
	if self.selected then
		local val = sfx.env_param(app.instrument, self.env_id, self.selected)
		local str = tostr(val)
		print(str, self.width - 3 - (4 * #str), 3, 7)
	end
	rect(0, 0, self.width - 1, self.height - 1, 5)
end


return ui_visual
:: src/ui_wavetable.lua
--[[pod_format="raw",created="2026-01-25 09:41:43",modified="2026-01-30 18:48:07",revision=9384]]
local sfx = require "src/sfx.lua"
local Wavetable = require "src/wavetable.lua"
local ui = require "src/ui.lua"


local ui_wavetable = {}


local wt = nil
local wave = 25


function ui_wavetable.attach(parent, el)
	el.width = 480 - 2 * 4
	el.height = 270 - 11 - 100
	parent:attach(el)
	

	-- TODO	
	wt = Wavetable.new(256, 32)
	wt:set_wavetable(drakma_cosine2saw2reso)

	
	function el:update()
		if not wt then return end
		
		local _, _, _, _, wheel_y = mouse()
		if wheel_y > 0 and wave > 0 then
			wave -= 1
		elseif wheel_y < 0 and wave < wt.height - 1 then
			wave += 1
		end
	
		if key("alt") then
			if keyp("1") then
				wt:set_wavetable(cz_saw)
			end	
			if keyp("2") then
				wt:set_wavetable(cz_square)
			end	
			if keyp("3") then
				wt:set_wavetable(cz_pulse)
			end	
			if keyp("4") then
				wt:set_wavetable(cz_doublesine)
			end	
			if keyp("5") then
				wt:set_wavetable(cz_sawpulse)
			end	
			if keyp("6") then
				wt:set_wavetable(cz_reso1)
			end	
			if keyp("7") then
				wt:set_wavetable(cz_reso2)
			end	
			if keyp("8") then
				wt:set_wavetable(cz_reso3)
			end
			if keyp("9") then
				wt:set_wavetable(split(cz_saw, cz_reso1))
			end
			
			if keyp("q") then
				wt:set_wavetable(drakma_cosine2saw)
			end
			if keyp("w") then
				wt:set_wavetable(drakma_triangle2saw)
			end
			if keyp("e") then
				wt:set_wavetable(drakma_sine2saw)
			end
			if keyp("r") then
				wt:set_wavetable(drakma_square2saw)
			end
			if keyp("t") then
				wt:set_wavetable(drakma_cosine2saw2reso)
			end
			if keyp("a") then
				wt:set_wavetable(drakma_cosine2square)
			end
			if keyp("s") then
				wt:set_wavetable(drakma_triangle2square)
			end
			if keyp("d") then
				wt:set_wavetable(drakma_triangle2square2saw)
			end
			if keyp("f") then
				wt:set_wavetable(drakma_pulsewidth)
			end
			if keyp("g") then
				wt:set_wavetable(drakma_sawpulse)
			end
			if keyp("z") then
				wt:set_wavetable(drakma_saw2reso)
			end
			if keyp("x") then
				wt:set_wavetable(drakma_square2reso)
			end
			if keyp("c") then
				wt:set_wavetable(drakma_triangle2reso)
			end
			if keyp("v") then
				wt:set_wavetable(drakma_sawpulse2reso)
			end
			if keyp("b") then
				wt:set_wavetable(drakma_sawpulse2resoalt)
			end
		end
	end
	
	
	function el:draw()
		--print("(the wavetable editor is coming soon!)", 158, 70, 5)
		---[[
		print("num_instruments: "..sfx.num_instruments(), 4, 60, 58)
		print("num_tracks: "..sfx.num_tracks(), nil, nil, 58)
		print("num_patterns: "..sfx.num_patterns(), nil, nil, 58)
		print("patterns_address: "..string.format("%x",sfx.patterns_address()), nil, nil, 58)
		print("instruments_address: "..string.format("%x",sfx.instruments_address()), nil, nil, 58)
		print("tracks_address: "..string.format("%x",sfx.tracks_address()), nil, nil, 58)
		-- Temporary wavetable display		
		if not wt then return end
		local ox <const> = 270
		local oy <const> = el.height // 2
		rrectfill(ox, oy - 50, 200, 101, 0, 59)
		line(ox, oy, ox + 200 - 1, oy, 60)
		local last_y
		for i = 0, 199 do
			local sample = (i * wt.width) // 200
			local value = wt:get(wave, sample)
			local y = oy - math.floor(0.5 + 50 * value)
			if last_y then
				line(ox + i, last_y, ox + i, y, 27)
			end
			pset(ox + i, y, 26)
			last_y = y
		end
		print(string.format("%d", wave), ox + 4, oy - 60, 19)
		--]]
	end
end


return ui_wavetable
:: src/undo.lua
--[[pod_format="raw",created="2026-01-29 15:20:29",modified="2026-01-30 18:48:07",revision=2187]]
local app = require "src/app.lua"
local selection = require "src/selection.lua"


local undo = {}


local undo_stack


local count = 1
function undo.init()
	undo_stack = create_undo_stack(
		function()
--			notify("checkpoint "..count) count += 1
			return {
				sfx = userdata("u8",0x40000):peek(0x40000),
				app = {
					-- Shared State
					pattern = app.pattern,
					track = app.track,
					instrument = app.instrument,
					-- Synth State
					node = app.node,
					wt = app.wt,
					-- Tracker State
					base_note = app.base_note,
					base_volume = app.base_volume,
					tracker_step = app.tracker_step,
					-- UI State
					view = app.view,
					detail = app.detail,
					track_header = app.track_header,
					height_row = app.height_row,
					env_advanced = app.env_advanced,
				},
				selection = selection.state(),
			}
		end,
		function(state)
			state.sfx:poke(0x40000)
			-- Shared State
			app.pattern = state.app.pattern
			app.track = state.app.track
			app.instrument = state.app.instrument
			-- Synth State
			app.node = state.app.node
			app.wt = state.app.wt
			-- Tracker State
			app.base_note = state.app.base_note
			app.base_volume = state.app.base_volume
			app.tracker_state = state.app.tracker_state
			-- UI State
			app.view = state.app.view
			app.detail = state.app.detail
			app.track_header = state.app.track_header
			app.height_row = state.app.height_row
			app.env_advanced = state.app.env_advanced
			-- Refresh
			app.refresh_gui = true
			-- Selection
			selection.set_state(state.selection)
		end,
		0x81 -- (0x1 binary  0x80 pxu rle)
	)
end


function undo.checkpoint()
	undo_stack:checkpoint()
end


function undo.undo()
	undo_stack:undo()
end


function undo.redo()
	undo_stack:redo()
end


return undo
:: src/waves.lua
--[[pod_format="raw",created="2026-01-23 20:54:55",modified="2026-01-30 18:48:07",revision=11038]]
----------------------------------------------------------------------------------------------------
-- Transforms
----------------------------------------------------------------------------------------------------


function nes_slope(func, coeff)
	local coeff = coeff or 2
	return function(x, w)
		local value = 2 * func(x, w) - 1
		if value > 0.0 then
			value -= x * coeff
		else
			value -= (1 - x) * coeff
		end
		value /= 1 + coeff
		local y = 0.5 + value / 2
		return y
	end
end


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


function bitcrunch(func, res)
	res = res and (res - 1) or 15
	return function(x, w)
		return math.floor(0.5 + res * func(x, w)) / res
	end
end


function phase(func, ph)
	return function(x, w)
		return func(x + ph, w)
	end
end


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


function split(funcA, funcB)
	return function(x, w)
		if x < 0.5 then
			return funcA(2 * x, w)
		else
			return funcB(2 * x - 1, w)
		end
	end
end


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


function mask(func1, func2)
	return function(x, w)
		return 1 - (1 - func1(x, w)) * (1 - func2(x, w))
	end
end


function multiply(func1, func2)
	return function(x, w)
		return func1(x, w) * func2(x, w)
	end
end


function multiply_bipolar(func1, func2)
	return function(x, w)
		local value1 = 2 * func1(x, w) - 1
		local value2 = 2 * func2(x, w) - 1
		return 0.5 + (value1 * value2) / 2
	end
end


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


function inverse(func)
	return function(x, w)
		return 1 - func(x, w)
	end
end


function reverse(func)
	return function(x, w)
		return func(x, 1 - w)
	end
end


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


function sequence(...)
	local funcs = {...}
	local count = #funcs
	return function(x, w)
		local idx = 1 + math.floor(0.5 + w * (count - 1))
		return funcs[idx](x, w * count % 1.000000000001) -- TODO
	end
end


----------------------------------------------------------------------------------------------------
-- Basic Waves
----------------------------------------------------------------------------------------------------


function w_cos(x, w)
	return 0.5 + cos(x) / 2
end


function w_sin(x, w)
	return 0.5 + sin(x) / 2
end


function w_saw(x, w)
	return x % 1.0
end


function w_triangle(x, w)
	x = x % 1.0
	if x < 0.5 then
		return 1 - (2 * x)
	else
		return (2 * x) - 1
	end
end


w_cotriangle = phase(w_triangle, 0.25)


function w_pulse50(x, w)
	x = x % 1.0
	if x < 0.5 then
		return 1
	else
		return 0
	end
end


w_square = w_pulse50


function w_pulse75(x, w)
	x = x % 1.0
	if x < 0.75 then
		return 1
	else
		return 0
	end
end


function w_pulse25(x, w)
	x = x % 1.0
	if x < 0.25 then
		return 1
	else
		return 0
	end
end


function w_pulse12(x, w)
	x = x % 1.0
	if x < 0.125 then
		return 1
	else
		return 0
	end
end


function w_pulse01(x, w)
	x = x % 1.0
	if x < 0.0078125 then
		return 1
	else
		return 0
	end
end


function w_trapeze(x, w)
	x = x % 1.0
	if x < 0.5 then
		return 0
	else
		return (2 * x) - 1
	end
end


w_triangle16 = bitcrunch(w_triangle, 16)


nes_triangle = nes_slope(phase(w_triangle16, 0.75), 1)


nes_pulse12 = nes_slope(w_pulse12, 1)
nes_pulse25 = nes_slope(w_pulse25, 1)
nes_pulse50 = nes_slope(w_pulse50, 1)
nes_pulse75 = nes_slope(w_pulse75, 1)


nes_waveforms = sequence(nes_triangle, nes_pulse75,
	nes_pulse50, nes_pulse25, nes_pulse12)


----------------------------------------------------------------------------------------------------
-- Phase Distortion
----------------------------------------------------------------------------------------------------


--[[
	y = a * x + b
	0 = a * 0 + b
	b = 0
	py = a * px
	a = py / px
	1 = c * 1 + d
	d = 1 - c
	py = c * px + d
	py = c * px + 1 - c
	py - 1 = c * (px - 1)
	c = (py - 1) / (px - 1)
]]
function bend(p0x, p0y, p1x, p1y)
	return function(x, w)
		local px = p0x + (p1x - p0x) * w
		local py = p0y + (p1y - p0y) * w
		
		local a <const> = py / px
		local c <const> = (py - 1) / (px - 1)
		local d <const> = 1 - c
		
		if x < px then
			return x * a
		else
			return x * c + d
		end
	end
end


function doublebend(funcA, funcB)
	return function(x, w)
		if x < 0.5 then
			return funcA(2 * x, w) / 2
		else
			return 0.5 + funcB(2 * x - 1, w) / 2
		end
	end
end


function distort(wfunc, bfunc)
	return function(x, w)
		return wfunc(bfunc(x, w), w)
	end
end


function reso(func)
	return function(x, w)
		local r = (15 * w) + 1
		return func((r * x) % 1, w)
	end
end


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


cz_saw =
	distort(
		w_cos,
		bend(0.5, 0.5, 0.0, 0.5)
	)


cz_square =
	distort(
		w_cos, 
		doublebend(
			bend(0.0, 0.0, 1.0, 0.0),
			bend(0.0, 0.0, 1.0, 0.0)
		)
	)


cz_pulse =
	distort(
		w_cos, 
		bend(0.0, 0.0, 0.99, 0.0)
	)


cz_doublesine =
	distort(
		split(w_cos, w_cos),
		bend(0.5, 0.5, 0.01, 0.5)
	)


cz_sawpulse =
	distort(
		w_cos,
		doublebend(
			bend(0.0, 0.0, 0.0, 0.0),
			bend(1.0, 1.0, 0.0, 1.0)
		)
	)


cz_reso1 =
	mask(
		reso(w_cos),
		w_saw
	)


cz_reso2 =
	mask(
		reso(w_cos),
		w_triangle
	)


cz_reso3 =
	mask(
		reso(w_cos),
		w_trapeze
	)


cz_saw_reso1 = split(cz_saw, cz_reso1)	

	
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


drakma_cosine2saw =
	distort(
		inverse(w_cos),
		bend(0.5, 0.5, 1.0, 0.5)
	)


drakma_triangle2saw =
	distort(
		inverse(w_triangle),
		bend(0.5, 0.5, 1.0, 0.5)
	)


drakma_sine2saw =
	distort(
		w_sin,
		doublebend(
			bend(0.5, 0.5, 0.0, 0.5),
			bend(0.5, 0.5, 1.0, 0.5)
		)
	)


drakma_square2saw =
	reverse(
		distort(
			w_saw,
			doublebend(
				bend(0.5, 0.5, 1.0, 0.0),
				bend(0.5, 0.5, 0.0, 0.99999)
			)
		)
	)


drakma_cosine2square =
	distort(
		phase(w_cos, 0.5), 
		doublebend(
			bend(0.5, 0.5, 1.0, 0.0),
			bend(0.5, 0.5, 1.0, 0.0)
		)
	)


drakma_triangle2square =
	distort(
		phase(w_triangle, 0.5),
		doublebend(
			bend(0.5, 0.5, 1.0, 0.0),
			bend(0.5, 0.5, 1.0, 0.0)
		)
	)


drakma_triangle2square2saw =
	sequence(drakma_triangle2square, drakma_square2saw)
	

drakma_pulsewidth =
	distort(
		w_square, 
		bend(0.5, 0.5, 1 - 0.001953, 0.5)
	)
	
	
drakma_sawpulse =
	split(
		distort(
			w_cos,	
			bend(0.5, 0.5, 0.0, 0.5)
		),
		distort(
			w_cos,
			doublebend(
				bend(0.5, 0.5, 0.0, 1.0),
				bend(0.5, 0.5, 1.0, 0.0)
			)
		)
	)

	
drakma_saw2reso =
	mask(
		reso(reverse(drakma_cosine2saw)),
		w_saw
	)

	
drakma_square2reso =
	mask(
		reso(reverse(drakma_cosine2square)),
		w_trapeze
	)

	
drakma_triangle2reso =
	mask(
		reso(w_triangle),
		w_triangle
	)


drakma_cosine2saw2reso = sequence(drakma_cosine2saw, drakma_saw2reso)

	
drakma_sawpulse2reso = mask(reso(w_cos), inverse(drakma_pulsewidth))

	
drakma_sawpulse2resoalt =
	mask(
		reso(reverse(cz_sawpulse)),
		distort(
			w_trapeze, 
			bend(0.5, 0.5, 1 - 0.001953, 0.5)
		)
	)

:: src/wavetable.lua
--[[pod_format="raw",created="2026-01-23 13:43:16",modified="2026-01-30 18:48:07",revision=11373]]
-- TODO: move into pfx

local Wavetable = structure {
	-- width: Int -- number of samples in a wave
	-- height: Int -- number of waves in the wavetable
	-- samples: Array[Int]
}


function Wavetable.new(width, height)
--	local samples = {}
--	for i = 0, width * height do
--		samples[i] = 0.0
--	end
	samples = userdata("i16", width, height)
	return Wavetable {
		width = width,
		height = height,
		samples = samples,
	}
end


function Wavetable:get(wave, sample)
	assert(0 <= wave and wave < self.height) -- TODO: should be < height?
--	assert(0 <= sample and sample < self.width) -- TODO: should be < width?
	local sample = sample % self.width
	local value = self.samples:get(sample, wave)
	return value / 0x7fff
end


function Wavetable:set(wave, sample, value)
	assert(0 <= wave and wave < self.height) -- TODO: should be < height?
	assert(0 <= sample and sample < self.width) -- TODO: should be < width?
	assert(-1.0 <= value and value <= 1.0)
	local sample = sample % self.width
	self.samples:set(sample, wave, value * 0x7fff)
end


function Wavetable:set_wave(wave, func)
	-- func: (x: Float) -> Float
	-- `x` is in [0,1] (instead of [0, pi])
	-- `result` is in [0, 1] (instead of [-1, +1])
	local start = wave * self.width
	local length <const> = self.width
	for i = 0, self.width - 1 do
		local value = 2 * func(i / length) - 1
		self:set(wave, i, value)
	end
end


function Wavetable:set_wavetable(func)
	-- func: (x: Float, w: Float) -> Float
	-- `x` is in [0,1] (instead of [0, pi])
	-- `w` is in [0,1] (0 = first wave of the wt, 1 = last wave)
	-- `result` is in [0, 1] (instead of [-1, +1])
	for wave = 0, self.height - 1 do
		local w = wave / (self.height - 1)
		local wavefunc = function(x) return func(x, w) end
		self:set_wave(wave, wavefunc)
	end
end


return Wavetable
:: todo.txt
--[[pod_format="raw",created="2024-04-10 20:46:30",modified="2026-01-30 18:48:07",revision=9743]]
- fix selection appearing on other patterns
- fix first note on the track
- fix selection drag (cannot collapse)
- fix note playing when entering fields in selectors
- show hollow cursor when notegrid doesn't have keyboard focus
- fix keyboard focus for notegrid
- fix num fields in track dialog and settings
- fix num field entry for tuning in fm node (must support fractions)
- add scrolling support for synth knobs and fields
- remove vertical drag direction for knobs and fields
- show next and previous pattern in notegrid
- allow editing note, instr., vol, fx in a single go,
  then jump

- chord mode (when selection span multiple channels)
- paginated mode, both for cursor movement and playhead following;
  configurable length: screen, beat or bar.
- add track config for beat and bar length
- add song config for beat and bar length, plus some settings

- add auto-hide ruler on the left side for row numbers

:: .info.pod
--[[pod,author="drakmaniso",created="2024-04-16 13:35:13",icon=userdata("u8",16,16,"00000001010101010101010101000000000001070707070707070707070100000001071818181818181818181807010001071818181818180718181818180701010718181818181807071818181807010107181818181818071807181818070101071818181818180718071818180701010718181818070707181818181807010107181818070707071818181818070101071818181807071818181818180701010718181818181818181818181807010106071818181818181818181807060101060607070707070707070707060601000106060606060606060606060601000000010606060606060606060601000000000001010101010101010101000000"),lowcol_icon=false,modified="2026-01-30 18:48:07",notes="An instrument and wavetable\neditor for \".sfx\" files",runtime=24,stored="2024-04-16 11:37:51",title="WaveMaker",version="0.0.4",workspaces={{location="main.lua",workspace_index=1},{location="gfx/0.gfx#53",workspace_index=2},{location="map/0.map",workspace_index=3},{location="sfx/0.sfx",workspace_index=4},{location="pal/0.pal",workspace_index=7}}]]
:: fonts/.info.pod
--[[pod,created="2026-01-30 07:12:02",modified="2026-01-30 18:48:07"]]
:: fonts/p8_mod.font
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI2LTAxLTMwIDA3OjEyOjQzIixtb2RpZmllZD0iMjAyNi0w
MS0zMCAwNzoxNDozNCIscmV2aXNpb249Ml1dbHo0AHsFAACjBQAA8INweHUAAygACAAABAQIBhAD
8GpHMCdABwUHQAUCBUAFAAVAJTAEBgcGBCABAwcDASAHIUAkByAFBwIHAkACcAECUBMgFVACBQLA
IgACIBVQBQcFBwUgBwMGBwIgBQQCAQUgEwYFByACAVACIQIgAiQCIAUCBwIFMAIHAmACAUAHgAIg
BCIBIAclByADIgcgBwQHAQYA8QkGBAcgFQcUIAcBBwQHIBEHBQcgBzQgBwUJAPANBQcUMAIAAkAC
AAIBIAQCAQIEMAcABzABAgQCATwA8DQAAiACFQEGMAYFBwUwEwUHMAYRBjADFQMwBwMBBjAHAxEw
BgEFBzAVBwUwBxIHMAcSAzAFAxUwIQYwFxUwAyUwBhUDPADwFQEwAgUDBjADBQMFMAYBBAMwByIw
JQYwFQcCMBUXMAUSBTAFBxYA8B8EAQcgAyEDIAEiBCAGJAYgAgWQByACBFAHBQcVIAcFAwUHIAYh
BiADJQMgBwED3wCgAQMRIAYRBQYgFSIAAPcA8AIiAyAVAxUgMQcgFyUgAzUgBi0AgAUHESACFQMG
RQDwCxUgBgEHBAMgBzIgNQYgJQcCICUXIBUCFSAVIQHyFAcEAgEHIAYCAwIGIEIgAwIGAgMwBAcB
QAIFAjBPfyAPVQ8qBADyBiAPQQ9-H10PPiAOH2MPdw4gDxEPRAQA8DIgBA88DxwPHg8QIA8cDy4e
DxwgDzYeDxwIIA0PNg93DzYNIB0ODQ8UIA0OD38PKg86IA4PZw9jD2cOIA9-D10Pf1sA8BEgDzgY
Hw4gDg9jD2sPYw4gCA0ODQhAD1VADg9zD2MPcxIAoA9-Dg8iIA4NCA0pAPAKdx9jDjAFD1IPIEAP
EQ8qD0QwDg9rD3cPa1cA8CIADAAMIE9VIA8OBA8eDy0PJiAPER8hDyUCIA8MDx4fIA0gCA8eCA8k
DxogD04EDg9FIgBwIg9fHxIKIBkAsDwPEQYgDxAPDAIL1wDweCIPeh8iDxIgDx4PIAACDzwgCAkP
EAILICIPIg0gCA4ICwggDxIPPw8SAg0gCQ8QD34EDzggAgcPMgIDIA8PAg8ODxANIA4fQA8gDxgg
Dg8QGAEgCA84BAIJIAMHDxIPeA8YIA96D0ICCg9yIA8JDg9LD20PZiAPGg8nDyIPcwMgCQ9KH0kP
RmUAEToEAPJkGiAPIw9iHyINIAsACA8qD00wCw8SDyEPQCAPfQ95DxEPPQ9dIA4JCA8eDy4gBg8k
D34PJgEgDyQPTgQPRgkgCgkPWg9GDzAgDx4EBQ9EDzggDxQODyQYIA86D1YPUg8wCCAEDQQFBiAI
Ag4PIA0gHyIPJrwA8gIMDyQPcg8wIAQPNg8sDyYPZBMANEIPMK8AECMoAfAaDg9kDQ8oD3ggBAIG
DysPGUAPDgEIMAoPHw8SBDAEDw8PFQ8NMAQLBg-KAfAaIA8UBAIgDzAIDw4YIAgODyIPIAwgDigO
IAEPfgwPFA8SIAQODyQPIgNrAUAOCCAJDQDxAQEIIAQPfA8SAQggDi8gDiDkAPECJA8gASAGBw8m
AQsgDgcBDAU6AACNAVAPIg8kBxYA8AIPIg8tDzALIA8cCA4IBCAfKhYAMA8cAA0A8AcUDQ8kBCAI
DhgEMA0QDiAOBw8oAQ8skwDzDjAPXgggJwEPDiABHyQPRA9CIAIPHhINIA4XAQsgewFgMAgOCB8q
NgDRFAgBIAkADgAPHiAIBB4BQH4gD0BNACBoBnMBMQoECZkA8BMUIA0hDiAKAQoBCiAOAA4HDCAj
BwEgLxQPVA8yIBIPIg8SIAFhLyIOIA4FvQDwEgcJBwwgBhcBDw4wDxUBDwgGMAQKDxQEQAsPCAow
DQwBDXAAoGMBCCAIAQMECCA=
:: gfx/.info.pod
--[[pod,created="2024-03-24 00:48:06",modified="2026-01-30 18:48:07",stored="2024-03-24 00:48:06"]]
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2Iixtb2RpZmllZD0iMjAyNi0w
MS0zMCAxMzo0ODo0OSIscmV2aXNpb249OTk1MV1dbHo0AGAJAAAzPAAA8yV7WzBdPXtibXA9cHh1
AEMgCAgEwBdABxAXIAcQFxAHIBcQB0AXwCxmbGFncz0wLHBhbl94CADXeT0wLHpvb209MTF9LEMA
9g8QEATwCC85wA4HHrAOFx6gDicekA4HDhcOkA4HHgcGAOIOBx5gPgcuYB43DoAORwQAfx4nHpBO
8AZwAAsdOG8A8AoKPzmQLhcOcC43DlAuVw5QDkceBw5QDic_BgBBBy4QDggAMg4QLggA-xMAHicO
MC4HDgAONw4gHicOAB4XHiAONw4QPjAeFx6gPvAKgQAdchM-OaAeFx7cAPAGgB4HHgcecA4HPgcO
YB4HPgeOBwYOAgASBwYAYY4HPgceYB8AEXArABKAEwECfAAfA3wAGf8NEQ8EAO8SAP4qB-4AF_4n
3jfOJ94X7gf_LADuAEgACx83SAACMzpHvgIAL-46QwAkMTsnzkEAT84n-jtDACEfJUMAKv8HCAgE
MAdgF1AHAAdABwAHICcwN0AXsEIAGfAGDAwEYD85YB4fOh5AHg0eDQ4wHg0OAgB9IB4NLg0eEAYA
ICAOBgDfMA4dDg0eQA4tHlBOYHAACywxMHEA8APwDD85cA4fOg5gTmAOLQ5gHh0EAJ8eUA49DlBe
8AtPAB2UQE85UB4vOh4woAA4Tg0OBgAgEC4YALAAHh0OLR4AHi1OELYAbx4NHnAucGsAGl8LBgTw
MlwBDA8xAP9SAIIEH-AxABn6BjgIBB8g-yQkLyAPJPAkDg8gDvAmHgMAGw5QAOMzMS43MjM4MDk1
MjM4MV0Aoi0wLjUxNDI4NTcGAAJsABw1bAAkDyRWAAZfAAB0AG8kDi3_JB1pADhPLyQQHgIABBQ_
egADgAAv8GB4ADWvBQUEYAcgJwBHQIMBGUAFBQQgXwdvJyAXMAcAOgAcf0BHACcgB2A2ABxgAAcw
FyAn2wcfIDoAHV8nYCdgJ6YAGhAH4AB-QCcgRwBnYDgAHH9gZwBHICdApgAbAEYFH4BpABpyBwRy
TzsSTgIAH3LjCBoDPAByDi8RDhIOLQQAD0MAHGEMBgQwFyClBjEABxBtCTUQBwAIABMwGAAQQIkJ
DwAGGwBZAP8KCHAHAAhgFwAIB2AXCAAHcAgHAAdgCBAXUEsAGlEFBQQHIIkAFSAIAA9BAAwfNqsC
Ii8xNlIDIg43ACHwBKcADzcAGvAACQkEsE85MA4vOg4wDg0uHQfvEA5NDhAeLR4gHg0eQC6IAhoA
TgCxLzlAHg86HiAeLR5KABEuVgB-DjAOLQ4wTk4AHYGQbzkQDk86DkoACAQAL26Q7wIc-wEwDxZA
HjAuID4wLkAeUA4QPwAc-wEQDxZQHkAuMD4gLjAeQA4wPwAMD5UIZYIHBwRwTzoQTgIADzwADR8y
PAABcg4vEg4QDi0EAA9DABzxGRcXBPD5AfAFAQcB8AQBFwHwAwEnAQAB8AABNwEHAeABFxEnAeAR
BxEfABIHHwAg8AMKAE8FAfAMQwQaCmsABEwAEAIFAO8BAUcB8AAhByHwAiHwVVYAHhNuVgACUQBV
EQcR8ANlAEUEIfAEDQAQAxwAAXIABMMAH25tABqQGRkE8P8qAfAHPgBwBgEHEQABECwBABAAACQB
8APQEUcBJwGwAQcBRxEHEcABVxFEAWA3QfAAMQBDARAFgAAzBAEnsAA-BwEwPg0ZD6wBASQx4KkB
VyEHAfAAqgEE-gAfIo8CGghkABUDmwEdAVQBH1VWABr8KR8fBPAeBfBDBfABBfACDzpHDvAGDocO
8APH8AHn4PcBcAUwDvcBDjAFYPcDDz_QDvcDDpD3BQ2ABAAAGQCgDUAFMPcDHRAFYDMA-xYNsPcB
HcDnHeDHHcAFIA6HDh0ABaAFQA0ORw4tIAWABXBtUAXwEwMMHzasAAoQRqwAoYYO8APG8AHm4Pas
ABH2rAAR9qwAjPYDDpD2BQ2ABAAiDvasABL2rAAQ9qwAgfYBHcDmHeDGrAAVhqwAH0asACr8Jwfw
QwfwAQfwAg88TzsPPPAGDo87DvADzfAB7eD9AXAHMA79AQ4wB2D9Aw86kA79Aw6Q-QUMgAQAABkA
oAxABzD9AxwQB2AzAP8VDLD9ARzA7RzgzRzAByAOjQ4cAAegB0AMDk0OLCAHgAdwbFAHrwAeQeAH
8A4DAB8ktABNIPABswAh8AOwAB-ArgAgAO0DsBUH8AIHoAfwGU87rADzD287DzzgrzuAByDOIAdg
DzzODZDuDzpw-gFw-gEMYAQA-xwwBxD_AQwAB1DuHHANzg0MkM4coK4cwA1uDRygByAMTiwAB4AH
UEwwB-A-lAYZcBkZBLAH8AiRAD9AB0CTAD5f8ABM8ESQABn-AQkHBPAFTzogbhBuEG4gTgARBBrQ
CQcEoE87IG4QDk8PDj8AH6A-ABrAHBwE-zoIMA72Bg85BgAVDQUAUF72Cg0OBACx-QCWDfAADiYt
DiYIACwNEAkAuz4mDb4wDpYNDpYNBwAfvTcADGTwAA6W-gJqABktgQAEBQAv-QdNARn-AwcHBFcA
ZzAHADcANwAHMGcAVxQKGjAHBQROAx8BhAEbfwUE8AMH8Ak1ABpvCwUE8AsH5BEPDvEPDzIA4hAH
jQ6fIAdQB1AHYCcgOwAaEAg7AFEwBzAXAAQAP3AnMHoAHWQnMAcQByAEAC8nMJECGgM-ACIAJwQA
Dz8AH683IAdQJzAHUDcgOQAkLwdQOQAfTzBHECc5AB8CowEQALwOTwcwJyA_ACBvMCcAFwAnPgAl
RRAHIDeoAQ9AACJPAFcAJ0AAIxAnuw8SMH8ALzcg_BMcQAAnYAc7AZ_QB5AHIAdgJ2BAAB4EqA8x
AFdQCgAyQFcgWRAPTAAeEjeLAAcEAB83QwAeBo4AAoYACQwAD08AHmBHUAeQJ3AdAS9HUDsAIEAH
kDdgBgAPOwAdExBJAQFRASM3EFkBH5DbASYgEBdOAT9gN1DdAS4kEBdNAT8QN1CQACRFIAdQR_IB
D5IAKAPVARVHCgAOUAAPcwIULzdgcQIjrwMFBDcAFwAXADfsBxoxAwUEdRMAmAUPOQAdTycQRxA1
ACAvNxCjAB4CoQA-NxAHOQAdPzcQJ24AHz83EDdGAR8yJxAHAgAPowAeLwBHbgAfTzcANxCjACEf
AHAXDy8xNtgIHw8yAP-------------------------------------uUD0xMH19
:: label.png
b64$iVBORw0KGgoAAAANSUhEUgAAAeAAAAEOCAIAAADe_FMwAAAmUElEQVR4Ae2dX2hcyZ3vj3r7
LlwIzHLXktZgu910Mi_BJgOBPGg6mc0Fj8N4BNIo9oJbNzFtgyU17euZ7rQgLXkk9VzU6c74SshW
wG60uepZ1hkzAtuBjGFhxj2_ZiEwuYLkIUzTlnZAsSRMBkweEhbfh3JqynX_dJ0-df5_PzTN79T5
VdU5v1P1qde_p1-8QQEAAOA-4i7P98kLZ31bi5e-uE6C9dUlwS7jExewhgAAkuh7_sUf2Gu1mxx0
kAU7v-zFdcFeRK82D4CXv7gubmc4GgA1ZAeRfcHGBslcvvi2EswX15re9u-5POurS_MTF8i-uA_J
tQyIi5TA1Ms4KKyeT2-B4wAAd_xMgvXVJVPaEjSyWdWwyXoWtoNZOws6mhc09xpkVpF3loHB09N2
tZeprGFtAIALB5Ll84M4ysDRvKDpBGR046NG865sa6vNS16P-MszsvFZBQBw0HTiu9IPD889hoOi
4AXNmqjny3tVHXrmEB2TS6pm7q6DHwCOBkCG3dhtJb7LaJq4iHqO7I7TWDURWZkQNHkHrmTib_vm
G7JeZl-Y4K7l4x12BiBwmN2zevkOas2UlHhBm9KQbBeTs0UtXHrmOOVfGV8agAhCBLK_ukTkQHaN
sSi4nSV1owkqi00TeR5Tz6z2mAF9T7-4g2sfz02fWj4SzK4P2acUACCyxFACAADwJ32zX3sDVQAA
AB8SQwkAAACCBgAAYII4jebfHjZOnX37FuoFAACu0Tf7tTdE7AxHAwCADFr-_SkJsn-zEncrrtnh
6YlX__58iMIBAIBsO1Mvs7GRoC04eu7XV0hw6ZtTJL70zSn2Fm1nb6kPEIOY-hucPyKxZnfSTmO2
kcsBAEhCTxFRsDMrOtoSM_j89MSr4jORgtKyUh3P-frKpW9OsXfVpScPRB_Le2KR2TW7sMNyU3AF
onZWF4vLAQDIszNxBbXHV3Mv0n_H5xr9PvnRmLvF5ej1lU3c_PbTE6-23fnQkVNR-EhkRUkUqXna
cF00Y8HpxE8CAIAL6Oli-u1hU_McWb7GXv7w8eCz8T94f270_5c_eJ_71GzUeLwP3ndH0DHj2-bt
TM5DU12yf-MSlSzrTbZd3YVmmlIt21HE4wAAN-lq7kWXZ5wb-b478lU7rfWfn3I6ijtl57lfXyH-
nI5Ju1lHuwapDi2KukCwMwDuQ0zyWfP3Ljv60gfvE0e7KR_qF7V8_ma-9oaiKPNvD7OtT0_8qmnn
2bdvYekAAOR5_ZkovzlFG7_ae5GY2smJ-qrgSx_8Pzf6ffafapqk0Vizr007a0q5t6D1gKABAMAm
gnZWFCUmbl7YGQAA7EO83NPOiqL0zX7tDdQLAAB8SAwlAAAAfxJP-vgNVAEAAPwo6FQqiSoAAIAP
iaEEAADgT_I0aq4sRvD9c-lpLIKH92_hCAB4ztGhYV1BK4ry8_HRUL72wv-7i2b7Z1u35Snv6NAw
_acGZFu4HKpILnbHzpWNNvYGAJ5TVe365wTN8vTEqyTou-NhOF7_O69-ncYf3-6ta-NyCrZ2kMLO
AISeykabc7SuoImaqaafnng10KZm7Uwu3XS0oJSpxInTo7Ai3-v3v5M3_Olv-RF7HgQaI0FzslY3
Un2zKufiyFaW2taarKNTqIxyR8awbeUEtjeIiqCfnnhVbVu2RS-2Dx-f-i2Nv-P616XOdXRo_OH9
W9SzXEwSSI6B3N3X9Nbdm84OmDg2JpT33s8dfpPTPxDJ2v5xv7PTHnlnD04BLgn66YlXfe5cU8iW
strRXKB2LpfD-gMAQEzvRt_dD8kvNK-68e3f0h8_vAjrq0vrq0skYP9JQGN1jiBbd29qtg9cLA1c
LBnHmsk251UUZeDsffLjYr0cAKQSj86rfuf1r-vnYTLpZHuz63M7j09c0Lw1PnGB3KWB5Vle-uK6
8sI-cMLdvVwnziUx264egSabdXTi2Jjmrd3rQ8Z9SQIEDdwW9Npf-ksoX-Jz5S9_eySf25k6muiY
xiL5nAd79nr6xR-67nyod5fIV1PNxmMqirLVy9F9H09ozHj2PnX07vUhtYihZuAaMb0bC-OVhflK
aN7z49u-NbgEasYnLhA1c7FxF64lcWyM_7GNJKfvhX-QG3D3ct2smumYn7xwVj07Oy8N_En-amcD
dq8PiaQBIEvQM7NVztchcDT9uTNjJp10rZfjrK8ura8uEeeSWMYsn7xwVt04cLFEvDxwsUTj3ct1
cqlOpv-i6NlZkIGz9wfO3oc_gGz67rUfkKi5svjK905xUuY0zUGtPTNb1Yv98JKf-_5Pmu2fbd3O
5afdfJJSrbazt8_2HOw-UC_XvarMw-u3Khtterl196az46s9uHX3Jtv43r--XUa5o7z3c4df7PQP
2sqJ09-6o3HW9o-7nZ32yDt7cAqwQ3Ukc3RomF7GBbtpyppt0YuBppq3rhQSU8uKouzs7WeLJW81
DQDwJ7qCXpivsF6Gc_2QLZaME4imW426t8_ZODbmzcSnf_DJtEfe2cPiBIEUNIzsmp3ZTM8d7T5t
5QQWCQDmBA1ctnM0HX36W3-EIgFAjxhK4CCZdJK9LNVqFgbhenFjAgCiQ1zvxsJ8hQQzs1WUSZD2
Zpe93NnbtzDIzt5_p9NNpZ55mRsTABAdYno3ZmarrJqpr4EgpVrNct_f3fwFCggAiOvd4IzMylqd
MzNb1YsjW9mdvX07fTudbiqVxAIFAILWhtXrwnxFbVu2RS8GoCfbhXPODnhk_ZpIWnUk4_y8lY22
SNrWK3ln5018tIJVFDlBL8xXqG3hXAAAcJmY3o2Z2Sr5oUYySEwtowhbd29qtg9cLA1cLBnHXLK6
XXze4rtN8tOMuTRuKJppYd7BtQL5qWPNHL2_IMTEUQLgraMTx8Y44e5erhPhkphtV49AGk0JWj1v
480ckSwJGm-m2Hau0cH3fXTm2Tn96Mzy4FqBXrIJmu1sXwBBA9Mc7D_ws7dvuW_4pcxd9t35UC_Z
mFdTzVyOwRR6j7G_ukRiO-4lZjc1r-K-PiKxnnxFGFwrQNOhJ6Z3Y2G_Qn6okTiZdJLG9XLZ8jjn
x05qjhkCEsfG6I_26CXvXq4bq5mmGcyi-qnnbbyZYz0r4mLakTW72Xkt6-XRmWWoOdKCnpmtzsxW
WV_jWD1pb3bZy4P9BywMQnqlUs_8zI0ZMjTtPHCxRJw7cLFE493LdXKpTlY3WpuXKlhT1iIGtzzv
4FqB-pOAxnr5xgkgHPTdaz8gUXNl8ZXvnWLvESmzmuag1p6ZrerFfnjJz3-3J832z7Zu5-LTUqfO
Fk27Y25ikhW0VB7ev1XZaHv_gbYL55wd8MjyNZG06kjG2XkFi7n1St7hc_6jFbgsHFRHMkeHhull
3CCVVe3CfEVtW7ZFL444rUbdlKPdtDMAwOfoCpqqGc51zdGRtfOR5WuezFvZaHsyb_KjFewLIEJM
78bMbJX8UCPLZNLPVNtq1A-2HzDIPNh-gNqZ9gr3oYXlgdoC64IG9u3c3uzSy3q5PDcxqdY0UfP5
sZPEzoqitDe7oXd0tliCRyTZOVssoQ6hIY4SuGBnQiqVrJfLnQ7fTtVMIY5WjxBlR1PvwOwiVQIh
F-TCfGVmtkr_USazGLiVc7GFEaJpk1ajTpwOB4HoEBPMW5ivoFjAW5vDziBqxAWlPDNbNUiYma3q
xSgxcNDRKAKAoL90K1XtwnxFbVu2RS8GoCdbwy85O2Di1qeoKggBMcE8OBcAAPwlaHgZuMbg0g3y
Yy9JQP-Zdq4vCgjCRxwlAP7h0YVTVLg05kT86MIp6BhEhBhKAPyDnnlFjDy4dAPiBiEjrndjYb5C
gpnZKsoE3OHRhVN67T3lK5IDQLCIGdybma1SO1NfAyCPwaUbRLLEtprCHVy6oelx2BmEj7jBPSJl
4mhqanUCuasXo8RAEE679JIE7H-PvgCEXNDErVS1C-MVtW3ZFr0YABBuqiMZElQ22iSubLRpO4n1
8tk0ri9pof_afaMraKpmOBfIJnHrUxQh0FC90pgIlNOrptz1_hrMxXUPcWFjejdmZqvkh8UHADCG
GlZc6I7MFW47GwkaAABcEK6ducweDIEjjrUFAHAQVpoiAq2OZKhzaX5lo60eh6SxsZsHg78EvTBf
mZmtYrUBAIxhXckaU8_egvn0UmTMsBITzFuYr2AhAgCAm8R7Snlmtkr-9aw9M1vVi1FiAABwXtCs
ahfmK2rbsi16MQAAAGvEDO5RO8O5AADgPnG9GzAyAECE7cI5O92PLF97brQf99sa7Z099rI6krEz
WmWj7W1tY1heAADgTyBoAIDDDFwsDVwsGcfmBjx7n-y4WJziu03y04y5NP9UMq53Y2G_QoKZ2SoW
HABA3M67l_tExCRm2y0Pu3t9yOaDNd7MEfmSoPFmjm3nGn1CTO-GzGyVVTP1NQAAmPI1kbXdcc7e
tylrH-q3J3HBPFbWamvPzFb1YixQACLL7uU6cbQDQ1mSMkvjzZyIo33lcVFBL8xX1LZlW-RiAEDU
GLhYYtVM4t3LdfbSQ4rvNvVETG75B1FBw7kAABFY-3Iutqzm3etDXMy2iEBczP4bt-uEGLwMAAD_
JI4SAADscGT5mpOjvbPn4GiVjXagaxvD8gIAAH8S17uxMF8hwcxsFWUCAAAfCZqomWp6Yb4CUwMA
1Gy9krfTPfHRynOjDb9ka7Rbnz43Wv4TW6OtvOxfQVM7E1kbJLAq52IsXwAAsEbM4B6rV1bWbAL5
GcQAgIgwuFYgP3WsmdNjtKUb5MdekoD_s_29B3xrYPCtARKw-2w7jX1C3OAeK2XYNgps3b3p7ICJ
Y2OoaqR4dGaZBoNrBXrJJmi2a4924RS1MI05iT_6cEpE0INvDTz66a72LD-dpVJmYz8Q07sxM1sl
P6w5AIAgg2sFJ0fTMa_IkTUdTeXLWlgv9gNxLClgzPrqEgnGJy6sry6NT1yg7TQGgPDozLKTo104
pddu1tGPfrrL_vfRT3f1Yl-VM4YlBXoCEQOzDK4V6D8JaGxikKUbRMTEyJpSHly6oefx59LeGhh8
a8Bv-u1J3732AxI1VxZf_d6X77kwXyHBzGw16Gvl89-9SbP9s63bufx0lHfRw-u3Khtterl196Y6
Z311iWp6fXWJypqN9UgcG4OqQs-WK3k73RMfrTw32vBLtka79elzo_U-sTXayssuF7M6kjk6NEwv
YwaprJqpr0EE6SliAIAM4gb3WCmzslYnzMxW9WKUOGSsry5RZbMxiCyJj1acHO3Wp06OtvJyOAVN
3EpVuzBfUduWbdGLQdAh-mX-2XYAgDxignlwLgAAuEwcXgaUxLExFAEA-xBDCQAAAIIGAABggrje
jYX5iqIoM7NVGtNLEBqODg1XFaWy0UYpAPCc6kjm6NAw29J3r-2ARM2VxQhWJJefxrJ4eP8WigCA
53B2VhQlDlUB9bIAAPiBGEoAAAD_pG-tn-8FVQAAAB8ST6WSqIL7dDpdVB5guQJjYigBAAD4kzh3
fbv_GxRFHq_XvqFu-Pb271EZ4EPuHXlR3QhFuKmIGErvJuoKw87At6gXJxThsiKeEzTLT9ZHyI-G
3C0uR68vMMXAxdLAxZJxrJkMgOUlpxn3BIpwgbjBvR_Nb9AKkpj_a_bo9aWfhEtA9dVbZfdynWwS
ErPt6nyaDIBlyCqi-6b6WlYESYAiehIzPiENTk4aC9aR_2YovYiv4V-gpqPNdrSsCDYBirAoaM0a
-Wh8o_fxaDwgSi_4ZyxsGAAsQOw8cLFktqMdRXBpUIRpQWseleTo61lBPWuj9CJbhQQ0JptHvX9I
i4V9BYB6yVlztB1F6IkbH4XSd6-9gF7crv8GFZHN66VvKIrS6XRTqaSiKN-e-j1qAnzLvSMvsssV
inBNEYSY3g0gu-TsBgDAt3aGIjxURBwfwIfbAICgGARIJYYSAAAABA0AAMAEcZGk5soiCXL56Z5p
xjnimYKTqskWS_rGVqOOjw2AJKAILwVNSkDL0TOtZ1kFCyo4ac9as9_Dm51dBzS2-OGBf3h4-xaK
YIqjQ8N2ukMRXgraWhVsHqTi38nyY9Bas7GdDw98YufKRht1MEXVnqOhCBnExI9Hp6bM5adlH49O
rQ8AO0eHykb74f1bdvY1FOE4cfcfWvBs9BafP57LpwhXDa-mBSEAinBe0ORRej6Q_KHn4KSWlwgZ
ubmySKdgYwACwXbh3H-74Fdf_fw--GArKMIbQQeObLEk8u1F4mCRy0_TNaReYaSFy9FceTTT-o7V
W9_OTAGInR_PHld84GgoIgyC5urSatQdn0LGmIGWtXgXZ71pcACwBwawY_evfP4fX1m_tl04B0eH
UhExb08tg3MMuAMrSlM2FzkhJI0MqJ3J5ZHla49Hjz85dBiVCRlxzdZMOsm1JI6Nbd292XO4nmlb
VwrP5U8tdzrdH458V3y09mYXn01Qi3Zk7az6myuLcLQkO1NHbxfOKap2SchThP20MClCW9Cabyj4
2sZpiallU12gY7NOzOWnqRm5mCQYuJLmoJLBsrP7jpanCElpoRK0JFqNerZYYlvmJiax5Rx3NBeo
ncvlsP_OP4bmLDgDHLez_44GYRM0cXSn0720epWqOZVK4jMAYN-OcDQE7QDEyPCyfXL56UjNCzsL
OheODg2xnhmZdDKTTrKBf9IAgJ31HP149PiTQ4ddeDwoQh7xnhntzS4X_CcNWNhLKGno7UwdvV04
p1jqawoowktBgzABO0fEzi47GkDQAMDOcHS0iKEE4SOTTrrWC-jZztTRj0ePPzl0GFUNoaAz6STZ
ujTwTxrQpL3Z5VpKtVq2WGJ-pVqtZy-PzwzY2akBpToaipBHXHy3G29gT9JAT0q12s7ePr3culJI
TC0rirKzt58tlg72H6iXy6hSuO1MHb1dOKdIGBmKkEcM_yHEZIsl1s5qiKYdnzeTTjqSAzs77ujH
o8efHDqMOgeFOEoQYjuLZ7YadQenbm92LbQAqXamjt4unFMkzwIgaOCMnSU5Wu9JJM0CO8PRoSTW
MyOTTmbSSTbwTxqg5WIvS7WahUG4XvbLXqrVqJ23rhSor609HuzsrKMfjx5-cuiwU8sPipBE3732
A5G8bLHUatT9mRZEOp1uKiVrVVEtqtm6UkhMLevdnZuYdOqpuGdQzyvvyz68f6uy0YadLcxbHckc
HRq2tlyhCBnEQvxu0aRUq1nu_7Obv7DcN5P_cgMbnBCaOWzfqOGVnRVFObJ87fHo8SeHDmPX_JY4
ShAydvb27fTtdLqplBVdtje7Zk_IUq1WL5fZvrCz_47eLpxTPH0GYFHQmfRzG5W9ZHeUJ2kgBCeE
nfMAdvaDo6EILwXNva3ey3uSBvxJtlgylX9p9WqrUYedfeJosx2hCNnE4JRIkZha9tsjdTqRO4N9
ZWfq6Mejx7FB-EYcJQAwIJ6NOFoZyWDxQNBAIgf7D_zs7VvuK_mpElPLLrtmu3BO8Z8H-XxyAB8S
65mRSScz6SQb_CcN0HLRuF4uWx7n-NhJzTFNPYD9V3DK0Y9Hjz85dBh2dmH5QRGS6LvXfiCSly2W
Wo26P9OCSKfTTaVkrapSrbazt2_218H_A_fHTtp-qmyxJJ48NzGpKIqzpXh4-1Zlo_03JwbCztWR
zNGhYWvLFYqQQSzE7xZZ6uWyhV7nx046MvvB-gOmMuUdVIqiHFm_9nj0_JNDh2FnEETiKEEoaTXq
2WJJPH9uYtIpV9bLZcGpnToSejp6u3BO8c6PsDOAoIF1RztoZ-GpHZ-Un46GnYEdYj0zMulkJp1k
A-_kAb3qUVEe7D9gkHmw-wAVpbN1NpiandS1mhxZvvZ49PiTQ4dhZxnrDYqQRN_99gORvGyx1GrU
-ZkWRDqdriQ9ZdLJ9maXm_tnN3_xs7fPWfL82EkS0ydR97X5AJ1O99LqVfYuUTM9EuxPp_bh-VuV
jbbnxgyinasjmaNDw9aWKxQhg7hTA2WLJTYId9V8i6byUqlkvVzudDRUyO269mbXvjTZ7qlUstWo
c1PTSWXY2Zgjy9e2C_cU_d4Mop1BaAVN7Rydk82fGCiPc7GFESwjOHVoHA07A38JWlGUrSsF9jIx
tdzpdH21MwFwwdGwM3CQWM_MTDqZSSfZQJPE1DL7szmaYBoAlh39ePT4k0OHYWf7OLupoQiWeM_M
9maXC9S0GvVsscS2zE1MWh5NPA0AO47eLpxTnPNpNO3s_KaGIswJWpBWo97pdC_tXqVqTqVCe6z5
nE7H4pK1_cm8mtcPjo6snYHHgs4WS2zQatSNt5kjm018UiDCpdWrJJibmGRj92f3W2UccXTE7Sy4
Wz1JCzoxwdIbtMj73m5OGmhKtRr912RuYpLKkY2dmronPlQz6_jHo8efHDoMO8vbrZ6khYC4Zmsm
naTx1pUCeysxtdzpdH848l29Edm_BhinGUza3uzCyBz1crlUq9XLZYOcS6tXucCATqebSvX_jvRg
MJ5aHMF5ZTh6u3BOMe-ZyNrZgiJcSwuTIrQFzb5hYmrZOIGl1aiLVKdnmqlJAVGksSjnJiapmucm
Jo0HFLSkyMFgCk-sbNnRkbWzNUV4khZ0Yj1Nqt7nsp-Jk0kDDVGkgSgvrV6ldlZf2p_6J05NJ9vR
j0ePPzl0GHZ2fLd6khYC4iIfoNN57lxKpZIufHX3Jw0x7PJ1fykHaPMcWb62XTin9DIv7Gxht3qS
Fn5Be-XmMHLgSheOT9bT0bCz5U-vSVr4BU1PKr2KdDrdVCpJ-9XJbKNebHZSANx3NOxsTREepgWa
mLMnpF5yKpVkG9lL7lbUTkjgW0c-Hj3_5NBh2NlZRXiSFlzijh_hInfJJSkuGwMXvoW85e7VvPIc
vV04p-zVyLAzCKqgWdX23IRqL1ve2EC24l1Wp1fz9nT049HjsDPwr6BNOVQzmRqZvWs8LMTtrZ1J
7JorvZpXxNGws1OK8CQt5IIW3CokTTOZbdSLrU0KgAuORhEcVITLaYEmhrUFQsbRoeHqSAZ1MEt1
JHN0aBh18BVxlABwpFLJTqdL4yDOe3RouIoPab5oKAIEDYLh6KDPC92AENC39s--gipESoLADs2V
xVx_mv6TRrZF3S4S5-LTdHzazs2r2e4OnU4Xn94T4tCEJ2DFhwNWtVy7pn-1NK3Zt_dc3KVUd0MU
nhBDCQCwjKZhBdtZcYv0NVa5VDsDr4hz17frv0FR5PF66RsoQpiknMtP00uuXU_pNI3E6kxTqtUb
RB5QhJuKiKH0boIKhxWiSCrK5soi6_ueomfz9frqDQg7h1gRcb28n6yP-Gh8g8YkIC3kkt5lc7hG
AEIpYk0pqwPNdq6XQeyVhcWhu57ogkqDbddUB9fODQiT9BY0Bytrtr5sgrqRa0HRAQgNVMcG7Zy1
NS2hVgSXE2WNxEwdlWZhSwk7AxAdd-c0hp4Q1B2jrBFRQVuuC_kIOwMQEX40vmFnv2v2jaxG4sbH
oGZRfrI_otmodwt2BiCUIqaKoLGBN-T8oNaIuLhDT9_99gN6cbv_Gyw72bxe_oaiKJ1ON5VK2hyq
ubLozjPn8tN_mFceqKQxdLlCEa4pghDTuwFklx4ALGBgXOE4PkBYyeWnSdBcWczlp9l-0sjlSJqX
i9l5HZxUdiW56ulV1amXEpyFllHGd4Sj-UAMJQgrZK9q7lhuSzu_q9kB2fE1lR3Qwmq2O1hJg1nY
Y4OtbVAOPABBA1FkWJK4Q974-qyYs2-KjmYQ08vw1RkoihIXP8m5XcftwObKovES4fqy-9w4Nnd4
tlhSN7YadXxs4_-i7Jj0C8oY31sps0uda5f0XdgZaUx3irzviI0WAEGrD221OlnhGo_juYzYzczN
Ze2tuFXCriRuCnaV2z8b-GxhvXdh312GzvTGl1fbnutQxjkkqZI9i_zV7KY2GvuQejFcbF3Qmge4
hZ3Arh7jmK42qV_O3WDqzebyWpf0guqYvq_k-Wz8ZeXN62YZuWI6-kbGdVPX0P-15M7skG00ecRs
FldT4gbj0BxuTHWCt_cqFg0A8o4curWx0YyJ2y86sWpzZVHE0YIDal56deD7Fq8eMhDFQSV9W2Gi
C9ISnQrIEjRXWe5ffKkZj6MeU96XY73PHeZYLgBI2mjQsRRBB5FssSR_ThjHAGiSSSfbm92IF8Hy
RmP-QbQE3WrU8V2BbGBnbDQIGgDgU5oriz58qlx_OnKCzqSTXEvi2NjW3ZtcY3uz6-5oAMgjk05a
WIfWegWR--Hf-zcJzjTH-fA8-3j070NWYSFBa642y0vQ2dFAINwRUGepn7lUq_3s7bMtB-sP1Mtl
1xZzdOwfOLLFknhyq1F3TNAAALWaCTt7_9liSa1p4FuaK4uKouTy0yQQiXP5aZuTruXWSXCmOS7e
K4avFWIy6aQjOUGZVx7ZYknTzpymUclA2DmXn6bCZc3LtbMxVTYNLGBKzRB0_Glvdi20BHdeeXZ2
PDOalfSPozWFqxezsEJ3gbjlI50ENheHs6MBcXe0GvVwz_u_nWm_pHcMeiV9AjEs9S8rXL2Yk7ub
jo5ZONKJRmlgB2dHA5qUajW6t7euFOhuL9VqoZzXDpl0knsFay9uMGZEKulbmiuLepIltzTjnuIW
YS23brZLHB8s3NCNrWZnbz9bLLUa9TDNa5P2Zpd7VAuD7OztdzrdVOqZl7kxI1JJ38Ia1mxshzPN
cQu9IOiwkUknqREM9ja7-_kOZ-sGZV55lGo1RVG2rhQURUlMLZvq_7Obv6iXy6hkpJBxUsZQ1pBB
9yfxi7iJ2L4BmlceO3v7RM2JqeWtKwViavG_nY7FlwpiJU8NniY-bEBniVs43tnA5oJwdjSg9ou4
TVKpZ98ioPNKJTG1rCgKdTS5DOsXBAEWNHWoIzJ1djRAyRZLpvIvrV5tNerBnddNTVNTS9V0uCuJ
TSf4sUwLGoSVTqebSiWjM68jpsYXDCLNlUVFUXL5aRKIx3YmPfavd0lw95_OifeK4WsBACJl51x_
mtiW-ecUzDXSS_prC5hSMwQdRRJTy5Ga1w4H_w940jd8lfShozU9yzYSj6tzNBvlYVrQmXQyk06y
gR2cHQ048kUCNK-UAtbLZcvjnB87ae3VQlNJ35LLT_tJlm3P5ad7StwF4mY7tDe7XGAHZ0cDtIyt
Rj1bLIl3nJuYtPMhvJpXXgEJB-sP7Oztmx3kYP8BRVFSqWeiNPVqQa-kWm6dBGea4-7cI8Sweo4W
8bvlqY-9612zXWKQWlghmrAglIDOK4N6uWyh1-mxk6ikb8nlp1nJ0pgE6n_bUqbc-adj5GeqVxwf
LKzUy_VsseSmULydVxKtRl3wdQhzE5NOuTJklQw9rUbd8TFj4qmZdJL_1JdmcXY0YHnFOCgUz_f1
fOM5-lLBreSpwdPkh21oh7h4anuza3BpFmdHAwY7vFSr7eztq28d7D9wfuykpL3t1bzOkkknyco0
eB31S9FeqCSwSQwlCCuZ9LNNWy_X5yYmubtzE5OsUEIwrzw7s69zsP_A2pLsSymK0t7sOvJqoamk
38gWS_qfPx81jq8VVli5pFLJVqPe6XzZQm3CZQZ3Xql2pk9eL5e51_Feir6a5ggRrKQ-aTXqnLJp
3FxZJEEuP03iXH6atpOYg95S9zWOez5nDJ8qOqRSSfYX_nmdkqPx6_i9lAxpBrGSQYRVp55eWTvn
8tOkC-uvHocNROysKErc7KNn0s_WBQlsrkJnRwMA_I213DoJzjTHg-LMxLmm8jWdy9rc7JgWBU0d
6ohMnR0NAADsk8tPi-uUpLEu5saxMKZ1QQMAQDTRtDBpNGteCDq6dDpdax1TqWQQ50Ul-V9JRVFO
DZ4mwY1H73n_MNliSe8WUa3ev16__tJgBHGbQ9AR4tLqVRLMTUxGYV5J70LfgsRsCyoZCFqNelAe
NWa2QyadzKSTbGAHZ0eLMqVaTSTN8Y3t1byRBZWMFHGzHdqbXS6wg7OjRdzOpVqtXi47MmCn002l
ep_XXs0rlZ7PcGn1KhUliR15I2ff3Q_V1GMtt06CM81xbF6HBQ18SL1cdtCSiqII7m2v5pVKz2eY
m5gUd7T4Gzn77r61c4jJFkviya1GHYKOlqNF0oxtEqB5PcTbdwlTJU8NnibBjUfvuTZpc2Uxl59m
LxVFIS00JoE6tjPvm7-8WxK8_9qfxXtB0BFibmIyUvO68y5uvl2YKukHiKyJgtnYQNOc303x7mt-
ppqWJehMOskG7c2unQI5OxogpFLPqhqReVFJIMPdmu2W7WwN04KmDnVEps6OBgAIImu5dRKcaY77
5JH0RNxcWXTT0aYFDQAAkjg1eJoENx69J2_W5soiVTArXD35knxjcYvw5i--Vrqgs8USG7QadTuV
cnY0QOh0utY6plLJIM6LSvq-kv6BNazZ2A7vvvZnC73MCZr6lG2xbFVnRwMyxOTyhvdqXlTSb6zl
1knwqzu-IsGNR_-5-JlluEtI0Jn0l99460qBvZWYWu50uj8c_a6iKO1NoWPf2dGAvL1NYtd2uFfz
opLAtwgJmnVlYmrZOMHl0QAAXvF--u1-Pov_K235laSWfzz69xB0D1qNerZYYlvmJiYtz_3saAAQ
cvlpFAF1dh-OZj3t57ygybidTpdtSaWSdhzt4GjAEVKpJP0obn4Or_ZFJaPjO0VRmiuL7NHSXFmk
hw2NScDG9k_jrV-ukSDxWr94L9OCdvyTw8j_NEuk5kUlbWKgNknKW8utk_BMc9zOY9PnYWPuOWmj
2u_mSLzWTzUtUdDOHs4hOOohBeg1ypXknMVpjm3nckiLZeWdaY5TTUs6ctTYPFfMEvPDAoKaAQg0
zZVFajRWbXqxh8oTJJef1nwwvbfwl6ABAEDTZewl164nd2_PE-pgbMw9Hs23c5xs-XLPbJc4lhcA
wKbv9MzF3lLHNpW3llu3dpxYju2QeK2fa8mkkyRob3ZJ3N7sknbS0t7sWhR0p9N18AM7OxoAwE08
Ud6Z5rjf6tBq1M12IUZmHc02KopiRdCp1LOBHMHZ0QAA4cCC7wIHkTJrZNpOGq0IGgAAgE2Igomj
Ne2sKEoMZQIAAPfJpJPUziRgZZ1JJ0_fb-Tdaz9ApQAAwFecPt-Y-r9X-j93ENXN134D1wAAABB0
RVh0TG9kZVBORwAyMDExMDIyMeNZtsEAAAAASUVORK5CYII=
:: label.qoi
b64$cW9pZgAAAeAAAAEOBAH_--Ho-f39-f39-f3T-qKIefk-wf7DAEz5P8H_ooh5zD-9-f39-BLE
P9cS2z8Sxj8S1D-_wwBM0D-AEss-wBLFPxLQP-6iiHnOP-39-c4SwT-AEsE-yhLBP8YSxD-FEsY-
xxI-Ej-Z-sMATD-N-qKIecU-xhLFP8cS2z8Sxj8S1D-_wwBMzz8SwD8SyT8S2j-_ooh5zj-9-f3A
EsE-wBLBP8QSwT-AEsE-xRLCPxLBP8YSP8ISP8USxj-IEj-IEsY-yP7DAEzAP9D_ooh5PxI-1hLB
PxI-EsE-wRI-Ej-AEsA-wBLAP8ESwD-CEsA-wBLAPxLAPxI-wRLBP8ASxT-C-sMATM8-Ej-AEsQ-
wRLAPxLBPxLAPxI-wBLQP-6iiHnOP-39-cASwD-CEsA-xBLBP8ASwT-FEsI-EsE-xhI-whI-xRLG
P8QSxz-EEsI-wRI-yP7DAEw-Ej-L-qKIecE-EsE-xhLFP8cSwj8SwT8Swj-AEsQ-Ej8SwD8SwD8S
wT8SwD8SPxI-EsA-EsA-Ej8SwD8Swz8SwT-_wwBMzz-AEj8Swz8Swj-CEj8SwD8SwD8S0D-_ooh5
xj8SxT-9-f3AEsA-whLAP8QSxj-FEsI-yhI-whI-xRLGP8QSwD-DEsA-xBLCP8ESP8j_wwBMPxI-
y-6iiHk-Ej-aEsE-wRLAPxLCPxLDP8ESPxLAPxLAPxLBP8ISP8ASwT8SwD8SPxLAPxLEP8ASP-7D
AEzPPxLAPxLEP8ASwT8Swj-AEsE-EtA--qKIecU-wRLEP-39-cASwD-CEsA-xBI-EsI-Ej-FEsU-
xxI-wBLBP9MSwD-DEsA-xBI-wRLCP8b_wwBMwT-N-qKIecU-xhLFP8cSwj8SwT8Swj8Swj8SwD8S
P8ESwT8SwT8Swj8SPxLAPxLAPxI-EsA-EsY-wP7DAEzPPxLAPxLGPxLAPxLBPxLAPxLAPxLQP-6i
iHnGPxLFP-39-cASwD-CEsA-xBI-EsI-Ej-FEsU-xRLBP8ASwT-FEsY-xBLAP8MSwD-EEj-BEsI-
xf7DAEzCP87_ooh5xD-WEsE-Ej8SwT-BEj8Swz-BEj8SxD-AEsA-wRI-EsA-Ej8SwD8SwD-AEsE-
EsA-wRI--sMATNA-wBLBPxLAP8ESwT8SwT8SwD8SP8ESzz-_ooh5zj-9-f3AEsE-wBLBP8QSxj-F
EsU-xRLBP8oSwD-CEsA-xBLHP8QSxj-G-sMATMA-7f6iiHnVPxLjP-7DAEz7P-6iiHnOP-39-f39
3BL7P-7DAEz7P-6iiHnOP-39-f32-tbX2tX_n6CmIP39-f39-f3TPCCMidQ8IDv9-f39-f390jwg
O9Q8IDv1PCA79TwgO-U8IDv1PCA79TwgO-U8IDv1PCA79TwgO9Q8IDv1PCA79TwgO-U8IDv1PCA7
9TwgO-U8IDv1PCA79TwgO9Q8IDvCPMM7yv5fV0-BOy7BOy7AO848wTvDPCA7wjzDO8ouwTsuwTsu
wTvNPME7wzwgO8I8wzvKLsE7LsE7LsE7zTzBO8M8IDvCPMM7yi7BOy7BOy7BO808wTvDPCA7wjzD
O8ouwTsuwTsuwTvNPME7wzwgO8I8wzvKLsE7LsE7LsE7zTzBO8M8IDvCPMM7yi7BOy7BOy47zzzB
O8M8IDvCPMM7yi7BOy7BOy7BO8kgOyA7IME7IDsgOzwgO8g-wTvHPCA7wjz_dU6XwTz_wsPHyi47
LjsuOy47wC471jwgO8I8-nVOl8E8-sLDx8ouOy47LjsuOy47LjvVPCA7wjz_dU6XwTz_wsPHyi47
LjsuOy47wS471TwgO8I8-nVOl8E8-sLDx8ouOy47LjsuO8EuO9U8IDvCPP51TpfBPP7Cw8fKLjsu
Oy47LjsuO9c8IDvCPP51TpfBPP7Cw8fKLjsuOy47LjsuO9c8IDvCPP51TpfBPP7Cw8fKLjsuOy47
LjsuO9c8IDvCPP51TpfBPP7Cw8fKLjsuOy47LjvBLjvJIDsgOyA7wyA7PCA7yD-_Hjc8P8A7xjwg
O8I8-nVOl8E8-sLDx8ouOy47LjsuO8AuO848wTvDPCA7wjz_dU6XwTz_wsPHyi47LjsuOy47Ljsu
O808wTvDPCA7wjz_dU6XwTz_wsPHyi47LjsuOy47LsE7zTzBO8M8IDvCPP51TpfBPP7Cw8fKLjsu
Oy47LjvALsA7zTzBO8M8IDvCPP51TpfBPP7Cw8fKLjsuOy47LjsuwTvNPME7wzwgO8I8-nVOl8E8
-sLDx8ouOy47LjsuOy7BO808wTvDPCA7wjz_dU6XwTz_wsPHyi47LjsuOy47LsE7zTzBO8M8IDvC
PP51TpfBPP7Cw8fKLjsuOy47LjvBLjvJIME7IME7wCA7wDwgO8g-BsA-wDvFPCA7wjz_dU6XwTz_
wsPHyi47LjsuOy47wC471jwgO8I8-nVOl8E8-sLDx8ouOy47LjsuOy47LjvVPCA7wjz_dU6XwTz_
wsPHyi47LjsuOy47LjvXPCA7wjz_dU6XwTz_wsPHyi47LjsuOy47wS471TwgO8I8-nVOl8E8-sLD
x8ouOy47LjsuO8EuO9U8IDvCPP51TpfBPP7Cw8fKLjsuOy47LjvBLjvVPCA7wjz_dU6XwTz_wsPH
yi47LjsuOy47LjsuO9U8IDvCPP51TpfBPP7Cw8fKLjsuOy47LjvBLjvLIDvBIDsgO8E8IDvIPwbB
P8A7xDwgO8I8wzvKLsE7LsE7LsE7zTzBO8M8IDvCPMM7yi7BOy7BOy7BO808wTvDPCA7wjzDO8ou
wTsuwTsuwTvNPME7wzwgO8I8wzvKLsE7LsE7LsE7zTzBO8M8IDvCPMM7yi7BOy7BOy7BO808wTvD
PCA7wjzDO8ouwTsuwTsuwTvNPME7wzwgO8I8wzvKLsE7LsE7LsE7zTzBO8M8IDvCPMM7yi7BOy7B
O8EuO8sgOyDBOyA7IDs8IDvIPwY-BsA-O8Q8IDv1PCA79TwgO-U8IDv1PCA79TwgO-U8IDv1PCA7
9TwgO8g-Bj-ABj87xDwgO-U8IDv1PCA79TwgO-U8IDv1PCA79TwgO-U8IDv1PCA7yD8GP8AGPzvE
PCA7-f39-f39-dI8IDvIPwY-Bj-AO8Q8-f39-f39-dUgO8U-wgY-wTvFPP6KJMrJ-ilikuv_AAAA
GPY1GPY1GPY1GPY1GPY1GPY1GPY1IDvEP8AGwj87xzwNyRjrNRj2NRj2NRj2NRj2NRj2NRj2NRj2
NSA7xD8Gwz87xzwNwv738KLBDcIYwP7xqm0YxP6T6JrBGCzBGML_jtzZwRgawRjQNRjCOMEYxBXB
GMIswRgswRjCGsEYGsEY0DUYwjjBGMQVwRjCLMEYLMEYwhrBGBrBGNA1GMI4wRjEFRjELMEYLMEY
whrBGBrBGNA1GMI4wRjEFRjELMEYLMEYwhrBGBrBGNA1GMI4wRjEFRjELMEYLMEYwhrBGBrBGNA1
GPY1GPY1IDvEPwbDPzvHPA3BOA3COMANGMAVGMQsGCwYLBgsGMQaGBoY0jUYwTgYxxUYxCwYLBgs
GCwYxBoYGhgaGNA1GME4GMcVGMQsGCwYLBgsGMQaGBoYGhjQNRjBOBjHFRjELBgsGCwYLBjEGhga
GBoY0DUYwTgYxxUYxCwYLBgsGCwYxBoYGhgaGNA1GME4GMcVGMQsGCwYLBgsGMQaGBoYGhjQNRj2
NRj2NSA7xD-ABsE-wDvHPA3BOA3COMANGMAVGBUYwiwYLBgsGCwYxBoYGsAYyP6Uc7QYxjUYwTgY
OMAYxBXBGMIsGCwYLBgsGMIawRgaGBoYxxwYxjUYwTgYxxXBGMIsGCwYLBgsGMMawBgaGBoYxxwY
xjUYwTgYxxUYFRjCLBgsGCwYLBjCGsEYGhgaGMccGMY1GME4GMcVGBUYwiwYLBgsGCwYwhrBGBoY
GhjHHBjGNRjBOBjHFRgVGMIsGCwYLBgsGMIawRgaGBoYxxwYxjUYw-6xrW8Yxv6nelT_KWKSxv5c
lWIYyP48lZIYyhwYxjUYwzIYxv6nelT_KWKSxiAYyBAYyhwYxjX_1tfaO8U-wzvIPA3BOA3FGMAV
wRjCLBgsGCwYLBjEGhgaGNI1GME4GMA4GMYVGMIsGCwYLBgsGMIaGMEaGBoY0DUYwTgYyRUYwiwY
LBgsGCwYxBoYGhgaGNA1GME4GMcVwRjCLBgsGCwYLBjCGhjBGhgaGNA1GME4GMcVwRjCLBgsGCwY
LBjCGhjBGhgaGNA1GME4GMcVwRjCLBgsGCwYLBjCGhjBGhgaGNA1GPY1GPY1IDvUPA3COMENwhjC
FRjCLMEYLMEYxBoYGhjSNRjCOMEYxBXBGMIswRgswRjCGsEYGsEY0DUYwjjBGMQVwRjCLMEYLMEY
whrBGBrBGNA1GMI4wRjGFRjCLMEYLMEYwhrBGBrBGNA1GMI4wRjGFRjCLMEYLMEYwhrBGBrBGNA1
GMI4wRjGFRjCLMEYLMEYwhrBGBrBGNA1GPY1GPY1IDvUPA3JGOs1GPY1GPY1GPY1GPY1GPY1GPY1
GPY1IDvUPDX9-f39-f391CA71Dw1-f39-f39-dQgO9Q8NcI4wTXEFTXELME1LME1who1GjUawTXU
OME1xRXBNes4wTXEFcE1zRrBNRrBNdU4wTXEFTXtOME1xBU17TjBNcQVNf393yA7wyDCO8s8NcE4
NccVNcQsNSw1wSw1who1GjUaNRo11Dg1wDg1OMA1wRU17Dg1xxU10Ro1GjUaNdQ4NccVNew4NccV
New4NccVNf393yA7wiDAPMAgwDvKPDXBODU4wDXEFTUVNcIsNSw1LME1whrBNRo1GjXHHDXKODXA
ODU4wDXBFcE1xf5clWI1yBA1yhw1yjg1xxXBNcUgNcYawDUaNRo1xxw1yjg1xxU1FTXFIDXIEDXK
HDXKODXHFTUVNcUgNcgQNcocNco4NccVNRU1xSA1yBA1yhw1zDI1xv6nelQ1xiA1yBA1yhw1zDI1
xhg1xiA1yBA1yhw1x-7W19o7wiA8IMA8IDvKPDXBODXAODXEFcE1wiw1LDUsNcYaNRo1GjXUODXA
ODXGFTXqODXJFTXPGjUaNRo11Dg1xxXBNeo4NccVwTXqODXHFcE1-f3dIDvBIMA8IMA8IMA7yTw1
wjjBNcYVNcIswTUswTXEGjUawTXUOME1xRXBNes4wTXEFcE1zRrBNRrBNdU4wTXGFTXrOME1xhU1
6zjBNcYVNf393SA7wSA8IMI8IDvJPDX9-f39-f391CA7wCDAPCDCPCDGO8I8Nf39-f39-f3UIDvA
IDw7IDsgOyA8IDsgOyA8IDvCPDX9-f39-f391CA7wCDGPCDCPCDAO8I8NcI4wTXEFTXELME1LMA1
wxrBNRrBNdU4wTXEFcE1wizBNSzBNcIawTUawTXVOME1xBXBNc0awTUawTXVOME1xBU17TjBNcQV
Ne04wTXEFTX9-d8gO8cgPCDCPCA7wzw1wTg1xxU1xCw1LDXALDXFGjUaNRo11Dg1wjjANcEVNcQs
NSw1LDUsNcQaNRo1GjXUODXHFTXRGjUaNRo11Dg1xxU17Dg1xxU17Dg1xxU1-f3fIDvHIMA8IMA8
IMA7wzw1wTg1xxU1FTXCLDUsNcAsNcQawDUaNRo1xxw1yjg1OMA1OMA1wRXBNcIsNSw1LDUsNcIa
wTUaNRo1xxw1yjg1xxXBNcX_XJViNcYawDUaNRo1xxw1yjg1xxU1FTXFIDXIEDXKHDXKODXHFTUV
NcUgNcgQNcocNco4NccVNRU1xSA1yBA1yhw1zDI1xhg1xiA1yBA1yhw1zDI1xhg1xiA1yBA1yhw1
x-7W19o7yCA8IMA8IDvEPDXBODXHFcE1wiw1LDXALDXFGjUaNRo11Dg1wDg1xhU1wiw1LDUsNSw1
who1wRo1GjXUODXHFTUVNc8aNRo1GjXUODXHFcE16jg1xxXBNeo4NccVwTX9-d0gO8ggwDzAIMA7
xDw1wjjBNcYVNcIswTUswTXCGsE1GsE11TjBNcQVwTXCLME1LME1whrBNRrBNdU4wTXEFcE1zRrB
NRrBNdU4wTXGFTXrOME1xhU16zjBNcYVNf393SA7ySDCO8U8Nf39-f39-f3UIDvUPDX9-f39-f39
1CA71Dw1-f39-f39-dQgO9Q8NcI4wTXEFTXELME1LME1whrBNRrBNdQ4wTXFFcE1wizBNSzBNcIa
wTUawTXVOME1xBXBNc0awTUawTXVOME1xBU17TjBNcQVNe04wTXEFTX9-d8gO9Q8NcE4NccVNcQs
NSw1wSw1xBo1GjUaNdQ4NTg1xRU1xCw1LDUsNSw1xBo1GjUaNdQ4NckVNc8aNRo1GjXUODXHFTXs
ODXHFTXsODXHFTX9-d8gO8A80DvAPDXBODXHFTUVNcIsNSw1LME1whrBNRo1GjXHHDXKOMI1xBXB
NcIsNSw1LDUsNcIawTUaNRo1xxw1yjg1xxXBNcX_XJViNcYawDUaNRo1xxw1yjg1xxU1FTXFIDXI
EDXKHDXKODXHFTUVNcUgNcgQNcocNco4NccVNRU1xSA1yBA1yhw1zDI1xhg1xiA1yBA1yhw1zDI1
xhg1xiA1yBA1yhw1x-7W19o7wCDQO8A8NcE4NccVwTXCLDUsNSw1xBo1wRo1GjXUODXAODXGFTXC
LDUsNSw1LDXCGjXBGjUaNdQ4NccVNdEaNRo1GjXUODXHFcE16jg1xxXBNeo4NccVwTX9-d0gO9Q8
NcI4wTXGFTXCLME1LME1whrBNRrBNdQ4wjXEFcE1wizBNSzBNcIawTUawTXVOME1xBXBNc0awTUa
wTXVOME1xhU16zjBNcYVNes4wTXGFTX9-d0gO9Q8Nf39-f39-f3UIDvUPP4UOln2NQL2NQL2NQL2
NQL2NQL2NQL2NQL2NSA71DwC9jUC9jUC9jUC9jUC9jUC9jUC9jUC9jUgO8UuwTvKPALCOMECxBUC
xCzBAizAAsMawALAGsEC0DUCwTjCAsQVwQLCLMECLMECwhrBAhrBAtA1AsE4wQLFFQLPGgIaAhrB
AtA1AsI4wQLEFQLoNQLBOMECxRUC6DUCwTjBAsUVAug1AvY1AvY1IDvELjvBLjsuOy47xTwCwTgC
xxUCxCwCLALALALEGgLAGgIaAtA1AsE4AscVAsQsAiwCLAIsAsQaAhoCGgLQNQLBOALAOALEFQLP
GgIaAhoCGgLQNQLBOALHFQLoNQLBOALAOALEFQLoNQLBOALAOALEFQLoNQL2NQL2NSA7xC47wy47
LjvFPALBOALHFQIVAsIsAiwCwCwCxBoCwBoCGgLHHALGNQLBOMECxRXBAsIsAiwCLAIsAsIawQIa
AhoCxxwCxjUCwTgCwDgCxBUCFQLF-lyVYgLFGsECGgIaAsccAsY1AsE4AjjAAsQVAhUCxSACyBAC
yhwCxjUCwTgCwDgCxBUCFQLFIALIEALKHALGNQLBOALAOALEFQIVAsUgAsgQAsocAsY1AsMyAsYY
AsYgAsgQAsocAsY1AsMyAsYYAsYgAsgQAsocAsY1-tbX2jvELjvDLsE7xTwCwTgCxxXBAsIsAiwC
wCwCxBoCwBoCGgLQNQLBOALJFQLCLAIsAiwCLALCGgLBGgIaAtA1AsE4AsA4AsQVwQLPGgIaAhoC
0DUCwTgCwDgCxBXBAuY1AsE4AsA4AsQVwQLmNQLBOALAOALEFcEC5jUC9jUC9jUgO8QuO8EuO8Eu
O8U8AsI4wQLGFQLCLMECLMECwhrBAhrBAtA1AsE4wgLEFcECwizBAizBAsIawQIawQLQNQLBOMEC
xxUCzxoCGsEC0DUCwjjBAsYVAuY1AsE4wQLHFQLmNQLBOMECxxUC5jUC9jUC9jUgO8UuwTvCLjvF
PAL2NQL2NQL2NQL2NQL2NQL2NQL2NQL2NSA71Dw1-f39-f39-dQgO9Q8Nf39-f39-f3UIDvUPDXC
OME1xBU1xCzBNSzBNd84wTXFFcE16jjBNcUVNc8aNRo1GsE1-f39-fYgO9Q8NcE4NccVNcQsNSw1
wSw13zg1wDg1OMA1wRU17Dg1wDg1OMA1wRU1zxo1GjUaNRo1-f39-fYgO9Q8NcE4NccVNRU1wiw1
LDUswTXFEDXKHDXKODXAODU4wDXBFcE1xf5clWI1yBA1yhw1yjg1wDg1OMA1wRU1FTXFIDXFGsE1
GjUaNcccNcwyNcYYNcYgNcgQNcocNcwyNcYYNcYgNcgQNcocNcwyNcYYNcYgNcgQNcocNcwyNcYY
NcYgNcgQNcocNcwyNcYYNcYgNcgQNcocNcf_1tfaO8E8wTs8wDvBPMA7PME7wjw1wTg1xxXBNcIs
NSw1LDXhODXAODXGFTXqODXAODXEFcE1zxo1GjUaNf39-f32IDvCPDvAPDs8Ozw7wjw7wzw1wjjB
NcYVNcIswTUswTXfOME1xRXBNeo4wTXHFTXPGjUawTX9-f399iA7wjw7wDw7PDs8wTvAPDvDPDX9
-f39-f391CA7wjw7wDw7PDvBPDvAPDvDPDX9-f39-f391CA7wTzBOzw7PDs8wDvBPDvDPDX9-f39
-f391CA71Dw1wjjBNcQVNcQswTUswDX93DjBNcQVwTXNGjUaNRrBNf39-f32IDvUPDXBODXHFTXE
LDUsNcAsNf3bODXHFTXPGjUaNRo1GjX9-f399iA71Dw1wTg1xxU1FTXCLDUsNcAsNcYQNcocNcwy
NcYYNcb_XJViNcgQNcocNco4NccVwTXFIDXFGsE1GjUaNcccNcwyNcYYNcYgNcgQNcocNcwyNcYY
NcYgNcgQNcocNcwyNcYYNcYgNcgQNcocNcwyNcYYNcYgNcgQNcocNcwyNcYYNcYgNcgQNcocNcf_
1tfaO8X_XJViwTsgwTvGPDXBODXHFcE1wiw1LDXALDX92zg1yRU1zxo1GjUaNf39-f32-tbX2jvF
-lyVYjsgOyA7IDvGPDXCOME1xhU1wizBNSzBNf3bOME1xBXBNc8aNRrBNf39-f32-tbX2jvF-lyV
YjsgOyA7IDvGPDX9-f39-f391P7W19o7xf5clWI7IDsgOyA7xjw1-f39-f39-dT_1tfaO8X_XJVi
wTsgwTvGPDX9-f39-f391P7W19o71Dw1wjjBNcQVNcQswTUswTXgOME1xBXBNcIswTUswTXCGsE1
GsE11DjCNcQVNc8aNRo1GsE11DjBNcUVNcQswTUswTX9-f39yCA71Dw1wTg1xxU1xCw1LDXBLDXf
ODXCOMA1wxU1wiw1LDUsNSw1xBo1GjUaNdQ4NcI4wDXBFTXPGjUaNRo1GjXUODXAODXEFTXELDUs
NSw1LDX9-f39yCA71Dw1wTg1xxU1FTXCLDUsNSzBNcUQNcocNco4NTjANTjANcEVwTXCLDUsNSw1
LDXCGsE1GjUaNcccNco4wTXAOMA1wRU1FTXF-lyVYjXFGsE1GjUaNcccNco4NcA4NcQVNRU1wiw1
LDUsNSw1xRA1yhw1zDI1xhg1xiA1yBA1yhw1zDI1xhg1xiA1yBA1yhw1zDI1xhg1xiA1yBA1yhw1
zDI1xhg1xiA1yBA1yhw1x-7W19o71Dw1wTg1xxXBNcIsNSw1LDXhODXAODXGFTXCLDUsNSw1LDXC
GjXBGjUaNdQ4NccVwTXPGjUaNRo11Dg1wDg1xBXBNcIsNSw1LDUsNf39-f3IIDvUPDXCOME1xhU1
wizBNSzBNeA4wTXEFcE1wizBNSzBNcIawTUawTXUODXJFTXPGjUawTXUOME1xxU1wizBNSzBNf39
-f3IIDvDPDs8O8A8wDs8O8Y8Nf39-f39-f3UIDvDPDs8Ozw7PDs8O8Y8AvY1AvY1AvY1AvY1AvY1
AvY1AvY1AvY1IDvDPDs8Ozw7PDs8O8Y8AvY1AvY1AvY1AvY1AvY1AvY1AvY1AvY1IDvDPME7PDs8
Ozw7xjwCwjjBAsQVAsQswQIswALcNQLBOMICxBXBAsIswQIswQLCGsECGsEC0DUCwTjBAsUVAug1
AsE4wgLEFQLELMECLMEC2zUC9jUC9jUC9jUC9jUgO8Q8O8A8wDvAPME7xDwCwTgCxxUCxCwCLALA
LALcNQLBOALJFQLCLAIsAiwCLALEGgIaAhoC0DUCwTgCwDgCxBUC6DUCwTgCwjjAAsEVAsQsAiwC
LAIsAts1AvY1AvY1AvY1AvY1IDvUPALBOALHFQIVAsIsAiwCwCwCxhACyhwCxjUCwTjBAsUVwQLC
LAIsAiwCLALCGsECGgIaAsccAsY1AsE4AsA4AsQVAhUCxf5clWICyBACyhwCxjUCwTjBAsA4wALB
FQIVAsIsAiwCLAIsAsUQAsocAsY1AsMyAsYYAsYgAsgQAsocAsY1AsMyAsYYAsYgAsgQAsocAsY1
AsMyAsYYAsYgAsgQAsocAsY1AsMyAsYYAsYgAsgQAsocAsY1-tbX2jvUPALBOALHFcECwiwCLALA
LALcNQLBOALJFQLCLAIsAiwCLALCGgLBGgIaAtA1AsE4AsA4AsQVwQLmNQLBOALHFcECwiwCLAIs
AiwC2zUC9jUC9jUC9jUC9jUgO9Q8AsI4wQLGFQLCLMECLMEC2zUCwTjCAsQVwQLCLMECLMECwhrB
AhrBAtA1AsE4wQLHFQLmNQLBOALJFQLCLMECLMEC2zUC9jUC9jUC9jUC9jUgO8UQwTsQwTvGPAL2
NQL2NQL2NQL2NQL2NQL2NQL2NQL2NSA7xxA7EDvIPDX9-f39-f391CA7xxA7EMA7xzw1-f39-f39
-dQgO8cQOxA7yDw1wjjBNcQVNcQswTUswTX92jjBNcUVNf39-f390CA7xxA7EDvIPDXBODXHFTXE
LDUsNcEsNf3aODXAODU4wDXBFTX9-f39-dAgO9Q8NcE4NccVNRU1wiw1LDUswTXFEDXKHDXMMjXG
GDXG-lyVYjXIEDXKHDXKODXAODU4wDXBFTUVNcUgNcgQNcocNcwyNcYYNcYgNcgQNcocNcwyNcYY
NcYgNcgQNcocNcwyNcYYNcYgNcgQNcocNcwyNcYYNcYgNcgQNcocNcwyNcYYNcYgNcgQNcocNcf_
1tfaO9Q8NcE4NccVwTXCLDUsNSw1-dw4NcA4NcQVwTX9-f39-c4gO9Q8NcI4wTXGFTXCLME1LME1
-do4wTXHFTX9-f39-c4gO9Q8Nf39-f39-f3UIDvUPDX9-f39-f391CA7wjzAOzzBOzzBOzzBO8I8
Nf39-f39-f3UIDvBPDvCPDvAPDvBPDs8O8I8NcI4wTXEFTXELME1LMA14TjBNcQVwTXCLME1LME1
whrBNRrBNcL_yqnqwTUGwTUGwTXGOME1xBU17TjBNcQVNcQswTUswTXCGsE1GsE1-f39_yA7wTzB
O8A8O8A8wDvAPME7wjw1wTg1xxU1xCw1LDXALDXgODXJFTXCLDUsNSw1LDXEGjUaNRo1wgbBNcEG
NcEGNcU4NccVNew4NccVNcQsNSw1LDUsNcQaNRo1-f39-SA7wzw7wDw7wDw7wTw7xDw1wTg1xxU1
FTXCLDUsNcAsNcYQNcocNco4NccVwTXCLDUsNSw1LDXCGsE1GjUaNcIGNQY1wAbANcEGNcU4NTjA
NcQVNRU1xf5clWI1yBA1yhw1yjg1xxU1FTXCLDUsNSw1LDXEGjUawDXIHDXMMjXGGDXGIDXIEDXK
HDXMMjXGGDXGIDXIEDXKHDXMMjXGGDXGIDXIEDXKHDXMMjXGGDXGIDXIEDXKHDXH-tbX2jvBPMA7
wTw7wDzBOzw7xDw1wTg1xxXBNcIsNSw1wCw14Dg1yRU1wiw1LDUsNSw1who1wRo1GjXCBjUGNcEG
NcEGNcU4NcA4NcQVwTXqODXHFcE1wiw1LDUsNSw1xBo1GjX9-f39IDvUPDXCOME1xhU1wizBNSzB
NeA4wTXEFcE1wizBNSzBNcIawTUawTXCBjUGNQbBNcEGNcY4wTXGFTXrOME1xhU1wizBNSzBNcQa
NRo1-f39-SA71Dw1-f39-f39-dQgO9Q8Nf39-f39-f3UIDvHLsA7yTw1-f39-f39-dQgO8guO8k8
NcI4wTXEFTXELME1LME14DjBNcQVwTXCLME1LME1whrBNRrBNcIGwTUGwTUGwTXGOME1xBU17DjB
NcUVNcQswTUswTXCGsE1GsE1-f39_yA7yC47yTw1wTg1xxU1xCw1LDXBLDXfODXJFTXCLDUsNSw1
LDXEGjUaNRo1wgbBNcEGNcEGNcU4NcI4wDXBFTXsODXAODXEFTXELDUsNSw1LDXEGjUaNf39-f0g
O8guO8k8NcE4NccVNRU1wiw1LDUswTXFEDXKHDXKODXHFcE1wiw1LDUsNSw1whrBNRo1GjXCBjUG
NcAGwDXBBjXFODXCOMA1wRU1FTXF-lyVYjXIEDXKHDXKODXAODXEFTUVNcIsNSw1LDUsNcQaNRrA
NcgcNcwyNcYYNcYgNcgQNcocNcwyNcYYNcYgNcgQNcocNcwyNcYYNcYgNcgQNcocNcwyNcYYNcYg
NcgQNcocNcf_1tfaO8cuwTvIPDXBODXHFcE1wiw1LDUsNeE4NckVNcIsNSw1LDUsNcIaNcEaNRo1
wgY1BjXBBjXBBjXFODXHFcE16jg1wDg1xBXBNcIsNSw1LDUsNcQaNRo1-f39-SA71Dw1wjjBNcYV
NcIswTUswTXgOME1xBXBNcIswTUswTXCGsE1GsE1wgY1BjUGwTXBBjXGOME1xhU16jjBNccVNcIs
wTUswTXEGjUaNf39-f0gO9Q8Nf39-f39-f3UIDvUPAL2NQL2NQL2NQL2NQL2NQL2NQL2NQL2NSA7
1DwC9jUC9jUC9jUC9jUC9jUC9jUC9jUC9jUgO8A80DvAPALCOMECxBUCxCzBAizAAtw1AsE4wgLE
FcECwizBAizBAsIawQIawQLQNQLCOMECxBUC6DUCwTjBAsUVAsQswQIswQLCGsECGsEC0DUC9jUC
9jUC9jUC9jUgO8Ag0DvAPALBOALHFQLELAIsAsAsAtw1AsE4AskVAsIsAiwCLAIsAsQaAhoCGgLQ
NQLBOALHFQLoNQLBOALAOAI4wALBFQLELAIsAiwCLALEGgIaAtI1AvY1AvY1AvY1AvY1IDvUPALB
OALHFQIVAsIsAiwCwCwCxhACyhwCxjUCwTjBAsUVwQLCLAIsAiwCLALCGsECGgIaAsccAsY1AsE4
AjjAAsQVAhUCxf5clWICyBACyhwCxjUCwTgCwDgCOMACwRUCFQLCLAIsAiwCLALEGgIawALIHALG
NQLDMgLGGALGIALIEALKHALGNQLDMgLGGALGIALIEALKHALGNQLDMgLGGALGIALIEALKHALGNQLD
MgLGGALGIALIEALKHALGNf7W19o71DwCwTgCxxXBAsIsAiwCwCwC3DUCwTgCyRUCwiwCLAIsAiwC
whoCwRoCGgLQNQLBOALAOALEFcEC5jUCwTgCwDgCxBXBAsIsAiwCLAIsAsQaAhoC0jUC9jUC9jUC
9jUC9jUgO9Q8AsI4wQLGFQLCLMECLMEC2zUCwTjCAsQVwQLCLMECLMECwhrBAhrBAtA1AsI4wQLG
FQLmNQLBOMECxxUCwizBAizBAsQaAhoC0jUC9jUC9jUC9jUC9jUgO9Q8AvY1AvY1AvY1AvY1AvY1
AvY1AvY1AvY1IDvBPME7PME7PME7PME7wjw1-f39-f39-dQgO8E8Ozw7PDs8O8A8O8E8O8M8Nf39
-f39-f3UIDvBPME7PME7wDw7wTw7wzw1wjjBNcQVNcQswTUswTX92zjBNcQVNew4wjXEFTXELME1
LME1-f39-cggO8E8O8E8Ozw7wDw7wTw7wzw1wTg1xxU1xCw1LDXBLDX92jg1xxU17Dg1wjjANcEV
NcQsNSw1LDUsNf39-f3IIDvBPDvBPDs8O8A8O8E8O8M8NcE4NccVNRU1wiw1LDUswTXFEDXKHDXM
MjXGGDXG-lyVYjXIEDXKHDXKODU4wDXEFTUVNcUgNcgQNcocNco4wTXAOMA1wRU1FTXCLDUsNSw1
LDXFEDXKHDXMMjXGGDXGIDXIEDXKHDXMMjXGGDXGIDXIEDXKHDXMMjXGGDXGIDXIEDXKHDXMMjXG
GDXGIDXIEDXKHDXH-tbX2jvUPDXBODXHFcE1wiw1LDUsNf3cODXAODXEFcE16jg1xxXBNcIsNSw1
LDUsNf39-f3IIDvUPDXCOME1xhU1wizBNSzBNf3bOME1xhU16jg1yRU1wizBNSzBNf39-f3IIDvU
PDX9-f39-f391CA7xS7BOy7BO8Y8Nf39-f39-f3UIDvFLjsuOy47LjvGPDX9-f39-f391CA7xS47
LjsuOy47xjw1wjjBNcQVNf3oOME1xBU17DjBNcUVNc8awTUawTX9-f37IDvFLjsuOy47LjvGPDXB
ODXHFTX95zg1xxU17Dg1ODXFFTXRGjUaNf39-f0gO8UuwTsuwTvGPDXBODXHFTUVNcX_XJViNcgQ
NcocNcwyNcYYNcYgNcgQNcocNco4NTjANcQVNRU1xSA1yBA1yhw1yjjCNcQVNRU1xSA1xxo1GsA1
yBw1zDI1xhg1xiA1yBA1yhw1zDI1xhg1xiA1yBA1yhw1zDI1xhg1xiA1yBA1yhw1zDI1xhg1xiA1
yBA1yhw1x-7W19o71Dw1wTg1xxXBNf3lODXAODXEFcE16jg1wDg1xBXBNc8aNRo1-f39-SA71Dw1
wjjBNcYVNf3mOME1xhU16jjCNcYVNc8aNRo1-f39-SA71Dw1-f39-f39-dQgO9Q8Nf39-f39-f3U
IDvUPDX9-f39-f391CA71Dw1wjjBNcQVNf3oOME1xBU17TjBNcQVwTXNGsE1GsE1-f39_yA7yDw7
yTw1wTg1xxU1-ec4NccVNew4NccVNdEaNRo1-f39-SA7xzzBO8g8NcE4NccVNRU1xf5clWI1yBA1
yhw1zDI1xhg1xiA1yBA1yhw1yjg1OMA1xBU1FTXFIDXIEDXKHDXKODXHFcE1xSA1xxo1GsA1yBw1
zDI1xhg1xiA1yBA1yhw1zDI1xhg1xiA1yBA1yhw1zDI1xhg1xiA1yBA1yhw1zDI1xhg1xiA1yBA1
yhw1x-7W19o7xjzDO8c8NcE4NccVwTX95Tg1wDg1xBXBNeo4NckVNc8aNRo1-f39-SA7xTzFO8Y8
NcI4wTXGFTX95jjBNcYVNes4wTXEFcE1zxo1GjX9-f39IDvUPDX9-f39-f391CA71Dz_KWKS9jUY
9jUY9jUY9jUY9jUY9jUY9jUY9jUgO9Q8GPY1GPY1GPY1GPY1GPY1GPY1GPY1GPY1IDvUPBj2NRj2
NRjCOMEYxBUY6DUYwjjBGMQVGM8awRgawRjQNRjCOMEYxBUYzxrBGBrBGNA1GMI4wRjEFRjPGsEY
GsEY0DUY9jUY9jUgO9Q8GPY1GPY1GME4GMcVGOg1GME4GMcVGNEaGBoY0jUYwTgYxxUY0RoYGhjS
NRjBOBjHFRjRGhgaGNI1GPY1GPY1IDvFPMU7xjwYwzIYxv6nelT_KWKSxv5clWIYyBAYyhwYxjUY
wzIYxv6nelT_KWKSxiAYyBAYyhwYxjUYwTgYOMAYxBUYFRjFIBjIEBjKHBjGNRjBOBg4wBjEFRgV
GMUgGMcaGBrAGMgcGMY1GME4GDjAGMQVGBUYxSAYxxoYGsAYyBwYxjUYwTgYOMAYxBUYFRjFIBjH
GhgawBjIHBjGNRjDMhjG-qd6VP4pYpLGIBjIEBjKHBjGNRjDMhjG-qd6VP4pYpLGIBjIEBjKHBjG
Nf7W19o7xjzDO8c8GPY1GPY1GME4GMA4GMQVwRjmNRjBOBjAOBjEFcEYzxoYGhjSNRjBOBjAOBjE
FcEYzxoYGhjSNRjBOBjAOBjEFcEYzxoYGhjSNRj2NRj2NSA7xzzBO8g8GPY1GPY1GMI4wRjGFRjm
NRjCOMEYxhUYzxoYGhjSNRjCOMEYxhUYzxoYGhjSNRjCOMEYxhUYzxoYGhjSNRj2NRj2NSA7yDw7
yTwY9jUY9jUY9jUY9jUY9jUY9jUY9jUY9jUgO9Q8Nf39-f39-f3UIDvUPDX9-f39-f391CA71Dw1
-fU4wjXEFTX9-f39-dAgO9Q8Nf31ODXCOMA1wRU1-f39-f3QIDvUPDXDMjXG-qd6VDXG-lyVYjXI
EDXKHDXMMjXGGDXGIDXIEDXKHDXKOME1wDjANcEVNRU1xSA1yBA1yhw1zDI1xhg1xiA1yBA1yhw1
zDI1xhg1xiA1yBA1yhw1zDI1xhg1xiA1yBA1yhw1zDI1xhg1xiA1yBA1yhw1zDI1xhg1xiA1yBA1
yhw1x-7W19o7wTw7wjzAO8A8wDs8wTvCPDX99Tg1xxXBNf39-f39ziA7wTw7wTw7PDs8Ozw7PDs8
O8I8Nf31ODXJFTX9-f39-c4gO8E8O8E8Ozw7PDs8OzzBO8I8Nf39-f39-f3UIDvBPDvBPDs8Ozw7
PDs8O8Q8Nf39-f39-f3UIDvBPME7PMA7wDzAO8A8O8Q8Nf39-f39-f3UIDvUPDX99jjBNcQVNf39
-f390CA71Dw1-fU4NcI4wDXBFTX9-f39-dAgO9Q8NcMyNcYYNcb_XJViNcgQNcocNcwyNcYYNcYg
NcgQNcocNco4NTjANTjANcEVNRU1xSA1yBA1yhw1zDI1xhg1xiA1yBA1yhw1zDI1xhg1xiA1yBA1
yhw1zDI1xhg1xiA1yBA1yhw1zDI1xhg1xiA1yBA1yhw1zDI1xhg1xiA1yBA1yhw1x-7W19o71Dw1
-fU4NcA4NcQVwTX9-f39-c4gO9Q8Nf32OME1xhU1-f39-f3OIDvCIMM7xCDBO8I8Nf39-f39-f3U
IDvCIDzBIDvDIMA8IMA7wTw1-f39-f39-dQgO8IgPCDBO8IgwDzBIMA7wDw1-f39-f39-dQgO8Ag
wTwgwTvCIDzDIDvAPDX99jjBNcQVNf39-f390CA7wCA8wyA7wiDBPCDBO8A8Nf31ODXHFTX9-f39
-dAgO8AgwDzBIMA7wiDBPCA7wjw1wzI1xhg1xv5clWI1yBA1yhw1zDI1xhg1xiA1yBA1yhw1yjg1
OMA1xBU1FTXFIDXIEDXKHDXMMjXGGDXGIDXIEDXKHDXMMjXGGDXGIDXIEDXKHDXMMjXGGDXGIDXI
EDXKHDXMMjXGGDXGIDXIEDXKHDXMMjXGGDXGIDXIEDXKHDXH-tbX2jvBIMA8IMA7wyA8wSA7wjw1
-fU4NcA4NcQVwTX9-f39-c4gO8IgwTvEIMM7wjw1-fY4wTXGFTX9-f39-c4gO9Q8Nf39-f39-f3U
IDvUPAL2NQL2NQL2NQL2NQL2NQL2NQL2NQL2NSA71DwC9jUC9jUC9jUC9jUC9jUC9jUC9jUC9jUg
O8UgxTvGPAL2NQL2NQL2NQLCOMECxBUCzxrBAhrBAtA1AsI4wQLEFQLPGsECGsEC0DUCwjjBAsQV
As8awQIawQLQNQL2NQL2NSA7xSD_ygB-wyA7xjwC9jUC9jUC9jUCwTgCxxUC0RoCGgLSNQLBOALH
FQLRGgIaAtI1AsE4AscVAtEaAhoC0jUC9jUC9jUgO8UgDMMgO8Y8AsMyAsYYAsb_XJViAsgQAsoc
AsY1AsMyAsYYAsYgAsgQAsocAsY1AsMyAsYYAsYgAsgQAsocAsY1AsE4AjjAAsQVAhUCxSACxxoC
GsACyBwCxjUCwTgCOMACxBUCFQLFIALHGgIawALIHALGNQLBOAI4wALEFQIVAsUgAscaAhrAAsgc
AsY1AsMyAsYYAsYgAsgQAsocAsY1AsMyAsYYAsYgAsgQAsocAsY1-tbX2jvFIAzDIDvGPAL2NQL2
NQL2NQLBOALAOALEFcECzxoCGgLSNQLBOALAOALEFcECzxoCGgLSNQLBOALAOALEFcECzxoCGgLS
NQL2NQL2NSA7xSAMwyA7xjwC9jUC9jUC9jUCwjjBAsYVAs8aAhoC0jUCwjjBAsYVAs8aAhoC0jUC
wjjBAsYVAs8aAhoC0jUC9jUC9jUgO8UgDMMgO8Y8AvY1AvY1AvY1AvY1AvY1AvY1AvY1AvY1IDvF
IMU7xjw1-f39-f39-dQgO9Q8Nf39-f39-f3UIDvUPDX99jjBNcQVNf39-f390CA71Dw1-fU4NccV
Nf39-f390CA71Dw1wzI1xhg1xv5clWI1yBA1yhw1zDI1xhg1xiA1yBA1yhw1yjg1OMA1xBU1FTXF
IDXIEDXKHDXMMjXGGDXGIDXIEDXKHDXMMjXGGDXGIDXIEDXKHDXMMjXGGDXGIDXIEDXKHDXMMjXG
GDXGIDXIEDXKHDXMMjXGGDXGIDXIEDXKHDXH-tbX2jvAPNA7wDw1-fU4NcA4NcQVwTX9-f39-c4g
O8Ag0DvAPDX99jjBNcYVNf39-f39ziA71Dw1-f39-f39-dQgO9Q8Nf39-f39-f3UIDvUPDX9-f39
-f391CA71Dw1-f39-f39-dQgO8M8wTvAPMA7PDs8O8Q8Nf39-f39-f3UIDvDPDs8Ozw7PDs8Ozw7
xDw1wzI1xhg1xv5clWI1yBA1yhw1zDI1xhg1xiA1yBA1yhw1zDI1xhg1xiA1yBA1yhw1zDI1xhg1
xiA1yBA1yhw1zDI1xhg1xiA1yBA1yhw1zDI1xhg1xiA1yBA1yhw1zDI1xhg1xiA1yBA1yhw1zDI1
xhg1xiA1yBA1yhw1x-7W19o7wzzAO8A8Ozw7PDs8O8Q8Nf39-f39-f3UIDvDPDs8Ozw7PDs8wTvE
PDX9-f39-f391CA7wzw7PDs8wDvAPME7xDw1-f39-f39-dQgO9Q8Nf39-f39-f3UIDvUPDX9-f39
-f391CA71Dw1-f3xOME1xBU1zxrBNRrBNdU4wTXEFTXPGsE1GsE11TjBNcQVNc8awTUawTX9-ccg
O9Q8Nf398Dg1xxU10Ro1GjXWODXHFTXRGjUaNdY4NccVNdEaNRo1-f3JIDvFLsE7LsE7xjw1wzI1
xhg1xv5clWI1yBA1yhw1zDI1xhg1xiA1yBA1yhw1zDI1xhg1xiA1yBA1yhw1yjg1OMA1xBU1FTXF
IDXHGjUawDXIHDXKODU4wDXEFTUVNcUgNccaNRrANcgcNco4NTjANcQVNRU1xSA1xxo1GsA1yBw1
zDI1xhg1xiA1yBA1yhw1zDI1xhg1xiA1yBA1yhw1x-7W19o7xS47LjsuOy47xjw1-f3wODXAODXE
FcE1zxo1GjXWODXAODXEFcE1zxo1GjXWODXAODXEFcE1zxo1GjX9-ckgO8UuOy47LjsuO8Y8Nf39
8TjBNcYVNc8aNRo11zjBNcYVNc8aNRo11zjBNcYVNc8aNRo1-f3JIDvFLjsuOy47LjvGPDX9-f39
-f391CA7xS7BOy7BO8Y8AvY1AvY1AvY1AvY1AvY1AvY1AvY1AvY1IDvUPAL2NQL2NQL2NQL2NQL2
NQL2NQL2NQL2NSA71DwC9jUC9jUC9jUC9jUC9jUC9jUC9jUC9jUgO9Q8AvY1AvY1AvY1AvY1AvY1
AvY1AvY1AvY1IDvUPALDMgLGGALG-lyVYgLIEALKHALGNQLDMgLGGALGIALIEALKHALGNQLDMgLG
GALGIALIEALKHALGNQLDMgLGGALGIALIEALKHALGNQLDMgLGGALGIALIEALKHALGNQLDMgLGGALG
IALIEALKHALGNQLDMgLGGALGIALIEALKHALGNQLDMgLGGALGIALIEALKHALGNf7W19o71DwC9jUC
9jUC9jUC9jUC9jUC9jUC9jUC9jUgO9Q8AvY1AvY1AvY1AvY1AvY1AvY1AvY1AvY1IDvHIMI7xzwC
9jUC9jUC9jUC9jUC9jUC9jUC9jUC9jUgO8cgPMAgO8c8Nf39-f39-f3UIDvGIMM7xzw1-f39-f39
-dQgO8YgPMEgO8c8Nf39-f39-f3UIDvGIMA8wCA7xzw1-f39-f39-dQgO8YgwDzAIMA7xjw1wzI1
xhg1xv5clWI1yBA1yhw1zDI1xhg1xiA1yBA1yhw1zDI1xhg1xiA1yBA1yhw1zDI1xhg1xiA1yBA1
yhw1zDI1xhg1xiA1yBA1yhw1zDI1xhg1xiA1yBA1yhw1zDI1xhg1xiA1yBA1yhw1zDI1xhg1xiA1
yBA1yhw1x-7W19o7xiA8wiA7xjw1-f39-f39-dQgO8YgxDvGPDX9-f39-f391CA71Dw1-f39-f39
-dQgO9Q8Nf39-f39-f3UIDvUPDX9-f39-f391CA71Dw1-f39-f39-dQgO8H_dU6Xzf7Cw8fCPDX9
-f39-f391CA7wP51TpfP-sLDx8E8NcMyNcYYNcb_XJViNcgQNcocNcwyNcYYNcYgNcgQNcocNcwy
NcYYNcYgNcgQNcocNcwyNcYYNcYgNcgQNcocNcwyNcYYNcYgNcgQNcocNcwyNcYYNcYgNcgQNcoc
NcwyNcYYNcYgNcgQNcocNcwyNcYYNcYgNcgQNcocNcf_1tfaO8D_dU6Xz-7Cw8fBPDX9-f39-f39
1CA7wP51TpfP-sLDx8E8Nf39-f39-f3UIDvA-nVOl8-_wsPHwTw1-f39-f39-dQgO8D_dU6XxT-B
O8X_wsPHwTw1-f39-f39-dQgO8D_dU6XxD-DO8T_wsPHwTw1-f39-f39-dQgO8D_dU6XxD-DO8T_
wsPHwTw1-f39-f39-dQgO8D_dU6XxD-DO8T_wsPHwTw1-f39-f39-dQgO8D_dU6XxT-BO8X_wsPH
wTw1wzI1xhg1xv5clWI1yBA1yhw1zDI1xhg1xiA1yBA1yhw1zDI1xhg1xiA1yBA1yhw1zDI1xhg1
xiA1yBA1yhw1zDI1xhg1xiA1yBA1yhw1zDI1xhg1xiA1yBA1yhw1zDI1xhg1xiA1yBA1yhw1zDI1
xhg1xiA1yBA1yhw1x-7W19o7wP51TpfP-sLDx8E8Nf39-f39-f3UIDvA-nVOl8-_wsPHwTw1-f39
-f39-dQgO8D_dU6Xz-7Cw8fBPDX9-f39-f391CA7wP51TpfP-sLDx8E8AvY1AvY1AvY1AvY1AvY1
AvY1AvY1AvY1IDvB-nVOl83_wsPHwjwC9jUC9jUC9jUC9jUC9jUC9jUC9jUC9jUgO9Q8AvY1AvY1
AvY1AvY1AvY1AvY1AvY1AvY1IDvUPAL2NQL2NQL2NQL2NQL2NQL2NQL2NQL2NSA71DwCwzICxhgC
xv5clWICyBACyhwCxjUCwzICxhgCxiACyBACyhwCxjUCwzICxhgCxiACyBACyhwCxjUCwzICxhgC
xiACyBACyhwCxjUCwzICxhgCxiACyBACyhwCxjUCwzICxhgCxiACyBACyhwCxjUCwzICxhgCxiAC
yBACyhwCxjUCwzICxhgCxiACyBACyhwCxjX_1tfaO8H_dU6Xzf7Cw8fCPAL2NQL2NQL2NQL2NQL2
NQL2NQL2NQL2NSA7wP51TpfP-sLDx8E8AvY1AvY1AvY1AvY1AvY1AvY1AvY1AvY1IDvA-nVOl8-_
wsPHwTwC9jUC9jUC9jUC9jUC9jUC9jUC9jUC9jUgO8D_dU6Xz-7Cw8fBPDX9-f39-f391CA7wP51
TpfFPzvH-sLDx8E8Nf39-f39-f3UIDvA-nVOl8U-wDvG-sLDx8E8Nf39-f39-f3UIDvA-nVOl8U-
wTvF-sLDx8E8Nf39-f39-f3UIDvA-nVOl8U-wjvE-sLDx8E8NcMyNcYYNcb_XJViNcgQNcocNcwy
NcYYNcYgNcgQNcocNcwyNcYYNcYgNcgQNcocNcwyNcYYNcYgNcgQNcocNcwyNcYYNcYgNcgQNcoc
NcwyNcYYNcYgNcgQNcocNcwyNcYYNcYgNcgQNcocNcwyNcYYNcYgNcgQNcocNcf_1tfaO8D_dU6X
xT-BO8X_wsPHwTw1-f39-f39-dQgO8D_dU6XxT-AO8b_wsPHwTw1-f39-f39-dQgO8D_dU6XxT87
x-7Cw8fBPDX9-f39-f391CA7wP51TpfP-sLDx8E8Nf39-f39-f3UIDvA-nVOl8-_wsPHwTw1-f39
-f39-dQgO8D_dU6Xz-7Cw8fBPDX9-f39-f391CA7wf51TpfN-sLDx8I8Nf39-f39-f3UIDvUPDXD
MjXGGDXG-lyVYjXIEDXKHDXMMjXGGDXGIDXIEDXKHDXMMjXGGDXGIDXIEDXKHDXMMjXGGDXGIDXI
EDXKHDXMMjXGGDXGIDXIEDXKHDXMMjXGGDXGIDXIEDXKHDXMMjXGGDXGIDXIEDXKHDXMMjXGGDXG
IDXIEDXKHDXHPNY1-f39-f39-dQAAAAAAAAAAQ==
:: map/.info.pod
--[[pod,created="2024-03-24 00:48:06",modified="2026-01-30 18:48:07",stored="2024-03-24 00:48:06"]]
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI0IDAwOjQ4OjA2Iixtb2RpZmllZD0iMjAyNS0w
My0xNyAxNzozODozMSIscmV2aXNpb249OTM2OF1dbHo0AGcAAABWEAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD--------------------78QgiKSxoaWRkZW49ZmFsc2UscGFuX3g9
MAgAwnk9MCx0aWxlX2g9OAkAwHc9OCx6b29tPTF9fQ==
:: pal/.info.pod
--[[pod,created="2024-04-10 04:52:51",modified="2026-01-30 18:48:07",stored="2024-04-10 04:52:51"]]
:: pal/0.pal
b64$LS1bW3BvZCxiZ19jb2xvcj0wLGJsYWNrZXN0X2NvbG9yPTAsY3JlYXRlZD0iMjAyNC0wNC0x
MCAwNDo1Mjo1MSIsaGlkZGVuPXtbMF09ZmFsc2UsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRy
dWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVl
LGZhbHNlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSxmYWxzZSx0cnVlLHRydWUsdHJ1ZSx0cnVl
LHRydWUsdHJ1ZSx0cnVlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLHRydWUs
dHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWV9LGhpZGRlbl90b2dnbGVzPXtbMF09dHJ1ZSxm
YWxzZSxmYWxzZSxmYWxzZX0saHVlX29mZnNldD0tMC4zNjI4ODA4ODY0MjY1OSxpY29uPXVzZXJk
YXRhKCJ1OCIsMTYsMTYsIjAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMTA3MDcw
NzA3MDcwNzA3MDcwNjAxMDAwMDAwMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA2MDYwMTAwMDAwMDAw
MDEwNzA3MDcwNzA3MDcwNzA3MDYwNjA2MDEwMDAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNjA2MDYw
NjAxMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDEwNzA3MDcwNzA3MDcwNzA3
MDcwNzA3MDcwMTAwMDAwMTA3MDcwNjA2MDEwMTBkMGQwMTAxMDcwNzAxMDAwMDAxMDcwNzA2MDYw
MTAxMGQwZDAxMDEwNzA3MDEwMDAwMDEwNzA3MDEwMTA3MDcwNjA2MGQwZDA3MDcwMTAwMDAwMTA3
MDcwMTAxMDcwNzA2MDYwZDBkMDcwNzAxMDAwMDAxMDcwNzBkMGQwMTAxMGQwZDA2MDYwNzA3MDEw
MDAwMDEwNzA3MGQwZDAxMDEwZDBkMDYwNjA3MDcwMTAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3
MDcwNzAxMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDEwMTAxMDEwMTAxMDEw
MTAxMDEwMTAxMDEwMTAwIiksbG9ja2VkPXtbMF09dHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRy
dWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVl
LHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0
cnVlLHRydWUsdHJ1ZSx0cnVlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlfSxtb2RpZmllZD0iMjAyNi0w
MS0zMCAxNjowNTo1NyIsb2twYWxfdmVyc2lvbj0iMC4wLjQiLHBpY2tlcnNfbW9kZT0ibGluZWFy
X2h1ZSIscmV2aXNpb249MTU3OSx0ZXN0X2N1YmVfY29sb3JzPXtbMF09ezE1LDMxLDR9LHszMSw0
LDIwfSx7NCwyMCwyMX0sezEwLDksMjV9LHs5LDI1LDI0fSx7OCwyNCwyfSx7MjYsMTEsMjd9LHsx
MSwyNywzfSx7MjcsMywxOX0sezI4LDE3LDE5fSx7MjgsMTIsMTZ9LHsxMiwxNiwxfSx7NiwyOSwx
M30sezI5LDEzLDE4fSx7MTMsMTgsMX0sezcsMjMsMTR9LHsyMywxNCwxM30sezE0LDMwLDE4fSx7
Nyw2LDIyfSx7NiwyMiw1fSx7MjIsNSwyMX0sezEsMSwxfSx7MSwxLDF9LHsxLDEsMX19LHRlc3Rf
bW9kZT0iY3ViZXMiLHRlc3RfcmFtcF9jb2xvcnM9dXNlcmRhdGEoInU4IiwxMCwyNywiMDAxODA4
MTkwOTBhMWEwYjFiMDAwNjAwMDAwMDAwMDAwMDAwMDMwMDE2MDAwMDAwMDAwMDAwMDAxMzAwMDUw
MDAwMDAwMDAwMDAwMDAxMDAwZDAwMDAwMDAwMDAwMDAwMTAwMDFkMDAwMDAwMDAwMDAwMDAxMTAw
MTcwMDAwMDAwMDAwMDAwMDBjMDAwZTAwMDAwMDAwMDAwMDAwMWMwMDFlMTIwMjE1MTQwNDFmMGYw
NzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDE0MDQxZjBmMDgxODAyMDAwMDE1MDUxNjA2MDcxNzBl
MWUwMDAwMDExMDExMGMxYzFkMGQxMjAwMDAxMzAzMWIwYjFhMGEwOTE5MDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwIiksd2hpdGVzdF9jb2xvcj03XV1sejQA2QEAABUCAAD1BXVz
ZXJkYXRhKCJpMzIiLDY0LCIwAQDAMWQyYjUzMDA3ZTI1CADwFzAwODc1MTAwYWI1MjM2MDA1ZjU3
NGYwMGMyYzNjNzAwZmZmMWU4CABAMDA0ZAgAEWE2AGBmZmVjMjcKACBlNDgAQDI5YWQkAGA4Mzc2
OWMgADE3N2E4AMBjY2FhMDAxYzVlYWMwAPAdYTVhMTAwNzU0ZTk3MDAxMjUzNTkwMDc0MmYyOTAw
NDkyZDM4MDBhMjg4NzlAAPADYWNjNTAwYzMwMDRjMDBlYjZiRgBgOTBlYzQyCgAgYjLAAKA2NGRm
ZjYwMGJkiQAAlgBAMGRhYkAAVjg1NmQwAQBAODE0MbAAUGIzOTQ2VADwBDYxNzQwMDk5MmM3MTAw
Y2EwMDfIADBhMjQMAAQBAPA3YmM2NjgzMDBmYTliYmEwMGIxYWQ2ZjAwZjdmMGEyMDA1Yzk1NjIw
MDkzZTg5YTAwM2M5NTkyMDA4ZWRjZDkwMDk0NzNiNGAA8ANhOWVhMDBhNzdhNTQwMGYxYWGgAH82
MjdhOTEwAQAG8BQ3Njc3N2QwMGQ2ZDdkYTAwOWZhMGE2MDAxZTM3M2MwMDM3NCcBITAzAQAxMDAy
AQCgMDAxNjE2MTYiKQ==
:: sfx/.info.pod
--[[pod,created="2024-03-24 00:48:06",modified="2026-01-30 18:48:07",stored="2024-03-24 00:48:06"]]
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI2LTAxLTMwIDE2OjUxOjQ5Iixtb2RpZmllZD0iMjAyNi0w
MS0zMCAxODozMToxNCIscmV2aXNpb249Ml1dbHo0AO0BAAC_FQAA-zRweHUAAygAAAQABA9AEAIO
AAGgASACoA4ADxAADfDKAQIDD-8wDx_QBAUGBzAHDw_QCAkKC0AMkA8MDw0PDgxADPD-AQDr8D2q
ARAGDyAQASABIAHwAAIQAg4QASAPISABMA_BkA8RAiAOUAIPIRAB8KgPKA--8MYP_AoP-w_AD-cP
DQFwD2YPaQ9yD3MPdA4PaQ9uCQD-Ag9yD3UPbQ9lD24PdAABEAYOWwACP7zww08AAa9vD3QPaA9l
D3KwOgAGH0A6AAOmYQ9uD2QOD2EfbkUAH0BFABsv8AkwAP------MR--AQCs58gPQAAPEA4wDysv
-w8oBAAAEAAXJgQAayv--w8ALQIAS-0PDi0CAOH9D-A0D1AQDwzwDgPwCV4A8A5AbycPGw8kLQ8b
-SMAUQ0B-ScPYF9ADQT9J-BwBCAAcA8rLQ8o-StRABArQwBiK-A3A-AoGwDwCSQNDycNDyn9KwH9
Lw79LxAPbfAvD4jwLR4AgQMFIA8k-S8AGgAATABZBQoFIAcRABwDEQAsDw4SANNADydvKP0ocP0o
fv0oEgDhGA8cDx0vGh0PGA8aHxwHACIPHAYA8gb9HCACAAIdMR1R-RwONQ4dPh1U-Rw3AC-9sAgA
----------------F1D9sPD-OQ==
:: sfx/0.sfxi
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI2LTAxLTMwIDExOjM2OjA4Iixtb2RpZmllZD0iMjAyNi0w
MS0zMCAxODo0MTo1NCIscmV2aXNpb249NTFdXWx6NAAYAgAATAsAAP9TcHh1AAMoAAAEAAQPQBAC
DgABoAEgAqAOAA8QAA3wygECAwQFBgcED-_QCAkKCw8MDw0PDg8PAw--kA0PEQ8SDxMPFA8VDxYP
FwAP-5APGA8ZDxoPGw8cDx0PHg8fAA--8P8BAOv8UKoBEAYPMBABIAEgAfAAAhACDhABIA8hD_AQ
ATAPgAACgAgQBA8xD9QBQA_f8KsPMdACAQ8TQA--D00PLS8aDxMfDWABoA8M8JQP_AoP-w_AD-cP
DQFwD2EPYw9pD2TAXgARDF4A6iABMA_78MMID07wxAEAOgDvcA91D2wPcw9lsAEQBgw7AAGYDvDD
DygP--DGOQAv8AkvAP------RB--AQCs8BnIDgANQA89DzwPNg--HzUf-w84L-8PN---IwD1Lw8g
NQ8FFQ71J-BwJwAi9bAIAPIUVQ83JQ82DzcPMXUPMw829RsCFQEAJSBlIPUfDy8lJ3UX9RkpABCV
KQDyADEPN-UqACUQ9SoHJRf1IBoA8wTVHzYFCQ859SsQBRD1KxcFF-UdGQCaSfUrQPUrR-UddAAD
CADwCgAPICBMBR8rBQ83BQ8rDzcFFwwPQxwPSBwGAEBPHA8kFQDwE-UQQAUQBQAFEAXwAvUQRwUX
BQcFFwX3AvUQIA9j4A9yEAsCAGDwFg8F8CxcAP8IPPUsMPUsN-UsD2QQD2PwLA8JEA8F8P8BAP-e
UP----9R
:: sfx/worst_case_note_grid.sfxi
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI2LTAxLTI3IDE5OjU5OjM0Iixtb2RpZmllZD0iMjAyNi0w
MS0zMCAwNjo0NjoyNiIscmV2aXNpb249M11dbHo0ABcBAACyIQAA8CdweHUAAygAAAQABA9AEAIO
AAGgASACoA4ADxAADfDKAQIDBAUGBwAP-5AICQoLDwwPDQ8ODw8QAPAADQ8RDxIPEw8UDxUPFg8X
EwD-Bg8YDxkPGg8bDxwPHQ8eDx8AD--w-wEA6-8nqgEQBg8gEAEgASAB8AACEAIMEAEgDyEgATAP
QPDDDygP--DGD-gKD-8PgA-3Dw0B8AkBEAYMMAD------70f-wEArO-ID0AADUAPLQ8yDzUPMggA
Zc-wMPwwDz4Pdg9tD3YIAGWPDAAPNwAMAA4EACZcD0AAHTDaAA9KAeMvDgBJASwvDUBJAf------
--_qX---sPBwCgD-------------------80UP_w8P85
:: src/.info.pod
--[[pod,created="2024-04-07 08:14:00",modified="2026-01-30 18:48:07",stored="2024-04-07 08:14:00"]]
:: src/wavetables/.info.pod
--[[pod,created="2026-01-25 09:38:05",modified="2026-01-30 18:48:07"]]
:: [eoc]
