picotron cartridge // www.picotron.net
version 2

:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA3Iixtb2RpZmllZD0iMjAyNS0w
My0xMCAyMTozMDo1NSIscmV2aXNpb249NjIxNV1dbHo0ADdBAADmngAA9iN7WzBdPXtibXA9cHh1
AEMgCAgEcLcgRyAXIEcgt3AsZmxhZ3M9MCxwYW5feD0tMS44MwEAETcXABB5FwAnNDICAKcsem9v
bT0xMX0sWQDxCAwMBDAncAcgB2AHoAegB5BnQGdAJwAnBAA7Z-ALagBGNi4xNgEAFDNpADcwLjMB
ACIyN2oAHDdpACPwDGoAPyAHUGgAS-8SN2BXQHcgFwAXAAcAFxAHEDcQByAHEBcQB0AHMAdgN-AM
cAA3nw0JBACnEAeNBwQABi_nAG4AN-EGCQkEMAdgBw0HQActByAHTQcAB20XAgA-BwBnaAA7UQA3
MAc9ZAAxEAddaAAABgAADgBfPQcwNzBsADopEEfMACEXbWoAPyBHEGYAN-8KGBgE8CjagNoPGXDa
HmDaLlDaPkDaTjDZXgMABPsCTkDZPlDZLmDZHnDZDoDZ8CiLABMwfQASMG0ADVYD-wjwGwewB7AH
UGcwBwBHQAcQJ1AHIAfwDEYACx84RgAFAbkCTwAHIAdKACPzAgsLBCBHQAdOByAHbgcAB44XAgDP
BwAHbgcgB04HQEcgUAAcc9BOQG4gjhACAF8gbkBO0EIAGVRAQATw-wEA0b8H8C4n8CxH8C0H8C8D
ABowCQAVMAMA8gYXUAfwKScgF-ArV-AtF-AuB-BbBwACAFMn8CUHAAIAMfAnJwkAVRfwJgcAFABQ
BwAHEBcoAAyqAEQuMTI1rgABDAABsgAfM7IAARCzfQESK1EAQitH8GsPAPECIAfwLCfwbTfwKwfw
L0fwa0cjAFXwLUfwbBQAASoAEkctAAAhADEX8C4qAHEvB-ArN-Bw6QBNK0fw7Q0Bki8HQAdQFwAn
ANQAEicCALAQFwAX0AdAFzAHINgARQcQBwACAAHvBAMQADDAhyAuAAIQADgXECccAG-wAxdQBwA-
AApi8AMHQBcQFQAlFwAhADEQJwAWAB_gSwGfNEAHADECERlAAQMPAFQH8BuHIDcCGCAYADQhB0A7
Ah8X8AAh8A4QEAQQtyAHsAcAB9AX0BdQRyAXQCcQFxAXMCcwBwYAkWAXEGdAFyBHUAwA-wBAB3AX
0BfQBwAHsAcgtxByABMfMXIAAPEE1wD3F0CXIBcQdyA3AHcgp2CXQBUAPxkA11gAKCUHAAIAkTAH
sAfwABfwBg4AMSAXQKQEQHAHAAfGABGwFgBRAAdAFyAIABOwGABA8AgX8A4ABmIBLwAH5gAoBVgB
AEABQBAXECewArEwJzAXYCcwF0BnEHABAAwAP3AHQFgBNrYUQJcQFyCHADcgx1gBHxZYAT0RAw4A
MVAXEOQDALoAAMYAEbAWAACRAgK9AxOwGAAv8AVYATcv8PA5ACH6AicSBPAqB-AVJ-ATR-AUB-AW
AwAfecUEAgAzAg_CBAgfN70EBQIIAA84AAYvJxC1BAYL2wBULTAuMjfcAE8xNC41xgMQQVAXUBdh
CvMBFyAXIHcgFzBXMBcQNxA3EAYAABAAABgABCQAADAAD3oCMzAHEKf0AHEQd3CHUHcwaQBhMHdQ
h3B3FgBOpxD3B4YCD-gBTQkbAQH7ADAnECf9APMCMBcgF4AXIBdwFzAXYBdAF1ACAB-QEQE4MAVQ
h4QBYRA3ENcQxwIAT9cQ9w4IAS4POQCToBkLBBD3BSAH8AWpBhAHcAIQB-AHAHQCAA0DAAIABC4E
ARAALxcQHAACFiCbAwEQACDwB1AAXwUHIPcFQwEVHzCZAAGQ9wcA9w0QBwAnbQBHEGcAJ2cAElcC
BA0YACdnEJsAXwD3DAD3hwAn9AVUDARQ9wdA9wjwD-cJIAfwCAfwDgkAwQ33CwAH8AoH8AxHEGwA
AR8BYzcABzAnAEMBVSAH8AtHmQAAtwQiZ0AKABQHFgBDUAfwCiMAANMHMCBHQGMBA7AEQDAH8Ann
ABMHAgA4RwBXngURAI8IM-AIZ50BIAcQLwwHAgAQIPAKggf3EfAMB-AGBwA7BfdECgFmLTcuMzc1
DQ0uNDcrAgoLAZQH8AcHIPcK8A4JAEANB-AJawFC8AwHMDEFA5sBMgBHIJkAYicQN-ALB20KEwAu
ASJQVwoAFAAWADRn8AojAAGKByEwV0QAARsBZCBH8AkHQCoAAfsAFTBAAAQdASDwCO4GAowCKhdA
HwDCJxBn8AcH8Az3EfAGBwAPCwEm8g4oDQQQ9xQg9wPwAgcA9wTwA-cF8ANnIBdANzCnMLABECcA
Dy_ABw4ACgQyACL3BUIAIQcAUgA-IPcUrQIUHziWAAFyB-AC9wMAB1MAovcFQCcQRzA3oFdYAX8g
BzA3AIcADgAKBDIAA0IAIQQAUgAPlgAlX1QMBPAKQwMGkHcgJ2BXAAdQx9ABIPAMyQMQF8kBABgD
EaDlAVHwC2cAR94BEGdkEgIxAw4TACMJdxMAEnc5AFNgB-AIh04ABhMAtAenICdgh0DHAAdwEQMD
HgIr9z7dAPMAMTcuNDQ2NDI4NTcxNDI55wDALTQuNjQ4ODA5NTIzBgAC8gAeNvIADyoDBzBgJyAF
BJFnwAcAV-AMB1BzCAFXDDBnAKfXBCHwC7EPAP0AQ1B3AKcYAw0TADoJB2ATAFN38AgHcE4ABRMA
MAcHkHAAU4fABwCH_AIP8gA-DzUTIg_BBRMAWwBPI1cwl1EAOpAtB3AHECcwJyAfCg9PADQBewEf
UE0AKw7HBw86AMNnCQkEl2AXAgAfl0cAFB82RwAAVEAHABcwdwIwFwAnnQgfMFMAJV8KCgTwVDoA
FQ9IAScPOgD------------------------------------------------------------qkSjg
AQAADgEAAJk_DgEA8CKUJ-D-xTcgh-D-vncAAZcB8P_7lwEnIUcR8P_3VzEnAQcBlwEH8P_ztwEH
AQcBNyFHDgCAsdcBBwF3ETcMAICv1wEHEZcRJwwAQa03EXcoACG3ARAAYqs3ATeR1wwA8AepNwEn
EdchdwEnAfD-qDcBJwH3AyGHGgDwCqcnARcRhwHHEXcB8P_mJwEXAbcRdwE3AWcPAKEXARcB5wFn
AUcRegAQpJIA8BVXEYcBZwFXAUcB8P_kFwEHAUcRtwFnMScBNwHw-6MnEUcBhxFUADCnATcQAFAB
VwF3AUgAUQcB1wEnEgBg5wFXAfcADQDwBqEnATcRRwEnAWcB9wTw-6EXATcBF7IAUAEXAWcB0ABx
V-D-oAcBR0IAQCcBhwGhADl3AUcWADAnYVd0AFHw-6ABdyEAMScRBwkBUFcBVwFnFwARV5IAIgch
FwBhBwEnIVcB0gAhoFdGAAIWACFHASIAEBEsAXAn8P9up-AWawES5x0A8AchFwEX8P9q9wPwEicR
VyEHAfcDEacBgTwCIADxAPD-N-cH8BAXAXcRBwH3BroBERIbAEC38P807DMArADBNwH3CgE3MSfw
DwEH9ABhL-cN8A0XtwBg9wxRV-AOGACAB-D-LPcP8AwbASH3DUUAABQ0ABsA8AIK8P8p9xHwClcB
FwE3IfcDIe0AMUfwCx0AkQzw-yf3E-AJFxoBMAcRB0AAQAEBJyELADE38AolAJEO8P8l9xTwCScP
AWAXAVcR1wHzAFEHERfwCSIAgBDw-yP3FvAIigEhISciATGnEVcjAACfNQAjAFAR8P8i9885IAE3
mgIhAUeeAVAXAUcBN30BIfAHJgBQE-D-IAEnAAGPAAAdAAFaAgF2AAHnAUEHAfAGKgChFfD-HgH3
GfAGN4EBAkcAEydbAABjADAH8AYoAIIX8P8d9xrwBj0ABR0AEgG4AQGkAARTALMW8P8cBwH3GvAF
N3wAE0cYAgAOAAFiACDwBQ0Aw-cY8P8aBwH3G-AFJ34AE0coABUHtgBRBwHwBQFPAHT-GQH3HfAF
nQAhVyEnACIRR4wAA1MAwBrw-xcB9wRB9wXwBYoBAEYBIlcBBwEAmQISNywAEQF3AGD-FwcB9wFI
AFMR9wTwBoQAAs0AIgchWQAAWACA9wQx9wXw-xUuACIBBwIAVBH3A-AGDAEBggADXwEAYgACswAj
ADEoACj-FDoAABQAEwJuAAA7ARA3AgIB2QNQNwEX8AI5ABcRZQAp-xM8AAAVABQBegABPwAAigMB
CABANwEn8CoAFNc-AAJqACX-Ek0DBgIAAUQAFiGBAAdCAAlBAANDABURjwMBBgAApAAg8AYKAwP-
ABEnTAQCQQBWAAEHAcctAACvACT-EEAAEmcTABAASgIDPQAjERfIAAE9AAQ8ABVnPAAVD1AAFYd7
ABcnegAHPQAA9QMAHQQCYwAi-w-LAAERACoB53MAE0e3ASIn4F4AAjYAEOdvABLncQAqEedoABRH
aABU4AHXEccvABINLQAsAedjABMnYQAGYwATx4gAJf8NMwAKZAAGzwIBZgAAzQAR5zQAENdoAEbX
EfcBZQACWAMEZQARd2MAJPcBLgBQDNcB9wQEARUFLAAFXgCRRwFn4AHXAfcCLQCSx-D-DAG3AfcE
WgEnBddYABLHVgDBAwEHEdfw-wvHAfcFVAAn9wNPABHHTQCABAEHEcfw-wpJARL3-gICKAABSwAw
9wPgHwci9wZxABAKJQACDAEETAAApwAw9wPgbwADlgATCDEAEBElAFUJEScRN0cAEAhrABAIpQcj
9whGABEJRAAh9whCABAK_wUQCB8AFQo_ACL3CDwAMQsBpzwARIcB9wmnAABFAAACAAM-ABALPwAB
IgASC_8AFwhAABAMQAARBqECLfcLQQARB4QCFKcnAAEmABcNRQARB9YBAFwGEJdGABB3KQAFRAAR
J0IAIuAHQgAxDgGHQgBPVwH3DkIAABAPHwARBB8APxEB50AAAAIhAAEnBCD3EmMAEgRBADIG4AdC
ADEQAXdCABNHIAAyBfcHQwAxBuAB_AEQEcUHEAQgABEUYgAWBz8AYacB9xMBVz8AEDcfAAE-ACEF
ET8AEgWIAwQiAEABNwHnEwICIwACkAAzBeABRgAQFCQAEAN5AAIlABABEgIVIf0EEwCsABAC-AJA
R-D-AioAJvcAKwAFqgQBHAICrwIALABBN-D-ApEFIOcRLAAzAvAF8AIDLgAhAuAZCSH3AwcAEQcw
AAEvAAH8CRCXMgAgBvfIAAMCAEAR9wLgKgARtx8GELftCAJiAAAVAACDBxKnZQAFuwUAMwAgAdDl
AxG3JwMTpzMAAjIAMUcBZ9cAIfAFcgAHmQBQAcBxlwF4ClAXEWcBl2MFcPD-AQFHAZceBjBxtwEV
ATQ3AddeBQAzANEAgLcBdwHHARcRlwF3CQUR-x8AAAwAAEwAg-cDwGcB1xFnMAABaQGBVwHXAYcB
RxEHCgBiABFn5wqilwHHAbdxIOcB120FICHXhAOQRwHXAZcBVzF3KwDxAgCHMWcBpwHHAZcR9wkB
5xGHZwEy1wH3xQEQp4YEACcAAFwBMKcB1_QCMwsB54UFENeyAxEXSAEBJwAQ-iYAMMcB18cCMAwB
57wFIhHXmgMQ18wBYQEBF-D_x64AAJkEEPcGBQVKABAJCgIQ1wUAMBfw-ScCEEcMABE3rgoh9wxZ
AQNQADAKAdf3AFIBAQfw-SgAMAIRFyoKAFIAMucRx1AAMQoBZ6kBAAALUGcBF-D8QAAArgIgEbeP
AwdQAFELAWdBt-QHAWYLQvD8AbfCBCICASsAIhHHaQFRCgF3AecpADRHAYdTAAB9BgIqACENAWQC
BYAAEHcQABEXTgcTl1cAAy0AAREERfcAEceBAAIrAAC4CwAOCwFZABV3KgAl5xFWABML1gACMQxR
F-D7AbcaAjjHAaeBACQR5wEBEbeuAAErAAJVADQnAdcsAAGQBhbnKwERFwYAMSfw_x8MIHcRAgIS
h6sABlcAEQs7BxGnHgkwhwE3VwBhFwFHEYcRywMRd1oAEQFaACD3AD4AFQAwABBnZwBh8PsBN0Gn
ZgIQ96gCEOcZAlIAEfcBET4AEQHcCgAvADB3YVddACH3A_8JMIcBd1cCEAC8AAE5BwHfAwExAFAX
EXcBlyYCMAXw_y8AACgDEIfeBBAB_wMQAQgAAY0AYVcB9wIhl3wDMFcBx1wAAgUIACkDEKeLDBAB
sAATAswHAzEAIQG3MQBRNxHX8PvpAwIwABDnGwATd8sEEge3AGH3AgHHAYehCiDnAV8AGjcvABFn
LwAkAxEtABG3eAZTZyH3AAFcAAC4CRKXgQcSV4oAAl4AEALeAAAxAJEXYfcKAQfw_1ctADFnAXeY
ARH31wURA1wAEAJZARADjwIQAvQAEAdwAQE8DgKZAAD2BwBNAAEhCCIDEWQAEQMaAxEnqAAwF-D7
sQA2p1EnLAAREVkFCiwAAA0EAH8CApUEEHdxADEFARctABEFiQAEKQAytwHHVQAh9wYLCQAICBIR
VQgBVgASBFkAEZctABPHgAIA9wMYty8AAQMABysAAPICAX4CEUcqABEnYwIi9waVCAJZABIFPQER
hzEJU9cRRxFHDAEAWQASV9oIIfcHWQASBn8DEXcoCVDnQWfw-AUGCSgAEgGzAAkqAGD3AAGX8Pxb
ARHH7AEXl1MAAqICAuMPAigAEadiAQCBABGH9gATCFMAMQgB100DACwAEOcpABGXVQEAAwEBjwIh
9wksAHQIAccBJ1F3JQBCR0FHASkAM1cBBycAQifxAxcpABF37wEQ1ykAEecCASGnUXADQfcKMTfn
A4MXARch9wkBtyoAYccBp-D8d9IDAEoCUwH3HAF3kAQBbA8cpygAAAQAAMUAHxsoAAEADgcBKAAR
R1AAAYIHAikAEidZBTELAZcpAD13AacpABMaoBADKQAABQECKQAyBwGHKwARdyYDQacB9xnICwUt
ADMMAXcvAABEDwEtAABFAQMtABEYiwMAKQIFKwARl6wAFCcrAAAoBg4rADENAWcrAFiXATcRNysA
APYBIfcWRAQFKwARVysAgacxVwGH8P1nFQIfdykACAF-AQApADWnAYcnACQRRycAOBMBlyUAEZex
ABHXZwkBegkSJ14CExInADCHAXcnADRXMacnABFnSAsUJ6ABCykAJocBKQATEfMGDyMAADE3ESd_
BiH3Em8EEad1AUH3EAGnAgAHKQASJ2kGYAH3EhFnEXkDEjcpAAJCBRhXKwAxBxFXtgMh9xHJCBKX
TwMfDysAACIRdykAEBAtBSgRpykAEUf-AgMpACRnAbMDIfcPWAURBxUAEDe-BgAdCAIvAACCAQMx
AABiAQMxAAAiADFnEZcGByf3DS8AMmcBFy8AETcPABlHMQADYgAHMwABXgAiAQczABEnDwAAywAB
owgRDBwAEZePARBX2QIRJzMAQ2chlxEvADlnIWctACERd5MBCC0AANoDIvD9PAMRR1wFEFd2AxEH
kgQRh4EBEFcJBBg3LwARh20DBi8AFBFcAAByBir3CC0AAG4BEWftABGnHgAUEVwAAaIEACoFE0fr
ABLXLwAzxwFnqAUQZ6oFAfUGKhF3LwAAJwEDLwAAHAoFLwATBV0TIncBLwESZxAGALEDModx5zEA
EeeNACD3AW0HAgoIALcADTAAEHejBTF38P5JCSEHQS8HEGdqBxInkwAFMgARFxoAAxMBMzcRpzUA
AJULAeYTAjUABPcUAzUAAhoAASYBEVc5AQCGAAQ5ABJXxQwRZzgINTcRZzgAAAYBARkAAJsKAIcK
EQdlABI3OgAAawlgZ3HHAVch-wsKcgARd30LADkAMRcxR9UBAO0DATcAAJkBIfcAywFABxG3IeET
GUdyABEH-wUAyAQRRx8EHRc4AFEXEacRRyQDF0dwABEHbAMEOAAhVwFPAQBRABW3cABAAQcRh08B
EBGsAAY8ABE3CgMRB7AAGLc_AADsAAPKEBG3igAgB6H6Fgh4ABFHDBcRBx4NETeSAAIWABAXPgAR
V1gHEbc9AAChAAYCACNnAYMAAWwTAoMAIgdhGgAAGwMJSQARF5EGEUchAwC-AwEtAAMCAAAKAxQ3
jgAADhgFAgATJ_YGANABAnQGYwfw-gcBd0sAArYNEWcrACC3EWcXEVeMABFn5gETBwIAUTcBRyFX
fgIAggEHRQARpxoEE0dwDSH3CMQAIlcRhwARdxUAAPgCMRdRd0MGFCc8AAE3BgDkACBnIS4AIPcI
ygMBzgEC0AMAbwEUR7ACAQcHUgFXAfD_ygQByQOBl1FHAfcIIWdSAQDTBmBHAXcRtxEdChFXXAAl
lyE0AAJjChCHqgM29wkBagASxy4CIhFnMQAAygIALAJTNwE3IXcACEP3ChGnYQAg1xEBAw0uAEZH
MRcBLgAnAbdcABCHagIbATAAFaczCAD3EQNcADG3AQdeAAYuAAAwAwkwABCXUAUgpxEvAQA2AAJe
ABSX7QABYgUMMAARDbMDAvMFAGgDEXc4ABGXPAMRVzYAABoBCzYAEedGDwBnAACDAANpAAAuAjIh
dwH9DxB3gxEpAGc0ACz3CGoAIRG3NQURZ4YHADEAACsHCDEAAYMDCmYAEcfGBQBaABuXMwAQhwsC
AjQAIwEnZQAxlxHH-QYRh8sFAKgWAjIAADAABTIAAZcABFUCFYcaEROHHQcVBzQAAHsBD2YAAxHX
GAcCMgAxV-D-qAkCMgAAaAAAtAoaB2YAERFpDg8zAAgBDg0VBmcAMXcRlyAACjQAEQfUARdHaQAA
iQYHaQA-EXcRNgADAKUDCGwAAMoLEQcyBAC9AxEHQgQA3gQB9wgBgwQQJzwAEQIfABEnTQAA6gME
gAwC2QERNz4BKmcROwAAGgAAOwAATwIHOgAUBDoABXUAIxFniwQTlzoAASsCAToAAJ4FCHQAAK8A
AnIAIqcBNgARJ34AAv0DEQcSAA46AAx0ACP3AzsAAvYEIicBjwRKx-D-AzkAAGYEBnMAADcAIxFH
NwAAmwMINwAAAgETh0AHEDdQBgABChHXfQQSNz0PBHEAIRcRZQAAoxYQBMMBAqUBAzgAEQF0ATXn
ESc4ACERR3YAMWchd4IBDzYAAgJuACLnAW4AEZcVABVXSwgRhycFEec5ABOXpwARV10DACIEBnAA
NucBV28ADzYAAzFQVwEOABMRuxIRV_8IESdcBQAVAAAIAQC6AwQ5AABnAQY7AAD4AAIQAwGCCAHX
EwGkBQGxBgI_AACJAAQ_AADPAAh5AABXBgE_ABECjgEhEUc_AAEGAAG0FBGX4gUEPgAAQAACJgEF
fAAlEUebEAE4ACMRV3oAAdUAIgFnPAApBTc8AAAzAwJ6ACY3EXoAExc3AyEHARMBLxF3PAAEEUd4
ABI36RASR_EBASkIA7gAAD4AAOIAAj4AEUccAB0XegARJzwEEmdqDwpBABVnQQBJ1-D-BkEAIUB3
NQEiVwHSCBFnKwcR1y0BAIUCIDcR5QcCPABhxwHw-wc3KwAEPQAAZggHMQgQITcJEceyABEHKQcf
lz0ACBEwQAgCewASR0AAEBEXFRHHHAIRF8oCADEAAkIAAKsEQfD-B7d1ERJ3PgABuQAwEVdRYAIg
txFUDBEXkQMVRzYAEjf1IAg3AAC3BQFGCxFniAQTJ1YMBDIAACkBCjIAEQcTARBX2AETd-YGAMIA
JJcRMwARV1oVCDMAAL0AEtdKEwCgARFHMwAApwUTdzMAIWcBoxYCSA4ENAAB_w4RAeAEERc0AVNX
EZcRh6AAMHdBNwAaADMBAjAAAJIEAzAAEZdRAROn8AAA7hMADxpBEUcRV_ILIFcw1AUDLAARJ3ML
EncICwUtACInQVoFIEcw1wMStysAEjdTAgFxDjGnEDchAAAuABEJOgBQhwE3QMcrABEAogMTJy0A
ANMhQRcBpzAjAQovABBQ2BIR50IDA-ABAAgBALkIPxGnQDAAARHXCAACsgUADAIFNAAAwwhHEZdw
BzQAEQGNBFE3UOcRd1ICEQc8AhEXBQMAmgIVZ3QAAwIAXREHQTeQQQBBJ3D3AN0IEQepAgJKACEH
8YMgDAIAPBcRwD8AUxeQV-ECNQAE1wIUId8CUScBVzEHCgAiB0EIADon0IdBABDgRQELAgAFXwNR
FwE3QQehBBIHxAlYcTcBh7CDAAAIEAGOGQsCABchVwADewABcQwwAZcRvQ0QoGcBJ-cCRAAlAYd0
ACIXwQoAAlEBEQcpAwLnBAc3ABECrBABTggTBwsCDAIAEUdxABFHAgAAuQEkZ5A-ABIK-AA18ADH
6AUHNQBBAWcRV9UZADUAMVeQhwwCCzcAE1diAQQfAgCYBwRoAFEHAUeQh4MDNTcRxzYAEOD_AyJX
AasBAZ8OAC4AAmcAAE0FElc0ABBBJB4CFQEQ4BYCAhoCAYgPAKISIFcRCg5BV4CHAcsdEAItAAEL
ASHgVysAEnddAAD2AwLMAAJdADFngIckBQcxACHQV7UAH4dcAAAiEXcpAAA2BA0qAApZACB3cMcD
AC4AIQyXKgcih8AuABGXxAQUh4IHAVsAFmctAAC3BQ4tAADGAQJaAQtcABG3xgQ9h7BnXAAA9wAL
XAARx8EJDC0AAlwAJFcRWgAQhwUcQP8M1xEHBSB3sIoHMWcRh0AFHXdaAAMtAAHnBkCHAXegJAAC
UAwRZ3YGE2dZACaHYCwAEwIqABE3Yg4AFwUDWgAjAWfjCB13LgAA-QAC9QIXh1wARmcBhxFaABEN
UAIid5DoBQxaABFnSQMzd3BXDgEaDi4AD1oAAADiAAYuAABzBjF3kFfNAgA-AyZ3AQoPAlwAM4dg
V4oAEQ62ABRnLgADXAARdxIHEXfKGgDkAA8uAAQDXAAGLgAthxFaABCAhAETRzQDFmcuABARigAo
p1AuAEKXAUeQLgAkZwFaABF31AcRB8gBM5dgN_QAGg8uAAAAAQYuAAJaAAEsABBHwSAwEPcBixUQ
gKgCD1sABSCnYDEHOCcRxy8AIlcRXAAAVgIDlAEBiQ8ALQAwhwEX9SIREIkAAlwAE1c-AQCLAAEt
AAF5DISncBcBhyH3ASwAICeAaQIAXQAKWQAANAAzp4AHDwECLAAxF5BXSAwC4QARVyQAEZczBjWn
kJcoACKnsO8EAtoAE1d6AAKCAEKHAbeAKgAAiggxl6BnIAAAVgACUgAQh3oAAV4AAyoAACYlASoA
MecRV-0BAtYAAV4KAmEADCkAGddRAC-3AlAABALhCSmHAVIAAGwHDFIAM6eQ15UBAl8FAGoFA7Mf
AlYAAiIBASsAJ4DXVgAkRxFWACIRB0IAMgHHcC0AEBODACGAx9UKBFgAQ-cCEQdhAAAwAQorABPX
bgAFWAAiAhHrCgJqAiLHYFUBEBMOFA1ZABUDLAEHKgAA0gRWl4C3AQf8AAVZABFndQMxx2CHkSmC
E9chBwGncMdLAAJUAAM0ABKHLgEEKQBQ9wERp2B9AAIoAAFPAAIdHgUlAB2ASWBFNC45NG5uBVRx
GDUWAC42N11gDkssDwEADyBcEaQr8AnGFxFXIYBH8P_xRyGHEWCn8P_pVyG3EUDgDnCkVyH3ACEQ
sw7wAJ8B9wqR1-D-mzH3BAEXwWwQ4Dfw-5gRRzG3MScBR1FnzAqAlSEnMcch5zF1GKA3EFfw-4oh
J0EXgiHxAQFhdxEnIWfw-4YxJyEnISecKrAxpyEXMVfw-4NBh9QNICGXiwMQAyYAYIAxlxFXUYkT
wPcGIVfw-34hpxFXQQMEMFchN_0e8ABX8P98ETchRxFnQZcBNyEMJiD3A0wAEXkWAPMDNwEXEbch
VzFXEfcFIVcR8P92FwBwJwGHQddB9ykRcPD-cxE3IZfQD4AR9woB9wQhZyYMYHERNyGHIQENQfcL
UZfVFVAH8P9vEWUAsychZyH3CzF3MWcRGABQbSEnMSfpBRERoiEAGABih-D-axE3FgBRAbcxN2FQ
FAC4C3Hw-2kBRzE3XxBgQfcKQUcRnhpRN-D-ZwHXAFAFAfcTIWgXEMcVABBlRQFwAfcgIYcRN1QQ
ABQAEGQdCJAh5xGXMfcEIbcWIyAR14ws8QBiRxEHEdcxZyGXMYcR9wyQKUBgATcRrg7AlyF3EfcA
MTch9w4RGQ5CN-D-XwgMIBGHXRBCEachF68aEEfTARFdDBAgdyF8BHHXEfcUEVcRGAAQW9QQAXIi
MIcxt6IcIWcRTACQWhE3ETcRZyFnBAETAIgiIBFnFgAx8P9ZCREw9wOB6R9AEfcBcZ0KAYMAEVjT
I2A3EXcx9wJ4LhBBMBhA9wERN88AEViEAADfBYL3BCGnASdBt54hkTfw-1YBNyEXMaoaMMcBNzUg
EpcZABBVgy0QIYwAMPcEEZwOQEdx9wnwCQJTABFVOAAgFyHmJQAWARBXDBYAPwARN9MRQCfw-1RA
AAAEEQF5IQC7F2GHAUdR9wC7LgGzAgEmADI3MRfVAGACARcRRxHlAVJHQfcGASYAEBd1AWHw-1M3
QRdYACBnUdsKADsVQWcBRzH9JmEnASchdwElAAElAgBLCQDUJALoDgDWBjLnMYc2GyARByYAERHd
DhEARhYAQQkAxhAQYSIAIFchxgJiUycR9xEBHQCiVwFHMafxAHcBRxsAAGslQBcR9xL8ArARxxEX
UQcxBxFnEbkVAB4AcQGXERcx9xCeBMC3ESdhJxEHIVcRRyHdL3FTdxEnERcxlAMAjxJAh0E3cdgO
YVcRd-D-VO0I8AIRhxFnQfcAEScRdyF3gecBR7sDEFVnAwCdBiBnQe4RUCF3EZdxKyMAswMQVbEC
AM4AIGdRNwDhIXcRZ7H3BhFn8P9TATe8AVBnEWdR5yQwAN4GUIH3BxFXHAAhRxFFMJBRJ0FXIUcR
hyFMBUAHcfcIHgASUgkIAOQUQEFXMcdmBREBNBkwhxHXFBQQUXwLIDEnqQFRQWeBZxG_CwCzBSAH
US4WASIAAN8uAAYDkmdRd0EHcTcR1yEAQAEHQad8IyH-UGMKdKchBxFnUYccAACDDTMhpyEMACBR
p5wtQNyH8FrWAkCHUXdxRwcHAgAkYYcrAEABB0G3LQBwXIfwZbfwWPkAQGdRd2G3KAEFDjJRdyFz
DfAFB1FnETdh1-Bat-Bj1-BXN0GnMYcLGnFB5wEHUTdBxwbwAEF3EfcI8FnX8GH3APBWN2wLQzGX
YQf5FBDBlQbwAQcxhyH3BvBY9wDwX-cC8FRfDDER9wY1DgGoFkEHAQeBegDQIfcT8Fb3AvBe9wPw
UycAMiH3BCcAAEMqBgIAIMcxHB6A8FX3A-BLN9DJBhBS5w0CLgAQFwsFEicoAAGfLvAC9wERJzE3
8FP3BAHQN-A3Z7D9ABBR4gACMQBDNwH3JCkA9wBBFyEX8FL3BBGwZ-A1h6ApACECUbYAACkAAGcg
ASUAYaCH8DOnkCUAEgdfBBAH9hUSJRENALoBACYAZJCn8DHHgCYAAMgcMBEXcdQJMPclMdMd4Ich
Z-BS9wMhgMfwL_dwDAUwAPBQnhdCJxFHMV0PgLcB9yYxFyF3Ai9AYUfwUp4ywhFw5-Au9wBgEScR
5zAANhcRN_MBAP4A8BAR9ychJzFnAVdBR-BS5xEXIWD3APAu9wFQIScB5-BQ_gCABxH3EhH3J-H2
GiDwUmYdgVD3AfAu9wJAoB5whzEX8FBnEboqICnBqQAgURccBJAhQPcC8C73AyCgAPAGEUcxFxEH
8FBnAfcVAfclEYcRFyF3KwCABxEXMUcRNyFxaFMtEfcCIJ4AABsMIfBP4ACxERcB9wkh9yQR5xHt
CSHwUZkPwCcxIPcCEfAsEfcDENgyAeYEMfBPF-UDIBcRDxlBEfciESMeUBcRZ-BRBRgQEQ4yshD3
AxHwLCH3AwAhaxAAegwx8E8HkgxQJyFnEdfNARAgdRsgJwE5AAD4DAHsAlERAPcDITsAAVcrESe_
IhBP1wkQNyoEhAG3IUcR9x4ROQAhhwFxABQxNQARMW8AECFLI0EBZ-A3QQZQJzF3EZdECBAdhxsA
0RhROmfwAYdsAikHIW8AEUfYHUABh-A2CA8wQYcBbggGOABTOYfwAXfUH8IHMfcCMfAsMRcR1zF3
NVB34LfwNAYFIVGHIBpRpwH3HBE6AHFH8Dm34HchYADFIdcRJyHwGWewIQcBPADCEXfAEdfwMgEn
EYdRjhwQHLcYAY8uUPA31xHArwsBdgAAPwCgMbBn8AWHoDE3AYUKAKUK8AB3sCHn8DARFxGHUZcB
9zH8BgLxBkA35yGw9gtRBwFHMddAAHCgh-ADp5AhKgMixzH0ADB3oCGXLhEvvQZxR1GHIfctMc0m
dofwNvcCEaB9ALDHETcxkKfwAcdwQREAFMd-AABQAED3APAvYAUgN2EwACD3LKQBAkMANAExkIQA
sMcRJ1Fwx-AA12BRFwJDV1EXIYQAEJA1AEMC8C4XQwBSFxH3KhGZB4IBN-A19wMhkIgA8ABHERdR
VwFHQWDX8AD3AECJAAByAxGBiQARgCMAofcC8CwXERchR2E8CRAqGy_TdxEn8DT3BSGAiwAgcQdq
BpFRQPcA8AD3ATA7BDQnEVcTARJwSQBwA-AsB1FXcf8eIPdGABVg8DX3BiFwigAAVwrBJyFHQTD3
AfAA9wIgIgVgJxEXAXcx3gwwZ2AxrACyx-ArByGHgbcB90c-AHLHIWchYGcRLTbhdwEXIUdRIPcC
8AD3AxDcBCAHASkCAM0AMGdgIQcAkNfwKgcxd5H3VUMQMfA116AAUQcRYGcBJwAgIXcDFbJBEPcD
8AEB9wIAQVoAAGcGQWcBZ1AHANHH8CoBB0FXofcBIfdBUgOBNccRZzFQZxFLCACpALFRAPcCAfAC
AfcCYRYJExGEAHBQMWcRN0E3QQBgUSfB9wJBnQIQKKkCQPA0N0GkEjNnIVCLADERhyGcABRRSwAQ
URcAMkcRl4wAIUAxHgDwAAEXISchB-ArAQfxBfcFQY0nECh3DSDwNEoHAJUJMmchQJoAIZcBQQAR
YVAAERFQAAIVADJ3EUfaAAB3LgNMAADWFiBnUacdoAmh9wQBNxGX8DMwAAEjADMRUEfSABKXpAAQ
QdoEQgMB9wIwAQFQFBEXdhMlQCE2AAZZACB3UccvlAdBZyH3AhE3AVsAAkQOQRFAATeqADBnAZe4
AAEAAUAEAfcDnAcwIYchpQkkQCFoAAAEH7DwLBEH8QOXAddh11oCQQAhtxH1CjCH8DTyCEERhzFA
2SMAPgEjhxE6AJMx9wMB8AQR9wKkAiIHIT4ZMTBBB30QcIfwLhEH8QIrGDCHcccHLxAhRi4RIVcA
E4ehADAHMTDKAwO9DwEUAACDAXHwBREHEecxIgAgEYfHADQRIEFnAGB38C8hB-FDEUABp3GXhQkA
rwYAnABQd-A1dzFbCBMgNzkjRwFpAHFB5xEXAfAGDQAi50FYAEJ3AachVgAAMQIxh-AxrgBAJxGn
gZARQKcR9xNMC2IhZ-A0hxGyCDEgIReqACF3ITQAIDHnmjpxBhEXEedBh88PJacRUQBQEYfwMRem
ADAn8QeGDEB3IfcTcQsiEVf_ABKnpwASAacAEWevACBnMfwcAacAAJIPAa4iEQdxFAJXABGHEAbw
AzEXAQfxAYdRp7EnEZcRRyH3FRICUhFH8DV3qAAhUSAVFAIEEgD0AQFnHBDwyB-BBxG3UZcBBzFH
EacADwMCrADQd-AwAQfxBJcR9wDRt1gHMcH3CH4pMzV3AXkAMWEANxsGI0chNQAhUbdxAgCrAQHU
BhInXDAA3RAjEGE1ADABZ-AeAiDxBCAMgYF3AXdB9wRRDgNTd-A2ZxEmADFREBcFAQJbAJCHIScR
dzE3IfAxDTFHQTfmKAKeGBSnWABAEVfwMT4A8AHxA2cRR5EnARdBBxEXQfcXGRAAXAAzN1cBKgAA
lAoAShgUIRAAQEcBN1GxBCLwBAAEMSEXERoaAAIAYhEXAbdRB50BQQFX8DChAFIH8QJXEa8DAS8A
IDEHhQcgBjGJDpMHESchV-A4VxFeACFhJ3gBERcaAQAlHQCZCAKEASLwBOoDQQEHQWdgABEHugcC
9QZSxxFH8DC0AiDxAp8JA2QBAm4AgUHXQQdBR3FnKApTR-A6RwGkABBByBECawAylwFnNQARMdkA
AQMFISFXOgFEJyHXMdUA00fwLxEHQQfxAwchF1G1ABIxQgBR9wQBd0HYA1AGEScxJ2cAEhc2AEEh
1yE3CgAzVyEXmAABzgBTpwEHMTc8ARMn4QzSAccAATfwMCEHIQfxA4gMFWcZGlP3BQFHQUkBALoF
gTdBB-A7NwEAlQsBzh4CNgEEsgoSh80AFKf-AQBDAIEJAccQASfwMccAMQK3QU0AIDFXOwkSArca
AZ0CIfcDGQFyFxHwPCcBEGEAAigBBF0ABMkAFEFhAALBAnL3FhABF-AywQBBx0FnId0BABAFIkdB
WwAxZyGn5wJV8D0XARBZAAAGBgKdPANbAEUx8ARRWwAArQthFiABB-AzuABRAfcAUbcZAgH5MAD_
AxCHwg_xIecBZ-A_BwEg9xecAQlRABFBrAARxzUAALgyYfcWQAHwM6kANQH3ESoAIOcB_AYBFwFB
ETch15ocYGfwPgFA9-ocBJsCAVIAdVHwBCEXIaeNAkD3IvA5oABS4fcQMQcWACEhxzAHEScMABFX
QjMATwAwRPcYOwIITQAgERcWAgDjKQMQAjEi8DmdAHMAJxH3CSEHohxhBxG3EcdR_QAQBroMYxFX
8ET3IvsBAEUBAPoDMiFXAUcAYRcB9yHwOjQBEAAyAAHjBwECABAhwD8Qd-gmAVsJY-BF9yEBR5oV
EFdDAADlEHAHAfcl8DsRPQAQMZQANKehZ4UAIAGXZBCRJxEnITfwRfcmOgBzJ1F3EfAEEY8VQvck
8Du1ABCBtgOgFyH3DkEHIfcKMUoOASMDIUX31gIQAW8AAIkIMCTwPKsAcHEnQQcRJ5FHDpAR9wBB
d6GHIZcQDSDwRgYOALIhAmUAoDnwPCEHQQdhNzEIAUD3AUFXYADwAQQh9wBxNxGHEUchJ-BG9yb1
QAFvA0L3N-A_kABAcTdRF6cHIadBRgEx9wYRdjWSESfwR-c6EfADLQCgPxEH0SdBx4HXIZsHEMeC
ExFnJQBQSPc4MfC3B-EB9zXwQCEHwTchd2H3BUEHEdERMbchxyoRUAfwSvc2IgMQAk8AIDbwMAkB
AgAQYTINMPcMIZoHcfcBIWcxB0EmMzNK9zdXADI08ELNBIFxJyFXEfcOIaMYQQdBVxHIC1UH8Ev3
NVoAMjXwQy0AEGFEQkD3D1F3LQ_TJxFX8Ev3NAEHUwDxABsB9wfwRREHwScR9xYBB78HIPclExMg
8E0uMhUcUAAQHCoAgUYRB7EnEfcYMRkh9yS0AgEoABQbUgCRVzH3EQGnEYfwNQJlsRch9xkRKwAg
TocvDTQRMWdWAEAHUfcV8xkg8EguAFKhFyH3EtIEgCwhFwFX8E_nDAEQFX4EQDHwAUFfIgFMMYDH
8EnRFyH3EFoAQgMR9xctABHHHjsCygNAMfAAMcwCASMxQcfwShFdABAOtB2SCBH3FiGH8FDH6joQ
xwIEAlALEpcnMRDXLwAQsdoQAF0fQAkB9xdhDxDXbhAzDQHHXAAGLwCi5-BL0RcR9wshh1wAUkFH
8FHnLQBRpwEHQeAQBkBnEfcO0xBwAPBM0fcNMek7AMkTAR8rIfBR8BOA9w4Rl2HQYYf6LxA34T6w
TUEAYfcNMZcB9wfsAAQsACECER0wUHcBB1HQKwsAVTAA3zQj8FMuAEAIIfcPYwkBLgASBHYwYFcB
B2HAcWkIIPcRJARhBfBUYfcLuyoAFBATDToVEVIqKCD3EX8UUGGwYQdRjRCABzA38Exh9wvLDhEh
wQhhByH3CxEnShUwSzcwAAIxFNGw6AAQ9wYscTBn8Elh9wvBCED3BjE3yAIAEBgwSWcwAzQSGFwA
IQEHxBCwCiB38Ehh9woxR0E6O1EhNzH3Cf8HMEl3IKoXAZYCE1FeABAEDweB9wogAXfwSFEzMBAH
kRUQC18HkQcRN0EX8Ep3ATcAEAEWB0AHYaBxLAYBwDdw9wwQAYfwRwcWAw8LAE4GAfknkiAB8EuH
ARD3DO03U7cBB2GQFAkBrCpxDRARh-BGcU4qIach1BkQB5oEYFfwT4cREA0YAYgiRQdxgIE0AHEP
EAGX8EZhxQYA_DwAmwelBAFX8E6XARD3DzIAInBx6AXglwHnEfcPIAGX8EVx9wXCARCnngAAMgBw
TZcBIPcPETIAYncBB4FgkTAAANMAgREQAafwRIH3_AQQAIwPAEoFgfBNpwEQ9xEBiCMBswkygVCB
vAYBNiQw9xIQYEYgQ4E9A0EEcfcDuSVAt-BMAZwAEhKfOAESBjGRQKFODQFQAVATEAGHETYAEQKL
ARFBcikAOgdAt-BLET8BIRMBaiERJxcAYQeRMLEHASYeUQER9xUAlyVxQpH3ACH3B8kqYCGnEafw
SzABMAD3FV8SAy4KUAEHoSCxZA9A9w0B9xU5UBfwQZFnwxMQIeUJQBG38EpaHgBqAhANQwRhwQDx
AvcPpgNQASfwQFHUDUF3Afcj4wwwx-BJXRcALQAxD-EP2wIw9xYRqRxAN-BAQRwoEXeRFGABZyHH
8EhaIBAHIQBB9xPxC_EDEgWBAhAXbhgx8EBRNilAEfclIRQBgSfwSTchFyEXiwBRBQHH8QozABAG
tgCANzF38D5RJyFMEyH3KCUlYSfwR3cxNwsJACUAEKfACwPxAABUAAB7RAAgBDA9UTedFjAR9y6x
F0HwR-cAvgAiBxEzDEQH0QcBAgBAZwH3MVAAUQHwPUFXxxgQ98cDAGsAMEb3ARMCEjD-AQORASYH
AQIAAGYaIPcOMAUgByF2ACJBl3sVUQQhV0HHIg8glxFHAAI8PgBSAxEOfBcUBwIAAbgCBgIAEZdO
AFANAQcx100AkCEnIechR2EnQU4fETeSRxJHxxIAZQMCuDwPRwABAqg7AfhGEwBIAEL3FSFXRQBh
ATfwR-chIgAD1hcjAQcMCgC0AeMh8D1RhyEnIWdh9wlBFzMAAJcHQSER9yVXDgFPAnD3GPA_QYch
cw0g9xGVDSER1yYAEBhVAhAmHQU2KCFnJgCxNxG3QSdxBxF3IWdYOjBJ9xhRAgFyCBAqGxdhGfA_
UYcRABqBIQchJ0FnMWcKH2D3AvBJ9xkJGiQQAfsIECmkFQALRyI_UYk3UAcRBzEH4xMQYcQUYPcB
8Er3E44MAEYHAH0CICtBQh1Q9xDwQFHQJAKJCyAHIaAcAIANAmALAA4XQPBL9xBsHTJB9w-qF9H3
KmEXQQdx9wnwQVFXaQYRJ9MEADcSAT0AEhE9AABKNJHwTPcJcQdBF2F6AaAHAfdC8Q9n8EtRaRwA
ZhgjB1F1ACIRF7MNITEnSg9U8FZn8Q80AGFD8HFRRxEKGxBhYgogNzE2AwL6EwCKGgDtCyPwfMJI
Yfc-8HdRNy4AISeBiQBAMRchB9wWBOMmAC4AMYL3BS4AoAcB9z0R8HhRNyGyABE3zAQRFz4DEVEd
ADEC8IOrPQQCAKD3KzGHUfB5QScxAEojJ4FuChGBDgkBLwAyUYcxKwAQB58DACAOUQPweVEHyRsh
F3EZABLBijMgB1HPG0WH8ITxmSch9yoHACIX4TMAAIIBAYgABQIAEiFlGREHwzUAJR5EhOEHAQIA
IPcsBwBR8QDwe6FHHALTAQwCAAOsAQBqAQCGORiGQQACfwBQB9HwfLGmFwMVAgwCAAQWABBBByxK
h-CH4YEAleHwfaEXEScBNwkBB78ABTwAAr8AKofRPABgAQfB8H6hthcBNRkM_wAIAgABwAA7l-CI
QgAT0UAAAIoVAU8QIwGncABsRxGH8InBcABxsfCAoRcRFycRMacxt5YBU0cBl-CKKgAi9y6WABKA
lgBQIdchx1HjEEKH8IuxIgAGTAAzofCBJgAAdw0g10FAGEiH8IyxSgBAsfCCkRwDQVchxyEiAFgB
l-CMoSIAYAEHkfCDoQgDMFch10YAEBFyFRKO9wEHJgBRgfCEkSfyEkDXEadxlS1Md-CPkSQAEYVu
AFFHUacBt5FMAPk7E5AcBSP3MCsFMfCGgQM7YSEnAacRlykgAMcZEZF0ACL3MkoAIIdhZAAAwx4w
twGHMEoRESQAFpFKAEGB8IhhTykCOTgBmzdEp-CTcUYAYZHwiUFXEdcCAIsbAPQGRpfwlIFBAEJx
8IsxNhFAF1HXMcIUAGECJpaBYQAxi0FXsApgJxEXIZdBPTZCd-CXkSAAQIHwjTHTFQBNBCA3sWUA
QufwmXEcADGR8I7TNSJHMeI2AI8NI-CZWQBRcfCOQVewJgBFBSE3AUwHQwHwm4EdACFhR5whAuMX
AN0AUvcC8JxhZgFAcfCOcfMtAfgBAKkTUAHH8J1hOQDwAWHwjZGHAadBdzF3IafwnXEuAOJh8I6h
dwHnkacxl-CeUToCQWHwjsFoGEUQIYcBFgBBQfCO4YQDMBH3D6QXABoAABgAEFEYAAKbBREPlAAA
tUxBnGH3KhsAALwPQidR9w4FEQIcADBB9ywaAAGcGQDfBkQhVzFHHgAQER8AESpuACDxAr8YQOcR
BzFWARMHAgBwFwHwm0H3KyAAEATKHGJHARfhNyH5EwQgAJAx9ypR8I3xBTd1AyLxBbhOAn0WMPCa
QQYFMzHwjZkCowdRJxFXURfxASftFAFrE3OZMfcpQfCMlwIEHQWCdyGHQRchlyESAFKHIfCYMU0A
FIzEBAUMBBAX6xkklzHrB38HIfCXMfcnLAACANsSEhH9CwIdBAIsAEEx8IyBhBEGJgAARgwCDQBQ
x0HwlyHDB1Uh8ItxtyIAIfcVUBEQ50ABEZa6B1Ih8IuBxx4AM0H3FOEAQudh8JYBCETwioHnHgAh
EhEJAGEB9wBx8JVICEQR8IqRgAgzUfcM_AAAiwLCgfCVAfcmIfCIkfcDFQAUYaIRACAAQQOR8JPV
HmIR8Iax9wIXAFWB9wYhFyIAAMMEII8RvApCIfCD0WELNbH3AV4GABAHseHwjBH3JCHwfPEFEDZX
B8FHURc-AQAkAHDxA-CIEfciawAhb-FuCzMBB-HKAAEkANIH8QrwghH3IyHwbfETaRMHYgYMAgDh
9wnxEPB7EfciIfBr8RUKRwBuIA8vAAeQAQfxFfB2EfcgggAyZvEXFAAPNQAL8gMLAQfxG-BvEfch
IfBb8QkX8Qg0AARLBw84AAVxDQEH8R7wa20AhAHwWvEJJ-EIcAAERgcPPAAF9gEPAQfxH-BqAfch
EfBY8Qk3OgAGQAcPOgADgBEBB-Ej8GcBdgBw8FfxCkfxCcIADgEHDDkA_AETARfxJfBk9x8BB-BV
8Q1HcwAPOgALAKAY1ynwYfcfAfBT8RA38QerIQN0DQwzAJAZAQfxLfBe9x4zABgSMwACdQcFKQAY
HWQBQPEc8F36ETDwUvGLFyHxCDQAJfc1UAHxAIcBB-EY8Fz3HfBR8QInwcAJNbEHgckAI-cztQH1
A6fxG-Bb9xsB8E-hBwFH4YdBB9IBJvcJKQDwAOfxHPBZ9xoBB-BO4QcBZ8kiJEEnKAAF7AwTKSwA
MB-wV1MAEE0nAEThtzFHJwBDhyH3I_IHhPcB8SDwVfcaJgAj5yEmABAPyxITIYsCMucBBycAMfBL
0dUAIcEHDjMSgRtTMTH3IRYDofcB8SPwU-cZ8EsjCEKn4fcJIgCBDFH3HQEH0Re7A4PxJPBS9xjw
SiQAArkAAigANgtBB6UEJAfh6wNj8STwUfcXMgAZxzIAIwpRIQED2AES8UlSkgXxJvBR9xbwSTMA
ArEAEQmQPgA_ABRB-wMGhgIS8QcABBcEVibwUPcVPwAY4T8AIQZRggAQF8cOAgIAAJAAsfEJB-EM
8FD3FPBINgAV5zYAEsHIABJh4wAx8QknFgACMAA2T-cTMAAEKwASCwcAEgJpCAGHAiDxBQgAAGwP
AA0AcQjwT-cS8Ec4AAo6ABLhoQUABgAFLAQSAwgAEsEkAAEsAIqB8E33EvBG0T8AAigAReEHAde6
BgN_AAE9BAH_ACUHoWwBE2FtCVFL9xLwRUsAJ-cBTAAC-QA2AQfhTgAFEwAXB1EAKgEHqQYTAVcA
b0r3EfBG4VcAAQGUACHRtwICJQcB_QAAUwADGAIPVwAKNRDwRVsCD1cADBUJrAAETQASoY0AMHHw
SUgAJPEARwAHSQABSwA0F8GnIwgDSQASwUcFJYGHRQBSYfBJ9w9FAAZHAAQVAQI4ADoPsZcRAAIi
ACH3EX8BCUsAHOc2LR8yNi0CVjExLjA1o56QLHpvb209MX19
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Iixtb2RpZmllZD0iMjAyNS0w
My0xMCAyMTozMDo1NSIsc3RvcmVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Il1d
:: map/
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Iixtb2RpZmllZD0iMjAyNS0w
My0xMCAyMTozMDo1NSIscmV2aXNpb249NTgzMF1dbHo0AGkAAABYEAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD--------------------78QgiKSxoaWRkZW49ZmFsc2UscGFuX3g9
MAgAwnk9MCx0aWxlX2g9OAkA4Hc9OCx6b29tPTAuNX19
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Iixtb2RpZmllZD0iMjAyNS0w
My0xMCAyMTozMDo1NSIsc3RvcmVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Il1d
:: pal/
:: pal/0.pal
b64$LS1bW3BvZCxiZ19jb2xvcj0wLGJsYWNrZXN0X2NvbG9yPTAsY3JlYXRlZD0iMjAyNS0wMy0x
MCAxMzo1NjoxNCIsaGlkZGVuPXtbMF09ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2V9LGhpZGRlbl90b2dnbGVzPXtbMF09ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2V9LGh1
ZV9tb2RlPSJodWUrbHVtIixpY29uPXVzZXJkYXRhKCJ1OCIsMTYsMTYsIjAwMDEwMTAxMDEwMTAx
MDEwMTAxMDEwMDAwMDAwMDAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNjAxMDAwMDAwMDAwMDAxMDcw
NzA3MDcwNzA3MDcwNzA2MDYwMTAwMDAwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDYwNjA2MDEwMDAw
MDAwMTA3MDcwNzA3MDcwNzA3MDcwNjA2MDYwNjAxMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3MDcw
NzA3MDEwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwMTAwMDAwMTA3MDcwNjA2MDEwMTBk
MGQwMTAxMDcwNzAxMDAwMDAxMDcwNzA2MDYwMTAxMGQwZDAxMDEwNzA3MDEwMDAwMDEwNzA3MDEw
MTA3MDcwNjA2MGQwZDA3MDcwMTAwMDAwMTA3MDcwMTAxMDcwNzA2MDYwZDBkMDcwNzAxMDAwMDAx
MDcwNzBkMGQwMTAxMGQwZDA2MDYwNzA3MDEwMDAwMDEwNzA3MGQwZDAxMDEwZDBkMDYwNjA3MDcw
MTAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzAxMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3
MDcwNzA3MDEwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAwIiksbG9ja2VkPXtbMF09
dHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLGZhbHNlLHRydWUsdHJ1ZSx0
cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1
ZSx0cnVlLGZhbHNlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2V9LG1vZGlmaWVkPSIyMDI1LTAzLTEwIDIxOjMwOjU1Iixva3BhbF92ZXJzaW9u
PSIxLjEuMSIscmV2aXNpb249NDc4LHRlc3RfY3ViZV9jb2xvcnM9e1swXT17MTUsMzEsNH0sezMx
LDQsMjB9LHs0LDIwLDIxfSx7MTAsOSwyNX0sezksMjUsMjR9LHs4LDI0LDJ9LHsyNiwxMSwyN30s
ezExLDI3LDN9LHsyNywzLDE5fSx7MjgsMTcsMTl9LHsyOCwxMiwxNn0sezEyLDE2LDF9LHs2LDI5
LDEzfSx7MjksMTMsMTh9LHsxMywxOCwxfSx7NywyMywxNH0sezIzLDE0LDEzfSx7MTQsMzAsMTh9
LHs3LDYsMjJ9LHs2LDIyLDV9LHsyMiw1LDIxfSx7MSwxLDF9LHsxLDEsMX0sezEsMSwxfX0sdGVz
dF9tb2RlPSJyYW1wcyIsdGVzdF9yYW1wX2NvbG9ycz11c2VyZGF0YSgidTgiLDEwLDI3LCIwMDE4
MDgxOTA5MGExYTBiMWIwMDA2MDAwMDAwMDAwMDAwMDAwMzAwMTYwMDAwMDAwMDAwMDAwMDEzMDAw
NTAwMDAwMDAwMDAwMDAwMDEwMDBkMDAwMDAwMDAwMDAwMDAxMDAwMWQwMDAwMDAwMDAwMDAwMDEx
MDAxNzAwMDAwMDAwMDAwMDAwMGMwMDBlMDAwMDAwMDAwMDAwMDAxYzAwMWUxMjAyMTUxNDA0MWYw
ZjA3MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTQwNDFmMGYwODE4MDIwMDAwMTUwNTE2MDYwNzE3
MGUxZTAwMDAwMTEwMTEwYzFjMWQwZDEyMDAwMDEzMDMxYjBiMWEwYTA5MTkwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAiKSx3aGl0ZXN0X2NvbG9yPTddXWx6NAAtAQAAFQIAAPUF
dXNlcmRhdGEoImkzMiIsNjQsIjABAMAxZDJiNTMwMDdlMjUIAPAfMDA4NzUxMDBhYjUyMzYwMDVm
NTc0ZjAwYzJjM2M3MDBmZmYxZTgwMGU4NDg1ZBAAEWE2AGBmZmVjMjcKACBlNDgA4DI5YWRmZjAw
ODM3NjljIABANzdhOAgAsGNjYWEwMDI0NjNiLwDwHjBhNWExMDA2NTQ2ODgwMDEyNTM1OTAwNzQy
ZjI5MDA0NTJkMzIwMGEyODg3OUAA8A1hY2M1MDBiMDI1NDMwMGUyNmIwMjAwOTVmMDQyUAAgYjLA
AKA2NGRmZjYwMGJkiQAAlgBAMGRhYkAAXzg1NTcwAQBuf2RkNDI4MTABAA51ODQ3NzNlMAEAfzQ3
NGNiZDABAClQMDAwIik=
:: pal/1.pal
b64$LS1bW3BvZCxiZ19jb2xvcj0wLGJsYWNrZXN0X2NvbG9yPTAsY3JlYXRlZD0iMjAyNS0wMy0x
MCAxNzo0NzozOCIsaGlkZGVuPXtbMF09ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2V9LGhpZGRlbl90b2dnbGVzPXtbMF09ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2V9LGh1
ZV9tb2RlPSJodWUrbHVtIixpY29uPXVzZXJkYXRhKCJ1OCIsMTYsMTYsIjAwMDEwMTAxMDEwMTAx
MDEwMTAxMDEwMDAwMDAwMDAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNjAxMDAwMDAwMDAwMDAxMDcw
NzA3MDcwNzA3MDcwNzA2MDYwMTAwMDAwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDYwNjA2MDEwMDAw
MDAwMTA3MDcwNzA3MDcwNzA3MDcwNjA2MDYwNjAxMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3MDcw
NzA3MDEwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwMTAwMDAwMTA3MDcwNjA2MDEwMTBk
MGQwMTAxMDcwNzAxMDAwMDAxMDcwNzA2MDYwMTAxMGQwZDAxMDEwNzA3MDEwMDAwMDEwNzA3MDEw
MTA3MDcwNjA2MGQwZDA3MDcwMTAwMDAwMTA3MDcwMTAxMDcwNzA2MDYwZDBkMDcwNzAxMDAwMDAx
MDcwNzBkMGQwMTAxMGQwZDA2MDYwNzA3MDEwMDAwMDEwNzA3MGQwZDAxMDEwZDBkMDYwNjA3MDcw
MTAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzAxMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3
MDcwNzA3MDEwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAwIiksbG9ja2VkPXtbMF09
dHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRy
dWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVl
LHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlfSxtb2RpZmllZD0iMjAyNS0wMy0xMCAxNzo1NTo0MCIsb2twYWxfdmVyc2lvbj0i
MS4xLjEiLHJldmlzaW9uPTEwLHRlc3RfY3ViZV9jb2xvcnM9e1swXT17MTUsMzEsNH0sezMxLDQs
MjB9LHs0LDIwLDIxfSx7MTAsOSwyNX0sezksMjUsMjR9LHs4LDI0LDJ9LHsyNiwxMSwyN30sezEx
LDI3LDN9LHsyNywzLDE5fSx7MjgsMTcsMTl9LHsyOCwxMiwxNn0sezEyLDE2LDF9LHs2LDI5LDEz
fSx7MjksMTMsMTh9LHsxMywxOCwxfSx7NywyMywxNH0sezIzLDE0LDEzfSx7MTQsMzAsMTh9LHs3
LDYsMjJ9LHs2LDIyLDV9LHsyMiw1LDIxfSx7MSwxLDF9LHsxLDEsMX0sezEsMSwxfX0sdGVzdF9t
b2RlPSJjdWJlcyIsdGVzdF9yYW1wX2NvbG9ycz11c2VyZGF0YSgidTgiLDEwLDI3LCIwMDE4MDgx
OTA5MGExYTBiMWIwMDA2MDAwMDAwMDAwMDAwMDAwMzAwMTYwMDAwMDAwMDAwMDAwMDEzMDAwNTAw
MDAwMDAwMDAwMDAwMDEwMDBkMDAwMDAwMDAwMDAwMDAxMDAwMWQwMDAwMDAwMDAwMDAwMDExMDAx
NzAwMDAwMDAwMDAwMDAwMGMwMDBlMDAwMDAwMDAwMDAwMDAxYzAwMWUxMjAyMTUxNDA0MWYwZjA3
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTQwNDFmMGYwODE4MDIwMDAwMTUwNTE2MDYwNzE3MGUx
ZTAwMDAwMTEwMTEwYzFjMWQwZDEyMDAwMDEzMDMxYjBiMWEwYTA5MTkwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAiKSx3aGl0ZXN0X2NvbG9yPTddXWx6NAASAQAAFQIAAPUFdXNl
cmRhdGEoImkzMiIsNjQsIjABAMAxZDJiNTMwMDdlMjUIAPAXMDA4NzUxMDBhYjUyMzYwMDVmNTc0
ZjAwYzJjM2M3MDBmZmYxZTgIAEAwMDRkCAARYTYAYGZmZWMyNwoAIGU0OABAMjlhZCQAYDgzNzY5
YyAAMTc3YTgAsGNjYWEwMDI0NjNiLwDwHjBhNWExMDA2NTQ2ODgwMDEyNTM1OTAwNzQyZjI5MDA0
NTJkMzIwMGEyODg3OUAA8A1hY2M1MDBiOTAwM2UwMGUyNmIwMjAwOTVmMDQyUAAgYjLAAKA2NGRm
ZjYwMGJkiQAAlgBAMGRhYkAA3zg1NTcwMDliYWYzOTABAOFQMDAwIik=
:: pal/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTEwIDEzOjU2OjE0Iixtb2RpZmllZD0iMjAyNS0w
My0xMCAyMTozMDo1NSJdXQ==
:: sfx/
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA3Iixtb2RpZmllZD0iMjAyNS0w
My0xMCAyMTozMDo1NSIscmV2aXNpb249NTc2NV1dbHo0ABEBAABSCAAA8CdweHUAAygAAAQABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDBAUGBwAP-5AICQoLDwwPDQ8ODw8QAPAADQ8RDxIPEw8UDxUP
Fg8XEwDxAQ8YDxkPGg8bDxwPHQ8eDx8UAPEAIA8hDyIPIw8kDyUPJg8nFADxACgPKQ8qDysPLA8t
Dy4PLxQA8QAwDzEPMg8zDzQPNQ82DzcUAP8FOA85DzoPOw88Dz0PPg8-AA--8P8BAOv-J1oBEAYP
IBABIAEgAfAAAhACDBABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDDAA-zkf-wEA
3L-4D0AADUD--7DwcAoA--9kH-8BAP_ZUP----8g
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Iixtb2RpZmllZD0iMjAyNS0w
My0xMCAyMTozMDo1NSIsc3RvcmVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Il1d
:: src/
:: src/files.lua
--[[pod_format="raw",created="2025-03-08 09:21:19",modified="2025-03-10 19:33:11",revision=344]]
-- Loading and saving -------------------------------------------------------------


function save_working_file()
	local ext = pwf():ext()
	if ext == "hex" or ext == "txt" then
		return save_hex_file()
	else
		if ext != "pal" then
			notify("unknown file extension: saved using default file format")
		end
		return save_pal_file()
	end
end


function load_working_file(data, metadata)
	
	if fstat(pwf()) ~= "file" then
		-- This is a new file
		create_metadata()
		is_new_file = true
		return
	end

	metadata = metadata or {}
	local ext = pwf():ext()
	if ext == "pal" then
		load_pal_file(data, metadata or {})
		if undo_stack then undo_stack:reset() end
		send_palette()

	elseif ext == "hex" or ext == "txt" then
		if metadata.okpal_version then
			current_import_choice = "overwrite"
			load_hex_file(data, metadata or {})
			if undo_stack then undo_stack:reset() end
			send_palette()
		else
			imported_hex_file = { data = data, metadata = metadata }
		end

	else
		notify("unkown file extension: OkPal can only load \".pal\" and \".hex\" palettes")
	end
end


-- Metadata ----------------------------------------------------------------------


function create_metadata()
	local metadata = {}
	metadata.okpal_version = okpal_version
	metadata.icon = userdata("u8",16,16,"0001010101010101010101000000000000010707070707070707060100000000000107070707070707070606010000000001070707070707070706060601000000010707070707070707060606060100000107070707070707070707070701000001070707070707070707070707010000010707060601010d0d01010707010000010707060601010d0d010107070100000107070101070706060d0d07070100000107070101070706060d0d07070100000107070d0d01010d0d060607070100000107070d0d01010d0d060607070100000107070707070707070707070701000001070707070707070707070707010000010101010101010101010101010100")
	metadata.bg_color = bg_color
	metadata.blackest_color = blackest_color
	metadata.whitest_color = whitest_color
	metadata.hidden_toggles = hidden_toggles
	metadata.hidden = copy(hidden)
	metadata.locked = copy(locked)
	metadata.hue_mode = hue_mode
	metadata.test_mode = test_mode
	metadata.test_cube_colors = copy(test_cube_colors)
	metadata.test_ramp_colors = test_ramp_colors and test_ramp_colors:convert("u8")
	return metadata
end


function load_metadata(metadata)
	metadata = metadata or {}
	bg_color = metadata.bg_color or 0
	blackest_color = metadata.blackest_color or 0
	whitest_color = metadata.whitest_color or 7
	
	if type(metadata.hidden_toggles) == "table" then
		hidden_toggles = metadata.hidden_toggles
	else
		hidden_toggles = {}
		for row = 0, 3 do
			hidden_toggles[row] = false
		end
	end
	
	if type(metadata.hidden) == "table" then
		hidden = metadata.hidden
	else
		hidden = {}
		for c = 0, 63 do
			hidden[c] = false
		end
	end
	
	if type(metadata.locked) == "table" then
		locked = metadata.locked
	elseif pwf() == "/ram/cart/pal/0.pal" then
		-- This only occurs when a default starting file
		-- is created.
		for c = 0, 63 do
			locked[c] = c <= 31
		end
	else
		locked = {}
		for c = 0, 63 do
			locked[c] = false
		end
	end

	if type(metadata.hue_mode) == "string" then
		hue_mode = metadata.hue_mode
	else
		hue_mode = "hue+lum"
	end

	if type(metadata.test_mode) == "string" then
		test_mode = metadata.test_mode
	else
		test_mode = "cubes"
	end

	if type(metadata.test_cube_colors) == "table" then
		test_cube_colors = copy(metadata.test_cube_colors)
	else
		test_cube_colors = copy(default_test_cube_colors)
	end
	
	if type(metadata.test_ramp_colors) == "userdata" then
		test_ramp_colors = metadata.test_ramp_colors:convert("u8")
	else
		test_ramp_colors = default_test_ramp_colors:convert("u8")
	end
end


-- Load and save pal files -------------------------------------------------------


function load_pal_file(data, metadata)
	if data then
		if type(data) == "userdata" and data:width() == 64 then
			for c = 0, 63 do
				if data[c] then
					set_color(c, data[c])
				end
			end
		else
			notify("unable to load working file")
			return
		end
	else
		-- New file
	end
	rebuild_pal()
	load_metadata(metadata)
end


function save_pal_file()
	local output = userdata("i32", 64)
	for c = 0, 63 do
		output:set(c, get_color(c))
	end
	return output, create_metadata()
end


-- Load and save hex files ---------------------------------------------------------


function load_hex_file(data, metadata)
	if type(data) == "string" then
		local lines = split(data, "\n", false)
		local codes = {}
		for l in all(lines) do
			local code = tonum("0x" .. l:gsub("%s",""))
			if type(code) == "number" then
				codes[#codes + 1] = code
			elseif code then
				notify("error importing hex file")
			end
		end
		local start = 0
		if current_import_choice == "dont_clobber" then
			-- TODO: put in separate function and add menu item
			for c = 0, 32 do
				set_color(c, peek4(0x5000 + 4 * (64 + c)))
			end
			start = 32
		end
		if #codes > 64 - start then
			notify("*** not enough space to import all the colors ***")
		end
		for c = start, 63 do
			if codes[c - start + 1] then
				set_color(c, codes[c - start + 1])
			else
				set_color(c, 0x000000)
			end
		end
		rebuild_pal()
	elseif data then
		notify("import hex file: unkown type: " .. type(data))
	end

	load_metadata(metadata)
	if current_import_choice == "dont_clobber" then
		active_color = nil
		for c = 0, 31 do
			hidden[c] = true
			locked[c] = true
		end
		hidden_toggles[0] = true
		hidden_toggles[1] = true
		blackest_color = 0
		whitest_color = 7
		bg_color = 0
	else
		local best_black, best_white = find_blackest_and_whitest()
		blackest_color = metadata.blackest_color or best_black
		whitest_color = metadata.whitest_color or best_white
		bg_color = metadata.bg_color or blackest_color
	end
end


function save_hex_file(filename)
	-- Don't export trailing black colors
	local fin = 63
	while fin > 0 and get_color(fin) == 0 do
		fin -= 1
	end
	
	local output = ""
	for c = 0, fin do
		output ..= color_to_hex(get_color(c)) .. "\n"
	end
	return output, create_metadata()
end

:: src/globals.lua
--[[pod_format="raw",created="2024-04-03 09:15:53",modified="2025-03-10 21:30:55",revision=3926]]
current_import_choice = "dont_clobber"

undo_stack = nil

padlock_flashing = false
padlock_flashing_time = 0

gui = nil
gui_changed = false

is_new_file = false
imported_hex_file = nil

blink_timer = 180 + math.random(1, 6) * 90
blink_eye = math.random(0, 3)
crying_a_timer = 0

help_current_line = 1


-- Saved in settings ----------------------------------------------------------


user_settings = {
	send_palette = true,
	dont_blink = false,
}


-- Saved in undo stack ----------------------------------------------------------


pal_okhsl = {}
pal_code = {}

-- and also `test_cube_colors`? or not?


-- Saved in metadata --------------------------------------------------------------


okpal_version = "1.1.1"

active_color = nil
bg_color = 0 -- TODO: what about fg?
blackest_color = 0 -- TODO: remove?
whitest_color = 7 -- TODO: remove?

hidden_toggles = { [0] = false, false, false, false }
hidden = {}
for i = 0, 63 do hidden[i] = false end
locked = {}
for i = 0, 63 do locked[i] = i <= 31 end

hue_mode = "hue+sat"

test_mode = "cubes"
test_cube_colors = nil
test_ramp_colors = nil


-- Constants ----------------------------------------------------------------------


default_test_cube_colors = {
	[0] = 
	{15, 31, 4},
	{31, 4, 20},
	{4, 20, 21},
	--
	{10, 9, 25},
	{9, 25, 24},
	{8, 24, 2},
	--
	{26, 11, 27},
	{11, 27, 3},
	{27, 3, 19},
	--
	{28, 17, 19},
	{28, 12, 16},
	{12, 16, 1},
	--
	{6, 29, 13},
	{29, 13, 18},
	{13, 18, 1},
	--
	{7, 23, 14},
	{23, 14, 13},
	{14, 30, 18},
	--
	{7, 6, 22},
	{6, 22, 5},
	{22, 5, 21},
	--
	{1, 1, 1},
	{1, 1, 1},
	{1, 1, 1},
	--
}

default_test_ramp_colors = userdata("u8", 10, 27, 0)
default_test_ramp_colors:set(
	0, 0,
	 0, 24,  8, 25,  9, 10, 26, 11, 27,  0,
	 6,  0,  0,  0,  0,  0,  0,  0,  3,  0, 
	22,  0,  0,  0,  0,  0,  0,  0, 19,  0, 
	 5,  0,  0,  0,  0,  0,  0,  0,  1,  0, 
	13,  0,  0,  0,  0,  0,  0,  0, 16,  0, 
	29,  0,  0,  0,  0,  0,  0,  0, 17,  0, 
	23,  0,  0,  0,  0,  0,  0,  0, 12,  0, 
	14,  0,  0,  0,  0,  0,  0,  0, 28,  0, 
	30, 18,  2, 21, 20,  4, 31, 15,  7,  0,
	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	 0, 20,  4, 31, 15,  8, 24,  2,  0,  0,
	21,  5, 22,  6,  7, 23, 14, 30,  0,  0,
	 1, 16, 17, 12, 28, 29, 13, 18,  0,  0,
	19,  3, 27, 11, 26, 10,  9, 25,  0,  0
)


:: src/gui.lua
--[[pod_format="raw",created="2024-03-31 05:58:06",modified="2025-03-10 21:30:55",revision=7378]]
function generate_gui()
	gui = create_gui()
	generate_palette_gui()
end


-----------------------------------------------------------------------------------


local modal = nil


function open_modal(width, height, autoclose)
	if modal ~= nil then
		--TODO: !!!
		return
	end
	
	modal = gui:attach {
		x = 0, y = 0,
		width = gui.width, height = gui.height,
		autoclose = autoclose or false,
		draw = function(self)
			poke(0x550b, 0x3f)
			---fillp(0b0101101001011010)
			---fillp(0b0001001001001000)
			---fillp(0b1110110110110111)
			fillp(0b0011011011001001)
			rectfill(0, 0, self.width - 1, self.height - 1, 61)
			fillp()
			poke(0x550b, 0x00)
		end,
		click = function(self, msg)
			if msg.has_pointer and self.autoclose then
				close_modal()
			end
		end
	}
	local el = modal:attach {
		x = (modal.width - width) // 2, y = (modal.height - height) // 2,
		width = width, height = height,
		draw = function(self)
			clip()
			rect(-3, -3, self.width+3, self.height+3, bg_color)
			rectfill(-2, -2, self.width+2, self.height+2, outline_color())
			rect(-1, -1, self.width+1, self.height+1, bg_color)
		end,
	}
	return el
end


function has_modal()
	return modal ~= nil
end


function close_modal()
	if modal then
		modal:detach()
	end
	modal = nil
end


-----------------------------------------------------------------------------------


function create_label(el)
	el.width = el.width or (5 * #el.label + 4)
	el.height = el.height or 9
	gui:new(el)
	function el:draw()
		print(self.label, 0, 0, self.fg or outline_color())
	end
	return el
end


-----------------------------------------------------------------------------------


function create_button(el)
	local label = el.label or "---"
	el.width = el.width or (#label * 5 + 8 + 8)
	el.height = el.height or 16
	el.cursor = "pointer"

	function el:draw(msg)
		local fg = self.fg or bg_color
		line(2, 0, self.width - 3, 0, fg)
		pset(1, 1, fg)
		line(2, self.height - 1, self.width - 3, self.height - 1, fg)
		pset(self.width - 2, 1, fg)
		line(0, 2, 0, self.height - 3, fg)
		pset(1, self.height - 2, fg)
		line(self.width - 1, 2, self.width - 1, self.height - 3, fg)
		pset(self.width - 2, self.height - 2, fg)
		local pressed = msg.has_pointer and self.clicked
		if pressed then
			rectfill(1, 1, self.width - 2, self.height - 2, fg)
		end
		print(self.label or "---", 9, 4, pressed and outline_color() or fg)
	end
	
	function el:click()
		self.clicked = true
	end
	
	function el:release(msg)
		self.clicked = false
		if (msg.has_pointer and self.act) self.act()
	end	

	return el
end


function create_action_button(el)
	local s = get_spr(el.sprite)
	el.width = s:width() or 16
	el.height = s:height() or 16
	el.cursor = "pointer"

	function el:draw(msg)
		pal(7, outline_color())
		local s = el.sprite
		if el.active and not el:active() then
			s += 2
		elseif el.clicked and msg.has_pointer then
			s += 1
		end
		spr(s, 0, 0)
		pal(7, 7)
	end
	
	function el:click()
		self.clicked = true
	end
	
	function el:release(msg)
		self.clicked = false
		if (msg.has_pointer and self.act) self.act()
	end	

	return el
end


-----------------------------------------------------------------------------------


function create_field(el)
	el.cursor = "pointer"

	function el:draw()
		local str = type(self.get == "function") and self:get() or "---"
		local fg = type(self.get_fg == "function") and self:get_fg() or outline_color()
		local prefix = self.small_font and "\014" or ""
		if self:has_keyboard_focus() then
			local suffix = (time() % 0.666 > 0.333) and "\016" or ""
			str =  self.str .. suffix
			print(prefix .. str, 1, 1, fg)
			clip()
			rect(-1, -1, self.width, self.height, fg)
		else
			local ww,hh = print(prefix .. str, 0, -1000)
			print(prefix .. str, self.width - ww - 1, 1, fg)
		end
	end

	function el:click()
		self:set_keyboard_focus(true)
		readtext(true)
		self.str = "" -- starting editing new string
	end

	el.custom_update = el.update
	function el:update()
		self:custom_update()
		if self:has_keyboard_focus() then
			while peektext() do
				self.str = self.str .. readtext()
			end
			if keyp("backspace") then
				self.str = sub(self.str, 1, -2)
			end
			if keyp("enter") then
				if type(self.set) == "function" then
					self:set(self.str)
				end
				self:set_keyboard_focus(false)
			end
		end
	end

--	gui:new(el)

	return el
end


-----------------------------------------------------------------------------------


function create_checkbox(el)
	el.width = el.width or (16 + 5 * #el.label + 4)
	el.height = el.height or 12
	el.cursor = "pointer"
	el.get = el.get or function(self) return self.checked end
	el.toggle = el.toggle or function(self) self.checked = not self.checked end
	gui:new(el)

	function el:draw()
		local fg = self.fg or outline_color()
		local checked = self:get()
		pal(7, fg)
		spr(checked and 49 or 48, 0, 0)
		pal(7)
		print(el.label, 16, 1, fg)
	end
	
	function el:release(msg)
		if msg.has_pointer then
			self:toggle()
		end
	end	

	return el
end


------------------------------------------------------------------------------


function create_radio_button(el)
	el.width = 188
	el.height = 12 -- TODO: count the lines?
	el.cursor = "pointer"
	
	function el:draw()
		local fg = self.fg or bg_color
		oval(0, 0, 8, 8, fg)
		local choices = self.parent.choices
		if choices and choices[self.group] == self.key then
			ovalfill(2, 2, 6, 6, fg)
		end
		print(el.label, 15, 1, fg)
	end
	
	function el:tap()
		if not self.parent.choices then
			self.parent.choices = {}
		end
		self.parent.choices[self.group] = self.key
	end
	
	return el
end


--------------------------------------------------------------------------------


function clear_cube_colors()
	for i = 0, #test_cube_colors - 1 do
		test_cube_colors[i] = { 1, 1, 1 }
	end
end


function clear_ramp_colors()
	for i = 0, test_ramp_colors:width()-1 do
		for j = 0, test_ramp_colors:height()-1 do
			test_ramp_colors:set(i, j, bg_color)
		end
	end
end


-- Utility functions ----------------------------------------------------------------


function outline_color()
	if pal_okhsl[bg_color].l < 0.5 then
		return whitest_color
	else
		return blackest_color
	end
end


function contrast_color(c)
	return (pal_okhsl[c].l < 0.5) and whitest_color or blackest_color
end


function sl_coords(c)
	local sat = pal_okhsl[c].s
	local lum = pal_okhsl[c].l
	local x = slider_border + sat * slider_inner
	local y = slider_border + slider_inner - lum * slider_inner
	return x, y
end


function coords_sl(x, y)
	local sat = (x - slider_border) / slider_inner
	local lum = 1.0 - ((y - slider_border) / slider_inner)
	return sat, lum
end


function hl_coords(c)
	local hue = pal_okhsl[c].h
	local lum = pal_okhsl[c].l
	local x = slider_border + hue * slider_inner * 2
	local y = slider_border + slider_inner - lum * slider_inner
	return x, y
end


function coords_hl(x, y)
	local hue = (x - slider_border) / (2 * slider_inner)
	local lum = 1.0 - ((y - slider_border) / slider_inner)
	return hue, lum
end


function s_coordsy(c)
	local sat = pal_okhsl[c].s
	local y = slider_border + slider_inner - sat * slider_inner
	return y
end


function coordsy_s(y)
	local sat = 1.0 - ((y - slider_border) / slider_inner)
	return sat
end


-- Remove 0.25 to compensate for Picotron's angle origin,
-- and 29/360 to compensate for OkLab weird position of
-- the red color.
local angle_correction = 0.25 + 0.08


function hs_coords(c)
	local hue = pal_okhsl[c].h
	local sat = mid(0.0, pal_okhsl[c].s, 1.0)
	local a = angle_correction - hue
	local dx = sat * cos(a) * (slider_inner / 2)
	local dy = sat * sin(a) * (slider_inner / 2)
	local x = slider_border + (slider_inner / 2) + dx
	local y = slider_border + (slider_inner / 2) + dy
	return x, y
end


function coords_hs(x, y)
	local dx = x - (slider_border + (slider_inner / 2))
	local dy = y - (slider_border + (slider_inner / 2))
	local hue = -atan2(dx, dy) + angle_correction
	dx = (2.0 * dx) / slider_inner
	dy = (2.0 * dy) / slider_inner
	local sat = sqrt(dx * dx + dy * dy) -- / (slider_inner / 2)
	return hue, sat
end


function h_coords(c, radius_delta)
	local s = slider_size + 2 * slider_border
	local r = s - slider_border + (radius_delta or 0)
	local hue = pal_okhsl[c].h
	local a = angle_correction - hue
	local dx = cos(a) * (r / 2)
	local dy = sin(a) * (r / 2)
	local x = (s / 2) + dx + 0.5
	local y = (s / 2) + dy + 0.5
	return x, y
end


function coords_h(x, y)
	local s = slider_size + 2 * slider_border
	local r = s - 6
	local dx = x - ((s / 2) + 0.5)
	local dy = y - ((s / 2) + 0.5)
	local hue = -atan2(dx, dy) + angle_correction
	dx = (2.0 * dx) / r
	dy = (2.0 * dy) / r
	local sat = sqrt(dx * dx + dy * dy)
	return hue, sat
end
:: src/gui_help.lua
--[[pod_format="raw",created="2025-03-07 10:21:37",modified="2025-03-07 17:37:27",revision=440]]
local text_view

function open_help()
	local el = open_modal(270, 250, true)
	if not el then
		return
	end
	text_view = el:attach(create_text_view { x = 10, y = 0, width = 250, height = 250 })
	text_view:set_text(fetch("manual.txt"))
end


function create_text_view(el)
	el.lines = {}

	function el:set_text(text)
		el.lines = soft_wrap(text, self.width)
	end

	function el:draw(msg)
		cursor(0, 0)
		color(bg_color)
		local l = help_current_line
		local y = 0
		while y < self.height do
			print(self.lines[l])
			y += 11
			l += 1
		end
	end
	
	function el:mousewheel(msg)
		local nb_lines = self.height // 11
		help_current_line = mid(
			1,
			help_current_line - (msg.wheel_y * 3),	
			#self.lines - nb_lines
		)
	end	

	return el
end
:: src/gui_hexdialog.lua
--[[pod_format="raw",created="2025-03-05 12:06:52",modified="2025-03-07 09:39:40",revision=249]]
function open_import_hex_file_dialog()
	local el = open_modal(180, 100, false)
	el:attach(create_label { x = 50, y = 6, label = "Import \".hex\" file", fg = bg_color })
	el:attach(create_radio_button {
		x = 16, y = 36, 
		label = "Import after Picotron's colors",
		group = "import_hex",
		key = "dont_clobber",
	})
	el:attach(create_radio_button {
		x = 16, y = 56, 
		label = "Replace all colors",
		group = "import_hex",
		key = "overwrite",
	})
	el.choices = { import_hex = "dont_clobber" }
	el:attach(create_button {
		x = 110, y = 80,
		label = "Import",
		act = function() prepare_imported_hex(el) end
	})
end


function prepare_imported_hex(dialog)
	current_import_choice = dialog.choices.import_hex
	load_hex_file(imported_hex_file.data, imported_hex_file.metadata or {})
	clear_cube_colors()
	clear_ramp_colors()
	if (undo_stack) undo_stack:reset()
	send_palette()
	imported_hex_file = nil
	close_modal()
end
:: src/gui_newfile.lua
--[[pod_format="raw",created="2025-03-05 08:57:06",modified="2025-03-05 12:06:43",revision=168]]
function open_new_file_dialog()
	local el = open_modal(180, 100, false)
	el:attach(create_label { x = 60, y = 6, label = "New Palette", fg = bg_color })
	el:attach(create_radio_button {
		x = 16, y = 36, 
		label = "Keep default colors",
		group = "new_palette",
		key = "keep_default",
	})
	el:attach(create_radio_button {
		x = 16, y = 56, 
		label = "Start with empty palette",
		group = "new_palette",
		key = "empty_palette",
	})
	el.choices = { new_palette = "keep_default" }
	el:attach(create_button {
		x = 110, y = 80,
		label = "Let's go!",
		act = function() prepare_new_file(el) end
	})
end


function prepare_new_file(dialog)
	if dialog.choices.new_palette == "empty_palette" then
		clear_colors()
	end
	close_modal()
end
:: src/gui_palette.lua
--[[pod_format="raw",created="2025-02-28 10:09:19",modified="2025-03-10 21:30:55",revision=2312]]
function generate_palette_gui()
	gui.tap = function(self, msg) if (msg.has_pointer) active_color = nil end
	local pal_el = create_palette{ x = 16, y = 6 }
	gui:attach(pal_el)
	gui:attach(create_visibility_buttons { x = pal_el.x - 14, y = pal_el.y + 1 })
	gui:attach(create_color_preview { x = pal_el.x + pal_el.width + 8, y = pal_el.y })
	gui:attach(create_test_zone { x = 390, y = 4 })
	if hue_mode == "hue+sat" then
		local h_slider = create_hue_slider{ x = 6, y = 68 }
		gui:attach(h_slider)
		h_slider:attach(create_hue_sat_slider { x = slider_border, y = slider_border })
		local sl_slider = create_sat_lum_slider{ x = 200 + 16, y = 66 }
		local s_slider = create_sat_slider { x = sl_slider.x, y = sl_slider.y + sl_slider.height }
		local l_slider = create_lum_slider { x = sl_slider.x - 16, y = sl_slider.y }
		gui:attach(s_slider)
		gui:attach(l_slider)
		gui:attach(sl_slider)
	elseif hue_mode == "hue+lum" then
		local hl_slider = create_hue_lum_slider{ x = 6 + 16, y = 66 }
		local h_slider = create_sat_slider { x = hl_slider.x, y = hl_slider.y + hl_slider.height }
		local l_slider = create_lum_slider { x = hl_slider.x - 16, y = hl_slider.y }
		gui:attach(h_slider)
		gui:attach(l_slider)
		gui:attach(hl_slider)
		local s_slider = create_vertical_sat_slider { x = 356, y = hl_slider.y }
		gui:attach(s_slider)
	end

	local x_buttons = 346
	gui:attach(create_action_button { x = x_buttons, y = 4, sprite = 16,
		act = function(self) undo_stack:undo() end,
		active = function(self) return #(undo_stack.undo_stack) >= 1 end })
	gui:attach(create_action_button { x = x_buttons + 16 + 2, y = 4, sprite = 19,
		act = function(self) undo_stack:redo() end,
		active = function(self) return #(undo_stack.redo_stack) >= 1 end })
	gui:attach(create_action_button { x = x_buttons, y = 4 + 16 + 2, sprite = 24,
		act = function(self) open_settings() end })
	gui:attach(create_action_button { x = x_buttons + 16 + 2, y = 4 + 16 + 2, sprite = 27,
		act = function(self) open_help() end })
	gui:attach(create_hue_mode_switch { x = 300, y = 54 })

end


-----------------------------------------------------------------------------------


function create_palette(el)
	local size = 12
	local nb_columns = 16
	local nb_rows = 4
	el.width = (nb_columns * size) + 1
	el.height = (nb_rows * size) + 1

	function el:draw(msg)
		clip()
		rect(0, 0, self.width, self.height, outline_color())
		for c = 0, 63 do
			local x = 1 + ((c % nb_columns) * size)
			local y = 1 + ((c \ nb_columns) * size)
			rectfill(x, y, x + size - 1, y + size - 1, c)
			if hidden[c] then
				ovalfill(
					x + 2, y + 2,
					x + size - 3, y + size - 3,
					0
				)
			end
			if c == active_color then
				rect(
					x + 1, y + 1,
					x + size - 2, y + size - 2,
					contrast_color(active_color)
				)
			end
		end	
		if self.drag_pos then
			local col = (msg.mx - 1) \ size
			local row = (msg.my - 1) \ size
			local c = col + row * nb_columns
			if 0 <= c and c <= 63 then
				local x = 1 + col * size
				local y = 1 + row * size
				if c != active_color and not locked[c] then
					oval(
						x + 2, y + 2,
						x + size - 3, y + size - 3,
						contrast_color(c)
					)
				end
			end
			local mx, my = self.drag_pos.x, self.drag_pos.y
			rectfill(mx, my, mx + 8, my + 8, active_color)		
		end
	end

	function el:click(msg)
		local col = min(nb_columns - 1, (msg.mx - 1) \ size)
		local row = min(nb_rows - 1, (msg.my - 1) \ size)
		local c = col + row * nb_columns
		if msg.mb == 1 then
			active_color = c
			self.click_pos = { x = msg.mx, y = msg.my }
		elseif msg.mb == 2 then
			hidden[c] = not hidden[c]
			if hidden[c] then
				local all_hidden = true
				for i = 0, nb_columns - 1 do
					if not hidden[(row * nb_columns) + i] then
						all_hidden = false
					end
				end
				if all_hidden then
					hidden_toggles[row] = true
				end
			else
				hidden_toggles[row] = false
			end
			dont_blink()
		end
	end	
	
	function el:drag(msg)
		if self.click_pos and not self.drag_pos then
			local dx = abs(self.click_pos.x - msg.mx)
			local dy = abs(self.click_pos.y - msg.my)
			if dx > 1 or dy > 1 then
				if locked[active_color] then
					padlock_flashing = true
				else
					self.drag_pos = {}
				end
			end
		end
		if self.drag_pos then
			self.drag_pos = { x = msg.mx, y = msg.my }
		end
	end
	
	function el:release(msg)
		if self.drag_pos then
			local col = (msg.mx - 1) \ size
			local row = (msg.my - 1) \ size
			local c = col + row * nb_columns
			if 0 <= c and c <= 63 and not locked[c] then
				undo_stack:checkpoint()
				swap_colors(active_color, c)
				active_color = c
				send_palette()
			end			
		end
		self.click_pos = nil
		self.drag_pos = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end

	return el
end


local blink_anim <const> = { [0] = 40, 41, 42, 43, 43, 43, 42, 41, 40 }


function create_visibility_buttons(el)
	local size = 12
	local nb_rows = 4
	el.width = size
	el.height = nb_rows * size
	el.cursor = "pointer"
	

	function el:draw(msg)
		pal(7, outline_color())
		for row = 0, 3 do
			if hidden_toggles[row] then
				spr(43, 0, row * size)
			else
				local sprite = 40
				if blink_timer <= 0 and blink_eye == row then
					sprite = blink_anim[- blink_timer] 
				end
				spr(sprite, 0, row * size)
			end
		end
		pal(7, 7)
	end
	
	function el:update(msg)
		if not user_settings.dont_blink then
			blink_timer -= 1
			if blink_timer <= -9 then
				blink_timer = 180 + math.random(1, 6) * 90
				local nb_eyes = active_color and 4 or 3
				blink_eye = math.random(0, nb_eyes)
				if hidden_toggles[blink_eye] then
					blink_eye = math.random(0, nb_eyes)
				end
			end
		end
	end
	
	function el:tap(msg)
		local row = mid(0, msg.my \ size, 3)
		hidden_toggles[row] = not hidden_toggles[row]
		for c = row * 16, row * 16 + 15 do
			hidden[c] = hidden_toggles[row]
		end
		dont_blink()
	end
	
	return el
end


function dont_blink()
	local all_eyes_closed = true
	for i = 0, 3 do
		if not hidden_toggles[i] then all_eyes_closed = false end
	end
	if all_eyes_closed then
		crying_a_timer = 40
	end
end


function blinked()
	if user_settings.dont_blink then
		return
	end
	pal(1, 0)
	if crying_a_timer > 20 then
		spr(254, 0, 0)
	elseif crying_a_timer > 0 then
		spr(255, 0, -16)
	end
	pal(1, 1)
end


------------------------------------------------------------------------------


function create_color_preview(el)
	local size = 12
	el.width = size * 4 + 2 + 120
	el.height = size * 4 + 2
	
	function el:draw(msg)
		if active_color then
			---rect(0, 0, self.height - 1, self.height - 1, 0)
			rectfill(1, 1, self.height - 2, self.height - 2, active_color)
			print(string.format("%d", active_color), 4, 4, contrast_color(active_color))
			local c = get_color(active_color)
--			print("#" .. color_to_hex(c), 7, self.height - 10, contrast_color(active_color))
			pal(7, outline_color())
			if locked[active_color] then
				if padlock_flashing_time % 18 < 10 then
					spr(2, self.height + 4, 1)
				end
			else
				spr(1, self.height + 4, 1)
			end
			if hidden[active_color] then
				spr(43, self.height + 4 + size, 1)
			else
				local sprite = 40
				if blink_timer <= 0 and blink_eye == 4 then
					sprite = blink_anim[- blink_timer] 
				end
				spr(sprite, self.height + 4 + size, 1)
			end
			if bg_color == active_color then
				spr(10, self.height + 4 + 2 * size, 1)
			else
				spr(9, self.height + 4 + 2 * size, 1)
			end
			pal(7, 7)
			local hue = pal_okhsl[active_color].h * 360.0
			while hue < 0.0 do
				hue += 360.0
			end
			print("\014       hue: ", self.height + 5, 18, outline_color()) -- .. string.format("%3.0f", hue) .. "\031", self.height + 5, 24, outline_color())
			print("\014saturation: ", self.height + 5, 27) -- .. string.format("%3.0f", pal_okhsl[active_color].s * 100.0) .. "%", self.height + 5, 33)
			print("\014 luminance: ", self.height + 5, 36) -- .. string.format("%3.0f", pal_okhsl[active_color].l * 100.0) .. "%", self.height + 5, 42)
		else
			print("\^pOkPal" .. "\^-p\014\|o " .. okpal_version, 24, 0, outline_color())
			print("\014\|b\-g(press f1 for help)")
		end
	end
	
	function el:tap(msg)
		if (not active_color) return
		if msg.mx < self.height or msg.my > size then
			return
		elseif msg.mx < self.height + 4 + size then
			locked[active_color] = not locked[active_color]
		elseif msg.mx < self.height + 4 + 2 * size then
			hidden[active_color] = not hidden[active_color]
		elseif msg.mx < self.height + 4 + 3 * size then
			if key("shift") and bg_color != active_color then
				whitest_color = active_color
			elseif key("ctrl") then
				blackest_color = active_color
			elseif bg_color == active_color then
				bg_color = blackest_color
			else
				bg_color = active_color
			end
		end
	end
	
	function el:hover(msg)
		if msg.has_pointer and msg.mx >= self.height + 4 and msg.mx <= self.height + 4 + 3 * size and msg.my <= size then
			self.cursor = "pointer"
		else
			self.cursor = 1
		end
	end

	gui:new(el)
	
	-- Input field for the color code
	el:attach(create_field {
		x = 5, y = el.height - 12,
		width = 40, height = 9,
		small_font = false,
		get_fg = function(self) return contrast_color(active_color or 0) end,
		get = function(self)
			if (not active_color) return ""
			return "#" .. color_to_hex(get_color(active_color))
		end,
		set = function(self, str)
			if (locked[active_color]) return
			str = str:gsub("%s", ""):gsub("#", "")
			if (#str ~= 6) return
			local code = tonum("0x" .. str)
			if (type(code) ~= "number") return
			undo_stack:checkpoint()
			change_color_code(active_color, code)
		end,
		update = function(self, msg)
			self.hidden = active_color == nil
		end
	})

	-- Input field for hue
	el:attach(create_field {
		x = 100, y = 17,
		width = 20, height = 7,
		small_font = true,
		get_fg = function(self) return outline_color() end,
		get = function(self)
			if (not active_color) return ""
			local hue = pal_okhsl[active_color].h * 360.0
			while hue < 0.0 do
				hue += 360.0
			end
			return string.format("%3.0f\031", hue)
		end,
		set = function(self, str)
			if (locked[active_color]) return
			str = str:gsub("%s", ""):gsub("\031", "")
			local hue = tonum(str)
			if (type(hue) ~= "number") return
			hue = (hue % 360.0) / 360.0
			undo_stack:checkpoint()
			change_color(active_color, hue, nil, nil)
		end,
		update = function(self, msg)
			self.hidden = active_color == nil
		end
	})

	-- Input field for saturation
	el:attach(create_field {
		x = 100, y = 26,
		width = 20, height = 7,
		small_font = true,
		get_fg = function(self) return outline_color() end,
		get = function(self)
			if (not active_color) return ""
			local sat = pal_okhsl[active_color].s * 100.0
			return string.format("%3.0f%%", sat)
		end,
		set = function(self, str)
			if (locked[active_color]) return
			str = str:gsub("%s", ""):gsub("%%", "")
			local sat = tonum(str)
			if (type(sat) ~= "number") return
			sat = sat / 100.0
			undo_stack:checkpoint()
			change_color(active_color, nil, sat, nil)
		end,
		update = function(self, msg)
			self.hidden = active_color == nil
		end
	})

	-- Input field for luminance
	el:attach(create_field {
		x = 100, y = 35,
		width = 20, height = 7,
		small_font = true,
		get_fg = function(self) return outline_color() end,
		get = function(self)
			if (not active_color) return ""
			local lum = pal_okhsl[active_color].l * 100.0
			return string.format("%3.0f%%", lum)
		end,
		set = function(self, str)
			if (locked[active_color]) return
			str = str:gsub("%s", ""):gsub("%%", "")
			local lum = tonum(str)
			if (type(lum) ~= "number") return
			lum = lum / 100.0
			undo_stack:checkpoint()
			change_color(active_color, nil, nil, lum)
		end,
		update = function(self, msg)
			self.hidden = active_color == nil
		end
	})
	
	return el
end


---------------------------------------------------------------------------------


function create_hue_mode_switch(el)
	el.width = get_spr(38):width()
	el.height = get_spr(38):height()
	el.cursor = "pointer"
	function el:draw(msg)
		pal(7, outline_color())
		spr(hue_mode == "hue+sat" and 38 or 39, 0, 0)
		pal(7)
	end
	function el:tap(msg)
		if hue_mode == "hue+sat" then
			hue_mode = "hue+lum"
		else
			hue_mode = "hue+sat"
		end
		gui_changed = true
	end
	return el
end


---------------------------------------------------------------------------------


function create_test_zone(el)
	el.width = (24 + 4) * 3
	el.height = 12 + (24 + 4) * 8 + 15
	el.cursor = "pointer"
	el.cubes = {}
	el.ramps = nil

	function el:draw()
		pal(7, outline_color())
		if test_mode == "cubes" then
			spr(34, 0, 0)
		elseif test_mode == "ramps" then
			spr(35, 0, 0)
		end
		pal(7, 7)
	end
	
	function el:click(msg)
		if msg.my > 12 then
			return
		end
		if test_mode == "cubes" and msg.mx > 33 then
			test_mode = "ramps"
			for c in all(self.cubes) do
				c.hidden = true
			end
			self.ramps.hidden = false
		elseif test_mode == "ramps" and msg.mx < 33 then
			test_mode = "cubes"
			for c in all(self.cubes) do
				c.hidden = false
			end
			self.ramps.hidden = true
		end
	end
	
	function el:mousewheel(msg)
		if active_color and msg.wheel_y < 0 then
			active_color = (active_color + 1) % 64
		elseif active_color and msg.wheel_y > 0 then
			active_color = (active_color - 1) % 64
		end
	end
	
	gui:new(el)
	
	for i = 0, 2 do
		for j = 0, 7 do
			el.cubes[#el.cubes + 1] =
				el:attach(create_test_cube { x = i * 28, y = 12 + j * 28, test_id = i + 3 * j })
		end
	end
	
	el.ramps = el:attach(create_test_ramps { x = 0, y = 12, hidden = test_mode ~= "ramps" })

	el:attach(create_action_button { x = 54, y = 238, sprite = 32,
		act =
			function(self)
				undo_stack:checkpoint()
				if test_mode == "cubes" then
					clear_cube_colors()
				elseif test_mode == "ramps" then
					clear_ramp_colors()
				end
			end })

	return el
end


function create_test_cube(el)
	el.width = 24 + 4
	el.height = 24 + 4
	el.hidden = test_mode ~= "cubes"

	function el:draw()
		local colors = test_cube_colors[self.test_id]
		pal(10, colors[1])
		pal(9, colors[2])
		pal(25, colors[3])
		spr(8, 2, 2)
		pal(10, 10)
		pal(9, 9)
		pal(25, 25)
	end
	
	function el:hover(msg)
		if msg.mx > 2 and msg.my > 2 and msg.mx < self.width - 2 and msg.my < self.height - 2 then
			el.cursor = "crosshair"
		else
			el.cursor = 1
		end
	end
	
	function el:click(msg)
		local face = 2
		if msg.mx > self.width - 10 or msg.my < 10 then
			if msg.mx > self.height - msg.my then
				face = 3
			else
				face = 1
			end
		end
		if msg.mb == 1 then
			undo_stack:checkpoint()
			test_cube_colors[self.test_id][face] = active_color or 1
		elseif msg.mb == 2 then
			active_color = test_cube_colors[self.test_id][face]
		end
	end
	
	return el
end


function create_test_ramps(el)
	el.width = (24 + 4) * 3
	el.height = (24 + 4) * 8
	
	function el:square_of(x, y)
		if x < 2 or x > self.width - 2 or y <= 4 or y >= self.height - 4 then
			return nil, nil
		end
		local i = mid(0, (x - 2) // 8, 9)
		local j = mid(0, (y - 4) // 8, 26)
		return i, j
	end

	function el:draw(msg)
--		rectfill(0, 0, self.width, self.height, 8)
		for i = 0, 9 do
			for j = 0, 26 do
				local x = 2 + i * 8
				local y = 4 + j * 8
				local c = test_ramp_colors:get(i, j)
				rectfill(x, y, x + 7, y + 7, c)
			end
		end
		local i, j = self:square_of(msg.mx, msg.my)
		if i then
			local x = 2 + i * 8
			local y = 4 + j * 8
			local c = test_ramp_colors:get(i, j)
			if c == 0 then
				rect(x, y, x + 7, y + 7, contrast_color(c))
			end
		end
	end
	
	function el:hover(msg)
		local i, j = self:square_of(msg.mx, msg.my)
		if i then
			el.cursor = "crosshair"
		else
			el.cursor = 1
		end
	end
	
	function el:click(msg)
		local  i, j = self:square_of(msg.mx, msg.my)
		if (not i) return
		if msg.mb == 1 then
			undo_stack:checkpoint()
			test_ramp_colors:set(i, j, active_color)
		elseif msg.mb == 2 then
			active_color = mid(0, test_ramp_colors:get(i, j), 63)
		elseif msg.mb == 4 then
			test_ramp_colors:set(i, j, 0)
		end
	end

	return el
end
:: src/gui_settings.lua
--[[pod_format="raw",created="2025-02-28 11:31:28",modified="2025-03-10 15:52:22",revision=1239]]
function open_settings()
	local el = open_modal(220, 170, true)
	el:attach(create_label { x = 90, y = 6, label = "Settings", fg = bg_color })
	
	local default_apps = get_default_apps()
	el:attach(create_label {
		x = 10, y = 30,
		label = "Default apps for \".pal\" and \".hex\" files:",
		fg = bg_color,
	})
	local pal_path = el:attach(create_label {
		x = 50, y = 50, width = 220 - 50,
		label = "pal: " .. default_apps.pal,
		fg = bg_color,
	})
	el:attach(create_button {
		x = 16, y = 46,
		label = "set",
		fg = bg_color,
		act =
			function(self)
				set_default_apps("pal")
				pal_path.label = "pal: set to " .. env().argv[0]
			end
	})
	local hex_path = el:attach(create_label {
		x = 50, y = 70, width = 220 - 50,
		label = "hex: " .. default_apps.hex,
		fg = bg_color,
	})
	el:attach(create_button {
		x = 16, y = 66,
		label = "set",
		fg = bg_color,
		act =
			function(self)
				set_default_apps("hex")
				hex_path.label = "hex: set to " .. env().argv[0]
			end
	})
	
	el:attach(create_checkbox {
		x = 10, y = 100,
		label = "Send palette to sprite and map editors",
		fg = bg_color,
		get = function(self) return user_settings.send_palette end,
		toggle = function(self) change_settings { send_palette = not user_settings.send_palette } end,
	})
	if key("shift") then
		el:attach(create_checkbox {
			x = 10, y = 120,
			label = "Don't blink!",
			fg = bg_color,
			get = function(self) return user_settings.dont_blink end,
			toggle = function(self) change_settings { dont_blink = not user_settings.dont_blink } end,
		})
	end
	
	el:attach(create_button {
		x = 170, y = 150,
		label = "Close",
		fg = bg_color,
		act = function() close_modal() end,
	})
end
:: src/gui_sliders.lua
--[[pod_format="raw",created="2024-04-05 07:49:07",modified="2025-03-10 21:30:55",revision=2096]]
slider_size = 170
slider_border = 6
slider_inner = slider_size - 2 * slider_border


-- Hue / saturation slider ----------------------------------------------------------


function create_hue_sat_slider(el)
	el.width = slider_size
	el.height = slider_size
	el.drag_delta = nil
	
	function el:draw()
		clip()
		oval(
			slider_border - 1, slider_border - 1,
			slider_border + slider_inner + 1, slider_border + slider_inner + 1,
			outline_color()
		)
		fillp(0b0101101001011010)
		rectfill(slider_size \ 2 - 24, slider_size \ 2, slider_size \ 2 + 24, slider_size \ 2, 7)
		rectfill(slider_size \ 2, slider_size \ 2 - 24, slider_size \ 2, slider_size \ 2 + 24, 7)
		fillp()
		for c = 0, 63 do
			if not hidden[c] and pal_okhsl[c].l != 0 then
				local x, y = hs_coords(c)
				ovalfill(x - 3, y - 3, x + 3, y + 3, c)
			end
		end
		if active_color and not hidden[active_color] then
			local x, y = hs_coords(active_color)
			pal(7, whitest_color)
			pal(14, active_color)
			spr(
				self.drag_delta and 12 or 11,
				x - 5, y - 5,
				x + 5, y + 5
			)
			pal(14, 14)
			pal(7, 7)
		end
		pal(7, outline_color())
		spr(13, -6, 120)
		pal(7, 7)
	end	
	
	function el:hover(msg)
		if (not msg.mx or not msg.my) return false
		local _, r = coords_hs(msg.mx, msg.my)
		if r > 1.02 then
			return false
		end
		if active_color and not hidden[active_color] then
			local ax, ay = hs_coords(active_color)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx <= 5 and dy <= 5 then
				self.cursor = "grab"
			else
				self.cursor = 1
			end
		end
		return true
	end
	
	function el:click(msg)
		local _, r = coords_hs(msg.mx, msg.my)
		if r > 1.02 then
			return false
		end
		if active_color and not hidden[active_color] then
			local ax, ay = hs_coords(active_color)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx <= 5 and dy <= 5 then
				undo_stack:checkpoint()
				self.drag_delta = { x = ax - msg.mx, y = ay - msg.my }
				return true
			end
		end
		active_color = nil
		-- In reverse order to prioritize colors on top
		for c = 63, 0, -1 do
			local cx, cy = hs_coords(c)
			local dx = abs(cx - msg.mx)
			local dy = abs(cy - msg.my)
			if dx <= 3 and dy <= 3 and not hidden[c] and pal_okhsl[c].l != 0 then
				undo_stack:checkpoint()
				active_color = c
				self.drag_delta = { x = cx - msg.mx, y = cy - msg.my }
				self.cursor = "grab"
				return true
			end
		end
		self.drag_delta = nil
		return true
	end
	
	function el:drag(msg)
		if (not active_color) return
		if (not self.drag_delta) return
		if locked[active_color] then
			padlock_flashing = true
		else
			local ax = msg.mx + self.drag_delta.x
			local ay = msg.my + self.drag_delta.y
			local hue, sat = coords_hs(ax, ay)
			change_color(active_color, hue, sat, nil)
			return true
		end
	end
	
	function el:release(msg)
		send_palette()
		self.drag_delta = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end

	return el
end


------------------------------------------------------------------------------------


function create_hue_lum_slider(el)
	el.width = slider_size * 2
	el.height = slider_size
	el.drag_delta = nil
		
	function el:draw()
		clip()
		rect(
			slider_border - 1, slider_border - 1, 
			slider_border + (slider_inner * 2) + 1, slider_border + slider_inner + 1, 
			outline_color()
		)
		for c = 0, 63 do
			if not hidden[c] and pal_okhsl[c].l != 0 then
				local x, y = hl_coords(c)
				ovalfill(x - 3, y - 3, x + 3, y + 3, c)
			end
		end
		if active_color and not hidden[active_color] then
			local x, y = hl_coords(active_color)
			pal(7, whitest_color)
			pal(14, active_color)
			spr(
				self.drag_delta and 12 or 11,
				x - 5, y - 5,
				x + 5, y + 5
			)
			pal(14, 14)
			pal(7, 7)
		end
		pal(7, outline_color())
		spr(15, -22, 128)
		pal(7, 7)
	end	
	
	function el:hover(msg)
		if active_color and not hidden[active_color] then
			local ax, ay = hl_coords(active_color)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx < 6 and dy < 6 then
				self.cursor = "grab"
			else
				self.cursor = 1
			end
		end
	end
	
	function el:click(msg)
		if active_color and not hidden[active_color] then
			local ax, ay = hl_coords(active_color)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx < 6 and dy < 6 then
				undo_stack:checkpoint()
				self.drag_delta = { x = ax - msg.mx, y = ay - msg.my }
				return
			end
		end
		active_color = nil
		-- In reverse order to prioritize colors on top
		for c = 63, 0, -1 do
			local cx, cy = hl_coords(c)
			local dx = abs(cx - msg.mx)
			local dy = abs(cy - msg.my)
			if dx < 3 and dy < 3 and not hidden[c] and pal_okhsl[c].l != 0 then
				undo_stack:checkpoint()
				active_color = c
				self.drag_delta = { x = cx - msg.mx, y = cy - msg.my }
				self.cursor = "grab"
				return
			end
		end
		self.drag_delta = nil
	end
	
	function el:drag(msg)
		if (not active_color) return
		if (not self.drag_delta) return
		if locked[active_color] then
			padlock_flashing = true
		else
			local ax = msg.mx + self.drag_delta.x
			local ay = msg.my + self.drag_delta.y
			local hue, lum = coords_hl(ax, ay)
			hue = max(0.0, hue)
			change_color(active_color, hue, nil, lum)
		end
	end
	
	function el:release(msg)
		send_palette()
		self.drag_delta = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end

	return el
end


-- Saturation / luminance slider ----------------------------------------------------


function create_sat_lum_slider(el)
	el.width = slider_size
	el.height = slider_size
	el.drag_delta = nil
		
	function el:draw()
		clip()
		rect(
			slider_border - 1, slider_border - 1, 
			slider_border + slider_inner + 1, slider_border + slider_inner + 1, 
			outline_color()
		)
		for c = 0, 63 do
			if not hidden[c] and pal_okhsl[c].l != 0 then
				local x, y = sl_coords(c)
				ovalfill(x - 3, y - 3, x + 3, y + 3, c)
			end
		end
		if active_color and not hidden[active_color] then
			local x, y = sl_coords(active_color)
			pal(7, whitest_color)
			pal(14, active_color)
			spr(
				self.drag_delta and 12 or 11,
				x - 5, y - 5,
				x + 5, y + 5
			)
			pal(14, 14)
			pal(7, 7)
		end
		pal(7, outline_color())
		spr(14, -22, 128)
		pal(7, 7)
	end	
	
	function el:hover(msg)
		if active_color and not hidden[active_color] then
			local ax, ay = sl_coords(active_color)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx < 6 and dy < 6 then
				self.cursor = "grab"
			else
				self.cursor = 1
			end
		end
	end
	
	function el:click(msg)
		if active_color and not hidden[active_color] then
			local ax, ay = sl_coords(active_color)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx < 6 and dy < 6 then
				undo_stack:checkpoint()
				self.drag_delta = { x = ax - msg.mx, y = ay - msg.my }
				return
			end
		end
		active_color = nil
		-- In reverse order to prioritize colors on top
		for c = 63, 0, -1 do
			local cx, cy = sl_coords(c)
			local dx = abs(cx - msg.mx)
			local dy = abs(cy - msg.my)
			if dx < 3 and dy < 3 and not hidden[c] and pal_okhsl[c].l != 0 then
				undo_stack:checkpoint()
				active_color = c
				self.drag_delta = { x = cx - msg.mx, y = cy - msg.my }
				self.cursor = "grab"
				return
			end
		end
		self.drag_delta = nil
	end
	
	function el:drag(msg)
		if (not active_color) return
		if (not self.drag_delta) return
		if locked[active_color] then
			padlock_flashing = true
		else
			local ax = msg.mx + self.drag_delta.x
			local ay = msg.my + self.drag_delta.y
			local sat, lum = coords_sl(ax, ay)
			change_color(active_color, nil, sat, lum)
		end
	end
	
	function el:release(msg)
		send_palette()
		self.drag_delta = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end

	return el
end


-- 1D Sliders ----------------------------------------------------------------------


function create_hue_slider(el)
	el.width = slider_size + 2 * slider_border
	el.height = slider_size + 2 * slider_border

	function el:draw()
		clip()
		for c = 0, 63 do
			if not hidden[c] and pal_okhsl[c].l != 0 then
				cx1, cy1 = h_coords(c, -2)
				cx2, cy2 = h_coords(c, 18)
				line(cx1, cy1, cx2, cy2, c)
			end
		end
		if active_color and not hidden[active_color] then
			local ax, ay = h_coords(active_color)
			pal(7, outline_color())
			pal(13, active_color)
			spr(7, ax - 4, ay - 4)
			pal(13, 13)
			pal(7, 7)
		end
	end	

	function el:hover(msg)
		-- I think there is a bug in Picotron's handling of mouse coords
		-- when one widget is on top of another.
		--[[
		if (not msg.mx or not msg.my) return
		if active_color then
			local ax, ay = h_coords(active_color)
			--printh(string.format("%.0f %.0f - %.0f %.0f", ax, ay, msg.mx, msg.my))
			if
				msg.mx >= ax - 6 and msg.mx <= ax + 6
				and msg.my >= ay - 6 and msg.my <= ay + 6
			then
				self.cursor = "grab"
			else
				self.cursor = 1
			end
		end
		--]]
	end

	function el:click(msg)
		undo_stack:checkpoint()
		if active_color and not hidden[active_color] then
			local ax, ay = h_coords(active_color)
			--[[
			if
				msg.mx >= ax - 6 and msg.mx <= ax + 6
				and msg.my >= ay - 6 and msg.my <= ay + 6
			then
			]]
				self.drag_delta = { x = ax - msg.mx, y = ay - msg.my }
			-- end
		end
	end
	
	function el:drag(msg)
		if (not active_color) return
		if (not self.drag_delta) return
		if locked[active_color] then
			padlock_flashing = true
		else
			local ax = msg.mx + self.drag_delta.x
			local ay = msg.my + self.drag_delta.y
			local hue = coords_h(ax, ay)
			change_color(active_color, hue, nil, nil)
		end
	end
	
	function el:release(msg)
		send_palette()
		self.drag_delta = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end

	return el
end


function create_sat_slider(el)
	el.width = slider_size
	el.height = 16
	
	function el:draw()
		clip()
		for c = 0, 63 do
			if not hidden[c] and pal_okhsl[c].l != 0 then
				local ax, _ = sl_coords(c)
				line(ax, 0, ax, self.height - 9, c)
			end
		end
		if active_color and not hidden[active_color] then
			local ax, _ = sl_coords(active_color)
			pal(7, outline_color())
			pal(13, active_color)
			spr(5, ax - 4, self.height - 9)
			pal(13, 13)
			pal(7, 7)
		end
	end	
	
	function el:hover(msg)
		if active_color and not hidden[active_color] then
			local ax, _ = sl_coords(active_color)
			if msg.mx and msg.mx >= ax - 4 and msg.mx <= ax + 4 and msg.my >= self.height - 9 then
				self.cursor = "grab"
			else
				self.cursor = 1
			end
		end
	end

	function el:click(msg)
		undo_stack:checkpoint()
		if active_color and not hidden[active_color] then
			local ax, _ = sl_coords(active_color)
			if msg.mx and msg.mx >= ax - 4 and msg.mx <= ax + 4 and msg.my >= self.height - 9 then
				self.drag_delta_x = ax - msg.mx
			end
		end
	end
	
	function el:drag(msg)
		if (not active_color) return
		if (not self.drag_delta_x) return
		if locked[active_color] then
			padlock_flashing = true
		else
			local ax = msg.mx + self.drag_delta_x
			local sat, lum = coords_sl(ax, 0)
			change_color(active_color, nil, sat, nil)
		end
	end
	
	function el:release(msg)
		send_palette()
		self.drag_delta_x = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end
			
	return el
end


function create_lum_slider(el)
	el.width = 16
	el.height = slider_size
	
	function el:draw()
		clip()
		for c = 0, 63 do
			if not hidden[c] and pal_okhsl[c].l != 0 then
				local _, ay = sl_coords(c)
				line(9, ay, self.width, ay, c)
			end
		end
		if active_color and not hidden[active_color] then
			local _, ay = sl_coords(active_color)
			pal(7, outline_color())
			pal(13, active_color)
			spr(6, 0, ay - 4)
			pal(13, 13)
			pal(7, 7)
		end
	end	
	
	function el:hover(msg)
		if active_color and not hidden[active_color] then
			local _, ay = sl_coords(active_color)
			if msg.my and msg.my >= ay - 4 and msg.my <= ay + 4 and msg.mx <= 9 then
				self.cursor = "grab"
			else
				self.cursor = 1
			end
		end
	end

	function el:click(msg)
		undo_stack:checkpoint()
		if active_color and not hidden[active_color] then
			local _, ay = sl_coords(active_color)
			if msg.my and msg.my >= ay - 4 and msg.my <= ay + 4 and msg.mx <= 9 then
				self.drag_delta_y = ay - msg.my
			end
		end
	end
	
	function el:drag(msg)
		if (not active_color) return
		if (not self.drag_delta_y) return
		if locked[active_color] then
			padlock_flashing = true
		else
			local ay = msg.my + self.drag_delta_y
			local sat, lum = coords_sl(0, ay)
			change_color(active_color, nil, nil, lum)
		end
	end
	
	function el:release(msg)
		send_palette()
		self.drag_delta_y = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end
			
	return el
end


-----------------------------------------------------------------------------------


function create_vertical_sat_slider(el)
	el.width = 23
	el.height = slider_size
	
	function el:draw()
--		rectfill(0, 0, self.width, self.height, 6)
--		clip()
		for c = 0, 63 do
--			if
--				not hidden[c] and pal_okhsl[c].l != 0
--				and c ~= active_color
--				and active_color
--				and abs(pal_okhsl[active_color].h - pal_okhsl[c].h) < 0.1
--			then
--				local ay = s_coordsy(c)
--				local dx = (pal_okhsl[c].h - pal_okhsl[active_color].h) * 100.0
--				rectfill(self.width//2 + dx - 2, ay - 2, self.width//2 + dx + 2, ay + 2, c)
--			end
			if
				not hidden[c] and pal_okhsl[c].l != 0
				and c ~= active_color
				and active_color
				and abs(pal_okhsl[active_color].h - pal_okhsl[c].h) < 0.1
			then
				local ay = s_coordsy(c)
				if pal_okhsl[c].h < pal_okhsl[active_color].h then
--					line(0, ay, self.width//2 - 3, ay, c)
					rectfill(0, ay-2, 4, ay+2, c)
				elseif pal_okhsl[c].h > pal_okhsl[active_color].h then
--					line(self.width//2 + 3, ay, self.width-1, ay, c)
					rectfill(self.width//2 + 7, ay-2, self.width//2 + 7 + 4, ay + 2, c)
				else
					line(2, ay, self.width - 3, ay, c)
				end
			end
		end
		line(
			self.width // 2, slider_border, 
			self.width // 2, slider_border + slider_inner, 
			outline_color()
		)
		if active_color and not hidden[active_color] then
			local ay = s_coordsy(active_color)
			pal(7, outline_color())
			pal(13, active_color)
			spr(4, 5, ay - 4)
			pal(13, 13)
			pal(7, 7)
		end
		clip()
		pal(7, outline_color())
		spr(23, -8, self.height + 4)
		pal(7)
	end	
	
	function el:hover(msg)
		if active_color and not hidden[active_color] then
			local ay = s_coordsy(active_color)
			if msg.my and msg.my >= ay - 4 and msg.my <= ay + 4
					and msg.mx >= 6 and msg.mx <= self.width - 6 then
				self.cursor = "grab"
			else
				self.cursor = 1
			end
		end
	end

	function el:click(msg)
		undo_stack:checkpoint()
		if active_color and not hidden[active_color] then
			local ay = s_coordsy(active_color)
			if msg.my and msg.my >= ay - 4 and msg.my <= ay + 4
					and msg.mx >= 6 and msg.mx <= self.width - 6 then
				self.drag_delta_y = ay - msg.my
			end
		end
	end
	
	function el:drag(msg)
		if (not active_color) return
		if (not self.drag_delta_y) return
		if locked[active_color] then
			padlock_flashing = true
		else
			local ay = msg.my + self.drag_delta_y
			local sat = coordsy_s(ay)
			change_color(active_color, nil, sat, nil)
		end
	end
	
	function el:release(msg)
		send_palette()
		self.drag_delta_y = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end
			
	return el
end

:: src/integration.lua
--[[pod_format="raw",created="2025-03-08 09:24:27",modified="2025-03-10 15:52:22",revision=269]]
function register_as_default_app()
	local okpal_path = env().argv[0]

	-- Prevent registering the wrong path when
	-- developing OkPal.
	if okpal_path == "/system/apps/terminal.lua" then
		return
	end
	
	if fstat("/system/util/default_app.lua") ~= "file" then
		return
	end

	local default_apps = fetch("/appdata/system/default_apps.pod") or {}
	if default_apps["pal"] == nil then
		create_process(
			"/system/util/default_app.lua",
			{ argv = { "pal", okpal_path } }
		)
	end
	if default_apps["hex"] == nil then
		create_process(
			"/system/util/default_app.lua",
			{ argv = { "hex", okpal_path } }
		)
	end
end


function get_default_apps()
	local result = { pal = "(unknown)", hex = "(unknown)" }

	if fstat("/system/util/default_app.lua") ~= "file" then
		return result
	end

	local default_apps = fetch("/appdata/system/default_apps.pod") or {}
	result.pal = default_apps.pal or "(none)"
	result.hex = default_apps.hex or "(none)"

	return result
end


function set_default_apps(extension)
	local okpal_path = env().argv[0]

	-- Prevent registering the wrong path when
	-- developing OkPal.
	if okpal_path == "/system/apps/terminal.lua" then
		return
	end
	
	if fstat("/system/util/default_app.lua") ~= "file" then
		return
	end

	create_process(
		"/system/util/default_app.lua",
		{ argv = { extension, okpal_path } }
	)
end


-----------------------------------------------------------------------------


function send_palette()
	if not user_settings.send_palette then
		return
	end
	
	local palette = userdata("i32", 64)
	for c = 0, 63 do
		palette:set(c, get_color(c))
	end
	
	-- Updating the PID lists as we're sending the event
	-- to not miss new processes.
	for pid in all(find_gfx_map_pids()) do
		send_message(pid, { event = "set_palette", palette = palette })
	end
end


-- From Eiyeron's fork #eyn_okpal_fork-0
function find_gfx_map_pids()
	local matching_pids = {}
	for process in all(fetch "/ram/system/processes.pod") do
		local name <const> = process.name
		if name == "gfx" or name == "map" then
			matching_pids[#matching_pids + 1] = process.id
		end
	end
	return matching_pids
end


-- Drag-and-drop ------------------------------------------------------------------


function handle_drop_items(msg)
	for i = 1, #msg.items do
		local item = msg.items[i]
		if item.pod_type == "file_reference" and item.attrib == "file" then
--			undo_stack:checkpoint()
--			send_message(pid(), { event = "open_file", filename = item.fullpath })
		local okpal_path = env().argv[0]
		-- Prevent registering the wrong path when
		-- developing OkPal.
		if okpal_path == "/system/apps/terminal.lua" then
			return
		end
		create_process(
			okpal_path,
			{
				argv = { item.fullpath },
			}
		)
		end
	end
end

:: src/oklab.lua
--[[pod_format="raw",created="2024-03-31 09:08:26",modified="2025-03-10 19:14:59",revision=981]]
-- Copyright(c) 2021 Bjorn Ottosson
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of
-- this software and associated documentation files(the "Software"), to deal in
-- the Software without restriction, including without limitation the rights to
-- use, copy, modify, merge, publish, distribute, sublicense, and /or sell copies
-- of the Software, and to permit persons to whom the Software is furnished to do
-- so, subject to the following conditions:
--
-- The above copyright noticeand this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

oklab = {}
oklab.__index = oklab

function oklab.color_to_okhsl(code)
	local srgb = {
		r = ((code & 0xff0000) >> 16) / 255,
		g = ((code & 0x00ff00) >> 8) / 255,
		b = ((code & 0x0000ff)) / 255,
	}
	return oklab.srgb_to_okhsl(srgb)
end

function oklab.okhsl_to_color(okhsl)
	local srgb = oklab.okhsl_to_srgb(okhsl)
	local r = mid(0x00, math.floor(srgb.r * 255 + 0.5), 0xff)
	local g = mid(math.floor(srgb.g * 255 + 0.5), 0xff)
	local b = mid(math.floor(srgb.b * 255 + 0.5), 0xff)
	return (r << 16) | (g << 8) | b
end

function oklab.new()
    local inst = setmetatable({}, oklab)
    return inst
end

-- Finds the maximum saturation possible for a given hue that fits in sRGB
-- Saturation here is defined as S = C/L
-- a and b must be normalized so a^2 + b^2 == 1
function oklab.compute_max_saturation(a, b)
    if a ~= 0.0 or b ~= 0.0 then
    	-- Max saturation will be when one of r, g or b goes below zero.
        -- Select different coefficients depending on which component goes below zero first

        -- Blue component (default)
        local k0 = 1.35733652
        local k1 = -0.00915799
        local k2 = -1.1513021
        local k3 = -0.50559606
        local k4 = 0.00692167
        local wl = -0.0041960863
        local wm = -0.7034186147
        local ws = 1.707614701

        if -1.88170328 * a - 0.80936493 * b > 1 then
            -- Red component
            k0 = 1.19086277
            k1 = 1.76576728
            k2 = 0.59662641
            k3 = 0.75515197
            k4 = 0.56771245
            wl = 4.0767416621
            wm = -3.3077115913
            ws = 0.2309699292
        elseif 1.81444104 * a - 1.19445276 * b > 1 then
            -- Green component
            k0 = 0.73956515
            k1 = -0.45954404
            k2 = 0.08285427
            k3 = 0.1254107
            k4 = 0.14503204
            wl = -1.2684380046
            wm = 2.6097574011
            ws = -0.3413193965
        end

        -- Approximate max saturation using a polynomial:
        local S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b

        -- Do one step Halley's method to get closer
        -- this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite
        -- this should be sufficient for most applications, otherwise do two/three steps

        local k_l = 0.3963377774 * a + 0.2158037573 * b
        local k_m = -0.1055613458 * a - 0.0638541728 * b
        local k_s = -0.0894841775 * a - 1.291485548 * b

        do
            local l_ = 1.0 + S * k_l
            local m_ = 1.0 + S * k_m
            local s_ = 1.0 + S * k_s

            local l = l_ * l_ * l_
            local m = m_ * m_ * m_
            local s = s_ * s_ * s_

            local l_dS = 3.0 * k_l * l_ * l_
            local m_dS = 3.0 * k_m * m_ * m_
            local s_dS = 3.0 * k_s * s_ * s_

            local l_dS2 = 6.0 * k_l * k_l * l_
            local m_dS2 = 6.0 * k_m * k_m * m_
            local s_dS2 = 6.0 * k_s * k_s * s_

            local f = wl * l + wm * m + ws * s
            local f1 = wl * l_dS + wm * m_dS + ws * s_dS
            local f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2

            local s_denom = f1 * f1 - 0.5 * f * f2
            if s_denom ~= 0.0 then  S = S - f * f1 / s_denom end
        end

        return S
    else
        return 0.0
    end
end

-- finds L_cusp and C_cusp for a given hue
-- a and b must be normalized so a^2 + b^2 == 1
function oklab.find_cusp(a, b)
	-- First, find the maximum saturation (saturation S = C/L)
    local S_cusp = oklab.compute_max_saturation(a, b)

    -- Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:
    local rgb_at_max = oklab.oklab_to_linear_srgb({L = 1, a = S_cusp * a, b = S_cusp * b })
    local max_comp = math.max(rgb_at_max.r, rgb_at_max.g, rgb_at_max.b)
    if max_comp ~= 0.0 then
        local L_cusp = (1.0 / max_comp) ^ 0.3333333333333333
        return { L = L_cusp, C = L_cusp * S_cusp }
    else
        return { L = 0.0, C = 0.0 }
    end
end

-- Finds intersection of the line defined by
-- L = L0 * (1 - t) + t * L1
-- C = t * C1
-- a and b must be normalized so a^2 + b^2 == 1
function oklab.find_gamut_intersection(a, b, L1, C1, L0, x)
    -- Find the cusp of the gamut triangle
    local cusp = x or oklab.find_cusp(a, b)

    -- Find the intersection for upper and lower half separately
    local t = 0.0
    if ((L1 - L0) * cusp.C - (cusp.L - L0) * C1) <= 0.0 then
        -- Lower half
        local t_denom = C1 * cusp.L + cusp.C * (L0 - L1)
        if t_denom ~= 0.0 then t = cusp.C * L0 / t_denom end
    else
        -- Upper half
        -- First intersect with triangle
        local t_denom = C1 * (cusp.L - 1.0) + cusp.C * (L0 - L1)
        if t_denom ~= 0.0 then t = cusp.C * (L0 - 1.0) / t_denom end

        -- Then one step Halley's method
        do
            local dL = L1 - L0
            local dC = C1

            local k_l = 0.3963377774 * a + 0.2158037573 * b
            local k_m = -0.1055613458 * a - 0.0638541728 * b
            local k_s = -0.0894841775 * a - 1.291485548 * b

            local l_dt = dL + dC * k_l
            local m_dt = dL + dC * k_m
            local s_dt = dL + dC * k_s

            -- If higher accuracy is required, 2 or 3 iterations of the following block can be used:
            do
                local L = L0 * (1.0 - t) + t * L1
				local C = t * C1

				local l_ = L + C * k_l
				local m_ = L + C * k_m
				local s_ = L + C * k_s

				local l = l_ * l_ * l_
				local m = m_ * m_ * m_
				local s = s_ * s_ * s_

				local ldt = 3.0 * l_dt * l_ * l_
				local mdt = 3.0 * m_dt * m_ * m_
				local sdt = 3.0 * s_dt * s_ * s_

				local ldt2 = 6.0 * l_dt * l_dt * l_
				local mdt2 = 6.0 * m_dt * m_dt * m_
				local sdt2 = 6.0 * s_dt * s_dt * s_

                local r0 = 4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s - 1
				local r1 = 4.0767416621 * ldt - 3.3077115913 * mdt + 0.2309699292 * sdt
				local r2 = 4.0767416621 * ldt2 - 3.3077115913 * mdt2 + 0.2309699292 * sdt2

                local r_denom = r1 * r1 - 0.5 * r0 * r2
                local u_r = 0.0
                if r_denom ~= 0.0 then u_r = r1 / r_denom end
				local t_r = -r0 * u_r

                local g0 = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s - 1
				local g1 = -1.2684380046 * ldt + 2.6097574011 * mdt - 0.3413193965 * sdt
				local g2 = -1.2684380046 * ldt2 + 2.6097574011 * mdt2 - 0.3413193965 * sdt2

                local g_denom = g1 * g1 - 0.5 * g0 * g2
                local u_g = 0.0
                if g_denom ~= 0.0 then u_g = g1 / g_denom end
				local t_g = -g0 * u_g

                local b0 = -0.0041960863 * l - 0.7034186147 * m + 1.707614701 * s - 1
				local b1 = -0.0041960863 * ldt - 0.7034186147 * mdt + 1.707614701 * sdt
				local b2 = -0.0041960863 * ldt2 - 0.7034186147 * mdt2 + 1.707614701 * sdt2

                local b_denom = (b1 * b1 - 0.5 * b0 * b2)
                local u_b = 0.0
                if b_denom ~= 0.0 then u_b = b1 / b_denom end
				local t_b = -b0 * u_b

                if u_r < 0.0 then t_r = 3.40282347e+38 end
                if u_g < 0.0 then t_g = 3.40282347e+38 end
                if u_b < 0.0 then t_b = 3.40282347e+38 end

                t = t + math.min(t_r, t_g, t_b)
            end
        end
    end

    return t
end

function oklab.get_Cs(L, a_, b_)
    local cusp = oklab.find_cusp(a_, b_)
    local C_max = oklab.find_gamut_intersection(a_, b_, L, 1.0, L, cusp)
    local ST_max = oklab.to_ST(cusp)

    -- Scale factor to compensate for the curved part of gamut shape:
    local k = 0.0
    local k_denom = math.min(L * ST_max.S, (1.0 - L) * ST_max.T)
    if k_denom ~= 0.0 then k = C_max / k_denom end

    local C_mid = 0.0
    do
        local ST_mid = oklab.get_ST_mid(a_, b_)

        -- Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.
        local C_a = L * ST_mid.S
        local C_b = (1.0 - L) * ST_mid.T

        local cae4 = C_a * C_a * C_a * C_a
        local cbe4 = C_b * C_b * C_b * C_b
        C_mid = 0.9 * k * ((1.0 / (1.0 / cae4 + 1.0 / cbe4)) ^ 0.25)
    end

    local C_0 = 0.0
    do
        -- for C_0, the shape is independent of hue, so ST are constant. Values picked to roughly be the average values of ST.
        local C_a = L * 0.4
        local C_b = (1.0 - L) * 0.8

        -- Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.
        local cae2 = C_a * C_a
        local cbe2 = C_b * C_b
        C_0 = math.sqrt(1.0 / (1.0 / cae2 + 1.0 / cbe2))
    end

    return { C_0 = C_0, C_mid = C_mid, C_max = C_max }
end

-- Returns a smooth approximation of the location of the cusp
-- This polynomial was created by an optimization process
-- It has been designed so that S_mid < S_max and T_mid < T_max
function oklab.get_ST_mid(a_, b_)
    local S = 0.11516993
    local s_denom = 7.4477897 + 4.1590124 * b_
        + a_ * (-2.19557347 + 1.75198401 * b_
        + a_ * (-2.13704948 - 10.02301043 * b_
        + a_ * (-4.24894561 + 5.38770819 * b_ + 4.69891013 * a_)))
    if s_denom ~= 0.0 then
        S = 0.11516993 + 1.0 / s_denom
    end

    local T = 0.11239642
    local t_denom = 1.6132032 - 0.68124379 * b_
        + a_ * (0.40370612 + 0.90148123 * b_
        + a_ * (-0.27087943 + 0.6122399 * b_
        + a_ * (0.00299215 - 0.45399568 * b_ - 0.14661872 * a_)))
	if t_denom ~= 0.0 then
        T = 0.11239642 + 1.0 / t_denom
    end

	return { S = S, T = T }
end

function oklab.linear_srgb_to_oklab(c)
    local l = 0.4122214708 * c.r
            + 0.5363325363 * c.g
            + 0.0514459929 * c.b
	local m = 0.2119034982 * c.r
            + 0.6806995451 * c.g
            + 0.1073969566 * c.b
	local s = 0.0883024619 * c.r
            + 0.2817188376 * c.g
            + 0.6299787005 * c.b

    local l_ = l ^ 0.3333333333333333
    local m_ = m ^ 0.3333333333333333
    local s_ = s ^ 0.3333333333333333

    return {
        L = 0.2104542553 * l_
          + 0.793617785 * m_
          - 0.0040720468 * s_,
        a = 1.9779984951 * l_
          - 2.428592205 * m_
          + 0.4505937099 * s_,
        b = 0.0259040371 * l_
          + 0.7827717662 * m_
          - 0.808675766 * s_ }
end

function oklab.okhsl_to_oklab(hsl)
	local l = hsl.l
    if l >= 1.0 then return { L = 1.0, a = 0.0, b = 0.0 } end
    if l <= 0.0 then return { L = 0.0, a = 0.0, b = 0.0 } end

    local s = hsl.s
    if s < 0.0 then s = 0.0 end
    if s > 1.0 then s = 1.0 end

    local h = hsl.h
    local h_rad = h * 6.283185307179586
    local a_ = math.cos(h_rad)
    local b_ = math.sin(h_rad)
    local L = oklab.toe_inv(l)

    local cs = oklab.get_Cs(L, a_, b_)
    local C_0 = cs.C_0
	local C_mid = cs.C_mid
	local C_max = cs.C_max

    local mid = 0.8
	local mid_inv = 1.25

    local C = 0.0
    local t = 0.0
    local k_0 = 0.0
    local k_1 = 0.0
    local k_2 = 0.0
    if s < mid then
        t = mid_inv * s

		k_1 = mid * C_0
        if C_mid ~= 0.0 then
		    k_2 = 1.0 - k_1 / C_mid
        end

        local k_denom = 1.0 - k_2 * t
		if k_denom ~= 0.0 then
            C = t * k_1 / k_denom
        end
    else
        local t_denom = 1.0 - mid
        if t_denom ~= 0.0 then
            t = (s - mid) / t_denom
        end

		k_0 = C_mid
        if C_0 ~= 0.0 then
		    k_1 = (1.0 - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0
        end

        local C_denom = C_max - C_mid
		k_2 = 1.0
        if C_denom ~= 0.0 then
            k_2 = 1.0 - k_1 / C_denom
        end

        local k_denom = 1.0 - k_2 * t
        if k_denom ~= 0.0 then
		    C = k_0 + t * k_1 / k_denom
        end
    end

    return {
        L = L,
        a = C * a_,
        b = C * b_ }
end

function oklab.okhsl_to_srgb(hsl)
    return oklab.oklab_to_srgb(oklab.okhsl_to_oklab(hsl))
end

function oklab.okhsv_to_oklab(hsv)
	local v = hsv.v
    if v <= 0.0 then return { L = 0.0, a = 0.0, b = 0.0 } end
    if v > 1.0 then v = 1.0 end

    local s = hsv.s
    if s < 0.0 then s = 0.0 end
    if s > 1.0 then s = 1.0 end

    local h = hsv.h
    local h_rad = h * 6.283185307179586
    local a_ = math.cos(h_rad)
    local b_ = math.sin(h_rad)

    local cusp = oklab.find_cusp(a_, b_)
	local ST_max = oklab.to_ST(cusp)
	local S_max = ST_max.S
	local T_max = ST_max.T
	local S_0 = 0.5
    local k = 1.0
    if S_max ~= 0.0 then
	    k = 1.0 - S_0 / S_max
    end

    -- first we compute L and V as if the gamut is a perfect triangle:

	-- L, C when v==1:
    local v_denom = S_0 + T_max - T_max * k * s
    local L_v = 1.0
    local C_v = 0.0
    if v_denom ~= 0.0 then
        L_v = 1.0 - s * S_0 / v_denom
	    C_v = s * T_max * S_0 / v_denom
    end

    local L = v * L_v
	local C = v * C_v

    --then we compensate for both toe and the curved top part of the triangle:
    local L_vt = oklab.toe_inv(L_v)
    local C_vt = 0.0
    if L_v ~= 0.0 then
        C_vt = C_v * L_vt / L_v
    end

    local L_new = oklab.toe_inv(L)
    if L ~= 0.0 then
        C = C * L_new / L
    end
    L = L_new

    local rgb_scale = oklab.oklab_to_linear_srgb({
        L = L_vt,
        a = a_ * C_vt,
        b = b_ * C_vt })
    local max_comp = math.max(
        rgb_scale.r,
        rgb_scale.g,
        rgb_scale.b, 0.0)
    local scale_L = 0.0
    if max_comp ~= 0.0 then
        scale_L = (1.0 / max_comp) ^ 0.3333333333333333
    end

	C = C * scale_L
    return {
        L = L * scale_L,
        a = C * a_,
        b = C * b_ }
end

function oklab.okhsv_to_srgb(hsv)
    return oklab.oklab_to_srgb(oklab.okhsv_to_oklab(hsv))
end

function oklab.oklab_to_linear_srgb(lab)
    local l_ = lab.L
        + 0.3963377774 * lab.a
        + 0.2158037573 * lab.b
	local m_ = lab.L
        - 0.1055613458 * lab.a
        - 0.0638541728 * lab.b
	local s_ = lab.L
        - 0.0894841775 * lab.a
        - 1.291485548 * lab.b

    local l = l_ * l_ * l_
    local m = m_ * m_ * m_
    local s = s_ * s_ * s_

    return {
        r = 4.0767416621 * l
          - 3.3077115913 * m
          + 0.2309699292 * s,
        g = -1.2684380046 * l
           + 2.6097574011 * m
           - 0.3413193965 * s,
        b = -0.0041960863 * l
           - 0.7034186147 * m
           + 1.707614701 * s }
end

function oklab.oklab_to_okhsl(lab)
    local L = lab.L
    if L >= 1.0 then return { h = 0.0, s = 0.0, l = 1.0 } end
    if L <= 0.0 then return { h = 0.0, s = 0.0, l = 0.0 } end

    local Csq = lab.a * lab.a + lab.b * lab.b
    if Csq > 0.0 then
        local C = math.sqrt(Csq)
        local a_ = lab.a / C
        local b_ = lab.b / C

        -- 1.0 / math.pi = 0.3183098861837907
        local h = 0.5 + 0.5 * math.atan(-lab.b, -lab.a) * 0.3183098861837907

        local cs = oklab.get_Cs(L, a_, b_)
        local C_0 = cs.C_0
        local C_mid = cs.C_mid
        local C_max = cs.C_max

        -- Inverse of the interpolation in okhsl_to_srgb:
        local mid = 0.8
        local mid_inv = 1.25

        local s = 0.0
        if C < C_mid then
            local k_1 = mid * C_0
            local k_2 = 1.0
            if C_mid ~= 0.0 then
                k_2 = (1.0 - k_1 / C_mid)
            end

            local t_denom = k_1 + k_2 * C
            local t = 0.0
            if t_denom ~= 0.0 then
                t = C / t_denom
            end

            s = t * mid
        else
            local k_0 = C_mid
            local k_1 = 0.0
            if C_0 ~= 0.0 then
                k_1 = (1.0 - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0
            end

            local C_denom = C_max - C_mid
            local k_2 = 1.0
            if C_denom ~= 0.0 then
                k_2 = 1.0 - k_1 / C_denom
            end

            local t_denom = k_1 + k_2 * (C - k_0)
            local t = 0.0
            if t_denom ~= 0.0 then
                t = (C - k_0) / t_denom
            end

            s = mid + (1.0 - mid) * t
        end

        return { h = h, s = s, l = oklab.toe(L) }
    else
        return { h = 0.0, s = 0.0, l = L }
    end
end

function oklab.oklab_to_okhsv(lab)
    local L = lab.L
    if L >= 1.0 then return { h = 0.0, s = 0.0, v = 1.0 } end
    if L <= 0.0 then return { h = 0.0, s = 0.0, v = 0.0 } end

    local Csq = lab.a * lab.a + lab.b * lab.b
    if Csq > 0.0 then
        local C = math.sqrt(Csq)
        local a_ = lab.a / C
        local b_ = lab.b / C

        -- 1.0 / math.pi = 0.3183098861837907
        local h = 0.5 + 0.5 * math.atan(-lab.b, -lab.a) * 0.3183098861837907

        local cusp = oklab.find_cusp(a_, b_)
        local ST_max = oklab.to_ST(cusp)
        local S_max = ST_max.S
        local T_max = ST_max.T
        local S_0 = 0.5
        local k = 1.0
        if S_max ~= 0.0 then
            k = 1.0 - S_0 / S_max
        end

        -- first we find L_v, C_v, L_vt and C_vt
        local t_denom = C + L * T_max
        local t = 0.0
        if t_denom ~= 0.0 then
            t = T_max / t_denom
        end
        local L_v = t * L
        local C_v = t * C

        local L_vt = oklab.toe_inv(L_v)
        local C_vt = 0.0
        if L_v ~= 0.0 then
            C_vt = C_v * L_vt / L_v
        end

        -- we can then use these to invert the step that compensates for the toe and the curved top part of the triangle:
        local rgb_scale = oklab.oklab_to_linear_srgb({
            L = L_vt,
            a = a_ * C_vt,
            b = b_ * C_vt })
        local scale_denom = math.max(
            rgb_scale.r,
            rgb_scale.g,
            rgb_scale.b, 0.0)
        local scale_L = 0.0
        if scale_denom ~= 0.0 then
            scale_L = (1.0 / scale_denom) ^ 0.3333333333333333
            L = L / scale_L
            C = C / scale_L
        end

        local toel = oklab.toe(L)
        C = C * toel / L
        L = toel

        -- we can now compute v and s:
        local v = 0.0
        if L_v ~= 0.0 then v = L / L_v end

        local s = 0.0
        local s_denom = ((T_max * S_0) + T_max * k * C_v)
        if s_denom ~= 0.0 then
            s = (S_0 + T_max) * C_v / s_denom
        end

        return { h = h, s = s, v = v }
    else
        return { h = 0.0, s = 0.0, v = L }
    end
end

function oklab.oklab_to_srgb(lab)
    local lrgb = oklab.oklab_to_linear_srgb(lab)
	return {
		r = oklab.srgb_transfer_function(lrgb.r),
		g = oklab.srgb_transfer_function(lrgb.g),
		b = oklab.srgb_transfer_function(lrgb.b) }
end

function oklab.srgb_to_okhsl(rgb)
    return oklab.oklab_to_okhsl(oklab.srgb_to_oklab(rgb))
end

function oklab.srgb_to_okhsv(rgb)
    return oklab.oklab_to_okhsv(oklab.srgb_to_oklab(rgb))
end

function oklab.srgb_to_oklab(srgb)
    return oklab.linear_srgb_to_oklab({
		r = oklab.srgb_transfer_function_inv(srgb.r),
		g = oklab.srgb_transfer_function_inv(srgb.g),
		b = oklab.srgb_transfer_function_inv(srgb.b) })
end

function oklab.srgb_transfer_function(a)
    if 0.0031308 >= a then
        return 12.92 * a
    else
        return 1.055 * (a ^ 0.4166666666666667) - 0.055
    end
end

function oklab.srgb_transfer_function_inv(a)
    if 0.04045 < a then
        return ((a + 0.055) * 0.9478672985781991) ^ 2.4
    else
        return a * 0.07739938080495357
    end
end

function oklab.to_ST(cusp)
	local L = cusp.L
    local C = cusp.C
    if L ~= 0.0 and L ~= 1.0 then
        return { S = C / L, T = C / (1.0 - L) }
    elseif L ~= 0.0 then
        return { S = C / L, T = 0.0 }
    elseif L ~= 1.0 then
        return { S = 0.0, T = C / (1.0 - L) }
    else
        return { S = 0.0, T = 0.0 }
    end
end

function oklab.toe(x)
    local y = 1.170873786407767 * x - 0.206
	return 0.5 * (y + math.sqrt(y * y + 0.14050485436893204 * x))
end

function oklab.toe_inv(x)
    local denom = 1.170873786407767 * (x + 0.03)
    if denom ~= 0.0 then
    	return (x * x + 0.206 * x) / denom
    else
        return 0.0
    end
end

return oklab
:: src/palette.lua
--[[pod_format="raw",created="2024-03-31 08:27:10",modified="2025-03-05 16:21:40",revision=3587]]
function set_color(c, code)
	poke4(0x5000 + 4 * c, code)
end


function get_color(c)
	return peek4(0x5000 + 4 * c)
end


function color_to_hex(c)
	return string.format("%06x", c)
end


function rebuild_pal(c)
	for c = 0, 63 do
		pal_code[c] = get_color(c)
		pal_okhsl[c] = oklab.color_to_okhsl(pal_code[c])
	end
end


function change_color_code(c, code)
	pal_code[c] = code
	pal_okhsl[c] = oklab.color_to_okhsl(pal_code[c])
	set_color(c, code)
end


function change_color(c, hue, sat, lum)
	local hsl = {
		h = hue or pal_okhsl[c].h,
		s = sat or pal_okhsl[c].s,
		l = lum or pal_okhsl[c].l,
	}
	hsl.h = mid(-1.0, hsl.h, 1.0)
	hsl.s = mid(0.0, hsl.s, 1.0)
	hsl.l = mid(0.0, hsl.l, 1.0)
	local code = oklab.okhsl_to_color(hsl)
	pal_code[c] = code
	pal_okhsl[c] = hsl
	set_color(c, code)
	return
end


function swap_colors(c1, c2)
	pal_code[c1], pal_code[c2] = pal_code[c2], pal_code[c1]
	pal_okhsl[c1], pal_okhsl[c2] = pal_okhsl[c2], pal_okhsl[c1]
	set_color(c1, pal_code[c1])
	set_color(c2, pal_code[c2])
end


function clear_colors()
	for c = 0, 63 do
		local code, lum
		if c == 7 then
			code = 0xffffff
			lum = 1.0
		else
			code = 0x000000
			lum = 0.0
		end
		pal_code[c] = code
		pal_okhsl[c] = { h = 0.0, s = 0.0, l = lum }
		set_color(c, code)
		locked[c] = (c == 0) or (c == 7)
		hidden[c] = false
		for row = 0, 3 do hidden_toggles[row] = false end
		for i = 0, #test_cube_colors - 1 do
			test_cube_colors[i] = { 1, 1, 1 }
		end
	end
	bg_color = 0
	blackest_color = 0
	whitest_color = 7
end


function restore_default_palette()
	for c = 0, 63 do
		code = peek4(0x5000 + 4 * (64 + c))
		set_color(c, code)
		pal_code[c] = code
		pal_okhsl[c] = oklab.color_to_okhsl(code)
		locked[c] = c <= 31
		hidden[c] = false
		for row = 0, 3 do hidden_toggles[row] = false end
		test_cube_colors = copy(default_test_cube_colors)
	end
	bg_color = 0
	blackest_color = 0
	whitest_color = 7
end


function find_blackest_and_whitest()
	local min_lum = 1.0
	local best_black = 0
	local max_lum = 0.0
	local best_white = 1
	for c = 0, 63 do
		if pal_okhsl[c].l < min_lum then
			best_black = c
			min_lum = pal_okhsl[c].l
		end
		if pal_okhsl[c].l > max_lum then
			best_white = c
			max_lum = pal_okhsl[c].l
		end
	end
	return best_black, best_white
end
:: src/settings.lua
--[[pod_format="raw",created="2025-03-07 18:22:46",modified="2025-03-10 15:52:22",revision=358]]
local settings_folder = "/appdata/okpal/"
local settings_filepath = "/appdata/okpal/settings.pod"


function load_settings()
	mkdir(settings_folder)
	local s = fetch(settings_filepath)
	if s then
		for k, v in pairs(user_settings) do
			if type(s[k]) ~= nil then
				user_settings[k] = s[k]
			end
		end
	end
end


function change_settings(t)
	for k, v in pairs(t) do
		user_settings[k] = v
	end
	store(settings_filepath, user_settings)
end

:: src/soft_wrap.lua
--[[pod_format="raw",created="2025-03-07 11:09:14",modified="2025-03-07 17:37:27",revision=426]]
function soft_wrap(text, width)
	local space_width <const> = print(" ", -1000, -1000) + 1000
	local lines = {}
	local line = ""
	local x = 0
	local indentation = 0 -- indentation of the current paragraph

	local function add_word(word)
		local dx = print(word, -1000, -1000) + 1000
		if x + space_width + dx >= width then
			add(lines, line)
			line = ""
			x = 0
			for i = 1, indentation do
				line ..= " "
				x += space_width
			end
			line ..= word
			x += dx
		else
			if line:find("^%s*$") then
				line ..= word
				x += dx
			else
				line ..= " " .. word
				x += space_width + dx
			end
		end
	end
	
	local function add_line()
		add(lines, line)
		line = ""
		x = 0
	end
	
	local in_paragraph = false
	local in_code = false
	local ignore_word = false
	local ignore_line = false
	add_line()
	for hard_line in text:gmatch("([^\n]*)\n?") do
		ignore_line = false
		ignore_word = false
		if hard_line:find("^%s*$") then
			if in_paragraph then
				add_line()
				add_line()
				in_paragraph = false
				indentation = 0
			end
		elseif hard_line:find("^%s*- ") then
			if in_paragraph then
				add_line()
			end
			add_word("-")
			indentation = 2
			in_paragraph = true
			ignore_word = true
		elseif hard_line:find("^```%s*$") then
			if line ~= "" then
				add_line()
			end
			in_code = not in_code
			ignore_line = true
		else
			in_paragraph = true
 		end
 		
 		if not ignore_line then
	 		if in_code then
	 			line = hard_line
	 			add_line()
	 		else
				for word in hard_line:gmatch("([^%s]*)%s?") do
					if ignore_word then
						ignore_word = false
					else
						add_word(word)
					end
				end
			end
		end
	end
	add_line()
	
	return lines
end
:: src/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTAzIDE4OjA3OjM0Iixtb2RpZmllZD0iMjAyNS0w
My0xMCAyMTozMDo1NSIsc3RvcmVkPSIyMDI0LTA0LTAzIDE4OjA3OjM0Il1d
:: label.qoi
b64$cW9pZgAAAeAAAAEOBAH_--Ho-f39-f39-f3T-rkAPvI-wf6iiHnMP-39-f39-cUSxD-X-rkA
Ps8-wBLOP8ASzz-_ooh5zj-9-f39zBLAP8ASwD-HEsE-wBLBP8sSwT-IEsQ-xhLGP8kSPxI-3RLF
P8YSxT-H-rkAPs4-EsA-Es4-Es8--qKIec4--f39-csSwD-CEsA-xhLBP8ASwT-GEsI-EsE-yBI-
whI-xhLGP8oSP8n_uQA_xj-P-qKIeT8SP9b_uQA_zj8SP8ASwz-BEsE-wBLBPxLPP-6iiHnOP-39
-f3LEsA-whLAP8YSwT-AEsE-xhLCPxLBP8gSP8ISP8YSxj-GEsc-xf65AD7CP8ESP8v_ooh5wT8S
wT-GEsU-x-65AD7OP8ASPxLDPxLAPxLCPxLAPxLPP-6iiHnGPxLFP-39-f3LEsA-whLAP8YSxj-G
EsI-zBI-whI-xhLGP8YSwD-DEsA-xf65AD7CP8ESP8v_ooh5PxI-2v65AD7OPxLAPxLDPxLAPxLA
P8ESwD8Szz-_ooh5xT-BEsQ--f39-csSwD-CEsA-xhI-EsI-Ej-GEsU-yRI-wBLBP9YSwD-DEsA-
xf65AD4-wRLCP8v_ooh5xT-GEsU-x-65AD7OPxLAPxLDP8ESwD8SwD8SwD8Szz-_ooh5xj8SxT-9
-f39yxLAP8ISwD-GEj8Swj8SP8YSxT-HEsE-wBLBP8YSxj-GEsA-wxLAP8X_uQA_P8ESwj-M-qKI
ecQ-1v65AD7PP8ASwT8SwD8Swz-BEsA-wBLOP-6iiHnOP-39-f3MEsA-wBLAP8cSxj-GEsU-xxLB
P8sSwD-CEsA-xhLHP8X_uQA_xj-qEtc-Eto--qKIec4--f39-f394-65AD70P-6iiHnOP-39-f39
-f4AAAD9-f39-f39-f39-f39-f39-f39-f39-f39-f39-f39-f39-f3iPzU-NT81PzU-NT81xT81
PzU-NT81PzU-NdE-1TXDP9Y1-f39-f39xT81yj81wj81yj81zj-XNcE-NdY-Ne0--f39xjXfPzU-
NcM-Ncc-NT81PzXNPzU-Nf3NPzXPPzXNP9c1wT811j817T81yv4dK1PK-n4lU8r_AIdRyv6rUjbK
-l9XT8r_wsPHyj-K-v8ATcr_-6MAyv7-7CfK-gDkNsr_Ka3-yv6DdpzK-v93qMr_-8yqyj81-f3K
PzXPPzXbP9k1PzXYPzXsPzXKKMotyg-K-qtSNsouyjvKP8oNyiHKH8ojyv4prf-KEModyhTKPzXd
PzXDPzXBPzXHPzXDPzXNPzX9xT81PzU-NcE-NcQ-NT81PzXEPzXMP8M1wD81PzU-NcE-NcE-wDXA
P8I1PzXCP8E1P8E1P8E1P8A1wT-ANcE-NeI-wjXEPzXKKMotyg-K-qtSNsouyjvKP8oNyiHKH8oj
yv4prf-KEModyhTKPzX9-co-NcM-NT81wT81wz81wD81wT81PzXRP8M1P8E1PzU-NT81PzU-wTU-
xTXDPzU-NT81PzU-wTU-NT81PzXEPzXgP8Q1wz81yijKLcoPyv6rUjbKLso7yj-KDcohyh-KI8r_
Ka3-yhDKHcoUyj813T81wz81wT81wz81wT81wz81wz81PzXFPzX9wz81PzXFPzXIPzU-NcI-Ncs-
wzU-wTU-NT81wD-ANcA-wDXBP8M1wz-ANcA-wTU-NT81P8A1wD-BNcI-Nd8-xjXCPzXKKMotyg-K
-qtSNsouyjvKP8oNyiHKH8ojyv4prf-KEModyhTKPzX9-co-NcM-Nck-NcY-NdA-xDU-wTU-NT81
PzU-NT-DNT-ENcI-NT81PzU-NT81PzU-NcM-NcM-Nd0-wDU-wDU-NT-ANcE-Ncooyi3KD8r_q1I2
yi7KO8o-yg3KIcofyiPK-imt-8oQyh3KFMo-Nd0-NcM-NcE-NcE-NcM-NT81PzXJPzXDPzX9wT81
PzU-NT81wz81xj81PzU-NT81wD81yj-FNcA-wDXAPzXBPzXBPzXAP8U1wj81PzU-NT81PzU-NT81
wT-ANcQ-Nd0-NcA-wjXAPzXBPzXKKMotyg-K-qtSNsouyjvKP8oNyiHKH8ojyv4prf-KEModyhTK
PzX9-co-NcE-NT81PzXHPzXEPzU-NT81zT-fNdo-Nd0-NcA-wDXAPzXCPzXKKMotyg-K-qtSNsou
yjvKP8oNyiHKH8ojyv4prf-KEModyhTKPzXdPzXDPzXBPzU-NcU-Nck-NT81PzXDPzXHP8A1xD-A
NcQ-wTXlPzU-NcU-Ncg-NT81wj81yT-fNdo-Nd4-NcI-NcM-Ncooyi3KD8r_q1I2yi7KO8o-yg3K
IcofyiPK-imt-8oQyh3KFMo-Nf3UPzXFPzXEPzU-NeA-NcM-Nck-NcY-Nc4--dQ1yj-CNcQ-Ncoo
yi3KD8r_q1I2yi7KO8o-yg3KIcofyiPK-imt-8oQyh3KFMo-Nd0-NcM-NcE-NcE-NcM-Ncc-NcM-
NcM-Ncg-NcU-NcQ-NT817z81zz81-fQ-Ncooyi3KD8r_q1I2yi7KO8o-yg3KIcofyiPK-imt-8oQ
yh3KFMo-Nf3UPzXFPzXEPzU-NeA-Nc8-Nf39xT81yijKLcoPyv6rUjbKLso7yj-KDcohyh-KI8r_
Ka3-yhDKHcoUyj813z81PzXDPzXDPzXBPzXJPzU-NT81wz81PzXFP8E1wD81wD-BNcA-NcA-wTXh
PzXKPzXCPzXKPzX99T-_JGOwyv4ApaHK-mVGiMr_ElNZyv50LynK-kUtMsoSyv7-rMXK-rkAPsr_
4msCyv6V8ELK-gCyUcr_ZN-2yv69mt-K-uQNq8r_-4VXyj81-f3NPzU-NT81PzU-NT81xT81PzU-
NT81PzU-Nf32PyDKFco6yjnKG8oDyv6iiHnKMcr_uQA_ygDKMsomyjbKB8oPyizKPzX9-f3CFMw1
zCzMNcz_q1I2zDXOP8I1xD8gyhXKOso5yhvKA8r_ooh5yjHK-rkAPsoAyjLKJso2ygfKD8osyj81
-f39wRTMCjXLLMwbNcsKzAM1zT-ENcM-IMoVyjrKOcobygPK-qKIecoxyv65AD7KAMoyyibKNsoH
yg-KLMo-Nf39zD-KNcQ-yjXSFMwKwDXKLMwbwDXKCswDwDXMP8Y1wj8gyhXKOso5yhvKA8r_ooh5
yjHK-rkAPsoAyjLKJso2ygfKD8osyj81-f3LPzXKPzXCPzXKPzXQFMwKwTXJLMwbwTXJCswDwTXL
P8A1P8A1PzU-wDXBPyDKFco6yjnKG8oDyv6iiHnKMcr_uQA_ygDKMsomyjbKB8oPyizKPzX9-co-
Ncw-NcA-Ncw-Nc4UzArCNcgszBvCNcgKzAPCNcs-NcA-wjXAPzXBPyDKFco6yjnKG8oDyv6iiHnK
Mcr_uQA_ygDKMsomyjbKB8oPyizKPzX9-co-NcQ-wDXEPzXAPzXCP8Q1wj81zRTMCsM1xyzMG8M1
xwrMA8M1zD81wD-ANcA-NcI-IMoVyjrKOcobygPK-qKIecoxyv65AD7KAMoyyibKNsoHyg-KLMo-
Nf39yj81wT-ANT-ANT-ANcE-NcA-NcE-wTXAP8E1wT81zCzMCsQ1xgrMG8Q1xhvMA8Q1zT81wj81
wz8gyhXKOso5yhvKA8r_ooh5yjHK-rkAPsoAyjLKJso2ygfKD8osyj81-f3KPzXBP8Y1wT81wD81
wT-ANcI-wDXBPzXMLMwKxDXGCswbxDXGG8wDxDXOP8I1xD8gyhXKOso5yhvKA8r_ooh5yjHK-rkA
PsoAyjLKJso2ygfKD8osyj81-f3KPzXCP8Q1wj81wD81xz-ANcE-NcwszArENcYKzBvENcYbzAPE
Ndg-IMoVyjrKOcobygPK-qKIecoxyv65AD7KAMoyyibKNsoHyg-KLMo-Nf39yj81wD-CNcA-wjXA
PzXAPzXGP8A1wj81zCzMCsQ1xgrMG8Q1xhvMA8Q12D8gyhXKOso5yhvKA8r_ooh5yjHK-rkAPsoA
yjLKJso2ygfKD8osyj81-f3KPzXAP8I1wD-CNcA-NcA-NcU-wDXDPzXMLMwKxDXGCswbxDXGG8wD
xDXYPzX9-f3EPzXePzXAP8E1P8E1P8E1wD-ANcA-wDXDP8E1P8A1xD-BNcA-wDU-wTXDPzU-NT-B
NT81wT-BNcA-Nd0-NcI-xDXCPzXAPzXEP8A1xD81zCzMCsQ1xgrMG8Q1xhvMA8Q12D81-f39xD81
3T81wT81PzU-NT81PzXBPzXBPzXFPzXCPzXEPzXBPzU-NT81PzXDPzU-NT81wT81wT81PzXBPzXc
PzXBP8Y1wT81wD81xD-ANcQ-NcwszArENcYKzBvENcYbzAPENc4-wjXEPzX9-f3EPzXdPzXBP8E1
P8A1wD-ANcA-wTU-wTXDP8A1wT81xD-ANcA-NT81P8A1xD-BNT-ANcA-NcE-wTXBPzXcPzXBP8A1
P8A1P8A1wT81wD81zD81zCzMCsQ1xgrMG8Q1xhvMA8Q1zT-ENcM-Nf39-cQ-Nd0-NcE-NcE-NT81
PzXDPzXBPzXDPzXCPzXEPzXBPzU-NT81PzXDPzU-NT81wT81wT81wz813D81xD-ANcQ-NcA-NcQ-
wDXEPzXMLMwKwzXHCswbwzXHG8wDwzXNP8Y1wj81-f39xD813j81wD81wT81PzU-wTU-wDXAP8A1
xD81wT-BNcM-NcE-wDXAPzU-NcM-NT81P8E1P8E1PzXCPzXdPzXMPzXAPzXMPzXMLMwKwjXICswb
wjXIG8wDwjXNP8A1P8A1PzU-wDXBPzX9-f3EPzX9-cs-Nco-NcI-Nco-Nc0szArBNckKzBvBNckb
zAPBNc4-NcA-wjXAPzXBPzX9-f3EPzX9-cw-yjXEP8o1zizMCsA1ygrMG8A1yhvMA8A10D81wD-A
NcA-NcI-Nf39-cQ-Nf39_izMCjXLCswbNcsbzAM10j81wj81wz81-f39xD81-f36LMw1zArMNcwb
zDXUP8I1xD81-f39xD81-f39-eQ-Nf39-cQ-Nf39-f3kPzX9-f3EPzX9-f395D81-f39xD81-f39
-eQ-Nf39-cQ-Nf39-f3aP8I1xD81-f39xD81-f39-dk-xDXDPzX9-f3EPzX9-f392D-GNcI-Nf39
-cQ-Nf39-f3XP8A1P8A1PzU-wDXBPzX9-f3EPzX9-f3CH8w1zCHMNcwNzDXLPzXAP8I1wD81wT81
-f39xD81-f39wR-MADXLIcwSNcsNzC01zD81wD-ANcA-NcI-Nf39-cQ-Nf39-cAfzADANcohzBLA
NcoNzC3ANc0-NcI-NcM-Nf39-cQ-Nf39-R-MAME1ySHMEsE1yQ3MLcE1zj-CNcQ-Nf39-cQ-Nf39
-B-MAMI1yCHMEsI1yA3MLcI12D81-f39xD81-f37H8wAwzXHIcwSwzXHDcwtwzXYPzX9-f3EPzX9
-fohzADENcYAzBLENcYSzC3ENdg--f39xjX9-fohzADENcYAzBLENcYSzC3ENf39-f39-d4hzADE
NcYAzBLENcYSzC3ENf39-f39-d4hzADENcYAzBLENcYSzC3ENf39-f39-d4hzADENcYAzBLENcYS
zC3ENf39-f39-d4hzADENcYAzBLENcYSzC3ENf39-f39-d4hzADENcYAzBLENcYSzC3ENf39-f39
-d4hzADENcYAzBLENcYSzC3ENf3pGzX9-f398CHMAMM1xwDMEsM1xxLMLcM1-eobNc8KNf39-f3e
IcwAwjXIAMwSwjXIEswtwjX92g01zhs1zwo1wSw1-f39-dohzADBNckAzBLBNckSzC3BNf3WEjXC
DTXOGzXPCjXBLDX9-f392iHMAMA1ygDMEsA1yhLMLcA1-dcSNcINNc4bNc4KNcIsNf39-f3aIcwA
NcsAzBI1yxLMLTX92BI1ww01zRs1zgo1wSw1-f39-dshzDXMAMw1zBLMNf3aEjXCDTXNGzXOCjXB
LDX9-f39-f39wRI1wg01zRs1zgo1wSw1zgA1-f39-f393wM1zBI1wg01zRs1zgo1wSw1zgA1-qKI
eTX9-f39-f3dAzXM-rkAPjXCDTXNGzXNCjXCLDXNADXA-qKIeTX91T-9-eM1-f3gAzXL-rkAPjXD
DTXMGzXNCjXBLDXOADX_ooh5NcMUNf3QPzX9-eE-Nf394AM1zP65AD41wg013Ao1wSw1zQA1wP6i
iHk1wxQ1-dA-Nf394T81-f3VHTE1yAM1y-65AD41wg014Cw1zQA1-qKIeTXDFDX90T81-f3hPzX9
-dYdMTXHAzXL-rkAPjX0ADXA-qKIeTXDFDX90T81-f3eP8I1-f3WHTE1yAM1-cMANRI1wxQ1-dI-
Nf393T-DNdAyzDXMI8w1zCbMNfsdMTXHAzX9wgA1wBI1wxQ1-dI-Nf393D-FNc4yzCY1yyPM-gCH
UTXLJsw5NfsdMTXIAzXODcE12yzBNcwANRI1wxQ1-cc-xjXCPzX9-dw-xTXNMswmwDXKI8wPwDXK
Jsw5wDX8HTE1xwM1yv65AD7BDcM1wz-PNcMswzXN-qKIeTXDFDX90z81-f3cP8U1zDLMJsE1ySPM
D8E1ySbMOcE1-B0xNdP_uQA_ww3DP8I1zz-CLMU10RQ1-dQ-Nf393T-DNcwyzCbCNcgjzA-CNcgm
zDnCNfAtNcodMTXREsUNwjXXLMU10RQ1-dQ-Nf393j8fwTXLMswmwzXHI8wPwzXHJsw5wzXxLTXJ
HTE10RLFDcI11yzFP8I1wQDBNf3ePzX9-d4fwzXJI8wmxDXGJswPxDXGD8w5xDXxLTXKHTE1zT-B
EsUNwTXZLMM1wz-AAMM13C41-D81-f3dH8U1yCPMJsQ1xibMD8Q1xg-MOcQ18i011z-BNcISww3B
NdsswTXFAMU12i418R-GNcI-Nf393R-FNcgjzCbENcYmzA-ENcYPzDnENfMtNdQ-wDXGEsE16QDF
NcAUwTXULjX9wD81-f3dH8U1yCPMJsQ1xibMD8Q1xg-MOcQ18y01yzHBNcI-wDX2AMU-FMM10i41
wiE1_j81-f3eH8M1ySPMJsQ1xibMD8Q1xg-MOcQ19C01yTHDNT-ANfkAwzUUxTXRLjXBITX7PzX9
-d8fwTXKI8wmxDXGJswPxDXGD8w5xDX0LTXIMcU1-ADBNcAUxTXQLjXBITX8PzX9-eE-NcojzCbE
NcYmzA-ENcYPzDnENfUtNccxxTX9wxTFPzXOLjXBITX9PzX9-eE-NcojzCbENcYmzA-ENcYPzDnE
NeT_5A2rNdgxxTX9xBTDNcA-wDXLLjXCITX9PzX9-d4UwT81yiPMJsM1xybM-gCHUcM1xw-MOcM1
5v7kDas11x0xwx01-cUUwTXDPzXJLjXCITX9wD81-f3dFMM1yiPMJsI1yCbM-gCHUcI1yA-MOcI1
6P7kDas11D-ANR0xwR01-c8-wDXLITX9wT81-f3cFMU1ySPMJsE1ySbM-gCHUcE1yQ-MOcE16v7k
Das10j81wh3BNf3SPzXJITX0FMY1wj81-f3RMsE1xhTFNckjzCbANcomzP4Ah1HANcoPzDnANez_
5A2rNc8-wDX92z-ANf3MPzX9-dAywzXFFMU1ySPMJjXLJsz_AIdRNcsPzDk17f7kDas1zj81-d8-
Nf3LPzX9-c8yxTXFFMM1yiPMNcwmzDXM-gCHUcw17-7kDas1zD81-eE-IcE1_TLGNcI-Nf39zzLF
NcYUwT81-f3GDzXJP8A1-eIhwzX9xj81-f3INsE1wjLFNck-Nf39xw81xz81-eMhxTX9xT81-f3H
NsM1wjLDNco-Nf390D81-eQhxTX9xT81-f3GNsU1wjLBNcs-Nf39zz81-eUhxTX3NsY1wj81-f3G
NsU1zzHBPzX9-c0PwTX95iHDNT81-cQ-Nf39xjbFNc4xwzX9-cwPwzX5CsE15iHBNcE-Nf3DPzXD
O8E1-f02wzXOMcU1-f3KD8U19wrDNew-NfQxxjXCPzXCO8M1-f02wTXPMcU1-f3KD8U17hvBNcMK
xTXsPzX9wT81wTvFNf390jHFNc82zDXMNsw1zP4prf-MNe4-D8U17RvDNcL_q1I2xTXtPzXyO8Y1
wj81wTvFNf390zHDNc82zDk1yzbMIDXL-imt-8woNe0-NcAPwzXtG8U1wf6rUjbFNe4-Nf0-NcE7
xTX9-dQxwT81zjbMOcA1yjbMIMA1yv4prf-MKMA17D81wg-BNe4bxTXC-qtSNsM18D81-D81wjvD
Nf391CPDNc02zDnBNck2zCDBNcn_Ka3-zCjBNes-NfYbxTXD-qtSNsE18j81_z81wzvBNf391CPF
Ncs2zDnCNcg2zCDCNcj_Ka3-zCjCNes-NfcbwzX7PzXvI8Y1wj81-f3cI8UhNck2zDnDNcc2zCDD
NccKzCjDNeo-NfkbwTX9PzXuIcY1wj81-f3cI8UhNcgVzDnENcYKzCDENcYgzCjENek-NdstwTX9
3z81_T81-f3dI8MhwDXIFcw5xDXGCswgxDXGIMwoxDXoPzXbLcM1-d8-Nfg-Nf393iPBIcA1yRXM
OcQ1xgrMIMQ1xiDMKMQ16D812i3FNf3ePzX4PzX9-d8hwTXKFcw5xDXGCswgxDXGIMwoxDXnPzXb
LcU1-d8-Nfc-Nf394T81yhXMOcQ1xgrMIMQ1xiDMKMQ15j813C3FNf3gPzX2PzX9-d4swT81yhXM
OcQ1xgrMIMQ1xiDMKMQ15j813S3DNf3hPzX2PzX92wfBNfsswzXKFcw5xDXGCswgxDXGIMwoxDXl
PzXfLcE1-eM-NfU-Nf3aB8M1_SzFNckVzDnENcYKzCDENcYgzCjENeQ-Nf39yz816CzGNcI-Nf3Z
B8U1_CzFNckVzDnDNccKzCDDNccgzCjDNeU-Nf39yz816AfGNcI-Nf3ZB8U1_CzFNckVzDnCNcgK
zCDCNcggzCjCNeU-Nf39zT818z81-dkHxTX4HSzDHTXJFcw5wTXJCswgwTXJIMwowTXmPzX9-c0-
NfM-Nf3aB8M1_h0swR01yhXMOcA1ygrMIMA1yiDMKMA15j81-f3PPzXyPzX92wfBNfoKwB3BCsA1
yRXMOTXLCswgNcsgzCg15z81-f3PPzXmCsY1wj81-f3cCsU1yRXMNcwKzDXMIMw15z81-f3RPzXx
PzX9-dwKxTX9_j81-f3RPzXxPzX9-d0KwzX9_j81-f3TPzXwPzX9-d4KwT81-fo-Nf390z818D81
-f3hPzX9_T81-f3VPzXvPzX9-eE-Nf35PzX9-dU-Ne8-Nf394T81-fg-Nf391z817j81-f3eJsE-
Nf34PzX9-dc-Ne4-Nf393SbDNf34PzX9-dc-Ne4-Nf393CbFNc87zDXMB8w1zBDMNd0-Nf392T81
zR-ANdAmxjXCPzXd-qKIecE1-fgmxTXOO8wQNcsHzDo1yxDMKDXdPzX9-dgfwTXJH8E10gDGNcI-
NdwSwzX99ybFNc07zBDANcoHzDrANcoQzCjANd0-Nf3LPzX9yR-DNcUfwTXVFcY1wj812xLFNf32
ACbDADXMO8wQwTXJB8w6wTXJEMwowTXcPzX9wgPBNf3QH8U1wh-ANdgSxjXCPzXbEsU1-fYVACbB
ABU1yzvMEMI1yAfMOsI1yBDMKMI13D81-cEDwzXEPzX9yB-FNeo-NdsSxTX99xUAwRU1yzvMEMM1
xwfMOsM1xxDMKMM13D81-cADxTX9zh-FNeo-NdwSwzX99w3AFcENwDXJB8wQxDXGEMw6xDXGOswo
xDXcPzX9wAPFNcM-Nf3JH8M13w3GNcI-Nd0SwTX99w-BDcM1yQfMEMQ1xhDMOsQ1xjrMKMQ12z81
-cEDxTX90B-BPzXrPzX9-doPww3CNckHzBDENcYQzDrENcY6zCjENds-Nf3CA8M1xD81whLBNf3G
PzXrPzX9-dkPxQ3ANcoHzBDENcYQzDrENcY6zCjENds-Nf3DA8E1yRLDNf3FPzXfD8Y1wj81-f3Z
D8UNPzXKB8wQxDXGEMw6xDXGOswoxDXbPzX9zT81wBLFNf3EPzXrPzXpEME1-ekPxTU-NcoHzBDE
NcYQzDrENcY6zCjENdo-Nf3REsU1-cU-Neo-NegQwzX96Q-DNcA-NcoHzBDENcYQzDrENcY6zCjE
NckHxDXJPzX9zj81wBLFNf3FPzXqPzXnEMU1-ekPwTXBPzXKB8wQxDXGEMw6xDXGOswoxDXPB8M1
xD81-dISwzX9xj813hDGNcI-NecQxTX97z81ygfMEMM1xxDMOsM1xzrMKMM12z81-c4-NcISwTX9
xz816j815xDFNf3vPzXKB8wQwjXIEMw6wjXIOswowjXcPzX9-d8-Neo-NegQwzX98D81ygfMEME1
yRDMOsE1yTrMKME13T813QfBNeo-NcEuwTX9yD816j816RDBNf3xPzXKB8wQwDXKEMw6wDXKOswo
wDXMOsQ1yj813AfDNewuwzX9xz816j81-f3hPzXKB8wQNcsQzDo1yzrMKDXTOsM1xD813AfFNeg-
NS7FNf3HPzXpPzX9-d7_AIdRwT81ygfMNcwQzDXMOsw13z813AfFOsA16C7FNf3HPzXpPzX96v6r
UjbBNewPwzX98z813AfFOsE15T81LsU1-cc-Nek-Nf3pCsM16g-FNf3yPzXdB8M6wzXnLsM1-cg-
Nd0PxjXCPzX96ArFNekPxTX98j813gfBOsQ1zBDBNdM-NcEuwTX9yT813QrGNcI-Nf3oCsU16Q-F
Nf3yPzXgOsU1yxDDNf3kPzXpPzX96ArFNeoPwzX94hDJNcQ-NeE6wzXLEMU1zDvBNcA-Nf3PPzXp
PzX96QrDNewPwT81-fM-NeI6wTXMEMU1yzvDNf3RPzXpPzX96grBNfA-Nf3zPzXzEMU1PzU-NT81
PzU-NT87xT81PzU-NT81PzU-NT81PzU-NT81PzU-NT819T816T81-f3hPzX98z819BDDNcs7xTX9
0D816T81-f0gwTXa-rkAPsE-NdA-zDXMMcw1zB3MNdk-NfUQwTXMO8U-Nf3PPzXpPzX9-CDDNdgS
wzXPP8wdNcsxzBA1yx3MOjXZPzX9yTvDNf3RPzXpPzX9_yDFNdYSxTXNP8wdwDXKMcwQwDXKHcw6
wDXZPzX9yjvBNcA-Nf3PPzXdEsY1wj81-fsgxTXWEsU1zD-MHcE1yTHMEME1yR3MOsE12T81-f3h
PzXpPzX9_yDFNdYSxTXLP8wdwjXIMcwQwjXIHcw6wjXZPzX9zz81-c8-Nek-Nf38IMM12BLDNcs-
zB3DNccxzBDDNccdzDrDNdk-Nf394T816T81-f0gwTXaEsE-NcoxzB3ENcYdzBDENcb_5A2rzDrE
Ndk-Nf3PPzX9zz816T81zS7BNf06wTX9yz81yjHMHcQ1xh3MEMQ1xg-MOsQ12j81-f3fPzXqPzXM
LsM1_zrDNf3KPzXKMcwdxDXGHcwQxDXGD8w6xDXaPzX9zj81-c4-Neo-NcsuxTX5OsU1-ck-Ncox
zB3ENcYdzBDENcYPzDrENdo-Nf393z813jrGNcI-NcsuxTX5OsU1-ck-NcoxzB3ENcYdzBDENcYP
zDrENdo-Nf3OPzX9zj816j81yy7FNfk6xTX9yT81yjHMHcQ1xh3MEMQ1xg-MOsQ12j81-f3fPzXq
PzXMLsM1_zrDNf3KPzXKMcwdxDXGHcwQxDXGD8w6xDXaPzX9zj81-c4-Neo-Nc0uwTX9OsE1-cs-
NcoxzB3ENcYdzBDENcYPzDrENdo-Nf391DLBNcY-Neo-Nf394T81yjHMHcM1xx3MEMM1xw-MOsM1
3D81-c0-Nf3CMsM1xD816z81-e4twTXsPzXKMcwdwjXIHcwQwjXID8w6wjXdPzX9-dEyxTXDPzXr
PzX97S3DNes-NcoxzB3BNckdzBDBNckPzDrBNd4-Nf3NPzX9wTLFNcM-Nes-Nf3sLcU1yTnBNdw-
NcoxzB3ANcodzBDANcoPzDrANd8-Nf390TLFNcM-Nd8txjXCPzX95RvBNcItxTXIOcM12z81yjHM
HTXLHcwQNcsPzDo14T814ijBNeM-Nf3CMsM1wz817D81-eQbwzXBLcU1xznFNdo-NcoxzDXMHcw1
zA-MNeI-NeEowzX96DLBNcQ-NeA5xjXCPzX94xvFNcEtwzXIOcU12j81-fY-NeAoxTXhPzX9zD81
xDLANdgbxjXCPzX94xvFNcItwTXJOcU12j81-fY-NeAoxTX98D81xjLCNeA-Nf3jG8U10TnDNds-
Nf33PzXfKMU14T81-cs-NcsywTXdPzX95BvDNdM5wTXcPzX99z814CjDNf3wPzXOMsA12z81-eUb
wTX1PzX99z814SjBNf3xPzXtPzX9-eE-Nf34PzX9-dc-Ne4-Nf394T81-fg-Nf391z817j81-f3h
PzX9_D81-f3XPzXuPzX9-eE-NdA-zDXMO8w1zP6iiHnMNd8-Nf390SPBNT817z81-f3hPzXPP8wS
Ncs7zC41yxLMAzXfPzX9-dAjwz817z816APBNf3yPzXOP8wSwDXKO8wuwDXKEswDwDXgPzX9-c4j
xTXvPzXnA8M1-fE-Nc0-zBLBNck7zC7BNckSzAPBNeA-Nf39ziPFNe8-NeYDxTX98D81zD-MEsI1
yDvMLsI1yBLMA8I14T81-f3NI8U14wPGNcI-NeYDxTX98D81yz-MEsM1xzvMLsM1xxLMA8M12DvA
NcU-Nf39ziPDNfA-NeYDxTX98D81yjvMEsQ1xhLMLsQ1xi7MA8Q11jvANcg-Nf39ziPBNfE-NecD
wzXqKME1-cI-Nco7zBLENcYSzC7ENcYuzAPENdQ7wDXKPzX9-comwTXAPzXFIzXqPzXoA8E16ijD
Nf3BPzXKO8wSxDXGEswuxDXGLswDxDXSO8A1zT81-f3IJsM-NccjwDXoPzX92CjFNf3APzXKO8wS
xDXGEswuxDXGLswDxDXQO8A1zz81-f3HJsU1ySPANdooxjXCPzX92CjFNf3APzXKO8wSxDXGEswu
xDXGLswDxDXkPzXSIME1-e0mxTXLI8A15D81-dgoxTX9wD81yjvMEsQ1xhLMLsQ1xi7MA8Q15D81
0SDDNf3sJsU1zSPANeI-Nf3ZKMM1-cE-Nco7zBLENcYSzC7ENcYuzAPENeU-Nc8gxTX97CbDNdAj
NeE-Nf3aKME1-cI-Nco7zBLENcYSzC7ENcYuzAPENeY-Nc4gxTX97SbBNfU-Nf394T81yjvMEsM1
xxLMLsM1xy7MA8M15z81ziDFNf3uPzX2PzX9-eE-Nco7zBLCNcgSzC7CNcguzAPCNeEoNcU-Nc4g
wzX96f4Ah1HBNcA-NcYmNe4-Nf394T81yjvMEsE1yRLMLsE1yS7MA8E14CjANcc-Nc4gwTX96Q-D
PzXIJsA17D81-f3hPzXKO8wSwDXKEswuwDXKLswDwDXgKDXJPzX9_w-FNcomNes-Nf394T81yjvM
EjXLEswuNcsuzAM13yjANcs-Nf36D8U1yybANek-Nf394T81yjvMNcwSzDXMLsw13yg1zj81-fkP
xTXNJsA15z81-f3hPzX98SjANdA-Nf35D8M10CY1yz81wT811D81-f3hPzX98Cg10j81-foPwTXf
PzU-NT811D81-f3hPzX9-cg-Nf35PzXhP8M11D81-f3hPzX9-ck-Nf33PzX9PzX9-eE-Nf39yj81
-fU-NcYPNdo-NcE-NdQ-Nf394T81-f3LPzX98z81yA812T81wT811D81-f3hPzX9-cw-Nf3xPzXK
D8A12D-BNdU-Nf394T81-f3NPzX97z81zQ818T81-f3hPzXQKMw1zCjMNcwozDXyPzX97T81zw81
1j-CNdQ-Nf394T81zyjNNcsozTXLKM018z81-es-NdEPwDXTPzXYPzX9-eE-Nc4ozjXKKM41yijO
NeogNcc-NfY5wTXsPzXUDzXSP8M11D81-f3hPzXNKM81ySjPNckozzXpIDXJPzX0OcM16j81-cc-
Nf394T81zCjQNcgo0DXIKNA15yDANcs-wDXB-imt-8E16znFNec-wDXrP8M11D81-f3hPzXLKNE1
xyjRNcco0TXmIDXPPzUKwzXqOcU15j817T81PzXWPzX9-eE-Ncoo0jXGKNI1xijSNeUgNdEKxTXi
NsE1wjnFNeU-Ne4-wzXUPzX9-eE-Ncoo0jXGKNI1xijSNeMgwDXSCsU14TbDNcI5wzXkP8A1-cw-
Nf394T81yijSNcYo0jXGKNI14iA11ArFNeA2xTXCOcE15D818j-CNdQ-Nf394T81yijSNcYo0jXG
KNI1_grDNeE2xTXpP8A18j812D81-f3hPzXKKNI1xijSNcYo0jX7CsE1PzXgNsU16D819D-DNdQ-
Nf394T81yijSNcYo0jXGKNI1-cI-wDXfNsM15z-ANf3SPzX9-eE-Ncoo0jXGKNI1xijSNf3EP8A1
3jbBNeY-wDX3PzXBPzXUPzX9-eE-Ncoo0jXGKNI1xijSNf3GP8A1-cc-wDX5P8M11D81-f3hPzXK
KNE1xyjRNcco0TX6CjXKP8A19RXBNcc-wDX7PzXBPzXUP-394zXKKNA1yCjQNcgo0DX6CjXNP8A1
8hXDNcQ-wDX9-f39zSjPNckozzXJKM811z814Qo1zz-ANe8VxTXBP8A1-cE-wzX9-f3HKM41yijO
NcoozjXXP8E13wo10j-BNewVxT-BNf3DP8A1-f39yijNNcsozTXLKM011z-DNd0KNdY-wTXpFcU1
-cY-wzX9-f3HKMw1zCjMNcwozDXaPzXfCjXZP8I15T8VwzX96Ts1xy41zRI1yAMQNeM6NcYoBzXH
GzXC-qtSNjXBLTXMIDk1xTY1xjI1x-7kDas1wCwfNf3vPzXe-imt-zXeP8I13T-CNcAVwTX9yD-D
Nds7NccuNc0SNcgDEDXjOjXGKAc1xxs1wv6rUjY1wS01zCA5NcU2NcYyNccPNcAsHzX97z813f4p
rf814z-FNc8-xTX91T812zs1xy41zRI1yAMQNeM6NcYoBzXHGzXC-qtSNjXBLTXMIDk1xTY1xjI1
xw81wCwfNf3wPzXc-imt-zXqP881-dg-wjXcOzXHLjXNEjXIAxA14zo1xigHNccbNcL_q1I2NcEt
NcwgOTXFNjXGMjXHDzXALB81-fA-Ndv_Ka3-Nf39_js1xy41zRI1yAMQNeM6NcYoBzXHGzXC-qtS
NjXBLTXMIDk1xTY1xjI1xw81wCwfNf3wPzX9-fo-Nds7NccuNc0SNcgDEDXjOjXGKAc1xxs1wgo1
wS01zCA5NcU2NcYyNccPNcAsHzX98T81-ewVNf3KPzXbOzXHLjXNEjXIAxA14zo1xigHNccbNcIK
NcEtNcwgOTXFNjXGMjXHDzXALB81-cE-0zXZPzX97BU1-cY-wzXbOzXHLjXNEjXIAxA14zo1xigH
NccbNcIKNcEtNcwgOTXFNjXGMjXHDzXALB81-cA-NdM-Ndk-Nf3rFTX9-f39-cg-NdU-Ndk-Nf3r
FTX9-f39-cc-NcE-wDU-NcE-wTU-wTU-wDXBPzXaPzX9yjY1yTk10RU1-f39-f3HPzXAPzXBPzXB
PzXBPzU-NT81PzXAPzXbP8A1xD81-cE2Nck5NdEVNf3HPzX9-f37PzXAPzXBPzXBP8A1wD-BNT-A
NcE-Nd0-wTXBP8A1-cA2Nck5NdEVNf3GP8E1-f39_j81wD81wT81wT81wT81PzU-NT81wD814D-E
Nf02Nck5NdEVNf3FP8M1-f39_T81wT-ANT-BNT-BNT81PzU-NT81wD814z-ANf3ANjXJOTXSFTX9
xj81-f39_z811T814z81-cE2Nck5NdIVNf3GPzX9-f38PzXTPzX96DY1yjk10RU1-cY-Nf39-f0-
0zXRPzU-NT81PzU-wTX9yzY1yjk1-do-NcM-NcQ-wDU-wTU-wTU-NT81P8E1P8E1P8E1P8E1wD-A
NT-ANf39-fQ-NT81PzU-NT81-c02Nco5Nf3aPzXDP8A1wj81wT81PzXAPzXAPzU-NT81PzU-NT81
wD81wT81wD81PzU-NT81-f398z-BNT81PzU-wDX9zDY1yjk1-do-xzXBP8E1P8E1wD81wD81PzU-
wDXAP8E1wD81wT81wD81PzU-NT81-f398z81PzU-NT81PzX9zTY1yjk1-eA-wDXEPzU-NT81wD81
wD81PzU-NT81PzU-NcA-NcE-NcA-NT81PzU-Nf39-fM-NT81wD-ANT-BNf39_z81wz-ANcA-NT81
wD81wT-ANT81PzU-NT81wD81wD-BNT-ANcA-NT81-f39-f39-f39-f3dAAAAAAAAAAE=
:: main.lua
--[[pod_format="raw",created="2024-03-31 05:33:06",modified="2025-03-10 21:30:55",revision=7104]]
include "src/globals.lua"
include "src/oklab.lua"
include "src/palette.lua"
include "src/settings.lua"
include "src/files.lua"
include "src/integration.lua"
include "src/soft_wrap.lua"
include "src/gui.lua"
include "src/gui_palette.lua"
include "src/gui_sliders.lua"
include "src/gui_settings.lua"
include "src/gui_help.lua"
include "src/gui_newfile.lua"
include "src/gui_hexdialog.lua"


function _init()
	load_settings()
	
	register_as_default_app()

	window {
		tabbed = true,
		icon = --[[pod_type="gfx"]]unpod("b64:bHo0ABYAAAAUAAAA8AVweHUAQyAICARwtyBHIBcgRyC3cA=="),
	}
	
	local working_file_path = env()[1]
	if type(working_file_path) ~= "string" then
		mkdir("/ram/cart/pal")
		working_file_path = "/ram/cart/pal/0.pal"
	end

	wrangle_working_file(
		save_working_file,
		load_working_file,
		working_file_path
	)
	
	-- Force the 11 first rows of the screen to use a default palette,
	-- so that the menu bar stays readable even when the colors used by
	-- the gui are redefined.
	poke(0x5400, 0b01010101, 0b01010101, 0b00010101)
	
	rebuild_pal()
	
	on_event("gained_visibility", function() send_palette() end)
		
	on_event("drop_items", handle_drop_items)
	
	undo_stack = create_undo_stack(undo_save_state, undo_load_state)

	menuitem { id = "okpal_div1", label = "", divider = true, action = function() end }
	menuitem {
		id = "okpal_reset_colors",
		label = "\^:0000000000000000 Picotron Palette",
		action = function() undo_stack:checkpoint(); restore_default_palette() end
	}
	menuitem {
		id = "okpal_clear_colors",
		label = "\^:0000000000000000 Empty Palette",
		action = function() undo_stack:checkpoint(); clear_colors() end
	}
	menuitem { id = "okpal_div2", label = "", divider = true, action = function() end }
	menuitem {
		id = "okpal_manual",
		label = "\^:0000000000000000 Help",
		shortcut = "F1",
		action = open_help
	}
	
	test_cube_colors = test_cube_colors or copy(default_test_cube_colors)
	test_ramp_colors = test_ramp_colors or default_test_ramp_colors:convert("u8")
	generate_gui()
	
	if is_new_file then
		open_new_file_dialog()
	end
	
	if imported_hex_file then
		open_import_hex_file_dialog()
	end
end


function _draw()
	cls(bg_color)
	gui:draw_all()
	blinked()
end


function _update()
	if padlock_flashing then
		padlock_flashing_time += 1
	end
	if crying_a_timer > 0 then
		crying_a_timer -= 1
	end
	
	if gui_changed then
		generate_gui()
		gui_changed = false
	end
	gui:update_all()
	
	if key("ctrl") then
		if keyp("c") then copy_color() end
		if keyp("x") then cut_color() end
		if keyp("v") then paste_color() end
		if keyp("z") then undo_stack:undo() end
		if keyp("y") then undo_stack:redo() end
	end
	
	if keyp("f1") then open_help() end
end




-- Undo ---------------------------------------------------------------------------


function undo_save_state(_item)
	return {
		pal_okhsl = copy(pal_okhsl),
		pal_code = copy(pal_code),
		test_cube_colors = copy(test_cube_colors),
		test_ramp_colors = test_ramp_colors and test_ramp_colors:convert("u8"),
	}
end


function undo_load_state(state, _item)
	pal_okhsl = state.pal_okhsl
	pal_code = state.pal_code
	test_cube_colors = state.test_cube_colors
	test_ramp_colors = state.test_ramp_colors
	for c = 0, 63 do
		set_color(c, pal_code[c])
	end
	send_palette()
end


function copy(t)
	if type(t) == "table" then
		local new = {}
		for k, v in pairs(t) do
			new[k] = copy(v)
		end
		return new
	else
		return t
	end
end


-- Copy and paste ----------------------------------------------------------------


function copy_color()
	if active_color then
		set_clipboard("#" .. color_to_hex(get_color(active_color)))
	end
end


function cut_color()
	if active_color then
		set_clipboard("#" .. color_to_hex(get_color(active_color)))
		if not locked[active_color] then
			 undo_stack:checkpoint()
			change_color_code(active_color, 0x000000)
		end
	end
end


function paste_color()
	if not active_color then
		notify("unable to paste: no selected color")
		return
	end
	if locked[active_color] then
		notify("unable to paste: selected color is locked")
		return
	end
	local cb = get_clipboard()
	if type(cb) == "string" then
		local hex = string.gsub(cb, "%s", "")
		if sub(hex, 1, 1) == "#" then
			hex = sub(hex, 2, -1)
		end
		local code = tonumber("0x" .. hex)
		if type(code) == "number" then
			undo_stack:checkpoint()
			change_color_code(active_color, code)
		else
			notify("unable to paste: unrecognized string: \"" .. cb .."\"")
		end
	else
		notify("unable to paste: type not supported (" .. type(cb) .. ")")
	end
end

:: manual.txt
--[[pod_format="raw",created="2024-04-04 06:47:16",icon=userdata("u8",16,16,"00000101010101010101010101000000000106060606060606060606060100000107010606060606060606060606010000010106060707070707070707060100000106060607070707060606070601000107010606070707070606060706010000010106060706060607070707060100000106060607060606070707070601000107010606070707070707070706010000010106060606060606060606060100000106060606060606060606060601000107010606060606060606060601010000010101010101010101010101070100000101070707070707070707070601000000010606060606060606060601000000000001010101010101010101000000"),modified="2025-03-08 10:15:57",revision=440,stored="2024-04-04 06:56:33"]]
# OkPal

OkPal is a tool to create and edit color palettes. You can easily use those palettes in your programs, and even directly in Picotron's sprite and map editors.

To use a palette in your programs:

```
    fetch("pal/0.pal"):poke(0x5000)
```


## Features

- Any change to the palette is propagated to
  Picotron's sprite and map editors.
- Use a perceptually uniform color space (oklab).
- Choose colors by hue, saturation and lightness.
- Reorder colors by drag-and-drop.
- Undo/redo.
- Supports two file formats: ".hex" and ".pal"
- Multiple options for importing external palettes
  (keep default palette, overwrite it, or try to 
  match it)


## Usage

The tool shows you four different views of the 64
colors in the current palette:

- at the top-left of the screen, the colors are
  shown in palette order (same as in sprite editor
  first tab);
- below, on the left, the colors are shown inside
  a circle picker: the angle correspond to the hue,
  and the distance from the center correspond to the
  saturation;
- in the middle the colors are shown as inside a
  square picker: the X axis correspond to the
  saturation, and the Y axis correspond to the
  lightness;
- finally, on the right is a "test zone", where
  you can use 24 paintable cubes to test color
  combinations.

To modify a color, you must first select it. You can
do that either by clicking in the palette overview
at the top of the screen, or by clicking directly on
one of the color dots in the circle picker or in the
square picker.

Once selected, some information about the color are
displayed on the right of the palette overview:

- the color number;
- the hex code corresponding to the RGB values of
  the color;
- a padlock icon: if the padlock is closed, the color
  is "locked" and cannot be edited; click on the icon
  to lock/unlock it;
- an eye icon: if the eye is closed, the color is only
  shown in the palette overview; it is hidden in the
  circle and square pickers.
- a paint bucket icon: you can click on it to change
  the color background to the current selected color;
  click again to go back to a black background.

You can copy the current color by using Ctrl-C, and
paste a copied color onto the current one by using
Ctrl-V. This also works outside OkPal: the color is
stored in the clipboard as a hex code ("#ffacc5").

There is five different ways to adjust the selected
color:

- a small colored circle *outside* the circle picker
  allows you to change the hue of the color;
- a small colored circle *inside* the circle picker
  allows you to change at the same time the hue and
  the saturation;
- a small colored triangle below the square picker
  allows you to change just the saturation;
- a small colored triangle at the right of the square
  picker allows you to change the lightness;
- finally, a small colored circle inside the square
  picker allows you to change at the same time the
  saturation and the lightness.

Any change you make can be reverted by hitting
Ctrl-Z for undo. Use Ctrl-Y for redo.

Once you have several colors in you palettes, you can
reorder them in the palette overview: just drag one
color onto another, they will swap their positions.
Note that both colors must be unlocked.


## Using the palette in cartridges

By default, the palette you edit is saved in the
cart you're working on, alongside your sprite sheets
and maps.

The default path is "/ram/cart/pal/0.pal"

In order to use a palette in your programs, you just
need to copy it in memory. The default palette is
stored at address 0x5000:

```
    fetch("pal/0.pal"):poke(0x5000)
```


## Loading and saving

If you only need one palette for your cart, you
don't need to do anything special to save it. It is
saved alongside the rest of your assets each time
you hit Ctrl-S.

In order to create a new palette, use the '+' button
at the right of the tabs and choose the name of your
new palette, for example "1.pal". If you need to
start from scratch for this new palette, use
"Empty Palette" or "Picotron Palette" from the menu.

You can load a previously created palette by using
"Open File" in the menu.


## Importing and exporting

You can import and export palettes for use with
external tools. Currently the only supported format
is ".hex" files, which are simple text files with one
line per color, represented by their RGB code in hex
format (without "#" or "0x", just the hexadecimal
numbers).

To import a palette, choose "Open File" from the
menu, and select the ".hex" file. If this is the first
time you open this external palette in OkPal, a
dialog will appear to let you choose how to arrange
the colors in the palette. You can either:

- Keep default Picotron palette in the first 32 colors,
  and put the imported colors in the last 32 slots.
- Completely remove the Picotron palette and import
  the whole palette, but reorder the colors to try
  to match the default colors.
- Or simply import the palette as is. Note that this
  will affect the interface and probably make it
  difficult to use the menu, the sprite editor and
  the map editor.

To export a palette, choose "Save File As" in the
menu. In the save dialog, enter a file name ending
in ".hex".


## Changelog

2025-03-08: version 1.1.0 (release #okpal-8)

- removed remapping option when importing ".hex" palettes (was not working very well anyway);
- added text entries for the hex code, the hue, the saturation and the luminance;
- added a new tab for drawing color ramps in the test zone;
- added dialog when creating a new palette (to choose between empty palette or default colors);
- added settings dialog;
- added settings to register OkPal as default app for ".pal" and ".hex" files;
- added settings for disabling the propagation of the palette to the sprite and map editors;
- added blink;
- changed dialog when importing ".hex" files;
- changed dialog for displaying help;
- fixed menu bar colors when default colors are redefined;
- fixed undo/redo of test cube color changes;

2025-02-26: version 1.0.4 (release #okpal-7)

- added registering as default app for ".pal" and ".hex" (needed for the file dialog?)
- added undo/redo and help buttons;
- added "clear" button to the "test cubes";
- added legends for the two pickers;
- changed: moved the luminance slider to the left of the sat/lum picker for consistency;
- fixed: palette is now propagated to all gfx and map editors (thanks to Eiyeron for the implementation);
- fixed: the "test cubes" saved in metadata where not properly loaded;


2024-08-23: version 1.0.3 (release #okpal-6)

- added: add file icon to saved palettes;
- changed: can load and import palettes by
  double-clicking in the file dialog (no need
  to drag-and-drop anymore);
- fixed: bug in BBS;

2024-05-03: version 1.0.2 (release #okpal-5)

- fixed: bug while using "+" button in Picotron
  0.1.0g;
- changed: disabled tabs in BBS, as it prevents
  the cart from running;

2024-04-27: version 1.0.1 (release #okpal-4)

- fixed: picotron's palette was not locked in the
  default file on first opening;
- fixed: saving a ".pal" file from an imported
  ".hex" file was not working;
- explain how to export to .hex in the manual;

2024-04-06: version 1.0.0 (release #okpal-3)

- propagate palette to sprite and map editors;
- undo/redo;
- reorder colors by drag-and-drop;
- import dialog;
- reorder imported colors to match default colors;
- added a manual;
- menu entries to initialize the palette and open
  the manual;
- flash padlock icon when trying to edit a locked
  color;
- shift-click paint-bucket icon to change the "white"
  color used in the interface, and ctrl-click the
  icon to change the "black" (useful when importing
  external palettes);

2024-04-02: version 0.0.3 (release #okpal-2)

- Added the ability to change the background color (by clicking on the small paint bucket icon), and switched the default background to black.
- Added the ability to import ".hex" files (using drag and drop from the "Open File" dialog); to actually create the ".pal" file, you need to save.
- Improved the color pickers.
- Added the ability to copy/paste colors (using a hex string starting with #).
- Added the ability to show/hide individual colors (right click on a color in the palette).

2024-04-01: v0.0.1 (release #okpal-1)

- Added the ability to lock colors, to avoid accidentally modifying them. By default the first 33 colors are locked (click on the padlock to unlock)
- Added the ability to hide specific rows of color from the two color pickers.
- Added sliders to change the individual components (hue, saturation and luminance).
- Added the ability to select a color by clicking on their dot in the color pickers.
- Added a test zone, with 24 paintable cubes (click on a cube face to change its color).


:: todo.txt
--[[pod_format="raw",created="2024-03-31 20:08:43",modified="2025-03-07 09:36:51",revision=884]]
- right click for fine-tuning colors;

Maybe:
- in-app gui for manual?
- multi-selection (ability to move a group of
  colors in the sliders)
- editing tools for multi-selection;
- Add another tab in the test zone, with the 
  hue/sat circle and sat/lum square, but filles
  with color zones instead of dots.
- remove locking mechanism?
- import the palette from an image saved by
  the #paint cartridge;

:: .info.pod
b64$LS1bW3BvZCxhdXRob3I9ImRyYWttYW5pc28iLGJic19pZD0iX2Rldjk3MiIsY3JlYXRlZD0i
MjAyNC0wNC0yNyAxMjozMDo1NCIsaWNvbj11c2VyZGF0YSgidTgiLDE2LDE2LCIwMDAwMDAwMTAx
MDEwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDAw
MTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwNzAxMDAwMTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwZDBk
MDcwMTAxMDcwZDBkMDEwMTA2MDYwNzA3MDYwNjBkMGQwNzAxMDEwNzBkMGQwMTAxMDYwNjA3MDcw
NjA2MGQwZDA3MDEwMTA3MGQwZDA2MDYwZDBkMDEwMTA3MDcwZDBkMDcwMTAxMDcwZDBkMDYwNjBk
MGQwMTAxMDcwNzBkMGQwNzAxMDEwNzBkMGQwNzA3MDYwNjA3MDcwMTAxMGQwZDA3MDEwMTA3MGQw
ZDA3MDcwNjA2MDcwNzAxMDEwZDBkMDcwMTAxMDcwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwNzAx
MDEwNjA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwNzA2MDEwMTA2MDYwNzA3MDcwNzA3MDcwNzA3MDcw
NzA2MDYwMTAwMDEwNjA2MDYwNjA2MDYwNjA2MDYwNjA2MDYwMTAwMDAwMDAxMDYwNjA2MDYwNjA2
MDYwNjA2MDYwMTAwMDAwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAwMDAwMCIpLG1vZGlmaWVk
PSIyMDI1LTAzLTEwIDIxOjMwOjU1Iixub3Rlcz0iUGFsZXR0ZSBFZGl0b3Jcbih1c2UgbWVudSB0
byBvcGVuIHRoZSBtYW51YWwpIixydW50aW1lPTE0LHNhbmRib3g9ZmFsc2Usc3RvcmVkPSIyMDI0
LTA0LTE0IDEwOjMwOjA0Iix0aXRsZT0iT2tQQUwiLHZlcnNpb249IjEuMC4zIix3b3Jrc3BhY2Vz
PXt7bG9jYXRpb249InNyYy9nbG9iYWxzLmx1YSM5Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0
aW9uPSJtYWluLmx1YSM5NyIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ic3JjL2d1aS5s
dWEjMzM2Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJzcmMvZ3VpX3BhbGV0dGUubHVh
IzI4NSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ic3JjL2d1aV9zbGlkZXJzLmx1YSMy
MTMiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImdmeC8wLmdmeCIsd29ya3NwYWNlX2lu
ZGV4PTJ9LHtsb2NhdGlvbj0ibWFwLzAubWFwIix3b3Jrc3BhY2VfaW5kZXg9M30se2xvY2F0aW9u
PSJzZngvMC5zZngiLHdvcmtzcGFjZV9pbmRleD00fSx7bG9jYXRpb249InBhbC8wLnBhbCIsd29y
a3NwYWNlX2luZGV4PTd9fV1d
:: [eoc]
