picotron cartridge // www.picotron.net
version 2

:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA3Iixtb2RpZmllZD0iMjAyNS0w
My0yMyAxNjoxMjozOCIscmV2aXNpb249OTExMF1dbHo0AIFDAAAdogAA9iN7WzBdPXtibXA9cHh1
AEMgCAgEcLcgRyAXIEcgt3AsZmxhZ3M9MCxwYW5feD0tMS44MwEAETcXABB5FwAnNDICAKcsem9v
bT0xMX0sWQDxCAwMBDAncAcgB2AHoAegB5BnQGdAJwAnBAA7Z-ALagBGNi4xNgEAFDNpADcwLjMB
ACIyN2oAHDdpACPwDGoAPyAHUGgAS-8SN2BXQHcgFwAXAAcAFxAHEDcQByAHEBcQB0AHMAdgN-AM
cAA3nw0JBACnEAeNBwQABi_nAG4AN-EGCQkEMAdgBw0HQActByAHTQcAB20XAgA-BwBnaAA78AMA
NzAHMAcgB0AHEAdQBwAHYBcGAAAOAF8wBzA3MGwAOikQR8wAAM4AbwdNByBHEGYAN-8KGBgE8Cja
gNoPGXDaHmDaLlDaPkDaTjDZXgMABPsCTkDZPlDZLmDZHnDZDoDZ8CiLABMwfQASMG0ADVYD-wjw
GwewB7AHUGcwBwBHQAcQJ1AHIAfwDEYACx84RgAFAbkCEgCOAQ9KACCjCwsE0E5AbiCOEAIAXCBu
QE7QQgBELjEyNUYAAQwAAUoALDEwSwDjIEdAB04HIAduBwAHjhcCAM8HAAduByAHTgdARyBZAHtU
QEAE8P8BANG-B-AuJ-AsR-AtB-AvAwAaMAkAFTADAPIGF1AH8CknIBfwK1fwLRfwLgfwWwcAAgBT
J-AlBwACADHwJycJAFUX8CYHABQAUAcABxAXKAAPswATHzOyAAEQs1UAEixRAG4sFwAH8GsRAEIg
B-ArEQDRK0fwbDfwKwfwL0fwawYAQSsH8G-pABAtEgBAEBfwKy8AIyw3NwASRxAAEW-3AE0rR-Dt
GwGSLwdAB1AXACcA4gASJwIAgBAXABfQB0AXHQR1AAcQBxAHAAIAAWgFAxAAMMCHIC4AAhAAOBcQ
JxwAIfADTgQPPwAJYvADB0AXEBUAJRcAIQAxECcAFgAfoFkBIfAOEBAEELcgB7AHAAfQF9AXUEcg
F0AnEBcQFzAnMAcGAJFgFxBnQBcgR1AMAP8AQAdwF9AX0AcAB7AHILcQcgATHzFyAADxBNcA9xdA
lyAXEHcgNwB3IKdgl0AVAD8ZANdYACglBwACAJEwB7AH8AAX8AYOADEgF0AtBBFwtwURQPAAAAIA
MUAXIAgAE7AYAEDwCBfwDgAAWwQFYgEP5gAnBVgBAEABQBAXECfAAbEwJzAXYCcwF0BnEHABAAwA
P3AHQFgBNrYUQJcQFyCHADcgx1gBHxZYAT0RAw4AMVAXEPQCALoAAMYAEbAWAADqAwLNAhOwGAAv
8AVYATSDBTME8B0HABdFABAXgAcKDgABGwPhV1BHMEdABzBXgEcQBxBuBv8BIAcAN0AHIGcgB4AH
MFfwEy4DIQB_ABAKWgA2NwAHUAABaAAgVwBoAAAbBAAIAEZHMEdQFgAJogAPegAjCVACQVAXUBfM
CfMBFyAXIHcgFzBXMBcQNxA3EAYAABAAABgABCQAADAAD1wCHR8zXQIDMAcQp6EEcRB3cIdQdzBq
AGEwd1CHcHcWAG_nEPcHANdlACgv8PCfACgDHgEB-gAwJxAnAAHzAjAXIBeAFyAXcBcwF2AXQBdQ
AgAf0BQBOTAFUIeIAWEQNxDXEMcCAE-XEPcOCwFkAKMCH_9iAiEyCwUEpAI1BwA3owMDyQcmAAdv
BgLHBw9iABMZNmIAoBkLBBD3BSAH8AXNBhAHnwIQBxEHAKMCAEcEAAIABD8EARAALxcQHAACFiCB
BwEQACDwB1AAbwUHIPcFEBAJIgOZAJD3BwD3DRAHACdtAEcQZwAnZwASV_gHDRgAJ2cQmwBfAPcM
APeHACf0BVQMBFD3B0D3CPAP9wkgB-AIB-AOCQCyDfcLAAfwCgfwDEeOBQEfAWM3AAcwJwBDAVUg
B-ALR5kAAJ0IImdACgAUBxYAQ1AH8AojAADkBzAgR0BjAQOOCEAwB-AJ5wATBwIAOEcAV68FAFwF
ACEHE2edASAHEMkLBwIAECAfCoIH9xHwDAfwBgcAOwX3RAoBVDMzLjg3CwFWLTcuMTTADAOmDB8y
FQEFlAfwBwcg9wrwDgkAQA0H8Al1AULwDAcwpAIDpQEyAEcgowB2JxA38AsHMKIBAGoPElcKABQA
FgA0Z-AKIwABpQchMFdEAAElAWQgR-AJB0AqAAEFARUwQAAEJwEg8AgJBwKWAioXQB8AwicQZ-AH
B-AM9xHwBgcADxUBMPADIg8E8BT3DiAH4PcAAAfwAPcCBADxAxCnIDcgF0A3EKcgJ0AHQDfwAAcA
BA8ABB8AAy8AIAEAPgBfIPcO8BSuAhMfOIMAAnL3AOAHAPcBVQDxAzegJzAnEEcQN6AnIEcARxD3
AgcABA8ABB8AIvcCLwAgBwA_AA_DACZfVAwE8AoxAwaQdyAnYFcAB1DHtAEg8Ay3AxAXrQEABgMR
oMkBUfALZwBHwgEQZ_wRAh8DDhMAIwl3EwASdzkAU2AH8AiHTgAGEwC0B6cgJ2CHQMcAB3D-AgMC
Aiv3Pt0A8wAxNy40NDY0Mjg1NzE0MjnnAMAtNC42NDg4MDk1MjMGAA5CBQryAA8OAwAwYCcg8wOR
Z8AHAFfwDAdQPAwAtgNAAGcAp8UEIfALOQ8A-QBDUHcAp-wCDRMAOgkHYBMAU3fwCAdwTgAFEwAw
BweQcABTh8AHAIfcAg-yAD8PvRIiD28FEwBbAE8jVzCXUQA6cS0HcAcQJzBuCh8ATwA0AXsBH1BN
ACqXKGoBAAAJAAAA_Q9P----tpkAIgGTBZEA8DMH8AAH8DIGAEAxB-ACJBAVMG0GEiAtDwILAAA3
DEDwLgdAqAYAeQM1LQdQGgBlQAfwLAdQOAAQQL8PAMEDESoGAD8p90SkABMdMu8AEAXvABEAmAUR
wJoFJIAXKwdDACfwEnIAEyA7BhKwHQByJwAX8BYXAB0AERfKEBEgDQARoAYAExCzCBGgrAABMABz
ByAn8AInANAAFeDYADtgBwACAEMgB-AUCQASIFYAALYPJQcgFAAQACEAAg8AAgIAA0ERAhMAEMCR
BgMNEBEgiA0bAAIANSAH8MQJQCcAF9DOBgSKAATpB1EHIBfwEzIQCYQAIxcQLQAi8BSUCQF_ACIX
ECQAKBewfABlFyAHsCcAVQBBIBfwAzsAACsADwABCQACACPwFuwAAXwAAlYBIwcAFAABfgACNAIO
-gAEOBED-AACFgAEOgAC_AAAwwAiJ8D_AAC5ECYHAAIAECf0ASInAAIAKRcQwgFSAAfwFRcJAAJ4
AAFHCDIAJ7BcEQAOACQHsGMIAR8BIPACCwALmgI3MTMxnAJHMi4yMIUYAqYCGTRJA1MvBQQQFwIA
BagAAxAAJBcgCAAlBwCtEAISABMACAASMLIAHBcYAA4yABcgZgAmEBdkAA_DDyJnCQkEl2AXAgAf
l0YAFB80RwAAPQBHAAQAD1EAJwDpCAAPAhFAzxEgYBeEAgMSAC8nIFUALQMhAgapAAJAAg9fACof
EOgNGB8wOgCoIR8feQYftD0AEx83PAD-Yw8YAhoPOgD---------------------------------
------------------------MHwo4AEAAA4BaTMFAQDwIpQn8P-FNyCH8P__dwABlwHw-7uXASch
RxHw-7dXMScBBwGXAQfw-7O3AQcBBwE3IUcOAICx1wEHAXcRNwwAgK-XAQcRlxEnDABBrTcRdygA
IbcBEABiqzcBN5HXDADwB6k3AScR1yF3AScB8P_oNwEnAfcDIYcaAPAKpycBFxGHAccRdwHw-6Yn
ARcBtxF3ATcBZw8AoRcBFwHnAWcBRxF6ABCkkgDwFVcRhwFnAVcBRwHw-6QXAQcBRxG3AWcxJwE3
AfD-oycRRwGHEVQAMKcBNxAAUAFXAXcBSABRBwHXAScSAGDnAVcB9wANAPAGoScBNxFHAScBZwH3
BPD-oRcBNwEXsgBQARcBZwHQAHFX8P_gBwFHQgBAJwGHAaEAOXcBRxYAMCdhV3QAUfD-oAF3IQAx
JxEHCQFQVwFXAWcXABFXkgAiByEXAGEHASchVwHSACGgV0YAAhYAIUcBIgAQESwBcCfw-26n8BZr
ARLnHQDwByEXARfw-2r3A-ASJxFXIQcB9wMRpwHDMgIgAPEA8P839wfwEBcBdxEHAfcGugEREhsA
QLfw-zSbNwCsAME3AfcKATcxJ-APAQf0AGEv9w3wDRe3AGD3DFFX8A4YAIAH8P8s9w-wDBsBIfcN
RQAAwzcAGwDwAgrw-yn3EfAKVwEXATch9wMh7QAxR-ALHQCRDPD-J-cT8AkXGgEwBxEHQABAAQEn
IQsAMTfwCiUAkQ7w-yX3FPAJJw8BYBcBVxHXAfMAUQcRF-AJIgCAEPD-I-cW8AiKASEhJyIBMacR
VyMAAIc1ACMAUBHw-yL3bD0gATeaAiEBR54BUBcBRwE3fQEh8AcmAFAT8P8gAScAAY8AAB0AAVoC
AXYAAecBQQcB8AYqAKEV8P8eAfcZ8AY3gQECRwATJ1sAAGMAMAfwBigAghfw-x33GvAGPQAFHQAS
AbgBAaQABFMAsxbw-xwHAfca8AU3fAATRxgCAA4AAWIAIPAFDQDD9xjw-xoHAfcb8AUnfgATRygA
FQe2AFEHAfAFAU8AdP8ZAfcd8AWdACFXIScAIhFHjAADUwDAGvD-FwH3BEH3BfAFigEARgEiVwEH
AQCZAhI3LAARAXcAYP8XBwH3AUgAUxH3BPAGhAACzQAiByFZAABYAID3BDH3BfD-FS4AIgEHAgBU
EfcD8AYMAQGCAANfAQBiAAKzACMAMSgAKP8UOgAAFAATAm4AADsBEDcCAgHZA1A3ARfwAjkAFxFl
ACn-EzwAABUAFAF6AAE-AACKAwEIAEA3ASfwKgAU1z8AAmoAJf8STQMGAgABRAAWIYEAB0IACUEA
A0MAFRGPAwEGAACkACDwBgoDA-8AESdMBAJBAFYAAQcBxy0AAK8AJP8QQAASZxMAEABKAgM9ACMR
F8gAAT0ABDwAFWc8ABUPUAAVh3sAFyd6AAc9AAD1AwAdBAJjACL-D8sAAREAKgHncwATR7cBIifg
XgACNgAQ528AEudxACoR52gAFEdoAFTgAdcRxy8AEg0tACwB52MAEydhAAZjABPHiAAl-w0zAApk
AAbPAgFmAADNABHnNAAQ12gARtcR9wFlAAJYAwRlABF3YwAk9wEuAFAM1wH3BAQBFQUsAAVeAJFH
AWfgAdcB9wItAJLH8P8MAbcB9wRaAScF11gAEsdWAMEDAQcR1-D-C8cB9wVUACf3A08AEcdNAIAE
AQcRx-D-CkkBEvf_AgIoAAFLADD3A_AfByL3BnEAEAolAAIMAQRMAACnADD3A_BvAAOWABMIMQAQ
ESUAVQkRJxE3RwAQCGsAEAilByP3CEYAEQlEACH3CEIAEAr7BRAIHwAVCj4AIvcIPAAxCwGnPABE
hwH3CacAAEUAAAIAAz8AEAs-AAEiABIL7wAXCEAAEAxAABEGoQIt9wtBABEHhAIUpycAASYAFw1F
ABEH1gEAXAYQl0YAEHcpAAVEABEnQgAi4AdCADEOAYdCAE9XAfcOQgAAEA8fABEEHwA-EQHnQAAA
AiEAAScEIPcSYwASBEEAMgbgB0IAMRABd0IAE0cgADIF9wdDADEG4AH4ARARxQcQBCAAERRiABYH
PwBhpwH3EwFXPwAQNx8AAT8AIQURPwASBYgDBCIAQAE3AecTAgIjAAKQADMF4AFGABAUJAAQA3kA
AiUAEAESAhUh-QQTAKwAEAL8AkBH8P8CKgAm9wArAAWqBAEcAgKvAgAsAEE38P8CkQUg5xEsADMC
8AXwAgMuACEC4BkJIfcDBwARBzAAAS8AAfwJEJcyACAG98gAAwIAQBH3AuAqABG3HwYQt_0IAmIA
ABUAAIMHEqdlAAW7BQAzACAB0OUDEbcnAxOnMwACMgAxRwFn1wAh8AVyAAeZAFABwHGXAXgKUBcR
ZwGXYwVw8P8BAUcBlx4GMHG3ARUBNDcB114FADMA0QCAtwF3AccBFxGXAXcJBRH-HwAADAAATACD
9wPAZwHXEWcwAAFpAYFXAdcBhwFHEQcKAGIAEWfnCqKXAccBt3Eg5wHXbQUgIdeEA5BHAdcBlwFX
MXcrAPECAIcxZwGnAccBlxH3CQHnEYdnATLXAffFARCnhgQAJwAAXAEwpwHX5AIzCwHnhQUQ17ID
ERdIAQEnABD_JgAwxwHXxwIwDAHnvAUiEdeaAxDXzAFhAQEX8P7HrgAAmQQQ9wYFBUoAEAkKAhDX
BQAwF-D9JwIQRwwAETeuCiH3DFkBA1AAMAoB1-cAUgEBB-D9KAAwAhEXKgoAUgAy5xHHUAAxCgFn
qQEAAAtQZwEX8PxAAACuAiARt48DB1AAUQsBZ0G39AcBZgtC8PwBt8IEIgIBKwAiEcdpAVEKAXcB
5ykANEcBh1MAAH0GAioAIQ0BZAIFgAAQdxAAERdOBxOXVwADLQABEQRF9wARx4EAAisAALgLAA4L
AVkAFXcqACXnEVYAEwvWAAIxDFEX8PsBtxoCOMcBp4EAJBHnAQERt64AASsAAlUANCcB1ywAAZAG
FucrAREXBgAxJ-D7HwwgdxECAhKHqwAGVwARCzsHEaceCTCHATdXAGEXAUcRhxHLAxF3WgARAVoA
IPcAPgAVADAAEGdnAGHw_wE3QadmAhD3qAIQ5xkCUgAR9wERPgARAdwKAC8AMHdhV10AIfcD7wkw
hwF3VwIQALwAATkHAd8DATEAUBcRdwGXJgIwBfD7LwAAKAMQh94EEAH7AxABCAABjQBhVwH3AiGX
fAMwVwHHXAACBQgAKQMQp4sMEAGwABMCzAcDMQAhAbcxAFE3Edfw__kDAjAAEOcbABN3ywQSB7cA
YfcCAccBh6EKIOcBXwAaNy8AEWcvACQDES0AEbd4BlNnIfcAAVwAALgJEpeBBxJXigACXgAQAt4A
ADEAkRdh9woBB-D7Vy0AMWcBd5gBEffXBREDXAAQAlkBEAOPAhAC9AAQB3ABATwOApkAAPYHAE0A
ASEIIgMRZAARAxoDESeoADAX8PuxADanUScsABERWQUKLAAADQQAfwIClQQQd3EAMQUBFy0AEQWJ
AAQpADK3AcdVACH3BgsJAAgIEhFVCAFWABIEWQARly0AE8eAAgD3Axi3LwABAwAHKwAA8gIBfgIR
RyoAESdjAiL3BpUIAlkAEgU9ARGHMQlT1xFHEUcMAQBZABJX2ggh9wdZABIGfwMRdygJUOdBZ-D8
BQYJKAASAbMACSoAYPcAAZfw-FsBEcfsAReXUwACogIC4w8CKAARp2IBAIEAEYf2ABMIUwAxCAHX
TQMALAAQ5ykAEZdVAQADAQGPAiH3CSwAdAgBxwEnUXclAEJHQUcBKQAzVwEHJwBCJ-EDFykAEXfv
ARDXKQAR5wIBIadRcANB9woxN_cDgxcBFyH3CQG3KgBhxwGn8Px30gMASgJTAfccAXeQBAFsDxyn
KAAABAAAxQAfGygAAQAOBwEoABFHUAABggcCKQASJ1kFMQsBlykAPXcBpykAExqgEAMpAAAFAQIp
ADIHAYcrABF3JgNBpwH3GcgLBS0AMwwBdy8AAEQPAS0AAEUBAy0AERiLAwApAgUrABGXrAAUJysA
ACgGDisAMQ0BZysAWJcBNxE3KwAA9gEh9xZEBAUrABFXKwCBpzFXAYfw-WcVAh93KQAIAX8BACkA
NacBhycAJBFHJwA4EwGXJQARl7EAEddnCQF6CRInXgITEicAMIcBdycANFcxpycAEWdICxQnoAEL
KQAmhwEpABMR8wYPIwAAMTcRJ34GIfcSbwQRp3UBQfcQAacCAAcpABInaQZgAfcSEWcReQMSNykA
AkIFGFcrADEHEVe2AyH3EckIEpdPAx8PKwAAIhF3KQAQEC0FKBGnKQARR-8CAykAJGcBswMh9w9Y
BREHFQAQN78GAB0IAi8AAIIBAzEAAGIBAzEAACIAMWcRlwYHJ-cNLwAyZwEXLwARNw8AGUcxAANi
AAczAAFeACIBBzMAEScPAADLAAGjCBEMHAARl48BEFfZAhEnMwBDZyGXES8AOWchZy0AIRF3kwEI
LQAA2gMi8P08AxFHXAUQV3YDEQeSBBGHgQEQVwkEGDcvABGHbQMGLwAUEVwAAHIGKvcILQAAbgER
Z_0AEaceABQRXAABogQAKgUTR_sAEtcvADPHAWeoBRBnqgUB9QYqEXcvAAAnAQMvAAAcCgUvABMF
XRMidwEvARJnEAYAsQMyh3HnMQAR540AIPcBbQcCCggAtwANMAAQd6MFMXfw-kkJIQdBLwcQZ2oH
EieTAAUyABEXGgADEwEzNxGnNQAAlQsB5hMCNQAE9xQDNQACGgABJgERVzkBAIYABDkAElfFDBFn
OAg1NxFnOAAABgEBGQAAmwoAhwoRB2UAEjc6AABrCWBncccBVyH-CwpyABF3fQsAOQAxFzFH1QEA
7QMBNwAAmQEh9wDLAUAHEbch4RMZR3IAEQf-BQDIBBFHHwQdFzgAURcRpxFHJAMXR3AAEQdsAwQ4
ACFXAU8BAFEAFbdwAEABBxGHTwEQEawABjwAETcKAxEHsAAYtz4AAOwAA8oQEbeKACAHofoWCHgA
EUcMFxEHHg0RN5IAAhYAEBc_ABFXWAcRtz0AAKEABgIAI2cBgwABbBMCgwAiB2EaAAAbAwlJABEX
kQYRRyEDAL8DAS0AAwIAAAoDFDeOAAAOGAUCABMn5gYA0AECdAZjB-D_BwF3SwACtg0RZysAILcR
ZxcRV4wAEWfmARMHAgBRNwFHIVd_AgCCAQdFABGnGgQTR3ANIfcIxAAiVxGHABF3FQAA_AIxF1F3
QwYUJzwAATcGAOQAIGchLgAg9wjKAwHOAQLQAwBvARRHsAIBBwdSAVcB8P7KBAHJA4GXUUcB9wgh
Z1IBANMGYEcBdxG3ER0KEVdcACWXITQAAmMKEIeqAzb3CQFqABLHLgIiEWcxAADKAgAsAlM3ATch
dwAIQ-cKEadhACDXEQEDDS4ARkcxFwEuACcBt1wAEIdqAhsBMAAVpzMIAPcRA1wAMbcBB14ABi4A
ADADCTAAEJdQBSCnES8BADYAAl4AFJftAAFiBQwwABENswMC8wUAaAMRdzgAEZc8AxFXNgAAGgEL
NgAR50YPAGcAAIMAA2kAAC4CMiF3Af0PEHeDESkAZzQALPcIagAhEbc1BRFnhgcAMQAAKwcIMQAB
gwMKZgARx8YFAFoAG5czABCHCwICNAAjASdlADGXEcf9BhGHywUAqBYCMgAAMAAFMgABlwAEVQIV
hxoRE4cdBxUHNAAAewEPZgADEdcYBwIyADFX8P_oCQIyAABoAAC0ChoHZgAREWkODzMACAEODRUG
ZwAxdxGXIAAKNAARB9QBF0dpAACJBgdpAD8RdxE2AAMApQMIbAAAygsRBzIEAL0DEQdCBADeBAH3
CAGDBBAnPAARAh8AESdNAADqAwSADALZARE3PgEqZxE7AAAaAAA7AABPAgc6ABQEOgAFdQAjEWeL
BBOXOgABKwIBOgAAngUIdAAArwACcgAipwE2ABEnfgAC-QMRBxIADjoADHQAI-cDOwAC9gQiJwGP
BErH8P8DOQAAZgQGcwAANwAjEUc3AACbAwg3AAACAROHQAcQN1AGAAEKEdd9BBI3PQ8EcQAhFxFl
AACjFhAEwwECpQEDOAARAXQBNecRJzgAIRFHdgAxZyF3ggEPNgACAm4AIucBbgARlxUAFVdLCBGH
JwUR5zkAE5enABFXXQMAIgQGcAA25wFXbwAPNgADMVBXAQ4AExG7EhFX7wgRJ1wFABUAAAgBALoD
BDkAAGcBBjsAAPgAAhADAYIIAdcTAaQFAbEGAj4AAIkABD4AAM8ACHkAAFcGAT4AEQKOASERRz4A
AQYAAbQUEZfiBQQ_AABAAAImAQV8ACURR5sQATgAIxFXegAB1QAiAWc8ACkFNzwAADMDAnoAJjcR
egATFzcDIQcBEwEvEXc8AAQRR3gAEjfpEBJH4QEBKQgDuAAAPgAA4gACPgARRxwAHRd6ABEnPAQS
Z2oPCkEAFWdBAEnX8P8GQQAhQHc1ASJXAdIIEWcrBxHXLQEAhQIgNxHlBwI8AGHHAfD-BzcrAAQ9
AABmCAcxCBAhNwkRx7IAEQcpBx_XPQAIETBACAJ7ABJHQAAQERcVEcccAhEXygIAMQACQgAAqwRB
8P8Ht3UREnc_AAG5ADARV1FgAiC3EVQMEReRAxVHNgASN-UgCDcAALcFAUYLEWeIBBMnVgwEMgAA
KQEKMgARBxMBEFfYARN39gYAwgAklxEzABFXWhUIMwAAvQAS10oTAKABEUczAACnBRN3MwAhZwGj
FgJIDgQ0AAH7DhEB4AQRFzQBU1cRlxGHoAAwd0E3ABoAMwECMAAAkgQDMAARl1EBE6fwAADuEwAP
GkERRxFX4gsgVzDUBQMsABEncwsSdwgLBS0AIidBWgUgRzDXAxK3KwASN1MCAXEOMacQNyEAAC4A
EQk6AFCHATdAxysAEQCiAxMnLQAA0yFBFwGnMCMBCi8AEFDYEhHnQgMD8AEACAEAuQg-EadAMAAB
EdcIAAKyBQAMAgU0AADDCEcRl3AHNAARAY0EUTdQ5xF3UgIRBzwCERcFAwCaAhVndAADAgBdEQdB
N5BBAEEncPcA3QgRB6kCAkoAIQfxgyAMAgA8FxHAPwBTF5BX8QI1AATXAhQh3wJRJwFXMQcKACIH
QQgAOifQh0EAEOBFAQsCAAVfA1EXATdBB6EEEgfECVhxNwGHsIMAAAgQAY4ZCwIAFyFXAAN7AAFx
DDABlxG9DRCgZwEn9wJEACUBh3QAIhfBCgACUQERBykDAucEBzcAEQKsEAFOCBMHCwIMAgARR3EA
EUcCAAC5ASRnkD8AEgr8ADXwAMfoBQc1AEEBZxFX1RkANQAxV5CHDAILNwATV2IBBB8CAJgHBGgA
UQcBR5CHgwM1NxHHNgAQ4P4DIlcBqwEBnw4ALgACZwAATQUSVzQAEEEkHgIVARDgFgICGgIBiA8A
ohIgVxEKDkFXgIcByx0QAi0AAQsBIeBXKwASd10AAPYDAswAAl0AMWeAhyQFBzEAIdBXtQAfh1wA
ACIRdykAADYEDSoAClkAIHdwxwMALgAhDJcqByKHwC4AEZfEBBSHggcBWwAWZy0AALcFDi0AAMYB
AloBC1wAEbfGBD2HsGdcAAD3AAtcABHHwQkMLQACXAAkVxFaABCHBRxA-wzXEQcFIHewigcxZxGH
QAUdd1oAAy0AAecGQIcBd6AkAAJQDBFndgYTZ1kAJodgLAATAioAETdiDgAXBQNaACMBZ_MIHXcu
AAD9AAL1AheHXABGZwGHEVoAEQ1QAiJ3kOgFDFoAEWdJAzN3cFcOARoOLgAPWgAAAOIABi4AAHMG
MXeQV80CAD8DJncBCg8CXAAzh2BXigARDrYAFGcuAANcABF3EgcRd8oaAOQADy4ABANcAAYuAC2H
EVoAEICEARNHNAMWZy4AEBGKACinUC4AQpcBR5AuACRnAVoAEXfUBxEHyAEzl2A35AAaDy4AAAAB
Bi4AAloAASwAEEfBIDAQ9wGLFRCAqAIPWwAFIKdgMQc4JxHHLwAiVxFcAABWAgOUAQGJDwAtADCH
ARf1IhEQiQACXAATVz8BAIsAAS0AAXkMhKdwFwGHIfcBLAAgJ4BpAgBdAApZAAA0ADOngAcPAQIs
ADEXkFdIDALhABFXJAARlzMGNaeQlygAIqew7wQC2gATV3oAAoIAQocBt4AqAACKCDGXoGcgAABW
AAJSABCHegABXgADKgAAJiUBKgAx5xFX-QEC1gABXgoCYQAMKQAZ11EAL-cCUAAEAuEJKYcBUgAA
bAcMUgAzp5DXlQECXwUAagUDsx8CVgACIgEBKwAngNdWACRHEVYAIhEHQgAyAcdwLQAQE4MAIYDH
1QoEWABD9wIRB2EAADABCisAE9duAAVYACICEesKAmoCIsdgVQEQEw4UDVkAFQMsAQcqAADSBFaX
gLcBB-wABVkAEWd1AzHHYIeRKYIT1yEHAadwx0sAAlQAAzQAEocuAQQpAFD3ARGnYH0AAigAAU8A
Ah0eBSUAG4A2LFYtNzQuOdBjBYt0PjUuOeZjHzFLLBkPAQAAIFwRpCvwCcYXEVchgEfw-7FHIYcR
YKfw-6lXIbcRQOAOcKRXIfcAIRCzDvAAnwH3CpHX8P_bMfcEARfBbBDgN-D-mBFHMbcxJwFHUWfM
CoCVIScxxyHnMXUYoDcQV-D-iiEnQReCIfEBAWF3ESchZ-D-hjEnISchJ5wqsDGnIRcxV-D-g0GH
1A0gIZeLAxADJgBggDGXEVdRiRPA9wYhV-D-fiGnEVdBAwQwVyE37R7wAFfw-3wRNyFHEWdBlwE3
IQwmIPcDTAAReRYA8wM3ARcRtyFXMVcR9wUhVxHw-3YXAHAnAYdB10H3KRFw8P9zETchl9APgBH3
CgH3BCFnJgxgcRE3IYchAQ1B9wtRl9UVUAfw-28RZQCzJyFnIfcLMXcxZxEYAFBtIScxJ_kFERGi
IQAYAGKH8P9rETcWAFEBtzE3YVAUALgLcfD-aQFHMTdfEGBB9wpBRxGeGlE38P9nAdcAUAUB9xMh
aBcQxxUAEGVFAXAB9yAhhxE3VBAAFAAQZB0IkCHnEZcx9wQhtxYjIBHXjCzxAGJHEQcR1zFnIZcx
hxH3DJApQGABNxGuDsCXIXcR9wAxNyH3DhEZDkI38P9fCAwgEYddEEIRpyEXrxoQR9MBEV0MECB3
IXwEcdcR9xQRVxEYABBb1BABciIwhzG3ohwhZxFMAJBaETcRNxFnIWcEARMAiCIgEWcWADHw-1kJ
ETD3A4HpH0AR9wFxnQoBgwARWNMjYDcRdzH3AnguEEEwGED3ARE3zwARWIQAAN8FgvcEIacBJ0G3
niGRN-D-VgE3IRcxqhowxwE3NSASlxkAEFWDLRAhjAAw9wQRnA5AR3H3CfAJAlMAEVU4ACAXIeYl
ABYBEFcMFgA-ABE30xFAJ-D-VEAAAAQRAXkhALsXYYcBR1H3ALsuAbMCASYAMjcxF9UAYAIBFxFH
EeUBUkdB9wYBJgAQF3UBYfD-UzdBF1gAIGdR2woAOxVBZwFHMf0mYScBJyF3ASUAASUCAEsJANQk
AugOANYGMucxhzYbIBEHJgAREd0OEQBGFgBBCQDGEBBhIgAgVyHGAmJTJxH3EQEdAKJXAUcxp-EA
dwFHGwAAayVAFxH3EvwCsBHHERdRBzEHEWcRuRUAHgBxAZcRFzH3EJ4EwLcRJ2EnEQchVxFHId0v
cVN3EScRFzGUAwCPEkCHQTdx2A5hVxF38P9U7QjwAhGHEWdB9wARJxF3IXeB5wFHuwMQVWcDAJ0G
IGdB7hFQIXcRl3ErIwCzAxBVsQIAzgAgZ1E3AOEhdxFnsfcGEWfw-1MBN7wBUGcRZ1HnJDAA3gZQ
gfcHEVccACFHEUUwkFEnQVchRxGHIUwFQAdx9wgeABJSCQgA5BRAQVcxx2YFEQE0GTCHEdcUFBBR
fAsgMSepAVFBZ4FnEb4LALMFIAdRLhYBIgAA3y4ABgOSZ1F3QQdxNxHXIQBAAQdBp3wjIf9QYwp0
pyEHEWdRhxwAAIMNMyGnIQwAIFGnnC1A3IfwWtYCQIdRd3FHBwcCACRhhysAQAEHQbctAHBch-Bl
t-BY_QBAZ1F3YbcoAQUOMlF3IXMN8AUHUWcRN2HX8Fq38GPX8Fc3QacxhwsacUHnAQdRN0HHBvAA
QXcR9wjwWdfwYfcA8FY3bAtDMZdhB-kUEMGVBvABBzGHIfcG8Fj3APBf9wLwVF8MMRH3BjUOAagW
QQcBB4F6ANAh9xPwVvcC8F73A-BTJwAyIfcEJwAAQyoGAgAgxzEcHoDwVfcD8Es30MkGEFLnDQIu
ABAXCwUSJygAAZ8u8AL3AREnMTfwU-cEAdA38DdnsP0AEFHiAAIxAEM3AfckKQD3AEEXIRfwUvcE
EbBn8DWHoCkAIQJRtgAAKQAAZyABJQBhoIfwM6eQJQASB18EEAf2FRIlEQ0AugEAJgBkkKfwMceA
JgAAyBwwERdx1Akw9yUx0x3ghyFn8FL3AyGAx-Av53AMBTAA8FCeF0InEUcxXQ_AtwH3JjEXIXcC
L0BhR-BSnjLCEXDn8C73AGARJxHnMAA2FxE34wEA-gDwEBH3JyEnMWcBV0FH8FLnERchYPcA8C73
AVAhJwHn8FD6AIAHEfcSEfcn8fYaIPBSZh2BUPcB8C73AkCgHnCHMRfwUGcRuiogKcGpACBRFxwE
kCFA9wLwLvcDIKAA8AYRRzEXEQfwUGcB9xUB9yURhxEXIXcrAPMCBxEXMUcRNyEg9wPwLRH3AiCe
AAAbDCHwT_AAsREXAfcJIfckEecR7Qkh8FGZD8AnMSD3AhHwLBH3AxDYMgHmBDHwTxf1AyAXEQ8Z
QRH3IhEjHlAXEWfwUQUYEBEOMrIQ9wMR8Cwh9wMAIWsQAHoMMfBPB5IMUCchZxHXzQEQIHUbICcB
OQAA_AwB7AJREQD3AyE7AAFXKxEnviIQT9cJEDcqBIQBtyFHEfceETkAIYcBcQAUMTUAETFvABAh
SyNBAWfwN0EGUCcxdxGXRAgQHYcbANEYUTpn8AGHbAIpByFvABFH2B1AAYfwNggPMEGHAW4IBjgA
UzmH8AF31B-CBzH3AjHwLDEXEdcxdzVQd_C38DQGBSFRhyAaUacB9xwROgBxR-A5t_B3IWAAxSHX
ESch8BlnsCEHATwAwhF3wBHX8DIBJxGHUY4cEBy3GAGPLlDwN9cRwK8LAXYAAD8AoDGwZ-AFh6Ax
NwGFCgClCvAAd7Ah5-AwERcRh1GXAfcx-AYC8QZAN_chsPYLUQcBRzHXQABwoIfwA6eQISoDIscx
9AAwd6Ahly4RL70GcUdRhyH3LTHNJnaH8Db3AhGgfQCwxxE3MZCn8AHHcEERABTHfwAAUABA9wDw
L2AFIDdhMAAg9yykAQJDADQBMZCEALDHESdRcMfwANdgURcCQ1dRFyGEABCQNQBDAvAuF0MAUhcR
9yoRmQeCATfwNfcDIZCIAPAARxEXUVcBR0Fg1-AA9wBAiQAAcgMRgYkAEYAjAKH3AvAsFxEXIUdh
PAkQKhsvk3cRJ-A09wUhgIsAIHEHagZAUUD3ANhuETA7BDQnEVcTARJwSQBwA-AsB1FXcf8eIPdG
ABVg8DX3BiFwigAAVwpSJyFHQTDJbhEgIgVgJxEXAXcx3gwwZ2AxrACyx-ArByGHgbcB90c-AHLH
IWchYGcRLTZxdwEXIUdRINxuIQMQ3AQgBwEpAgDNADBnYCEHAJDX8CoHMXeR91VDEDHwNdegAFEH
EWBnAScAICF3AxWyQRD3A-ABAfcCAEFaAABnBkFnAWdQBwDRx-AqAQdBV6H3ASH3QVIDgTXHEWcx
UGcRSwgAqQCxUQD3AgHwAgH3AmEWCRMRhABwUDFnETdBN0EAYFEnwfcCQZ0CECipAkDwNDdBpBIz
ZyFQiwAxEYchnAAUUUsAEFEXADJHEZeMACFAMR4A8AABFyEnIQfwKwEH8QX3BUGNJxAodw0g8DRK
BwCVCTJnIUCaACGXAUEAEWFQABERUAACFQAydxFH2gAAdy4DTAAA1hYgZ1GnHaAJofcEATcRl-Az
MAABIwAzEVBH0gASl6QAEEHaBEIDAfcCMAEBUBQRF3YTJUAhNgAGWQAgd1HHL5QHQWch9wIRNwFb
AAJEDkERQAE3qgAwZwGXuAABAAFABAH3A5wHMCGHIaUJJEAhaAAABB_w8CwRB-EDlwHXYddaAkEA
IbcR9Qowh-A08ghBEYcxQNkjAD4BI4cROgCTMfcDAfAEEfcCpAIiByE_GTEwQQd9EHCH8C4RB-EC
Kxgwh3HHBy8QIUYuESFXABOHoQAwBzEwygMDvQ8BFAAAgwFx8AURBxHnMSIAIBGHxwA0ESBBZwBg
d-AvIQfxQxFAAadxl4UJAK8GAJwAUHfwNXcxWwgTIDc5I0cBaQBxQecRFwHwBg0AIudBWABCdwGn
IVYAADECMYfwMa4AQCcRp4GQEUCnEfcTTAtiIWfwNIcRsggxICEXqgAhdyE0ACAx55o6cQYRFxHn
QYfPDyWnEVEAUBGH8DEXpgAwJ-EHhgxAdyH3E3ELIhFX-gASp6cAEgGnABFnrwAgZzH8HAGnAACS
DwGuIhEHcRQCVwARhxAG8AMxFwEH8QGHUaexJxGXEUch9xUSAlIRR-A1d6gAIVEgFRQCBBIA9AEB
ZxwQ8MgfwQcRt1GXAQcxRxGnAA8DAqwA0HfwMAEH8QSXEfcA0bdYBzHB9wh_KTM1dwF5ADFhADcb
BiNHITUAIVG3cQIAqwEB1AYSJ1wwAN0QIxBhNQAwAWfwHgIg8QQgDIGBdwF3QfcEUQ4DU3fwNmcR
JgAxURAXBQECWwCQhyEnEXcxNyHwMQ0xR0E35igCnhgUp1gAQBFX8DE_APAB8QNnEUeRJwEXQQcR
F0H3FxkQAFwAMzdXASoAAJQKAEoYFCEQAEBHATdRsQQi8AQABDEhFxEaGgACAGIRFwG3UQedAUEB
V-AwoQBSB-ECVxGvAwEvACAxB4UHIAYxiQ6TBxEnIVfwOFcRXgAhYSd4AREXGgEAJR0AmQgChAEi
8ATqA0EBB0FnYAARB7oHAvUGUscRR-AwtAIg8QKfCQNkAQJuAIFB10EHQUdxZygKU0fwOkcBpAAQ
QcgRAmsAMpcBZzUAETHZAAEDBSEhVzoBRCch1zHVANNH8C8RB0EH8QMHIRdRtQASMUIAUfcEAXdB
2ANQBhEnMSdnABIXNgBBIdchNwoAM1chF5gAAc4AU6cBBzE3PAETJ_EM0gHHAAE38DAhByEH8QOI
DBVnGRpT9wUBR0FJAQC6BYE3QQfwOzcBAJULAc4eAjYBBLIKEofNABSn-wEAQwCBCQHHEAEn8DHH
ADECt0FNACAxVzsJEgK3GgGdAiH3AxkBchcR8DwnARBhAAIoAQRdAATJABRBYQACwQJy9xYQARfw
MsEAQcdBZyHdAQAQBSJHQVsAMWchp_cCVfA9FwEQWQAABgYCnTwDWwBFMfAEUVsAAK0LYRYgAQfw
M7gAUQH3AFG3GQIB_TAA-gMQh8IPsSHnAWfwPgcBIPcXnAEJUQARQawAEcc1AAC4MmH3FkAB8DOp
ADUB9xEqACDnAfgGARcBQRE3IdeaHGBn8D4BQPf6HASbAgFSAHVR8AQhFyGnjQJA9yLwOaAAUuH3
EDEHFgAhIccwBxEnDAARV0IzAE8AMET3GDsCCE0AIBEXFgIA4ykDEAIxIvA5nQBzACcR9wkhB6Ic
YQcRtxHHUfkAEAa6DGMRV-BE9yL7AQBFAQD6AzIhVwFHAGEXAfch8Do0ARAAMgAB4wcBAgAQIcA-
EHf4JgFbCWPwRfchAUeaFRBXQwAA5RBwBwH3JfA7ET0AEDGUADSnoWeFACABl2QQkScRJyE38EX3
JjoAcydRdxHwBBGPFUL3JPA7tQAQgbYDoBch9w5BByH3CjFKDgEjAyFF99YCEAFvAACJCDAk8Dyr
AHBxJ0EHESeRRw6QEfcAQXehhyGXEA0g8EYGDgCyIQJlAKA58DwhB0EHYTcxCAFA9wFBV2AA8AEE
IfcAcTcRhxFHISfwRvcm9UABbwNC9zfwPpAAQHE3URenByGnQUYBMfcGEXY1khEn8Ef3OhHwAy0A
oD8RB9EnQceB1yGbBxDHghMRZyUAUEj3ODHwtwfxAfc18EAhB8E3IXdh9wVBBxHRETG3IccqEVAH
8Er3NiIDEAJPACA28DAJAQIAEGEyDTD3DCGaB3H3ASFnMQdBJjMzSvc3VwAyNPBCzQSBcSchVxH3
DiGjGEEHQVcRyAtVB-BL9zVaADI18EMtABBhREJA9w9Rdy0PkycRV-BL9zQBB1MA8QAbAfcH8EUR
B8EnEfcWAQe-ByD3JRMTIPBNLjIVHFAAEBwqAIFGEQexJxH3GDEZIfcktAIBKAAUG1IAkVcx9xEB
pxGH8DUCZbEXIfcZESsAIE6HLw00ETFnVgBAB1H3FfMZIPBILgBSoRch9xLSBIAsIRcBV-BPpwwB
EBV_BEAx8AFBXyIBTDGAx-BJ0Rch9xBaAEIDEfcXLQARxx47AsoDQDHwADHMAgEjMUHH8EoRXQAQ
DrQdkggR9xYhh-BQx_o6EMcCBAJQCxKXJzEQ1y8AELHaEABdH0AJAfcXYQ8Q124QMw0Bx1wABi8A
oufwS9EXEfcLIYdcAFJBR-BR5y0AUacBB0HgEAZAZxH3DtMQcADwTNH3DTHpOwDJEwEfKyHwUfAT
gPcOEZdh0GGH_i8QN_E_sE1BAGH3DTGXAfcH7AAELAAhAhEdMFB3AQdR0CsLAFUwAN80I-BTLgBA
CCH3D2MJAS4AEgR2MGBXAQdhwHFpCCD3ESQEYQXwVGH3C7sqABQQEw06FRFSKigg9xF-FFBhsGEH
UY0QgAcwN-BMYfcLyw4RIcEIYQch9wsRJ0oVMEs3MAACMRTRsOgAEPcGLHEwZ-BJYfcLwQhA9wYx
N8gCABAYMElnMAM0EhhcACEBB8QQsAogd-BIYfcKMUdBOjtRITcx9wn-BzBJdyCqFwGWAhNRXgAQ
BA8HgfcKIAF38EhRMzAQB5EVEAtfB5EHETdBF-BKdwE3ABABFgdAB2GgcSwGAcA3cPcMEAGH8EcH
FgMPCwBOBgH5J5IgAfBLhwEQ9wztN1O3AQdhkBQJAawqcQ0QEYfwRnFOKiGnIdQZEAeaBGBX8E_H
ERANGAGIIkUHcYCBNABxDxABl-BGYcUGAPg8AJsHpQQBV-BOlwEQ9w8yACJwcegF4JcB5xH3DyAB
l-BFcfcFwgEQp54AADIAcE2XASD3DxEyAGJ3AQeBYJEwAADTAIEREAGn8ESB9-gEEACMDwBKBYHw
TacBEPcRAYgjAbMJMoFQgbwGATYkMPcSEGBGIEOBPQNBBHH3A7klQLfwTAGcABISnzgBEgYxkUCh
Tg0BUAFQExABhxE2ABECiwERQXIpADoHQLfwSxE-ASETAWohEScXAGEHkTCxBwEmHlEBEfcVAJcl
cUKR9wAh9wfJKmAhpxGn8EswATAA9xVfEgMuClABB6EgsWQPQPcNAfcVOVAX8EGRZ8MTECHlCUAR
t-BKWh4AagIQDUMEYcEA8QL3D6YDUAEn8EBR1A1BdwH3I_MMMMfwSV0XAC0AMQ-xD9sCMPcWEakc
QDfwQEEcKBF3kRRgAWchx-BIWiAQByEAQfcT8QvhAxIFgQIQF24YMfBAUTYpQBH3JSEUAYEn8Ek3
IRchF4sAUQUBx-EKMwAQBrYAgDcxd-A_USchTBMh9yglJWEn8Ed3MTcLCQAlABCnwAsD8QAAVAAA
e0QAIAQwPVE3nRYwEfcusRdB8Ef3AL4AIgcRMwxEB9EHAQIAQGcB9zFQAFEB8D1BV8cYEPfHAwBr
ADBG9wETAhIw-wEDkQEmBwECAABmGiD3DjAFIAchdgAiQZd7FVEEIVdBxyIPIJcRRwACPD4AUgMR
DnwXFAcCAAG4AgYCABGXTgBQDQEHMddNAJAhJyHnIUdhJ0FOHxE3kkcSR8cSAGUDArg8D0cAAQKo
OwH4RhMASABC9xUhV0UAYQE38Ef3ISIAA9YXIwEHDAoAtAHjIfA9UYchJyFnYfcJQRczAACXB0Eh
EfclVw4BTwJw9xjwPkGHIXMNIPcRlQ0hEdcmABAYVQIQJh0FNighZyYAsTcRt0EncQcRdyFnWDow
SfcYUQIBcggQKhsXYRnwPlGHEQAagSEHISdBZzFnCh9g9wLwSfcZCRokEAH7CBAppBUAC0ciPlGJ
N1AHEQcxB_MTEGHEFGD3AfBK9xOODABGBwB9AiArQUIdUPcQ8EBR0CQCiQsgByGgHACADQJgCwAO
F0DwS-cQbB0yQfcP6hfR9yphF0EHcfcJ8EFRV2kGESfTBAA3EgE9ABIRPQAASjSR8Ez3CXEHQRdh
egGgBwH3QvEPZ-BLUWkcAGYYIwdRdQAiERezDSExJ0oPVPBWZ-EPNABhQ-BxUUcRChsQYWIKIDcx
NgMC_hMAihoA7Qsj8HzCSGH3P-B3UTcuACEngYkAQDEXIQfcFgTjJgAuADGC9wUuAKAHAfc9EfB4
UTchsgARN8wEERc_AxFRHQAxAvCDqz0EAgCg9ysxh1HweUEnMQBKIyeBbgoRgQ4JAS8AMlGHMSsA
EAefAwAgDlED8HlRB8kbIRdxGQASwYozIAdRzxtFh-CE8ZknIfcqBwAiF_EzAACCAQGIAAUCABIh
ZRkRB8M1ACUeRIThBwECACD3LAcAUfEA8HuhRxwC0wEMAgADrAEAagEAhjkYhkEAAn8AUAfR8Hyx
phcDFQIMAgAEFgAQQQcsSofwh_GBAJXh8H2hFxEnATcJAQe-AAU8AAK-ACqH0TwAYAEHwfB_obYX
ATUZDPsACAIAAcAAO5fwiEIAE9FAAACKFQFPECMBp3AAbEcRh-CJwXAAcbHwgKEXERcnETGnMbeW
AVNHAZfwiioAIvculgASgJYAUCHXIcdR4xBCh-CLsSIABkwAM6HwgSYAAHcNINdBQBhIh-CMsUoA
QLHwgpEcA0FXIcchIgBYAZfwjKEiAGABB5Hwg6EIAzBXIddGABARchUSjvcBByYAUYHwhJEn8hJA
1xGncZUtTHfwj5EkABGFbgBRR1GnAbeRTAD5OxOQHAUj9zArBTHwhoEDO2EhJwGnEZcpIADHGRGR
dAAi9zJKACCHYWQAAMMeMLcBhzBKEREkABaRSgBBgfCIYU8pAjk4AZs3RKfwk3FGAGGR8IlBVxHX
AgCLGwD0BkaX8JSBQQBCcfCLMTYRQBdR1zHCFABhAiaWgWEAMYtBV7AKYCcRFyGXQT02Qnfwl5Eg
AECB8I0x0xUATQQgN7FlAELn8JlxHAAxkfCO0zUiRzHiNgCPDSPwmVkAUXHwjkFXsCYARQUhNwFM
B0MB8JuBHQAhYUecIQLjFwDdAFL3AvCcYWYBQHHwjnHzLQH4AQCpE1ABx-CdYTkA8AFh8I2RhwGn
QXcxdyGn8J1xLgDiYfCOoXcB55GnMZfwnlE6AkFh8I7BaBhFECGHARYAQUHwjuGEAzAR9w_kFwAa
AAAYABBRGAACmwURD5QAALVMQZxh9yobAAC8D0InUfcOBRECHAAwQfcsGgABnBkA3wZEIVcxRx4A
EBEfABEqbgAg8QK-GEDnEQcxVgETBwIAcBcB8JtB9ysgABAEyhxiRwEX4Tch_RMEIACQMfcqUfCN
8QU3dQMi8QW4TgJ9FjDwmkEGBTMx8I2ZAqMHUScRV1EX8QEn7RQBaxNzmTH3KUHwjJcCBB0Fgnch
h0EXIZchEgBShyHwmDFNABSMxAQFDAQQF_sZJJcx6wd-ByHwlzH3JywAAgDbEhIR-QsCHQQCLABB
MfCMgYQRBiYAAEYMAg0AUMdB8JchwwdVIfCLcbciACH3FVAREOdAARGWugdSIfCLgcceADNB9xTh
AELnYfCWAQhE8IqB5x4AIRIRCQBhAfcAcfCVSAhEEfCKkYAIM1H3DPgAAIsCwoHwlQH3JiHwiJH3
AxUAFGGiEQAgAEEDkfCT1R5iEfCGsfcCFwBVgfcGIRciAADDBCCPEbwKQiHwg9FhCzWx9wFeBgAQ
B7Hh8IwR9yQh8HzxBRA2VwfBR1EXPwEAJABw8QPwiBH3ImsAIW-xbgszAQfxygABJADSB-EK8IIR
9yMh8G3xE2kTB2IGDAIA4fcJ8RDwexH3IiHwa-EVCkcAbiAPLwAHkAEH8RXwdhH3IIIAMmbxFxQA
DzUAC-IDCwEH8RvwbxH3ISHwW-EJF-EINAAESwcPOAAFcQ0BB-Ee8GttAIQB8FrxCSfxCHAABEYH
DzwABfYBDwEH8R-wagH3IRHwWPEJNzoABkAHDzoAA4ARAQfxI-BnAXYAcPBX8QpH8QnCAA4BBww5
APgBEwEX8SXwZPcfAQfwVfENR3MADzoACwCgGNcp8GH3HwHwU-EQN-EHqyEDdA0MMwCQGQEH8S3w
XvceMwAYEjMAAnUHBSkAGB1kAUDxHPBd_hEw8FLxixch8Qg0ACX3NVAB8QCHAQfxGPBc9x3wUfEC
J8HACTWxB4HJACP3M7UB9QOn8RvwW-cbAfBP4QcBR_GHQQfSASb3CSkA8ADn8RzwWfcaAQfwTuEH
AWfJIiRBJygABewMEyksADAf8FdTABBNJwBE4bcxRycAQ4ch9yPiB4T3AfEg8FX3GiYAI_chJgAQ
D8sSEyGLAjLnAQcnADHwS9HVACHBBw4zEoEbUzEx9yEWA6H3AfEj8FP3GfBLIwhCp_H3CSIAgQxR
9x0BB9EXuwOD8STwUvcY8EokAAK5AAIoADYLQQelBCQH4esDY-Ek8FH3FzIAGccyACMKUSEBA9gB
EvFJUpIF8SbwUfcW8EkzAAKxABEJkD4APgAUQf8DBoYCEvEHAAQXBFYm8FD3FT8AGOE-ACEGUYIA
EBfHDgICAACQALHxCQfxDPBQ9xTwSDYAFec2ABLByAASYeMAMfEJJxYAAjAANk-3EzAABCsAEgsH
ABICaQgBhwIg8QUIAABsDwANAHEI8E-3EvBHOAAKOgAS4aEFAAYABSwEEgMIABLBJAABLACKgfBN
9xLwRtE-AAIoAEXhBwHXugYDfgABPQQB-gAlB6FsARNhbQlRS-cS8EVLACf3AUwAAv0ANgEH4U4A
BRMAFwdRACoBB6kGEwFXAG9K9xHwRuFXAAEBlAAh0bcCAiUHAfkAAFMAAxgCD1cACjUQ8EVbAg9X
AAwVCawABE0AEqGNADBx8ElIACTxAEcAB0kAAUsANBfBpyMIA0kAEsFHBSWBh0UAUmHwSfcPRQAG
RwAEFQECOAA6D7GXEQACIgAh9xF-AQlLABznNi0fMjYtAlYxMS4wNVWJkCx6b29tPTF9fQ==
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Iixtb2RpZmllZD0iMjAyNS0w
My0yMyAxNjoxMjozOSIsc3RvcmVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Il1d
:: src/
:: src/custom_wrangle.lua
--[[pod_format="raw",created="2025-03-17 17:47:53",modified="2025-03-23 16:12:38",revision=120]]
--[[

	wrangle.lua

	not designed to be customisible; aim to take care of 90% of cases with a minimal replacement for boilerplate.
	to customise: copy and modify (internals will not change [much] after 0.1)

	wrangle_working_file(save_state, load_state, untitled_filename)

	user supplies two callbacks, similar to create_undo_stack():

		save_state()          -- should return data (and optionally metadata)
		load_state(dat, meta) -- takes data and restores program state

]]


local current_filename

-- last known metadata on disk for a given filename
-- can use to check if contents of file has changed due to another process
local last_known_filename  = nil
local last_known_meta      = nil

-- set when contents is found to be stale due to external changes
-- ( --> stop auto-saving)
local stale_filename       = nil

local _env = env
local _send_message = _send_message
local split = split
local create_process = create_process

function pwf()
	return current_filename
end



local function update_menu_items()
	
	-- don't need -- can do file open, CTRL-I to get file info
	-- also: can hover over tab to see filename
	-- ** maybe: right click on tab gives a different tab-specific menu
	--    at the moment it is only really useful for "close tab", and maybe confusing that there is the same menu twice
--[[
	menuitem{
		id = "file_info",
		label = "\^:1f3171414141417f About "..current_filename:basename(),
		action = function() create_process("/system/apps/about.p64", {argv={current_filename}, window_attribs={workspace = "current"}}) end
	}
	-- \^:1c367f7777361c00  -- i in circle
]]


	--** fundamental problem (maybe wrangler could tackle):
	--** when edit metadata, doesn't feel like anything changes on disk until save it
	--** But then Save As, what happens? Should wrangler store current metadata and pass it on?
--[[
	menuitem{
		id = "file_info",
		label = "\^:1c367f7777361c00 File Metadata",
		action = function() create_process("/system/apps/about.p64", {argv={current_filename}, window_attribs={workspace = "current"}}) end
	}
]]

	menuitem{
		id = "open_file",
		label = "\^:7f4141417f616500 Open File",
		shortcut = "CTRL-O",
		action = function()
			local segs = split(current_filename,"/",false)
			local path = string.sub(current_filename, 1, -#segs[#segs] - 2) -- same folder as current file
			--create_process("/system/apps/filenav.p64", {path = path, window_attribs= {workspace = "current", autoclose=true}})

			--printh("Open File // _env().prog_name: ".._env().prog_name)
			-- can assume when program is terminal, co-running /ram/cart and should use that to open the file (useful for developing tools that use file wrangler)
			local open_with = _env().argv[0]

			-- when opening with terminal, can assume co-running ram/cart
			--> use /ram/cart to run it.   //  allows wrangling files from load'ed cartridge; useful for tool dev
			if (open_with == "/system/apps/terminal.lua") then
				open_with = "/ram/cart/main.lua"
			end

			create_process("/system/apps/filenav.p64", {path = path, open_with = open_with, window_attribs= {workspace = "current", autoclose=true}})
		end
	}

	-- save file doesn't go through filenav -- can send straight to even handler installed by wrangle.lua
	if (current_filename:sub(1,10) == "/ram/cart/") then
		menuitem{
			id = "save_file",
			label = "\f6\^:7f4141417f616500 Save File (auto)",
			shortcut = "CTRL-S", -- ctrl-s is handled by window manager
			action = function() _send_message(pid(), {event = "save_file"}) return true end -- still save just in case!
		}
	else
		menuitem{
			id = "save_file",
			label = "\^:7f4141417f616500 Save File",
			shortcut = "CTRL-S", -- ctrl-s is handled by window manager
			action = function() _send_message(pid(), {event = "save_file"}) end
		}
	end

	menuitem{
		id = "save_file_as",
		label = "\^:7f4141417f616500 Save File As",

		action = function() 
			local segs = split(current_filename,"/",false)
			local path = string.sub(current_filename, 1, -#segs[#segs] - 2) -- same folder as current file
			create_process("/system/apps/filenav.p64", 
				{path=path, intention="save_file_as", use_ext = current_filename:ext(), window_attribs={workspace = "current", autoclose=true}})
		end
	}

end




local function set_current_filename(fn)
	fn = fullpath(fn) -- nil for bad filenames
	if (not fn) return false
	current_filename = fn
	stale_filename = nil
	window{
		title = current_filename:basename(),
		location = current_filename, 
		unique_location = true
	}
	update_menu_items() -- (auto) shown on /ram/cart files
	return true -- could set
end



--[[
	wrangle_working_file() // the user-facing api

	untitled_filename is also used to specifiy default extension (foo.pal -> auto appends .pal on save)

]]
function custom_wrangle_working_file(save_state, load_state, untitled_filename, get_hlocation, set_hlocation)

	local w = {
		save = function(w)
			-- printh("## save "..current_filename)
			local content, meta = save_state()
			if (not meta) meta = {}

			local err = store(current_filename, content, meta)

			if (err) then
				return err
			end

			-- use callback to modify current_filename with new location suffix (e.g. foo.lua#23 line number changes)

			if (get_hlocation) then
				w.update_hloc(w, get_hlocation())
			end


			last_known_filename = current_filename
			last_known_meta = fetch_metadata(current_filename)

		end,

		load = function(w)
			local content, meta, hloc = fetch(current_filename)

			load_state(content, meta)
			if (set_hlocation) set_hlocation(hloc)

			last_known_filename = current_filename
			last_known_meta = unpod(pod(meta))

			return content, meta
		end,


		update_hloc = function(w, newloc)

			newloc = tostring(newloc) -- could be a number
			if (type(newloc) ~= "string") return

			local old_filename = current_filename
			current_filename = split(current_filename, "#", false)[1].."#"..newloc
			if (current_filename ~= old_filename) then
				-- tell wm new location
				--printh("telling wm new location: "..current_filename)
				window{location = current_filename}

				if (set_hlocation) set_hlocation(newloc) -- callback that e.g. changes cursor position
			end

		end


	}

	untitled_filename = untitled_filename or "untitled.pod"
	
	
	-- derive current_file
	
	cd(_env().path)

	-- look for current filename first in environment (location) and then on commandline

	current_filename = untitled_filename

	if not fullpath(current_filename) then
		-- can't resolve: use /appdata. happens when e.g. /ram/cart is not available because sandboxed
		current_filename = "/appdata/"..untitled_filename:basename()
	end


	if (_env().location) then
		current_filename = _env().location
	elseif (_env().argv and _env().argv[1]) then
		current_filename = _env().argv[1]
	end

	current_filename = fullpath(current_filename)

	local current_file_exists = fstat(current_filename)

	-- when file doesn't exist, w:load() also serves to init state by calling load_state(nil, ..)
	-- to do: can this fail?
	w:load()

	-- create
	if (not current_file_exists) then
		w:save() -- don't care about result
	end


	-- tell window manager working file
	-- ** [currently] needs to happen after creating window **

	window{
		title = current_filename:basename(),
		location = current_filename, 
		unique_location = true
	}



	------ install events ------

	-- invoked directly from app menu, and by wm when about to run / save cartridge
	on_event("save_file", function(msg)
		-- can optionally 
		if (msg.filename) then
			current_filename = msg.filename
		end

		-- refuse to save over external changes. to do: nicer way to handle this
		if (stale_filename == current_filename) then
			notify(stale_filename..": skipped saving over external changes")
			return
		end

		local err = w:save()
		
		if (err) then
			notify(err)
	
		-- show message only when NOT auto-saving /ram/cart files
		elseif (sub(current_filename, 1, 10) ~= "/ram/cart/") then

			if (fullpath(current_filename):sub(1,8) == "/system/") then
				notify("saved "..current_filename.." ** warning: changes to /system/ not written to disk **")
			else
				notify("saved "..current_filename)

			end
		end

	end)

	-- invoked by filenav intention
	on_event("open_file", function(msg)
		set_current_filename(msg.filename)
		w:load()
	end)

	on_event("jump_to_hloc", function(msg)
		local newloc_str = msg.hloc and "#"..msg.hloc or ""

		if (w.set_hlocation) w:set_hlocation(newloc)
		local old_filename = current_filename
		current_filename = split(current_filename, "#", false)[1]..newloc_str
		if (current_filename ~= old_filename) then
			-- tell wm new location
--			printh("request setting window location: "..current_filename)
			window{location = current_filename}
		end

	end)

	-- invoked by filenav intention
	on_event("save_file_as", function(msg)
		
		if (set_current_filename(msg.filename)) then

			-- 0.1.0c: automatically add extension if none is given
			if (not current_filename:ext() and untitled_filename:ext()) then
				set_current_filename(current_filename.."."..untitled_filename:ext())
			end

			local err = w:save()
			if (err) then
				notify(err)			
			else
				notify("saved as "..current_filename) -- show message even if cart file
			end
		end
		
	end)


	-- autosave cart file when lose focus

	on_event("lost_focus", function(msg)
		if (sub(current_filename, 1, 10) == "/ram/cart/") then
			w:save()
		end
	end)

	
	--[[
		when gaining focus, check that file being edited has a newer version on disk
		if so, warn that external changes are detected (user might want to reload)
	]]
	on_event("gained_focus", function(msg)
	
		if split(last_known_filename,"#",false)[1] == split(current_filename,"#",false)[1] then
			local md1 = fetch_metadata(current_filename)
			if (md1 and md1.revision) then
--				printh("revision on disk:"..(md1.revision or -1).."   last_known_meta: "..pod(last_known_meta))
				if (last_known_meta and last_known_meta.revision and last_known_meta.revision < md1.revision) then
					-- to do: how to disable autosave / 
					stale_filename = current_filename
					--notify("warning: external changes detected -- this version is stale")
					notify("warning: external changes detected")
				end
			end
		end
	end)

	update_menu_items()

	return w
end







:: src/files.lua
--[[pod_format="raw",created="2025-03-08 09:21:19",modified="2025-03-23 15:45:13",revision=915]]
-- Loading and saving -------------------------------------------------------------


function save_working_file()
	local ext = pwf():ext()
	if ext == "hex" or ext == "txt" then
		return save_hex_file()
	else
		if ext != "pal" then
			notify("unknown file extension: saved using default file format")
		end
		return save_pal_file()
	end
end


function load_working_file(data, metadata)
	if fstat(pwf()) ~= "file" then
		-- This is a new file
		create_metadata()
		is_new_file = true
		return
	end

	metadata = metadata or {}
	local ext = pwf():ext()
	if ext == "pal" then
		load_pal_file(data, metadata or {})
		if undo_stack then undo_stack:reset() end
		send_palette()

	elseif ext == "hex" or ext == "txt" then
		if metadata.okpal_version then
			current_import_choice = "overwrite"
			load_hex_file(data, metadata or {})
			if undo_stack then undo_stack:reset() end
			send_palette()
		else
			imported_hex_file = { data = data, metadata = metadata }
		end

	else
		notify("unkown file extension: OkPal can only load \".pal\" and \".hex\" palettes")
	end
end


-- Metadata ----------------------------------------------------------------------


function create_metadata()
	local metadata = {}
	metadata.okpal_version = okpal_version
	metadata.icon = userdata("u8",16,16,"0001010101010101010101000000000000010707070707070707060100000000000107070707070707070606010000000001070707070707070706060601000000010707070707070707060606060100000107070707070707070707070701000001070707070707070707070707010000010707060601010d0d01010707010000010707060601010d0d010107070100000107070101070706060d0d07070100000107070101070706060d0d07070100000107070d0d01010d0d060607070100000107070d0d01010d0d060607070100000107070707070707070707070701000001070707070707070707070707010000010101010101010101010101010100")
	metadata.bg_color = bg_color
	metadata.blackest_color = blackest_color
	metadata.whitest_color = whitest_color
	metadata.hidden_toggles = hidden_toggles
	metadata.hidden = copy(hidden)
	metadata.locked = copy(locked)
	metadata.pickers_mode = pickers_mode
	metadata.hue_offset = hue_offset
	metadata.test_mode = test_mode
	metadata.test_cube_colors = copy(test_cube_colors)
	metadata.test_ramp_colors = test_ramp_colors and test_ramp_colors:convert("u8")
	return metadata
end


function load_metadata(metadata)
	metadata = metadata or {}
	bg_color = metadata.bg_color or 0
	blackest_color = metadata.blackest_color or 0
	whitest_color = metadata.whitest_color or 7
	
	if type(metadata.hidden_toggles) == "table" then
		hidden_toggles = metadata.hidden_toggles
	else
		hidden_toggles = {}
		for row = 0, 3 do
			hidden_toggles[row] = false
		end
	end
	
	if type(metadata.hidden) == "table" then
		hidden = metadata.hidden
	else
		hidden = {}
		for c = 0, 63 do
			hidden[c] = false
		end
	end
	
	if type(metadata.locked) == "table" then
		locked = metadata.locked
	elseif pwf() == "/ram/cart/pal/0.pal" then
		-- This only occurs when a default starting file
		-- is created.
		for c = 0, 63 do
			locked[c] = c <= 31
		end
	else
		locked = {}
		for c = 0, 63 do
			locked[c] = false
		end
	end

	if type(metadata.pickers_mode) == "string" then
		pickers_mode = metadata.pickers_mode
	else
		pickers_mode = "linear_hue"
	end
	
	if type(metadata.hue_offset) == "number" then
		hue_offset = metadata.hue_offset
	else
		hue_offset = 0.0
	end

	if type(metadata.test_mode) == "string" then
		test_mode = metadata.test_mode
	else
		test_mode = "cubes"
	end

	if type(metadata.test_cube_colors) == "table" then
		test_cube_colors = copy(metadata.test_cube_colors)
	else
		test_cube_colors = default_test_cube_colors()
	end
	
	if type(metadata.test_ramp_colors) == "userdata" then
		test_ramp_colors = metadata.test_ramp_colors:convert("u8")
	else
		test_ramp_colors = default_test_ramp_colors()
	end
end


-- Load and save pal files -------------------------------------------------------


function load_pal_file(data, metadata)
	if data then
		if type(data) == "userdata" and data:width() == 64 then
			for c = 0, 63 do
				if data[c] then
					poke_color_code(c, data[c])
				end
			end
		else
			notify("unable to load working file")
			return
		end
	else
		-- New file
	end
	rebuild_palette()
	load_metadata(metadata)
	update_hidden_toggles()
end


function save_pal_file()
	local output = userdata("i32", 64)
	for c = 0, 63 do
		output:set(c, color_code(c))
	end
	return output, create_metadata()
end


-- Load and save hex files ---------------------------------------------------------


function load_hex_file(data, metadata)
	if type(data) == "string" then
		local lines = split(data, "\n", false)
		local codes = {}
		for l in all(lines) do
			local code = tonum("0x" .. l:gsub("%s",""))
			if type(code) == "number" then
				codes[#codes + 1] = code
			elseif code then
				notify("error importing hex file")
			end
		end
		local start = 0
		if current_import_choice == "dont_clobber" then
			-- TODO: put in separate function and add menu item
			for c = 0, 32 do
				poke_color_code(c, peek4(0x5000 + 4 * (64 + c)))
			end
			start = 32
		end
		if #codes > 64 - start then
			notify("*** not enough space to import all the colors ***")
		end
		for c = start, 63 do
			if codes[c - start + 1] then
				poke_color_code(c, codes[c - start + 1])
			else
				poke_color_code(c, 0x000000)
			end
		end
		rebuild_palette()
	elseif data then
		notify("import hex file: unkown type: " .. type(data))
	end

	load_metadata(metadata)
	if current_import_choice == "dont_clobber" then
		active_color = nil
		for c = 0, 31 do
			hidden[c] = true
			locked[c] = true
		end
		hidden_toggles[0] = true
		hidden_toggles[1] = true
		blackest_color = 0
		whitest_color = 7
		bg_color = 0
	else
		local best_black, best_white = find_blackest_and_whitest()
		blackest_color = metadata.blackest_color or best_black
		whitest_color = metadata.whitest_color or best_white
		bg_color = metadata.bg_color or blackest_color
	end
	update_hidden_toggles()
end


function save_hex_file()
	-- Don't export trailing black colors
	local fin = 63
	while fin > 0 and color_code(fin) == 0 do
		fin -= 1
	end
	
	local output = ""
	for c = 0, fin do
		output ..= color_hex(c) .. "\n"
	end
	return output, { metadata_format="none" }
end

:: src/globals.lua
--[[pod_format="raw",created="2024-04-03 09:15:53",modified="2025-03-23 16:12:38",revision=6729]]
current_import_choice = "dont_clobber"

undo_stack = nil

padlock_flashing = false
padlock_flashing_time = 0

circling_anim_timer = 0

gui = nil
gui_changed = false

is_new_file = false
select_file_for_export = false
imported_hex_file = nil

blink_timer = 180 + math.random(1, 6) * 90
blink_eye = math.random(0, 3)
crying_a_timer = 0
crying_a_done = false

help_current_line = 1


-- Saved in settings ----------------------------------------------------------


user_settings = {
	send_palette = true,
	show_color_names = true,
	show_color_band = true,
	open_in_gfx_workspace = false,
	dont_blink = false,
	no_jump_scares = false,
}


-- Saved in metadata --------------------------------------------------------------


okpal_version = "1.2.2"

active_color = nil
bg_color = 0 -- TODO: what about fg?
blackest_color = 0 -- TODO: remove?
whitest_color = 7 -- TODO: remove?

hidden_toggles = { [0] = false, false, false, false }
hidden = {}
for i = 0, 63 do hidden[i] = false end
locked = {}
for i = 0, 63 do locked[i] = i <= 31 end

pickers_mode = "linear_hue"
hue_offset = 0.0

test_mode = "cubes"
test_cube_colors = nil
test_ramp_colors = nil


-- Constants ----------------------------------------------------------------------


function default_test_cube_colors()
	return {
		[0] = 
		{15, 31, 4},
		{31, 4, 20},
		{4, 20, 21},
		--
		{10, 9, 25},
		{9, 25, 24},
		{8, 24, 2},
		--
		{26, 11, 27},
		{11, 27, 3},
		{27, 3, 19},
		--
		{28, 17, 19},
		{28, 12, 16},
		{12, 16, 1},
		--
		{6, 29, 13},
		{29, 13, 18},
		{13, 18, 1},
		--
		{7, 23, 14},
		{23, 14, 13},
		{14, 30, 18},
		--
		{7, 6, 22},
		{6, 22, 5},
		{22, 5, 21},
		--
		{1, 1, 1},
		{1, 1, 1},
		{1, 1, 1},
		--
	}
end


function default_test_ramp_colors()
	local ud = userdata("u8", 10, 27, 0)
	ud:set(
		0, 0,
		 0, 24,  8, 25,  9, 10, 26, 11, 27,  0,
		 6,  0,  0,  0,  0,  0,  0,  0,  3,  0, 
		22,  0,  0,  0,  0,  0,  0,  0, 19,  0, 
		 5,  0,  0,  0,  0,  0,  0,  0,  1,  0, 
		13,  0,  0,  0,  0,  0,  0,  0, 16,  0, 
		29,  0,  0,  0,  0,  0,  0,  0, 17,  0, 
		23,  0,  0,  0,  0,  0,  0,  0, 12,  0, 
		14,  0,  0,  0,  0,  0,  0,  0, 28,  0, 
		30, 18,  2, 21, 20,  4, 31, 15,  7,  0,
		 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
		 0, 20,  4, 31, 15,  8, 24,  2,  0,  0,
		21,  5, 22,  6,  7, 23, 14, 30,  0,  0,
		 1, 16, 17, 12, 28, 29, 13, 18,  0,  0,
		19,  3, 27, 11, 26, 10,  9, 25,  0,  0
	)
	return ud
end	

:: src/gui.lua
--[[pod_format="raw",created="2024-03-31 05:58:06",modified="2025-03-22 10:11:52",revision=9825]]
function generate_gui()
	gui = create_gui()
	generate_palette_gui()
end


-----------------------------------------------------------------------------------


local modal = nil


function open_modal(width, height, autoclose)
	if modal ~= nil then
		--TODO: !!!
		return
	end

	modal = gui:attach {
		x = 0, y = 0,
		width = gui.width, height = gui.height,
		autoclose = autoclose or false,
		click = function(self, msg)
			if msg.has_pointer and self.autoclose then
				close_modal()
			end
		end
	}
	local el = modal:attach {
		x = (modal.width - width) // 2, y = (modal.height - height) // 2,
		width = width, height = height,
		draw = function(self)
			clip()
			rect(-3, -3, self.width+3, self.height+3, bg_color)
			rectfill(-2, -2, self.width+2, self.height+2, outline_color())
			rect(-1, -1, self.width+1, self.height+1, bg_color)
		end,
	}
	return el
end


function has_modal()
	return modal ~= nil
end


function refresh_modal()
	if has_modal() then
		gui:attach(modal)
	end
end


function close_modal()
	if modal then
		modal:detach()
	end
	modal = nil
	gui_changed = true -- necessary after closing settings dialog
end


-----------------------------------------------------------------------------------


function create_label(el)
	el.width = el.width or (5 * #el.label + 4)
	el.height = el.height or 9
	gui:new(el)
	function el:draw()
		print(self.label, 0, 0, self.fg or outline_color())
	end
	return el
end


-----------------------------------------------------------------------------------


function create_button(el)
	local label = el.label or "---"
	el.width = el.width or (#label * 5 + 8 + 8)
	el.height = el.height or 16
	el.cursor = "pointer"

	function el:draw(msg)
		local fg = self.fg or bg_color
		line(2, 0, self.width - 3, 0, fg)
		pset(1, 1, fg)
		line(2, self.height - 1, self.width - 3, self.height - 1, fg)
		pset(self.width - 2, 1, fg)
		line(0, 2, 0, self.height - 3, fg)
		pset(1, self.height - 2, fg)
		line(self.width - 1, 2, self.width - 1, self.height - 3, fg)
		pset(self.width - 2, self.height - 2, fg)
		local pressed = msg.has_pointer and self.clicked
		if pressed then
			rectfill(1, 1, self.width - 2, self.height - 2, fg)
		end
		print(self.label or "---", 9, 4, pressed and outline_color() or fg)
	end
	
	function el:click()
		self.clicked = true
	end
	
	function el:release(msg)
		self.clicked = false
		if (msg.has_pointer and self.act) self.act()
	end	

	return el
end


function create_action_button(el)
	local s = get_spr(el.sprite)
	el.width = s:width() or 16
	el.height = s:height() or 16
	el.cursor = "pointer"

	function el:draw(msg)
		pal(7, outline_color())
		local s = el.sprite
		if el.active and not el:active() then
			s += 2
		elseif el.clicked and msg.has_pointer then
			s += 1
		end
		spr(s, 0, 0)
		pal(7, 7)
	end
	
	function el:click()
		self.clicked = true
	end
	
	function el:release(msg)
		self.clicked = false
		if (msg.has_pointer and self.act) self.act()
	end	

	return el
end


-----------------------------------------------------------------------------------


function create_field(el)
	el.cursor = "pointer"

	function el:draw()
		local str = type(self.get == "function") and self:get() or "---"
		local fg = type(self.get_fg == "function") and self:get_fg() or outline_color()
		local prefix = self.small_font and "\014" or ""
		if self:has_keyboard_focus() then
			local suffix = (time() % 0.666 > 0.333) and "\016" or ""
			str =  self.str .. suffix
			print(prefix .. str, 1, 1, fg)
			clip()
			rect(-1, -1, self.width, self.height, fg)
		else
			local ww,hh = print(prefix .. str, 0, -1000)
			print(prefix .. str, self.width - ww - 1, 1, fg)
		end
	end

	function el:click()
		self:set_keyboard_focus(true)
		readtext(true)
		self.str = "" -- starting editing new string
	end

	el.custom_update = el.update
	function el:update()
		self:custom_update()
		if self:has_keyboard_focus() then
			while peektext() do
				self.str = self.str .. readtext()
			end
			if keyp("backspace") then
				self.str = sub(self.str, 1, -2)
			end
			if keyp("enter") then
				if type(self.set) == "function" then
					self:set(self.str)
				end
				self:set_keyboard_focus(false)
			end
		end
	end

--	gui:new(el)

	return el
end


-----------------------------------------------------------------------------------


function create_checkbox(el)
	el.width = el.width or (16 + 5 * #el.label + 4)
	el.height = el.height or 12
	el.cursor = "pointer"
	el.get = el.get or function(self) return self.checked end
	el.toggle = el.toggle or function(self) self.checked = not self.checked end
	gui:new(el)

	function el:draw()
		local fg = self.fg or outline_color()
		local checked = self:get()
		pal(7, fg)
		spr(checked and 49 or 48, 0, 0)
		pal(7, 7)
		print(el.label, 16, 1, fg)
	end
	
	function el:release(msg)
		if msg.has_pointer then
			self:toggle()
		end
	end	

	return el
end


------------------------------------------------------------------------------


function create_radio_button(el)
	el.width = 188
	el.height = 12 -- TODO: count the lines?
	el.cursor = "pointer"
	
	function el:draw()
		local fg = self.fg or bg_color
		local choices = self.parent.choices
		local checked = choices and choices[self.group] == self.key
		pal(7, fg)
		spr(checked and 51 or 50, 0, 0)
		pal(7, 7)
		print(el.label, 15, 1, fg)
	end
	
	function el:tap()
		if not self.parent.choices then
			self.parent.choices = {}
		end
		self.parent.choices[self.group] = self.key
	end
	
	return el
end


-- Utility functions ----------------------------------------------------------------


function outline_color()
	if lum(bg_color) < 0.5 then
		return whitest_color
	else
		return blackest_color
	end
end


function contrast_color(c)
	return (lum(c) < 0.5) and whitest_color or blackest_color
end


function contrast_color_darker(c)
	return (lum(c) < 0.15) and whitest_color or blackest_color
end


function distance(ax, ay, bx, by)
	return math.sqrt((ax - bx)^2 + (ay - by)^2)
end
:: src/gui_alt_sliders.lua
--[[pod_format="raw",created="2025-03-11 11:29:57",modified="2025-03-22 10:11:52",revision=2075]]
local rectangle_width = 375
local rectangle_height = 98
local rectangle_border = 7
local rectangle_inner_width = rectangle_width - 2 * rectangle_border
local rectangle_inner_height = rectangle_height - 2 * rectangle_border


-------------------------------------------------------------------------------


local function hv_coords(c, ordinate)
	local hue = (hue(c) + hue_offset) % 1.0
	local v = color_component(c, ordinate)
	local x = rectangle_border + hue * rectangle_inner_width
	local y = rectangle_border + rectangle_inner_height - v * rectangle_inner_height
	return x, y
end


local function coords_hv(x, y)
	local hue = (x - rectangle_border) / rectangle_inner_width
	hue = (hue - hue_offset) % 1.0
	local v = 1.0 - ((y - rectangle_border) / rectangle_inner_height)
	return hue, v
end


local function h_coords(hue)
	hue = (hue % 1.0)
	local x = rectangle_border + hue * rectangle_inner_width
	return x
end


---------------------------------------------------------------------------------


function create_rectangle_picker(el)
	el.ordinate = el.ordinate or "l"
	el.width = rectangle_width
	el.height = rectangle_height
	el.drag_delta = nil
		
	function el.draw(self, _msg)
		rect(
			rectangle_border - 1, rectangle_border - 1, 
			rectangle_border + rectangle_inner_width + 1, rectangle_border + rectangle_inner_height + 1, 
			outline_color()
		)
		for c = 0, 63 do
			if not hidden[c] and lum(c) != 0 then
				local x, y = hv_coords(c, self.ordinate)
				pal(14, c)
				spr(11, x - 5, y - 5)
				pal(14, 14)
			end
		end
		if active_color and not hidden[active_color] then
			local x, y = hv_coords(active_color, self.ordinate)
			pal(7, outline_color())
			pal(14, active_color)
			spr(
				self.drag_delta and 13 or 12,
				x - 5, y - 5,
				x + 5, y + 5
			)
			pal(14, 14)
			pal(7, 7)
			if circling_anim_timer > 0 then
				local delta = math.floor(0.5 + 5 + 10 * circling_anim_timer * circling_anim_timer)
				oval(
					x - delta, y - delta,
					x + delta, y + delta,
					outline_color()
				)
			end
		end
		clip()
		pal(7, outline_color())
		spr(self.ordinate == "l" and 22 or 23, -11, self.height - 74)
		pal(7, 7)
	end
	
	function el.hover(self, msg)
		self.cursor = 1
		if active_color and not hidden[active_color] then
			local ax, ay = hv_coords(active_color, self.ordinate)
			if distance(ax, ay, msg.mx, msg.my) < 6 then
				self.cursor = "pointer"
			end
		end
		-- In reverse order to prioritize colors on top
		for c = 63, 0, -1 do
			local cx, cy = hv_coords(c, self.ordinate)
			if distance(cx, cy, msg.mx, msg.my) < 5 and not hidden[c] and lum(c) != 0 then
				self.cursor = "pointer"
			end
		end
	end
	
	function el.click(self, msg)
		if active_color and not hidden[active_color] then
			local ax, ay = hv_coords(active_color, self.ordinate)
			if distance(ax, ay, msg.mx, msg.my) < 6 then
				undo_stack:checkpoint()
				mouselock(0x4|0x8, 1.0, 0.25)
				self.cursor = 0
				self.drag_delta = { ox = ax, oy = ay, x = 0, y = 0 }
				return
			end
		end
		
		active_color = nil
		-- In reverse order to prioritize colors on top
		for c = 63, 0, -1 do
			local cx, cy = hv_coords(c, self.ordinate)
			if distance(cx, cy, msg.mx, msg.my) < 5 and not hidden[c] and lum(c) != 0 then
				undo_stack:checkpoint()
				active_color = c
				local ax, ay = hv_coords(active_color, self.ordinate)
				mouselock(0x4|0x8, 1.0, 0.25)
				self.cursor = 0
				self.drag_delta = { ox = ax, oy = ay, x = 0, y = 0 }
				return
			end
		end
		self.drag_delta = nil
	end
	
	function el.drag(self, msg)
		if (not active_color) return
		if (not self.drag_delta) return
		if locked[active_color] then
			padlock_flashing = true
		elseif msg.mb & 0x07 then
			self.drag_delta.x += msg.dx
			self.drag_delta.y += msg.dy
			local ax = self.drag_delta.ox + self.drag_delta.x * 0.25
			local ay = self.drag_delta.oy + self.drag_delta.y * 0.25
			local hue, v = coords_hv(ax, ay)
			hue = max(0.0, hue)
			if msg.mb & 2 ~= 0 then hue = nil end
			if msg.mb & 4 ~= 0 then v = nil end
			local sat = self.ordinate == "s" and v or nil
			local lum = self.ordinate == "l" and v or nil
			change_color(active_color, hue, sat, lum)
		end
	end
	
	function el.release(self, msg)
		send_palette()
		self.drag_delta = nil
		padlock_flashing = false
		padlock_flashing_time = 0
		mouselock(false)
		self.cursor = nil
	end
	
	function el.mousewheel(self, msg)
		hue_offset += (msg.wheel_x / 360.0) % 1.0
		hue_offset += (4 * msg.wheel_y / 360.0) % 1.0
	end

	return el
end


--------------------------------------------------------------------------------


function create_hue_knob(el)
	el.width = rectangle_width
	el.height = 9
	
	function el.draw(self, _msg)
		if active_color and not hidden[active_color] then
			local ax, _ = hv_coords(active_color, "l")
			pal(7, outline_color())
			pal(13, 0)
			spr(5, ax - 4, 0)
			pal(13, 13)
			pal(7, 7)
		end
	end	
	
	function el.hover(self, msg)
		self.cursor = 1
		if active_color and not hidden[active_color] then
			local ax, _ = hv_coords(active_color, "l")
			if msg.mx and msg.mx >= ax - 4 and msg.mx <= ax + 4 then
				self.cursor = "grab"
			end
		end
	end

	function el.click(self, msg)
		undo_stack:checkpoint()
		if active_color and not hidden[active_color] then
			local ax, _ = hv_coords(active_color, "l")
			if msg.mx and msg.mx >= ax - 4 and msg.mx <= ax + 4 then
				mouselock(0x4|0x8, 1.0, 0.25)
				self.cursor = 0
				self.drag_delta = { ox = ax, x = 0 }
			end
		end
	end
	
	function el.drag(self, msg)
		if (not active_color) return
		if (not self.drag_delta) return
		if locked[active_color] then
			padlock_flashing = true
		else
			self.drag_delta.x += msg.dx
			local ax = self.drag_delta.ox + self.drag_delta.x * 0.25
			local hue, _ = coords_hv(ax, 0)
			hue = max(0.0, hue)
			change_color(active_color, hue, nil, nil)
		end
	end
	
	function el.release(self, msg)
		send_palette()
		self.drag_delta = nil
		padlock_flashing = false
		padlock_flashing_time = 0
		mouselock(false)
		self.cursor = 1
	end
			
	return el
end


--------------------------------------------------------------------------------


function create_val_knob(el)
	el.ordinate = el.ordinate or "l"
	el.width = 9
	el.height = rectangle_height
	
	function el.draw(self, _msg)
		if active_color and not hidden[active_color] then
			local _, ay = hv_coords(active_color, self.ordinate)
			pal(7, outline_color())
			pal(13, active_color)
			spr(6, 0, ay - 4)
			pal(13, 13)
			pal(7, 7)
		end
	end	
	
	function el.hover(self, msg)
		self.cursor = 1
		if active_color and not hidden[active_color] then
			local _, ay = hv_coords(active_color, self.ordinate)
			if msg.my and msg.my >= ay - 4 and msg.my <= ay + 4 then
				self.cursor = "grab"
			end
		end
	end

	function el.click(self, msg)
		undo_stack:checkpoint()
		if active_color and not hidden[active_color] then
			local _, ay = hv_coords(active_color, self.ordinate)
			if msg.my and msg.my >= ay - 4 and msg.my <= ay + 4 then
				mouselock(0x4|0x8, 1.0, 0.25)
				self.cursor = 0
				self.drag_delta = { oy = ay, y = 0 }
			end
		end
	end
	
	function el.drag(self, msg)
		if (not active_color) return
		if (not self.drag_delta) return
		if locked[active_color] then
			padlock_flashing = true
		else
			self.drag_delta.y += msg.dy
			local ay = self.drag_delta.oy + self.drag_delta.y * 0.25
			local _, v = coords_hv(0, ay)
			local sat = self.ordinate == "s" and v or nil
			local lum = self.ordinate == "l" and v or nil
			change_color(active_color, nil, sat, lum)
		end
	end
	
	function el.release(self, msg)
		send_palette()
		self.drag_delta_y = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end
			
	return el
end


--------------------------------------------------------------------------------


function create_color_names(el)
	el.width = rectangle_inner_width + 1
	el.height = 8
	function el.draw(self, msg)
		local x = math.floor(0.5 + h_coords(hue_offset))
		spr(46, x - rectangle_border - rectangle_inner_width - 1, 0)
		spr(46, x - rectangle_border, 0)
	end
	return el
end


--local colors = {
--	{ name = "rose", hue = 2.0 / 360.0 },
--	{ name = "red", hue = 29.0 / 360.0 },
--	{ name = "orange", hue = 53.0 / 360.0 },
--	{ name = "yellow", hue = 110.0 / 360.0 },
--	{ name = "green", hue = 142.0 / 360.0 },
--	{ name = "cyan", hue = 195.0 / 360.0 },
--	{ name = "blue", hue = 264.0 / 360.0 },
--	{ name = "violet", hue = 294.0 / 360.0 },
--	{ name = "purple", hue = 328.0 / 360.0 },
----	{ name = "magenta", hue = 328.0 / 360.0 },
--}
--
--
--function create_hue_ruler(el)
--	el.width = rectangle_inner_width
--	el.height = 8
--	function el.draw(self, msg)
--		for col in all(colors) do
--			local x = h_coords(hue_offset + col.hue)
--			print("\014" .. col.name, x - (#col.name * 2) - rectangle_border, 0)
--		end
--	end
--	return el
--end


--------------------------------------------------------------------------------


function init_color_band()
	-- Create the hue gradient palette
	local hue_step = 1.0 / 62.0
	local hue = 0
	for c = 1, 63 do
		if c ~= 1 and c ~= 7 then
			local color_code = oklab.okhsl_to_color({ h = hue, s = 1.0, l = 0.6 })
			poke4(0x5300 + 4 * c, color_code)
			hue += hue_step
		end
	end
	-- Create the sprite for the band
	local band = get_spr(44)
	set_draw_target(band)
	local width = band:width()
	local flat = (width // 61) + 1
	for x = 0, band:width() - 1 do
		local c = 1 + (x // flat )
		if c >= 1 then c += 1 end
		if c >= 7 then c += 1 end
		line(x, 2, x, 9, c)
	end
	set_draw_target()
end


function show_color_band()
	poke(0x5440, 0b11111111, 0b00001111)
end


function hide_color_band()
	poke(0x5440, 0b00000000, 0b00000000)
end


function create_color_band(el)
	el.width = rectangle_inner_width + 1
	el.height = 8
	function el.draw(self, _msg)
		local x = math.floor(0.5 + h_coords(hue_offset))
		spr(44, x - rectangle_border - rectangle_inner_width - 1, 0)
		spr(44, x - rectangle_border, 0)
	end
	return el
end

--------------------------------------------------------------------------------


function create_hue_scrubber(el)
	el.width = get_spr(47):width()
	el.height = get_spr(47):height()
	el.cursor = "grab"
	gui:new(el)
	function el.draw(self, _msg)
		pal(7, outline_color())
		spr(47, 0, 0)
		pal(7, 7)
	end
	function el.click(self, msg)
		self.drag_delta = msg.mx
		self.drag_origin = hue_offset
	end
	function el.drag(self, msg)
		if self.drag_delta then
			local dh, _ = coords_hv(msg.mx, 0) - coords_hv(self.drag_delta, 0)
			hue_offset = self.drag_origin + dh
		end
	end
	function el.release(self, msg)
		self.drag_delta = nil
	end
	function el.tap(self, msg)
		hue_offset = 0.0
	end
	return el
end
:: src/gui_help.lua
--[[pod_format="raw",created="2025-03-07 10:21:37",modified="2025-03-07 17:37:27",revision=440]]
local text_view

function open_help()
	local el = open_modal(270, 250, true)
	if not el then
		return
	end
	text_view = el:attach(create_text_view { x = 10, y = 0, width = 250, height = 250 })
	text_view:set_text(fetch("manual.txt"))
end


function create_text_view(el)
	el.lines = {}

	function el:set_text(text)
		el.lines = soft_wrap(text, self.width)
	end

	function el:draw(msg)
		cursor(0, 0)
		color(bg_color)
		local l = help_current_line
		local y = 0
		while y < self.height do
			print(self.lines[l])
			y += 11
			l += 1
		end
	end
	
	function el:mousewheel(msg)
		local nb_lines = self.height // 11
		help_current_line = mid(
			1,
			help_current_line - (msg.wheel_y * 3),	
			#self.lines - nb_lines
		)
	end	

	return el
end
:: src/gui_hexdialog.lua
--[[pod_format="raw",created="2025-03-05 12:06:52",modified="2025-03-11 16:50:38",revision=318]]
function open_import_hex_file_dialog()
	local el = open_modal(180, 100, false)
	el:attach(create_label { x = 50, y = 6, label = "Import \".hex\" file", fg = bg_color })
	el:attach(create_radio_button {
		x = 16, y = 36, 
		label = "Import after Picotron's colors",
		group = "import_hex",
		key = "dont_clobber",
	})
	el:attach(create_radio_button {
		x = 16, y = 56, 
		label = "Replace all colors",
		group = "import_hex",
		key = "overwrite",
	})
	el.choices = { import_hex = "dont_clobber" }
	el:attach(create_button {
		x = 110, y = 80,
		label = "Import",
		act = function() prepare_imported_hex(el) end
	})
end


function prepare_imported_hex(dialog)
	current_import_choice = dialog.choices.import_hex
	load_hex_file(imported_hex_file.data, imported_hex_file.metadata or {})
	clear_cube_colors()
	clear_ramp_colors()
	if (undo_stack) undo_stack:reset()
	send_palette()
	imported_hex_file = nil
	close_modal()
	gui_changed = true
end
:: src/gui_newfile.lua
--[[pod_format="raw",created="2025-03-05 08:57:06",modified="2025-03-12 09:49:40",revision=188]]
function open_new_file_dialog()
	local el = open_modal(180, 100, false)
	el:attach(create_label { x = 60, y = 6, label = "New Palette", fg = bg_color })
	el:attach(create_radio_button {
		x = 16, y = 36, 
		label = "Keep default colors",
		group = "new_palette",
		key = "keep_default",
	})
	el:attach(create_radio_button {
		x = 16, y = 56, 
		label = "Start with empty palette",
		group = "new_palette",
		key = "empty_palette",
	})
	el.choices = { new_palette = "keep_default" }
	el:attach(create_button {
		x = 110, y = 80,
		label = "Let's go!",
		act = function() prepare_new_file(el) end
	})
end


function prepare_new_file(dialog)
	if dialog.choices.new_palette == "empty_palette" then
		clear_colors()
	end
	close_modal()
end
:: src/gui_old_sliders.lua
--[[pod_format="raw",created="2025-03-17 19:49:11",modified="2025-03-22 10:11:52",revision=758]]
local circle_size = 190
local circle_border = 13
local circle_inner = circle_size - 2 * circle_border


local square_size = 190
local square_border = 7
local square_inner = square_size - 2 * square_border


------------------------------------------------------------------------------------


local function sl_coords(c)
	local sat = sat(c)
	local lum = lum(c)
	local x = square_border + sat * square_inner
	local y = square_border + square_inner - lum * square_inner
	return x, y
end


local function coords_sl(x, y)
	local sat = (x - square_border) / square_inner
	local lum = 1.0 - ((y - square_border) / square_inner)
	return sat, lum
end


-- Remove 0.25 to compensate for Picotron's angle origin,
-- and 29/360 to compensate for OkLab weird position of
-- the red color.
local angle_correction = 0.25 + 0.08


local function hs_coords(c)
	local hue = hue(c)
	local sat = mid(0.0, sat(c), 1.0)
--	sat = ((sat * 3.0) / 4.0) + 0.25
	local a = angle_correction - hue
	local dx = sat * cos(a) * (circle_inner / 2)
	local dy = sat * sin(a) * (circle_inner / 2)
	local x = circle_border + (circle_inner / 2) + dx
	local y = circle_border + (circle_inner / 2) + dy
	return x, y
end


local function h_coords(c, radius_delta, hue_delta)
	local r = circle_inner + (radius_delta or 0)
	local hue = hue(c) + (hue_delta or 0)
	local a = angle_correction - hue
	local dx = cos(a) * (r / 2)
	local dy = sin(a) * (r / 2)
	local x = circle_border + (circle_inner / 2) + dx + 0.5
	local y = circle_border + (circle_inner / 2) + dy + 0.5
	return x, y
end


local function coords_hs(x, y)
	local dx = x - (circle_border + (circle_inner / 2))
	local dy = y - (circle_border + (circle_inner / 2))
	local hue = -atan2(dx, dy) + angle_correction
	dx = (2.0 * dx) / circle_inner
	dy = (2.0 * dy) / circle_inner
	local sat = sqrt(dx * dx + dy * dy) -- / (circle_inner / 2)
	return hue, sat
end


--local function coords_h(x, y)
--	local s = circle_size + 2 * circle_border
--	local r = s - 6
--	local dx = x - ((s / 2) + 0.5)
--	local dy = y - ((s / 2) + 0.5)
--	local hue = -atan2(dx, dy) + angle_correction
--	dx = (2.0 * dx) / r
--	dy = (2.0 * dy) / r
--	local sat = sqrt(dx * dx + dy * dy)
--	return hue, sat
--end


---------------------------------------------------------------------------------------


function create_hue_sat_picker(el)
	el.width = circle_size
	el.height = circle_size
	el.drag_delta = nil
	
	function el.draw(self, _msg)
		oval(
			circle_border - 1, circle_border - 1,
			circle_border + circle_inner + 1, circle_border + circle_inner + 1,
			outline_color()
		)
		line(circle_size \ 2 - 12, circle_size \ 2, circle_size \ 2 + 12, circle_size \ 2, outline_color())
		line(circle_size \ 2, circle_size \ 2 - 12, circle_size \ 2, circle_size \ 2 + 12, outline_color())
--		fillp(0b0101101001011010)
--		rectfill(circle_size \ 2 - 24, circle_size \ 2, circle_size \ 2 + 24, circle_size \ 2, 7)
--		rectfill(circle_size \ 2, circle_size \ 2 - 24, circle_size \ 2, circle_size \ 2 + 24, 7)
--		fillp()
		for c = 0, 63 do
			if not hidden[c] and lum(c) != 0 then
				local x, y = hs_coords(c)
				pal(14, c)
				spr(11, x - 5, y - 5)
				pal(14, 14)
			end
		end
		if active_color and not hidden[active_color] then
			-- Triangular knob
			local ax, ay = h_coords(active_color, 6, 0.0)
			local bx, by = h_coords(active_color, 24, -0.008)
			local cx, cy = h_coords(active_color, 24, 0.008)
			pal(7, outline_color())
			line(ax, ay, bx, by, 7)
			line(bx, by, cx, cy, 7)
			line(cx, cy, ax, ay, 7)
			pal(7)
			-- Active dot
			local x, y = hs_coords(active_color)
			pal(7, outline_color())
			pal(14, active_color)
			spr(
				self.drag_delta and 13 or 12,
				x - 5, y - 5
			)
			pal(14, 14)
			pal(7, 7)
			if circling_anim_timer > 0 then
				local delta = math.floor(0.5 + 5 + 10 * circling_anim_timer * circling_anim_timer)
				oval(
					x - delta, y - delta,
					x + delta, y + delta,
					outline_color()
				)
			end
		end
		clip()
		pal(7, outline_color())
		spr(14, 0, 138)
		pal(7, 7)
	end	
	
	function el.hover(self, msg)
		self.cursor = 1
		if active_color and not hidden[active_color] then
			local h, r = coords_hs(msg.mx, msg.my)
			local dh = h - hue(active_color)
			if dh < -0.5 then dh += 1.0 end
			if
				r >= 1.02 and r <= 1.18
				and abs(dh) <= 0.01
			then
				self.cursor = "grab"
			else
				local ax, ay = hs_coords(active_color)
				if distance(ax, ay, msg.mx, msg.my) < 6 then
					self.cursor = "pointer"
				end
			end
		end
		-- In reverse order to prioritize colors on top
		for c = 63, 0, -1 do
			local cx, cy = hs_coords(c, self.ordinate)
			if distance(cx, cy, msg.mx, msg.my) < 5 and not hidden[c] and lum(c) != 0 then
				self.cursor = "pointer"
			end
		end
	end
	
	function el.click(self, msg)
		local h, r = coords_hs(msg.mx, msg.my)
		local active_hue = active_color and hue(active_color) or 0
		local dh = h - active_hue
		if dh < -0.5 then dh += 1.0 end
		if
			(active_color and not hidden[active_color])
			and r >= 1.02 and r <= 1.18
			and abs(dh) <= 0.01
		then
			undo_stack:checkpoint()
			mouselock(0x4|0x8, 1.0, 0.25)
			self.cursor = 0
			local ax, ay = h_coords(active_color, 10)
			self.knob_drag_delta = { ox = ax, oy = ay, x = 0, y = 0 }
			return true
		elseif active_color and not hidden[active_color] then
			local ax, ay = hs_coords(active_color)
			if distance(ax, ay, msg.mx, msg.my) < 6 then
				undo_stack:checkpoint()
				local ax, ay = hs_coords(active_color)
				mouselock(0x4|0x8, 1.0, 0.25)
				self.cursor = 0
				self.drag_delta = { ox = ax, oy = ay, x = 0, y = 0 }
				return true
			end
		end
		active_color = nil
		-- In reverse order to prioritize colors on top
		for c = 63, 0, -1 do
			local cx, cy = hs_coords(c)
			if distance(cx, cy, msg.mx, msg.my) < 5 and not hidden[c] and lum(c) != 0 then
				undo_stack:checkpoint()
				active_color = c
				local ax, ay = hs_coords(active_color)
				mouselock(0x4|0x8, 1.0, 0.25)
				self.cursor = 0
				self.drag_delta = { ox = ax, oy = ay, x = 0, y = 0 }
				return true
			end
		end
		self.knob_drag_delta = nil
		self.drag_delta = nil
		return true
	end
	
	function el.drag(self, msg)
		if not active_color then return end
		if locked[active_color] then
			padlock_flashing = true
			return
		end
		if self.knob_drag_delta then
			self.knob_drag_delta.x += msg.dx
			self.knob_drag_delta.y += msg.dy
			local ax = self.knob_drag_delta.ox + self.knob_drag_delta.x * 0.25
			local ay = self.knob_drag_delta.oy + self.knob_drag_delta.y * 0.25
			local hue, sat = coords_hs(ax, ay)
			change_color(active_color, hue, nil, nil)
		elseif self.drag_delta then
			self.drag_delta.x += msg.dx
			self.drag_delta.y += msg.dy
			local ax = self.drag_delta.ox + self.drag_delta.x * 0.25
			local ay = self.drag_delta.oy + self.drag_delta.y * 0.25
			local hue, sat = coords_hs(ax, ay)
			if msg.mb == 4 then hue = nil end
			if msg.mb == 2 then sat = nil end
			change_color(active_color, hue, sat, nil)
			return true
		end
	end
	
	function el.release(self, msg)
		send_palette()
		self.knob_drag_delta = nil
		self.drag_delta = nil
		padlock_flashing = false
		padlock_flashing_time = 0
		mouselock(false)
		self.cursor = 1
	end

	return el
end


-------------------------------------------------------------------------------------


function create_sat_lum_picker(el)
	el.width = square_size
	el.height = square_size
	el.drag_delta = nil
		
	function el.draw(self, _msg)
		rect(
			square_border - 1, square_border - 1, 
			square_border + square_inner + 1, square_border + square_inner + 1, 
			outline_color()
		)
		for c = 0, 63 do
			local dh = hue(c) - hue(active_color or 0)
			if dh < -0.5 then dh += 1.0 end
			if not hidden[c] and lum(c) != 0 then -- and abs(dh) <= 0.1 then
				local x, y = sl_coords(c)
				pal(14, c)
				spr(11, x - 5, y - 5)
				pal(14, 14)
			end
		end
		if active_color and not hidden[active_color] then
			local x, y = sl_coords(active_color)
			pal(7, outline_color())
			pal(14, active_color)
			spr(
				self.drag_delta and 13 or 12,
				x - 5, y - 5,
				x + 5, y + 5
			)
			pal(14, 14)
			pal(7, 7)
			if circling_anim_timer > 0 then
				local delta = math.floor(0.5 + 5 + 10 * circling_anim_timer * circling_anim_timer)
				oval(
					x - delta, y - delta,
					x + delta, y + delta,
					outline_color()
				)
			end
		end
		clip()
		pal(7, outline_color())
		spr(15, -11, self.height + 12 - 64)
		pal(7, 7)
	end	
	
	function el.hover(self, msg)
		self.cursor = 1
		if active_color and not hidden[active_color] then
			local ax, ay = sl_coords(active_color)
			if distance(ax, ay, msg.mx, msg.my) < 6 then
				self.cursor = "grab"
			end
		end
		-- In reverse order to prioritize colors on top
		for c = 63, 0, -1 do
			local cx, cy = sl_coords(c, self.ordinate)
			if distance(cx, cy, msg.mx, msg.my) < 5 and not hidden[c] and lum(c) != 0 then
				self.cursor = "pointer"
			end
		end
	end
	
	function el.click(self, msg)
		if active_color and not hidden[active_color] then
			local ax, ay = sl_coords(active_color)
			if distance(ax, ay, msg.mx, msg.my) < 6 then
				undo_stack:checkpoint()
				mouselock(0x4|0x8, 1.0, 0.25)
				self.cursor = 0
				self.drag_delta = { ox = ax, oy = ay, x = 0, y = 0 }
				return
			end
		end
		active_color = nil
		-- In reverse order to prioritize colors on top
		for c = 63, 0, -1 do
			local cx, cy = sl_coords(c)
			if distance(cx, cy, msg.mx, msg.my) < 5 and not hidden[c] and lum(c) != 0 then
				undo_stack:checkpoint()
				active_color = c
				local ax, ay = sl_coords(active_color)
				mouselock(0x4|0x8, 1.0, 0.25)
				self.cursor = 0
				self.drag_delta = { ox = ax, oy = ay, x = 0, y = 0 }
				return
			end
		end
		self.drag_delta = nil
	end
	
	function el.drag(self, msg)
		if (not active_color) return
		if (not self.drag_delta) return
		if locked[active_color] then
			padlock_flashing = true
		else
			self.drag_delta.x += msg.dx
			self.drag_delta.y += msg.dy
			local ax = self.drag_delta.ox + self.drag_delta.x * 0.25
			local ay = self.drag_delta.oy + self.drag_delta.y * 0.25
			local sat, lum = coords_sl(ax, ay)
			if msg.mb == 2 then sat = nil end
			if msg.mb == 4 then lum = nil end
			change_color(active_color, nil, sat, lum)
		end
	end
	
	function el.release(self, msg)
		send_palette()
		self.drag_delta = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end

	return el
end


------------------------------------------------------------------------------------


function create_sat_knob(el)
	el.width = square_size
	el.height = 9
	
	function el.draw(self, _msg)
		if active_color and not hidden[active_color] then
			local ax, _ = sl_coords(active_color)
			pal(7, outline_color())
			pal(13, 0)
			spr(5, ax - 4, 0)
			pal(13, 13)
			pal(7, 7)
		end
	end	
	
	function el.hover(self, msg)
		self.cursor = 1
		if active_color and not hidden[active_color] then
			local ax, _ = sl_coords(active_color)
			if msg.mx and msg.mx >= ax - 4 and msg.mx <= ax + 4 then
				self.cursor = "grab"
			end
		end
	end

	function el.click(self, msg)
		undo_stack:checkpoint()
		if active_color and not hidden[active_color] then
			local ax, _ = sl_coords(active_color)
			if msg.mx and msg.mx >= ax - 4 and msg.mx <= ax + 4 then
				mouselock(0x4|0x8, 1.0, 0.25)
				self.cursor = 0
				self.drag_delta = { ox = ax, x = 0 }
			end
		end
	end
	
	function el.drag(self, msg)
		if (not active_color) return
		if (not self.drag_delta) return
		if locked[active_color] then
			padlock_flashing = true
		else
			self.drag_delta.x += msg.dx
			local ax = self.drag_delta.ox + self.drag_delta.x * 0.25
			local sat, lum = coords_sl(ax, 0)
			change_color(active_color, nil, sat, nil)
		end
	end
	
	function el.release(self, msg)
		send_palette()
		self.drag_delta_x = nil
		padlock_flashing = false
		padlock_flashing_time = 0
		self.cursor = 1
		mouselock(false)
	end
			
	return el
end


--------------------------------------------------------------------------------


function create_lum_knob(el)
	el.width = 9
	el.height = square_size
	
	function el.draw(self, _msg)
		if active_color and not hidden[active_color] then
			local _, ay = sl_coords(active_color)
			pal(7, outline_color())
			pal(13, active_color)
			spr(6, 0, ay - 4)
			pal(13, 13)
			pal(7, 7)
		end
	end	
	
	function el.hover(self, msg)
		self.cursor = 1
		if active_color and not hidden[active_color] then
			local _, ay = sl_coords(active_color)
			if msg.my and msg.my >= ay - 4 and msg.my <= ay + 4 then
				self.cursor = "grab"
			end
		end
	end

	function el.click(self, msg)
		undo_stack:checkpoint()
		if active_color and not hidden[active_color] then
			local _, ay = sl_coords(active_color)
			if msg.my and msg.my >= ay - 4 and msg.my <= ay + 4 then
				mouselock(0x4|0x8, 1.0, 0.25)
				self.cursor = 0
				self.drag_delta = { ox = ax, oy = ay, x = 0, y = 0 }
			end
		end
	end
	
	function el.drag(self, msg)
		if (not active_color) return
		if (not self.drag_delta) return
		if locked[active_color] then
			padlock_flashing = true
		else
			self.drag_delta.y += msg.dy
			local ay = self.drag_delta.oy + self.drag_delta.y * 0.25
			local sat, lum = coords_sl(0, ay)
			change_color(active_color, nil, nil, lum)
		end
	end
	
	function el.release(self, msg)
		send_palette()
		self.drag_delta_y = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end
			
	return el
end

:: src/gui_palette.lua
--[[pod_format="raw",created="2025-02-28 10:09:19",modified="2025-03-23 15:45:13",revision=5043]]
function generate_palette_gui()
	gui.tap = function(self, msg) if (msg.has_pointer) active_color = nil end
	local pal_el = create_palette{ x = 17, y = 6 }
	gui:attach(pal_el)
	gui:attach(create_visibility_buttons { x = pal_el.x - 14, y = pal_el.y + 1 })
	gui:attach(create_color_preview { x = pal_el.x + pal_el.width + 8, y = pal_el.y })
	
	local x_buttons = 347
	gui:attach(create_action_button { x = x_buttons, y = 4, sprite = 16,
		act = function(self) undo_stack:undo(); update_hidden_toggles() end,
		active = function(self) return #(undo_stack.undo_stack) >= 1 end })
	gui:attach(create_action_button { x = x_buttons + 16 + 2, y = 4, sprite = 19,
		act = function(self) undo_stack:redo(); update_hidden_toggles() end,
		active = function(self) return #(undo_stack.redo_stack) >= 1 end })
	gui:attach(create_action_button { x = x_buttons, y = 4 + 16 + 2, sprite = 24,
		act = function(self) open_settings() end })
	gui:attach(create_action_button { x = x_buttons + 16 + 2, y = 4 + 16 + 2, sprite = 27,
		act = function(self) open_help() end })
	gui:attach(create_pickers_mode_switch { x = x_buttons, y = 41 })

	if pickers_mode == "circular_hue" then
		hide_color_band()
		gui:attach(create_hue_sat_picker { x = 0, y = 56 })
		local right = gui:attach(create_sat_lum_picker{ x = 196, y = 270 - 190 - 24, abscissa = "s" })
		gui:attach(create_sat_knob { x = right.x, y = right.y + right.height - 3 })
		gui:attach(create_lum_knob { x = right.x - 5, y = right.y })
	else
		if user_settings.show_color_band then
			show_color_band()
		else
			hide_color_band()
		end
		if user_settings.show_color_names then
			gui:attach(create_color_names { x = 11 + 7, y = 148 })
		end
		if user_settings.show_color_band then
			gui:attach(create_color_band { x = 11 + 7, y = 243 })
		end
		gui:attach(create_rectangle_picker { x = 11, y = 148, ordinate = "s" })
		-- Attach the bottom one last so it has priority for clicks. The two
		-- pickers have a slight overlap due to their borders, and black colors
		-- are difficult to grab otherwise.
		gui:attach(create_rectangle_picker { x = 11, y = 54 })
		gui:attach(create_val_knob { x = 6, y = 56, ordinate = "l" })
		gui:attach(create_val_knob { x = 6, y = 148, ordinate = "s" })
		gui:attach(create_hue_knob { x = 11, y = 243 })
		gui:attach(create_hue_scrubber { x = 174, y = 254 })
	end
	
	local is_hex = (pwf():ext() == "hex")
	gui:attach(create_test_zone { x = 390, y = 4, only_hex_tab = is_hex })	
end


-------------------------------------------------------------------------------


function change_hidden(c, hide)
	hidden[c] = hide
	update_hidden_toggles()
end


function update_hidden_toggles()
	local nb_columns <const> = 16
	for row = 0, 3 do
		local some_non_black = false
		local some_visible = false
		for column = 0, nb_columns - 1 do
			local c = (row * nb_columns) + column
			local is_black = color_code(c) == 0x000000
			if is_black then
				hidden[c] = false
			else
				some_non_black = true
			end
			if (c > 0) and (not is_black) and (not hidden[c]) then
				some_visible = true
			end
		end
		hidden_toggles[row] = some_non_black and (not some_visible)
	end
	dont_blink()
end


-----------------------------------------------------------------------------------


function create_palette(el)
	local size = 12
	local nb_columns = 16
	local nb_rows = 4
	el.width = (nb_columns * size) + 1
	el.height = (nb_rows * size) + 1
	el.cursor = "pointer"

	function el.draw(self, msg)
		clip()
		rect(0, 0, self.width, self.height, outline_color())
		for c = 0, 63 do
			local x = 1 + ((c % nb_columns) * size)
			local y = 1 + ((c \ nb_columns) * size)
			rectfill(x, y, x + size - 1, y + size - 1, c)
			if hidden[c] then
				ovalfill(x + 2, y + 2, x + size - 3, y + size - 3, bg_color)
			end
			if c == active_color then
				rect(
					x + 1, y + 1,
					x + size - 2, y + size - 2,
					contrast_color(active_color)
				)
			end
		end	
		if self.drag_pos then
			local col = (msg.mx - 1) \ size
			local row = (msg.my - 1) \ size
			local c = col + row * nb_columns
			if 0 <= c and c <= 63 then
				local x = 1 + col * size
				local y = 1 + row * size
				if c != active_color and not locked[c] then
					rect(x + 3, y + 3, x + size - 4, y + size - 4, contrast_color(c))
				end
			end
			local mx, my = self.drag_pos.x, self.drag_pos.y
			rectfill(mx, my, mx + 8, my + 8, active_color)		
		end
	end

	function el.click(self, msg)
		local col = min(nb_columns - 1, (msg.mx - 1) \ size)
		local row = min(nb_rows - 1, (msg.my - 1) \ size)
		local c = col + row * nb_columns
		if msg.mb == 1 then
			self.previous_active = active_color
			active_color = c
			self.click_pos = { x = msg.mx, y = msg.my }
		elseif msg.mb == 2 then
			change_hidden(c, not hidden[c])
		end
	end
	
	function el.drag(self, msg)
		if self.click_pos and not self.drag_pos then
			local dx = abs(self.click_pos.x - msg.mx)
			local dy = abs(self.click_pos.y - msg.my)
			if dx > 1 or dy > 1 then
				if locked[active_color] then
					padlock_flashing = true
				else
					self.drag_pos = {}
				end
			end
		end
		if self.drag_pos then
			self.drag_pos = { x = msg.mx, y = msg.my }
		end
	end
	
	function el.release(self, msg)
		if self.drag_pos then
			local col = (msg.mx - 1) \ size
			local row = (msg.my - 1) \ size
			local c = col + row * nb_columns
			if 0 <= c and c <= 63 and not locked[c] then
				undo_stack:checkpoint()
				swap_colors(active_color, c)
				active_color = c
				send_palette()
			end			
		end
		self.click_pos = nil
		self.drag_pos = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end

	function el.tap(self, msg)
		if color_code(active_color) == 0x000000
			or active_color == self.previous_active
		then
			circling_anim_timer = 1.0
			self.previous_active = nil
		end
	end

	function el.mousewheel(self, msg)
		if not active_color then
			active_color = 0
		elseif msg.wheel_y < 0 then
			active_color = (active_color + 1) % 64
		elseif msg.wheel_y > 0 then
			active_color = (active_color - 1) % 64
		end
	end

	return el
end


local blink_anim <const> = { [0] = 40, 41, 42, 43, 43, 43, 42, 41, 40 }


function create_visibility_buttons(el)
	local size = 12
	local nb_rows = 4
	el.width = size
	el.height = nb_rows * size
	el.cursor = "pointer"

	function el.draw(self, msg)
		pal(7, outline_color())
		for row = 0, 3 do
			if hidden_toggles[row] then
				spr(43, 0, row * size)
			else
				local sprite = 40
				if blink_timer <= 0 and blink_eye == row then
					sprite = blink_anim[- blink_timer] 
				end
				spr(sprite, 0, row * size)
			end
		end
		pal(7, 7)
	end
	
	function el.update(self, msg)
		if not user_settings.dont_blink then
			blink_timer -= 1
			if blink_timer <= -9 then
				blink_timer = 180 + math.random(1, 6) * 90
				local nb_eyes = active_color and 4 or 3
				blink_eye = math.random(0, nb_eyes)
				if hidden_toggles[blink_eye] then
					blink_eye = math.random(0, nb_eyes)
				end
			end
		end
	end
	
	function el.tap(self, msg)
		local row = mid(0, msg.my \ size, 3)
		local action = not hidden_toggles[row]
		for c = row * 16, row * 16 + 15 do
			change_hidden(c, action)
		end
		dont_blink()
	end
	
	return el
end


function dont_blink()
	local all_eyes_closed = true
	for i = 0, 3 do
		if not hidden_toggles[i] then all_eyes_closed = false end
	end
	if all_eyes_closed then
		crying_a_timer = 46
	end
end


function blinked()
	if user_settings.no_jump_scares or crying_a_done then
		return
	end
	pal(1, 0)
	if crying_a_timer > 20 then
		spr(254, 0, 0)
	elseif crying_a_timer > 0 then
		spr(255, 0, -16)
	end
	pal(1, 1)
end


------------------------------------------------------------------------------


function create_color_preview(el)
	local size = 12
	el.width = size * 4 + 2 + 120
	el.height = size * 4 + 2

	gui:new(el)

	-- Input field for the color code
	el:attach(create_field {
		x = 5, y = el.height - 12,
		width = 40, height = 9,
		small_font = false,
		get_fg = function(self) return contrast_color(active_color or 0) end,
		get = function(self)
			if (not active_color) return ""
			return "#" .. color_hex(active_color)
		end,
		set = function(self, str)
			if (locked[active_color]) return
			str = str:gsub("%s", ""):gsub("#", "")
			if (#str ~= 6) return
			local code = tonum("0x" .. str)
			if (type(code) ~= "number") return
			undo_stack:checkpoint()
			change_color_code(active_color, code)
		end,
		update = function(self, msg)
			self.hidden = active_color == nil
		end
	})

	-- Input field for hue
	el:attach(create_field {
		x = 96, y = 22,
		width = 21, height = 9,
		small_font = true,
		get_fg = function(self) return outline_color() end,
		get = function(self)
			if (not active_color) return ""
			local h = hue(active_color) * 360.0
			while h < 0.0 do
				h += 360.0
			end
			return string.format("%3.0f\031", h)
		end,
		set = function(self, str)
			if (locked[active_color]) return
			str = str:gsub("%s", ""):gsub("\031", "")
			local h = tonum(str)
			if (type(h) ~= "number") return
			h = (h % 360.0) / 360.0
			undo_stack:checkpoint()
			change_color(active_color, h, nil, nil)
		end,
		update = function(self, msg)
			self.hidden = active_color == nil
		end
	})

	-- Input field for saturation
	el:attach(create_field {
		x = 96, y = 31,
		width = 21, height = 9,
		small_font = true,
		get_fg = function(self) return outline_color() end,
		get = function(self)
			if (not active_color) return ""
			local s = sat(active_color) * 100.0
			return string.format("%3.0f%%", s)
		end,
		set = function(self, str)
			if (locked[active_color]) return
			str = str:gsub("%s", ""):gsub("%%", "")
			local s = tonum(str)
			if (type(s) ~= "number") return
			s = s / 100.0
			undo_stack:checkpoint()
			change_color(active_color, nil, s, nil)
		end,
		update = function(self, msg)
			self.hidden = active_color == nil
		end
	})

	-- Input field for luminance
	el:attach(create_field {
		x = 96, y = 40,
		width = 21, height = 9,
		small_font = true,
		get_fg = function(self) return outline_color() end,
		get = function(self)
			if (not active_color) return ""
			local l = lum(active_color) * 100.0
			return string.format("%3.0f%%", l)
		end,
		set = function(self, str)
			if (locked[active_color]) return
			str = str:gsub("%s", ""):gsub("%%", "")
			local l = tonum(str)
			if (type(l) ~= "number") return
			l = l / 100.0
			undo_stack:checkpoint()
			change_color(active_color, nil, nil, l)
		end,
		update = function(self, msg)
			self.hidden = active_color == nil
		end
	})

	-- Container callbacks

	function el.draw(self, msg)
		if active_color then
			rectfill(1, 1, self.height - 2, self.height - 2, active_color)
			print(string.format("%d", active_color), 4, 4, contrast_color(active_color))
			pal(7, outline_color())
			if locked[active_color] then
				if padlock_flashing_time % 18 < 10 then
					spr(2, self.height + 4, 1)
				end
			else
				spr(1, self.height + 4, 1)
			end
			if hidden[active_color] then
				spr(43, self.height + 4 + size, 1)
			else
				local sprite = 40
				if blink_timer <= 0 and blink_eye == 4 then
					sprite = blink_anim[- blink_timer] 
				end
				spr(sprite, self.height + 4 + size, 1)
			end
			if bg_color == active_color then
				spr(10, self.height + 4 + 2 * size, 1)
			else
				spr(9, self.height + 4 + 2 * size, 1)
			end
			pal(7, 7)
			local hue = hue(active_color) * 360.0
			while hue < 0.0 do
				hue += 360.0
			end
			print("\014hue:        ", self.height + 3, 23, outline_color())
			print("\014saturation: ", self.height + 3, 32)
			print("\014lightness:  ", self.height + 3, 41)
		else
			print("\^pOkPal" .. "\^-p\014\|o " .. okpal_version, 24, 16, outline_color())
			if env().sandbox then
				print("\014    " .. env().sandbox .. " sandbox", 24, 34)
			end
		end
	end
	
	function el.tap(self, msg)
		if (not active_color) return
		if msg.mx < self.height or msg.my > size then
			return
		elseif msg.mx < self.height + 4 + size then
			locked[active_color] = not locked[active_color]
		elseif msg.mx < self.height + 4 + 2 * size then
			change_hidden(active_color, not hidden[active_color])
		elseif msg.mx < self.height + 4 + 3 * size then
			if key("shift") and bg_color != active_color then
				whitest_color = active_color
			elseif key("ctrl") then
				blackest_color = active_color
			elseif bg_color == active_color then
				bg_color = blackest_color
			else
				bg_color = active_color
			end
		end
	end
	
	function el.hover(self, msg)
		if msg.has_pointer and msg.mx >= self.height + 4 and msg.mx <= self.height + 4 + 3 * size and msg.my <= size then
			self.cursor = "pointer"
		else
			self.cursor = 1
		end
	end
	
	return el
end


---------------------------------------------------------------------------------


function create_pickers_mode_switch(el)
	el.width = get_spr(36):width()
	el.height = get_spr(36):height()
	el.cursor = "pointer"
	function el.draw(self, msg)
		pal(7, outline_color())
		spr(pickers_mode == "circular_hue" and 36 or 37, 0, 0)
		pal(7)
	end
	function el.tap(self, msg)
		if pickers_mode == "circular_hue" then
			pickers_mode = "linear_hue"
		else
			pickers_mode = "circular_hue"
		end
		gui_changed = true
	end
	return el
end


---------------------------------------------------------------------------------


function create_test_zone(el)
	el.width = (24 + 4) * 3
	el.height = 12 + (24 + 4) * 8 + 15
	el.cursor = "pointer"
	el.cubes = {}
	el.ramps = nil
	
	gui:new(el)
	
	if el.only_hex_tab then
		el.ramps = el:attach(create_test_hex { x = 0, y = 0 })
	else
		for i = 0, 2 do
			for j = 0, 7 do
				el.cubes[#el.cubes + 1] =
					el:attach(create_test_cube { x = i * 28, y = 12 + j * 28, test_id = i + 3 * j })
			end
		end
		
		el.ramps = el:attach(create_test_ramps { x = 0, y = 12, hidden = test_mode ~= "ramps" })
	
		el:attach(
			create_action_button {
				x = 54, y = 238, sprite = 32,
				act =
					function(self)
						undo_stack:checkpoint()
						if test_mode == "cubes" then
							clear_cube_colors()
						elseif test_mode == "ramps" then
							clear_ramp_colors()
						end
					end 
			}
		)
	end

	function el.draw(self, msg)
		if self.only_hex_tab then return end
		pal(7, outline_color())
		if test_mode == "cubes" then
			spr(34, 0, 0)
		elseif test_mode == "ramps" then
			spr(35, 0, 0)
		end
		pal(7, 7)
	end
	
	function el.click(self, msg)
		if self.only_hex_tab then return end
		if msg.my > 12 then
			return
		end
		if test_mode == "cubes" and msg.mx > 33 then
			test_mode = "ramps"
			for c in all(self.cubes) do
				c.hidden = true
			end
			self.ramps.hidden = false
		elseif test_mode == "ramps" and msg.mx < 33 then
			test_mode = "cubes"
			for c in all(self.cubes) do
				c.hidden = false
			end
			self.ramps.hidden = true
		end
	end
	
	function el.mousewheel(self, msg)
		if not active_color then
			active_color = 0
		elseif msg.wheel_y < 0 then
			active_color = (active_color + 1) % 64
		elseif msg.wheel_y > 0 then
			active_color = (active_color - 1) % 64
		end
	end

	return el
end


function create_test_cube(el)
	el.width = 24 + 4
	el.height = 24 + 4
	el.hidden = test_mode ~= "cubes"

	function el.draw(self, msg)
		local colors = test_cube_colors[self.test_id]
		pal(10, colors[1])
		pal(9, colors[2])
		pal(25, colors[3])
		spr(8, 2, 2)
		pal(10, 10)
		pal(9, 9)
		pal(25, 25)
	end
	
	function el.hover(self, msg)
		if msg.mx > 2 and msg.my > 2 and msg.mx < self.width - 2 and msg.my < self.height - 2 then
			el.cursor = "crosshair"
		else
			el.cursor = 1
		end
	end
	
	function el.click(self, msg)
		local face = 2
		if msg.mx > self.width - 10 or msg.my < 10 then
			if msg.mx > self.height - msg.my then
				face = 3
			else
				face = 1
			end
		end
		if msg.mb == 1 then
			undo_stack:checkpoint()
			test_cube_colors[self.test_id][face] = active_color or 1
		elseif msg.mb == 2 then
			active_color = test_cube_colors[self.test_id][face]
		end
	end
	
	return el
end


function create_test_ramps(el)
	el.width = (24 + 4) * 3
	el.height = (24 + 4) * 8
	
	function el:square_of(x, y)
		if x < 2 or x > self.width - 2 or y <= 4 or y >= self.height - 4 then
			return nil, nil
		end
		local i = mid(0, (x - 2) // 8, 9)
		local j = mid(0, (y - 4) // 8, 26)
		return i, j
	end

	function el.draw(self, msg)
		for i = 0, 9 do
			for j = 0, 26 do
				local x = 2 + i * 8
				local y = 4 + j * 8
				local c = test_ramp_colors:get(i, j)
				rectfill(x, y, x + 7, y + 7, c)
			end
		end
		local i, j = self:square_of(msg.mx, msg.my)
		if i then
			local x = 2 + i * 8
			local y = 4 + j * 8
			local c = test_ramp_colors:get(i, j)
			if c == 0 then
				rect(x, y, x + 7, y + 7, contrast_color(c))
			end
		end
	end
	
	function el.hover(self, msg)
		local i, j = self:square_of(msg.mx, msg.my)
		if i then
			el.cursor = "crosshair"
		else
			el.cursor = 1
		end
	end
	
	function el.click(self, msg)
		local  i, j = self:square_of(msg.mx, msg.my)
		if (not i) return
		if msg.mb == 1 then
			undo_stack:checkpoint()
			test_ramp_colors:set(i, j, active_color)
		elseif msg.mb == 2 then
			active_color = mid(0, test_ramp_colors:get(i, j), 63)
		elseif msg.mb == 4 then
			test_ramp_colors:set(i, j, 0)
		end
	end

	return el
end


function create_test_hex(el)
	el.width = (24 + 4) * 3
	el.height = (24 + 4) * 8 + 30
	el.cursor = 1
	function el:draw(msg)
		print("\014hex file", 26, 4, outline_color())
		local last_color = 63
		while last_color > 1 and color_code(last_color) == 0 do
			last_color -= 1
		end
		for c = 0, 63 do
			local x = (c < 32) and 6 or 46
			local y = 16 + (c % 32) * 7
			rectfill(x + 1, y + 1, x + 5, y + 5, c)
			if c <= last_color then
				print("\014" .. color_hex(c), x + 9, y + 1, outline_color())
			else
				print("\014......", x + 9, y + 1, outline_color())
			end
		end
	end
	return el
end
:: src/gui_settings.lua
--[[pod_format="raw",created="2025-02-28 11:31:28",modified="2025-03-23 16:12:38",revision=1658]]
function open_settings()
	local el = open_modal(220, 170, true)
	el:attach(create_label { x = 90, y = 6, label = "Settings", fg = bg_color })
	
	if key("shift") then
		el:attach(create_checkbox {
			x = 10, y = 30,
			label = "Don't blink!",
			fg = bg_color,
			get = function(self) return user_settings.dont_blink end,
			toggle = function(self) change_settings { dont_blink = not user_settings.dont_blink } end,
		})
		el:attach(create_checkbox {
			x = 10, y = 50,
			label = "No jump scares",
			fg = bg_color,
			get = function(self) return user_settings.no_jump_scares end,
			toggle = function(self) change_settings { no_jump_scares = not user_settings.no_jump_scares } end,
		})
	
	else
		el:attach(create_checkbox {
			x = 10, y = 30,
			label = "Send palette to sprite and map editors",
			fg = bg_color,
			get = function(self) return user_settings.send_palette end,
			toggle = function(self) change_settings { send_palette = not user_settings.send_palette } end,
		})
		el:attach(create_checkbox {
			x = 10, y = 50,
			label = "Show color names",
			fg = bg_color,
			get = function(self) return user_settings.show_color_names end,
			toggle = function(self) change_settings { show_color_names = not user_settings.show_color_names } end,
		})
		el:attach(create_checkbox {
			x = 120, y = 50,
			label = "Show color band",
			fg = bg_color,
			get = function(self) return user_settings.show_color_band end,
			toggle =
				function(self)
					change_settings { show_color_band = not user_settings.show_color_band }
				end,
		})
		el:attach(create_checkbox {
			x = 10, y = 70,
			label = "EXPERIMENTAL: Open in GFX workspace",
			fg = bg_color,
			is_default_app = get_default_app("hex") == env().argv[0],
			get = function(self) return user_settings.open_in_gfx_workspace end,
			toggle =
				function(self)
					change_settings { open_in_gfx_workspace = not user_settings.open_in_gfx_workspace }
				end,
		})
		el:attach(create_checkbox {
			x = 10, y = 90,
			label = "Default app for \".pal\" files",
			fg = bg_color,
			is_default_app = get_default_app("pal") == env().argv[0],
			get = function(self) return self.is_default_app end,
			toggle =
				function(self)
					self.is_default_app = not self.is_default_app
					set_default_app("pal", self.is_default_app)
				end,
		})
		el:attach(create_checkbox {
			x = 10, y = 110,
			label = "Default app for \".hex\" files",
			fg = bg_color,
			is_default_app = get_default_app("hex") == env().argv[0],
			get = function(self) return self.is_default_app end,
			toggle =
				function(self)
					self.is_default_app = not self.is_default_app
					set_default_app("hex", self.is_default_app)
				end,
		})
	end
	
	el:attach(create_button {
		x = 170, y = 150,
		label = "Close",
		fg = bg_color,
		act = function() close_modal() end,
	})
end
:: src/integration.lua
--[[pod_format="raw",created="2025-03-08 09:24:27",modified="2025-03-22 09:48:32",revision=625]]
-- Copy and paste ----------------------------------------------------------------


function copy_color()
	if active_color then
		set_clipboard("#" .. color_hex(active_color))
	end
end


function cut_color()
	if active_color then
		set_clipboard("#" .. color_hex(active_color))
		if not locked[active_color] then
			 undo_stack:checkpoint()
			change_color_code(active_color, 0x000000)
			change_hidden(active_color, true)
		end
	end
end


function paste_color()
	if not active_color then
		notify("unable to paste: no selected color")
		return
	end
	if locked[active_color] then
		notify("unable to paste: selected color is locked")
		return
	end
	local cb = get_clipboard()
	if type(cb) == "string" then
		local hex = string.gsub(cb, "%s", "")
		if sub(hex, 1, 1) == "#" then
			hex = sub(hex, 2, -1)
		end
		local code = tonumber("0x" .. hex)
		if type(code) == "number" then
			undo_stack:checkpoint()
			change_color_code(active_color, code)
			change_hidden(active_color, false)
		else
			notify("unable to paste: unrecognized string: \"" .. cb .."\"")
		end
	else
		notify("unable to paste: type not supported (" .. type(cb) .. ")")
	end
end


---------------------------------------------------------------------------------------------


function get_default_app(extension)
	if fstat("/system/util/default_app.lua") ~= "file" then
		return "(unknown)"
	end

	local default_apps = fetch("/appdata/system/default_apps.pod") or {}
	return default_apps[extension] or "(none)"
end


function set_default_app(extension, value)
	local okpal_path = env().argv[0]

	-- Prevent registering the wrong path when
	-- developing OkPal.
	if okpal_path == "/system/apps/terminal.lua" then
		return
	end
	
	local defaults = fetch("/appdata/system/default_apps.pod")
	if type(defaults) ~= "table" then return end
	if value then
		defaults[extension] = okpal_path
		notify("OkPal registered as default app for \"."..extension.."\" files")
	else
		defaults[extension] = nil
		notify("Cleared default app for \"."..extension.."\" files")
	end
	store("/appdata/system/default_apps.pod", defaults)
end


-----------------------------------------------------------------------------


function send_palette()
	if not user_settings.send_palette then
		return
	end
	
	local palette = userdata("i32", 64)
	for c = 0, 63 do
		palette:set(c, color_code(c))
	end
	
	-- Updating the PID lists as we're sending the event
	-- to not miss new processes.
	for pid in all(find_gfx_map_pids()) do
		send_message(pid, { event = "set_palette", palette = palette })
	end
end


-- From Eiyeron's fork #eyn_okpal_fork-0
function find_gfx_map_pids()
	local matching_pids = {}
	for process in all(fetch "/ram/system/processes.pod") do
		local name <const> = process.name
		if name == "gfx" or name == "map" then
			matching_pids[#matching_pids + 1] = process.id
		end
	end
	return matching_pids
end


-- Drag-and-drop ------------------------------------------------------------------


function handle_drop_items(msg)
	for i = 1, #msg.items do
		local item = msg.items[i]
		if item.pod_type == "file_reference" and item.attrib == "file" then
--			undo_stack:checkpoint()
--			send_message(pid(), { event = "open_file", filename = item.fullpath })
		local okpal_path = env().argv[0]
		-- Prevent registering the wrong path when
		-- developing OkPal.
		if okpal_path == "/system/apps/terminal.lua" then
			return
		end
		create_process(
			okpal_path,
			{
				argv = { item.fullpath },
			}
		)
		end
	end
end

:: src/oklab.lua
--[[pod_format="raw",created="2024-03-31 09:08:26",modified="2025-03-10 19:14:59",revision=981]]
-- Copyright(c) 2021 Bjorn Ottosson
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of
-- this software and associated documentation files(the "Software"), to deal in
-- the Software without restriction, including without limitation the rights to
-- use, copy, modify, merge, publish, distribute, sublicense, and /or sell copies
-- of the Software, and to permit persons to whom the Software is furnished to do
-- so, subject to the following conditions:
--
-- The above copyright noticeand this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

oklab = {}
oklab.__index = oklab

function oklab.color_to_okhsl(code)
	local srgb = {
		r = ((code & 0xff0000) >> 16) / 255,
		g = ((code & 0x00ff00) >> 8) / 255,
		b = ((code & 0x0000ff)) / 255,
	}
	return oklab.srgb_to_okhsl(srgb)
end

function oklab.okhsl_to_color(okhsl)
	local srgb = oklab.okhsl_to_srgb(okhsl)
	local r = mid(0x00, math.floor(srgb.r * 255 + 0.5), 0xff)
	local g = mid(math.floor(srgb.g * 255 + 0.5), 0xff)
	local b = mid(math.floor(srgb.b * 255 + 0.5), 0xff)
	return (r << 16) | (g << 8) | b
end

function oklab.new()
    local inst = setmetatable({}, oklab)
    return inst
end

-- Finds the maximum saturation possible for a given hue that fits in sRGB
-- Saturation here is defined as S = C/L
-- a and b must be normalized so a^2 + b^2 == 1
function oklab.compute_max_saturation(a, b)
    if a ~= 0.0 or b ~= 0.0 then
    	-- Max saturation will be when one of r, g or b goes below zero.
        -- Select different coefficients depending on which component goes below zero first

        -- Blue component (default)
        local k0 = 1.35733652
        local k1 = -0.00915799
        local k2 = -1.1513021
        local k3 = -0.50559606
        local k4 = 0.00692167
        local wl = -0.0041960863
        local wm = -0.7034186147
        local ws = 1.707614701

        if -1.88170328 * a - 0.80936493 * b > 1 then
            -- Red component
            k0 = 1.19086277
            k1 = 1.76576728
            k2 = 0.59662641
            k3 = 0.75515197
            k4 = 0.56771245
            wl = 4.0767416621
            wm = -3.3077115913
            ws = 0.2309699292
        elseif 1.81444104 * a - 1.19445276 * b > 1 then
            -- Green component
            k0 = 0.73956515
            k1 = -0.45954404
            k2 = 0.08285427
            k3 = 0.1254107
            k4 = 0.14503204
            wl = -1.2684380046
            wm = 2.6097574011
            ws = -0.3413193965
        end

        -- Approximate max saturation using a polynomial:
        local S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b

        -- Do one step Halley's method to get closer
        -- this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite
        -- this should be sufficient for most applications, otherwise do two/three steps

        local k_l = 0.3963377774 * a + 0.2158037573 * b
        local k_m = -0.1055613458 * a - 0.0638541728 * b
        local k_s = -0.0894841775 * a - 1.291485548 * b

        do
            local l_ = 1.0 + S * k_l
            local m_ = 1.0 + S * k_m
            local s_ = 1.0 + S * k_s

            local l = l_ * l_ * l_
            local m = m_ * m_ * m_
            local s = s_ * s_ * s_

            local l_dS = 3.0 * k_l * l_ * l_
            local m_dS = 3.0 * k_m * m_ * m_
            local s_dS = 3.0 * k_s * s_ * s_

            local l_dS2 = 6.0 * k_l * k_l * l_
            local m_dS2 = 6.0 * k_m * k_m * m_
            local s_dS2 = 6.0 * k_s * k_s * s_

            local f = wl * l + wm * m + ws * s
            local f1 = wl * l_dS + wm * m_dS + ws * s_dS
            local f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2

            local s_denom = f1 * f1 - 0.5 * f * f2
            if s_denom ~= 0.0 then  S = S - f * f1 / s_denom end
        end

        return S
    else
        return 0.0
    end
end

-- finds L_cusp and C_cusp for a given hue
-- a and b must be normalized so a^2 + b^2 == 1
function oklab.find_cusp(a, b)
	-- First, find the maximum saturation (saturation S = C/L)
    local S_cusp = oklab.compute_max_saturation(a, b)

    -- Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:
    local rgb_at_max = oklab.oklab_to_linear_srgb({L = 1, a = S_cusp * a, b = S_cusp * b })
    local max_comp = math.max(rgb_at_max.r, rgb_at_max.g, rgb_at_max.b)
    if max_comp ~= 0.0 then
        local L_cusp = (1.0 / max_comp) ^ 0.3333333333333333
        return { L = L_cusp, C = L_cusp * S_cusp }
    else
        return { L = 0.0, C = 0.0 }
    end
end

-- Finds intersection of the line defined by
-- L = L0 * (1 - t) + t * L1
-- C = t * C1
-- a and b must be normalized so a^2 + b^2 == 1
function oklab.find_gamut_intersection(a, b, L1, C1, L0, x)
    -- Find the cusp of the gamut triangle
    local cusp = x or oklab.find_cusp(a, b)

    -- Find the intersection for upper and lower half separately
    local t = 0.0
    if ((L1 - L0) * cusp.C - (cusp.L - L0) * C1) <= 0.0 then
        -- Lower half
        local t_denom = C1 * cusp.L + cusp.C * (L0 - L1)
        if t_denom ~= 0.0 then t = cusp.C * L0 / t_denom end
    else
        -- Upper half
        -- First intersect with triangle
        local t_denom = C1 * (cusp.L - 1.0) + cusp.C * (L0 - L1)
        if t_denom ~= 0.0 then t = cusp.C * (L0 - 1.0) / t_denom end

        -- Then one step Halley's method
        do
            local dL = L1 - L0
            local dC = C1

            local k_l = 0.3963377774 * a + 0.2158037573 * b
            local k_m = -0.1055613458 * a - 0.0638541728 * b
            local k_s = -0.0894841775 * a - 1.291485548 * b

            local l_dt = dL + dC * k_l
            local m_dt = dL + dC * k_m
            local s_dt = dL + dC * k_s

            -- If higher accuracy is required, 2 or 3 iterations of the following block can be used:
            do
                local L = L0 * (1.0 - t) + t * L1
				local C = t * C1

				local l_ = L + C * k_l
				local m_ = L + C * k_m
				local s_ = L + C * k_s

				local l = l_ * l_ * l_
				local m = m_ * m_ * m_
				local s = s_ * s_ * s_

				local ldt = 3.0 * l_dt * l_ * l_
				local mdt = 3.0 * m_dt * m_ * m_
				local sdt = 3.0 * s_dt * s_ * s_

				local ldt2 = 6.0 * l_dt * l_dt * l_
				local mdt2 = 6.0 * m_dt * m_dt * m_
				local sdt2 = 6.0 * s_dt * s_dt * s_

                local r0 = 4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s - 1
				local r1 = 4.0767416621 * ldt - 3.3077115913 * mdt + 0.2309699292 * sdt
				local r2 = 4.0767416621 * ldt2 - 3.3077115913 * mdt2 + 0.2309699292 * sdt2

                local r_denom = r1 * r1 - 0.5 * r0 * r2
                local u_r = 0.0
                if r_denom ~= 0.0 then u_r = r1 / r_denom end
				local t_r = -r0 * u_r

                local g0 = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s - 1
				local g1 = -1.2684380046 * ldt + 2.6097574011 * mdt - 0.3413193965 * sdt
				local g2 = -1.2684380046 * ldt2 + 2.6097574011 * mdt2 - 0.3413193965 * sdt2

                local g_denom = g1 * g1 - 0.5 * g0 * g2
                local u_g = 0.0
                if g_denom ~= 0.0 then u_g = g1 / g_denom end
				local t_g = -g0 * u_g

                local b0 = -0.0041960863 * l - 0.7034186147 * m + 1.707614701 * s - 1
				local b1 = -0.0041960863 * ldt - 0.7034186147 * mdt + 1.707614701 * sdt
				local b2 = -0.0041960863 * ldt2 - 0.7034186147 * mdt2 + 1.707614701 * sdt2

                local b_denom = (b1 * b1 - 0.5 * b0 * b2)
                local u_b = 0.0
                if b_denom ~= 0.0 then u_b = b1 / b_denom end
				local t_b = -b0 * u_b

                if u_r < 0.0 then t_r = 3.40282347e+38 end
                if u_g < 0.0 then t_g = 3.40282347e+38 end
                if u_b < 0.0 then t_b = 3.40282347e+38 end

                t = t + math.min(t_r, t_g, t_b)
            end
        end
    end

    return t
end

function oklab.get_Cs(L, a_, b_)
    local cusp = oklab.find_cusp(a_, b_)
    local C_max = oklab.find_gamut_intersection(a_, b_, L, 1.0, L, cusp)
    local ST_max = oklab.to_ST(cusp)

    -- Scale factor to compensate for the curved part of gamut shape:
    local k = 0.0
    local k_denom = math.min(L * ST_max.S, (1.0 - L) * ST_max.T)
    if k_denom ~= 0.0 then k = C_max / k_denom end

    local C_mid = 0.0
    do
        local ST_mid = oklab.get_ST_mid(a_, b_)

        -- Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.
        local C_a = L * ST_mid.S
        local C_b = (1.0 - L) * ST_mid.T

        local cae4 = C_a * C_a * C_a * C_a
        local cbe4 = C_b * C_b * C_b * C_b
        C_mid = 0.9 * k * ((1.0 / (1.0 / cae4 + 1.0 / cbe4)) ^ 0.25)
    end

    local C_0 = 0.0
    do
        -- for C_0, the shape is independent of hue, so ST are constant. Values picked to roughly be the average values of ST.
        local C_a = L * 0.4
        local C_b = (1.0 - L) * 0.8

        -- Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.
        local cae2 = C_a * C_a
        local cbe2 = C_b * C_b
        C_0 = math.sqrt(1.0 / (1.0 / cae2 + 1.0 / cbe2))
    end

    return { C_0 = C_0, C_mid = C_mid, C_max = C_max }
end

-- Returns a smooth approximation of the location of the cusp
-- This polynomial was created by an optimization process
-- It has been designed so that S_mid < S_max and T_mid < T_max
function oklab.get_ST_mid(a_, b_)
    local S = 0.11516993
    local s_denom = 7.4477897 + 4.1590124 * b_
        + a_ * (-2.19557347 + 1.75198401 * b_
        + a_ * (-2.13704948 - 10.02301043 * b_
        + a_ * (-4.24894561 + 5.38770819 * b_ + 4.69891013 * a_)))
    if s_denom ~= 0.0 then
        S = 0.11516993 + 1.0 / s_denom
    end

    local T = 0.11239642
    local t_denom = 1.6132032 - 0.68124379 * b_
        + a_ * (0.40370612 + 0.90148123 * b_
        + a_ * (-0.27087943 + 0.6122399 * b_
        + a_ * (0.00299215 - 0.45399568 * b_ - 0.14661872 * a_)))
	if t_denom ~= 0.0 then
        T = 0.11239642 + 1.0 / t_denom
    end

	return { S = S, T = T }
end

function oklab.linear_srgb_to_oklab(c)
    local l = 0.4122214708 * c.r
            + 0.5363325363 * c.g
            + 0.0514459929 * c.b
	local m = 0.2119034982 * c.r
            + 0.6806995451 * c.g
            + 0.1073969566 * c.b
	local s = 0.0883024619 * c.r
            + 0.2817188376 * c.g
            + 0.6299787005 * c.b

    local l_ = l ^ 0.3333333333333333
    local m_ = m ^ 0.3333333333333333
    local s_ = s ^ 0.3333333333333333

    return {
        L = 0.2104542553 * l_
          + 0.793617785 * m_
          - 0.0040720468 * s_,
        a = 1.9779984951 * l_
          - 2.428592205 * m_
          + 0.4505937099 * s_,
        b = 0.0259040371 * l_
          + 0.7827717662 * m_
          - 0.808675766 * s_ }
end

function oklab.okhsl_to_oklab(hsl)
	local l = hsl.l
    if l >= 1.0 then return { L = 1.0, a = 0.0, b = 0.0 } end
    if l <= 0.0 then return { L = 0.0, a = 0.0, b = 0.0 } end

    local s = hsl.s
    if s < 0.0 then s = 0.0 end
    if s > 1.0 then s = 1.0 end

    local h = hsl.h
    local h_rad = h * 6.283185307179586
    local a_ = math.cos(h_rad)
    local b_ = math.sin(h_rad)
    local L = oklab.toe_inv(l)

    local cs = oklab.get_Cs(L, a_, b_)
    local C_0 = cs.C_0
	local C_mid = cs.C_mid
	local C_max = cs.C_max

    local mid = 0.8
	local mid_inv = 1.25

    local C = 0.0
    local t = 0.0
    local k_0 = 0.0
    local k_1 = 0.0
    local k_2 = 0.0
    if s < mid then
        t = mid_inv * s

		k_1 = mid * C_0
        if C_mid ~= 0.0 then
		    k_2 = 1.0 - k_1 / C_mid
        end

        local k_denom = 1.0 - k_2 * t
		if k_denom ~= 0.0 then
            C = t * k_1 / k_denom
        end
    else
        local t_denom = 1.0 - mid
        if t_denom ~= 0.0 then
            t = (s - mid) / t_denom
        end

		k_0 = C_mid
        if C_0 ~= 0.0 then
		    k_1 = (1.0 - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0
        end

        local C_denom = C_max - C_mid
		k_2 = 1.0
        if C_denom ~= 0.0 then
            k_2 = 1.0 - k_1 / C_denom
        end

        local k_denom = 1.0 - k_2 * t
        if k_denom ~= 0.0 then
		    C = k_0 + t * k_1 / k_denom
        end
    end

    return {
        L = L,
        a = C * a_,
        b = C * b_ }
end

function oklab.okhsl_to_srgb(hsl)
    return oklab.oklab_to_srgb(oklab.okhsl_to_oklab(hsl))
end

function oklab.okhsv_to_oklab(hsv)
	local v = hsv.v
    if v <= 0.0 then return { L = 0.0, a = 0.0, b = 0.0 } end
    if v > 1.0 then v = 1.0 end

    local s = hsv.s
    if s < 0.0 then s = 0.0 end
    if s > 1.0 then s = 1.0 end

    local h = hsv.h
    local h_rad = h * 6.283185307179586
    local a_ = math.cos(h_rad)
    local b_ = math.sin(h_rad)

    local cusp = oklab.find_cusp(a_, b_)
	local ST_max = oklab.to_ST(cusp)
	local S_max = ST_max.S
	local T_max = ST_max.T
	local S_0 = 0.5
    local k = 1.0
    if S_max ~= 0.0 then
	    k = 1.0 - S_0 / S_max
    end

    -- first we compute L and V as if the gamut is a perfect triangle:

	-- L, C when v==1:
    local v_denom = S_0 + T_max - T_max * k * s
    local L_v = 1.0
    local C_v = 0.0
    if v_denom ~= 0.0 then
        L_v = 1.0 - s * S_0 / v_denom
	    C_v = s * T_max * S_0 / v_denom
    end

    local L = v * L_v
	local C = v * C_v

    --then we compensate for both toe and the curved top part of the triangle:
    local L_vt = oklab.toe_inv(L_v)
    local C_vt = 0.0
    if L_v ~= 0.0 then
        C_vt = C_v * L_vt / L_v
    end

    local L_new = oklab.toe_inv(L)
    if L ~= 0.0 then
        C = C * L_new / L
    end
    L = L_new

    local rgb_scale = oklab.oklab_to_linear_srgb({
        L = L_vt,
        a = a_ * C_vt,
        b = b_ * C_vt })
    local max_comp = math.max(
        rgb_scale.r,
        rgb_scale.g,
        rgb_scale.b, 0.0)
    local scale_L = 0.0
    if max_comp ~= 0.0 then
        scale_L = (1.0 / max_comp) ^ 0.3333333333333333
    end

	C = C * scale_L
    return {
        L = L * scale_L,
        a = C * a_,
        b = C * b_ }
end

function oklab.okhsv_to_srgb(hsv)
    return oklab.oklab_to_srgb(oklab.okhsv_to_oklab(hsv))
end

function oklab.oklab_to_linear_srgb(lab)
    local l_ = lab.L
        + 0.3963377774 * lab.a
        + 0.2158037573 * lab.b
	local m_ = lab.L
        - 0.1055613458 * lab.a
        - 0.0638541728 * lab.b
	local s_ = lab.L
        - 0.0894841775 * lab.a
        - 1.291485548 * lab.b

    local l = l_ * l_ * l_
    local m = m_ * m_ * m_
    local s = s_ * s_ * s_

    return {
        r = 4.0767416621 * l
          - 3.3077115913 * m
          + 0.2309699292 * s,
        g = -1.2684380046 * l
           + 2.6097574011 * m
           - 0.3413193965 * s,
        b = -0.0041960863 * l
           - 0.7034186147 * m
           + 1.707614701 * s }
end

function oklab.oklab_to_okhsl(lab)
    local L = lab.L
    if L >= 1.0 then return { h = 0.0, s = 0.0, l = 1.0 } end
    if L <= 0.0 then return { h = 0.0, s = 0.0, l = 0.0 } end

    local Csq = lab.a * lab.a + lab.b * lab.b
    if Csq > 0.0 then
        local C = math.sqrt(Csq)
        local a_ = lab.a / C
        local b_ = lab.b / C

        -- 1.0 / math.pi = 0.3183098861837907
        local h = 0.5 + 0.5 * math.atan(-lab.b, -lab.a) * 0.3183098861837907

        local cs = oklab.get_Cs(L, a_, b_)
        local C_0 = cs.C_0
        local C_mid = cs.C_mid
        local C_max = cs.C_max

        -- Inverse of the interpolation in okhsl_to_srgb:
        local mid = 0.8
        local mid_inv = 1.25

        local s = 0.0
        if C < C_mid then
            local k_1 = mid * C_0
            local k_2 = 1.0
            if C_mid ~= 0.0 then
                k_2 = (1.0 - k_1 / C_mid)
            end

            local t_denom = k_1 + k_2 * C
            local t = 0.0
            if t_denom ~= 0.0 then
                t = C / t_denom
            end

            s = t * mid
        else
            local k_0 = C_mid
            local k_1 = 0.0
            if C_0 ~= 0.0 then
                k_1 = (1.0 - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0
            end

            local C_denom = C_max - C_mid
            local k_2 = 1.0
            if C_denom ~= 0.0 then
                k_2 = 1.0 - k_1 / C_denom
            end

            local t_denom = k_1 + k_2 * (C - k_0)
            local t = 0.0
            if t_denom ~= 0.0 then
                t = (C - k_0) / t_denom
            end

            s = mid + (1.0 - mid) * t
        end

        return { h = h, s = s, l = oklab.toe(L) }
    else
        return { h = 0.0, s = 0.0, l = L }
    end
end

function oklab.oklab_to_okhsv(lab)
    local L = lab.L
    if L >= 1.0 then return { h = 0.0, s = 0.0, v = 1.0 } end
    if L <= 0.0 then return { h = 0.0, s = 0.0, v = 0.0 } end

    local Csq = lab.a * lab.a + lab.b * lab.b
    if Csq > 0.0 then
        local C = math.sqrt(Csq)
        local a_ = lab.a / C
        local b_ = lab.b / C

        -- 1.0 / math.pi = 0.3183098861837907
        local h = 0.5 + 0.5 * math.atan(-lab.b, -lab.a) * 0.3183098861837907

        local cusp = oklab.find_cusp(a_, b_)
        local ST_max = oklab.to_ST(cusp)
        local S_max = ST_max.S
        local T_max = ST_max.T
        local S_0 = 0.5
        local k = 1.0
        if S_max ~= 0.0 then
            k = 1.0 - S_0 / S_max
        end

        -- first we find L_v, C_v, L_vt and C_vt
        local t_denom = C + L * T_max
        local t = 0.0
        if t_denom ~= 0.0 then
            t = T_max / t_denom
        end
        local L_v = t * L
        local C_v = t * C

        local L_vt = oklab.toe_inv(L_v)
        local C_vt = 0.0
        if L_v ~= 0.0 then
            C_vt = C_v * L_vt / L_v
        end

        -- we can then use these to invert the step that compensates for the toe and the curved top part of the triangle:
        local rgb_scale = oklab.oklab_to_linear_srgb({
            L = L_vt,
            a = a_ * C_vt,
            b = b_ * C_vt })
        local scale_denom = math.max(
            rgb_scale.r,
            rgb_scale.g,
            rgb_scale.b, 0.0)
        local scale_L = 0.0
        if scale_denom ~= 0.0 then
            scale_L = (1.0 / scale_denom) ^ 0.3333333333333333
            L = L / scale_L
            C = C / scale_L
        end

        local toel = oklab.toe(L)
        C = C * toel / L
        L = toel

        -- we can now compute v and s:
        local v = 0.0
        if L_v ~= 0.0 then v = L / L_v end

        local s = 0.0
        local s_denom = ((T_max * S_0) + T_max * k * C_v)
        if s_denom ~= 0.0 then
            s = (S_0 + T_max) * C_v / s_denom
        end

        return { h = h, s = s, v = v }
    else
        return { h = 0.0, s = 0.0, v = L }
    end
end

function oklab.oklab_to_srgb(lab)
    local lrgb = oklab.oklab_to_linear_srgb(lab)
	return {
		r = oklab.srgb_transfer_function(lrgb.r),
		g = oklab.srgb_transfer_function(lrgb.g),
		b = oklab.srgb_transfer_function(lrgb.b) }
end

function oklab.srgb_to_okhsl(rgb)
    return oklab.oklab_to_okhsl(oklab.srgb_to_oklab(rgb))
end

function oklab.srgb_to_okhsv(rgb)
    return oklab.oklab_to_okhsv(oklab.srgb_to_oklab(rgb))
end

function oklab.srgb_to_oklab(srgb)
    return oklab.linear_srgb_to_oklab({
		r = oklab.srgb_transfer_function_inv(srgb.r),
		g = oklab.srgb_transfer_function_inv(srgb.g),
		b = oklab.srgb_transfer_function_inv(srgb.b) })
end

function oklab.srgb_transfer_function(a)
    if 0.0031308 >= a then
        return 12.92 * a
    else
        return 1.055 * (a ^ 0.4166666666666667) - 0.055
    end
end

function oklab.srgb_transfer_function_inv(a)
    if 0.04045 < a then
        return ((a + 0.055) * 0.9478672985781991) ^ 2.4
    else
        return a * 0.07739938080495357
    end
end

function oklab.to_ST(cusp)
	local L = cusp.L
    local C = cusp.C
    if L ~= 0.0 and L ~= 1.0 then
        return { S = C / L, T = C / (1.0 - L) }
    elseif L ~= 0.0 then
        return { S = C / L, T = 0.0 }
    elseif L ~= 1.0 then
        return { S = 0.0, T = C / (1.0 - L) }
    else
        return { S = 0.0, T = 0.0 }
    end
end

function oklab.toe(x)
    local y = 1.170873786407767 * x - 0.206
	return 0.5 * (y + math.sqrt(y * y + 0.14050485436893204 * x))
end

function oklab.toe_inv(x)
    local denom = 1.170873786407767 * (x + 0.03)
    if denom ~= 0.0 then
    	return (x * x + 0.206 * x) / denom
    else
        return 0.0
    end
end

return oklab
:: src/palette.lua
--[[pod_format="raw",created="2024-03-31 08:27:10",modified="2025-03-22 12:02:46",revision=4273]]
------------------------------------------------------------------------------------------


function color_code(c)
	return peek4(0x5000 + 4 * c)
end


function poke_color_code(c, code)
	poke4(0x5000 + 4 * c, code)
end


function copy_palette()
	return userdata("u32", 64):peek(0x5000)
end


function poke_palette(mem)
	mem:poke(0x5000)
end


---------------------------------------------------------------------------------------


function color_hex(c)
	return string.format("%06x", color_code(c))
end


----------------------------------------------------------------------------------------


local palette = {}


function hue(c)
	return palette[c].h
end


function sat(c)
	return palette[c].s
end


function lum(c)
	return palette[c].l
end


function color_component(c, name)
	return palette[c][name]
end


function copy_palette_hsl()
	return copy(palette)
end


function restore_palette_hsl(hsl)
	palette = hsl
end


local function code_to_hsl(code)
	local hsl = oklab.color_to_okhsl(code)
	if code == 0x000000 then
		hsl.s = 1.0
	end
	return hsl
end


function rebuild_palette(c)
	for c = 0, 63 do
		local code = color_code(c)
		-- TODO: something more subtle? only update the hsl values
		-- if they don't result in the same color code?
		palette[c] = code_to_hsl(color_code(c))
	end
end


function change_color_code(c, code)
	poke_color_code(c, code)
	palette[c] = code_to_hsl(color_code(c))
end


function change_color(c, hue, sat, lum)
	local hsl = {
		h = hue or palette[c].h,
		s = sat or palette[c].s,
		l = lum or palette[c].l,
	}
	hsl.h = hsl.h % 1.0
	hsl.s = mid(0.0, hsl.s, 1.0)
	hsl.l = mid(0.0, hsl.l, 1.0)
	palette[c] = hsl
	local code = oklab.okhsl_to_color(hsl)
	poke_color_code(c, code)
	return
end


function swap_colors(c1, c2)
	palette[c1], palette[c2] = palette[c2], palette[c1]
	local a, b = color_code(c1), color_code(c2)
	poke_color_code(c1, b)
	poke_color_code(c2, a)
end


function clear_colors()
	for c = 0, 63 do
		local code, lum
		if c == 7 then
			code = 0xffffff
			lum = 1.0
		else
			code = 0x000000
			lum = 0.0
		end
		palette[c] = { h = 0.0, s = 0.0, l = lum }
		poke_color_code(c, code)
		locked[c] = (c == 0) or (c == 7)
		hidden[c] = false
		clear_cube_colors()
		clear_ramp_colors()
	end
	for row = 0, 3 do hidden_toggles[row] = false end
	bg_color = 0
	blackest_color = 0
	whitest_color = 7
end


function reset_picotron_colors()
	for c = 0, 31 do
		code = peek4(0x5000 + 4 * (64 + c))
		poke_color_code(c, code)
		palette[c] = code_to_hsl(code)
		if c <= 31 then
			locked[c] = true
		end
	end
	bg_color = 0
	blackest_color = 0
	whitest_color = 7
end


function restore_default_palette()
	for c = 0, 63 do
		code = peek4(0x5000 + 4 * (64 + c))
		poke_color_code(c, code)
		palette[c] = code_to_hsl(code)
		if c <= 31 then
			locked[c] = true
		end
	end
	bg_color = 0
	blackest_color = 0
	whitest_color = 7
end


--------------------------------------------------------------------------------


function clear_cube_colors()
	for i = 0, #test_cube_colors - 1 do
		test_cube_colors[i] = { 1, 1, 1 }
	end
end


function clear_ramp_colors()
	for i = 0, test_ramp_colors:width()-1 do
		for j = 0, test_ramp_colors:height()-1 do
			test_ramp_colors:set(i, j, bg_color)
		end
	end
end


----------------------------------------------------------------------------------


function find_blackest_and_whitest()
	local min_lum = 1.0
	local best_black = 0
	local max_lum = 0.0
	local best_white = 1
	for c = 0, 63 do
		if palette[c].l < min_lum then
			best_black = c
			min_lum = palette[c].l
		end
		if palette[c].l > max_lum then
			best_white = c
			max_lum = palette[c].l
		end
	end
	return best_black, best_white
end


----------------------------------------------------------------------------------------
:: src/settings.lua
--[[pod_format="raw",created="2025-03-07 18:22:46",modified="2025-03-23 16:12:38",revision=534]]
local settings_folder = "/appdata/okpal/"
local settings_filepath = "/appdata/okpal/settings.pod"


function load_settings()
	mkdir(settings_folder)
	local s = fetch(settings_filepath)
	if s then
		for k, v in pairs(user_settings) do
			if type(s[k]) ~= "nil" then
				user_settings[k] = s[k]
			end
		end
	end
end


function change_settings(t)
	for k, v in pairs(t) do
		user_settings[k] = v
	end
	store(settings_filepath, user_settings)
end

:: src/soft_wrap.lua
--[[pod_format="raw",created="2025-03-07 11:09:14",modified="2025-03-12 15:05:26",revision=460]]
-- Soft-wraps a very tiny subset of markdown.
-- This code is absolutely horrible, but kind of work.
function soft_wrap(text, width)
	local space_width <const> = print(" ", -1000, -1000) + 1000
	local lines = {}
	local line = ""
	local x = 0
	local indentation = 0 -- indentation of the current paragraph

	local function add_word(word)
		if word == "" then return end
		local dx = print(word, -1000, -1000) + 1000
		if x + space_width + dx >= width then
			add(lines, line)
			line = ""
			x = 0
			for i = 1, indentation do
				line ..= " "
				x += space_width
			end
			line ..= word
			x += dx
		else
			if line:find("^%s*$") then
				line ..= word
				x += dx
			else
				line ..= " " .. word
				x += space_width + dx
			end
		end
	end
	
	local function add_line()
		add(lines, line)
		line = ""
		x = 0
	end
	
	local in_paragraph = false
	local in_code = false
	local ignore_word = false
	local ignore_line = false
	add_line()
	for hard_line in text:gmatch("([^\n]*)\n?") do
		ignore_line = false
		ignore_word = false
		if hard_line:find("^%s*$") then
			if in_paragraph then
				add_line()
				add_line()
				in_paragraph = false
				indentation = 0
			end
		elseif hard_line:find("^%s*- ") then
			if in_paragraph then
				add_line()
			end
			add_word("-")
			indentation = 2
			in_paragraph = true
			ignore_word = true
		elseif hard_line:find("^```%s*$") then
			if line ~= "" then
				add_line()
			end
			in_code = not in_code
			ignore_line = true
		else
			in_paragraph = true
 		end
 		
 		if not ignore_line then
	 		if in_code then
	 			line = hard_line
	 			add_line()
	 		else
				for word in hard_line:gmatch("([^%s]*)%s?") do
					if ignore_word then
						ignore_word = false
					else
						add_word(word)
					end
				end
			end
		end
	end
	add_line()
	
	return lines
end
:: src/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTAzIDE4OjA3OjM0Iixtb2RpZmllZD0iMjAyNS0w
My0yMyAxNjoxMjozOSIsc3RvcmVkPSIyMDI0LTA0LTAzIDE4OjA3OjM0Il1d
:: label.qoi
b64$cW9pZgAAAeAAAAEOBAH_--Ho-f39-f39-f3T-qKIefI-wf65AD7yP8H_ooh5zD-9-f39-cwS
xD-XEtA-Es4-wBLPP-65AD7PP8ASzj-AEs8--qKIec4--f390xLAP8ASwD-HEsE-wBLBP8sSwT-I
EsQ-xhLGP8kSPxI-3RLFP8YSxT-HEs8-wBLPPxLPP-65AD7OPxLAPxLOPxLPP-6iiHnOP-39-dIS
wD-CEsA-xhLBP8ASwT-GEsI-EsE-yBI-whI-xhLGP8oSP8n_uQA_xj-P-qKIeT8SP9YS0D8SxD-B
EsE-wBLBPxLPP-65AD7OPxI-wBLDP8ESwT-AEsE-Es8--qKIec4--f390hLAP8ISwD-GEsE-wBLB
P8YSwj8SwT-IEj-CEj-GEsY-xhLHP8X_uQA_wj-BEj-L-qKIecE-EsE-xhLFP8cS0D8SxD8SwD8S
wj8SwD8Szz-_uQA_zj-AEj8Swz8SwD8Swj8SwD8Szz-_ooh5xj8SxT-9-f3SEsA-whLAP8YSxj-G
EsI-zBI-whI-xhLGP8YSwD-DEsA-xf65AD7CP8ESP8v_ooh5PxI-2hLQPxLEPxLAPxLAP8ESwD8S
zz-_uQA_zj8SwD8Swz8SwD8SwD-BEsA-Es8--qKIecU-wRLEP-39-dISwD-CEsA-xhI-EsI-Ej-G
EsU-yRI-wBLBP9YSwD-DEsA-xf65AD4-wRLCP8v_ooh5xT-GEsU-xxLQPxLEP8ESwD8SwD8SwD8S
zz-_uQA_zj8SwD8Swz-BEsA-EsA-EsA-Es8--qKIecY-EsU--f390hLAP8ISwD-GEj8Swj8SP8YS
xT-HEsE-wBLBP8YSxj-GEsA-wxLAP8X_uQA_P8ESwj-M-qKIecQ-1hLPP8ESwD8SwD8Swz-BEsA-
wBLOP-65AD7PP8ASwT8SwD8Swz-BEsA-wBLOP-6iiHnOP-39-dMSwD-AEsA-xxLGP8YSxT-HEsE-
yxLAP8ISwD-GEsc-xf65AD7GP_r_ooh51z8S2j-_uQA_1z8S2j-_ooh5zj-9-f39-eoS9D-_uQA_
9D-_ooh5zj-9-f39-cb_AAAA-f39-f39-f39-f39-f39-f39-f39-f39-f39-f39-f39-f394z81
PzU-NT81PzU-NcU-NT81PzU-NT81PzXQP9U1wz-WNf39-f39-cY-Nco-NcI-Nco-Nc0-1zXBPzXW
PzXuP-39-cY1-f3ZPzXPPzXMP9c1wT811j817j81yv4dK1PK-n4lU8r_AIdRyv6rUjbK-l9XT8r_
wsPHyj-K-v8ATcr_-6MAyv7-7CfK-gDkNsr_Ka3-yv6DdpzK-v93qMr_-8yqyj81xv69mt-uNf3Q
PzXPPzXaP9k1PzXYPzXtPzXKKMotyg-K-qtSNsouyjvKP8oNyiHKH8ojyv4prf-KEModyhTKPzXG
B_41-dc-NT81PzXBPzXEPzU-NT81xD81yz-DNcA-NT81PzXBPzXBP8A1wD-CNT81wj-BNT-BNT-B
NT-ANcE-wDXBPzXjP8I1xD81yijKLcoPyv6rUjbKLso7yj-KDcohyh-KI8r_Ka3-yhDKHcoUyj81
xgfuNcc-wTXHP8I19T81wz81PzXBPzXDPzXAPzXBPzU-NdA-wzU-wTU-NT81PzU-NT-BNT-FNcM-
NT81PzU-NT-BNT81PzU-NcQ-NeE-xDXDPzXKKMotyg-K-qtSNsouyjvKP8oNyiHKH8ojyv4prf-K
EModyhTKPzXGB8I1wAfBNcAH4zXGPzXBPzXFP8Q1yD817j81PzXFPzXIPzU-NcI-Nco-wzU-wTU-
NT81wD-ANcA-wDXBP8M1wz-ANcA-wTU-NT81P8A1wD-BNcI-NeA-xjXCPzXKKMotyg-K-qtSNsou
yjvKP8oNyiHKH8ojyv4prf-KEModyhTKPzXGB8E1B8A1BzUHwDUH4jXGPzXBPzXEP8Y1yD816D81
wz81yT81xj81zz-ENT-BNT81PzU-NT81P8M1P8Q1wj81PzU-NT81PzU-NT81wz81wz813j-ANT-A
NT81P8A1wT81yijKLcoPyv6rUjbKLso7yj-KDcohyh-KI8r_Ka3-yhDKHcoUyj81xgfENQc1B8A1
B_I1xT-FNcI-wDU-wDU-NT-ANcg-Neo-NT81PzU-NcM-NcY-NT81PzU-NcA-Nck-xTXAP8A1wD81
wT81wT81wD-FNcI-NT81PzU-NT81PzU-NcE-wDXEPzXePzXAP8I1wD81wT81yijKLcoPyv6rUjbK
Lso7yj-KDcohyh-KI8r_Ka3-yhDKHcoUyj81xgfDNQfBNcEH4jXFP8U1wj81wD-CNcA-NcM-xTXm
PzXBPzU-NT81xz81xD81PzU-Ncw-3zXaPzXePzXAP8A1wD81wj81yijKLcoPyv6rUjbKLso7yj-K
Dcohyh-KI8r_Ka3-yhDKHcoUyj81xgfCNQfENQfiNcU-wTU-wTXDPzXAP8A1wD81wz81P8M17D81
PzXFPzXIPzU-NcI-Ncg-3zXaPzXfPzXCPzXDPzXKKMotyg-K-qtSNsouyjvKP8oNyiHKH8ojyv4p
rf-KEModyhTKPzXGB8E1B8U1B_I1xT-BNT-BNcQ-NcI-NcQ-NcA-wTXoPzXDPzXJPzXGPzXNP-3U
Ncs-wjXEPzXKKMotyg-K-qtSNsouyjvKP8oNyiHKH8ojyv4prf-KEModyhTKPzXGB8E1wgfANcAH
4zXFP8U1xT-CNcU-NcE-Nfg-Nc8-Nf30PzXKKMotyg-K-qtSNsouyjvKP8oNyiHKH8ojyv4prf-K
EModyhTKPzXGB_41-dA-Nc8-Nf39xT81yijKLcoPyv6rUjbKLso7yj-KDcohyh-KI8r_Ka3-yhDK
HcoUyj81xgfuNf3RPzXKPzXCPzXKPzX99T-_JGOwyv4ApaHK-mVGiMr_ElNZyv50LynK-kUtMsoS
yv7-rMXK-rkAPsr_4msCyv6V8ELK-gCyUcr_ZN-2ygfK-uQNq8r_-4VXyj81xgfuNf3TPzU-NT81
PzU-NT81xT81PzU-NT81PzU-Nf32PyDKFco6yjnKG8oDyv6iiHnKMcr_uQA_ygDKMsomyjbKBzXI
Bw-KLMo-NcYH7jX9-ccozDXMKMw1zCjMNc8-wjXEPyDKFco6yjnKG8oDyv6iiHnKMcr_uQA_ygDK
MsomyjbKBzUHxjUHD8osyj81xgfuNf39xijNNcsozTXLKM01zj-ENcM-IMoVyjrKOcobygPK-qKI
ecoxyv65AD7KAMoyyibKNsoHNQfGNQcPyizKPzXGB_41-dI-yjXEP8o10SjONcoozjXKKM41zT-G
NcI-IMoVyjrKOcobygPK-qKIecoxyv65AD7KAMoyyibKNsoHNQfGNQcPyizKPzXGB_41-dE-Nco-
NcI-Nco-Nc8ozzXJKM81ySjPNcw-wDU-wDU-NT-ANcE-IMoVyjrKOcobygPK-qKIecoxyv65AD7K
AMoyyibKNsoHNQfGNQcPyizKPzXGB_41-dA-Ncw-NcA-Ncw-Nc0o0DXIKNA1yCjQNcw-NcA-wjXA
PzXBPyDKFco6yjnKG8oDyv6iiHnKMcr_uQA_ygDKMsomyjbKBzUHxjUHD8osyj81xgfuNf3QPzXE
P8A1xD81wD81wj-ENcI-Ncwo0TXHKNE1xyjRNc0-NcA-wDXAPzXCPyDKFco6yjnKG8oDyv6iiHnK
Mcr_uQA_ygDKMsomyjbKBzUHxjUHD8osyj81xgfuNf3QPzXBP8A1P8A1P8A1wT81wD81wT-BNcA-
wTXBPzXLKNI1xijSNcYo0jXOPzXCPzXDPyDKFco6yjnKG8oDyv6iiHnKMcr_uQA_ygDKMsomyjbK
BzUHxjUHD8osyj81xgfuNf3QPzXBP8Y1wT81wD81wT-ANcI-wDXBPzXLKNI1xijSNcYo0jXPP8I1
xD8gyhXKOso5yhvKA8r_ooh5yjHK-rkAPsoAyjLKJso2ygc1B8Y1Bw-KLMo-NcYH7jX90D81wj-E
NcI-NcA-Ncc-wDXBPzXLKNI1xijSNcYo0jXZPyDKFco6yjnKG8oDyv6iiHnKMcr_uQA_ygDKMsom
yjbKBzXIBw-KLMo-NcYH7jXEPzU-NT81PzU-wTXjP8E1P8E1P8E1wD81yj81wD-CNcA-wjXAPzXA
PzXGP8A1wj81yyjSNcYo0jXGKNI12T8gyhXKOso5yhvKA8r_ooh5yjHK-rkAPsoAyjLKJso2ygfK
D8osyj81xgfuNcQ-NT81PzU-NT81wj814j81PzU-NcE-NT81PzXJPzXAP8I1wD-CNcA-NcA-NcU-
wDXDPzXLKNI1xijSNcYo0jXZP-5JdR3K-kWnJ8r_AMNeyv4A0aDK-gCztcr_FYu3yv5dT9HK-u9v
-8r_-zzmyv6tAJXKNf3IPzXGB_41xD-BNT81PzU-wDXlP8A1PzU-NcE-NcA-Nco-NcI-xDXCPzXA
PzXEP8A1xD81y-4dK1PSNcYo0jXGKNI12T8kyhjKFsoqyifKLMoOyibK-v885soPyjX9yD81xgfu
NcQ-NT81PzU-NT81wj814j81PzU-NcE-Nc0-NcE-xjXBPzXAPzXEP8A1xD81y-4dK1PSNcYo0jXG
KNI1zz-CNcQ-JMI1wiTCGMI1whjCFsI1whbCKsI1wirCJ8I1wifCLMI1wizCDsI1wg7CJsI1wibC
-v885sI1wijCD8I1wg-CNf3IPzXGB_41xD81PzXAP8A1P8E14z-BNT-BNcE-Nc0-NcE-wDU-wDU-
wDXBPzXAPzXMPzXL-h0rU9I1xijSNcYo0jXOP8Q1wz8kwTXEJMEYwTXEGMEWwTXEFsEqwTXEKsEn
wTXEJ8EswTXELMEOwTXEDsEmwTXEJsH_-zzmwTXEKMEPwTXED8E1-cg-NcYH7jX90D81xD-ANcQ-
NcA-NcQ-wDXEPzXL-h0rU9E1xyjRNcco0TXOP8Y1wj8kwDXGJMAYwDXGGMAWwDXGFsAqwDXGKsAn
wDXGJ8AswDXGLMAOwDXGDsAmwDXGJsD_-zzmwDXGKMAPwDXGD8A1-cg-NcYH7jX90D81zD81wD81
zD81y-4dK1PQNcgo0DXIKNA1zj-ANT-ANT81P8A1wT8kwDXGJMAYwDXGGMAWwDXGFsAqwDXGKsAn
wDXGJ8AswDXGLMAOwDXGDsAmwDXGJsD_-zzmwDXGKMAPwDXGD8A1-cg-NcYH7jX90T81yj81wj81
yj81zP4dK1PPNckozzXJKM81zz81wD-CNcA-NcE-JMA1xiTAGMA1xhjAFsA1xhbAKsA1xirAJ8A1
xifALMA1xizADsA1xg7AJsA1xibA-v885sA1xijAD8A1xg-ANf3IPzXGB_41-dI-yjXEP8o1zf4d
K1PONcoozjXKKM410T81wD-ANcA-NcI-JMA1xiTAGMA1xhjAFsA1xhbAKsA1xirAJ8A1xifALMA1
xizADsA1xg7AJsA1xibA-v885sA1xijAD8A1xg-ANf3IPzXGB_41xT-ANT-BNT-BNT81PzU-wTU-
wTU-wTU-wTXAP8A1P8A1zD-BNT-BNT81PzX4-h0rU801yyjNNcsozTXTPzXCPzXDPyTBNcQkwRjB
NcQYwRbBNcQWwSrBNcQqwSfBNcQnwSzBNcQswQ7BNcQOwSbBNcQmwf7-PObBNcQowQ-BNcQPwTX9
yD81xgfuNcQ-NcE-NT81wD81wD81PzU-NT81PzU-NcA-NcE-NcA-NT81PzU-NcA-Ncg-NcE-NT81
wT81_P4dK1PMNcwozDXMKMw11T-CNcQ-JMI1wiTCGMI1whjCFsI1whbCKsI1wirCJ8I1wifCLMI1
wizCDsI1wg7CJsI1wibC-v885sI1wijCD8I1wg-CNf3IPzXGB_41xD-BNT-BNcA-NcA-NT81P8A1
wD-BNcA-NcE-NcA-NT81PzU-Ncs-wTU-wTXAPzX9-eQ-JMoYyhbKKsonyizKDsomyijKD8o1-cg-
NcYH7jXGPzU-NT81wD81wD81PzU-NT81PzU-NcA-NcE-NcA-NT81PzU-NcA-Nco-NT81PzU-Nf39
5T8kyhjKFsoqyifKLMoOyibKKMoPyjX9yD81xgfuNcQ-wDXAPzU-NcA-NcE-wDU-NT81PzU-NcA-
NcA-wTU-wDXAPzU-Ncs-wTU-wTU-NT81yz-cNf32PzX91P7RS_PKNf3gPzXGB_41-dE-zjXNPzX9
9T81-dQUyjX94D81xgfuNf3QP881zj81-fQ-Nf3UFMI1whTCNf3gPzXGB8s1B8U1B8A1wAfINQfB
NcAHxDX90D-PNc4-Nf30PzX91BTBNcQUwTX94D81xgfLNQfFNQc1B8A1B8c1B8A1B8Y1-dA-wTXJ
P8E1wj-BNcA-wzXAPzX99D81-dQUwDXGFMA1-eA-NcYHxjUHNQfANcEHwTXBBzUHwDUHwDXAB8E1
wQfANQfGNcQ-NcE-wTXAP8A1PzU-NT-BNT-ANcA-wTXAP8A1wD-ANc8-wTU-wTU-NT81yT-BNck-
wTXBP8M1P8M1wD81wf4dK1M1-eM-NcY-NcE-Nf3UFMA1xhTANf3gPzXGB8U1wwc1B8A1BzUHwDUH
wDXBB8I1BzUHwDUHNcIHxDXEPzXCPzXAPzXBPzU-NcA-NcA-NT81PzXBPzXBPzXCPzXOPzU-NT81
wT81yT-PNcE-wzU-wzXAPzXAKD8oNcwozDXMKMw1zCjMNcw-NcY-NcE-Nf3UFMA1xhTANf3gPzXG
B8Y1BzUHwDUHwDUHNQfANQfCNQfANcEHNQfANQfANQfGNcQ-NcI-NcA-NcE-wTXAPzXAPzU-NT-A
NcA-wTU-wTXRPzU-NT81wD81yj-BNck-wTXBP8M1P8M1wD81wCg-wCg1yijNNcsozTXLKM01zT81
xD81wj81-dQUwDXGFMA1-eA-NcYHxTXDBzUHwDUHNQfANQfCNQc1B8A1BzUHwDUHwDUHxjXEPzXC
PzXAPzU-NT81PzXAPzXAPzU-NT81wz81wT81wD81zj81PzU-NT81yz-BNck-wTXCP8E1wD-DNcA-
NcAoP8EoNcgozjXKKM41yijONc4-NcI-NcM-Nf3UFME1xBTBNf3gPzXGB8Y1BzUHwDXBB8E1wQfA
NcAHwTXBB8A1wQfANQfGNcQ-wTU-wTU-wTU-NT81wD81wD81PzU-wTU-wDXAP8A10j81P8E1PzU-
Nck-zzXOPzXAKD-CKDXGKM81ySjPNckozzXPP8I1xD81-dQUwjXCFMI1-eA-NcYH7jX90D-PNc4-
NcAoP8AowDXGKNA1yCjQNcgo0DXZPzX91BTKNf3gPzXGB_41-dE-zjXNPzXCKMA-KDXFKNE1xyjR
Ncco0TXZPzX91BTKNf3gPzXGB_41-dI-3DXNKNI1xijSNcYo0jXZP-39-cY1-f35KNI1xijSNcYo
0jX9-f39-f3eKNI1xijSNcYo0jX9-f39-f3eKNI1xijSNcYo0jX9-f39-f3eKNI1xijSNcYo0jX9
-f39-f3eKNI1xijSNcYo0jXZP-39-f399DXLKNI1xijSNcYo0jXZPzXyP8U1-f39-fU-Ncso0jXG
KNI1xijSNdk-NfE-xzX9-f399D81yyjRNcco0TXHKNE12j818T-HNecfwzX9-f39xj81yyjQNcgo
0DXIKNA12z818T-HNeYfxTX9-f39xT81yyjPNckozzXJKM813D818T-HNeUfxzX9-f39xD81yyjO
NcoozjXKKM413T818T-HNeUfxzX9-f39xD81yyjNNcsozTXLKM013j818j-FNeYfxzX9-f39xD81
yyjMNcwozDXMKMw13z818-7-zKrDNecfxzX9-f39xD81-fQ-NfIUxTXmH8c1-f39-cQ-Nf30PzXx
FMc15h-FNdYywzX9-f3mPzX99D818RTHNecfwzXWMsU1-f395T81-fQ-NfEUxzX9xTLHNf3INsM1
-f3VPzX99D818RTHNf3FMsc1-cc2xTX9-dAxwzX99D818RTHNf3FMsc1-cY2xzX2O8M1-c8xxTX9
8z818hTFNf3GMsc1-cY2xzX1O8U1-c0xxzX98j818xTDNf3HMsc1wiPDNfs2xzX0O8c1-cwxxzXP
KMw1zCjMNcwozDXZPzX9wyHDNfgyxTXCI8U1_jbHNfQ7xzX9zDHHNc4ozTXLKM01yyjNNdk-Nf3C
IcU1_DLDNcIjxzX5Nsc19DvHNf3MMcc1zSjONcoozjXKKM412T81-cEhxzX9wiPHNfo2xTX1O8c1
-cwxxzXMKM81ySjPNckozzXZPzX9wSHHNf3CI8c1_zbDNfY7xzX9zTHFNcwo0DXIKNA1yCjQNdk-
NeT_-4VXwzXUIcc1-cIjxzX9_zvFNdk-wzXtMcM1zCjRNcco0TXHKNE12T814yzFNdMhxzX9wiPH
Nf38O8M12T8Hwz817B3DNcso0jXGKNI1xijSNdk-NeIsxzXSIcc1-cMjxTX9-d4-B8U-NeodxTXK
KNI1xijSNcYo0jXPP8I1xD814izHNdMhxTX9xSPDNf3eCsM19z8Hxz816B3HNcko0jXGKNI1xijS
Nc4-NcI-NcM-NeIsxzXUIcM1-f3qCsU19j8Hxz816B3HNcko0jXGKNI1xijSNc4-NcM-NcI-NeIs
xzX9-f3GCsc19T8Hxz816B3HNcko0jXGKNI1xijSNcg-NT-ANcA-NcQ-NcE-NeIsxzX9-f3GCsc1
9T8Hxz816B3HNcko0jXGKNI1xijSNcg-NT81PzU-NcU-NcA-NeMsxTX9-f3HCsc19T8Hxz816B3H
Ncko0jXGKNI1xijSNck-wDU-NT81xD81wT815CzDNf3p-gCyUcM1-dYKxzX2PwfFPzXqHcU1yijS
NcYo0jXGKNI1zj81wz81wj817gDDNf3eJsU14hXDNeoKxzX3PwfDPzXsHcM1yyjRNcco0TXHKNE1
yT81P8A1wD81wj81wz817QDFNf3cJsc14BXFNeoKxTX5P8M18T81yyjQNcgo0DXIKNA1yj81PzU-
NcA-wjXEPzXNDcM12ADHNf3bJsc13xXHNeoKwzX99D81yyjPNckozzXJKM81zD-ANT81yj81zA3F
NdcAx-6iiHk1-domxzXfFcc1-f3nPzXLKM41yijONcoozjXdPzXLDcc11gDHEjX92ibHNd8VxzX9
-dP_5A2rwzXNPzXLKM01yyjNNcsozTXNPzXBPzXKPzXLDcc11gDHEjX92ibHNd8VxzX9-dIPxTXM
PzXLKMw1zCjMNcwozDXOPzU-NT81yj81yw3HNdYAxxI1-dsmxTXgFcc1-eYQwzXiD8c1yz81-eM-
wzXKPzXLDcc11wDFEsA1-dwmwzXiFcU1-eYQxTXhD8c1yz81-fQ-NcsNxzXYAMMSwDX9-ckVwzX9
5hDHNeAPxzXLPzX95D-CNco-NcwNxTXaEsM1-f399xDHNeAPxzXLPzX94z81zj81zQ3DNf39yf4A
h1HDNf39yxDHNeD_5A2rxzXLPzX94z-DNco-NeL_q1I2wzX98f4Ah1HFNf39yhDHNeH_5A2rxTXM
PzX99D814QrFNf3v-gCHUcc1-f3JEMc14v7kDavDNc0-Nf3jPzXOPzXgCsc1-e7_AIdRxzX9-coQ
xTX3PzX94z-DNco-NeAKxzX97g-HNf39yxDDNfg-NdEozDXMKMw1zCjMNcg-Nc4-Ncr_uQA_wzXP
Csc1-e4PxzX93CDDNf3nPzXQKM01yyjNNcsozTXZPzXJEsU1zgrHNf3uD8c1-dsgxTX95j81zyjO
NcoozjXKKM41yD-DNco-NcgSxzXNCsc1-e8PxTX92yDHNf3lPzXOKM81ySjPNckozzXKPzXMPzXI
Esc1zgrFNf3xD8M1-dwgxzX95T81zSjQNcgo0DXIKNA1yD-DNco-NcgSxzXPCsM11i7DNf39_CDH
Nec6wzX1PzXMKNE1xyjRNcco0TXZPzXIEsc16y7FNf399yDHNeY6xTX0PzXLKNI1xijSNcYo0jXI
PzXAP8A1yj81yBLHNeouxzX9-fYgxzXlOsc18z81yyjSNcYo0jXGKNI1yD81wT81yj81yRLFNesu
xzX9-fcgxTXmOsc18z81yyjSNcYo0jXGKNI1yT-CNco-NcoSwzXsLsc1-f34IMM15zrHNegtwzXE
PzXLKNI1xijSNcYo0jXZPzX9Lsc1-f3EOcM1-d06xzXnLcU1wz81yyjSNcYo0jXGKNI1yD81wT81
yj811xvDNd8uxzX9-cM5xTX93DrHNeYtxzXCPzXLKNI1xijSNcYo0jXIP8M1yj811hvFNd8uxTX9
-cM5xzX93DrFNectxzXCPzXLKNI1xijSNcYo0jXIPzXBPzXKPzXVG8c13y7DNf39xDnHNf3dOsM1
6C3HNcI-Ncso0jXGKNI1xijSNdk-NdUbxzX9-eo5xzX9-c4txzXCPzXLKNE1xyjRNcco0TXNPzXK
PzXVG8c1-f3qOcc1-f3OLcc1wj81yyjQNcgo0DXIKNA1zj81yj811RvHNf396jnHNf39zy3FNcM-
NcsozzXJKM81ySjPNcs-wzXKPzXBA8M1zRvHNf396znFNf390S3DNcQ-NcsozjXKKM41yijONd0-
NcADxTXNG8U1-f3tOcM1-f3dPzXLKM01yyjNNcsozTXePzUDxzXNG8M1-f39-f3UPzXLKMw1zCjM
NcwozDXfPzUDxzX9-f39xijDNf3bPzX99D81A8c1-f39-cUoxTX92j81-fQ-NQPHNf39-f3EKMc1
-dk-Nf30PzUDxzX9-f39xCjHNf3ZPzX99D81wAPFNf39-f3FKMc1-dk-Nf30PzXBA8M1-f39-cYo
xzX92T81-fQ-Nf39-f3OKMc1-dk-Nf30PzX9-f39zyjFNf3aPzX99D81-f39-dAowzX92z810SjM
NcwozDXMKMw12T81-f39-f3yPzXQKM01yyjNNcsozTXZPzX9-f39-fI-Nc8ozjXKKM41yijONdk-
Nf39-f398j81zijPNckozzXJKM812T81-f39-f3yPzXNKNA1yCjQNcgo0DXZPzX9-f39-fI-Ncwo
0TXHKNE1xyjRNdk-Nf39-f398j81yyjSNcYo0jXGKNI12T81-f39-f3yPzXLKNI1xijSNcYo0jXZ
PzX9-f39-fI-Ncso0jXGKNI1xijSNdk-Nf39-f398j81yyjSNcYo0jXGKNI12T81-f39-f3yPzXL
KNI1xijSNcYo0jXZPzX9-f39-fI-Ncso0jXGKNI1xijSNdk-Nf39-f398j81yyjSNcYo0jXGKNI1
2T81-f39-f3yPzXLKNI1xijSNcYo0jXZP-39-f399DXLKNE1xyjRNcco0TX9-f39-f3fKNA1yCjQ
Ncgo0DXdP8A1wD-ANT-BNcs-wTU-wTU-wDXHP8A1P8E1P8E1P8A1wT-ANT-BNeA-NT81P8E1PzXB
PzXCP8A1PzU-Nco-wDU-wTU-wTU-wTU-wDXkP8A1PzU-NT-BNT-ANfU-wTU-NcE-NT81P8E1yT81
PzU-wTXAP8A1PzXBP8E1P8E1yT-BNT81PzU-wTU-wTU-NcE-wTXQP8E1zSjPNckozzXJKM813T81
PzU-NcE-Nc0-NT81PzXBPzU-NcU-NT81PzU-NT81PzU-NT81PzXBPzXiPzU-NT81wT81wT81wT81
PzU-NT81yT81wT81PzU-NcE-NcE-NT814j81wT81PzU-NT81PzU-NfQ-NT81PzXBPzU-NT81yz81
PzXAPzXAPzU-NT81wT81wj81yj81PzU-NT81PzU-NT81PzU-NcE-NdI-NT81zSjONcoozjXKKM41
3j81PzU-wTU-wDXMP8A1wD-ANcA-NT81xT81PzU-wDXAP8E1PzU-NT81wT-ANcEhwzXZP8AfwzU-
NcE-NcE-NT81PzU-Nck-NcE-wDXAP8A1wD-ANcA-NT814j81wT-BNT-BNT81PzX0P8A1wD81wT81
PzU-wDXKPzU-NcA-NcA-NT81PzXBP8A1wT81yj-BNT81PzU-wDXAP8E1PzXBP8A10T-ANc4ozTXL
KM01yyjNNd8-NT81wT81PzXBEsMNwTXCPzU-NT81wT81PzXBLMM1PzU-NQDDFMM-NT81PzXBIcU1
2R-FPzXBPzXBPzU-NT-BNck-NT81PzU-NT8jwzUmwzXAD8M12j81FcM1PzU-NT81PzXk-imt-8M1
yT81PzU-NcE-NT81PzXLP8E1wD81wD81PzU-NcE-NcI-Nco-NcE-NT81PzU-NT81wT81wT810jHD
NcsozDXMKMw1zCjMNeA-wDXAP8A1wD-BEsUNwTXBPzU-NT-BNT-BNcAsxTXAPwDFFMM-wDU-wSHH
Ndcfxz-ANT-BNT-ANcA-wTXJP8E1PzU-NSPEJsUPxTXaFcU-NT81PzU-NeMKxTXIP8E1P8E1wD-A
NT-BNco-NcA-wTU-wDXAP8E1P8E1wD81yj81wj-ANT81PzU-NcE-wTU-wTXA-uQNq8M1yDHFNf39
wBLHDcE1zCzHNQDHFMM1wyHHNdcfxzXeI8Qmx-4Ah1HFNdgVxzXoCsc1-d3_5A2rxTXGMcc1-fI-
yRLHDcE-zCzHPwDHFMM-wyHHP9cfxz-eI8Qmx-4Ah1HFP9gVxz-oCsc--dz_5A2rxz-FMcc1-fI-
NcgSxw3BNcwsxzUAxxTDNcMhxzXXH8c13iPEJsf_AIdRxTXYFcc16ArHNf3c-uQNq8c1xTHHNf3y
PzXIEscNwTXMLMc1AMcUwzXDIcc11x-HNd4jxCbH-gCHUcU12BXHNegKxzX93P7kDavHNcUxxzX9
8j81yBLHDcE1zCzHNQDHFMM1xCHFNdkfxTXfI8Qmx-4Ah1HFNdgVxzXoCsc1-dz_5A2rxzXFMcc1
-fI-NckSxQ3BNc4sxTXBAMUUwzXGIcM12x-DNdcywzXDI8Qmxf4Ah1HFNdoVxTXqCsU1-d3_5A2r
xzXGMcU1-fM-NcoSww3BNdAswzXDAMMUwzX9yDLFNcMjwzUmwzXA-gCHUcM13BXDNewKwzX93-7k
DavFNcgxwzX99D81-f3DMsc1-f390A-DNc0-NdEozDXMKMw1zCjMNdk-Nf39wzLHNf39-eQ-NdAo
zTXLKM01yyjNNdk-Nf39wzLHNf3INsM1-f3VPzXPKM41yijONcoozjXZPzX9-cMyxzX9xzbFNf39
1D81zijPNckozzXJKM812T81-f3DMsc1-cY2xzX9-dM-Nc0o0DXIKNA1yCjQNdk-Nf39xDLFNf3H
Nsc1-f3TPzXMKNE1xyjRNcco0TXZPzX9-cUywzX9wjnDNTbHNf390z81yyjSNcYo0jXGKNI12T81
-f39zTnFNsc14yDDNf3nPzXLKNI1xijSNcYo0jXZPzX9-f3MOcY2xzXiIMU1-eY-Ncso0jXGKNI1
xijSNdk-Nf39-cw5xzbFNeIgxzX95T81yyjSNcYo0jXGKNI12T81-f39zDnHNTbDNeMgxzX95T81
yyjSNcYo0jXGKNI12T81-f39zDnHNekgxzX95T81yyjSNcYo0jXGKNI12T81-f39zDnHNekgxzX9
5T81yyjSNcYo0jXGKNI12T81-f39zTnFNeogxzX95T81yyjSNcYo0jXGKNI12T81-f39zjnDNewg
xTX95j81yyjRNcco0TXHKNE12j81-f39-cQgwzX93C3DNcQ-Ncso0DXIKNA1yCjQNds-Nf39-f39
5i3FNcM-NcsozzXJKM81ySjPNcw-wjXKPzXi-qtSNsM1-f39-fotxzXCPzXLKM41yijONcoozjXM
PzXOPzXhCsU1-f39-fktxzXCPzXLKM01yyjNNcsozTXNP8M1yj814ArHNf39-f34Lcc1wj81yyjM
NcwozDXMKMw13z811xvDNcIKxzX9-f39_C3HNcI-Nf3jP8I1yz811hvFNcEKxzX9-f39_C3HNcI-
Nf3jPzXBPzXKPzXVG8c1wArHNf39-f35LcU1wz81-eQ-wjXKPzXVG8c1wArHNf39-f36LcM1xD81
-fQ-NdUbxzXBCsU1-f39-f3IPzX94z81wT81yj811RvHNcIKwzX9-f39zz-DNfE-Nf3jP8M1wD-C
NcQ-NdUbxzX9-f3uKMM14D8Hwz818D81-eM-NcE-NT81wj81wz811hvFNf39-e4oxTXePwfFPzXv
PzX96T81wz81wj811xvDNf39-e4oxzXcPwfHPzXuPzXRKMw1zCjMNcwozDXIPzXDPzXEPzXBPzX9
-f39zijHNdw-B8c-Ne4-NdAozTXLKM01yyjNNcg-wzU-NcU-NcA-Nf39-f3OKMc12zo-B8c-Ne4-
Nc8ozjXKKM41yijONcg-NcM-NcQ-NcE-Nf39-f3OKMc12jrAPwfHPzXuPzXOKM81ySjPNckozzXO
PzXDPzXCPzX9-f39zijHNdk6wT8Hxz817j81zSjQNcgo0DXIKNA1yD-DNT81wj81wz81-f39-c8o
xTXaOsI-B8U-Ne8-Ncwo0TXHKNE1xyjRNcg-NT81wj-CNcQ-Nf39-f3QKMM12zrDPwfDPzXwPzXL
KNI1xijSNcYo0jXIP8M1yj81-f39-fI6xD-DNfE-Ncso0jXGKNI1xijSNdk-Nf39-f3yOsc18z81
yyjSNcYo0jXGKNI1yD-ANT-ANco-Nf39-f3zOsU19D81yyjSNcYo0jXGKNI1yD81PzXMPzX9-f39
9DrDNfU-Ncso0jXGKNI1xijSNcg-wzXKPzX9-f39-fI-Ncso0jXGKNI1xijSNdk-Nf39-f398j81
yyjSNcYo0jXGKNI1yD-DNco-Nf39-f398j81yyjSNcYo0jXGKNI1zD81yj81-f39-f3yPzXLKNE1
xyjRNcco0TXJP8I1yz81-f39-f3yPzXLKNA1yCjQNcgo0DXbPzX9-f39-fI-NcsozzXJKM81ySjP
Ncs-Nc4-Nf39-f398j81yyjONcoozjXKKM41zD-DNco-Nf39-f398j81yyjNNcsozTXLKM01zT81
zj81-f39-f3yPzXLKMw1zCjMNcwozDXfPzX9-f39-fI-Nf3jP8M1yj81-f39-f3yPzX94z81PzXM
PzX9-f39-fI-Nf3jP8M1yj81wQPDNf39-f3pEMM1_D81-fQ-NcADxTX9-f395xDFNfc-Nf3jPzU-
wDXLPzUDxzX9-f395RDHNfY-Nf3jPzU-NT81yj81A8c1-f39-eUQxzX2PzX95D-ANT81yj81A8c1
-f39-eUQxzX2PzX99D81A8c1-f39-eUQxzX2PzXRKMw1zCjMNcwozDXZPzUDxzXl-qKIecM1-f39
9xDHNfY-NdAozTXLKM01yyjNNdk-NcADxTXlEsU1-f399xDFNfc-Nc8ozjXKKM41yijONdk-NcED
wzXlEsc1-f399xDDNfg-Nc4ozzXJKM81ySjPNdk-Ne0SxzX9-f39_D81zSjQNcgo0DXIKNA12T81
7RLHNf39-f34PzXMKNE1xyjRNcco0TXZPzXtEsc1-f39-fg-Ncso0jXGKNI1xijSNdk-Ne0SxzX9
-f39_D81yyjSNcYo0jXGKNI12T817hLFNf39-f35PzXLKNI1xijSNcYo0jXZPzXvEsM1-f39-fo-
Ncso0jXGKNI1xijSNdk-Nf3BLsM1-f39-eo-Ncso0jXGKNI1xijSNdk-Nf3ALsU1-f39-ek-Ncso
0jXGKNI1xijSNdk-Nf0uxzX9-f396D81yyjSNcYo0jXGKNI12T81-S7HNf39-f3oPzXLKNI1xijS
NcYo0jXZPzX9Lsc1-f39-eg-Ncso0TXHKNE1xyjRNdo-Nf0uxzX9-f3NO8M1-dQ-Ncso0DXIKNA1
yCjQNds-Nf0uxzX9-f3MO8U1-dM-NcsozzXJKM81ySjPNdw-Nf3ALsU1-f39zDvHNf3SPzXLKM41
yijONcoozjXdPzX9wS7DNf39-c07xzX90j81yyjNNcsozTXLKM013j81-f39-dU7xzX90j81yyjM
NcwozDXMKMw13z81-f39-dU7xzX90j81-fQ-Nf39-f3VO8c1-dI-Nf30PzX9-f391jvFNf3TPzX9
9D81-f39-dc7wzX91D81-fQ--f39-f30Nf39-f39-f39-f39-f39-f3fP9M1-f39-f3bPzX99j81
0z81-f39-f3ZPzU-Nf30PzXVPzXb-v8fisT_-yl6xP7-MGrE-v81WsT_-zlHxP7-PTDE-v5CAMT_
8VcAxP7nZADE-t1tAMT_1XQAxP7OegDE-sd_AMT_wYMAxP66hwDE-rSKAMT_rY4AxP6mkQDE-p_U
AMT_lpgAxP6NmwDE-oGfAMT_c6MAxP5epwDE-jutAMT_AK8xxP4ArlTE-gCsaMT_AKt2xP4AqoLE
-gCpi8T_AKiUxP4Ap5vE-gCmosT_AKWpxJ_fxP4Ao7bE-gCivcT_AKHExP4An8zE-gCe1MT_AJvf
xP4AmOvE-gCU_8T_M5D-xP5NjP-E-l_I-8T_boP-xP57f--E-od6-8T_k3T-xD-_AAAAwT-_n23-
-qxk-8T_uVj-xP7IR--E-tkl-8T_5QDzxP7sAOHE-vIAz8T__AC_xP78AKzANf3APzXBP8A1PzXB
P8E1P8E1P8A1wT812-7-H4rE-v8pesQIxDHE-v85R8T_-z0wxDnEO8T_52QAxC3EOMQBxP7HfgDE
-sGDAMT_uocAxAPEAsQ8xP6flADEL8QjxP6BnwDEPcQSxP47rQDEN8QnxP4ArGjE-gCrdsT_AKqC
xP4AqYvE-gColMT_AKebxCHEDcSfn8T_AKO2xArE-gChxMQkxP4AntTE-gCb38T_AJjrxP4AlPvE
-jOQ-8T_TYz-xP5fiP-E-m6D-8T_e3--xCXEK8M--gAAAMM-JsT_uVj-xP7IR--E-tkl-8T_5QDz
xCDENMT__AC_xB3ANf3APzXAPzXBPzXBPzXBPzU-NT81PzXAPzXb-v8fisT_-yl6xAjEMcT_-zlH
xP7-PTDEOcQ7xP7nZADELcQ4xAHE-sd_AMT_wYMAxP66hwDEA8QCxDzE-p_UAMQvxCPE-oGfAMQ9
xBLE-jutAMQ3xCfE-gCsaMT_AKt2xP4AqoLE-gCpi8T_AKiUxP4Ap5vEIcQNxJ_fxP4Ao7bECsT_
AKHExCTE-gCe1MT_AJvfxP4AmOvE-gCU_8T_M5D-xP5NjP-E-l_I-8T_boP-xP57f--EJcQrwj-_
AAAAxT8mw-65WP-E-shH-8T_2SX-xP7lAPPEIMQ0xP74AL7EHcA1-cA-NcA-NcE-NcE-wDXAP8E1
P8A1wT812-7-H4rE-v8pesQIxDHE-v85R8T_-z0wxDnEO8T_52QAxC3EOMQBxP7HfgDE-sGDAMT_
uocAxAPEAsQ8xP6flADEL8QjxP6BnwDEPcQSxP47rQDEN8QnxP4ArGjE-gCrdsT_AKqCxP4AqYvE
-gColMT_AKebxCHEDcSfn8T_AKO2xArE-gChxMQkxP4AntTE-gCb38T_AJjrxP4AlPvE-jOQ-8T_
TYz-xP5fiP-E-m6D-8T_e3--xCXEK8I--gAAAMU-JsP_uVj-xP7IR--E-tkl-8T_5QDzxCDENMT_
_AC_xB3ANf3APzXAPzXBPzXBPzXBPzU-NT81PzXAPzXb-v8fisT_-yl6xAjEMcT_-zlHxP7-PTDE
OcQ7xP7nZADELcQ4xAHE-sd_AMT_wYMAxP66hwDEA8QCxDzE-p_UAMQvxCPE-oGfAMQ9xBLE-jut
AMQ3xCfE-gCsaMT_AKt2xP4AqoLE-gCpi8T_AKiUxP4Ap5vEIcQNxJ_fxP4Ao7bECsT_AKHExCTE
-gCe1MT_AJvfxP4AmOvE-gCU_8T_M5D-xP5NjP-E-l_I-8T_boP-xP57f--EJcQrwj-_AAAAxT8m
w-65WP-E-shH-8T_2SX-xP7lAPPEIMQ0xP74AL7EHcA1-cA-NcE-wDU-wTU-wTU-NT81PzU-NcA-
Ndv_-x_KxP7-KXrECMQxxP7-OUfE-v89MMQ5xDvE-udkAMQtxDjEAcT_x34AxP7BgwDE-rqHAMQD
xALEPMT_n5QAxC-EI8T_gZ8AxD3EEsT_O60AxDfEJ8T_AKxoxP4Aq3bE-gCqgsT_AKmLxP4AqJTE
-gCnm8QhxA3En5-E-gCjtsQKxP4AocTEJMT_AJ7UxP4Am9-E-gCY68T_AJT7xP4zkP-E-k2M-8T_
X4j-xP5ug--E-nt--8QlxCvCP-4AAADFPybD-rlY-8T_yEf-xP7ZJf-E-uUA88QgxDTE-vgAvsQd
wDX9wD811T81-f39-f3WP8U1-fM-NdM-Nf39-f39-f3WP9M1-f39-f39-f39-e8-wDXAP8A1wD-A
NcA-wDXAPzU-NT81PzU-wTXAP8A1wD-ANcA-wDXAP8A1-f39-f39-cA-wDXAP8A1wD-ANcA-wDXB
PzU-NT81PzU-NcM-wDXAP8A1wD-ANcA-wDX9-f39-f38P8A1wD-ANcA-wDXAP8A1wj-BNT81PzU-
wDXDP8A1wD-ANcA-wDXAP8A1-f39-f39-D-ANcA-wDXAP8A1wD-ANcE-NT81PzU-NT81wz-ANcA-
wDXAP8A1wD-ANf39-f39-f3AP8A1wD-ANcA-wDXAP8A1wD81PzXAP8A1P8E1wD-ANcA-wDXAP8A1
wD-ANf39-f3LAAAAAAAAAAE=
:: main.lua
--[[pod_format="raw",created="2024-03-31 05:33:06",modified="2025-03-23 16:12:38",revision=10106]]
include "src/globals.lua"
include "src/custom_wrangle.lua"
include "src/oklab.lua"
include "src/palette.lua"
include "src/settings.lua"
include "src/files.lua"
include "src/integration.lua"
include "src/soft_wrap.lua"
include "src/gui.lua"
include "src/gui_palette.lua"
include "src/gui_alt_sliders.lua"
include "src/gui_old_sliders.lua"
include "src/gui_settings.lua"
include "src/gui_help.lua"
include "src/gui_newfile.lua"
include "src/gui_hexdialog.lua"


function _init()
	load_settings()

	window {
		tabbed = true,
		workspace = user_settings.open_in_gfx_workspace and 1 or nil,
		icon = --[[pod_type="gfx"]]unpod("b64:bHo0ABYAAAAUAAAA8AVweHUAQyAICARwtyBHIBcgRyC3cA=="),
	}
	
	local default_folder = "/ram/cart/pal/"
	-- TODO: useful or not?
--	if env().sandbox then
--		default_folder = "/appdata/pal/"
--	end
	
	local working_file_path = env()[1]
	if type(working_file_path) ~= "string" then
		mkdir(default_folder)
		working_file_path = default_folder .. "0.pal"
	end

	menuitem{
		id = "new_file",
		label = "\^:7f4141417f616500 New File",
		action = function()
			local segs = split(working_file_path,"/",false)
			local path = string.sub(working_file_path, 1, -#segs[#segs] - 2) -- same folder as current file
			local open_with = env().argv[0]
			if (open_with == "/system/apps/terminal.lua") then
				open_with = "/ram/cart/main.lua"
			end
			create_process("/system/apps/filenav.p64", { path = path, use_ext = "pal", intention="new_file", open_with = open_with, window_attribs= {workspace = "current", autoclose=true}})
		end
	}

	custom_wrangle_working_file(
		save_working_file,
		load_working_file,
		working_file_path
	)

	menuitem{
		id = "export_hex",
		label = "\^:7f4141417f616500 Export File",
		action = function()
			local current_filename = pwf()
			local segs = split(current_filename,"/",false)
			local path = string.sub(current_filename, 1, -#segs[#segs] - 2) -- same folder as current file
			create_process("/system/apps/filenav.p64", 
				{path=path, intention="select_file", use_ext = "hex", window_attribs={workspace = "current", autoclose=true}})
		end
	}
	on_event(
		"select_file",
		function(event)
			local filename = event.filename
			local ext = event.filename:ext()
			if ext == nil then
				filename ..= ".hex"
				ext = "hex"
			end
			notify("Palette exported to " .. filename)
			if ext == "hex" or ext == "txt" then
				store(filename, save_hex_file(), { metadata_format="none" })
			else
				local data, metadata = save_pal_file()
				store(filename, data, metadata)
			end
		end
	)

	
	-- Force the 11 first rows of the screen to use a default palette,
	-- so that the menu bar stays readable even when the colors used by
	-- the gui are redefined.
	poke(0x5400, 0b01010101, 0b01010101, 0b00010101)
	init_color_band()
	
	rebuild_palette()
	
	on_event("lost_focus", function() send_palette() end)
		
	on_event("drop_items", handle_drop_items)
	
	init_undo()

	menuitem { id = "okpal_div1", label = "", divider = true, action = function() end }
	menuitem {
		id = "okpal_clear_colors",
		label = "\^:0000000000000000 Clear Palette",
		action = function() undo_stack:checkpoint(); clear_colors() end
	}
	menuitem {
		id = "okpal_reset_colors",
		label = "\^:0000000000000000 Reset Pic. Colors",
		action = function() undo_stack:checkpoint(); reset_picotron_colors() end
	}
	menuitem { id = "okpal_div2", label = "", divider = true, action = function() end }
	menuitem {
		id = "okpal_manual",
		label = "\^:0000000000000000 Help",
		shortcut = "F1",
		action = open_help
	}
	
	test_cube_colors = test_cube_colors or default_test_cube_colors()
	test_ramp_colors = test_ramp_colors or default_test_ramp_colors()
	generate_gui()
	
	if is_new_file then
		open_new_file_dialog()
	end
	
	if imported_hex_file then
		open_import_hex_file_dialog()
	end
end


function _draw()
	cls(bg_color)
	gui:draw_all()
	blinked()
end


function _update()
	if padlock_flashing then
		padlock_flashing_time += 1
	end
	if crying_a_timer > 0 then
		crying_a_timer -= 1
		if crying_a_timer <= 0 then
			crying_a_done = true
		end
	end
	if circling_anim_timer > 0 then
		circling_anim_timer -= 1 / 12.0
	end
	
	if gui_changed then
		generate_gui()
		refresh_modal()
		gui_changed = false
	end
	gui:update_all()
	
	if key("ctrl") then
		if keyp("c") then copy_color() end
		if keyp("x") then cut_color() end
		if keyp("v") then paste_color() end
		if keyp("z") then undo_stack:undo(); update_hidden_toggles() end
		if keyp("y") then undo_stack:redo(); update_hidden_toggles() end
	end
	
	if keyp("f1") then open_help() end
	
	if keyp("tab") then
		pickers_mode = (pickers_mode == "linear_hue") and "circular_hue" or "linear_hue"
		gui_changed = true
	end
	
	if keyp("n") then
		change_settings({ show_color_names = not user_settings.show_color_names })
		gui_changed = true
	end
	if keyp("b") then
		change_settings({ show_color_band = not user_settings.show_color_band })
		if user_settings.show_color_band then
			show_color_band()
		else
			hide_color_band()
		end
		gui_changed = true
	end
end




-- Undo ---------------------------------------------------------------------------


function init_undo()
	undo_stack = create_undo_stack(
		-- Save current state
		function()
			return {
				mem = copy_palette(),
				hsl = copy_palette_hsl(),
				test_cube_colors = copy(test_cube_colors),
				test_ramp_colors = test_ramp_colors and test_ramp_colors:convert("u8"),
			}
		end,
		-- Restore previous state
		function(state)
			poke_palette(state.mem)
			restore_palette_hsl(state.hsl)
			test_cube_colors = state.test_cube_colors
			test_ramp_colors = state.test_ramp_colors
		end
		-- 0x11 -- appropriate?
	)	
end


function copy(t)
	if type(t) ~= "table" then
		return t
	end
	local new = {}
	for k, v in pairs(t) do
		new[k] = copy(v)
	end
	return new
end

:: manual.txt
--[[pod_format="raw",created="2024-04-04 06:47:16",icon=userdata("u8",16,16,"00000101010101010101010101000000000106060606060606060606060100000107010606060606060606060606010000010106060707070707070707060100000106060607070707060606070601000107010606070707070606060706010000010106060706060607070707060100000106060607060606070707070601000107010606070707070707070706010000010106060606060606060606060100000106060606060606060606060601000107010606060606060606060601010000010101010101010101010101070100000101070707070707070707070601000000010606060606060606060601000000000001010101010101010101000000"),modified="2025-03-23 16:12:32",revision=1173,stored="2024-04-04 06:56:33"]]
# OkPal

OkPal is a tool to create and edit color palettes.
You can easily use those palettes in your programs,
and even directly in Picotron's sprite and map editors.

To use a palette, add the following line to your 
initialisation code:

```
    fetch("pal/0.pal"):poke(0x5000)
```


## Features

- Colors are defined by their hue, saturation and
  lightness; the calculations use a perceptually
  uniform color space (OkLAB).
- Colors are displayed and edited on multiple
  2D graphs.
- Any change to the palette is propagated to
  Picotron's sprite and map editors.
- Ability to reorder colors by drag-and-drop.
- Undo/redo for all operations.
- Two file formats are supported: ".hex" and ".pal".
- Multiple options for importing external palettes
  (keep default palette, overwrite it, or try to 
  match it)


## Usage

The screen is separated in three different zones:
- At the top, the full palette is displayed, with
  colors ordered by number (sams as in the sprite
  editor first tab). The currently selected color
  is also displayed here.
- On the right, a "test zone" allows you to paint
  on cubes or square to test your modified palette.
- The rest of the screen display the colors as
  dots on interactive 2D graphs, called "pickers"
  in this manual. This is the main way to create
  and edit colors.


To modify a color, you must first select it. You can
do that either by clicking in the palette overview
at the top of the screen, or by clicking directly on
one of the color dots in the circle picker or in the
square picker.

Once selected, some information about the color are
displayed on the right of the palette overview:

- the color number;
- the hex code corresponding to the RGB values of
  the color;
- a padlock icon: if the padlock is closed, the color
  is "locked" and cannot be edited; click on the icon
  to lock/unlock it;
- an eye icon: if the eye is closed, the color is only
  shown in the palette overview; it is hidden in the
  circle and square pickers.
- a paint bucket icon: you can click on it to change
  the color background to the current selected color;
  click again to go back to a black background.

You can copy the current color by using Ctrl-C, and
paste a copied color onto the current one by using
Ctrl-V. This also works outside OkPal: the color is
stored in the clipboard as a hex code ("#ffacc5").

There is five different ways to adjust the selected
color:

- a small triangle *outside* the circle picker
  allows you to change the hue of the color;
- a small colored circle *inside* the circle picker
  allows you to change at the same time the hue and
  the saturation;
- a small colored triangle below the square picker
  allows you to change just the saturation;
- a small colored triangle at the right of the square
  picker allows you to change the lightness;
- finally, a small colored circle inside the square
  picker allows you to change at the same time the
  saturation and the lightness.

Any change you make can be reverted by hitting
Ctrl-Z for undo. Use Ctrl-Y for redo.

Once you have several colors in you palettes, you can
reorder them in the palette overview: just drag one
color onto another, they will swap their positions.
Note that both colors must be unlocked.


## Using the palette in cartridges

By default, the palette you edit is saved in the
cart you're working on, alongside your sprite sheets
and maps.

The default path is "/ram/cart/pal/0.pal"

In order to use a palette in your programs, you just
need to copy it in memory. The default palette is
stored at address 0x5000:

```
    fetch("pal/0.pal"):poke(0x5000)
```


## Loading and saving

If you only need one palette for your cart, you
don't need to do anything special to save it. It is
saved alongside the rest of your assets each time
you hit Ctrl-S.

In order to create a new palette, use the '+' button
at the right of the tabs and choose the name of your
new palette, for example "1.pal". If you need to
start from scratch for this new palette, use
"Empty Palette" or "Picotron Palette" from the menu.

You can load a previously created palette by using
"Open File" in the menu.


## Importing and exporting

You can import and export palettes for use with
external tools. Currently the only supported format
is ".hex" files, which are simple text files with one
line per color, represented by their RGB code in hex
format (without "#" or "0x", just the hexadecimal
numbers).

To import a palette, choose "Open File" from the
menu, and select the ".hex" file. If this is the first
time you open this external palette in OkPal, a
dialog will appear to let you choose how to arrange
the colors in the palette. You can either:

- Keep default Picotron palette in the first 32 colors,
  and put the imported colors in the last 32 slots.
- Or simply import the palette as is. Note that this
  will affect the interface and probably make it
  difficult to use the menu, the sprite editor and
  the map editor.

To export a palette, choose "Save File As" in the
menu. In the save dialog, enter a file name ending
in ".hex".


## Changelog

2025-??-??: versrion 1.2.2 (release ??)

- Added: when clicking on an empty slot (pure black) in the
  palette, the slot is initialised to pure white: this way
  it's faster to add new colors (no need to bring up saturation
  and luminance before chosing hue).
- Added: option for launching OkPal in the same workspace
  as the gfx editor.
- Added: Menu entry for creating a new file (necessary
  when sharing workspace with the gfx editor).
- Changed: when a ".hex" file is opened, the
  "test zone" (i.e. the cubes and ramps) is replaced
  with a simple overview of all the color codes; this
  is because ".hex" files do not contain any
  metadata, so they cannot save the test zone state.

2025-03-18: version 1.2.1 (release #okpal-10)

- Added: "Export File" menu entry to save a copy of the current file without opening it.
- Changed: ".hex" files are saved without metadata.
- Changed: dragging color dots is much more precise.
- Changed: constrain color changes along an axis when dragging a color dot
  using the right or middle mouse buttons (instead of holding "shift" or "control").
- Changed: bigger color dots, easier to grab.
- Changed: propagate palette to sprite and map editors only when focus is lost.
- Changed: Don't automatically register as default app for ".pal" and ".hex".
- Fixed: bug in opening files (due to bug in picotron's `wrangle.lua` since 0.1.1e)
- Fixed: reset display palette rows when hiding the color band.

2025-03-13: version 1.2.0 (release #okpal-9)

- Added: new alternate view with hue/lum and hue/sat pickers.
- Added: hold "shift" or "ctrl" when dragging a color dot to constrain the change along one axis.
- Added: ability to scroll the hue axis of the alternate view, either with the scroll wheel or the dedicated control at the bottom of the screen.
- Added: color names in the alternate view.
- Added: color band in the alternate view.
- Added: settings to hide the color names and color band.
- Added: angel.
- Changed: simplified the old view (remove color lines on the 1D sliders)

2025-03-08: version 1.1.0 (release #okpal-8)

- removed remapping option when importing ".hex" palettes (was not working very well anyway);
- added text entries for the hex code, the hue, the saturation and the luminance;
- added a new tab for drawing color ramps in the test zone;
- added dialog when creating a new palette (to choose between empty palette or default colors);
- added settings dialog;
- added settings to register OkPal as default app for ".pal" and ".hex" files;
- added settings for disabling the propagation of the palette to the sprite and map editors;
- added blink;
- changed dialog when importing ".hex" files;
- changed dialog for displaying help;
- fixed menu bar colors when default colors are redefined;
- fixed undo/redo of test cube color changes;

2025-02-26: version 1.0.4 (release #okpal-7)

- added registering as default app for ".pal" and ".hex" (needed for the file dialog?)
- added undo/redo and help buttons;
- added "clear" button to the "test cubes";
- added legends for the two pickers;
- changed: moved the luminance slider to the left of the sat/lum picker for consistency;
- fixed: palette is now propagated to all gfx and map editors (thanks to Eiyeron for the implementation);
- fixed: the "test cubes" saved in metadata where not properly loaded;


2024-08-23: version 1.0.3 (release #okpal-6)

- added: add file icon to saved palettes;
- changed: can load and import palettes by
  double-clicking in the file dialog (no need
  to drag-and-drop anymore);
- fixed: bug in BBS;

2024-05-03: version 1.0.2 (release #okpal-5)

- fixed: bug while using "+" button in Picotron
  0.1.0g;
- changed: disabled tabs in BBS, as it prevents
  the cart from running;

2024-04-27: version 1.0.1 (release #okpal-4)

- fixed: picotron's palette was not locked in the
  default file on first opening;
- fixed: saving a ".pal" file from an imported
  ".hex" file was not working;
- explain how to export to .hex in the manual;

2024-04-06: version 1.0.0 (release #okpal-3)

- propagate palette to sprite and map editors;
- undo/redo;
- reorder colors by drag-and-drop;
- import dialog;
- reorder imported colors to match default colors;
- added a manual;
- menu entries to initialize the palette and open
  the manual;
- flash padlock icon when trying to edit a locked
  color;
- shift-click paint-bucket icon to change the "white"
  color used in the interface, and ctrl-click the
  icon to change the "black" (useful when importing
  external palettes);

2024-04-02: version 0.0.3 (release #okpal-2)

- Added the ability to change the background color (by clicking on the small paint bucket icon), and switched the default background to black.
- Added the ability to import ".hex" files (using drag and drop from the "Open File" dialog); to actually create the ".pal" file, you need to save.
- Improved the color pickers.
- Added the ability to copy/paste colors (using a hex string starting with #).
- Added the ability to show/hide individual colors (right click on a color in the palette).

2024-04-01: v0.0.1 (release #okpal-1)

- Added the ability to lock colors, to avoid accidentally modifying them. By default the first 33 colors are locked (click on the padlock to unlock)
- Added the ability to hide specific rows of color from the two color pickers.
- Added sliders to change the individual components (hue, saturation and luminance).
- Added the ability to select a color by clicking on their dot in the color pickers.
- Added a test zone, with 24 paintable cubes (click on a cube face to change its color).


:: todo.txt
--[[pod_format="raw",created="2024-03-31 20:08:43",modified="2025-03-18 13:50:44",revision=1316]]
- Change: default_folder when sandboxed?
- Add: hold shift for fine-tuning colors.
- Add: on import, show number of colors.
- Add: setting for dragging sensibility.
- Add: "Ctrl-D" for duplicating current color.

Maybe:
- Add: new tab in test zone to show all hex codes
  and copy a ".hex" export to the clipboard?
- in-app gui for manual?
- multi-selection (ability to move a group of
  colors in the sliders)
- editing tools for multi-selection;
- Add another tab in the test zone for statistics?
- remove locking mechanism?
- import the palette from an image saved by
  the #paint cartridge;

:: .info.pod
b64$LS1bW3BvZCxhdXRob3I9ImRyYWttYW5pc28iLGJic19pZD0iX2Rldjk3MiIsY3JlYXRlZD0i
MjAyNC0wNC0yNyAxMjozMDo1NCIsaWNvbj11c2VyZGF0YSgidTgiLDE2LDE2LCIwMDAwMDAwMTAx
MDEwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDAw
MTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwNzAxMDAwMTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwZDBk
MDcwMTAxMDcwZDBkMDEwMTA2MDYwNzA3MDYwNjBkMGQwNzAxMDEwNzBkMGQwMTAxMDYwNjA3MDcw
NjA2MGQwZDA3MDEwMTA3MGQwZDA2MDYwZDBkMDEwMTA3MDcwZDBkMDcwMTAxMDcwZDBkMDYwNjBk
MGQwMTAxMDcwNzBkMGQwNzAxMDEwNzBkMGQwNzA3MDYwNjA3MDcwMTAxMGQwZDA3MDEwMTA3MGQw
ZDA3MDcwNjA2MDcwNzAxMDEwZDBkMDcwMTAxMDcwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwNzAx
MDEwNjA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwNzA2MDEwMTA2MDYwNzA3MDcwNzA3MDcwNzA3MDcw
NzA2MDYwMTAwMDEwNjA2MDYwNjA2MDYwNjA2MDYwNjA2MDYwMTAwMDAwMDAxMDYwNjA2MDYwNjA2
MDYwNjA2MDYwMTAwMDAwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAwMDAwMCIpLG1vZGlmaWVk
PSIyMDI1LTAzLTIzIDE2OjEyOjM5Iixub3Rlcz0iUGFsZXR0ZSBFZGl0b3Jcbih1c2UgbWVudSB0
byBvcGVuIHRoZSBtYW51YWwpIixydW50aW1lPTE2LHNhbmRib3g9ZmFsc2Usc3RvcmVkPSIyMDI0
LTA0LTE0IDEwOjMwOjA0Iix0aXRsZT0iT2tQQUwiLHZlcnNpb249IjEuMi4yIix3b3Jrc3BhY2Vz
PXt7bG9jYXRpb249Im1haW4ubHVhIzM5Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJz
cmMvZ2xvYmFscy5sdWEjMSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ic3JjL3NldHRp
bmdzLmx1YSMxIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJzcmMvZ3VpX3NldHRpbmdz
Lmx1YSM0OCIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ic3JjL2N1c3RvbV93cmFuZ2xl
Lmx1YSMxMjUiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImdmeC8wLmdmeCIsd29ya3Nw
YWNlX2luZGV4PTJ9fV1d
:: [eoc]
