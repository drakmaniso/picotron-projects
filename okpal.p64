picotron cartridge // www.picotron.net
version 2

:: gfx/
:: map/
:: sfx/
:: exports/
:: pal/
:: exports/lib/
:: exports/lib/oklab.lua
--[[pod_format="raw",created="2024-03-31 09:08:26",modified="2024-04-01 07:43:31",revision=211]]
-- Copyright(c) 2021 Bjorn Ottosson
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of
-- this software and associated documentation files(the "Software"), to deal in
-- the Software without restriction, including without limitation the rights to
-- use, copy, modify, merge, publish, distribute, sublicense, and /or sell copies
-- of the Software, and to permit persons to whom the Software is furnished to do
-- so, subject to the following conditions:
--
-- The above copyright noticeand this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

oklab = {}
oklab.__index = oklab

function oklab.color_to_okhsl(code)
	local srgb = {
		r = ((code & 0xff0000) >> 16) / 255,
		g = ((code & 0x00ff00) >> 8) / 255,
		b = ((code & 0x0000ff)) / 255,
	}
	return oklab.srgb_to_okhsl(srgb)
end

function oklab.okhsl_to_color(okhsl)
	local srgb = oklab.okhsl_to_srgb(okhsl)
	local r = mid(0x00, math.floor(srgb.r * 255 + 0.5), 0xff)
	local g = mid(math.floor(srgb.g * 255 + 0.5), 0xff)
	local b = mid(math.floor(srgb.b * 255 + 0.5), 0xff)
	return (r << 16) | (g << 8) | b
end

function oklab.new()
    local inst = setmetatable({}, oklab)
    return inst
end

-- Finds the maximum saturation possible for a given hue that fits in sRGB
-- Saturation here is defined as S = C/L
-- a and b must be normalized so a^2 + b^2 == 1
function oklab.compute_max_saturation(a, b)
    if a ~= 0.0 or b ~= 0.0 then
    	-- Max saturation will be when one of r, g or b goes below zero.
        -- Select different coefficients depending on which component goes below zero first

        -- Blue component (default)
        local k0 = 1.35733652
        local k1 = -0.00915799
        local k2 = -1.1513021
        local k3 = -0.50559606
        local k4 = 0.00692167
        local wl = -0.0041960863
        local wm = -0.7034186147
        local ws = 1.707614701

        if -1.88170328 * a - 0.80936493 * b > 1 then
            -- Red component
            k0 = 1.19086277
            k1 = 1.76576728
            k2 = 0.59662641
            k3 = 0.75515197
            k4 = 0.56771245
            wl = 4.0767416621
            wm = -3.3077115913
            ws = 0.2309699292
        elseif 1.81444104 * a - 1.19445276 * b > 1 then
            -- Green component
            k0 = 0.73956515
            k1 = -0.45954404
            k2 = 0.08285427
            k3 = 0.1254107
            k4 = 0.14503204
            wl = -1.2684380046
            wm = 2.6097574011
            ws = -0.3413193965
        end

        -- Approximate max saturation using a polynomial:
        local S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b

        -- Do one step Halley's method to get closer
        -- this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite
        -- this should be sufficient for most applications, otherwise do two/three steps

        local k_l = 0.3963377774 * a + 0.2158037573 * b
        local k_m = -0.1055613458 * a - 0.0638541728 * b
        local k_s = -0.0894841775 * a - 1.291485548 * b

        do
            local l_ = 1.0 + S * k_l
            local m_ = 1.0 + S * k_m
            local s_ = 1.0 + S * k_s

            local l = l_ * l_ * l_
            local m = m_ * m_ * m_
            local s = s_ * s_ * s_

            local l_dS = 3.0 * k_l * l_ * l_
            local m_dS = 3.0 * k_m * m_ * m_
            local s_dS = 3.0 * k_s * s_ * s_

            local l_dS2 = 6.0 * k_l * k_l * l_
            local m_dS2 = 6.0 * k_m * k_m * m_
            local s_dS2 = 6.0 * k_s * k_s * s_

            local f = wl * l + wm * m + ws * s
            local f1 = wl * l_dS + wm * m_dS + ws * s_dS
            local f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2

            local s_denom = f1 * f1 - 0.5 * f * f2
            if s_denom ~= 0.0 then  S = S - f * f1 / s_denom end
        end

        return S
    else
        return 0.0
    end
end

-- finds L_cusp and C_cusp for a given hue
-- a and b must be normalized so a^2 + b^2 == 1
function oklab.find_cusp(a, b)
	-- First, find the maximum saturation (saturation S = C/L)
    local S_cusp = oklab.compute_max_saturation(a, b)

    -- Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:
    local rgb_at_max = oklab.oklab_to_linear_srgb({L = 1, a = S_cusp * a, b = S_cusp * b })
    local max_comp = math.max(rgb_at_max.r, rgb_at_max.g, rgb_at_max.b)
    if max_comp ~= 0.0 then
        local L_cusp = (1.0 / max_comp) ^ 0.3333333333333333
        return { L = L_cusp, C = L_cusp * S_cusp }
    else
        return { L = 0.0, C = 0.0 }
    end
end

-- Finds intersection of the line defined by
-- L = L0 * (1 - t) + t * L1
-- C = t * C1
-- a and b must be normalized so a^2 + b^2 == 1
function oklab.find_gamut_intersection(a, b, L1, C1, L0, x)
    -- Find the cusp of the gamut triangle
    local cusp = x or oklab.find_cusp(a, b)

    -- Find the intersection for upper and lower half separately
    local t = 0.0
    if ((L1 - L0) * cusp.C - (cusp.L - L0) * C1) <= 0.0 then
        -- Lower half
        local t_denom = C1 * cusp.L + cusp.C * (L0 - L1)
        if t_denom ~= 0.0 then t = cusp.C * L0 / t_denom end
    else
        -- Upper half
        -- First intersect with triangle
        local t_denom = C1 * (cusp.L - 1.0) + cusp.C * (L0 - L1)
        if t_denom ~= 0.0 then t = cusp.C * (L0 - 1.0) / t_denom end

        -- Then one step Halley's method
        do
            local dL = L1 - L0
            local dC = C1

            local k_l = 0.3963377774 * a + 0.2158037573 * b
            local k_m = -0.1055613458 * a - 0.0638541728 * b
            local k_s = -0.0894841775 * a - 1.291485548 * b

            local l_dt = dL + dC * k_l
            local m_dt = dL + dC * k_m
            local s_dt = dL + dC * k_s

            -- If higher accuracy is required, 2 or 3 iterations of the following block can be used:
            do
                local L = L0 * (1.0 - t) + t * L1
				local C = t * C1

				local l_ = L + C * k_l
				local m_ = L + C * k_m
				local s_ = L + C * k_s

				local l = l_ * l_ * l_
				local m = m_ * m_ * m_
				local s = s_ * s_ * s_

				local ldt = 3.0 * l_dt * l_ * l_
				local mdt = 3.0 * m_dt * m_ * m_
				local sdt = 3.0 * s_dt * s_ * s_

				local ldt2 = 6.0 * l_dt * l_dt * l_
				local mdt2 = 6.0 * m_dt * m_dt * m_
				local sdt2 = 6.0 * s_dt * s_dt * s_

                local r0 = 4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s - 1
				local r1 = 4.0767416621 * ldt - 3.3077115913 * mdt + 0.2309699292 * sdt
				local r2 = 4.0767416621 * ldt2 - 3.3077115913 * mdt2 + 0.2309699292 * sdt2

                local r_denom = r1 * r1 - 0.5 * r0 * r2
                local u_r = 0.0
                if r_denom ~= 0.0 then u_r = r1 / r_denom end
				local t_r = -r0 * u_r

                local g0 = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s - 1
				local g1 = -1.2684380046 * ldt + 2.6097574011 * mdt - 0.3413193965 * sdt
				local g2 = -1.2684380046 * ldt2 + 2.6097574011 * mdt2 - 0.3413193965 * sdt2

                local g_denom = g1 * g1 - 0.5 * g0 * g2
                local u_g = 0.0
                if g_denom ~= 0.0 then u_g = g1 / g_denom end
				local t_g = -g0 * u_g

                local b0 = -0.0041960863 * l - 0.7034186147 * m + 1.707614701 * s - 1
				local b1 = -0.0041960863 * ldt - 0.7034186147 * mdt + 1.707614701 * sdt
				local b2 = -0.0041960863 * ldt2 - 0.7034186147 * mdt2 + 1.707614701 * sdt2

                local b_denom = (b1 * b1 - 0.5 * b0 * b2)
                local u_b = 0.0
                if b_denom ~= 0.0 then u_b = b1 / b_denom end
				local t_b = -b0 * u_b

                if u_r < 0.0 then t_r = 3.40282347e+38 end
                if u_g < 0.0 then t_g = 3.40282347e+38 end
                if u_b < 0.0 then t_b = 3.40282347e+38 end

                t = t + math.min(t_r, t_g, t_b)
            end
        end
    end

    return t
end

function oklab.get_Cs(L, a_, b_)
    local cusp = oklab.find_cusp(a_, b_)
    local C_max = oklab.find_gamut_intersection(a_, b_, L, 1.0, L, cusp)
    local ST_max = oklab.to_ST(cusp)

    -- Scale factor to compensate for the curved part of gamut shape:
    local k = 0.0
    local k_denom = math.min(L * ST_max.S, (1.0 - L) * ST_max.T)
    if k_denom ~= 0.0 then k = C_max / k_denom end

    local C_mid = 0.0
    do
        local ST_mid = oklab.get_ST_mid(a_, b_)

        -- Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.
        local C_a = L * ST_mid.S
        local C_b = (1.0 - L) * ST_mid.T

        local cae4 = C_a * C_a * C_a * C_a
        local cbe4 = C_b * C_b * C_b * C_b
        C_mid = 0.9 * k * ((1.0 / (1.0 / cae4 + 1.0 / cbe4)) ^ 0.25)
    end

    local C_0 = 0.0
    do
        -- for C_0, the shape is independent of hue, so ST are constant. Values picked to roughly be the average values of ST.
        local C_a = L * 0.4
        local C_b = (1.0 - L) * 0.8

        -- Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.
        local cae2 = C_a * C_a
        local cbe2 = C_b * C_b
        C_0 = math.sqrt(1.0 / (1.0 / cae2 + 1.0 / cbe2))
    end

    return { C_0 = C_0, C_mid = C_mid, C_max = C_max }
end

-- Returns a smooth approximation of the location of the cusp
-- This polynomial was created by an optimization process
-- It has been designed so that S_mid < S_max and T_mid < T_max
function oklab.get_ST_mid(a_, b_)
    local S = 0.11516993
    local s_denom = 7.4477897 + 4.1590124 * b_
        + a_ * (-2.19557347 + 1.75198401 * b_
        + a_ * (-2.13704948 - 10.02301043 * b_
        + a_ * (-4.24894561 + 5.38770819 * b_ + 4.69891013 * a_)))
    if s_denom ~= 0.0 then
        S = 0.11516993 + 1.0 / s_denom
    end

    local T = 0.11239642
    local t_denom = 1.6132032 - 0.68124379 * b_
        + a_ * (0.40370612 + 0.90148123 * b_
        + a_ * (-0.27087943 + 0.6122399 * b_
        + a_ * (0.00299215 - 0.45399568 * b_ - 0.14661872 * a_)))
	if t_denom ~= 0.0 then
        T = 0.11239642 + 1.0 / t_denom
    end

	return { S = S, T = T }
end

function oklab.linear_srgb_to_oklab(c)
    local l = 0.4122214708 * c.r
            + 0.5363325363 * c.g
            + 0.0514459929 * c.b
	local m = 0.2119034982 * c.r
            + 0.6806995451 * c.g
            + 0.1073969566 * c.b
	local s = 0.0883024619 * c.r
            + 0.2817188376 * c.g
            + 0.6299787005 * c.b

    local l_ = l ^ 0.3333333333333333
    local m_ = m ^ 0.3333333333333333
    local s_ = s ^ 0.3333333333333333

    return {
        L = 0.2104542553 * l_
          + 0.793617785 * m_
          - 0.0040720468 * s_,
        a = 1.9779984951 * l_
          - 2.428592205 * m_
          + 0.4505937099 * s_,
        b = 0.0259040371 * l_
          + 0.7827717662 * m_
          - 0.808675766 * s_ }
end

function oklab.okhsl_to_oklab(hsl)
	local l = hsl.l
    if l >= 1.0 then return { L = 1.0, a = 0.0, b = 0.0 } end
    if l <= 0.0 then return { L = 0.0, a = 0.0, b = 0.0 } end

    local s = hsl.s
    if s < 0.0 then s = 0.0 end
    if s > 1.0 then s = 1.0 end

    local h = hsl.h
    local h_rad = h * 6.283185307179586
    local a_ = math.cos(h_rad)
    local b_ = math.sin(h_rad)
    local L = oklab.toe_inv(l)

    local cs = oklab.get_Cs(L, a_, b_)
    local C_0 = cs.C_0
	local C_mid = cs.C_mid
	local C_max = cs.C_max

    local mid = 0.8
	local mid_inv = 1.25

    local C = 0.0
    local t = 0.0
    local k_0 = 0.0
    local k_1 = 0.0
    local k_2 = 0.0
    if s < mid then
        t = mid_inv * s

		k_1 = mid * C_0
        if C_mid ~= 0.0 then
		    k_2 = 1.0 - k_1 / C_mid
        end

        local k_denom = 1.0 - k_2 * t
		if k_denom ~= 0.0 then
            C = t * k_1 / k_denom
        end
    else
        local t_denom = 1.0 - mid
        if t_denom ~= 0.0 then
            t = (s - mid) / t_denom
        end

		k_0 = C_mid
        if C_0 ~= 0.0 then
		    k_1 = (1.0 - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0
        end

        local C_denom = C_max - C_mid
		k_2 = 1.0
        if C_denom ~= 0.0 then
            k_2 = 1.0 - k_1 / C_denom
        end

        local k_denom = 1.0 - k_2 * t
        if k_denom ~= 0.0 then
		    C = k_0 + t * k_1 / k_denom
        end
    end

    return {
        L = L,
        a = C * a_,
        b = C * b_ }
end

function oklab.okhsl_to_srgb(hsl)
    return oklab.oklab_to_srgb(oklab.okhsl_to_oklab(hsl))
end

function oklab.okhsv_to_oklab(hsv)
	local v = hsv.v
    if v <= 0.0 then return { L = 0.0, a = 0.0, b = 0.0 } end
    if v > 1.0 then v = 1.0 end

    local s = hsv.s
    if s < 0.0 then s = 0.0 end
    if s > 1.0 then s = 1.0 end

    local h = hsv.h
    local h_rad = h * 6.283185307179586
    local a_ = math.cos(h_rad)
    local b_ = math.sin(h_rad)

    local cusp = oklab.find_cusp(a_, b_)
	local ST_max = oklab.to_ST(cusp)
	local S_max = ST_max.S
	local T_max = ST_max.T
	local S_0 = 0.5
    local k = 1.0
    if S_max ~= 0.0 then
	    k = 1.0 - S_0 / S_max
    end

    -- first we compute L and V as if the gamut is a perfect triangle:

	-- L, C when v==1:
    local v_denom = S_0 + T_max - T_max * k * s
    local L_v = 1.0
    local C_v = 0.0
    if v_denom ~= 0.0 then
        L_v = 1.0 - s * S_0 / v_denom
	    C_v = s * T_max * S_0 / v_denom
    end

    local L = v * L_v
	local C = v * C_v

    --then we compensate for both toe and the curved top part of the triangle:
    local L_vt = oklab.toe_inv(L_v)
    local C_vt = 0.0
    if L_v ~= 0.0 then
        C_vt = C_v * L_vt / L_v
    end

    local L_new = oklab.toe_inv(L)
    if L ~= 0.0 then
        C = C * L_new / L
    end
    L = L_new

    local rgb_scale = oklab.oklab_to_linear_srgb({
        L = L_vt,
        a = a_ * C_vt,
        b = b_ * C_vt })
    local max_comp = math.max(
        rgb_scale.r,
        rgb_scale.g,
        rgb_scale.b, 0.0)
    local scale_L = 0.0
    if max_comp ~= 0.0 then
        scale_L = (1.0 / max_comp) ^ 0.3333333333333333
    end

	C = C * scale_L
    return {
        L = L * scale_L,
        a = C * a_,
        b = C * b_ }
end

function oklab.okhsv_to_srgb(hsv)
    return oklab.oklab_to_srgb(oklab.okhsv_to_oklab(hsv))
end

function oklab.oklab_to_linear_srgb(lab)
    local l_ = lab.L
        + 0.3963377774 * lab.a
        + 0.2158037573 * lab.b
	local m_ = lab.L
        - 0.1055613458 * lab.a
        - 0.0638541728 * lab.b
	local s_ = lab.L
        - 0.0894841775 * lab.a
        - 1.291485548 * lab.b

    local l = l_ * l_ * l_
    local m = m_ * m_ * m_
    local s = s_ * s_ * s_

    return {
        r = 4.0767416621 * l
          - 3.3077115913 * m
          + 0.2309699292 * s,
        g = -1.2684380046 * l
           + 2.6097574011 * m
           - 0.3413193965 * s,
        b = -0.0041960863 * l
           - 0.7034186147 * m
           + 1.707614701 * s }
end

function oklab.oklab_to_okhsl(lab)
    local L = lab.L
    if L >= 1.0 then return { h = 0.0, s = 0.0, l = 1.0 } end
    if L <= 0.0 then return { h = 0.0, s = 0.0, l = 0.0 } end

    local Csq = lab.a * lab.a + lab.b * lab.b
    if Csq > 0.0 then
        local C = math.sqrt(Csq)
        local a_ = lab.a / C
        local b_ = lab.b / C

        -- 1.0 / math.pi = 0.3183098861837907
        local h = 0.5 + 0.5 * math.atan(-lab.b, -lab.a) * 0.3183098861837907

        local cs = oklab.get_Cs(L, a_, b_)
        local C_0 = cs.C_0
        local C_mid = cs.C_mid
        local C_max = cs.C_max

        -- Inverse of the interpolation in okhsl_to_srgb:
        local mid = 0.8
        local mid_inv = 1.25

        local s = 0.0
        if C < C_mid then
            local k_1 = mid * C_0
            local k_2 = 1.0
            if C_mid ~= 0.0 then
                k_2 = (1.0 - k_1 / C_mid)
            end

            local t_denom = k_1 + k_2 * C
            local t = 0.0
            if t_denom ~= 0.0 then
                t = C / t_denom
            end

            s = t * mid
        else
            local k_0 = C_mid
            local k_1 = 0.0
            if C_0 ~= 0.0 then
                k_1 = (1.0 - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0
            end

            local C_denom = C_max - C_mid
            local k_2 = 1.0
            if C_denom ~= 0.0 then
                k_2 = 1.0 - k_1 / C_denom
            end

            local t_denom = k_1 + k_2 * (C - k_0)
            local t = 0.0
            if t_denom ~= 0.0 then
                t = (C - k_0) / t_denom
            end

            s = mid + (1.0 - mid) * t
        end

        return { h = h, s = s, l = oklab.toe(L) }
    else
        return { h = 0.0, s = 0.0, l = L }
    end
end

function oklab.oklab_to_okhsv(lab)
    local L = lab.L
    if L >= 1.0 then return { h = 0.0, s = 0.0, v = 1.0 } end
    if L <= 0.0 then return { h = 0.0, s = 0.0, v = 0.0 } end

    local Csq = lab.a * lab.a + lab.b * lab.b
    if Csq > 0.0 then
        local C = math.sqrt(Csq)
        local a_ = lab.a / C
        local b_ = lab.b / C

        -- 1.0 / math.pi = 0.3183098861837907
        local h = 0.5 + 0.5 * math.atan(-lab.b, -lab.a) * 0.3183098861837907

        local cusp = oklab.find_cusp(a_, b_)
        local ST_max = oklab.to_ST(cusp)
        local S_max = ST_max.S
        local T_max = ST_max.T
        local S_0 = 0.5
        local k = 1.0
        if S_max ~= 0.0 then
            k = 1.0 - S_0 / S_max
        end

        -- first we find L_v, C_v, L_vt and C_vt
        local t_denom = C + L * T_max
        local t = 0.0
        if t_denom ~= 0.0 then
            t = T_max / t_denom
        end
        local L_v = t * L
        local C_v = t * C

        local L_vt = oklab.toe_inv(L_v)
        local C_vt = 0.0
        if L_v ~= 0.0 then
            C_vt = C_v * L_vt / L_v
        end

        -- we can then use these to invert the step that compensates for the toe and the curved top part of the triangle:
        local rgb_scale = oklab.oklab_to_linear_srgb({
            L = L_vt,
            a = a_ * C_vt,
            b = b_ * C_vt })
        local scale_denom = math.max(
            rgb_scale.r,
            rgb_scale.g,
            rgb_scale.b, 0.0)
        local scale_L = 0.0
        if scale_denom ~= 0.0 then
            scale_L = (1.0 / scale_denom) ^ 0.3333333333333333
            L = L / scale_L
            C = C / scale_L
        end

        local toel = oklab.toe(L)
        C = C * toel / L
        L = toel

        -- we can now compute v and s:
        local v = 0.0
        if L_v ~= 0.0 then v = L / L_v end

        local s = 0.0
        local s_denom = ((T_max * S_0) + T_max * k * C_v)
        if s_denom ~= 0.0 then
            s = (S_0 + T_max) * C_v / s_denom
        end

        return { h = h, s = s, v = v }
    else
        return { h = 0.0, s = 0.0, v = L }
    end
end

function oklab.oklab_to_srgb(lab)
    local lrgb = oklab.oklab_to_linear_srgb(lab)
	return {
		r = oklab.srgb_transfer_function(lrgb.r),
		g = oklab.srgb_transfer_function(lrgb.g),
		b = oklab.srgb_transfer_function(lrgb.b) }
end

function oklab.srgb_to_okhsl(rgb)
    return oklab.oklab_to_okhsl(oklab.srgb_to_oklab(rgb))
end

function oklab.srgb_to_okhsv(rgb)
    return oklab.oklab_to_okhsv(oklab.srgb_to_oklab(rgb))
end

function oklab.srgb_to_oklab(srgb)
    return oklab.linear_srgb_to_oklab({
		r = oklab.srgb_transfer_function_inv(srgb.r),
		g = oklab.srgb_transfer_function_inv(srgb.g),
		b = oklab.srgb_transfer_function_inv(srgb.b) })
end

function oklab.srgb_transfer_function(a)
    if 0.0031308 >= a then
        return 12.92 * a
    else
        return 1.055 * (a ^ 0.4166666666666667) - 0.055
    end
end

function oklab.srgb_transfer_function_inv(a)
    if 0.04045 < a then
        return ((a + 0.055) * 0.9478672985781991) ^ 2.4
    else
        return a * 0.07739938080495357
    end
end

function oklab.to_ST(cusp)
	local L = cusp.L
    local C = cusp.C
    if L ~= 0.0 and L ~= 1.0 then
        return { S = C / L, T = C / (1.0 - L) }
    elseif L ~= 0.0 then
        return { S = C / L, T = 0.0 }
    elseif L ~= 1.0 then
        return { S = 0.0, T = C / (1.0 - L) }
    else
        return { S = 0.0, T = 0.0 }
    end
end

function oklab.toe(x)
    local y = 1.170873786407767 * x - 0.206
	return 0.5 * (y + math.sqrt(y * y + 0.14050485436893204 * x))
end

function oklab.toe_inv(x)
    local denom = 1.170873786407767 * (x + 0.03)
    if denom ~= 0.0 then
    	return (x * x + 0.206 * x) / denom
    else
        return 0.0
    end
end

return oklab
:: exports/lib/palette.lua
--[[pod_format="raw",created="2024-03-31 08:27:10",modified="2024-04-01 07:43:31",revision=713]]
function load_palette(filename)
	poke4(0x5000, get(fetch(filename)))
end


--[[
function fetch_palette(filename)
	local colors = split(fetch(filename):gsub("\r",""),"\n",true)
	local palette = {}
	for i = 1, #colors do
		palette[i - 1] = tonum("0x00" .. colors[i])
	end
	return palette
end
]]--


function set_color(c, code)
	poke4(0x5000 + 4 * c, code)
end


function get_color(c)
	return peek4(0x5000 + 4 * c)
end

function color_to_hex(c)
	return string.format("%06x", c)
end
:: exports/lib/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA4OjQyOjE5IixzdG9yZWQ9IjIwMjQtMDMt
MzEgMDg6NDI6MTkiXV1sejQABAAAAAMAAAAwbmls
:: exports/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA4OjQyOjE1IixzdG9yZWQ9IjIwMjQtMDMt
MzEgMDg6NDI6MTUiXV1sejQABAAAAAMAAAAwbmls
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA3Iixtb2RpZmllZD0iMjAyNC0w
NC0wMSAwNzo0MzozMSIscmV2aXNpb249ODM5XV1sejQAKAEAAKMxAADzFHtbMF09e2JtcD1weHUA
QyAQEATw8CxmbGFncz0wLHBhbl94CADHeT0wLHpvb209OH0sMQDxBQwMBPAALXANIA1gDaANkG1A
HSAdBAAxLQAtBAAvbeBPAAseNU8AYydwByAHYAQAYVBnQBcgFwQAMScAJwQAH2dTAB7-Eww3YFdA
dyAXABcABwAXEAcQNxAHIAcQFxAHQAcwB2A38AxSAB1gLQ1wDRAN_ACPUA1ADTANYD1EABv3AAsH
BBBnIIcAJw0HDQcNVwYAbycAhyBnEIQBGf8EBwsEECcgRwCHLactpy2HAEcgJ0AADw71AQ8xAP--
------------------------------------------------------------rlBtPTh9fQ==
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2IixzdG9yZWQ9IjIwMjQtMDMt
MzEgMDU6MzM6MDYiXV1sejQABAAAAAMAAAAwbmls
:: gui.lua
--[[pod_format="raw",created="2024-03-31 05:58:06",modified="2024-04-01 07:43:31",revision=1175]]
function generate_gui()
	gui = create_gui()
	local pal_el = create_palette{}
	gui:attach(pal_el)
	gui:attach(create_visibility_buttons { x = pal_el.x - 14, y = pal_el.y + 1 })
	gui:attach(create_color_preview { x = pal_el.x + pal_el.width + 8, y = pal_el.y })
	local hs_slider = create_hue_sat_slider{}
	gui:attach(hs_slider)
	local sl_slider = create_sat_lum_slider{}
	gui:attach(sl_slider)
	gui:attach(create_sat_slider { x = sl_slider.x, y = sl_slider.y + sl_slider.height + 2 })
	gui:attach(create_lum_slider { x = sl_slider.x + sl_slider.width + 2, y = sl_slider.y })
end


function create_palette(el)
	local size = 12
	local nb_columns = 16
	local nb_rows = 4
	el.width = (nb_columns * size) + 1
	el.height = (nb_rows * size) + 1
	el.x = (480 - el.width) \ 2 - 60
	el.y = 8
		
	function el:draw()
		clip()
		rectfill(0, 0, self.width, self.height, 0)
		for c = 0, 63 do
			local x = 1 + ((c % nb_columns) * size)
			local y = 1 + ((c \ nb_columns) * size)
			rectfill(x, y, x + size - 1, y + size - 1, c)
			if c == active_color then
				rect(x + 2, y + 2, x + size - 3, y + size - 3, 7)
			end
		end	
	end

	function el:drag(msg)
		local x = min(nb_columns - 1, (msg.mx - 1) \ size)
		local y = min(nb_rows - 1, (msg.my - 1) \ size)
		active_color = x + y * nb_columns
	end	

	return el
end


function create_visibility_buttons(el)
	local size = 12
	local nb_rows = 4
	el.width = size
	el.height = nb_rows * size
	
	function el:draw(msg)
		pal(13, 0)
		for row = 0, 3 do
			if hidden_rows[row] then
				spr(4, 0, row * size)
			else
				spr(3, 0, row * size)
			end
		end
		pal(13, 13)
	end
	
	function el:tap(msg)
		local row = mid(0, msg.my \ size, 3)
		hidden_rows[row] = not hidden_rows[row]
	end
	
	return el
end


function create_color_preview(el)
	local size = 12
	el.width = size * 4 + 2
	el.height = size * 4 + 2
	
	function el:draw(msg)
		if (not active_color) return
		rect(0, 0, self.width - 1, self.height - 1, 0)
		rectfill(1, 1, self.width - 2, self.height - 2, active_color)
		pal(13, 0)
		if locked[active_color] then
			spr(2, 0, self.height - size - 1)
		else
			spr(1, 0, self.height - size - 1)
		end
		pal(13, 13)
		print(tostr(active_color), self.width - 12, self.height - 10, 0)
	end
	
	function el:tap(msg)
		if (not active_color) return
		if msg.mx < size and msg.my >= self.height - size then
			locked[active_color] = not locked[active_color]
		end
	end
	
	return el
end


-- 2D Sliders -----------------------------------------------------------------------


local slider_size = 170
local slider_border = 6
local slider_inner = slider_size - 2 * slider_border


function create_hue_sat_slider(el)
	el.x = 240 - slider_size - 8
	el.y = 74
	el.width = slider_size
	el.height = slider_size
	el.drag_delta = nil
	
	function el:draw()
		clip()
		ovalfill(
			slider_border - 1, slider_border - 1,
			slider_border + slider_inner + 1, slider_border + slider_inner + 1,
			7
		)
		ovalfill(
			slider_border, slider_border,
			slider_border + slider_inner,
			slider_border + slider_inner,
			0
		)
		for c = 0, 63 do
			-- TODO: put nb_columns in global constant
			if not hidden_rows[c \ 16] then
				local x, y = hs_coords(c)
				ovalfill(x - 2, y - 2, x + 2, y + 2, c)
			end
		end
		if active_color then
			local x, y = hs_coords(active_color)
			if self.drag_delta then
				-- ovalfill(x - 6, y - 6, x + 6, y + 6, 7)
				ovalfill(x - 5, y - 5, x + 5, y + 5, active_color)
			else
				ovalfill(x - 6, y - 6, x + 6, y + 6, 7)
				ovalfill(x - 5, y - 5, x + 5, y + 5, active_color)
			end
		end
	end	

	function el:hover(msg)
		if active_color then
			local ax, ay = hs_coords(active_color)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx < 5 and dy < 5 then
				self.cursor = "grab"
			else
				self.cursor = false
			end
		end
	end
	
	function el:click(msg)
		if active_color then
			local ax, ay = hs_coords(active_color)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx < 5 and dy < 5 then
				self.drag_delta = { x = ax - msg.mx, y = ay - msg.my }
				return
			end
		end
		active_color = nil
		for c = 0, 63 do
			local cx, cy = hs_coords(c)
			local dx = abs(cx - msg.mx)
			local dy = abs(cy - msg.my)
			if dx < 3 and dy < 3 then
				active_color = c
				self.drag_delta = { x = cx - msg.mx, y = cy - msg.my }
				self.cursor = "grab"
				return
			end
		end
		self.drag_delta = nil
	end
	
	function el:release(msg)
		self.drag_delta = nil
	end
	
	function el:drag(msg)
		if active_color and self.drag_delta and not locked[active_color] then
			local ax = msg.mx + self.drag_delta.x
			local ay = msg.my + self.drag_delta.y
			local hue, sat = coords_hs(ax, ay)
			update_pal(active_color, hue, sat, nil)
		end
	end
		
	return el
end


function create_sat_lum_slider(el)
	el.x = 240 + 8
	el.y = 74
	el.width = slider_size
	el.height = slider_size
	el.drag_delta = nil
		
	function el:draw()
		clip()
		rectfill(
			slider_border - 1, slider_border - 1, 
			slider_border + slider_inner + 1, slider_border + slider_inner + 1, 
			7
		)
		rectfill(
			slider_border, slider_border, 
			slider_border + slider_inner, slider_border + slider_inner,
			0
		)
		for c = 0, 63 do
			if not hidden_rows[c \ 16] then
				local x, y = sl_coords(c)
				ovalfill(x - 2, y - 2, x + 2, y + 2, c)
			end
		end
		if active_color then
			local x, y = sl_coords(active_color)
			if self.drag_delta then
				-- ovalfill(x - 6, y - 6, x + 6, y + 6, 7)
				ovalfill(x - 5, y - 5, x + 5, y + 5, active_color)
			else
				ovalfill(x - 6, y - 6, x + 6, y + 6, 7)
				ovalfill(x - 5, y - 5, x + 5, y + 5, active_color)
			end
		end
	end	

	
	function el:hover(msg)
		if active_color then
			local ax, ay = sl_coords(active_color)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx < 6 and dy < 6 then
				self.cursor = "grab"
			else
				self.cursor = false
			end
		end
	end
	
	function el:click(msg)
		if active_color then
			local ax, ay = sl_coords(active_color)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx < 6 and dy < 6 then
				self.drag_delta = { x = ax - msg.mx, y = ay - msg.my }
				return
			end
		end
		active_color = nil
		for c = 0, 63 do
			local cx, cy = sl_coords(c)
			local dx = abs(cx - msg.mx)
			local dy = abs(cy - msg.my)
			if dx < 3 and dy < 3 then
				active_color = c
				self.drag_delta = { x = cx - msg.mx, y = cy - msg.my }
				self.cursor = "grab"
				return
			end
		end
		self.drag_delta = nil
	end
	
	function el:release(msg)
		self.drag_delta = nil
	end
	
	function el:drag(msg)
		if active_color and self.drag_delta and not locked[active_color] then
			local ax = msg.mx + self.drag_delta.x
			local ay = msg.my + self.drag_delta.y
			local sat, lum = coords_sl(ax, ay)
			update_pal(active_color, nil, sat, lum)
		end
	end
	
	return el
end


-- 1D Sliders ----------------------------------------------------------------------


function create_sat_slider(el)
	el.width = slider_size
	el.height = 7
	
	function el:draw()
		line(6, self.height \ 2, self.width - 6, self.height \ 2, 0)
		if active_color then
			local ax, _ = sl_coords(active_color)
			pal(13, 0)
			spr(5, ax - 5, 0)
			pal(13, 13)
		end
	end	
	
	function el:hover(msg)
		if active_color then
			local ax, _ = sl_coords(active_color)
			if msg.mx and msg.mx >= ax - 3 and msg.mx <= ax + 3 then
				self.cursor = "grab"
			else
				self.cursor = false
			end
		end
	end

	function el:click(msg)
		if active_color then
			local ax, _ = sl_coords(active_color)
			if msg.mx and msg.mx >= ax - 3 and msg.mx <= ax + 3 then
				self.drag_delta_x = ax - msg.mx
			end
		end
	end
	
	function el:release(msg)
		self.drag_delta_x = nil
	end
	
	function el:drag(msg)
		if active_color and self.drag_delta_x and not locked[active_color] then
			local ax = msg.mx + self.drag_delta_x
			local sat, lum = coords_sl(ax, 0)
			update_pal(active_color, nil, sat, nil)
		end
	end
		
	return el
end


function create_lum_slider(el)
	el.width = 7
	el.height = slider_size
	
	function el:draw()
		line(self.width \ 2, 6, self.width \ 2, self.height - 6, 0)
		if active_color then
			local _, ay = sl_coords(active_color)
			pal(13, 0)
			spr(6, 0, ay - 5, 0)
			pal(13, 13)
		end
	end	
	
	function el:hover(msg)
		if active_color then
			local _, ay = sl_coords(active_color)
			if msg.my and msg.my >= ay - 3 and msg.my <= ay + 3 then
				self.cursor = "grab"
			else
				self.cursor = false
			end
		end
	end

	function el:click(msg)
		if active_color then
			local _, ay = sl_coords(active_color)
			if msg.my and msg.my >= ay - 3 and msg.my <= ay + 3 then
				self.drag_delta_y = ay - msg.my
			end
		end
	end
	
	function el:release(msg)
		self.drag_delta_y = nil
	end
	
	function el:drag(msg)
		if active_color and self.drag_delta_y and not locked[active_color] then
			local ay = msg.my + self.drag_delta_y
			local sat, lum = coords_sl(0, ay)
			update_pal(active_color, nil, nil, lum)
		end
	end
		
	return el
end


-- Utility functions ----------------------------------------------------------------


function sl_coords(c)
	local sat = pal_okhsl[c].s
	local lum = pal_okhsl[c].l
	local x = slider_border + sat * slider_inner
	local y = slider_border + slider_inner - lum * slider_inner
	return x, y
end


function coords_sl(x, y)
	local sat = (x - slider_border) / slider_inner
	local lum = 1.0 - ((y - slider_border) / slider_inner)
	return sat, lum
end


function hs_coords(c)
	local hue = pal_okhsl[c].h
	local sat = mid(0.0, pal_okhsl[c].s, 1.0)
	local a = 0.25 - hue
	local dx = sat * cos(a) * (slider_inner / 2)
	local dy = sat * sin(a) * (slider_inner / 2)
	local x = slider_border + (slider_inner / 2) + dx
	local y = slider_border + (slider_inner / 2) + dy
	return x, y
end


function coords_hs(x, y)
	local dx = slider_border + (slider_inner / 2) - x
	local dy = slider_border + (slider_inner / 2) - y
	local hue = atan2(dx, - dy) - 0.25
	dx = (2.0 * dx) / slider_inner
	dy = (2.0 * dy) / slider_inner
	local sat = sqrt(dx * dx + dy * dy)
	return hue, sat
end
:: label.png
b64$iVBORw0KGgoAAAANSUhEUgAAAeAAAAEOCAIAAADe_FMwAAASE0lEQVR4Ae3dT4wcVX7A8VdF
5YLCjoQGyQhjyYcVdmAhitBosTEHc0BEDsUwDBVC7OokkxmtJtEi4Uxs7bIHI_TN4EiLIgt5NJG6
mFikPB47ZazsaR0JMAsOimD-yCAUsTJGcbLOShMrbJSw7hzebLmorq4-3dXVr159P2rB65k37a7f
q-721eisXxEAAPVYFf97b43NKDuLB9eX5WLllZdz-sneb3yTewjAkBid9SvR591tKrFBfdRZRrPo
H-b3V-IP89eZRgPd5CdIfi6i65TNsf35P1Y59_fPWq_Pf_b7WXnl5b3f_Kb8b9Ekyl4lsvKMoNDF
lBisB9eXwwsoVNu3xmZSrhlABXWWi5VXXi6arZypLfSa0c29KjyI-uosM5XSq3igY5ch-9U81zw8
iW89-GEY7vBS_ZAAqPILqdD3RyxZ6eKBDv8B_erpXzWJvy232g_uL-f6epHXKTd0Px3SNyR3JFBB
6fJ-KlV487G3kXItsZr1ilvPQEdLlHnxFUwnf23zfB0NeAA0GhjGhyv6scr-KQu35Q9R5itXXPzM
aiUEWl5DbGT5r7ayK5TXJgv_4PpyuBjS1zt1Bmqn6Ge21-6Kw90z0IUyNOw3-dbYTLTC0RBHfxjd
GSt4dE-FJw00kAzIyisvyzjIT016KGKfrKF_0HImK7otz-vJ-55llKKxSmxXyOisX6ns8ErMZbnx
jb5s0ftjVF_tAGoq2q6UOgshLA2uEABqJD3KUYbr2MwLABRkMgIAINAAAAINAAQaAECgAYBAAwAI
NACgF4sR1IjnBwwBA3Idexgv2146Fq5bs3Oxp_GecJ345-K3iX9LoKGJO__eytzzR-_b-TqH-vh6
5p7Vf-4sc8-Z37g9c8_f-NmBzD277t2a-abH-jR7z8rr2XsevStzi-E-Y5l7tr-7buaeP3j3bzP3
fNv4zez3PG1mv_f7nxrSXRetcGJbo9ntrnOY5tbsXPdLNVb2iQJAYlXzNzRMcPQn9DeTxQgADFLn
aHxjayFErMuxbXLRmp3rjnV30xvI5FYDUJRMZ-S-saTK7EbLG226XESjLDdT5xiLEQAoKlrbPDGV
G2IFZ4wEGkD5WrNzsra96izb3SvE8g9j7abaBBpAaY2OJbXXOs_G9KeNZTICACDQAAACDQD1ZzEC
AEW1l461ZudKfDUhRPiC0adyLXX-i7E-JNAAMJTWy0XsaazaKX9IoDF6m-edzNzz6SP-nbnnl-7n
mXtufe_NzD3v-uu1zD3-cd3M3POz82cy9_z69z2Ze94Sncw9297JnvPxR_-I3vQvY5lbdv7OLzP3
7PjPhzP3fPbce5l77vhK9nmVG1YhRCyR0UX423SJe7pznPMPCTQAxNMcy2uvcGe2PtwcbXSvP8--
NUCgUT_LK5OJP1-Ye5rhYBDRvGY2NBbx2OaUuOepP4FGjXW3uFe1gfzyR7bvvGrcZQINoMwct5eO
JT6VDU0pabg53Bl9mtLlzJ0EGkBDi9xrkfg056sVfapxmiWTWw0ACDQAgEADQP1ZjKDhFlcmGQIG
1F461pqdq-KfE0J0-4vy55L8bWxnrz8k0FDRwt7TDAE1-TJI-FaI-iS2M-0PCTQArUIZbaJ8Ggti
r9-KdTSU0Q2F-vUUdalwCsN1bG61uvD8gCFgQKV85KNtjT7tTnPib2P-7fU6KWnu-tvu74zu7ndv
UJzF-QqgdEULGKYzz5-3_m33V0Is9_HTuozR5E4CMNqCy4DGfjL4P1GjEPdicaMA6COvYf6iYU3f
3Gtn9NUyX7P71WTfo0WWTxN35nnD6jBcx_ZuqwvPDxgCBsRHvkZMRgAABBoAQKABgEADaKD20rH2
0rFC_0f1PvO856KXQ6ABqKs1OzfU-cOoc2t2rjU71x3ilF_NnMWtBmDADsr_yoXMnFyEPw8bHUYw
THae38Y25Ml99M3k_ZNwZ_xyRjtbk9sLQLnCOif2tDU7F0tnr6fyReQj_jQa0-6_S1J_rk6dhRAW
NxOAESoU2djm9IZGK5-e3NjPFamzEMLk-gBQupyBkynMX0O5OdyfEvdwW2adE99S0W_OIbG4kwD0
J8xresvkbxMTmf630d-G-qFofPO-2_jfhu8nfNnYaxZ68SExXMfmPqsLzw8YAgbER75GTEYAAAQa
AECgAYBAAwAINAAQaAAAgQYAEGgAINAAgDIYrmMzBQBQkMkIAIBAAwAINAAQaAAAgQYAAg0AINAA
AAINAAQaAECgAYBAAwAINACAQAMAgQYAEGgAINAAAAINAAQaAECgAQDpLEZQO_3pBblorS4yDUBj
huvYTKGOdc7Z6Bn-V3Kx7NzE9AACjTJ5fhB92jl5-kvn9_TO7j8JzzSsM43OHCx0ok3WLM5Sv2SE
rzMj9qRsa-vX5aLlmAwfINAQQogX--EP5eJbv-t3RaNsPLmzc-J8uO4v3K5jh3WWpabRgIL4WI6s
zrF1oUbLR_bOXeJs4rrotwKAkbAYQWVkFl_8pZ8o9y3a5fT35jo2Z4Ra66xfkYvW7JweV2RyqNWk
WdZZHYZ4PbZW8E0CfdRZCNFeOqbHRVmc61C73P3DzdemL9_yGq4VaXT3e3YdmxMECHRT0hxtdF0u
gUwDI2QygtK7ll5nLgcYBmNsU7huzc7pcVEW51piy-S_NNexOWXUotHa3KsEmjQXznT73i3yJ60f
XeL0oZTO1buEEEJ82JrfpsHlmJzogM1qSJ1DYZ1ja0CZOgshRPvohwS66XVmCACGx2IEpBmAmkxG
QJ0LMb71N9E131VQ6OYc-yhct_a3EWjq3NBGywczgYKNNsY-0qPOQgiLEyXNZQ3HdWxGAZTIZATU
mSkBBJruMCsABViMgOKUPjHXsZkDqtd574RctF46rscVGXyWSPOQKH5rcb661lmnRlucq8qf3u98
dUouDn28VscZ8vUPDMJkBOrXObZmkgCBps5gnqgN4-6nwnXrpeN6XJTFuVKTCqb68-mN9f6rNgNB
Id_7ulsunh0-l7PRrqPJbWZy-MrW_dDHa4nr2gnrLIQ4Ms5XIPqpc2zdEBZ3gJp11qDLQCEzn3wu
F8tbb2YakskIAKhT59iaQEN4fsAQhue2ozfW_6-aDAT5PTt_LnHdEBZ3AHWuttGB69Bo9NnodJ2T
5_Witbqox7Wb1JkPADPHyC1vvTlxnV9YZyFEe3pBj7FYlKKx9t_3XS6OfHCx4n_6-RfPyEXrpeOK
TOONN38oFw-teoBcjrzRkExG0PA6x9YV6Lx3orvUitQ5tgYI9Gh4fsDxA9owntwZrluri3pclEWd
kWj1iQm5mD51gWmgXo12HVuPKzKpczMd_eBi4jpW59i6nE-R-U8lrkfooV0PJK5RM5cnNh66sDhT
Gl09Rbrcq9Goa51-zfvrf3Ofu12DazKbdoieH3AncyLQXnuPDvdVswJNC3KaPnUhcc25AFWyGAEy
Gw3UwOYL4vKEXHb_SZO7t0GB9vyAe1jl03EdmzlgwEZ3VjaWrbM63E4NCjQA7Rl7hRBCmy97syHH
5vkB9y5nBBBoAEAJrCZcpOcHnHRdTsp1bOaA-nRe-HO5aP3oEoEGoI8fLH0iFw-Pbq11nYUQ7Xu3
6NFoU-vbzvMDPnucF3LWObYGgQYAJLD0vjzPDyr4VzrrV9I3GGObuNUKnZrr2MwBxfzXTvGV8zfW
4hKBxoaFvad7-WpxZZL5FPvCWxFCBEKI1lkyXZGHZ7f_YOmTcF3HSzD_6vc7f-n3ct362Wt6nAuB
hoJ13tDeE9DoKhtd6-e-fa3zW_GTCWfixOMaHIqp8Q3n_YFmV-To174uH9QEaAKdA61fnRPXAAh0
zXh_wOnWkbH3xrp11mYgyOnilBGuJ048rsdFWZwrlG206zAM9NPoCUeTr3aTQ62L7--4ncQ1AF1Z
Wl6V5wfaN7oJPD9wHZtPKRrLZAQAoCaLEZRicWWSIQAj9-N5_f9g-1Vbg8sxOdHBGWOb0h_MCKjC
mcnbHpm87ZFJIcSR8YBAq8jzdTgYcJooWudwKRtNoAEAw2IxAqB0r373oFzsO3CYaYzE-qu2Bldh
cpDAkOocW2O4rj2evCbQ6vD8gBuVM0VzGy0furA401F5YWFZLp5fnGEawKCeccVxTy7dM6cINEqo
s1wPo9GvfvegXOw7cJiBV2nfgcMMv3od8XvimZPh05ZjEmgoKgyEXJOJ6hvNEECgATTd5VtWhRCf
CXHHtVc1uzST0x2J5xdnEtcA_qiz9Nkt__Si5WhSNgI9ykbLxzBefN_Bw4lrQG_GeN0Qr2tzOZZO
Z_P5ATeoll32-MB1bM4UTWMyAmAkXlhYlg9GMYjN16YT1wQaanEdWz4YRS3qnLhGf42WD-0ujUDr
U_fENQACDQAomcUI6uKNN38oFw-teoBp1N3zizMvLCyHawYCAq1DneW6u9GeH7iOHa6ZWC0azRBA
oHXTXWe6DGjJZAT53Xn3lHwwCgAEWq06J66r8dCuBzgCIMPhyY2HLizOtC5oNNSx_sSEXEyfuqBQ
nX-N_23Tff_6BnM2udUA9Ffn2BoEemQ_-ela4hoAhsRiBP01GoBaDp4Whyfl0n3-OoEG0ETTpy6s
PjERrtV5Y28e-D_5WHZuItAAaqOzfiV9gzG2qVCjVbvAN8WecD3j-0qPRhNooCkW9p7u9avFlUnm
oyBTp4txHZsT1RInCwINAHW1S5wN18vOTXpclMW5AtCs0a6w9bgik0MFAAINAAk27zspH4yCQHM3
AGp9HhPXaGKguRsA1IWl2fW4ju35Aeeqgc7Vu_SiNb_NaYBAA8rVWQjRPvrhyBvtOrZc1Prrf3Fl
UsF3dfnVJzfvOxmuufkbHWjuBvRdZ7muaaONsU0qfyq5zQg0dwOAOjH1uyTXsTnXujPGPwrXrflt
DAQEGlCr0cb4RyrU2fODxDUwbBYjAAo1GqiMyQgAgEBXx3VsjpZzBOrOYgQABvGdr07JxaGP15hG
uUxGAGDwOsfWINBpXMfmdDlBKOjWqaflg1E0N9AASrT-vu3yMXidE9doXKBdx_aAOTuUUufEtRDi
0MdriWuUwmIEAAZBl4fHZAQAKvOLtdcS10hkuI6t9xV6fsAx10s19yQ3RiH779suF0c_uMgtVBmL
Ow9Aplp0WT_m9le4fa0jHxx2LbiOzRCARgT6wlP-EC015w2AQAP9cB2bIQAEGgAI9EhNnHg8XF_c
MjhvlbmOzRCABgVaNlo_OGwo7tGvfV0_GAWaEuiQ69icN6ejcp0T1yDQAAACPVKuY3PknAtAoGkB
OJECvv-jdxLXaDKLEQAKNhoQQpgNvGbXsTl4zgJRd949JR_MgkDTBXAKatU5cY38zv3EGsbLDuVF
61IHzw_4scr1vau75eLZ8XPUGc2p86W3j27ZMb-7ni-KfWWT4aL0OsfWQBNcevvouZ9YBLo0rmNz
VzF5fPrTtcQ1Rt7okntfx1J4fsCNRZ1pNEMoq9FbdszvvueLUl7NZKD0oizPjp9LXDNtNMSWHfMl
1lkIYTFTWQ3PD5hDuY2mzmiI3fd8sWXHvBDi0ttH5YJAA4BCjRZCtGbndt9T5suaTFZyHZshMGFA
KQS6tILMfPK5fDBJ6gwQaIU6Eu1yd6NvnXpaPpgqAAKtUE2iXW5go6kzQKBpCpMECDRlSbK89ebE
NTME0DeDT1E6zw8Gf5Fbp56Wi1_svUaadTpZcAcOlcVZZp704J-khnRZs88GMHImI6A4A7k8sfFg
VgCBptFq1TmyZkoAgR5ZowkQAAKtdKYZAgACTaMVc2Zy4xHafOHGWJ67nXsDKJfFCPputOcHzapz
dP3Y6Y0vque4HYBhMRnBgJnm2gEQaEU7RaoAEGgyXYnDkxuPmMdO37je49c5dKACFiMoMdNCCM8P
6l3n6PrgRpQ3vn7oMkCgybRqlwNgJExGMKSuaZA26gyMlsUIKgic5wf1eMcHT4vDkxtv-v3rnCBA
oJtS6p6ZPu5tLJ5xR-91QpcBAt3YTMdLHdZZritvdPiuABBofKmJkTwT5ep86TsSINBQ51uBOjME
EGjk6OaZU95jT4Rr0ZXRPmpCiwECjdIaTW1HOX8mDFWZjABNLjJ1hsoMblAAUJPJCACAQAMACDQA
EGgAAIEGAAINACDQAAACDQAEGgBAoAGAQAMACDQAgEADAIEGABBoACDQAAACDQBN9P9Q75kcBzbv
VAAAABB0RVh0TG9kZVBORwAyMDExMDIyMeNZtsEAAAAASUVORK5CYII=
:: main.lua
--[[pod_format="raw",created="2024-03-31 05:33:06",modified="2024-04-01 07:43:31",revision=1002]]
include "exports/lib/oklab.lua"
include "exports/lib/palette.lua"
include "gui.lua"


active_color = nil
pal_okhsl = {}
pal_code = {}


function _init()	
	window {
		tabbed = true,
		icon = --[[pod,pod_type="image"]]unpod("b64:bHo0ACQAAAAiAAAA8BNweHUAQyAICARAF0AHEAcAJyAXMAcAF1AXUAcABzAHIDcQ")
	}

	mkdir("/ram/cart/pal")
	wrangle_working_file(
		save_working_file,
		load_working_file,
		"/ram/cart/pal/0.pal" -- default
	)

	hidden_rows = {
		[0] = false,
		[1] = false,
		[2] = false,
		[3] = false,
	}
	locked = {}
	for c = 0, 63 do
		locked[c] = c < 33
	end
	
	rebuild_pal()
	generate_gui()
end


function _draw()
	cls(5)
	if active_color then
		local c = get_color(active_color)
		print("#" .. color_to_hex(c), 340, 13, 7)
		local okhsl = oklab.color_to_okhsl(c)
		print("hue: " .. string.format("%0.1f", okhsl.h * 360.0) .. "")
		print("chroma: " .. string.format("%0.3f", okhsl.s))
		print("luminance: " .. string.format("%0.1f", okhsl.l * 100.0) .. "%")
		--	print(color_to_hex(oklab.okhsl_to_color({h = 0, s = 0.5, l = 0.9})))
	end
	gui:draw_all()
end


function _update()
	gui:update_all()
end


on_event("drop_items",function(msg)
	for i = 1, #msg.items do
		local item = msg.items[i]
		if item.pod_type == "file_reference" and item.attrib== "file" then
			send_message(pid(), {event = "open_file", filename = item.fullpath})
		end
	end
end)


function rebuild_pal()
	for c = 0, 63 do
		pal_code[c] = get_color(c)
		pal_okhsl[c] = oklab.color_to_okhsl(pal_code[c])
	end
end


function update_pal(c, hue, sat, lum)
	local hsl = {
		h = hue or pal_okhsl[c].h,
		s = sat or pal_okhsl[c].s,
		l = lum or pal_okhsl[c].l,
	}
	hsl.h = mid(-1.0, hsl.h, 1.0)
	hsl.s = mid(0.0, hsl.s, 1.0)
	hsl.l = mid(0.0, hsl.l, 1.0)
	local code = oklab.okhsl_to_color(hsl)
	pal_code[c] = code
	pal_okhsl[c] = hsl
	set_color(c, code)
end


function save_working_file()
	local output = userdata("i32", 64)
	for c = 0, 63 do
		output:set(c, get_color(c))
	end
--	local output = ""
--	for c = 0, 63 do
--		output ..= color_to_hex(get_color(c)) .. "\n"
--	end
	return output
end


function load_working_file(item)
	if type(item) == "userdata" then
		for c = 0, 63 do
			if item[c] then
				set_color(c, item:get(c))
			end
		end
	elseif type(item) == "string" then
		-- TODO: remove support for ".hex" files?
		local colors = split(item:gsub("\r",""),"\n",true)
		for c = 0, 63 do
			if colors[c + 1] then
				set_color(c, colors[c + 1])
			else
				set_color(c, 0xff00ee)
			end
		end	
	elseif item then
		notify("load_working_file: unkown type: " .. type(item))
	end
	rebuild_pal()
end
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Iixtb2RpZmllZD0iMjAyNC0w
NC0wMSAwNzo0MzozMSIscmV2aXNpb249Nzk5XV1sejQAaAAAAFgQAADwCHt7Ym1wPXVzZXJkYXRh
KCJpMTYiLDMyAwAvIjABAP--------------------vxCCIpLGhpZGRlbj1mYWxzZSxwYW5feD0w
CADSeT0wLHRpbGVfaD0xNgoAEHcKAIB6b29tPTF9fQ==
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2IixzdG9yZWQ9IjIwMjQtMDMt
MzEgMDU6MzM6MDYiXV1sejQABAAAAAMAAAAwbmls
:: pal/0.pal
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDE5OjQ3OjQ2Iixtb2RpZmllZD0iMjAyNC0w
NC0wMSAwNzo0MzozMSIscmV2aXNpb249MjUzXV1sejQAcgEAABUCAAD1BXVzZXJkYXRhKCJpMzIi
LDY0LCIwAQDAMWQyYjUzMDA3ZTI1CADwFzAwODc1MTAwYWI1MjM2MDA1ZjU3NGYwMGMyYzNjNzAw
ZmZmMWU4CABAMDA0ZAgAEWE2AGBmZmVjMjcKACBlNDgAQDI5YWQkAGA4Mzc2OWMgADE3N2E4AMBj
Y2FhMDAxYzVlYWMwAPAdYTVhMTAwNzU0ZTk3MDAxMjUzNTkwMDc0MmYyOTAwNDkyZDM4MDBhMjg4
NzlAAPADYWNjNTAwYzMwMDRjMDBlYjZiRgBgOTBlYzQyCgAgYjLAAKA2NGRmZjYwMGJkiQAAlgBA
MGRhYkAAVTg1NmQwAQDwBjg3YTQ4YzAwYjZhZDgwMDBjYzljNvAAMGY3MUgA-QBiNjNlNWIwMDcz
MjQ2NzABAP8QMzA1MjZhMDAzNTY0N2UwMDQxN2Q5OTAwNTM5NmIxMAEATv8AYTg5ZWY4MDBkZTRj
NjUwAQARUDAwMCIp
:: pal/1.pal
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDIwOjM3OjEzIixtb2RpZmllZD0iMjAyNC0w
NC0wMSAwNDozNTozMiIscmV2aXNpb249Nl1dbHo0ADsBAAAVAgAA9QV1c2VyZGF0YSgiaTMyIiw2
NCwiMAEAwDFkMmI1MzAwN2UyNQgA8BcwMDg3NTEwMGFiNTIzNjAwNWY1NzRmMDBjMmMzYzcwMGZm
ZjFlOAgAQDAwNGQIABFhNgBgZmZlYzI3CgAgZTQ4AEAyOWFkJABgODM3NjljIAAxNzdhOADAY2Nh
YTAwMWM1ZWFjMADwHWE1YTEwMDc1NGU5NzAwMTI1MzU5MDA3NDJmMjkwMDQ5MmQzODAwYTI4ODc5
QADwA2FjYzUwMGMzMDA0YzAwZWI2YkYAYDkwZWM0MgoAIGIywACgNjRkZmY2MDBiZIkAAJYAQDBk
YWJAAFU4NTZkMAEA8A80YTY5OGEwMDRmODE5MTAwNTg5NzhiMDA3YmE2NjhOAN9hMzU2MDBkYjk2
NTIwAQCxUDAwMCIp
:: pal/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDE5OjQ3OjQ2IixzdG9yZWQ9IjIwMjQtMDMt
MzEgMTk6NDc6NDYiXV1sejQABAAAAAMAAAAwbmls
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA3Iixtb2RpZmllZD0iMjAyNC0w
NC0wMSAwNzo0MzozMSIscmV2aXNpb249Nzg2XV1sejQAEAEAAFEHAADwJ3B4dQADKAAAAwAED0AQ
Ag4AAaABIAKgDgAPEAAN8MoBAgMEBQYHAA--kAgJCgsPDA8NDw4PDxAA8AANDxEPEg8TDxQPFQ8W
DxcTAPEBDxgPGQ8aDxsPHA8dDx4PHxQA8QAgDyEPIg8jDyQPJQ8mDycUAPEAKA8pDyoPKw8sDy0P
Lg8vFADxADAPMQ8yDzMPNA81DzYPNxQA-wU4DzkPOg87DzwPPQ8_Dz8AD--w-wEA6-8nWgEQBg8g
EAEgASAB8AACEAIMEAEgDyEgATAPQPDDDygP--DGD-gKD-8PgA-3Dw0B8AkBEAYMMAD-OR--AQDc
v-gPQAANQP--sPBwCgD--2Qf-wEAl1D-----Hw==
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2IixzdG9yZWQ9IjIwMjQtMDMt
MzEgMDU6MzM6MDYiXV1sejQABAAAAAMAAAAwbmls
:: todo.txt
--[[pod_format="raw",created="2024-03-31 20:08:43",modified="2024-04-01 07:43:31",revision=109]]
- import ".hex" files;
- import the palette from an image saved by
  the #paint cartridge;
- accept drag-and-drop (or copy/pasting) of gfx;
- add a test zone with shaded cubes;
- add a logo (when no color is selected);

Maybe:
- multi-selection (ability to move a group of
  colors in the sliders)
- reorder colors by drag-and-drop (while respecting
  locked colors)

:: .info.pod
b64$LS1bW3BvZCxhdXRob3I9ImRyYWttYW5pc28iLGljb249dXNlcmRhdGEoInU4IiwxNiwxNiwi
MDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDcw
NzAxMDAwMDAwMDEwNzBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwMTAwMDEwNzBkMGQwZDBkMGQwZDBk
MGQwZDBkMGQwZDA3MDEwMTA3MGQwZDAxMDEwNjA2MDcwNzA2MDYwZDBkMDcwMTAxMDcwZDBkMDEw
MTA2MDYwNzA3MDYwNjBkMGQwNzAxMDEwNzBkMGQwNjA2MGQwZDAxMDEwNzA3MGQwZDA3MDEwMTA3
MGQwZDA2MDYwZDBkMDEwMTA3MDcwZDBkMDcwMTAxMDcwZDBkMDcwNzA2MDYwNzA3MDEwMTBkMGQw
NzAxMDEwNzBkMGQwNzA3MDYwNjA3MDcwMTAxMGQwZDA3MDEwMTA3MGQwZDBkMGQwZDBkMGQwZDBk
MGQwZDBkMDcwMTAxMDYwNzBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwNjAxMDEwNjA2MDcwNzA3MDcw
NzA3MDcwNzA3MDcwNjA2MDEwMDAxMDYwNjA2MDYwNjA2MDYwNjA2MDYwNjA2MDEwMDAwMDAwMTA2
MDYwNjA2MDYwNjA2MDYwNjA2MDEwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAi
KSxub3Rlcz0iIixydW50aW1lPTUsc3RvcmVkPSIyMDI0LTA0LTAxIDA3OjQzOjMxIix0aXRsZT0i
T2tQQUwiLHZlcnNpb249IjAuMC4xIix3b3Jrc3BhY2VzPXt7bG9jYXRpb249Im1haW4ubHVhIzQ0
Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJndWkubHVhIzEyIix3b3Jrc3BhY2VfaW5k
ZXg9MX0se2xvY2F0aW9uPSJleHBvcnRzL2xpYi9wYWxldHRlLmx1YSMyIix3b3Jrc3BhY2VfaW5k
ZXg9MX0se2xvY2F0aW9uPSJleHBvcnRzL2xpYi9va2xhYi5sdWEjMzciLHdvcmtzcGFjZV9pbmRl
eD0xfSx7bG9jYXRpb249ImdmeC8wLmdmeCIsd29ya3NwYWNlX2luZGV4PTJ9LHtsb2NhdGlvbj0i
bWFwLzAubWFwIix3b3Jrc3BhY2VfaW5kZXg9M30se2xvY2F0aW9uPSJzZngvMC5zZngiLHdvcmtz
cGFjZV9pbmRleD00fSx7bG9jYXRpb249InBhbC8wLnBhbCIsd29ya3NwYWNlX2luZGV4PTd9fV1d
bHo0AAQAAAADAAAAMG5pbA==
:: [eoc]
