picotron cartridge // www.picotron.net
version 2

:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA3Iixtb2RpZmllZD0iMjAyNS0w
My0yMiAwODoyMzozMyIscmV2aXNpb249ODYzNV1dbHo0ACJDAACaoQAA9iN7WzBdPXtibXA9cHh1
AEMgCAgEcLcgRyAXIEcgt3AsZmxhZ3M9MCxwYW5feD0tMS44MwEAETcXABB5FwAnNDICAKcsem9v
bT0xMX0sWQDxCAwMBDAncAcgB2AHoAegB5BnQGdAJwAnBAA7Z-ALagBGNi4xNgEAFDNpADcwLjMB
ACIyN2oAHDdpACPwDGoAPyAHUGgAS-8SN2BXQHcgFwAXAAcAFxAHEDcQByAHEBcQB0AHMAdgN-AM
cAA3nw0JBACnEAeNBwQABi_nAG4AN-EGCQkEMAdgBw0HQActByAHTQcAB20XAgA-BwBnaAA78AMA
NzAHMAcgB0AHEAdQBwAHYBcGAAAOAF8wBzA3MGwAOikQR8wAAM4AbwdNByBHEGYAN-8KGBgE8Cja
gNoPGXDaHmDaLlDaPkDaTjDZXgMABPsCTkDZPlDZLmDZHnDZDoDZ8CiLABMwfQASMG0ADVYD-wjw
GwewB7AHUGcwBwBHQAcQJ1AHIAfwDEYACx84RgAFAbkCEgCOAQ9KACCjCwsE0E5AbiCOEAIAXCBu
QE7QQgBELjEyNUYAAQwAAUoALDEwSwDjIEdAB04HIAduBwAHjhcCAM8HAAduByAHTgdARyBZAHtU
QEAE8P8BANG-B-AuJ-AsR-AtB-AvAwAaMAkAFTADAPIGF1AH8CknIBfwK1fwLRfwLgfwWwcAAgBT
J-AlBwACADHwJycJAFUX8CYHABQAUAcABxAXKAAPswATHzOyAAEQs1UAEixRAG4sFwAH8GsRAEIg
B-ArEQDRK0fwbDfwKwfwL0fwawYAQSsH8G-pABAtEgBAEBfwKy8AIyw3NwASRxAAEW-3AE0rR-Dt
GwGSLwdAB1AXACcA4gASJwIAgBAXABfQB0AXHQR1AAcQBxAHAAIAAWgFAxAAMMCHIC4AAhAAOBcQ
JxwAIfADTgQPPwAJYvADB0AXEBUAJRcAIQAxECcAFgAfoFkBIfAOEBAEELcgB7AHAAfQF9AXUEcg
F0AnEBcQFzAnMAcGAJFgFxBnQBcgR1AMAP8AQAdwF9AX0AcAB7AHILcQcgATHzFyAADxBNcA9xdA
lyAXEHcgNwB3IKdgl0AVAD8ZANdYACglBwACAJEwB7AH8AAX8AYOADEgF0AtBBFwtwURQPAAAAIA
MUAXIAgAE7AYAEDwCBfwDgAAWwQFYgEP5gAnBVgBAEABQBAXECfAAbEwJzAXYCcwF0BnEHABAAwA
P3AHQFgBNrYUQJcQFyCHADcgx1gBHxZYAT0RAw4AMVAXEPQCALoAAMYAEbAWAADqAwLNAhOwGAAv
8AVYATSDBTME8B0HABdFABAXgAcKDgABGwPhV1BHMEdABzBXgEcQBxBuBv8BIAcAN0AHIGcgB4AH
MFfwEy4DIQB_ABAKWgA2NwAHUAABaAAgVwBoAAAbBAAIAEZHMEdQFgAJogAPegAjCVACQVAXUBfM
CfMBFyAXIHcgFzBXMBcQNxA3EAYAABAAABgABCQAADAAD1wCMzAHEKegBHEQd3CHUHcwaQBhMHdQ
h3B3FgBPpxD3B2gCKS-w8GsDLgH7ADAnECf9APMCMBcgF4AXIBdwFzAXYBdAF1ACAB-QEQE4MAVQ
h4QBYRA3ENcQxwIAT9cQ9w4IAWIAnQIf71wCITILBQSeAjUHADedAwPDByYAB2kGAsEHD2IAExk2
YgCgGQsEEPcFIAfwBccGEAeZAhAHCwcAnQIAQQQAAgAEOQQBEAAvFxAcAAIWIHsHARAAIPAHUABv
BQcg9wUQCgkiA5kAkPcHAPcNEAcAJ20ARxBnACdnABJX4gcNGAAnZxCbAF8A9wwA94cAJ-QFVAwE
UPcHQPcI8A-3CSAH8AgH8A4JALIN9wsAB-AKB-AMR4gFAR8BYzcABzAnAEMBVSAH8AtHmQAAlwgi
Z0AKABQHFgBDUAfwCiMAAN4HMCBHQGMBA4gIQDAH8AnnABMHAgA4RwBXqQUAVgUAGwcTZ50BIAcQ
wwsHAgAQIBkKggf3EfAMB-AGBwA7BfdECgFmLTcuMzc1oQwuNDfGAgoLAZQH8AcHIPcK8A4JAEAN
B-AJawFC8AwHMJoCA5sBMgBHIJkAdicQN-ALBzCYAQBaDxJXCgAUABYANGfwCiMAAZUHITBXRAAB
GwFkIEfwCQdAKgAB_wAVMEAABB0BIPAI_QYCjAIqF0AfAMInEGfwBwfwDPcR8AYHAA8LASbwAyIP
BPAU9w4gB_D3AAAH8AD3AgQA8QMQpyA3IBdANxCnICdAB0A38AAHAAQPAAQfAAMvACABAD4AXyD3
DvAUmgITHziDAAJy9wDgBwD3AVUA8QM3oCcwJxBHEDegJyBHAEcQ9wIHAAQPAAQfACL3Ai8AIAcA
PgAPgwAmX1QMBPAKHQMGkHcgJ2BXAAdQx6oBIPAMowMQF6MBAPICEaC-AVHwC2cAR7gBEGfSEQIL
Aw4TACMJdxMAEnc5AFNgB-AIh04ABhMAtAenICdgh0DHAAdw6wID_AEr9z7dAPMAMTcuNDQ2NDI4
NTcxNDI55wDALTQuNjQ4ODA5NTIzBgAOLgUK8gAPBAMAMGAnIN8DkWfABwBX8AwHUCIMAKIDQABn
AKexBCHwCx8PAP0AQ1B3AKfyAg0TADoJB2ATAFN38AgHcE4ABRMAMAcHkHAAU4fABwCH0gIP8gA-
D6MSIg9bBRMAWwBPI1cwl1EAOnEtB3AHECcwVAofAE8ANAF7AR9QTQAqlyhqAQAACQAAAN8PT---
-7aZABUPiAgmDoYAEAWGABEAJQURwCcFJIAXrgZDACfwEpoGEyDIBRKwHQByJwAX8BYXAB0AERdH
EAGzBSEnoAYAExA2CCOgJyMAACAARCfwAifeBRPgCAAAqwMbAAIAQyAH8BQJABIgVgAAMw8lByAU
ABAAIQACDwACAgADvhACEwAQwB4GA4oPESAFDRsAAgA1IAfwRwlAJwAX0FsGBIoABGwHUQcgF-AT
rw8JhAAjFxAtACLwFBcJAX4AIhcQJAAoF7B8AGUXIAewJwBVAEEgF-ADOwAAKwAPAAEJAAIAI-AW
7AABfAACVgEjBwAUAAF_ABNAEQAM-gAEtRAD-AACFgAEOgAC_AAAwwAiJ8D_AAA2ECYHAAIAECf0
ASInAAIAKRcQwgFSAAfwFRcJAAJ4AAHUBzIAJ7DZEAAOACQHsPAHAR8BIPACCwALmwI3MTMxnQJH
Mi4yMAIYAqcCGTTgAlMvBQQQFwIABagAAxAAJBcgCAAlBwAqEAISABMACAASMLIAHBcYAA4yABcg
ZgAmEBdkAA8rChUMGxY3l2AXAgAfl0YAFB80RwAAPQBHAAQAD1EAJwCACBEgkRUhAAebAAAEAQIS
AC8nIFUALQMhAgapAAJAAg9fAB0P4gQnDzoAqCEfHxAGH7Q9ABMfNzwA-2MPGAIaDzoA--------
-------------------------------------------------zB8KOABAAAOAQAzBQEA8CKUJ-D-
xTcgh-D-vncAAZcB8P_7lwEnIUcR8P_3VzEnAQcBlwEH8P_ztwEHAQcBNyFHDgCAsdcBBwF3ETcM
AICv1wEHEZcRJwwAQa03EXcoACG3ARAAYqs3ATeR1wwA8AepNwEnEdchdwEnAfD-qDcBJwH3AyGH
GgDwCqcnARcRhwHHEXcB8P_mJwEXAbcRdwE3AWcPAKEXARcB5wFnAUcRegAQpJIA8BVXEYcBZwFX
AUcB8P_kFwEHAUcRtwFnMScBNwHw-6MnEUcBhxFUADCnATcQAFABVwF3AUgAUQcB1wEnEgBg5wFX
AfcADQDwBqEnATcRRwEnAWcB9wTw-6EXATcBF7IAUAEXAWcB0ABxV-D-oAcBR0IAQCcBhwGhADl3
AUcWADAnYVd0AFHw-6ABdyEAMScRBwkBUFcBVwFnFwARV5IAIgchFwBhBwEnIVcB0gAhoFdGAAIW
ACFHASIAEBEsAXAn8P9up-AWawES5x0A8AchFwEX8P9q9wPwEicRVyEHAfcDEacBwzICIADxAPD-
N-cH8BAXAXcRBwH3BroBERIbAEC38P80MjcArADBNwH3CgE3MSfwDwEH9ABhL-cN8A0XtwBg9wxR
V-AOGACAB-D-LPcP8AwbASH3DUUAAFo3ABsA8AIK8P8p9xHwClcBFwE3IfcDIe0AMUfwCx0AkQzw
-yf3E-AJFxoBMAcRB0AAQAEBJyELADE38AolAJEO8P8l9xTwCScPAWAXAVcR1wHzAFEHERfwCSIA
gBDw-yP3FvAIigEhISciATGnEVcjAADlOAAjAFAR8P8i9_88IAE3mgIhAUeeAVAXAUcBN30BIfAH
JgBQE-D-IAEnAAGPAAAdAAFaAgF2AAHnAUEHAfAGKgChFfD-HgH3GfAGN4EBAkcAEydbAABjADAH
8AYoAIIX8P8d9xrwBj0ABR0AEgG4AQGkAARTALMW8P8cBwH3GvAFN3wAE0cYAgAOAAFiACDwBQ0A
w-cY8P8aBwH3G-AFJ34AE0coABUHtgBRBwHwBQFPAHT-GQH3HfAFnQAhVyEnACIRR4wAA1MAwBrw
-xcB9wRB9wXwBYoBAEYBIlcBBwEAmQISNywAEQF3AGD-FwcB9wFIAFMR9wTwBoQAAs0AIgchWQAA
WACA9wQx9wXw-xUuACIBBwIAVBH3A-AGDAEBggADXwEAYgACswAjADEoACj-FDoAABQAEwJuAAA7
ARA3AgIB2QNQNwEX8AI5ABcRZQAp-xM8AAAVABQBegABPwAAigMBCABANwEn8CoAFNc-AAJqACX-
Ek0DBgIAAUQAFiGBAAdCAAlBAANDABURjwMBBgAApAAg8AYKAwP-ABEnTAQCQQBWAAEHAcctAACv
ACT-EEAAEmcTABAASgIDPQAjERfIAAE9AAQ8ABVnPAAVD1AAFYd7ABcnegAHPQAA9QMAHQQCYwAi
-w-LAAERACoB53MAE0e3ASIn4F4AAjYAEOdvABLncQAqEedoABRHaABU4AHXEccvABINLQAsAedj
ABMnYQAGYwATx4gAJf8NMwAKZAAGzwIBZgAAzQAR5zQAENdoAEbXEfcBZQACWAMEZQARd2MAJPcB
LgBQDNcB9wQEARUFLAAFXgCRRwFn4AHXAfcCLQCSx-D-DAG3AfcEWgEnBddYABLHVgDBAwEHEdfw
-wvHAfcFVAAn9wNPABHHTQCABAEHEcfw-wpJARL3-gICKAABSwAw9wPgHwci9wZxABAKJQACDAEE
TAAApwAw9wPgbwADlgATCDEAEBElAFUJEScRN0cAEAhrABAIpQcj9whGABEJRAAh9whCABAK_wUQ
CB8AFQo_ACL3CDwAMQsBpzwARIcB9wmnAABFAAACAAM-ABALPwABIgASC_8AFwhAABAMQAARBqEC
LfcLQQARB4QCFKcnAAEmABcNRQARB9YBAFwGEJdGABB3KQAFRAARJ0IAIuAHQgAxDgGHQgBPVwH3
DkIAABAPHwARBB8APxEB50AAAAIhAAEnBCD3EmMAEgRBADIG4AdCADEQAXdCABNHIAAyBfcHQwAx
BuAB_AEQEcUHEAQgABEUYgAWBz8AYacB9xMBVz8AEDcfAAE-ACEFET8AEgWIAwQiAEABNwHnEwIC
IwACkAAzBeABRgAQFCQAEAN5AAIlABABEgIVIf0EEwCsABAC-AJAR-D-AioAJvcAKwAFqgQBHAIC
rwIALABBN-D-ApEFIOcRLAAzAvAF8AIDLgAhAuAZCSH3AwcAEQcwAAEvAAH8CRCXMgAgBvfIAAMC
AEAR9wLgKgARtx8GELftCAJiAAAVAACDBxKnZQAFuwUAMwAgAdDlAxG3JwMTpzMAAjIAMUcBZ9cA
IfAFcgAHmQBQAcBxlwF4ClAXEWcBl2MFcPD-AQFHAZceBjBxtwEVATQ3AddeBQAzANEAgLcBdwHH
ARcRlwF3CQUR-x8AAAwAAEwAg-cDwGcB1xFnMAABaQGBVwHXAYcBRxEHCgBiABFn5wqilwHHAbdx
IOcB120FICHXhAOQRwHXAZcBVzF3KwDxAgCHMWcBpwHHAZcR9wkB5xGHZwEy1wH3xQEQp4YEACcA
AFwBMKcB1_QCMwsB54UFENeyAxEXSAEBJwAQ-iYAMMcB18cCMAwB57wFIhHXmgMQ18wBYQEBF-D_
x64AAJkEEPcGBQVKABAJCgIQ1wUAMBfw-ScCEEcMABE3rgoh9wxZAQNQADAKAdf3AFIBAQfw-SgA
MAIRFyoKAFIAMucRx1AAMQoBZ6kBAAALUGcBF-D8QAAArgIgEbePAwdQAFELAWdBt-QHAWYLQvD8
AbfCBCICASsAIhHHaQFRCgF3AecpADRHAYdTAAB9BgIqACENAWQCBYAAEHcQABEXTgcTl1cAAy0A
AREERfcAEceBAAIrAAC4CwAOCwFZABV3KgAl5xFWABML1gACMQxRF-D7AbcaAjjHAaeBACQR5wEB
EbeuAAErAAJVADQnAdcsAAGQBhbnKwERFwYAMSfw_x8MIHcRAgISh6sABlcAEQs7BxGnHgkwhwE3
VwBhFwFHEYcRywMRd1oAEQFaACD3AD4AFQAwABBnZwBh8PsBN0GnZgIQ96gCEOcZAlIAEfcBET4A
EQHcCgAvADB3YVddACH3A_8JMIcBd1cCEAC8AAE5BwHfAwExAFAXEXcBlyYCMAXw_y8AACgDEIfe
BBAB_wMQAQgAAY0AYVcB9wIhl3wDMFcBx1wAAgUIACkDEKeLDBABsAATAswHAzEAIQG3MQBRNxHX
8PvpAwIwABDnGwATd8sEEge3AGH3AgHHAYehCiDnAV8AGjcvABFnLwAkAxEtABG3eAZTZyH3AAFc
AAC4CRKXgQcSV4oAAl4AEALeAAAxAJEXYfcKAQfw_1ctADFnAXeYARH31wURA1wAEAJZARADjwIQ
AvQAEAdwAQE8DgKZAAD2BwBNAAEhCCIDEWQAEQMaAxEnqAAwF-D7sQA2p1EnLAAREVkFCiwAAA0E
AH8CApUEEHdxADEFARctABEFiQAEKQAytwHHVQAh9wYLCQAICBIRVQgBVgASBFkAEZctABPHgAIA
9wMYty8AAQMABysAAPICAX4CEUcqABEnYwIi9waVCAJZABIFPQERhzEJU9cRRxFHDAEAWQASV9oI
IfcHWQASBn8DEXcoCVDnQWfw-AUGCSgAEgGzAAkqAGD3AAGX8PxbARHH7AEXl1MAAqICAuMPAigA
EadiAQCBABGH9gATCFMAMQgB100DACwAEOcpABGXVQEAAwEBjwIh9wksAHQIAccBJ1F3JQBCR0FH
ASkAM1cBBycAQifxAxcpABF37wEQ1ykAEecCASGnUXADQfcKMTfnA4MXARch9wkBtyoAYccBp-D8
d9IDAEoCUwH3HAF3kAQBbA8cpygAAAQAAMUAHxsoAAEADgcBKAARR1AAAYIHAikAEidZBTELAZcp
AD13AacpABMaoBADKQAABQECKQAyBwGHKwARdyYDQacB9xnICwUtADMMAXcvAABEDwEtAABFAQMt
ABEYiwMAKQIFKwARl6wAFCcrAAAoBg4rADENAWcrAFiXATcRNysAAPYBIfcWRAQFKwARVysAgacx
VwGH8P1nFQIfdykACAF-AQApADWnAYcnACQRRycAOBMBlyUAEZexABHXZwkBegkSJ14CExInADCH
AXcnADRXMacnABFnSAsUJ6ABCykAJocBKQATEfMGDyMAADE3ESd_BiH3Em8EEad1AUH3EAGnAgAH
KQASJ2kGYAH3EhFnEXkDEjcpAAJCBRhXKwAxBxFXtgMh9xHJCBKXTwMfDysAACIRdykAEBAtBSgR
pykAEUf-AgMpACRnAbMDIfcPWAURBxUAEDe-BgAdCAIvAACCAQMxAABiAQMxAAAiADFnEZcGByf3
DS8AMmcBFy8AETcPABlHMQADYgAHMwABXgAiAQczABEnDwAAywABowgRDBwAEZePARBX2QIRJzMA
Q2chlxEvADlnIWctACERd5MBCC0AANoDIvD9PAMRR1wFEFd2AxEHkgQRh4EBEFcJBBg3LwARh20D
Bi8AFBFcAAByBir3CC0AAG4BEWftABGnHgAUEVwAAaIEACoFE0frABLXLwAzxwFnqAUQZ6oFAfUG
KhF3LwAAJwEDLwAAHAoFLwATBV0TIncBLwESZxAGALEDModx5zEAEeeNACD3AW0HAgoIALcADTAA
EHejBTF38P5JCSEHQS8HEGdqBxInkwAFMgARFxoAAxMBMzcRpzUAAJULAeYTAjUABPcUAzUAAhoA
ASYBEVc5AQCGAAQ5ABJXxQwRZzgINTcRZzgAAAYBARkAAJsKAIcKEQdlABI3OgAAawlgZ3HHAVch
-wsKcgARd30LADkAMRcxR9UBAO0DATcAAJkBIfcAywFABxG3IeETGUdyABEH-wUAyAQRRx8EHRc4
AFEXEacRRyQDF0dwABEHbAMEOAAhVwFPAQBRABW3cABAAQcRh08BEBGsAAY8ABE3CgMRB7AAGLc_
AADsAAPKEBG3igAgB6H6Fgh4ABFHDBcRBx4NETeSAAIWABAXPgARV1gHEbc9AAChAAYCACNnAYMA
AWwTAoMAIgdhGgAAGwMJSQARF5EGEUchAwC-AwEtAAMCAAAKAxQ3jgAADhgFAgATJ_YGANABAnQG
Ywfw-gcBd0sAArYNEWcrACC3EWcXEVeMABFn5gETBwIAUTcBRyFXfgIAggEHRQARpxoEE0dwDSH3
CMQAIlcRhwARdxUAAPgCMRdRd0MGFCc8AAE3BgDkACBnIS4AIPcIygMBzgEC0AMAbwEUR7ACAQcH
UgFXAfD_ygQByQOBl1FHAfcIIWdSAQDTBmBHAXcRtxEdChFXXAAllyE0AAJjChCHqgM29wkBagAS
xy4CIhFnMQAAygIALAJTNwE3IXcACEP3ChGnYQAg1xEBAw0uAEZHMRcBLgAnAbdcABCHagIbATAA
FaczCAD3EQNcADG3AQdeAAYuAAAwAwkwABCXUAUgpxEvAQA2AAJeABSX7QABYgUMMAARDbMDAvMF
AGgDEXc4ABGXPAMRVzYAABoBCzYAEedGDwBnAACDAANpAAAuAjIhdwH9DxB3gxEpAGc0ACz3CGoA
IRG3NQURZ4YHADEAACsHCDEAAYMDCmYAEcfGBQBaABuXMwAQhwsCAjQAIwEnZQAxlxHH-QYRh8sF
AKgWAjIAADAABTIAAZcABFUCFYcaEROHHQcVBzQAAHsBD2YAAxHXGAcCMgAxV-D-qAkCMgAAaAAA
tAoaB2YAERFpDg8zAAgBDg0VBmcAMXcRlyAACjQAEQfUARdHaQAAiQYHaQA-EXcRNgADAKUDCGwA
AMoLEQcyBAC9AxEHQgQA3gQB9wgBgwQQJzwAEQIfABEnTQAA6gMEgAwC2QERNz4BKmcROwAAGgAA
OwAATwIHOgAUBDoABXUAIxFniwQTlzoAASsCAToAAJ4FCHQAAK8AAnIAIqcBNgARJ34AAv0DEQcS
AA46AAx0ACP3AzsAAvYEIicBjwRKx-D-AzkAAGYEBnMAADcAIxFHNwAAmwMINwAAAgETh0AHEDdQ
BgABChHXfQQSNz0PBHEAIRcRZQAAoxYQBMMBAqUBAzgAEQF0ATXnESc4ACERR3YAMWchd4IBDzYA
AgJuACLnAW4AEZcVABVXSwgRhycFEec5ABOXpwARV10DACIEBnAANucBV28ADzYAAzFQVwEOABMR
uxIRV_8IESdcBQAVAAAIAQC6AwQ5AABnAQY7AAD4AAIQAwGCCAHXEwGkBQGxBgI_AACJAAQ_AADP
AAh5AABXBgE_ABECjgEhEUc_AAEGAAG0FBGX4gUEPgAAQAACJgEFfAAlEUebEAE4ACMRV3oAAdUA
IgFnPAApBTc8AAAzAwJ6ACY3EXoAExc3AyEHARMBLxF3PAAEEUd4ABI36RASR_EBASkIA7gAAD4A
AOIAAj4AEUccAB0XegARJzwEEmdqDwpBABVnQQBJ1-D-BkEAIUB3NQEiVwHSCBFnKwcR1y0BAIUC
IDcR5QcCPABhxwHw-wc3KwAEPQAAZggHMQgQITcJEceyABEHKQcflz0ACBEwQAgCewASR0AAEBEX
FRHHHAIRF8oCADEAAkIAAKsEQfD-B7d1ERJ3PgABuQAwEVdRYAIgtxFUDBEXkQMVRzYAEjf1IAg3
AAC3BQFGCxFniAQTJ1YMBDIAACkBCjIAEQcTARBX2AETd-YGAMIAJJcRMwARV1oVCDMAAL0AEtdK
EwCgARFHMwAApwUTdzMAIWcBoxYCSA4ENAAB_w4RAeAEERc0AVNXEZcRh6AAMHdBNwAaADMBAjAA
AJIEAzAAEZdRAROn8AAA7hMADxpBEUcRV_ILIFcw1AUDLAARJ3MLEncICwUtACInQVoFIEcw1wMS
tysAEjdTAgFxDjGnEDchAAAuABEJOgBQhwE3QMcrABEAogMTJy0AANMhQRcBpzAjAQovABBQ2BIR
50IDA-ABAAgBALkIPxGnQDAAARHXCAACsgUADAIFNAAAwwhHEZdwBzQAEQGNBFE3UOcRd1ICEQc8
AhEXBQMAmgIVZ3QAAwIAXREHQTeQQQBBJ3D3AN0IEQepAgJKACEH8YMgDAIAPBcRwD8AUxeQV-EC
NQAE1wIUId8CUScBVzEHCgAiB0EIADon0IdBABDgRQELAgAFXwNRFwE3QQehBBIHxAlYcTcBh7CD
AAAIEAGOGQsCABchVwADewABcQwwAZcRvQ0QoGcBJ-cCRAAlAYd0ACIXwQoAAlEBEQcpAwLnBAc3
ABECrBABTggTBwsCDAIAEUdxABFHAgAAuQEkZ5A-ABIK-AA18ADH6AUHNQBBAWcRV9UZADUAMVeQ
hwwCCzcAE1diAQQfAgCYBwRoAFEHAUeQh4MDNTcRxzYAEOD_AyJXAasBAZ8OAC4AAmcAAE0FElc0
ABBBJB4CFQEQ4BYCAhoCAYgPAKISIFcRCg5BV4CHAcsdEAItAAELASHgVysAEnddAAD2AwLMAAJd
ADFngIckBQcxACHQV7UAH4dcAAAiEXcpAAA2BA0qAApZACB3cMcDAC4AIQyXKgcih8AuABGXxAQU
h4IHAVsAFmctAAC3BQ4tAADGAQJaAQtcABG3xgQ9h7BnXAAA9wALXAARx8EJDC0AAlwAJFcRWgAQ
hwUcQP8M1xEHBSB3sIoHMWcRh0AFHXdaAAMtAAHnBkCHAXegJAACUAwRZ3YGE2dZACaHYCwAEwIq
ABE3Yg4AFwUDWgAjAWfjCB13LgAA-QAC9QIXh1wARmcBhxFaABENUAIid5DoBQxaABFnSQMzd3BX
DgEaDi4AD1oAAADiAAYuAABzBjF3kFfNAgA-AyZ3AQoPAlwAM4dgV4oAEQ62ABRnLgADXAARdxIH
EXfKGgDkAA8uAAQDXAAGLgAthxFaABCAhAETRzQDFmcuABARigAop1AuAEKXAUeQLgAkZwFaABF3
1AcRB8gBM5dgN_QAGg8uAAAAAQYuAAJaAAEsABBHwSAwEPcBixUQgKgCD1sABSCnYDEHOCcRxy8A
IlcRXAAAVgIDlAEBiQ8ALQAwhwEX9SIREIkAAlwAE1c-AQCLAAEtAAF5DISncBcBhyH3ASwAICeA
aQIAXQAKWQAANAAzp4AHDwECLAAxF5BXSAwC4QARVyQAEZczBjWnkJcoACKnsO8EAtoAE1d6AAKC
AEKHAbeAKgAAiggxl6BnIAAAVgACUgAQh3oAAV4AAyoAACYlASoAMecRV-0BAtYAAV4KAmEADCkA
GddRAC-3AlAABALhCSmHAVIAAGwHDFIAM6eQ15UBAl8FAGoFA7MfAlYAAiIBASsAJ4DXVgAkRxFW
ACIRB0IAMgHHcC0AEBODACGAx9UKBFgAQ-cCEQdhAAAwAQorABPXbgAFWAAiAhHrCgJqAiLHYFUB
EBMOFA1ZABUDLAEHKgAA0gRWl4C3AQf8AAVZABFndQMxx2CHkSmCE9chBwGncMdLAAJUAAM0ABKH
LgEEKQBQ9wERp2B9AAIoAAFPAAIdHgUlAB2AaWNFNC45NCJxBQh0GDUWAC42N2lbDkssDwEADyBc
EaQr8AnGFxFXIYBH8P_xRyGHEWCn8P_pVyG3EUDgDnCkVyH3ACEQsw7wAJ8B9wqR1-D-mzH3BAEX
wWwQ4Dfw-5gRRzG3MScBR1FnzAqAlSEnMcch5zF1GKA3EFfw-4ohJ0EXgiHxAQFhdxEnIWfw-4Yx
JyEnISecKrAxpyEXMVfw-4NBh9QNICGXiwMQAyYAYIAxlxFXUYkTwPcGIVfw-34hpxFXQQMEMFch
N_0e8ABX8P98ETchRxFnQZcBNyEMJiD3A0wAEXkWAPMDNwEXEbchVzFXEfcFIVcR8P92FwBwJwGH
QddB9ykRcPD-cxE3IZfQD4AR9woB9wQhZyYMYHERNyGHIQENQfcLUZfVFVAH8P9vEWUAsychZyH3
CzF3MWcRGABQbSEnMSfpBRERoiEAGABih-D-axE3FgBRAbcxN2FQFAC4C3Hw-2kBRzE3XxBgQfcK
QUcRnhpRN-D-ZwHXAFAFAfcTIWgXEMcVABBlRQFwAfcgIYcRN1QQABQAEGQdCJAh5xGXMfcEIbcW
IyAR14ws8QBiRxEHEdcxZyGXMYcR9wyQKUBgATcRrg7AlyF3EfcAMTch9w4RGQ5CN-D-XwgMIBGH
XRBCEachF68aEEfTARFdDBAgdyF8BHHXEfcUEVcRGAAQW9QQAXIiMIcxt6IcIWcRTACQWhE3ETcR
ZyFnBAETAIgiIBFnFgAx8P9ZCREw9wOB6R9AEfcBcZ0KAYMAEVjTI2A3EXcx9wJ4LhBBMBhA9wER
N88AEViEAADfBYL3BCGnASdBt54hkTfw-1YBNyEXMaoaMMcBNzUgEpcZABBVgy0QIYwAMPcEEZwO
QEdx9wnwCQJTABFVOAAgFyHmJQAWARBXDBYAPwARN9MRQCfw-1RAAAAEEQF5IQC7F2GHAUdR9wC7
LgGzAgEmADI3MRfVAGACARcRRxHlAVJHQfcGASYAEBd1AWHw-1M3QRdYACBnUdsKADsVQWcBRzH9
JmEnASchdwElAAElAgBLCQDUJALoDgDWBjLnMYc2GyARByYAERHdDhEARhYAQQkAxhAQYSIAIFch
xgJiUycR9xEBHQCiVwFHMafxAHcBRxsAAGslQBcR9xL8ArARxxEXUQcxBxFnEbkVAB4AcQGXERcx
9xCeBMC3ESdhJxEHIVcRRyHdL3FTdxEnERcxlAMAjxJAh0E3cdgOYVcRd-D-VO0I8AIRhxFnQfcA
EScRdyF3gecBR7sDEFVnAwCdBiBnQe4RUCF3EZdxKyMAswMQVbECAM4AIGdRNwDhIXcRZ7H3BhFn
8P9TATe8AVBnEWdR5yQwAN4GUIH3BxFXHAAhRxFFMJBRJ0FXIUcRhyFMBUAHcfcIHgASUgkIAOQU
QEFXMcdmBREBNBkwhxHXFBQQUXwLIDEnqQFRQWeBZxG_CwCzBSAHUS4WASIAAN8uAAYDkmdRd0EH
cTcR1yEAQAEHQad8IyH-UGMKdKchBxFnUYccAACDDTMhpyEMACBRp5wtQNyH8FrWAkCHUXdxRwcH
AgAkYYcrAEABB0G3LQBwXIfwZbfwWPkAQGdRd2G3KAEFDjJRdyFzDfAFB1FnETdh1-Bat-Bj1-BX
N0GnMYcLGnFB5wEHUTdBxwbwAEF3EfcI8FnX8GH3APBWN2wLQzGXYQf5FBDBlQbwAQcxhyH3BvBY
9wDwX-cC8FRfDDER9wY1DgGoFkEHAQeBegDQIfcT8Fb3AvBe9wPwUycAMiH3BCcAAEMqBgIAIMcx
HB6A8FX3A-BLN9DJBhBS5w0CLgAQFwsFEicoAAGfLvAC9wERJzE38FP3BAHQN-A3Z7D9ABBR4gAC
MQBDNwH3JCkA9wBBFyEX8FL3BBGwZ-A1h6ApACECUbYAACkAAGcgASUAYaCH8DOnkCUAEgdfBBAH
9hUSJRENALoBACYAZJCn8DHHgCYAAMgcMBEXcdQJMPclMdMd4IchZ-BS9wMhgMfwL_dwDAUwAPBQ
nhdCJxFHMV0PgLcB9yYxFyF3Ai9AYUfwUp4ywhFw5-Au9wBgEScR5zAANhcRN_MBAP4A8BAR9ych
JzFnAVdBR-BS5xEXIWD3APAu9wFQIScB5-BQ_gCABxH3EhH3J-H2GiDwUmYdgVD3AfAu9wJAoB5w
hzEX8FBnEboqICnBqQAgURccBJAhQPcC8C73AyCgAPAGEUcxFxEH8FBnAfcVAfclEYcRFyF3KwDz
AgcRFzFHETchIPcD8C0R9wIgngAAGwwh8E-gALERFwH3CSH3JBHnEe0JIfBRmQ-AJzEg9wIR8CwR
9wMQ2DIB5gQx8E8X9QMgFxEPGUER9yIRIx5QFxFn8FEFGBARDjKyEPcDEfAsIfcDACFrEAB6DDHw
TweSDFAnIWcR180BECB1GyAnATkAAPgMAewCUREA9wMhOwABVysRJ74iEE-XCRA3KgSEAbchRxH3
HhE5ACGHAXEAFDE1ABExbwAQIUsjQQFn8DdBBlAnMXcRl0QIEB2HGwDRGFE6Z-ABh2wCKQchbwAR
R9gdQAGH8DYIDzBBhwFuCAY4AFM5h-ABd9Qfwgcx9wIx8CwxFxHXMXc1UHfgt-A0BgUhUYcgGlGn
AfccEToAcUfwObfgdyFgAMUh1xEnIfAZZ7AhBwE8AMIRd8AR1-AyAScRh1GOHBActxgBjy5Q8DfX
EcCvCwF2AAA-AKAxsGfwBYegMTcBhQoApQrwAHewIefwMBEXEYdRlwH3MfwGAvEGQDfnIbD2C1EH
AUcx10AAcKCH8AOnkCEqAyLHMfQAMHegIZcuES_9BnFHUYch9y0xzSZ2h-A29wIRoH0AsMcRNzGQ
p-ABx3BBEQAUx38AAFAAQPcA8C9gBSA3YTAAIPcspAECQwA0ATGQhACwxxEnUXDH8ADXYFEXAkNX
URchhAAQkDUAQwLwLhdDAFIXEfcqEZkHggE38DX3AyGQiADwAEcRF1FXAUdBYNfwAPcAQIkAAHID
EYGJABGAIwCh9wLwLBcRFyFHYTwJECobL5N3ESfwNPcFIYCLACBxB2oGQFFA9wBvbhEwOwQ0JxFX
EwEScEkAcAPwLAdRV3H-HiD3RgAVYPA19wYhcIoAAFcKUichR0EwYG4RICIFYCcRFwF3Md4MMGdg
MawAssfwKwchh4G3AfdHPwByxyFnIWBnES02cXcBFyFHUSBzbiEDENwEIAcBKQIAzQAwZ2AhBwCQ
1-AqBzF3kfdVQxAx8DXXoABRBxFgZwEnACAhdwMVskEQ9wPwAQH3AgBBWgAAZwZBZwFnUAcA0cfw
KgEHQVeh9wEh90FSA4E1xxFnMVBnEUsIAKkAsVEA9wIB8AIB9wJhFgkTEYQAcFAxZxE3QTdBAGBR
J8H3AkGdAhAoqQJA8DQ3QaQSM2chUIsAMRGHIZwAFFFLABBRFwAyRxGXjAAhQDEeAPAAARchJyEH
8CsBB-EF9wVBjScQKHcNIPA0SgcAlQkyZyFAmgAhlwFBABFhUAAREVAAAhUAMncRR9oAAHcuA0wA
ANYWIGdRpx2gCaH3BAE3EZfwMzAAASMAMxFQR9IAEpekABBB2gRCAwH3AjABAVAUERd2EyVAITYA
BlkAIHdRxy_UB0FnIfcCETcBWwACRA5BEUABN6oAMGcBl7gAAQABQAQB9wOcBzAhhyGlCSRAIWgA
AAQfsPAsEQfxA5cB12HXWgJBACG3EfUKMIfwNPIIQRGHMUDZIwA_ASOHEToAkzH3AwHwBBH3AqQC
IgchPhkxMEEHfRBwh-AuEQfxAisYMIdxxwcvECFGLhEhVwATh6EAMAcxMMoDA70PARQAAIMBcfAF
EQcR5zEiACARh8cANBEgQWcAYHfwLyEH8UMRQAGncZeFCQCvBgCcAFB38DV3MVsIEyA3OSNHAWkA
cUHnERcB8AYNACLnQVgAQncBpyFWAAAxAjGH8DGuAEAnEaeBkBFApxH3E0wLYiFn8DSHEbIIMSAh
F6oAIXchNAAgMeeaOnEGERcR50GHzw8lpxFRAFARh-AxF6YAMCfxB4YMQHch9xNxCyIRV-4AEqen
ABIBpwARZ68AIGcx-BwBpwAAkg8BriIRB3EUAlcAEYcQBvADMRcBB-EBh1GnsScRlxFHIfcVEgJS
EUfwNXeoACFRIBUUAgQSAPQBAWccEPDIH8EHEbdRlwEHMUcRpwAPAwKsANB38DABB-EElxH3ANG3
WAcxwfcIfikzNXcBeQAxYQA3GwYjRyE1ACFRt3ECAKsBAdQGEidcMADdECMQYTUAMAFn8B4CIPEE
IAyBgXcBd0H3BFEOA1N38DZnESYAMVEQFwUBAlsAkIchJxF3MTch8DENMUdBN_YoAp4YFKdYAEAR
V-AxPgDwAfEDZxFHkScBF0EHERdB9xcZEABcADM3VwEqAACUCgBKGBQhEABARwE3UbEEIvAEAAQx
IRcRGhoAAgBiERcBt1EHnQFBAVfwMKEAUgfxAlcRrwMBLwAgMQeFByAGMYkOkwcRJyFX8DhXEV4A
IWEneAERFxoBACUdAJkIAoQBIvAE6gNBAQdBZ2AAEQe6BwL1BlLHEUfwMLQCIPECnwkDZAECbgCB
QddBB0FHcWcoClNH8DpHAaQAEEHIEQJrADKXAWc1ABEx2QABAwUhIVc6AUQnIdcx1QDTR-AvEQdB
B-EDByEXUbUAEjFCAFH3BAF3QdgDUAYRJzEnZwASFzYAQSHXITcKADNXIReYAAHOAFOnAQcxNzwB
EyfhDNIBxwABN-AwIQchB-EDiAwVZxkaU-cFAUdBSQEAugWBN0EH8Ds3AQCVCwHOHgI2AQSyChKH
zQAUp-8BAEMAgQkBxxABJ-AxxwAxArdBTQAgMVc7CRICtxoBnQIh9wMZAXIXEfA8JwEQYQACKAEE
XQAEyQAUQWEAAsECcvcWEAEX8DLBAEHHQWch3QEAEAUiR0FbADFnIafnAlXwPRcBEFkAAAYGAp08
A1sARTHwBFFbAACtC2EWIAEH8DO4AFEB9wBRtxkCAfkwAP4DEIfCD7Eh5wFn8D4HASD3F5wBCVEA
EUGsABHHNQAAuDJh9xZAAfAzqQA1AfcRKgAg5wH4BgEXAUERNyHXmhxgZ-A_AUD3_hwEmwIBUgB1
UfAEIRchp40CQPci8DmgAFLh9xAxBxYAISHHMAcRJwwAEVdCMwBPADBE9xg7AghNACARFxYCAOMp
AxACMSLwOZ0AcwAnEfcJIQeiHGEHEbcRx1H5ABAGugxjEVfwRPci_wEARQEA_gMyIVcBRwBhFwH3
IfA6NAEQADIAAeMHAQIAECHAPxB3_CYBWwlj8EX3IQFHmhUQV0MAAOUQcAcB9yXwOxE9ABAxlAA0
p6FnhQAgAZdkEJEnESchN-BF9yY6AHMnUXcR8AQRjxVC9yTwO7UAEIG2A6AXIfcOQQch9woxSg4B
IwMhRffWAhABbwAAiQgwJPA8qwBwcSdBBxEnkUcOkBH3AEF3oYchlxANIPBGBg4AsiECZQCgOfA8
IQdBB2E3MQgBQPcBQVdgAPABBCH3AHE3EYcRRyEn8Eb3JvVAAW8DQvc38D6QAEBxN1EXpwchp0FG
ATH3BhF2NZIRJ-BH9zoR8AMtAKA-EQfRJ0HHgdchmwcQx4ITEWclAFBI9zgx8LcH8QH3NfBAIQfB
NyF3YfcFQQcR0RExtyHHKhFQB-BK9zYiAxACTwAgNvAwCQECABBhMg0w9wwhmgdx9wEhZzEHQSYz
M0r3N1cAMjTwQs0EgXEnIVcR9w4hoxhBB0FXEcgLVQfwS-c1WgAyNfBDLQAQYURCQPcPUXctD5Mn
EVfwS-c0AQdTAPEAGwH3B-BFEQfBJxH3FgEHvwcg9yUTEyDwTS4yFRxQABAcKgCBRhEHsScR9xgx
GSH3JLQCASgAFBtSAJFXMfcRAacRh-A1AmWxFyH3GRErACBOhy8NNBExZ1YAQAdR9xXzGSDwSC4A
UqEXIfcS0gSALCEXAVfwT6cMARAVfgRAMfABQV8iAUwxgMfwSdEXIfcQWgBCAxH3Fy0AEcceOwLK
A0Ax8AAxzAIBIzFBx-BKEV0AEA60HZIIEfcWIYfwUMfqOhDHAgQCUAsSlycxENcvABCx2hAAXR9A
CQH3F2EPENduEDMNAcdcAAYvAKLn8EvRFxH3CyGHXABSQUfwUectAFGnAQdB4BAGQGcR9w7TEHAA
8EzR9w0x6TsAyRMBHysh8FHwE4D3DhGXYdBhh-ovEDfhPrBNQQBh9w0xlwH3B_wABCwAIQIRHTBQ
dwEHUdArCwBVMADfNCPwUy4AQAgh9w9jCQEuABIEdjBgVwEHYcBxaQgg9xEkBGEF8FRh9wu7KgAU
EBMNOhURUiooIPcRfxRQYbBhB1GNEIAHMDfwTGH3C8sOESHBCGEHIfcLESdKFTBLNzAAAjEU0bDo
ABD3BixxMGfwSWH3C8EIQPcGMTfIAgAQGDBJZzADNBIYXAAhAQfEELAKIHfwSGH3CjFHQTo7USE3
MfcJ-wcwSXcgqhcBlgITUV4AEAQPB4H3CiABd-BIUTMwEAeRFRALXweRBxE3QRfwSncBNwAQARYH
QAdhoHEsBgHAN3D3DBABh-BHBxYDDwsATgYB_SeSIAHwS4cBEPcM7TdTtwEHYZAUCQGsKnENEBGH
8EZxTiohpyHUGRAHmgRgV-BPhxEQDRgBiCJFB3GAgTQAcQ8QAZfwRmHFBgD4PACbB6UEAVfwTpcB
EPcPMgAicHHoBeCXAecR9w8gAZfwRXH3BcIBEKeeAAAyAHBNlwEg9w8RMgBidwEHgWCRMAAA0wCB
ERABp-BEgff4BBAAjA8ASgWB8E2nARD3EQGIIwGzCTKBUIG8BgE2JDD3EhBgRiBDgT0DQQRx9wO5
JUC38EwBnAASEp84ARIGMZFAoU4NAVABUBMQAYcRNgARAosBEUFyKQA6B0C38EsRPwEhEwFqIREn
FwBhB5EwsQcBJh5RARH3FQCXJXFCkfcAIfcHySpgIacRp-BLMAEwAPcVXxIDLgpQAQehILFkD0D3
DQH3FTlQF-BBkWfDExAh5QlAEbfwSloeAGoCEA1DBGHBAPEC9w_mA1ABJ-BAUdQNQXcB9yPjDDDH
8EldFwAtADEP8Q-bAjD3FhGpHEA38EBBHCgRd5EUYAFnIcfwSFogEAchAEH3E-EL4QMSBYECEBdu
GDHwQFE2KUAR9yUhFAGBJ-BJNyEXIReLAFEFAcfxCjMAEAa2AIA3MXfwPlEnIUwTIfcoJSVhJ-BH
dzE3CwkAJQAQp8ALA-EAAFQAAHtEACAEMD1RN50WMBH3LrEXQfBH9wC_ACIHETMMRAfRBwECAEBn
AfcxUABRAfA9QVfHGBD3xwMAawAwRvcBEwISMP8BA5EBJgcBAgAAZhog9w4wBSAHIXYAIkGXexVR
BCFXQcciDyCXEUcAAjw_AFIDEQ58FxQHAgABuAIGAgARl04AUA0BBzHXTQCQISch5yFHYSdBTh8R
N5JHEkfHEgBlAwK4PA9HAAECqDsB_EYTAEgAQvcVIVdFAGEBN-BH9yEiAAPWFyMBBwwKALQB4yHw
PVGHISchZ2H3CUEXMwAAlwdBIRH3JVcOAU8CcPcY8D5BhyFzDSD3EZUNIRHXJgAQGFUCECYdBTYo
IWcmALE3EbdBJ3EHEXchZ1g6MEn3GFECAXIIECobF2EZ8D5RhxEAGoEhByEnQWcxZwofYPcC8En3
GQkaJBAB_wgQKaQVAAtHIj5RiTdQBxEHMQfjExBhxBRg9wHwSvcTjgwARgcAfQIgK0FCHVD3EPBA
UdAkAokLIAchoBwAgA0CYAsADhdA8Ev3EGwdMkH3D_oX0fcqYRdBB3H3CfBBUVdpBhEn0wQANxIB
PQASET0AAEo0kfBM9wlxB0EXYXoBoAcB90LxD2fwS1FpHABmGCMHUXUAIhEXsw0hMSdKD1TwVmfx
DzQAYUPwcVFHEQobEGFiCiA3MTYDAvoTAIoaAO0LI-B8wkhh9z-wd1E3LgAhJ4GJAEAxFyEH3BYE
4yYALgAxgvcFLgCgBwH3PRHweFE3IbIAETfMBBEXPgMRUR0AMQLwg6s9BAIAoPcrMYdR8HlBJzEA
SiMngW4KEYEOCQEvADJRhzErABAHnwMAIA5RA-B5UQfJGyEXcRkAEsGKMyAHUc8bRYfwhPGZJyH3
KgcAIhfhMwAAggEBiAAFAgASIWUZEQfDNQAlHkSE4QcBAgAg9ywHAFHxAPB7oUccAtMBDAIAA6wB
AGoBAIY5GIZBAAJ-AFAH0fB8saYXAxUCDAIABBYAEEEHLEqH8IfhgQCV4fB9oRcRJwE3CQEHvwAF
PAACvwAqh9E8AGABB8HwfqG2FwE1GQz7AAgCAAHAADuX8IhCABPRQAAAihUBTxAjAadwAGxHEYfw
icFwAHGx8IChFxEXJxExpzG3lgFTRwGX8IoqACL3LpYAEoCWAFAh1yHHUeMQQofwi7EiAAZMADOh
8IEmAAB3DSDXQUAYSIfwjLFKAECx8IKRHANBVyHHISIAWAGX8IyhIgBgAQeR8IOhCAMwVyHXRgAQ
EXIVEo73AQcmAFGB8ISRJ-ISQNcRp3GVLUx38I_RJAARhW4AUUdRpwG3kUwA_TsTkBwFI-cwKwUx
8IaBAzthIScBpxGXKSAAxxkRkXQAIvcySgAgh2FkAADDHjC3AYcwShERJAAWkUoAQYHwiGFPKQI5
OAGbN0Sn8JNxRgBhkfCJQVcR1wIAixsA9AZGl-CUgUEAQnHwizE2EUAXUdcxwhQAYQImloFhADGL
QVewCmAnERchl0E9NkJ38JeRIABAgfCNMdMVAE0EIDexZQBC5-CZcRwAMZHwjtM1Ikcx4jYAjw0j
8JlZAFFx8I5BV7AmAEUFITcBTAdDAfCbgR0AIWFHnCEC4xcA3QBS9wLwnGFmAUBx8I5x8y0B_AEA
qRNQAcfwnWE5APABYfCNkYcBp0F3MXchp-CdcS4A4mHwjqF3AeeRpzGX8J5ROgJBYfCOwWgYRRAh
hwEWAEFB8I7hhAMwEfcPpBcAGgAAGAAQURgAApsFEQ_UAAC1TEGcYfcqGwAAvA9CJ1H3DgURAhwA
MEH3LBoAAZwZAN8GRCFXMUceABARHwARKm4AIPECvxhA5xEHMVYBEwcCAHAXAfCbQfcrIAAQBMoc
YkcBF_E3IfkTBCAAkDH3KlHwjfEFN3UDIvEFuE4CfRYw8JpBBgUzMfCNmQKjB1EnEVdRF-EBJ_0U
AWsTc5kx9ylB8IyXAgQdBYJ3IYdBFyGXIRIAUoch8JgxTQAUjMQEBQwEEBfrGSSXMesHfwch8Jcx
9ycsAAIA2xISEf0LAh0EAiwAQTHwjIGEEQYmAABGDAINAFDHQfCXIcMHVSHwi3G3IgAh9xVQERDn
QAERlroHUiHwi4HHHgAzQfcU4QBC52HwlgEIRPCKgeceACESEQkAYQH3AHHwlUgIRBHwipGACDNR
9wz4AACLAsKB8JUB9yYh8IiR9wMVABRhohEAIABBA5Hwk9UeYhHwhrH3AhcAVYH3BiEXIgAAwwQg
jxG8CkIh8IPRYQs1sfcBXgYAEAex4fCMEfckIfB88QUQNlcHwUdRFz8BACQAcPED8IgR9yJrACFv
8W4LMwEH8coAASQA0gfxCvCCEfcjIfBt8RNpEwdiBgwCAOH3CfEQ8HsR9yIh8GvxFQpHAG4gDy8A
B5ABB-EV8HYR9yCCADJm8RcUAA81AAvyAwsBB-Eb8G8R9yEh8FvxCRfxCDQABEsHDzgABXENAQfx
HvBrbQCEAfBa8Qkn8QhwAARGBw88AAX2AQ8BB-Ef8GoB9yER8FjxCTc6AAZABw86AAOAEQEH8SPw
ZwF2AHDwV-EKR-EJwgAOAQcMOQD4ARMBF-El8GT3HwEH8FXxDUdzAA86AAsAoBjXKfBh9x8B8FPx
EDfxB6shA3QNDDMAkBkBB-Et8F73HjMAGBIzAAJ1BwUpABgdZAFA8RzwXfoRMPBS8YsXIfEINAAl
9zVQAfEAhwEH8RjwXPcd8FHxAifBwAk1sQeByQAj9zO1AfUDp-Eb8Fv3GwHwT_EHAUfhh0EH0gEm
9wkpAPAA5-Ec8Fn3GgEH8E7hBwFnySIkQScoAAXsDBMpLAAwH-BXUwAQTScAROG3MUcnAEOHIfcj
4geE9wHxIPBV9xomACPnISYAEA-LEhMhiwIy5wEHJwAx8EvR1QAhwQcOMxKBG1MxMfchFgOh9wHx
I-BT9xnwSyMIQqfh9wkiAIEMUfcdAQfRF7sDg-Ek8FL3GPBKJAACuQACKAA2C0EHpQQkB_HrA2Px
JPBR9xcyABnHMgAjClEhAQPYARLxSVKSBfEm8FH3FvBJMwACsQARCZA_AD4AFEH-AwaGAhLxBwAE
FwRWJvBQ9xU-ABjhPwAhBlGCABAXxw4CAgAAkACx8QkH8QzwUPcU8Eg2ABXnNgASwcgAEmHjADHx
CScWAAIwADZP9xMwAAQrABILBwASAmkIAYcCIPEFCAAAbA8ADQBxCPBP9xLwRzgACjoAEuGhBQAG
AAUsBBIDCAASwSQAASwAioHwTfcS8EbRPwACKABF4QcB17oGA34AAT0EAf4AJQehbAETYW0JUUv3
EvBFSwAn9wFMAAL9ADYBB_FOAAUTABcHUQAqAQepBhMBVwBvSvcR8EbhVwABAZQAIdG3AgIlBwH5
AABTAAMYAg9XAAo1EPBFWwIPVwAMFQmsAARNABKhjQAwcfBJSAAk8QBHAAdJAAFLADQXwacjCANJ
ABLBRwUlgYdFAFJh8En3D0UABkcABBUBAjgAOg_xlxEAAiIAIfcRfwEJSwAc5zYtHzI2LQJWMTEu
MDVViZAsem9vbT0xfX0=
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Iixtb2RpZmllZD0iMjAyNS0w
My0yMiAwODoyMzozNCIsc3RvcmVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Il1d
:: map/
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Iixtb2RpZmllZD0iMjAyNS0w
My0yMiAwODoyMzozMyIscmV2aXNpb249ODEyN11dbHo0AGkAAABYEAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD--------------------78QgiKSxoaWRkZW49ZmFsc2UscGFuX3g9
MAgAwnk9MCx0aWxlX2g9OAkA4Hc9OCx6b29tPTAuNX19
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Iixtb2RpZmllZD0iMjAyNS0w
My0yMiAwODoyMzozNCIsc3RvcmVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Il1d
:: sfx/
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA3Iixtb2RpZmllZD0iMjAyNS0w
My0yMiAwODoyMzozMyIscmV2aXNpb249ODA2Ml1dbHo0ABEBAABSCAAA8CdweHUAAygAAAQABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDBAUGBwAP-5AICQoLDwwPDQ8ODw8QAPAADQ8RDxIPEw8UDxUP
Fg8XEwDxAQ8YDxkPGg8bDxwPHQ8eDx8UAPEAIA8hDyIPIw8kDyUPJg8nFADxACgPKQ8qDysPLA8t
Dy4PLxQA8QAwDzEPMg8zDzQPNQ82DzcUAP8FOA85DzoPOw88Dz0PPg8-AA--8P8BAOv-J1oBEAYP
IBABIAEgAfAAAhACDBABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDDAA-zkf-wEA
3L-4D0AADUD--7DwcAoA--9kH-8BAP_ZUP----8g
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Iixtb2RpZmllZD0iMjAyNS0w
My0yMiAwODoyMzozNCIsc3RvcmVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Il1d
:: src/
:: src/custom_wrangle.lua
--[[pod_format="raw",created="2025-03-17 17:47:53",modified="2025-03-17 19:29:15",revision=74]]
--[[

	wrangle.lua

	not designed to be customisible; aim to take care of 90% of cases with a minimal replacement for boilerplate.
	to customise: copy and modify (internals will not change [much] after 0.1)

	wrangle_working_file(save_state, load_state, untitled_filename)

	user supplies two callbacks, similar to create_undo_stack():

		save_state()          -- should return data (and optionally metadata)
		load_state(dat, meta) -- takes data and restores program state

]]


local current_filename

-- last known metadata on disk for a given filename
-- can use to check if contents of file has changed due to another process
local last_known_filename  = nil
local last_known_meta      = nil

-- set when contents is found to be stale due to external changes
-- ( --> stop auto-saving)
local stale_filename       = nil

local _env = env
local _send_message = _send_message
local split = split
local create_process = create_process

function pwf()
	return current_filename
end



local function update_menu_items()
	
	-- don't need -- can do file open, CTRL-I to get file info
	-- also: can hover over tab to see filename
	-- ** maybe: right click on tab gives a different tab-specific menu
	--    at the moment it is only really useful for "close tab", and maybe confusing that there is the same menu twice
--[[
	menuitem{
		id = "file_info",
		label = "\^:1f3171414141417f About "..current_filename:basename(),
		action = function() create_process("/system/apps/about.p64", {argv={current_filename}, window_attribs={workspace = "current"}}) end
	}
	-- \^:1c367f7777361c00  -- i in circle
]]


	--** fundamental problem (maybe wrangler could tackle):
	--** when edit metadata, doesn't feel like anything changes on disk until save it
	--** But then Save As, what happens? Should wrangler store current metadata and pass it on?
--[[
	menuitem{
		id = "file_info",
		label = "\^:1c367f7777361c00 File Metadata",
		action = function() create_process("/system/apps/about.p64", {argv={current_filename}, window_attribs={workspace = "current"}}) end
	}
]]

	menuitem{
		id = "open_file",
		label = "\^:7f4141417f616500 Open File",
		shortcut = "CTRL-O",
		action = function()
			local segs = split(current_filename,"/",false)
			local path = string.sub(current_filename, 1, -#segs[#segs] - 2) -- same folder as current file
			--create_process("/system/apps/filenav.p64", {path = path, window_attribs= {workspace = "current", autoclose=true}})

			--printh("Open File // _env().prog_name: ".._env().prog_name)
			-- can assume when program is terminal, co-running /ram/cart and should use that to open the file (useful for developing tools that use file wrangler)
			local open_with = _env().argv[0]

			-- when opening with terminal, can assume co-running ram/cart
			--> use /ram/cart to run it.   //  allows wrangling files from load'ed cartridge; useful for tool dev
			if (open_with == "/system/apps/terminal.lua") then
				open_with = "/ram/cart/main.lua"
			end

			create_process("/system/apps/filenav.p64", {path = path, open_with = open_with, window_attribs= {workspace = "current", autoclose=true}})
		end
	}

	-- save file doesn't go through filenav -- can send straight to even handler installed by wrangle.lua
	if (current_filename:sub(1,10) == "/ram/cart/") then
		menuitem{
			id = "save_file",
			label = "\f6\^:7f4141417f616500 Save File (auto)",
			shortcut = "CTRL-S", -- ctrl-s is handled by window manager
			action = function() _send_message(pid(), {event = "save_file"}) return true end -- still save just in case!
		}
	else
		menuitem{
			id = "save_file",
			label = "\^:7f4141417f616500 Save File",
			shortcut = "CTRL-S", -- ctrl-s is handled by window manager
			action = function() _send_message(pid(), {event = "save_file"}) end
		}
	end

	menuitem{
		id = "save_file_as",
		label = "\^:7f4141417f616500 Save File As",

		action = function() 
			local segs = split(current_filename,"/",false)
			local path = string.sub(current_filename, 1, -#segs[#segs] - 2) -- same folder as current file
			create_process("/system/apps/filenav.p64", 
				{path=path, intention="save_file_as", use_ext = current_filename:ext(), window_attribs={workspace = "current", autoclose=true}})
		end
	}

end




local function set_current_filename(fn)
	fn = fullpath(fn) -- nil for bad filenames
	if (not fn) return false
	current_filename = fn
	stale_filename = nil
	window{
		title = current_filename:basename(),
		location = current_filename, 
		unique_location = true
	}
	update_menu_items() -- (auto) shown on /ram/cart files
	return true -- could set
end



--[[
	wrangle_working_file() // the user-facing api

	untitled_filename is also used to specifiy default extension (foo.pal -> auto appends .pal on save)

]]
function custom_wrangle_working_file(save_state, load_state, untitled_filename, get_hlocation, set_hlocation)

	local w = {
		save = function(w)
			-- printh("## save "..current_filename)
			local content, meta = save_state()
			if (not meta) meta = {}

			local err = store(current_filename, content, meta)

			if (err) then
				return err
			end

			-- use callback to modify current_filename with new location suffix (e.g. foo.lua#23 line number changes)

			if (get_hlocation) then
				w.update_hloc(w, get_hlocation())
			end


			last_known_filename = current_filename
			last_known_meta = fetch_metadata(current_filename)

		end,

		load = function(w)
			local content, meta, hloc = fetch(current_filename)

			load_state(content, meta)
			if (set_hlocation) set_hlocation(hloc)

			last_known_filename = current_filename
			last_known_meta = unpod(pod(meta))

			return content, meta
		end,


		update_hloc = function(w, newloc)

			newloc = tostring(newloc) -- could be a number
			if (type(newloc) ~= "string") return

			local old_filename = current_filename
			current_filename = split(current_filename, "#", false)[1].."#"..newloc
			if (current_filename ~= old_filename) then
				-- tell wm new location
				--printh("telling wm new location: "..current_filename)
				window{location = current_filename}

				if (set_hlocation) set_hlocation(newloc) -- callback that e.g. changes cursor position
			end

		end


	}

	untitled_filename = untitled_filename or "untitled.pod"
	
	
	-- derive current_file
	
	cd(_env().path)

	-- look for current filename first in environment (location) and then on commandline

	current_filename = untitled_filename

	if not fullpath(current_filename) then
		-- can't resolve: use /appdata. happens when e.g. /ram/cart is not available because sandboxed
		current_filename = "/appdata/"..untitled_filename:basename()
	end


	if (_env().location) then
		current_filename = _env().location
	elseif (_env().argv and _env().argv[1]) then
		current_filename = _env().argv[1]
	end

	current_filename = fullpath(current_filename)

	local current_file_exists = fstat(current_filename)

	-- when file doesn't exist, w:load() also serves to init state by calling load_state(nil, ..)
	-- to do: can this fail?
	w:load()

	-- create
	if (not current_file_exists) then
		w:save() -- don't care about result
	end


	-- tell window manager working file
	-- ** [currently] needs to happen after creating window **

	window{
		title = current_filename:basename(),
		location = current_filename, 
		unique_location = true
	}



	------ install events ------

	-- invoked directly from app menu, and by wm when about to run / save cartridge
	on_event("save_file", function(msg)
		-- can optionally 
		if (msg.filename) then
			current_filename = msg.filename
		end

		-- refuse to save over external changes. to do: nicer way to handle this
		if (stale_filename == current_filename) then
			notify(stale_filename..": skipped saving over external changes")
			return
		end

		local err = w:save()
		
		if (err) then
			notify(err)
	
		-- show message only when NOT auto-saving /ram/cart files
		elseif (sub(current_filename, 1, 10) ~= "/ram/cart/") then

			if (fullpath(current_filename):sub(1,8) == "/system/") then
				notify("saved "..current_filename.." ** warning: changes to /system/ not written to disk **")
			else
				notify("saved "..current_filename)

			end
		end

	end)

	-- invoked by filenav intention
	on_event("open_file", function(msg)
		set_current_filename(msg.filename)
		w:load()
	end)

	on_event("jump_to_hloc", function(msg)
		local newloc_str = msg.hloc and "#"..msg.hloc or ""

		if (w.set_hlocation) w:set_hlocation(newloc)
		local old_filename = current_filename
		current_filename = split(current_filename, "#", false)[1]..newloc_str
		if (current_filename ~= old_filename) then
			-- tell wm new location
--			printh("request setting window location: "..current_filename)
			window{location = current_filename}
		end

	end)

	-- invoked by filenav intention
	on_event("save_file_as", function(msg)
		
		if (set_current_filename(msg.filename)) then

			-- 0.1.0c: automatically add extension if none is given
			if (not current_filename:ext() and untitled_filename:ext()) then
				set_current_filename(current_filename.."."..untitled_filename:ext())
			end

			local err = w:save()
			if (err) then
				notify(err)			
			else
				notify("saved as "..current_filename) -- show message even if cart file
			end
		end
		
	end)


	-- autosave cart file when lose focus

	on_event("lost_focus", function(msg)
		if (sub(current_filename, 1, 10) == "/ram/cart/") then
			w:save()
		end
	end)

	
	--[[
		when gaining focus, check that file being edited has a newer version on disk
		if so, warn that external changes are detected (user might want to reload)
	]]
	on_event("gained_focus", function(msg)
	
		if split(last_known_filename,"#",false)[1] == split(current_filename,"#",false)[1] then
			local md1 = fetch_metadata(current_filename)
			if (md1 and md1.revision) then
--				printh("revision on disk:"..(md1.revision or -1).."   last_known_meta: "..pod(last_known_meta))
				if (last_known_meta and last_known_meta.revision and last_known_meta.revision < md1.revision) then
					-- to do: how to disable autosave / 
					stale_filename = current_filename
					--notify("warning: external changes detected -- this version is stale")
					notify("warning: external changes detected")
				end
			end
		end
	end)

	update_menu_items()

	return w
end







:: src/files.lua
--[[pod_format="raw",created="2025-03-08 09:21:19",modified="2025-03-20 14:00:46",revision=608]]
-- Loading and saving -------------------------------------------------------------


function save_working_file()
	local ext = pwf():ext()
	if ext == "hex" or ext == "txt" then
		return save_hex_file()
	else
		if ext != "pal" then
			notify("unknown file extension: saved using default file format")
		end
		return save_pal_file()
	end
end


function load_working_file(data, metadata)
	if fstat(pwf()) ~= "file" then
		-- This is a new file
		create_metadata()
		is_new_file = true
		return
	end

	metadata = metadata or {}
	local ext = pwf():ext()
	if ext == "pal" then
		load_pal_file(data, metadata or {})
		if undo_stack then undo_stack:reset() end
		send_palette()

	elseif ext == "hex" or ext == "txt" then
		if metadata.okpal_version then
			current_import_choice = "overwrite"
			load_hex_file(data, metadata or {})
			if undo_stack then undo_stack:reset() end
			send_palette()
		else
			imported_hex_file = { data = data, metadata = metadata }
		end

	else
		notify("unkown file extension: OkPal can only load \".pal\" and \".hex\" palettes")
	end
end


-- Metadata ----------------------------------------------------------------------


function create_metadata()
	local metadata = {}
	metadata.okpal_version = okpal_version
	metadata.icon = userdata("u8",16,16,"0001010101010101010101000000000000010707070707070707060100000000000107070707070707070606010000000001070707070707070706060601000000010707070707070707060606060100000107070707070707070707070701000001070707070707070707070707010000010707060601010d0d01010707010000010707060601010d0d010107070100000107070101070706060d0d07070100000107070101070706060d0d07070100000107070d0d01010d0d060607070100000107070d0d01010d0d060607070100000107070707070707070707070701000001070707070707070707070707010000010101010101010101010101010100")
	metadata.bg_color = bg_color
	metadata.blackest_color = blackest_color
	metadata.whitest_color = whitest_color
	metadata.hidden_toggles = hidden_toggles
	metadata.hidden = copy(hidden)
	metadata.locked = copy(locked)
	metadata.pickers_mode = pickers_mode
	metadata.hue_offset = hue_offset
	metadata.test_mode = test_mode
	metadata.test_cube_colors = copy(test_cube_colors)
	metadata.test_ramp_colors = test_ramp_colors and test_ramp_colors:convert("u8")
	return metadata
end


function load_metadata(metadata)
	metadata = metadata or {}
	bg_color = metadata.bg_color or 0
	blackest_color = metadata.blackest_color or 0
	whitest_color = metadata.whitest_color or 7
	
	if type(metadata.hidden_toggles) == "table" then
		hidden_toggles = metadata.hidden_toggles
	else
		hidden_toggles = {}
		for row = 0, 3 do
			hidden_toggles[row] = false
		end
	end
	
	if type(metadata.hidden) == "table" then
		hidden = metadata.hidden
	else
		hidden = {}
		for c = 0, 63 do
			hidden[c] = false
		end
	end
	
	if type(metadata.locked) == "table" then
		locked = metadata.locked
	elseif pwf() == "/ram/cart/pal/0.pal" then
		-- This only occurs when a default starting file
		-- is created.
		for c = 0, 63 do
			locked[c] = c <= 31
		end
	else
		locked = {}
		for c = 0, 63 do
			locked[c] = false
		end
	end

	if type(metadata.pickers_mode) == "string" then
		pickers_mode = metadata.pickers_mode
	else
		pickers_mode = "linear_hue"
	end
	
	if type(metadata.hue_offset) == "number" then
		hue_offset = metadata.hue_offset
	else
		hue_offset = 0.0
	end

	if type(metadata.test_mode) == "string" then
		test_mode = metadata.test_mode
	else
		test_mode = "cubes"
	end

	if type(metadata.test_cube_colors) == "table" then
		test_cube_colors = copy(metadata.test_cube_colors)
	else
		test_cube_colors = copy(default_test_cube_colors)
	end
	
	if type(metadata.test_ramp_colors) == "userdata" then
		test_ramp_colors = metadata.test_ramp_colors:convert("u8")
	else
		test_ramp_colors = default_test_ramp_colors:convert("u8")
	end
end


-- Load and save pal files -------------------------------------------------------


function load_pal_file(data, metadata)
	if data then
		if type(data) == "userdata" and data:width() == 64 then
			for c = 0, 63 do
				if data[c] then
					set_color(c, data[c])
				end
			end
		else
			notify("unable to load working file")
			return
		end
	else
		-- New file
	end
	rebuild_pal()
	load_metadata(metadata)
	update_hidden_toggles()
end


function save_pal_file()
	local output = userdata("i32", 64)
	for c = 0, 63 do
		output:set(c, get_color(c))
	end
	return output, create_metadata()
end


-- Load and save hex files ---------------------------------------------------------


function load_hex_file(data, metadata)
	if type(data) == "string" then
		local lines = split(data, "\n", false)
		local codes = {}
		for l in all(lines) do
			local code = tonum("0x" .. l:gsub("%s",""))
			if type(code) == "number" then
				codes[#codes + 1] = code
			elseif code then
				notify("error importing hex file")
			end
		end
		local start = 0
		if current_import_choice == "dont_clobber" then
			-- TODO: put in separate function and add menu item
			for c = 0, 32 do
				set_color(c, peek4(0x5000 + 4 * (64 + c)))
			end
			start = 32
		end
		if #codes > 64 - start then
			notify("*** not enough space to import all the colors ***")
		end
		for c = start, 63 do
			if codes[c - start + 1] then
				set_color(c, codes[c - start + 1])
			else
				set_color(c, 0x000000)
			end
		end
		rebuild_pal()
	elseif data then
		notify("import hex file: unkown type: " .. type(data))
	end

	load_metadata(metadata)
	if current_import_choice == "dont_clobber" then
		active_color = nil
		for c = 0, 31 do
			hidden[c] = true
			locked[c] = true
		end
		hidden_toggles[0] = true
		hidden_toggles[1] = true
		blackest_color = 0
		whitest_color = 7
		bg_color = 0
	else
		local best_black, best_white = find_blackest_and_whitest()
		blackest_color = metadata.blackest_color or best_black
		whitest_color = metadata.whitest_color or best_white
		bg_color = metadata.bg_color or blackest_color
	end
	update_hidden_toggles()
end


function save_hex_file()
	-- Don't export trailing black colors
	local fin = 63
	while fin > 0 and get_color(fin) == 0 do
		fin -= 1
	end
	
	local output = ""
	for c = 0, fin do
		output ..= color_to_hex(get_color(c)) .. "\n"
	end
	return output, { metadata_format="none" }
end

:: src/globals.lua
--[[pod_format="raw",created="2024-04-03 09:15:53",modified="2025-03-22 08:23:33",revision=6294]]
current_import_choice = "dont_clobber"

undo_stack = nil

padlock_flashing = false
padlock_flashing_time = 0

circling_anim_timer = 0

gui = nil
gui_changed = false

is_new_file = false
select_file_for_export = false
imported_hex_file = nil

blink_timer = 180 + math.random(1, 6) * 90
blink_eye = math.random(0, 3)
crying_a_timer = 0
crying_a_done = false

help_current_line = 1


-- Saved in settings ----------------------------------------------------------


user_settings = {
	send_palette = true,
	show_color_names = true,
	show_color_band = true,
	dont_blink = false,
	no_jump_scares = false,
}


-- Saved in undo stack ----------------------------------------------------------


pal_okhsl = {}
pal_code = {}

-- and also `test_cube_colors`? or not?


-- Saved in metadata --------------------------------------------------------------


okpal_version = "1.2.2"

active_color = nil
bg_color = 0 -- TODO: what about fg?
blackest_color = 0 -- TODO: remove?
whitest_color = 7 -- TODO: remove?

hidden_toggles = { [0] = false, false, false, false }
hidden = {}
for i = 0, 63 do hidden[i] = false end
locked = {}
for i = 0, 63 do locked[i] = i <= 31 end

pickers_mode = "linear_hue"
hue_offset = 0.0

test_mode = "cubes"
test_cube_colors = nil
test_ramp_colors = nil


-- Constants ----------------------------------------------------------------------


default_test_cube_colors = {
	[0] = 
	{15, 31, 4},
	{31, 4, 20},
	{4, 20, 21},
	--
	{10, 9, 25},
	{9, 25, 24},
	{8, 24, 2},
	--
	{26, 11, 27},
	{11, 27, 3},
	{27, 3, 19},
	--
	{28, 17, 19},
	{28, 12, 16},
	{12, 16, 1},
	--
	{6, 29, 13},
	{29, 13, 18},
	{13, 18, 1},
	--
	{7, 23, 14},
	{23, 14, 13},
	{14, 30, 18},
	--
	{7, 6, 22},
	{6, 22, 5},
	{22, 5, 21},
	--
	{1, 1, 1},
	{1, 1, 1},
	{1, 1, 1},
	--
}

default_test_ramp_colors = userdata("u8", 10, 27, 0)
default_test_ramp_colors:set(
	0, 0,
	 0, 24,  8, 25,  9, 10, 26, 11, 27,  0,
	 6,  0,  0,  0,  0,  0,  0,  0,  3,  0, 
	22,  0,  0,  0,  0,  0,  0,  0, 19,  0, 
	 5,  0,  0,  0,  0,  0,  0,  0,  1,  0, 
	13,  0,  0,  0,  0,  0,  0,  0, 16,  0, 
	29,  0,  0,  0,  0,  0,  0,  0, 17,  0, 
	23,  0,  0,  0,  0,  0,  0,  0, 12,  0, 
	14,  0,  0,  0,  0,  0,  0,  0, 28,  0, 
	30, 18,  2, 21, 20,  4, 31, 15,  7,  0,
	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	 0, 20,  4, 31, 15,  8, 24,  2,  0,  0,
	21,  5, 22,  6,  7, 23, 14, 30,  0,  0,
	 1, 16, 17, 12, 28, 29, 13, 18,  0,  0,
	19,  3, 27, 11, 26, 10,  9, 25,  0,  0
)


:: src/gui.lua
--[[pod_format="raw",created="2024-03-31 05:58:06",modified="2025-03-22 08:23:33",revision=9743]]
function generate_gui()
	gui = create_gui()
	generate_palette_gui()
end


-----------------------------------------------------------------------------------


local modal = nil


function open_modal(width, height, autoclose)
	if modal ~= nil then
		--TODO: !!!
		return
	end

	modal = gui:attach {
		x = 0, y = 0,
		width = gui.width, height = gui.height,
		autoclose = autoclose or false,
		click = function(self, msg)
			if msg.has_pointer and self.autoclose then
				close_modal()
			end
		end
	}
	local el = modal:attach {
		x = (modal.width - width) // 2, y = (modal.height - height) // 2,
		width = width, height = height,
		draw = function(self)
			clip()
			rect(-3, -3, self.width+3, self.height+3, bg_color)
			rectfill(-2, -2, self.width+2, self.height+2, outline_color())
			rect(-1, -1, self.width+1, self.height+1, bg_color)
		end,
	}
	return el
end


function has_modal()
	return modal ~= nil
end


function refresh_modal()
	if has_modal() then
		gui:attach(modal)
	end
end


function close_modal()
	if modal then
		modal:detach()
	end
	modal = nil
	gui_changed = true -- necessary after closing settings dialog
end


-----------------------------------------------------------------------------------


function create_label(el)
	el.width = el.width or (5 * #el.label + 4)
	el.height = el.height or 9
	gui:new(el)
	function el:draw()
		print(self.label, 0, 0, self.fg or outline_color())
	end
	return el
end


-----------------------------------------------------------------------------------


function create_button(el)
	local label = el.label or "---"
	el.width = el.width or (#label * 5 + 8 + 8)
	el.height = el.height or 16
	el.cursor = "pointer"

	function el:draw(msg)
		local fg = self.fg or bg_color
		line(2, 0, self.width - 3, 0, fg)
		pset(1, 1, fg)
		line(2, self.height - 1, self.width - 3, self.height - 1, fg)
		pset(self.width - 2, 1, fg)
		line(0, 2, 0, self.height - 3, fg)
		pset(1, self.height - 2, fg)
		line(self.width - 1, 2, self.width - 1, self.height - 3, fg)
		pset(self.width - 2, self.height - 2, fg)
		local pressed = msg.has_pointer and self.clicked
		if pressed then
			rectfill(1, 1, self.width - 2, self.height - 2, fg)
		end
		print(self.label or "---", 9, 4, pressed and outline_color() or fg)
	end
	
	function el:click()
		self.clicked = true
	end
	
	function el:release(msg)
		self.clicked = false
		if (msg.has_pointer and self.act) self.act()
	end	

	return el
end


function create_action_button(el)
	local s = get_spr(el.sprite)
	el.width = s:width() or 16
	el.height = s:height() or 16
	el.cursor = "pointer"

	function el:draw(msg)
		pal(7, outline_color())
		local s = el.sprite
		if el.active and not el:active() then
			s += 2
		elseif el.clicked and msg.has_pointer then
			s += 1
		end
		spr(s, 0, 0)
		pal(7, 7)
	end
	
	function el:click()
		self.clicked = true
	end
	
	function el:release(msg)
		self.clicked = false
		if (msg.has_pointer and self.act) self.act()
	end	

	return el
end


-----------------------------------------------------------------------------------


function create_field(el)
	el.cursor = "pointer"

	function el:draw()
		local str = type(self.get == "function") and self:get() or "---"
		local fg = type(self.get_fg == "function") and self:get_fg() or outline_color()
		local prefix = self.small_font and "\014" or ""
		if self:has_keyboard_focus() then
			local suffix = (time() % 0.666 > 0.333) and "\016" or ""
			str =  self.str .. suffix
			print(prefix .. str, 1, 1, fg)
			clip()
			rect(-1, -1, self.width, self.height, fg)
		else
			local ww,hh = print(prefix .. str, 0, -1000)
			print(prefix .. str, self.width - ww - 1, 1, fg)
		end
	end

	function el:click()
		self:set_keyboard_focus(true)
		readtext(true)
		self.str = "" -- starting editing new string
	end

	el.custom_update = el.update
	function el:update()
		self:custom_update()
		if self:has_keyboard_focus() then
			while peektext() do
				self.str = self.str .. readtext()
			end
			if keyp("backspace") then
				self.str = sub(self.str, 1, -2)
			end
			if keyp("enter") then
				if type(self.set) == "function" then
					self:set(self.str)
				end
				self:set_keyboard_focus(false)
			end
		end
	end

--	gui:new(el)

	return el
end


-----------------------------------------------------------------------------------


function create_checkbox(el)
	el.width = el.width or (16 + 5 * #el.label + 4)
	el.height = el.height or 12
	el.cursor = "pointer"
	el.get = el.get or function(self) return self.checked end
	el.toggle = el.toggle or function(self) self.checked = not self.checked end
	gui:new(el)

	function el:draw()
		local fg = self.fg or outline_color()
		local checked = self:get()
		pal(7, fg)
		spr(checked and 49 or 48, 0, 0)
		pal(7, 7)
		print(el.label, 16, 1, fg)
	end
	
	function el:release(msg)
		if msg.has_pointer then
			self:toggle()
		end
	end	

	return el
end


------------------------------------------------------------------------------


function create_radio_button(el)
	el.width = 188
	el.height = 12 -- TODO: count the lines?
	el.cursor = "pointer"
	
	function el:draw()
		local fg = self.fg or bg_color
		local choices = self.parent.choices
		local checked = choices and choices[self.group] == self.key
		pal(7, fg)
		spr(checked and 51 or 50, 0, 0)
		pal(7, 7)
		print(el.label, 15, 1, fg)
	end
	
	function el:tap()
		if not self.parent.choices then
			self.parent.choices = {}
		end
		self.parent.choices[self.group] = self.key
	end
	
	return el
end


-- Utility functions ----------------------------------------------------------------


function outline_color()
	if pal_okhsl[bg_color].l < 0.5 then
		return whitest_color
	else
		return blackest_color
	end
end


function contrast_color(c)
	return (pal_okhsl[c].l < 0.5) and whitest_color or blackest_color
end


function contrast_color_darker(c)
	return (pal_okhsl[c].l < 0.15) and whitest_color or blackest_color
end


function distance(ax, ay, bx, by)
	return math.sqrt((ax - bx)^2 + (ay - by)^2)
end
:: src/gui_alt_sliders.lua
--[[pod_format="raw",created="2025-03-11 11:29:57",modified="2025-03-22 08:23:33",revision=1994]]
local rectangle_width = 375
local rectangle_height = 98
local rectangle_border = 7
local rectangle_inner_width = rectangle_width - 2 * rectangle_border
local rectangle_inner_height = rectangle_height - 2 * rectangle_border


-------------------------------------------------------------------------------


local function hv_coords(c, ordinate)
	local hue = (pal_okhsl[c].h + hue_offset) % 1.0
	local v = pal_okhsl[c][ordinate]
	local x = rectangle_border + hue * rectangle_inner_width
	local y = rectangle_border + rectangle_inner_height - v * rectangle_inner_height
	return x, y
end


local function coords_hv(x, y)
	local hue = (x - rectangle_border) / rectangle_inner_width
	hue = (hue - hue_offset) % 1.0
	local v = 1.0 - ((y - rectangle_border) / rectangle_inner_height)
	return hue, v
end


local function h_coords(hue)
	hue = (hue % 1.0)
	local x = rectangle_border + hue * rectangle_inner_width
	return x
end


---------------------------------------------------------------------------------


function create_rectangle_picker(el)
	el.ordinate = el.ordinate or "l"
	el.width = rectangle_width
	el.height = rectangle_height
	el.drag_delta = nil
		
	function el.draw(self, _msg)
		rect(
			rectangle_border - 1, rectangle_border - 1, 
			rectangle_border + rectangle_inner_width + 1, rectangle_border + rectangle_inner_height + 1, 
			outline_color()
		)
		for c = 0, 63 do
			if not hidden[c] and pal_okhsl[c].l != 0 then
				local x, y = hv_coords(c, self.ordinate)
				pal(14, c)
				spr(11, x - 5, y - 5)
				pal(14, 14)
			end
		end
		if active_color and not hidden[active_color] then
			local x, y = hv_coords(active_color, self.ordinate)
			pal(7, outline_color())
			pal(14, active_color)
			spr(
				self.drag_delta and 13 or 12,
				x - 5, y - 5,
				x + 5, y + 5
			)
			pal(14, 14)
			pal(7, 7)
			if circling_anim_timer > 0 then
				local delta = math.floor(0.5 + 5 + 10 * circling_anim_timer * circling_anim_timer)
				oval(
					x - delta, y - delta,
					x + delta, y + delta,
					outline_color()
				)
			end
		end
		clip()
		pal(7, outline_color())
		spr(self.ordinate == "l" and 22 or 23, -11, self.height - 74)
		pal(7, 7)
	end
	
	function el.hover(self, msg)
		self.cursor = 1
		if active_color and not hidden[active_color] then
			local ax, ay = hv_coords(active_color, self.ordinate)
			if distance(ax, ay, msg.mx, msg.my) < 6 then
				self.cursor = "pointer"
			end
		end
		-- In reverse order to prioritize colors on top
		for c = 63, 0, -1 do
			local cx, cy = hv_coords(c, self.ordinate)
			if distance(cx, cy, msg.mx, msg.my) < 5 and not hidden[c] and pal_okhsl[c].l != 0 then
				self.cursor = "pointer"
			end
		end
	end
	
	function el.click(self, msg)
		if active_color and not hidden[active_color] then
			local ax, ay = hv_coords(active_color, self.ordinate)
			if distance(ax, ay, msg.mx, msg.my) < 6 then
				undo_stack:checkpoint()
				mouselock(0x4|0x8, 1.0, 0.25)
				self.cursor = 0
				self.drag_delta = { ox = ax, oy = ay, x = 0, y = 0 }
				return
			end
		end
		
		active_color = nil
		-- In reverse order to prioritize colors on top
		for c = 63, 0, -1 do
			local cx, cy = hv_coords(c, self.ordinate)
			if distance(cx, cy, msg.mx, msg.my) < 5 and not hidden[c] and pal_okhsl[c].l != 0 then
				undo_stack:checkpoint()
				active_color = c
				local ax, ay = hv_coords(active_color, self.ordinate)
				mouselock(0x4|0x8, 1.0, 0.25)
				self.cursor = 0
				self.drag_delta = { ox = ax, oy = ay, x = 0, y = 0 }
				return
			end
		end
		self.drag_delta = nil
	end
	
	function el.drag(self, msg)
		if (not active_color) return
		if (not self.drag_delta) return
		if locked[active_color] then
			padlock_flashing = true
		elseif msg.mb & 0x07 then
			self.drag_delta.x += msg.dx
			self.drag_delta.y += msg.dy
			local ax = self.drag_delta.ox + self.drag_delta.x * 0.25
			local ay = self.drag_delta.oy + self.drag_delta.y * 0.25
			local hue, v = coords_hv(ax, ay)
			hue = max(0.0, hue)
			if msg.mb & 2 ~= 0 then hue = nil end
			if msg.mb & 4 ~= 0 then v = nil end
			local sat = self.ordinate == "s" and v or nil
			local lum = self.ordinate == "l" and v or nil
			change_color(active_color, hue, sat, lum)
		end
	end
	
	function el.release(self, msg)
		send_palette()
		self.drag_delta = nil
		padlock_flashing = false
		padlock_flashing_time = 0
		mouselock(false)
		self.cursor = nil
	end
	
	function el.mousewheel(self, msg)
		hue_offset += (msg.wheel_x / 360.0) % 1.0
		hue_offset += (4 * msg.wheel_y / 360.0) % 1.0
--		if not active_color or locked[active_color] then
--			return
--		end
--		local v = pal_okhsl[active_color][self.ordinate]
--		v = mid(0.0, v + (msg.wheel_y / 100.0), 1.0)
--		local sat = self.ordinate == "s" and v or nil
--		local lum = self.ordinate == "l" and v or nil
--		undo_stack:checkpoint()
--		change_color(active_color, hue, sat, lum)
	end

	return el
end


--------------------------------------------------------------------------------


function create_hue_knob(el)
	el.width = rectangle_width
	el.height = 9
	
	function el.draw(self, _msg)
		if active_color and not hidden[active_color] then
			local ax, _ = hv_coords(active_color, "l")
			pal(7, outline_color())
			pal(13, 0)
			spr(5, ax - 4, 0)
			pal(13, 13)
			pal(7, 7)
		end
	end	
	
	function el.hover(self, msg)
		self.cursor = 1
		if active_color and not hidden[active_color] then
			local ax, _ = hv_coords(active_color, "l")
			if msg.mx and msg.mx >= ax - 4 and msg.mx <= ax + 4 then
				self.cursor = "grab"
			end
		end
	end

	function el.click(self, msg)
		undo_stack:checkpoint()
		if active_color and not hidden[active_color] then
			local ax, _ = hv_coords(active_color, "l")
			if msg.mx and msg.mx >= ax - 4 and msg.mx <= ax + 4 then
				mouselock(0x4|0x8, 1.0, 0.25)
				self.cursor = 0
				self.drag_delta = { ox = ax, x = 0 }
			end
		end
	end
	
	function el.drag(self, msg)
		if (not active_color) return
		if (not self.drag_delta) return
		if locked[active_color] then
			padlock_flashing = true
		else
			self.drag_delta.x += msg.dx
			local ax = self.drag_delta.ox + self.drag_delta.x * 0.25
			local hue, _ = coords_hv(ax, 0)
			hue = max(0.0, hue)
			change_color(active_color, hue, nil, nil)
		end
	end
	
	function el.release(self, msg)
		send_palette()
		self.drag_delta = nil
		padlock_flashing = false
		padlock_flashing_time = 0
		mouselock(false)
		self.cursor = 1
	end
			
	return el
end


--------------------------------------------------------------------------------


function create_val_knob(el)
	el.ordinate = el.ordinate or "l"
	el.width = 9
	el.height = rectangle_height
	
	function el.draw(self, _msg)
		if active_color and not hidden[active_color] then
			local _, ay = hv_coords(active_color, self.ordinate)
			pal(7, outline_color())
			pal(13, active_color)
			spr(6, 0, ay - 4)
			pal(13, 13)
			pal(7, 7)
		end
	end	
	
	function el.hover(self, msg)
		self.cursor = 1
		if active_color and not hidden[active_color] then
			local _, ay = hv_coords(active_color, self.ordinate)
			if msg.my and msg.my >= ay - 4 and msg.my <= ay + 4 then
				self.cursor = "grab"
			end
		end
	end

	function el.click(self, msg)
		undo_stack:checkpoint()
		if active_color and not hidden[active_color] then
			local _, ay = hv_coords(active_color, self.ordinate)
			if msg.my and msg.my >= ay - 4 and msg.my <= ay + 4 then
				mouselock(0x4|0x8, 1.0, 0.25)
				self.cursor = 0
				self.drag_delta = { oy = ay, y = 0 }
			end
		end
	end
	
	function el.drag(self, msg)
		if (not active_color) return
		if (not self.drag_delta) return
		if locked[active_color] then
			padlock_flashing = true
		else
			self.drag_delta.y += msg.dy
			local ay = self.drag_delta.oy + self.drag_delta.y * 0.25
			local _, v = coords_hv(0, ay)
			local sat = self.ordinate == "s" and v or nil
			local lum = self.ordinate == "l" and v or nil
			change_color(active_color, nil, sat, lum)
		end
	end
	
	function el.release(self, msg)
		send_palette()
		self.drag_delta_y = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end
			
	return el
end


--------------------------------------------------------------------------------


function create_color_names(el)
	el.width = rectangle_inner_width + 1
	el.height = 8
	function el.draw(self, msg)
		local x = math.floor(0.5 + h_coords(hue_offset))
		spr(46, x - rectangle_border - rectangle_inner_width - 1, 0)
		spr(46, x - rectangle_border, 0)
	end
	return el
end


--local colors = {
--	{ name = "rose", hue = 2.0 / 360.0 },
--	{ name = "red", hue = 29.0 / 360.0 },
--	{ name = "orange", hue = 53.0 / 360.0 },
--	{ name = "yellow", hue = 110.0 / 360.0 },
--	{ name = "green", hue = 142.0 / 360.0 },
--	{ name = "cyan", hue = 195.0 / 360.0 },
--	{ name = "blue", hue = 264.0 / 360.0 },
--	{ name = "violet", hue = 294.0 / 360.0 },
--	{ name = "purple", hue = 328.0 / 360.0 },
----	{ name = "magenta", hue = 328.0 / 360.0 },
--}
--
--
--function create_hue_ruler(el)
--	el.width = rectangle_inner_width
--	el.height = 8
--	function el.draw(self, msg)
--		for col in all(colors) do
--			local x = h_coords(hue_offset + col.hue)
--			print("\014" .. col.name, x - (#col.name * 2) - rectangle_border, 0)
--		end
--	end
--	return el
--end


--------------------------------------------------------------------------------


function init_color_band()
	-- Create the hue gradient palette
	local hue_step = 1.0 / 62.0
	local hue = 0
	for c = 1, 63 do
		if c ~= 1 and c ~= 7 then
			local color_code = oklab.okhsl_to_color({ h = hue, s = 1.0, l = 0.6 })
			poke4(0x5300 + 4 * c, color_code)
			hue += hue_step
		end
	end
	-- Create the sprite for the band
	local band = get_spr(44)
	set_draw_target(band)
	local width = band:width()
	local flat = (width // 61) + 1
	for x = 0, band:width() - 1 do
		local c = 1 + (x // flat )
		if c >= 1 then c += 1 end
		if c >= 7 then c += 1 end
		line(x, 2, x, 9, c)
	end
	set_draw_target()
end


function show_color_band()
	poke(0x5440, 0b11111111, 0b00001111)
end


function hide_color_band()
	poke(0x5440, 0b00000000, 0b00000000)
end


function create_color_band(el)
	el.width = rectangle_inner_width + 1
	el.height = 8
	function el.draw(self, _msg)
		local x = math.floor(0.5 + h_coords(hue_offset))
		spr(44, x - rectangle_border - rectangle_inner_width - 1, 0)
		spr(44, x - rectangle_border, 0)
	end
	return el
end

--------------------------------------------------------------------------------


function create_hue_scrubber(el)
	el.width = get_spr(47):width()
	el.height = get_spr(47):height()
	el.cursor = "grab"
	gui:new(el)
	function el.draw(self, _msg)
		pal(7, outline_color())
		spr(47, 0, 0)
		pal(7, 7)
	end
	function el.click(self, msg)
		self.drag_delta = msg.mx
		self.drag_origin = hue_offset
	end
	function el.drag(self, msg)
		if self.drag_delta then
			local dh, _ = coords_hv(msg.mx, 0) - coords_hv(self.drag_delta, 0)
			hue_offset = self.drag_origin + dh
		end
	end
	function el.release(self, msg)
		self.drag_delta = nil
	end
	function el.tap(self, msg)
		hue_offset = 0.0
	end
	return el
end
:: src/gui_help.lua
--[[pod_format="raw",created="2025-03-07 10:21:37",modified="2025-03-07 17:37:27",revision=440]]
local text_view

function open_help()
	local el = open_modal(270, 250, true)
	if not el then
		return
	end
	text_view = el:attach(create_text_view { x = 10, y = 0, width = 250, height = 250 })
	text_view:set_text(fetch("manual.txt"))
end


function create_text_view(el)
	el.lines = {}

	function el:set_text(text)
		el.lines = soft_wrap(text, self.width)
	end

	function el:draw(msg)
		cursor(0, 0)
		color(bg_color)
		local l = help_current_line
		local y = 0
		while y < self.height do
			print(self.lines[l])
			y += 11
			l += 1
		end
	end
	
	function el:mousewheel(msg)
		local nb_lines = self.height // 11
		help_current_line = mid(
			1,
			help_current_line - (msg.wheel_y * 3),	
			#self.lines - nb_lines
		)
	end	

	return el
end
:: src/gui_hexdialog.lua
--[[pod_format="raw",created="2025-03-05 12:06:52",modified="2025-03-11 16:50:38",revision=318]]
function open_import_hex_file_dialog()
	local el = open_modal(180, 100, false)
	el:attach(create_label { x = 50, y = 6, label = "Import \".hex\" file", fg = bg_color })
	el:attach(create_radio_button {
		x = 16, y = 36, 
		label = "Import after Picotron's colors",
		group = "import_hex",
		key = "dont_clobber",
	})
	el:attach(create_radio_button {
		x = 16, y = 56, 
		label = "Replace all colors",
		group = "import_hex",
		key = "overwrite",
	})
	el.choices = { import_hex = "dont_clobber" }
	el:attach(create_button {
		x = 110, y = 80,
		label = "Import",
		act = function() prepare_imported_hex(el) end
	})
end


function prepare_imported_hex(dialog)
	current_import_choice = dialog.choices.import_hex
	load_hex_file(imported_hex_file.data, imported_hex_file.metadata or {})
	clear_cube_colors()
	clear_ramp_colors()
	if (undo_stack) undo_stack:reset()
	send_palette()
	imported_hex_file = nil
	close_modal()
	gui_changed = true
end
:: src/gui_newfile.lua
--[[pod_format="raw",created="2025-03-05 08:57:06",modified="2025-03-12 09:49:40",revision=188]]
function open_new_file_dialog()
	local el = open_modal(180, 100, false)
	el:attach(create_label { x = 60, y = 6, label = "New Palette", fg = bg_color })
	el:attach(create_radio_button {
		x = 16, y = 36, 
		label = "Keep default colors",
		group = "new_palette",
		key = "keep_default",
	})
	el:attach(create_radio_button {
		x = 16, y = 56, 
		label = "Start with empty palette",
		group = "new_palette",
		key = "empty_palette",
	})
	el.choices = { new_palette = "keep_default" }
	el:attach(create_button {
		x = 110, y = 80,
		label = "Let's go!",
		act = function() prepare_new_file(el) end
	})
end


function prepare_new_file(dialog)
	if dialog.choices.new_palette == "empty_palette" then
		clear_colors()
	end
	close_modal()
end
:: src/gui_old_sliders.lua
--[[pod_format="raw",created="2025-03-17 19:49:11",modified="2025-03-22 08:23:33",revision=679]]
local circle_size = 190
local circle_border = 13
local circle_inner = circle_size - 2 * circle_border


local square_size = 190
local square_border = 7
local square_inner = square_size - 2 * square_border


------------------------------------------------------------------------------------


local function sl_coords(c)
	local sat = pal_okhsl[c].s
	local lum = pal_okhsl[c].l
	local x = square_border + sat * square_inner
	local y = square_border + square_inner - lum * square_inner
	return x, y
end


local function coords_sl(x, y)
	local sat = (x - square_border) / square_inner
	local lum = 1.0 - ((y - square_border) / square_inner)
	return sat, lum
end


-- Remove 0.25 to compensate for Picotron's angle origin,
-- and 29/360 to compensate for OkLab weird position of
-- the red color.
local angle_correction = 0.25 + 0.08


local function hs_coords(c)
	local hue = pal_okhsl[c].h
	local sat = mid(0.0, pal_okhsl[c].s, 1.0)
--	sat = ((sat * 3.0) / 4.0) + 0.25
	local a = angle_correction - hue
	local dx = sat * cos(a) * (circle_inner / 2)
	local dy = sat * sin(a) * (circle_inner / 2)
	local x = circle_border + (circle_inner / 2) + dx
	local y = circle_border + (circle_inner / 2) + dy
	return x, y
end


local function h_coords(c, radius_delta, hue_delta)
	local r = circle_inner + (radius_delta or 0)
	local hue = pal_okhsl[c].h + (hue_delta or 0)
	local a = angle_correction - hue
	local dx = cos(a) * (r / 2)
	local dy = sin(a) * (r / 2)
	local x = circle_border + (circle_inner / 2) + dx + 0.5
	local y = circle_border + (circle_inner / 2) + dy + 0.5
	return x, y
end


local function coords_hs(x, y)
	local dx = x - (circle_border + (circle_inner / 2))
	local dy = y - (circle_border + (circle_inner / 2))
	local hue = -atan2(dx, dy) + angle_correction
	dx = (2.0 * dx) / circle_inner
	dy = (2.0 * dy) / circle_inner
	local sat = sqrt(dx * dx + dy * dy) -- / (circle_inner / 2)
	return hue, sat
end


--local function coords_h(x, y)
--	local s = circle_size + 2 * circle_border
--	local r = s - 6
--	local dx = x - ((s / 2) + 0.5)
--	local dy = y - ((s / 2) + 0.5)
--	local hue = -atan2(dx, dy) + angle_correction
--	dx = (2.0 * dx) / r
--	dy = (2.0 * dy) / r
--	local sat = sqrt(dx * dx + dy * dy)
--	return hue, sat
--end


---------------------------------------------------------------------------------------


function create_hue_sat_picker(el)
	el.width = circle_size
	el.height = circle_size
	el.drag_delta = nil
	
	function el.draw(self, _msg)
		oval(
			circle_border - 1, circle_border - 1,
			circle_border + circle_inner + 1, circle_border + circle_inner + 1,
			outline_color()
		)
		line(circle_size \ 2 - 12, circle_size \ 2, circle_size \ 2 + 12, circle_size \ 2, outline_color())
		line(circle_size \ 2, circle_size \ 2 - 12, circle_size \ 2, circle_size \ 2 + 12, outline_color())
--		fillp(0b0101101001011010)
--		rectfill(circle_size \ 2 - 24, circle_size \ 2, circle_size \ 2 + 24, circle_size \ 2, 7)
--		rectfill(circle_size \ 2, circle_size \ 2 - 24, circle_size \ 2, circle_size \ 2 + 24, 7)
--		fillp()
		for c = 0, 63 do
			if not hidden[c] and pal_okhsl[c].l != 0 then
				local x, y = hs_coords(c)
				pal(14, c)
				spr(11, x - 5, y - 5)
				pal(14, 14)
			end
		end
		if active_color and not hidden[active_color] then
			-- Triangular knob
			local ax, ay = h_coords(active_color, 6, 0.0)
			local bx, by = h_coords(active_color, 24, -0.008)
			local cx, cy = h_coords(active_color, 24, 0.008)
			pal(7, outline_color())
			line(ax, ay, bx, by, 7)
			line(bx, by, cx, cy, 7)
			line(cx, cy, ax, ay, 7)
			pal(7)
			-- Active dot
			local x, y = hs_coords(active_color)
			pal(7, outline_color())
			pal(14, active_color)
			spr(
				self.drag_delta and 13 or 12,
				x - 5, y - 5
			)
			pal(14, 14)
			pal(7, 7)
			if circling_anim_timer > 0 then
				local delta = math.floor(0.5 + 5 + 10 * circling_anim_timer * circling_anim_timer)
				oval(
					x - delta, y - delta,
					x + delta, y + delta,
					outline_color()
				)
			end
		end
		clip()
		pal(7, outline_color())
		spr(14, 0, 138)
		pal(7, 7)
	end	
	
	function el.hover(self, msg)
		self.cursor = 1
		if active_color and not hidden[active_color] then
			local h, r = coords_hs(msg.mx, msg.my)
			local dh = h - pal_okhsl[active_color].h
			if dh < -0.5 then dh += 1.0 end
			if
				r >= 1.02 and r <= 1.18
				and abs(dh) <= 0.01
			then
				self.cursor = "grab"
			else
				local ax, ay = hs_coords(active_color)
				if distance(ax, ay, msg.mx, msg.my) < 6 then
					self.cursor = "pointer"
				end
			end
		end
		-- In reverse order to prioritize colors on top
		for c = 63, 0, -1 do
			local cx, cy = hs_coords(c, self.ordinate)
			if distance(cx, cy, msg.mx, msg.my) < 5 and not hidden[c] and pal_okhsl[c].l != 0 then
				self.cursor = "pointer"
			end
		end
	end
	
	function el.click(self, msg)
		local h, r = coords_hs(msg.mx, msg.my)
		local active_hue = active_color and pal_okhsl[active_color].h or 0
		local dh = h - active_hue
		if dh < -0.5 then dh += 1.0 end
		if
			(active_color and not hidden[active_color])
			and r >= 1.02 and r <= 1.18
			and abs(dh) <= 0.01
		then
			undo_stack:checkpoint()
			mouselock(0x4|0x8, 1.0, 0.25)
			self.cursor = 0
			local ax, ay = h_coords(active_color, 10)
			self.knob_drag_delta = { ox = ax, oy = ay, x = 0, y = 0 }
			return true
		elseif active_color and not hidden[active_color] then
			local ax, ay = hs_coords(active_color)
			if distance(ax, ay, msg.mx, msg.my) < 6 then
				undo_stack:checkpoint()
				local ax, ay = hs_coords(active_color)
				mouselock(0x4|0x8, 1.0, 0.25)
				self.cursor = 0
				self.drag_delta = { ox = ax, oy = ay, x = 0, y = 0 }
				return true
			end
		end
		active_color = nil
		-- In reverse order to prioritize colors on top
		for c = 63, 0, -1 do
			local cx, cy = hs_coords(c)
			if distance(cx, cy, msg.mx, msg.my) < 5 and not hidden[c] and pal_okhsl[c].l != 0 then
				undo_stack:checkpoint()
				active_color = c
				local ax, ay = hs_coords(active_color)
				mouselock(0x4|0x8, 1.0, 0.25)
				self.cursor = 0
				self.drag_delta = { ox = ax, oy = ay, x = 0, y = 0 }
				return true
			end
		end
		self.knob_drag_delta = nil
		self.drag_delta = nil
		return true
	end
	
	function el.drag(self, msg)
		if not active_color then return end
		if locked[active_color] then
			padlock_flashing = true
			return
		end
		if self.knob_drag_delta then
			self.knob_drag_delta.x += msg.dx
			self.knob_drag_delta.y += msg.dy
			local ax = self.knob_drag_delta.ox + self.knob_drag_delta.x * 0.25
			local ay = self.knob_drag_delta.oy + self.knob_drag_delta.y * 0.25
			local hue, sat = coords_hs(ax, ay)
			change_color(active_color, hue, nil, nil)
		elseif self.drag_delta then
			self.drag_delta.x += msg.dx
			self.drag_delta.y += msg.dy
			local ax = self.drag_delta.ox + self.drag_delta.x * 0.25
			local ay = self.drag_delta.oy + self.drag_delta.y * 0.25
			local hue, sat = coords_hs(ax, ay)
			if msg.mb == 4 then hue = nil end
			if msg.mb == 2 then sat = nil end
			change_color(active_color, hue, sat, nil)
			return true
		end
	end
	
	function el.release(self, msg)
		send_palette()
		self.knob_drag_delta = nil
		self.drag_delta = nil
		padlock_flashing = false
		padlock_flashing_time = 0
		mouselock(false)
		self.cursor = 1
	end

	return el
end


-------------------------------------------------------------------------------------


function create_sat_lum_picker(el)
	el.width = square_size
	el.height = square_size
	el.drag_delta = nil
		
	function el.draw(self, _msg)
		rect(
			square_border - 1, square_border - 1, 
			square_border + square_inner + 1, square_border + square_inner + 1, 
			outline_color()
		)
		for c = 0, 63 do
			local dh = pal_okhsl[c].h - pal_okhsl[active_color or 0].h
			if dh < -0.5 then dh += 1.0 end
			if not hidden[c] and pal_okhsl[c].l != 0 then -- and abs(dh) <= 0.1 then
				local x, y = sl_coords(c)
				pal(14, c)
				spr(11, x - 5, y - 5)
				pal(14, 14)
			end
		end
		if active_color and not hidden[active_color] then
			local x, y = sl_coords(active_color)
			pal(7, outline_color())
			pal(14, active_color)
			spr(
				self.drag_delta and 13 or 12,
				x - 5, y - 5,
				x + 5, y + 5
			)
			pal(14, 14)
			pal(7, 7)
			if circling_anim_timer > 0 then
				local delta = math.floor(0.5 + 5 + 10 * circling_anim_timer * circling_anim_timer)
				oval(
					x - delta, y - delta,
					x + delta, y + delta,
					outline_color()
				)
			end
		end
		clip()
		pal(7, outline_color())
		spr(15, -11, self.height + 12 - 64)
		pal(7, 7)
	end	
	
	function el.hover(self, msg)
		self.cursor = 1
		if active_color and not hidden[active_color] then
			local ax, ay = sl_coords(active_color)
			if distance(ax, ay, msg.mx, msg.my) < 6 then
				self.cursor = "grab"
			end
		end
		-- In reverse order to prioritize colors on top
		for c = 63, 0, -1 do
			local cx, cy = sl_coords(c, self.ordinate)
			if distance(cx, cy, msg.mx, msg.my) < 5 and not hidden[c] and pal_okhsl[c].l != 0 then
				self.cursor = "pointer"
			end
		end
	end
	
	function el.click(self, msg)
		if active_color and not hidden[active_color] then
			local ax, ay = sl_coords(active_color)
			if distance(ax, ay, msg.mx, msg.my) < 6 then
				undo_stack:checkpoint()
				mouselock(0x4|0x8, 1.0, 0.25)
				self.cursor = 0
				self.drag_delta = { ox = ax, oy = ay, x = 0, y = 0 }
				return
			end
		end
		active_color = nil
		-- In reverse order to prioritize colors on top
		for c = 63, 0, -1 do
			local cx, cy = sl_coords(c)
			if distance(cx, cy, msg.mx, msg.my) < 5 and not hidden[c] and pal_okhsl[c].l != 0 then
				undo_stack:checkpoint()
				active_color = c
				local ax, ay = sl_coords(active_color)
				mouselock(0x4|0x8, 1.0, 0.25)
				self.cursor = 0
				self.drag_delta = { ox = ax, oy = ay, x = 0, y = 0 }
				return
			end
		end
		self.drag_delta = nil
	end
	
	function el.drag(self, msg)
		if (not active_color) return
		if (not self.drag_delta) return
		if locked[active_color] then
			padlock_flashing = true
		else
			self.drag_delta.x += msg.dx
			self.drag_delta.y += msg.dy
			local ax = self.drag_delta.ox + self.drag_delta.x * 0.25
			local ay = self.drag_delta.oy + self.drag_delta.y * 0.25
			local sat, lum = coords_sl(ax, ay)
			if msg.mb == 2 then sat = nil end
			if msg.mb == 4 then lum = nil end
			change_color(active_color, nil, sat, lum)
		end
	end
	
	function el.release(self, msg)
		send_palette()
		self.drag_delta = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end

	return el
end


------------------------------------------------------------------------------------


function create_sat_knob(el)
	el.width = square_size
	el.height = 9
	
	function el.draw(self, _msg)
		if active_color and not hidden[active_color] then
			local ax, _ = sl_coords(active_color)
			pal(7, outline_color())
			pal(13, 0)
			spr(5, ax - 4, 0)
			pal(13, 13)
			pal(7, 7)
		end
	end	
	
	function el.hover(self, msg)
		self.cursor = 1
		if active_color and not hidden[active_color] then
			local ax, _ = sl_coords(active_color)
			if msg.mx and msg.mx >= ax - 4 and msg.mx <= ax + 4 then
				self.cursor = "grab"
			end
		end
	end

	function el.click(self, msg)
		undo_stack:checkpoint()
		if active_color and not hidden[active_color] then
			local ax, _ = sl_coords(active_color)
			if msg.mx and msg.mx >= ax - 4 and msg.mx <= ax + 4 then
				mouselock(0x4|0x8, 1.0, 0.25)
				self.cursor = 0
				self.drag_delta = { ox = ax, x = 0 }
			end
		end
	end
	
	function el.drag(self, msg)
		if (not active_color) return
		if (not self.drag_delta) return
		if locked[active_color] then
			padlock_flashing = true
		else
			self.drag_delta.x += msg.dx
			local ax = self.drag_delta.ox + self.drag_delta.x * 0.25
			local sat, lum = coords_sl(ax, 0)
			change_color(active_color, nil, sat, nil)
		end
	end
	
	function el.release(self, msg)
		send_palette()
		self.drag_delta_x = nil
		padlock_flashing = false
		padlock_flashing_time = 0
		self.cursor = 1
		mouselock(false)
	end
			
	return el
end


--------------------------------------------------------------------------------


function create_lum_knob(el)
	el.width = 9
	el.height = square_size
	
	function el.draw(self, _msg)
		if active_color and not hidden[active_color] then
			local _, ay = sl_coords(active_color)
			pal(7, outline_color())
			pal(13, active_color)
			spr(6, 0, ay - 4)
			pal(13, 13)
			pal(7, 7)
		end
	end	
	
	function el.hover(self, msg)
		self.cursor = 1
		if active_color and not hidden[active_color] then
			local _, ay = sl_coords(active_color)
			if msg.my and msg.my >= ay - 4 and msg.my <= ay + 4 then
				self.cursor = "grab"
			end
		end
	end

	function el.click(self, msg)
		undo_stack:checkpoint()
		if active_color and not hidden[active_color] then
			local _, ay = sl_coords(active_color)
			if msg.my and msg.my >= ay - 4 and msg.my <= ay + 4 then
				mouselock(0x4|0x8, 1.0, 0.25)
				self.cursor = 0
				self.drag_delta = { ox = ax, oy = ay, x = 0, y = 0 }
			end
		end
	end
	
	function el.drag(self, msg)
		if (not active_color) return
		if (not self.drag_delta) return
		if locked[active_color] then
			padlock_flashing = true
		else
			self.drag_delta.y += msg.dy
			local ay = self.drag_delta.oy + self.drag_delta.y * 0.25
			local sat, lum = coords_sl(0, ay)
			change_color(active_color, nil, nil, lum)
		end
	end
	
	function el.release(self, msg)
		send_palette()
		self.drag_delta_y = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end
			
	return el
end

:: src/gui_palette.lua
--[[pod_format="raw",created="2025-02-28 10:09:19",modified="2025-03-22 08:23:33",revision=4585]]
function generate_palette_gui()
	gui.tap = function(self, msg) if (msg.has_pointer) active_color = nil end
	local pal_el = create_palette{ x = 17, y = 6 }
	gui:attach(pal_el)
	gui:attach(create_visibility_buttons { x = pal_el.x - 14, y = pal_el.y + 1 })
	gui:attach(create_color_preview { x = pal_el.x + pal_el.width + 8, y = pal_el.y })
	gui:attach(create_test_zone { x = 390, y = 4 })
	
	local x_buttons = 347
	gui:attach(create_action_button { x = x_buttons, y = 4, sprite = 16,
		act = function(self) undo_stack:undo(); update_hidden_toggles() end,
		active = function(self) return #(undo_stack.undo_stack) >= 1 end })
	gui:attach(create_action_button { x = x_buttons + 16 + 2, y = 4, sprite = 19,
		act = function(self) undo_stack:redo(); update_hidden_toggles() end,
		active = function(self) return #(undo_stack.redo_stack) >= 1 end })
	gui:attach(create_action_button { x = x_buttons, y = 4 + 16 + 2, sprite = 24,
		act = function(self) open_settings() end })
	gui:attach(create_action_button { x = x_buttons + 16 + 2, y = 4 + 16 + 2, sprite = 27,
		act = function(self) open_help() end })
	gui:attach(create_pickers_mode_switch { x = x_buttons, y = 41 })

	if pickers_mode == "circular_hue" then
		hide_color_band()
		gui:attach(create_hue_sat_picker { x = 0, y = 56 })
		local right = gui:attach(create_sat_lum_picker{ x = 196, y = 270 - 190 - 24, abscissa = "s" })
		gui:attach(create_sat_knob { x = right.x, y = right.y + right.height - 3 })
		gui:attach(create_lum_knob { x = right.x - 5, y = right.y })
	else
		if user_settings.show_color_band then
			show_color_band()
		else
			hide_color_band()
		end
		if user_settings.show_color_names then
			gui:attach(create_color_names { x = 11 + 7, y = 148 })
		end
		if user_settings.show_color_band then
			gui:attach(create_color_band { x = 11 + 7, y = 243 })
		end
		gui:attach(create_rectangle_picker { x = 11, y = 148, ordinate = "s" })
		-- Attach the bottom one last so it has priority for clicks. The two
		-- pickers have a slight overlap due to their borders, and black colors
		-- are difficult to grab otherwise.
		gui:attach(create_rectangle_picker { x = 11, y = 54 })
		gui:attach(create_val_knob { x = 6, y = 56, ordinate = "l" })
		gui:attach(create_val_knob { x = 6, y = 148, ordinate = "s" })
		gui:attach(create_hue_knob { x = 11, y = 243 })
		gui:attach(create_hue_scrubber { x = 174, y = 254 })
	end
end


-------------------------------------------------------------------------------


function change_hidden(c, hide)
	hidden[c] = hide
	update_hidden_toggles()
end


function update_hidden_toggles()
	local nb_columns <const> = 16
	for row = 0, 3 do
		local some_non_black = false
		local some_visible = false
		for column = 0, nb_columns - 1 do
			local c = (row * nb_columns) + column
			local is_black = pal_code[c] == 0x000000
			if is_black then
				hidden[c] = false
			else
				some_non_black = true
			end
			if (c > 0) and (not is_black) and (not hidden[c]) then
				some_visible = true
			end
		end
		hidden_toggles[row] = some_non_black and (not some_visible)
	end
	dont_blink()
end


-----------------------------------------------------------------------------------


function create_palette(el)
	local size = 12
	local nb_columns = 16
	local nb_rows = 4
	el.width = (nb_columns * size) + 1
	el.height = (nb_rows * size) + 1
	el.cursor = "pointer"

	function el.draw(self, msg)
		clip()
		rect(0, 0, self.width, self.height, outline_color())
		for c = 0, 63 do
			local x = 1 + ((c % nb_columns) * size)
			local y = 1 + ((c \ nb_columns) * size)
			rectfill(x, y, x + size - 1, y + size - 1, c)
			if hidden[c] then
				ovalfill(x + 2, y + 2, x + size - 3, y + size - 3, bg_color)
			end
			if c == active_color then
				rect(
					x + 1, y + 1,
					x + size - 2, y + size - 2,
					contrast_color(active_color)
				)
			end
		end	
		if self.drag_pos then
			local col = (msg.mx - 1) \ size
			local row = (msg.my - 1) \ size
			local c = col + row * nb_columns
			if 0 <= c and c <= 63 then
				local x = 1 + col * size
				local y = 1 + row * size
				if c != active_color and not locked[c] then
					rect(x + 3, y + 3, x + size - 4, y + size - 4, contrast_color(c))
				end
			end
			local mx, my = self.drag_pos.x, self.drag_pos.y
			rectfill(mx, my, mx + 8, my + 8, active_color)		
		end
	end

	function el.click(self, msg)
		local col = min(nb_columns - 1, (msg.mx - 1) \ size)
		local row = min(nb_rows - 1, (msg.my - 1) \ size)
		local c = col + row * nb_columns
		if msg.mb == 1 then
			active_color = c
			self.click_pos = { x = msg.mx, y = msg.my }
			if pal_code[active_color] == 0x000000 then
				pal_okhsl[active_color] = { h = 0, s = 1, l = 0 }
				circling_anim_timer = 1.0
			end
		elseif msg.mb == 2 then
			change_hidden(c, not hidden[c])
		end
	end
	
	function el.drag(self, msg)
		if self.click_pos and not self.drag_pos then
			local dx = abs(self.click_pos.x - msg.mx)
			local dy = abs(self.click_pos.y - msg.my)
			if dx > 1 or dy > 1 then
				if locked[active_color] then
					padlock_flashing = true
				else
					self.drag_pos = {}
				end
			end
		end
		if self.drag_pos then
			self.drag_pos = { x = msg.mx, y = msg.my }
		end
	end
	
	function el.release(self, msg)
		if self.drag_pos then
			local col = (msg.mx - 1) \ size
			local row = (msg.my - 1) \ size
			local c = col + row * nb_columns
			if 0 <= c and c <= 63 and not locked[c] then
				undo_stack:checkpoint()
				swap_colors(active_color, c)
				active_color = c
				send_palette()
			end			
		end
		self.click_pos = nil
		self.drag_pos = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end

	function el.mousewheel(self, msg)
		if not active_color then
			active_color = 0
		elseif msg.wheel_y < 0 then
			active_color = (active_color + 1) % 64
		elseif msg.wheel_y > 0 then
			active_color = (active_color - 1) % 64
		end
	end

	return el
end


local blink_anim <const> = { [0] = 40, 41, 42, 43, 43, 43, 42, 41, 40 }


function create_visibility_buttons(el)
	local size = 12
	local nb_rows = 4
	el.width = size
	el.height = nb_rows * size
	el.cursor = "pointer"

	function el.draw(self, msg)
		pal(7, outline_color())
		for row = 0, 3 do
			if hidden_toggles[row] then
				spr(43, 0, row * size)
			else
				local sprite = 40
				if blink_timer <= 0 and blink_eye == row then
					sprite = blink_anim[- blink_timer] 
				end
				spr(sprite, 0, row * size)
			end
		end
		pal(7, 7)
	end
	
	function el.update(self, msg)
		if not user_settings.dont_blink then
			blink_timer -= 1
			if blink_timer <= -9 then
				blink_timer = 180 + math.random(1, 6) * 90
				local nb_eyes = active_color and 4 or 3
				blink_eye = math.random(0, nb_eyes)
				if hidden_toggles[blink_eye] then
					blink_eye = math.random(0, nb_eyes)
				end
			end
		end
	end
	
	function el.tap(self, msg)
		local row = mid(0, msg.my \ size, 3)
		local action = not hidden_toggles[row]
		for c = row * 16, row * 16 + 15 do
			change_hidden(c, action)
		end
		dont_blink()
	end
	
	return el
end


function dont_blink()
	local all_eyes_closed = true
	for i = 0, 3 do
		if not hidden_toggles[i] then all_eyes_closed = false end
	end
	if all_eyes_closed then
		crying_a_timer = 46
	end
end


function blinked()
	if user_settings.no_jump_scares or crying_a_done then
		return
	end
	pal(1, 0)
	if crying_a_timer > 20 then
		spr(254, 0, 0)
	elseif crying_a_timer > 0 then
		spr(255, 0, -16)
	end
	pal(1, 1)
end


------------------------------------------------------------------------------


function create_color_preview(el)
	local size = 12
	el.width = size * 4 + 2 + 120
	el.height = size * 4 + 2

	gui:new(el)

	-- Input field for the color code
	el:attach(create_field {
		x = 5, y = el.height - 12,
		width = 40, height = 9,
		small_font = false,
		get_fg = function(self) return contrast_color(active_color or 0) end,
		get = function(self)
			if (not active_color) return ""
			return "#" .. color_to_hex(get_color(active_color))
		end,
		set = function(self, str)
			if (locked[active_color]) return
			str = str:gsub("%s", ""):gsub("#", "")
			if (#str ~= 6) return
			local code = tonum("0x" .. str)
			if (type(code) ~= "number") return
			undo_stack:checkpoint()
			change_color_code(active_color, code)
		end,
		update = function(self, msg)
			self.hidden = active_color == nil
		end
	})

	-- Input field for hue
	el:attach(create_field {
		x = 100, y = 22,
		width = 20, height = 7,
		small_font = true,
		get_fg = function(self) return outline_color() end,
		get = function(self)
			if (not active_color) return ""
			local hue = pal_okhsl[active_color].h * 360.0
			while hue < 0.0 do
				hue += 360.0
			end
			return string.format("%3.0f\031", hue)
		end,
		set = function(self, str)
			if (locked[active_color]) return
			str = str:gsub("%s", ""):gsub("\031", "")
			local hue = tonum(str)
			if (type(hue) ~= "number") return
			hue = (hue % 360.0) / 360.0
			undo_stack:checkpoint()
			change_color(active_color, hue, nil, nil)
		end,
		update = function(self, msg)
			self.hidden = active_color == nil
		end
	})

	-- Input field for saturation
	el:attach(create_field {
		x = 100, y = 31,
		width = 20, height = 7,
		small_font = true,
		get_fg = function(self) return outline_color() end,
		get = function(self)
			if (not active_color) return ""
			local sat = pal_okhsl[active_color].s * 100.0
			return string.format("%3.0f%%", sat)
		end,
		set = function(self, str)
			if (locked[active_color]) return
			str = str:gsub("%s", ""):gsub("%%", "")
			local sat = tonum(str)
			if (type(sat) ~= "number") return
			sat = sat / 100.0
			undo_stack:checkpoint()
			change_color(active_color, nil, sat, nil)
		end,
		update = function(self, msg)
			self.hidden = active_color == nil
		end
	})

	-- Input field for luminance
	el:attach(create_field {
		x = 100, y = 40,
		width = 20, height = 7,
		small_font = true,
		get_fg = function(self) return outline_color() end,
		get = function(self)
			if (not active_color) return ""
			local lum = pal_okhsl[active_color].l * 100.0
			return string.format("%3.0f%%", lum)
		end,
		set = function(self, str)
			if (locked[active_color]) return
			str = str:gsub("%s", ""):gsub("%%", "")
			local lum = tonum(str)
			if (type(lum) ~= "number") return
			lum = lum / 100.0
			undo_stack:checkpoint()
			change_color(active_color, nil, nil, lum)
		end,
		update = function(self, msg)
			self.hidden = active_color == nil
		end
	})

	-- Container callbacks

	function el.draw(self, msg)
		if active_color then
			rectfill(1, 1, self.height - 2, self.height - 2, active_color)
			print(string.format("%d", active_color), 4, 4, contrast_color(active_color))
			pal(7, outline_color())
			if locked[active_color] then
				if padlock_flashing_time % 18 < 10 then
					spr(2, self.height + 4, 1)
				end
			else
				spr(1, self.height + 4, 1)
			end
			if hidden[active_color] then
				spr(43, self.height + 4 + size, 1)
			else
				local sprite = 40
				if blink_timer <= 0 and blink_eye == 4 then
					sprite = blink_anim[- blink_timer] 
				end
				spr(sprite, self.height + 4 + size, 1)
			end
			if bg_color == active_color then
				spr(10, self.height + 4 + 2 * size, 1)
			else
				spr(9, self.height + 4 + 2 * size, 1)
			end
			pal(7, 7)
			local hue = pal_okhsl[active_color].h * 360.0
			while hue < 0.0 do
				hue += 360.0
			end
			print("\014hue: ", self.height + 5, 23, outline_color())
			print("\014saturation: ", self.height + 5, 32)
			print("\014lightness: ", self.height + 5, 41)
		else
			print("\^pOkPal" .. "\^-p\014\|o " .. okpal_version, 24, 16, outline_color())
			if env().sandbox then
				print("\014    " .. env().sandbox .. " sandbox", 24, 34)
			end
		end
	end
	
	function el.tap(self, msg)
		if (not active_color) return
		if msg.mx < self.height or msg.my > size then
			return
		elseif msg.mx < self.height + 4 + size then
			locked[active_color] = not locked[active_color]
		elseif msg.mx < self.height + 4 + 2 * size then
			change_hidden(active_color, not hidden[active_color])
		elseif msg.mx < self.height + 4 + 3 * size then
			if key("shift") and bg_color != active_color then
				whitest_color = active_color
			elseif key("ctrl") then
				blackest_color = active_color
			elseif bg_color == active_color then
				bg_color = blackest_color
			else
				bg_color = active_color
			end
		end
	end
	
	function el.hover(self, msg)
		if msg.has_pointer and msg.mx >= self.height + 4 and msg.mx <= self.height + 4 + 3 * size and msg.my <= size then
			self.cursor = "pointer"
		else
			self.cursor = 1
		end
	end
	
	return el
end


---------------------------------------------------------------------------------


function create_pickers_mode_switch(el)
	el.width = get_spr(36):width()
	el.height = get_spr(36):height()
	el.cursor = "pointer"
	function el.draw(self, msg)
		pal(7, outline_color())
		spr(pickers_mode == "circular_hue" and 36 or 37, 0, 0)
		pal(7)
	end
	function el.tap(self, msg)
		if pickers_mode == "circular_hue" then
			pickers_mode = "linear_hue"
		else
			pickers_mode = "circular_hue"
		end
		gui_changed = true
	end
	return el
end


---------------------------------------------------------------------------------


function create_test_zone(el)
	el.width = (24 + 4) * 3
	el.height = 12 + (24 + 4) * 8 + 15
	el.cursor = "pointer"
	el.cubes = {}
	el.ramps = nil
	
	gui:new(el)
	
	for i = 0, 2 do
		for j = 0, 7 do
			el.cubes[#el.cubes + 1] =
				el:attach(create_test_cube { x = i * 28, y = 12 + j * 28, test_id = i + 3 * j })
		end
	end
	
	el.ramps = el:attach(create_test_ramps { x = 0, y = 12, hidden = test_mode ~= "ramps" })

	el:attach(
		create_action_button {
			x = 54, y = 238, sprite = 32,
			act =
				function(self)
					undo_stack:checkpoint()
					if test_mode == "cubes" then
						clear_cube_colors()
					elseif test_mode == "ramps" then
						clear_ramp_colors()
					end
				end 
		}
	)

	function el.draw(self, msg)
		pal(7, outline_color())
		if test_mode == "cubes" then
			spr(34, 0, 0)
		elseif test_mode == "ramps" then
			spr(35, 0, 0)
		end
		pal(7, 7)
	end
	
	function el.click(self, msg)
		if msg.my > 12 then
			return
		end
		if test_mode == "cubes" and msg.mx > 33 then
			test_mode = "ramps"
			for c in all(self.cubes) do
				c.hidden = true
			end
			self.ramps.hidden = false
		elseif test_mode == "ramps" and msg.mx < 33 then
			test_mode = "cubes"
			for c in all(self.cubes) do
				c.hidden = false
			end
			self.ramps.hidden = true
		end
	end
	
	function el.mousewheel(self, msg)
		if not active_color then
			active_color = 0
		elseif msg.wheel_y < 0 then
			active_color = (active_color + 1) % 64
		elseif msg.wheel_y > 0 then
			active_color = (active_color - 1) % 64
		end
	end

	return el
end


function create_test_cube(el)
	el.width = 24 + 4
	el.height = 24 + 4
	el.hidden = test_mode ~= "cubes"

	function el.draw(self, msg)
		local colors = test_cube_colors[self.test_id]
		pal(10, colors[1])
		pal(9, colors[2])
		pal(25, colors[3])
		spr(8, 2, 2)
		pal(10, 10)
		pal(9, 9)
		pal(25, 25)
	end
	
	function el.hover(self, msg)
		if msg.mx > 2 and msg.my > 2 and msg.mx < self.width - 2 and msg.my < self.height - 2 then
			el.cursor = "crosshair"
		else
			el.cursor = 1
		end
	end
	
	function el.click(self, msg)
		local face = 2
		if msg.mx > self.width - 10 or msg.my < 10 then
			if msg.mx > self.height - msg.my then
				face = 3
			else
				face = 1
			end
		end
		if msg.mb == 1 then
			undo_stack:checkpoint()
			test_cube_colors[self.test_id][face] = active_color or 1
		elseif msg.mb == 2 then
			active_color = test_cube_colors[self.test_id][face]
		end
	end
	
	return el
end


function create_test_ramps(el)
	el.width = (24 + 4) * 3
	el.height = (24 + 4) * 8
	
	function el:square_of(x, y)
		if x < 2 or x > self.width - 2 or y <= 4 or y >= self.height - 4 then
			return nil, nil
		end
		local i = mid(0, (x - 2) // 8, 9)
		local j = mid(0, (y - 4) // 8, 26)
		return i, j
	end

	function el.draw(self, msg)
		for i = 0, 9 do
			for j = 0, 26 do
				local x = 2 + i * 8
				local y = 4 + j * 8
				local c = test_ramp_colors:get(i, j)
				rectfill(x, y, x + 7, y + 7, c)
			end
		end
		local i, j = self:square_of(msg.mx, msg.my)
		if i then
			local x = 2 + i * 8
			local y = 4 + j * 8
			local c = test_ramp_colors:get(i, j)
			if c == 0 then
				rect(x, y, x + 7, y + 7, contrast_color(c))
			end
		end
	end
	
	function el.hover(self, msg)
		local i, j = self:square_of(msg.mx, msg.my)
		if i then
			el.cursor = "crosshair"
		else
			el.cursor = 1
		end
	end
	
	function el.click(self, msg)
		local  i, j = self:square_of(msg.mx, msg.my)
		if (not i) return
		if msg.mb == 1 then
			undo_stack:checkpoint()
			test_ramp_colors:set(i, j, active_color)
		elseif msg.mb == 2 then
			active_color = mid(0, test_ramp_colors:get(i, j), 63)
		elseif msg.mb == 4 then
			test_ramp_colors:set(i, j, 0)
		end
	end

	return el
end
:: src/gui_settings.lua
--[[pod_format="raw",created="2025-02-28 11:31:28",modified="2025-03-18 13:07:43",revision=1580]]
function open_settings()
	local el = open_modal(220, 170, true)
	el:attach(create_label { x = 90, y = 6, label = "Settings", fg = bg_color })
	
	if key("shift") then
		el:attach(create_checkbox {
			x = 10, y = 30,
			label = "Don't blink!",
			fg = bg_color,
			get = function(self) return user_settings.dont_blink end,
			toggle = function(self) change_settings { dont_blink = not user_settings.dont_blink } end,
		})
		el:attach(create_checkbox {
			x = 10, y = 50,
			label = "No jump scares",
			fg = bg_color,
			get = function(self) return user_settings.no_jump_scares end,
			toggle = function(self) change_settings { no_jump_scares = not user_settings.no_jump_scares } end,
		})
	
	else
		el:attach(create_checkbox {
			x = 10, y = 30,
			label = "Send palette to sprite and map editors",
			fg = bg_color,
			get = function(self) return user_settings.send_palette end,
			toggle = function(self) change_settings { send_palette = not user_settings.send_palette } end,
		})
		el:attach(create_checkbox {
			x = 10, y = 50,
			label = "Show color names",
			fg = bg_color,
			get = function(self) return user_settings.show_color_names end,
			toggle = function(self) change_settings { show_color_names = not user_settings.show_color_names } end,
		})
		el:attach(create_checkbox {
			x = 120, y = 50,
			label = "Show color band",
			fg = bg_color,
			get = function(self) return user_settings.show_color_band end,
			toggle =
				function(self)
					change_settings { show_color_band = not user_settings.show_color_band }
				end,
		})
		el:attach(create_checkbox {
			x = 10, y = 70,
			label = "Default app for \".pal\" files",
			fg = bg_color,
			is_default_app = get_default_app("pal") == env().argv[0],
			get = function(self) return self.is_default_app end,
			toggle =
				function(self)
					self.is_default_app = not self.is_default_app
					set_default_app("pal", self.is_default_app)
				end,
		})
		el:attach(create_checkbox {
			x = 10, y = 90,
			label = "Default app for \".hex\" files",
			fg = bg_color,
			is_default_app = get_default_app("hex") == env().argv[0],
			get = function(self) return self.is_default_app end,
			toggle =
				function(self)
					self.is_default_app = not self.is_default_app
					set_default_app("hex", self.is_default_app)
				end,
		})
	end
	
	el:attach(create_button {
		x = 170, y = 150,
		label = "Close",
		fg = bg_color,
		act = function() close_modal() end,
	})
end
:: src/integration.lua
--[[pod_format="raw",created="2025-03-08 09:24:27",modified="2025-03-20 14:02:14",revision=545]]
-- Copy and paste ----------------------------------------------------------------


function copy_color()
	if active_color then
		set_clipboard("#" .. color_to_hex(get_color(active_color)))
	end
end


function cut_color()
	if active_color then
		set_clipboard("#" .. color_to_hex(get_color(active_color)))
		if not locked[active_color] then
			 undo_stack:checkpoint()
			change_color_code(active_color, 0x000000)
			change_hidden(active_color, true)
		end
	end
end


function paste_color()
	if not active_color then
		notify("unable to paste: no selected color")
		return
	end
	if locked[active_color] then
		notify("unable to paste: selected color is locked")
		return
	end
	local cb = get_clipboard()
	if type(cb) == "string" then
		local hex = string.gsub(cb, "%s", "")
		if sub(hex, 1, 1) == "#" then
			hex = sub(hex, 2, -1)
		end
		local code = tonumber("0x" .. hex)
		if type(code) == "number" then
			undo_stack:checkpoint()
			change_color_code(active_color, code)
			change_hidden(active_color, false)
		else
			notify("unable to paste: unrecognized string: \"" .. cb .."\"")
		end
	else
		notify("unable to paste: type not supported (" .. type(cb) .. ")")
	end
end


---------------------------------------------------------------------------------------------


function get_default_app(extension)
	if fstat("/system/util/default_app.lua") ~= "file" then
		return "(unknown)"
	end

	local default_apps = fetch("/appdata/system/default_apps.pod") or {}
	return default_apps[extension] or "(none)"
end


function set_default_app(extension, value)
	local okpal_path = env().argv[0]

	-- Prevent registering the wrong path when
	-- developing OkPal.
	if okpal_path == "/system/apps/terminal.lua" then
		return
	end
	
	local defaults = fetch("/appdata/system/default_apps.pod")
	if type(defaults) ~= "table" then return end
	if value then
		defaults[extension] = okpal_path
		notify("OkPal registered as default app for \"."..extension.."\" files")
	else
		defaults[extension] = nil
		notify("Cleared default app for \"."..extension.."\" files")
	end
	store("/appdata/system/default_apps.pod", defaults)
end


-----------------------------------------------------------------------------


function send_palette()
	if not user_settings.send_palette then
		return
	end
	
	local palette = userdata("i32", 64)
	for c = 0, 63 do
		palette:set(c, get_color(c))
	end
	
	-- Updating the PID lists as we're sending the event
	-- to not miss new processes.
	for pid in all(find_gfx_map_pids()) do
		send_message(pid, { event = "set_palette", palette = palette })
	end
end


-- From Eiyeron's fork #eyn_okpal_fork-0
function find_gfx_map_pids()
	local matching_pids = {}
	for process in all(fetch "/ram/system/processes.pod") do
		local name <const> = process.name
		if name == "gfx" or name == "map" then
			matching_pids[#matching_pids + 1] = process.id
		end
	end
	return matching_pids
end


-- Drag-and-drop ------------------------------------------------------------------


function handle_drop_items(msg)
	for i = 1, #msg.items do
		local item = msg.items[i]
		if item.pod_type == "file_reference" and item.attrib == "file" then
--			undo_stack:checkpoint()
--			send_message(pid(), { event = "open_file", filename = item.fullpath })
		local okpal_path = env().argv[0]
		-- Prevent registering the wrong path when
		-- developing OkPal.
		if okpal_path == "/system/apps/terminal.lua" then
			return
		end
		create_process(
			okpal_path,
			{
				argv = { item.fullpath },
			}
		)
		end
	end
end

:: src/oklab.lua
--[[pod_format="raw",created="2024-03-31 09:08:26",modified="2025-03-10 19:14:59",revision=981]]
-- Copyright(c) 2021 Bjorn Ottosson
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of
-- this software and associated documentation files(the "Software"), to deal in
-- the Software without restriction, including without limitation the rights to
-- use, copy, modify, merge, publish, distribute, sublicense, and /or sell copies
-- of the Software, and to permit persons to whom the Software is furnished to do
-- so, subject to the following conditions:
--
-- The above copyright noticeand this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

oklab = {}
oklab.__index = oklab

function oklab.color_to_okhsl(code)
	local srgb = {
		r = ((code & 0xff0000) >> 16) / 255,
		g = ((code & 0x00ff00) >> 8) / 255,
		b = ((code & 0x0000ff)) / 255,
	}
	return oklab.srgb_to_okhsl(srgb)
end

function oklab.okhsl_to_color(okhsl)
	local srgb = oklab.okhsl_to_srgb(okhsl)
	local r = mid(0x00, math.floor(srgb.r * 255 + 0.5), 0xff)
	local g = mid(math.floor(srgb.g * 255 + 0.5), 0xff)
	local b = mid(math.floor(srgb.b * 255 + 0.5), 0xff)
	return (r << 16) | (g << 8) | b
end

function oklab.new()
    local inst = setmetatable({}, oklab)
    return inst
end

-- Finds the maximum saturation possible for a given hue that fits in sRGB
-- Saturation here is defined as S = C/L
-- a and b must be normalized so a^2 + b^2 == 1
function oklab.compute_max_saturation(a, b)
    if a ~= 0.0 or b ~= 0.0 then
    	-- Max saturation will be when one of r, g or b goes below zero.
        -- Select different coefficients depending on which component goes below zero first

        -- Blue component (default)
        local k0 = 1.35733652
        local k1 = -0.00915799
        local k2 = -1.1513021
        local k3 = -0.50559606
        local k4 = 0.00692167
        local wl = -0.0041960863
        local wm = -0.7034186147
        local ws = 1.707614701

        if -1.88170328 * a - 0.80936493 * b > 1 then
            -- Red component
            k0 = 1.19086277
            k1 = 1.76576728
            k2 = 0.59662641
            k3 = 0.75515197
            k4 = 0.56771245
            wl = 4.0767416621
            wm = -3.3077115913
            ws = 0.2309699292
        elseif 1.81444104 * a - 1.19445276 * b > 1 then
            -- Green component
            k0 = 0.73956515
            k1 = -0.45954404
            k2 = 0.08285427
            k3 = 0.1254107
            k4 = 0.14503204
            wl = -1.2684380046
            wm = 2.6097574011
            ws = -0.3413193965
        end

        -- Approximate max saturation using a polynomial:
        local S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b

        -- Do one step Halley's method to get closer
        -- this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite
        -- this should be sufficient for most applications, otherwise do two/three steps

        local k_l = 0.3963377774 * a + 0.2158037573 * b
        local k_m = -0.1055613458 * a - 0.0638541728 * b
        local k_s = -0.0894841775 * a - 1.291485548 * b

        do
            local l_ = 1.0 + S * k_l
            local m_ = 1.0 + S * k_m
            local s_ = 1.0 + S * k_s

            local l = l_ * l_ * l_
            local m = m_ * m_ * m_
            local s = s_ * s_ * s_

            local l_dS = 3.0 * k_l * l_ * l_
            local m_dS = 3.0 * k_m * m_ * m_
            local s_dS = 3.0 * k_s * s_ * s_

            local l_dS2 = 6.0 * k_l * k_l * l_
            local m_dS2 = 6.0 * k_m * k_m * m_
            local s_dS2 = 6.0 * k_s * k_s * s_

            local f = wl * l + wm * m + ws * s
            local f1 = wl * l_dS + wm * m_dS + ws * s_dS
            local f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2

            local s_denom = f1 * f1 - 0.5 * f * f2
            if s_denom ~= 0.0 then  S = S - f * f1 / s_denom end
        end

        return S
    else
        return 0.0
    end
end

-- finds L_cusp and C_cusp for a given hue
-- a and b must be normalized so a^2 + b^2 == 1
function oklab.find_cusp(a, b)
	-- First, find the maximum saturation (saturation S = C/L)
    local S_cusp = oklab.compute_max_saturation(a, b)

    -- Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:
    local rgb_at_max = oklab.oklab_to_linear_srgb({L = 1, a = S_cusp * a, b = S_cusp * b })
    local max_comp = math.max(rgb_at_max.r, rgb_at_max.g, rgb_at_max.b)
    if max_comp ~= 0.0 then
        local L_cusp = (1.0 / max_comp) ^ 0.3333333333333333
        return { L = L_cusp, C = L_cusp * S_cusp }
    else
        return { L = 0.0, C = 0.0 }
    end
end

-- Finds intersection of the line defined by
-- L = L0 * (1 - t) + t * L1
-- C = t * C1
-- a and b must be normalized so a^2 + b^2 == 1
function oklab.find_gamut_intersection(a, b, L1, C1, L0, x)
    -- Find the cusp of the gamut triangle
    local cusp = x or oklab.find_cusp(a, b)

    -- Find the intersection for upper and lower half separately
    local t = 0.0
    if ((L1 - L0) * cusp.C - (cusp.L - L0) * C1) <= 0.0 then
        -- Lower half
        local t_denom = C1 * cusp.L + cusp.C * (L0 - L1)
        if t_denom ~= 0.0 then t = cusp.C * L0 / t_denom end
    else
        -- Upper half
        -- First intersect with triangle
        local t_denom = C1 * (cusp.L - 1.0) + cusp.C * (L0 - L1)
        if t_denom ~= 0.0 then t = cusp.C * (L0 - 1.0) / t_denom end

        -- Then one step Halley's method
        do
            local dL = L1 - L0
            local dC = C1

            local k_l = 0.3963377774 * a + 0.2158037573 * b
            local k_m = -0.1055613458 * a - 0.0638541728 * b
            local k_s = -0.0894841775 * a - 1.291485548 * b

            local l_dt = dL + dC * k_l
            local m_dt = dL + dC * k_m
            local s_dt = dL + dC * k_s

            -- If higher accuracy is required, 2 or 3 iterations of the following block can be used:
            do
                local L = L0 * (1.0 - t) + t * L1
				local C = t * C1

				local l_ = L + C * k_l
				local m_ = L + C * k_m
				local s_ = L + C * k_s

				local l = l_ * l_ * l_
				local m = m_ * m_ * m_
				local s = s_ * s_ * s_

				local ldt = 3.0 * l_dt * l_ * l_
				local mdt = 3.0 * m_dt * m_ * m_
				local sdt = 3.0 * s_dt * s_ * s_

				local ldt2 = 6.0 * l_dt * l_dt * l_
				local mdt2 = 6.0 * m_dt * m_dt * m_
				local sdt2 = 6.0 * s_dt * s_dt * s_

                local r0 = 4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s - 1
				local r1 = 4.0767416621 * ldt - 3.3077115913 * mdt + 0.2309699292 * sdt
				local r2 = 4.0767416621 * ldt2 - 3.3077115913 * mdt2 + 0.2309699292 * sdt2

                local r_denom = r1 * r1 - 0.5 * r0 * r2
                local u_r = 0.0
                if r_denom ~= 0.0 then u_r = r1 / r_denom end
				local t_r = -r0 * u_r

                local g0 = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s - 1
				local g1 = -1.2684380046 * ldt + 2.6097574011 * mdt - 0.3413193965 * sdt
				local g2 = -1.2684380046 * ldt2 + 2.6097574011 * mdt2 - 0.3413193965 * sdt2

                local g_denom = g1 * g1 - 0.5 * g0 * g2
                local u_g = 0.0
                if g_denom ~= 0.0 then u_g = g1 / g_denom end
				local t_g = -g0 * u_g

                local b0 = -0.0041960863 * l - 0.7034186147 * m + 1.707614701 * s - 1
				local b1 = -0.0041960863 * ldt - 0.7034186147 * mdt + 1.707614701 * sdt
				local b2 = -0.0041960863 * ldt2 - 0.7034186147 * mdt2 + 1.707614701 * sdt2

                local b_denom = (b1 * b1 - 0.5 * b0 * b2)
                local u_b = 0.0
                if b_denom ~= 0.0 then u_b = b1 / b_denom end
				local t_b = -b0 * u_b

                if u_r < 0.0 then t_r = 3.40282347e+38 end
                if u_g < 0.0 then t_g = 3.40282347e+38 end
                if u_b < 0.0 then t_b = 3.40282347e+38 end

                t = t + math.min(t_r, t_g, t_b)
            end
        end
    end

    return t
end

function oklab.get_Cs(L, a_, b_)
    local cusp = oklab.find_cusp(a_, b_)
    local C_max = oklab.find_gamut_intersection(a_, b_, L, 1.0, L, cusp)
    local ST_max = oklab.to_ST(cusp)

    -- Scale factor to compensate for the curved part of gamut shape:
    local k = 0.0
    local k_denom = math.min(L * ST_max.S, (1.0 - L) * ST_max.T)
    if k_denom ~= 0.0 then k = C_max / k_denom end

    local C_mid = 0.0
    do
        local ST_mid = oklab.get_ST_mid(a_, b_)

        -- Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.
        local C_a = L * ST_mid.S
        local C_b = (1.0 - L) * ST_mid.T

        local cae4 = C_a * C_a * C_a * C_a
        local cbe4 = C_b * C_b * C_b * C_b
        C_mid = 0.9 * k * ((1.0 / (1.0 / cae4 + 1.0 / cbe4)) ^ 0.25)
    end

    local C_0 = 0.0
    do
        -- for C_0, the shape is independent of hue, so ST are constant. Values picked to roughly be the average values of ST.
        local C_a = L * 0.4
        local C_b = (1.0 - L) * 0.8

        -- Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.
        local cae2 = C_a * C_a
        local cbe2 = C_b * C_b
        C_0 = math.sqrt(1.0 / (1.0 / cae2 + 1.0 / cbe2))
    end

    return { C_0 = C_0, C_mid = C_mid, C_max = C_max }
end

-- Returns a smooth approximation of the location of the cusp
-- This polynomial was created by an optimization process
-- It has been designed so that S_mid < S_max and T_mid < T_max
function oklab.get_ST_mid(a_, b_)
    local S = 0.11516993
    local s_denom = 7.4477897 + 4.1590124 * b_
        + a_ * (-2.19557347 + 1.75198401 * b_
        + a_ * (-2.13704948 - 10.02301043 * b_
        + a_ * (-4.24894561 + 5.38770819 * b_ + 4.69891013 * a_)))
    if s_denom ~= 0.0 then
        S = 0.11516993 + 1.0 / s_denom
    end

    local T = 0.11239642
    local t_denom = 1.6132032 - 0.68124379 * b_
        + a_ * (0.40370612 + 0.90148123 * b_
        + a_ * (-0.27087943 + 0.6122399 * b_
        + a_ * (0.00299215 - 0.45399568 * b_ - 0.14661872 * a_)))
	if t_denom ~= 0.0 then
        T = 0.11239642 + 1.0 / t_denom
    end

	return { S = S, T = T }
end

function oklab.linear_srgb_to_oklab(c)
    local l = 0.4122214708 * c.r
            + 0.5363325363 * c.g
            + 0.0514459929 * c.b
	local m = 0.2119034982 * c.r
            + 0.6806995451 * c.g
            + 0.1073969566 * c.b
	local s = 0.0883024619 * c.r
            + 0.2817188376 * c.g
            + 0.6299787005 * c.b

    local l_ = l ^ 0.3333333333333333
    local m_ = m ^ 0.3333333333333333
    local s_ = s ^ 0.3333333333333333

    return {
        L = 0.2104542553 * l_
          + 0.793617785 * m_
          - 0.0040720468 * s_,
        a = 1.9779984951 * l_
          - 2.428592205 * m_
          + 0.4505937099 * s_,
        b = 0.0259040371 * l_
          + 0.7827717662 * m_
          - 0.808675766 * s_ }
end

function oklab.okhsl_to_oklab(hsl)
	local l = hsl.l
    if l >= 1.0 then return { L = 1.0, a = 0.0, b = 0.0 } end
    if l <= 0.0 then return { L = 0.0, a = 0.0, b = 0.0 } end

    local s = hsl.s
    if s < 0.0 then s = 0.0 end
    if s > 1.0 then s = 1.0 end

    local h = hsl.h
    local h_rad = h * 6.283185307179586
    local a_ = math.cos(h_rad)
    local b_ = math.sin(h_rad)
    local L = oklab.toe_inv(l)

    local cs = oklab.get_Cs(L, a_, b_)
    local C_0 = cs.C_0
	local C_mid = cs.C_mid
	local C_max = cs.C_max

    local mid = 0.8
	local mid_inv = 1.25

    local C = 0.0
    local t = 0.0
    local k_0 = 0.0
    local k_1 = 0.0
    local k_2 = 0.0
    if s < mid then
        t = mid_inv * s

		k_1 = mid * C_0
        if C_mid ~= 0.0 then
		    k_2 = 1.0 - k_1 / C_mid
        end

        local k_denom = 1.0 - k_2 * t
		if k_denom ~= 0.0 then
            C = t * k_1 / k_denom
        end
    else
        local t_denom = 1.0 - mid
        if t_denom ~= 0.0 then
            t = (s - mid) / t_denom
        end

		k_0 = C_mid
        if C_0 ~= 0.0 then
		    k_1 = (1.0 - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0
        end

        local C_denom = C_max - C_mid
		k_2 = 1.0
        if C_denom ~= 0.0 then
            k_2 = 1.0 - k_1 / C_denom
        end

        local k_denom = 1.0 - k_2 * t
        if k_denom ~= 0.0 then
		    C = k_0 + t * k_1 / k_denom
        end
    end

    return {
        L = L,
        a = C * a_,
        b = C * b_ }
end

function oklab.okhsl_to_srgb(hsl)
    return oklab.oklab_to_srgb(oklab.okhsl_to_oklab(hsl))
end

function oklab.okhsv_to_oklab(hsv)
	local v = hsv.v
    if v <= 0.0 then return { L = 0.0, a = 0.0, b = 0.0 } end
    if v > 1.0 then v = 1.0 end

    local s = hsv.s
    if s < 0.0 then s = 0.0 end
    if s > 1.0 then s = 1.0 end

    local h = hsv.h
    local h_rad = h * 6.283185307179586
    local a_ = math.cos(h_rad)
    local b_ = math.sin(h_rad)

    local cusp = oklab.find_cusp(a_, b_)
	local ST_max = oklab.to_ST(cusp)
	local S_max = ST_max.S
	local T_max = ST_max.T
	local S_0 = 0.5
    local k = 1.0
    if S_max ~= 0.0 then
	    k = 1.0 - S_0 / S_max
    end

    -- first we compute L and V as if the gamut is a perfect triangle:

	-- L, C when v==1:
    local v_denom = S_0 + T_max - T_max * k * s
    local L_v = 1.0
    local C_v = 0.0
    if v_denom ~= 0.0 then
        L_v = 1.0 - s * S_0 / v_denom
	    C_v = s * T_max * S_0 / v_denom
    end

    local L = v * L_v
	local C = v * C_v

    --then we compensate for both toe and the curved top part of the triangle:
    local L_vt = oklab.toe_inv(L_v)
    local C_vt = 0.0
    if L_v ~= 0.0 then
        C_vt = C_v * L_vt / L_v
    end

    local L_new = oklab.toe_inv(L)
    if L ~= 0.0 then
        C = C * L_new / L
    end
    L = L_new

    local rgb_scale = oklab.oklab_to_linear_srgb({
        L = L_vt,
        a = a_ * C_vt,
        b = b_ * C_vt })
    local max_comp = math.max(
        rgb_scale.r,
        rgb_scale.g,
        rgb_scale.b, 0.0)
    local scale_L = 0.0
    if max_comp ~= 0.0 then
        scale_L = (1.0 / max_comp) ^ 0.3333333333333333
    end

	C = C * scale_L
    return {
        L = L * scale_L,
        a = C * a_,
        b = C * b_ }
end

function oklab.okhsv_to_srgb(hsv)
    return oklab.oklab_to_srgb(oklab.okhsv_to_oklab(hsv))
end

function oklab.oklab_to_linear_srgb(lab)
    local l_ = lab.L
        + 0.3963377774 * lab.a
        + 0.2158037573 * lab.b
	local m_ = lab.L
        - 0.1055613458 * lab.a
        - 0.0638541728 * lab.b
	local s_ = lab.L
        - 0.0894841775 * lab.a
        - 1.291485548 * lab.b

    local l = l_ * l_ * l_
    local m = m_ * m_ * m_
    local s = s_ * s_ * s_

    return {
        r = 4.0767416621 * l
          - 3.3077115913 * m
          + 0.2309699292 * s,
        g = -1.2684380046 * l
           + 2.6097574011 * m
           - 0.3413193965 * s,
        b = -0.0041960863 * l
           - 0.7034186147 * m
           + 1.707614701 * s }
end

function oklab.oklab_to_okhsl(lab)
    local L = lab.L
    if L >= 1.0 then return { h = 0.0, s = 0.0, l = 1.0 } end
    if L <= 0.0 then return { h = 0.0, s = 0.0, l = 0.0 } end

    local Csq = lab.a * lab.a + lab.b * lab.b
    if Csq > 0.0 then
        local C = math.sqrt(Csq)
        local a_ = lab.a / C
        local b_ = lab.b / C

        -- 1.0 / math.pi = 0.3183098861837907
        local h = 0.5 + 0.5 * math.atan(-lab.b, -lab.a) * 0.3183098861837907

        local cs = oklab.get_Cs(L, a_, b_)
        local C_0 = cs.C_0
        local C_mid = cs.C_mid
        local C_max = cs.C_max

        -- Inverse of the interpolation in okhsl_to_srgb:
        local mid = 0.8
        local mid_inv = 1.25

        local s = 0.0
        if C < C_mid then
            local k_1 = mid * C_0
            local k_2 = 1.0
            if C_mid ~= 0.0 then
                k_2 = (1.0 - k_1 / C_mid)
            end

            local t_denom = k_1 + k_2 * C
            local t = 0.0
            if t_denom ~= 0.0 then
                t = C / t_denom
            end

            s = t * mid
        else
            local k_0 = C_mid
            local k_1 = 0.0
            if C_0 ~= 0.0 then
                k_1 = (1.0 - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0
            end

            local C_denom = C_max - C_mid
            local k_2 = 1.0
            if C_denom ~= 0.0 then
                k_2 = 1.0 - k_1 / C_denom
            end

            local t_denom = k_1 + k_2 * (C - k_0)
            local t = 0.0
            if t_denom ~= 0.0 then
                t = (C - k_0) / t_denom
            end

            s = mid + (1.0 - mid) * t
        end

        return { h = h, s = s, l = oklab.toe(L) }
    else
        return { h = 0.0, s = 0.0, l = L }
    end
end

function oklab.oklab_to_okhsv(lab)
    local L = lab.L
    if L >= 1.0 then return { h = 0.0, s = 0.0, v = 1.0 } end
    if L <= 0.0 then return { h = 0.0, s = 0.0, v = 0.0 } end

    local Csq = lab.a * lab.a + lab.b * lab.b
    if Csq > 0.0 then
        local C = math.sqrt(Csq)
        local a_ = lab.a / C
        local b_ = lab.b / C

        -- 1.0 / math.pi = 0.3183098861837907
        local h = 0.5 + 0.5 * math.atan(-lab.b, -lab.a) * 0.3183098861837907

        local cusp = oklab.find_cusp(a_, b_)
        local ST_max = oklab.to_ST(cusp)
        local S_max = ST_max.S
        local T_max = ST_max.T
        local S_0 = 0.5
        local k = 1.0
        if S_max ~= 0.0 then
            k = 1.0 - S_0 / S_max
        end

        -- first we find L_v, C_v, L_vt and C_vt
        local t_denom = C + L * T_max
        local t = 0.0
        if t_denom ~= 0.0 then
            t = T_max / t_denom
        end
        local L_v = t * L
        local C_v = t * C

        local L_vt = oklab.toe_inv(L_v)
        local C_vt = 0.0
        if L_v ~= 0.0 then
            C_vt = C_v * L_vt / L_v
        end

        -- we can then use these to invert the step that compensates for the toe and the curved top part of the triangle:
        local rgb_scale = oklab.oklab_to_linear_srgb({
            L = L_vt,
            a = a_ * C_vt,
            b = b_ * C_vt })
        local scale_denom = math.max(
            rgb_scale.r,
            rgb_scale.g,
            rgb_scale.b, 0.0)
        local scale_L = 0.0
        if scale_denom ~= 0.0 then
            scale_L = (1.0 / scale_denom) ^ 0.3333333333333333
            L = L / scale_L
            C = C / scale_L
        end

        local toel = oklab.toe(L)
        C = C * toel / L
        L = toel

        -- we can now compute v and s:
        local v = 0.0
        if L_v ~= 0.0 then v = L / L_v end

        local s = 0.0
        local s_denom = ((T_max * S_0) + T_max * k * C_v)
        if s_denom ~= 0.0 then
            s = (S_0 + T_max) * C_v / s_denom
        end

        return { h = h, s = s, v = v }
    else
        return { h = 0.0, s = 0.0, v = L }
    end
end

function oklab.oklab_to_srgb(lab)
    local lrgb = oklab.oklab_to_linear_srgb(lab)
	return {
		r = oklab.srgb_transfer_function(lrgb.r),
		g = oklab.srgb_transfer_function(lrgb.g),
		b = oklab.srgb_transfer_function(lrgb.b) }
end

function oklab.srgb_to_okhsl(rgb)
    return oklab.oklab_to_okhsl(oklab.srgb_to_oklab(rgb))
end

function oklab.srgb_to_okhsv(rgb)
    return oklab.oklab_to_okhsv(oklab.srgb_to_oklab(rgb))
end

function oklab.srgb_to_oklab(srgb)
    return oklab.linear_srgb_to_oklab({
		r = oklab.srgb_transfer_function_inv(srgb.r),
		g = oklab.srgb_transfer_function_inv(srgb.g),
		b = oklab.srgb_transfer_function_inv(srgb.b) })
end

function oklab.srgb_transfer_function(a)
    if 0.0031308 >= a then
        return 12.92 * a
    else
        return 1.055 * (a ^ 0.4166666666666667) - 0.055
    end
end

function oklab.srgb_transfer_function_inv(a)
    if 0.04045 < a then
        return ((a + 0.055) * 0.9478672985781991) ^ 2.4
    else
        return a * 0.07739938080495357
    end
end

function oklab.to_ST(cusp)
	local L = cusp.L
    local C = cusp.C
    if L ~= 0.0 and L ~= 1.0 then
        return { S = C / L, T = C / (1.0 - L) }
    elseif L ~= 0.0 then
        return { S = C / L, T = 0.0 }
    elseif L ~= 1.0 then
        return { S = 0.0, T = C / (1.0 - L) }
    else
        return { S = 0.0, T = 0.0 }
    end
end

function oklab.toe(x)
    local y = 1.170873786407767 * x - 0.206
	return 0.5 * (y + math.sqrt(y * y + 0.14050485436893204 * x))
end

function oklab.toe_inv(x)
    local denom = 1.170873786407767 * (x + 0.03)
    if denom ~= 0.0 then
    	return (x * x + 0.206 * x) / denom
    else
        return 0.0
    end
end

return oklab
:: src/palette.lua
--[[pod_format="raw",created="2024-03-31 08:27:10",modified="2025-03-20 16:21:14",revision=4034]]
function set_color(c, code)
	poke4(0x5000 + 4 * c, code)
end


function get_color(c)
	return peek4(0x5000 + 4 * c)
end


function color_to_hex(c)
	return string.format("%06x", c)
end


function rebuild_pal(c)
	for c = 0, 63 do
		local code = get_color(c)
		pal_code[c] = code
		-- TODO: something more subtle? only update the hsl values
		-- if they don't result in the same color code?
		pal_okhsl[c] = oklab.color_to_okhsl(pal_code[c])
	end
end


function change_color_code(c, code)
	pal_code[c] = code
	pal_okhsl[c] = oklab.color_to_okhsl(pal_code[c])
	set_color(c, code)
end


function change_color(c, hue, sat, lum)
	local hsl = {
		h = hue or pal_okhsl[c].h,
		s = sat or pal_okhsl[c].s,
		l = lum or pal_okhsl[c].l,
	}
	hsl.h = hsl.h % 1.0
	hsl.s = mid(0.0, hsl.s, 1.0)
	hsl.l = mid(0.0, hsl.l, 1.0)
	local code = oklab.okhsl_to_color(hsl)
	pal_code[c] = code
	pal_okhsl[c] = hsl
	set_color(c, code)
	return
end


function swap_colors(c1, c2)
	pal_code[c1], pal_code[c2] = pal_code[c2], pal_code[c1]
	pal_okhsl[c1], pal_okhsl[c2] = pal_okhsl[c2], pal_okhsl[c1]
	set_color(c1, pal_code[c1])
	set_color(c2, pal_code[c2])
end


function clear_colors()
	for c = 0, 63 do
		local code, lum
		if c == 7 then
			code = 0xffffff
			lum = 1.0
		else
			code = 0x000000
			lum = 0.0
		end
		pal_code[c] = code
		pal_okhsl[c] = { h = 0.0, s = 0.0, l = lum }
		set_color(c, code)
		locked[c] = (c == 0) or (c == 7)
		hidden[c] = false
		clear_cube_colors()
		clear_ramp_colors()
	end
	for row = 0, 3 do hidden_toggles[row] = false end
	bg_color = 0
	blackest_color = 0
	whitest_color = 7
end


function reset_picotron_colors()
	for c = 0, 31 do
		code = peek4(0x5000 + 4 * (64 + c))
		set_color(c, code)
		pal_code[c] = code
		pal_okhsl[c] = oklab.color_to_okhsl(code)
		if c <= 31 then
			locked[c] = true
		end
	end
	bg_color = 0
	blackest_color = 0
	whitest_color = 7
end


function restore_default_palette()
	for c = 0, 63 do
		code = peek4(0x5000 + 4 * (64 + c))
		set_color(c, code)
		pal_code[c] = code
		pal_okhsl[c] = oklab.color_to_okhsl(code)
		if c <= 31 then
			locked[c] = true
		end
	end
	bg_color = 0
	blackest_color = 0
	whitest_color = 7
end


--------------------------------------------------------------------------------


function clear_cube_colors()
	for i = 0, #test_cube_colors - 1 do
		test_cube_colors[i] = { 1, 1, 1 }
	end
end


function clear_ramp_colors()
	for i = 0, test_ramp_colors:width()-1 do
		for j = 0, test_ramp_colors:height()-1 do
			test_ramp_colors:set(i, j, bg_color)
		end
	end
end


----------------------------------------------------------------------------------


function find_blackest_and_whitest()
	local min_lum = 1.0
	local best_black = 0
	local max_lum = 0.0
	local best_white = 1
	for c = 0, 63 do
		if pal_okhsl[c].l < min_lum then
			best_black = c
			min_lum = pal_okhsl[c].l
		end
		if pal_okhsl[c].l > max_lum then
			best_white = c
			max_lum = pal_okhsl[c].l
		end
	end
	return best_black, best_white
end
:: src/settings.lua
--[[pod_format="raw",created="2025-03-07 18:22:46",modified="2025-03-18 09:58:24",revision=460]]
local settings_folder = "/appdata/okpal/"
local settings_filepath = "/appdata/okpal/settings.pod"


function load_settings()
	mkdir(settings_folder)
	local s = fetch(settings_filepath)
	if s then
		for k, v in pairs(user_settings) do
			if type(s[k]) ~= "nil" then
				user_settings[k] = s[k]
			end
		end
	end
end


function change_settings(t)
	for k, v in pairs(t) do
		user_settings[k] = v
	end
	store(settings_filepath, user_settings)
end

:: src/soft_wrap.lua
--[[pod_format="raw",created="2025-03-07 11:09:14",modified="2025-03-12 15:05:26",revision=460]]
-- Soft-wraps a very tiny subset of markdown.
-- This code is absolutely horrible, but kind of work.
function soft_wrap(text, width)
	local space_width <const> = print(" ", -1000, -1000) + 1000
	local lines = {}
	local line = ""
	local x = 0
	local indentation = 0 -- indentation of the current paragraph

	local function add_word(word)
		if word == "" then return end
		local dx = print(word, -1000, -1000) + 1000
		if x + space_width + dx >= width then
			add(lines, line)
			line = ""
			x = 0
			for i = 1, indentation do
				line ..= " "
				x += space_width
			end
			line ..= word
			x += dx
		else
			if line:find("^%s*$") then
				line ..= word
				x += dx
			else
				line ..= " " .. word
				x += space_width + dx
			end
		end
	end
	
	local function add_line()
		add(lines, line)
		line = ""
		x = 0
	end
	
	local in_paragraph = false
	local in_code = false
	local ignore_word = false
	local ignore_line = false
	add_line()
	for hard_line in text:gmatch("([^\n]*)\n?") do
		ignore_line = false
		ignore_word = false
		if hard_line:find("^%s*$") then
			if in_paragraph then
				add_line()
				add_line()
				in_paragraph = false
				indentation = 0
			end
		elseif hard_line:find("^%s*- ") then
			if in_paragraph then
				add_line()
			end
			add_word("-")
			indentation = 2
			in_paragraph = true
			ignore_word = true
		elseif hard_line:find("^```%s*$") then
			if line ~= "" then
				add_line()
			end
			in_code = not in_code
			ignore_line = true
		else
			in_paragraph = true
 		end
 		
 		if not ignore_line then
	 		if in_code then
	 			line = hard_line
	 			add_line()
	 		else
				for word in hard_line:gmatch("([^%s]*)%s?") do
					if ignore_word then
						ignore_word = false
					else
						add_word(word)
					end
				end
			end
		end
	end
	add_line()
	
	return lines
end
:: src/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTAzIDE4OjA3OjM0Iixtb2RpZmllZD0iMjAyNS0w
My0yMiAwODoyMzozNCIsc3RvcmVkPSIyMDI0LTA0LTAzIDE4OjA3OjM0Il1d
:: label.qoi
b64$cW9pZgAAAeAAAAEOBAH_--Ho-f39-f39-f3T-qKIefI-wf65AD7yP8H_ooh5zD-9-f39-cwS
xD-XEtA-Es4-wBLPP-65AD7PP8ASzj-AEs8--qKIec4--f390xLAP8ASwD-HEsE-wBLBP8sSwT-I
EsQ-xhLGP8kSPxI-3RLFP8YSxT-HEs8-wBLPPxLPP-65AD7OPxLAPxLOPxLPP-6iiHnOP-39-dIS
wD-CEsA-xhLBP8ASwT-GEsI-EsE-yBI-whI-xhLGP8oSP8n_uQA_xj-P-qKIeT8SP9YS0D8SxD-B
EsE-wBLBPxLPP-65AD7OPxI-wBLDP8ESwT-AEsE-Es8--qKIec4--f390hLAP8ISwD-GEsE-wBLB
P8YSwj8SwT-IEj-CEj-GEsY-xhLHP8X_uQA_wj-BEj-L-qKIecE-EsE-xhLFP8cS0D8SxD8SwD8S
wj8SwD8Szz-_uQA_zj-AEj8Swz8SwD8Swj8SwD8Szz-_ooh5xj8SxT-9-f3SEsA-whLAP8YSxj-G
EsI-zBI-whI-xhLGP8YSwD-DEsA-xf65AD7CP8ESP8v_ooh5PxI-2hLQPxLEPxLAPxLAP8ESwD8S
zz-_uQA_zj8SwD8Swz8SwD8SwD-BEsA-Es8--qKIecU-wRLEP-39-dISwD-CEsA-xhI-EsI-Ej-G
EsU-yRI-wBLBP9YSwD-DEsA-xf65AD4-wRLCP8v_ooh5xT-GEsU-xxLQPxLEP8ESwD8SwD8SwD8S
zz-_uQA_zj8SwD8Swz-BEsA-EsA-EsA-Es8--qKIecY-EsU--f390hLAP8ISwD-GEj8Swj8SP8YS
xT-HEsE-wBLBP8YSxj-GEsA-wxLAP8X_uQA_P8ESwj-M-qKIecQ-1hLPP8ESwD8SwD8Swz-BEsA-
wBLOP-65AD7PP8ASwT8SwD8Swz-BEsA-wBLOP-6iiHnOP-39-dMSwD-AEsA-xxLGP8YSxT-HEsE-
yxLAP8ISwD-GEsc-xf65AD7GP_r_ooh51z8S2j-_uQA_1z8S2j-_ooh5zj-9-f39-eoS9D-_uQA_
9D-_ooh5zj-9-f39-cb_AAAA-f39-f39-f39-f39-f39-f39-f39-f39-f39-f39-f39-f394z81
PzU-NT81PzU-NcU-NT81PzU-NT81PzXQP9U1wz-WNf39-f39-cY-Nco-NcI-Nco-Nc0-1zXBPzXW
PzXuP-39-cY1-f3ZPzXPPzXMP9c1wT811j817j81yv4dK1PK-n4lU8r_AIdRyv6rUjbK-l9XT8r_
wsPHyj-K-v8ATcr_-6MAyv7-7CfK-gDkNsr_Ka3-yv6DdpzK-v93qMr_-8yqyj81xv69mt-uNf3Q
PzXPPzXaP9k1PzXYPzXtPzXKKMotyg-K-qtSNsouyjvKP8oNyiHKH8ojyv4prf-KEModyhTKPzXG
B_41-dc-NT81PzXBPzXEPzU-NT81xD81yz-DNcA-NT81PzXBPzXBP8A1wD-CNT81wj-BNT-BNT-B
NT-ANcE-wDXBPzXjP8I1xD81yijKLcoPyv6rUjbKLso7yj-KDcohyh-KI8r_Ka3-yhDKHcoUyj81
xgfuNcc-wTXHP8I19T81wz81PzXBPzXDPzXAPzXBPzU-NdA-wzU-wTU-NT81PzU-NT-BNT-FNcM-
NT81PzU-NT-BNT81PzU-NcQ-NeE-xDXDPzXKKMotyg-K-qtSNsouyjvKP8oNyiHKH8ojyv4prf-K
EModyhTKPzXGB8I1wAfBNcAH4zXGPzXBPzXFP8Q1yD817j81PzXFPzXIPzU-NcI-Nco-wzU-wTU-
NT81wD-ANcA-wDXBP8M1wz-ANcA-wTU-NT81P8A1wD-BNcI-NeA-xjXCPzXKKMotyg-K-qtSNsou
yjvKP8oNyiHKH8ojyv4prf-KEModyhTKPzXGB8E1B8A1BzUHwDUH4jXGPzXBPzXEP8Y1yD816D81
wz81yT81xj81zz-ENT-BNT81PzU-NT81P8M1P8Q1wj81PzU-NT81PzU-NT81wz81wz813j-ANT-A
NT81P8A1wT81yijKLcoPyv6rUjbKLso7yj-KDcohyh-KI8r_Ka3-yhDKHcoUyj81xgfENQc1B8A1
B_I1xT-FNcI-wDU-wDU-NT-ANcg-Neo-NT81PzU-NcM-NcY-NT81PzU-NcA-Nck-xTXAP8A1wD81
wT81wT81wD-FNcI-NT81PzU-NT81PzU-NcE-wDXEPzXePzXAP8I1wD81wT81yijKLcoPyv6rUjbK
Lso7yj-KDcohyh-KI8r_Ka3-yhDKHcoUyj81xgfDNQfBNcEH4jXFP8U1wj81wD-CNcA-NcM-xTXm
PzXBPzU-NT81xz81xD81PzU-Ncw-3zXaPzXePzXAP8A1wD81wj81yijKLcoPyv6rUjbKLso7yj-K
Dcohyh-KI8r_Ka3-yhDKHcoUyj81xgfCNQfENQfiNcU-wTU-wTXDPzXAP8A1wD81wz81P8M17D81
PzXFPzXIPzU-NcI-Ncg-3zXaPzXfPzXCPzXDPzXKKMotyg-K-qtSNsouyjvKP8oNyiHKH8ojyv4p
rf-KEModyhTKPzXGB8E1B8U1B_I1xT-BNT-BNcQ-NcI-NcQ-NcA-wTXoPzXDPzXJPzXGPzXNP-3U
Ncs-wjXEPzXKKMotyg-K-qtSNsouyjvKP8oNyiHKH8ojyv4prf-KEModyhTKPzXGB8E1wgfANcAH
4zXFP8U1xT-CNcU-NcE-Nfg-Nc8-Nf30PzXKKMotyg-K-qtSNsouyjvKP8oNyiHKH8ojyv4prf-K
EModyhTKPzXGB_41-dA-Nc8-Nf39xT81yijKLcoPyv6rUjbKLso7yj-KDcohyh-KI8r_Ka3-yhDK
HcoUyj81xgfuNf3RPzXKPzXCPzXKPzX99T-_JGOwyv4ApaHK-mVGiMr_ElNZyv50LynK-kUtMsoS
yv7-rMXK-rkAPsr_4msCyv6V8ELK-gCyUcr_ZN-2ygfK-uQNq8r_-4VXyj81xgfuNf3TPzU-NT81
PzU-NT81xT81PzU-NT81PzU-Nf32PyDKFco6yjnKG8oDyv6iiHnKMcr_uQA_ygDKMsomyjbKBzXI
Bw-KLMo-NcYH7jX9-ccozDXMKMw1zCjMNc8-wjXEPyDKFco6yjnKG8oDyv6iiHnKMcr_uQA_ygDK
MsomyjbKBzUHxjUHD8osyj81xgfuNf39xijNNcsozTXLKM01zj-ENcM-IMoVyjrKOcobygPK-qKI
ecoxyv65AD7KAMoyyibKNsoHNQfGNQcPyizKPzXGB_41-dI-yjXEP8o10SjONcoozjXKKM41zT-G
NcI-IMoVyjrKOcobygPK-qKIecoxyv65AD7KAMoyyibKNsoHNQfGNQcPyizKPzXGB_41-dE-Nco-
NcI-Nco-Nc8ozzXJKM81ySjPNcw-wDU-wDU-NT-ANcE-IMoVyjrKOcobygPK-qKIecoxyv65AD7K
AMoyyibKNsoHNQfGNQcPyizKPzXGB_41-dA-Ncw-NcA-Ncw-Nc0o0DXIKNA1yCjQNcw-NcA-wjXA
PzXBPyDKFco6yjnKG8oDyv6iiHnKMcr_uQA_ygDKMsomyjbKBzUHxjUHD8osyj81xgfuNf3QPzXE
P8A1xD81wD81wj-ENcI-Ncwo0TXHKNE1xyjRNc0-NcA-wDXAPzXCPyDKFco6yjnKG8oDyv6iiHnK
Mcr_uQA_ygDKMsomyjbKBzUHxjUHD8osyj81xgfuNf3QPzXBP8A1P8A1P8A1wT81wD81wT-BNcA-
wTXBPzXLKNI1xijSNcYo0jXOPzXCPzXDPyDKFco6yjnKG8oDyv6iiHnKMcr_uQA_ygDKMsomyjbK
BzUHxjUHD8osyj81xgfuNf3QPzXBP8Y1wT81wD81wT-ANcI-wDXBPzXLKNI1xijSNcYo0jXPP8I1
xD8gyhXKOso5yhvKA8r_ooh5yjHK-rkAPsoAyjLKJso2ygc1B8Y1Bw-KLMo-NcYH7jX90D81wj-E
NcI-NcA-Ncc-wDXBPzXLKNI1xijSNcYo0jXZPyDKFco6yjnKG8oDyv6iiHnKMcr_uQA_ygDKMsom
yjbKBzXIBw-KLMo-NcYH7jXEPzU-NT81PzU-wTXjP8E1P8E1P8E1wD81yj81wD-CNcA-wjXAPzXA
PzXGP8A1wj81yyjSNcYo0jXGKNI12T8gyhXKOso5yhvKA8r_ooh5yjHK-rkAPsoAyjLKJso2ygfK
D8osyj81xgfuNcQ-NT81PzU-NT81wj814j81PzU-NcE-NT81PzXJPzXAP8I1wD-CNcA-NcA-NcU-
wDXDPzXLKNI1xijSNcYo0jXZP-5JdR3K-kWnJ8r_AMNeyv4A0aDK-gCztcr_FYu3yv5dT9HK-u9v
-8r_-zzmyv6tAJXKNf3IPzXGB_41xD-BNT81PzU-wDXlP8A1PzU-NcE-NcA-Nco-NcI-xDXCPzXA
PzXEP8A1xD81y-4dK1PSNcYo0jXGKNI12T8kyhjKFsoqyifKLMoOyibK-v885soPyjX9yD81xgfu
NcQ-NT81PzU-NT81wj814j81PzU-NcE-Nc0-NcE-xjXBPzXAPzXEP8A1xD81y-4dK1PSNcYo0jXG
KNI1zz-CNcQ-JMI1wiTCGMI1whjCFsI1whbCKsI1wirCJ8I1wifCLMI1wizCDsI1wg7CJsI1wibC
-v885sI1wijCD8I1wg-CNf3IPzXGB_41xD81PzXAP8A1P8E14z-BNT-BNcE-Nc0-NcE-wDU-wDU-
wDXBPzXAPzXMPzXL-h0rU9I1xijSNcYo0jXOP8Q1wz8kwTXEJMEYwTXEGMEWwTXEFsEqwTXEKsEn
wTXEJ8EswTXELMEOwTXEDsEmwTXEJsH_-zzmwTXEKMEPwTXED8E1-cg-NcYH7jX90D81xD-ANcQ-
NcA-NcQ-wDXEPzXL-h0rU9E1xyjRNcco0TXOP8Y1wj8kwDXGJMAYwDXGGMAWwDXGFsAqwDXGKsAn
wDXGJ8AswDXGLMAOwDXGDsAmwDXGJsD_-zzmwDXGKMAPwDXGD8A1-cg-NcYH7jX90D81zD81wD81
zD81y-4dK1PQNcgo0DXIKNA1zj-ANT-ANT81P8A1wT8kwDXGJMAYwDXGGMAWwDXGFsAqwDXGKsAn
wDXGJ8AswDXGLMAOwDXGDsAmwDXGJsD_-zzmwDXGKMAPwDXGD8A1-cg-NcYH7jX90T81yj81wj81
yj81zP4dK1PPNckozzXJKM81zz81wD-CNcA-NcE-JMA1xiTAGMA1xhjAFsA1xhbAKsA1xirAJ8A1
xifALMA1xizADsA1xg7AJsA1xibA-v885sA1xijAD8A1xg-ANf3IPzXGB_41-dI-yjXEP8o1zf4d
K1PONcoozjXKKM410T81wD-ANcA-NcI-JMA1xiTAGMA1xhjAFsA1xhbAKsA1xirAJ8A1xifALMA1
xizADsA1xg7AJsA1xibA-v885sA1xijAD8A1xg-ANf3IPzXGB_41xT-ANT-BNT-BNT81PzU-wTU-
wTU-wTU-wTXAP8A1P8A1zD-BNT-BNT81PzX4-h0rU801yyjNNcsozTXTPzXCPzXDPyTBNcQkwRjB
NcQYwRbBNcQWwSrBNcQqwSfBNcQnwSzBNcQswQ7BNcQOwSbBNcQmwf7-PObBNcQowQ-BNcQPwTX9
yD81xgfuNcQ-NcE-NT81wD81wD81PzU-NT81PzU-NcA-NcE-NcA-NT81PzU-NcA-Ncg-NcE-NT81
wT81_P4dK1PMNcwozDXMKMw11T-CNcQ-JMI1wiTCGMI1whjCFsI1whbCKsI1wirCJ8I1wifCLMI1
wizCDsI1wg7CJsI1wibC-v885sI1wijCD8I1wg-CNf3IPzXGB_41xD-BNT-BNcA-NcA-NT81P8A1
wD-BNcA-NcE-NcA-NT81PzU-Ncs-wTU-wTXAPzX9-eQ-JMoYyhbKKsonyizKDsomyijKD8o1-cg-
NcYH7jXGPzU-NT81wD81wD81PzU-NT81PzU-NcA-NcE-NcA-NT81PzU-NcA-Nco-NT81PzU-Nf39
5T8kyhjKFsoqyifKLMoOyibKKMoPyjX9yD81xgfuNcQ-wDXAPzU-NcA-NcE-wDU-NT81PzU-NcA-
NcA-wTU-wDXAPzU-Ncs-wTU-wTU-NT81yz-cNf32PzX91P7RS_PKNf3gPzXGB_41-dE-zjXNPzX9
9T81-dQUyjX94D81xgfuNf3QP881zj81-fQ-Nf3UFMI1whTCNf3gPzXGB8s1B8U1B8A1wAfINQfB
NcAHxDX90D-PNc4-Nf30PzX91BTBNcQUwTX94D81xgfLNQfFNQc1B8A1B8c1B8A1B8Y1-dA-wTXJ
P8E1wj-BNcA-wzXAPzX99D81-dQUwDXGFMA1-eA-NcYHxjUHNQfANcEHwTXBBzUHwDUHwDXAB8E1
wQfANQfGNcQ-NcE-wTXAP8A1PzU-NT-BNT-ANcA-wTXAP8A1wD-ANc8-wTU-wTU-NT81yT-BNck-
wTXBP8M1P8M1wD81wf4dK1M1-eM-NcY-NcE-Nf3UFMA1xhTANf3gPzXGB8U1wwc1B8A1BzUHwDUH
wDXBB8I1BzUHwDUHNcIHxDXEPzXCPzXAPzXBPzU-NcA-NcA-NT81PzXBPzXBPzXCPzXOPzU-NT81
wT81yT-PNcE-wzU-wzXAPzXAKD8oNcwozDXMKMw1zCjMNcw-NcY-NcE-Nf3UFMA1xhTANf3gPzXG
B8Y1BzUHwDUHwDUHNQfANQfCNQfANcEHNQfANQfANQfGNcQ-NcI-NcA-NcE-wTXAPzXAPzU-NT-A
NcA-wTU-wTXRPzU-NT81wD81yj-BNck-wTXBP8M1P8M1wD81wCg-wCg1yijNNcsozTXLKM01zT81
xD81wj81-dQUwDXGFMA1-eA-NcYHxTXDBzUHwDUHNQfANQfCNQc1B8A1BzUHwDUHwDUHxjXEPzXC
PzXAPzU-NT81PzXAPzXAPzU-NT81wz81wT81wD81zj81PzU-NT81yz-BNck-wTXCP8E1wD-DNcA-
NcAoP8EoNcgozjXKKM41yijONc4-NcI-NcM-Nf3UFME1xBTBNf3gPzXGB8Y1BzUHwDXBB8E1wQfA
NcAHwTXBB8A1wQfANQfGNcQ-wTU-wTU-wTU-NT81wD81wD81PzU-wTU-wDXAP8A10j81P8E1PzU-
Nck-zzXOPzXAKD-CKDXGKM81ySjPNckozzXPP8I1xD81-dQUwjXCFMI1-eA-NcYH7jX90D-PNc4-
NcAoP8AowDXGKNA1yCjQNcgo0DXZPzX91BTKNf3gPzXGB_41-dE-zjXNPzXCKMA-KDXFKNE1xyjR
Ncco0TXZPzX91BTKNf3gPzXGB_41-dI-3DXNKNI1xijSNcYo0jXZP-39-cY1-f35KNI1xijSNcYo
0jX9-f39-f3eKNI1xijSNcYo0jX9-f39-f3eKNI1xijSNcYo0jX9-f39-f3eKNI1xijSNcYo0jX9
-f39-f3eKNI1xijSNcYo0jXZP-39-f399DXLKNI1xijSNcYo0jXZPzXyP8U1-f39-fU-Ncso0jXG
KNI1xijSNdk-NfE-xzX9-f399D81yyjRNcco0TXHKNE12j818T-HNecfwzX9-f39xj81yyjQNcgo
0DXIKNA12z818T-HNeYfxTX9-f39xT81yyjPNckozzXJKM813D818T-HNeUfxzX9-f39xD81yyjO
NcoozjXKKM413T818T-HNeUfxzX9-f39xD81yyjNNcsozTXLKM013j818j-FNeYfxzX9-f39xD81
yyjMNcwozDXMKMw13z818-7-zKrDNecfxzX9-f39xD81-fQ-NfIUxTXmH8c1-f39-cQ-Nf30PzXx
FMc15h-FNdYywzX9-f3mPzX99D818RTHNecfwzXWMsU1-f395T81-fQ-NfEUxzX9xTLHNf3INsM1
-f3VPzX99D818RTHNf3FMsc1-cc2xTX9-dAxwzX99D818RTHNf3FMsc1-cY2xzX2O8M1-c8xxTX9
8z818hTFNf3GMsc1-cY2xzX1O8U1-c0xxzX98j818xTDNf3HMsc1wiPDNfs2xzX0O8c1-cwxxzXP
KMw1zCjMNcwozDXZPzX9wyHDNfgyxTXCI8U1_jbHNfQ7xzX9zDHHNc4ozTXLKM01yyjNNdk-Nf3C
IcU1_DLDNcIjxzX5Nsc19DvHNf3MMcc1zSjONcoozjXKKM412T81-cEhxzX9wiPHNfo2xTX1O8c1
-cwxxzXMKM81ySjPNckozzXZPzX9wSHHNf3CI8c1_zbDNfY7xzX9zTHFNcwo0DXIKNA1yCjQNdk-
NeT_-4VXwzXUIcc1-cIjxzX9_zvFNdk-wzXtMcM1zCjRNcco0TXHKNE12T814yzFNdMhxzX9wiPH
Nf38O8M12T8Hwz817B3DNcso0jXGKNI1xijSNdk-NeIsxzXSIcc1-cMjxTX9-d4-B8U-NeodxTXK
KNI1xijSNcYo0jXPP8I1xD814izHNdMhxTX9xSPDNf3eCsM19z8Hxz816B3HNcko0jXGKNI1xijS
Nc4-NcI-NcM-NeIsxzXUIcM1-f3qCsU19j8Hxz816B3HNcko0jXGKNI1xijSNc4-NcM-NcI-NeIs
xzX9-f3GCsc19T8Hxz816B3HNcko0jXGKNI1xijSNcg-NT-ANcA-NcQ-NcE-NeIsxzX9-f3GCsc1
9T8Hxz816B3HNcko0jXGKNI1xijSNcg-NT81PzU-NcU-NcA-NeMsxTX9-f3HCsc19T8Hxz816B3H
Ncko0jXGKNI1xijSNck-wDU-NT81xD81wT815CzDNf3p-gCyUcM1-dYKxzX2PwfFPzXqHcU1yijS
NcYo0jXGKNI1zj81wz81wj817gDDNf3eJsU14hXDNeoKxzX3PwfDPzXsHcM1yyjRNcco0TXHKNE1
yT81P8A1wD81wj81wz817QDFNf3cJsc14BXFNeoKxTX5P8M18T81yyjQNcgo0DXIKNA1yj81PzU-
NcA-wjXEPzXNDcM12ADHNf3bJsc13xXHNeoKwzX99D81yyjPNckozzXJKM81zD-ANT81yj81zA3F
NdcAx-6iiHk1-domxzXfFcc1-f3nPzXLKM41yijONcoozjXdPzXLDcc11gDHEjX92ibHNd8VxzX9
-dP_5A2rwzXNPzXLKM01yyjNNcsozTXNPzXBPzXKPzXLDcc11gDHEjX92ibHNd8VxzX9-dIPxTXM
PzXLKMw1zCjMNcwozDXOPzU-NT81yj81yw3HNdYAxxI1-dsmxTXgFcc1-eYQwzXiD8c1yz81-eM-
wzXKPzXLDcc11wDFEsA1-dwmwzXiFcU1-eYQxTXhD8c1yz81-fQ-NcsNxzXYAMMSwDX9-ckVwzX9
5hDHNeAPxzXLPzX95D-CNco-NcwNxTXaEsM1-f399xDHNeAPxzXLPzX94z81zj81zQ3DNf39yf4A
h1HDNf39yxDHNeD_5A2rxzXLPzX94z-DNco-NeL_q1I2wzX98f4Ah1HFNf39yhDHNeH_5A2rxTXM
PzX99D814QrFNf3v-gCHUcc1-f3JEMc14v7kDavDNc0-Nf3jPzXOPzXgCsc1-e7_AIdRxzX9-coQ
xTX3PzX94z-DNco-NeAKxzX97g-HNf39yxDDNfg-NdEozDXMKMw1zCjMNcg-Nc4-Ncr_uQA_wzXP
Csc1-e4PxzX93CDDNf3nPzXQKM01yyjNNcsozTXZPzXJEsU1zgrHNf3uD8c1-dsgxTX95j81zyjO
NcoozjXKKM41yD-DNco-NcgSxzXNCsc1-e8PxTX92yDHNf3lPzXOKM81ySjPNckozzXKPzXMPzXI
Esc1zgrFNf3xD8M1-dwgxzX95T81zSjQNcgo0DXIKNA1yD-DNco-NcgSxzXPCsM11i7DNf39_CDH
Nec6wzX1PzXMKNE1xyjRNcco0TXZPzXIEsc16y7FNf399yDHNeY6xTX0PzXLKNI1xijSNcYo0jXI
PzXAP8A1yj81yBLHNeouxzX9-fYgxzXlOsc18z81yyjSNcYo0jXGKNI1yD81wT81yj81yRLFNesu
xzX9-fcgxTXmOsc18z81yyjSNcYo0jXGKNI1yT-CNco-NcoSwzXsLsc1-f34IMM15zrHNegtwzXE
PzXLKNI1xijSNcYo0jXZPzX9Lsc1-f3EOcM1-d06xzXnLcU1wz81yyjSNcYo0jXGKNI1yD81wT81
yj811xvDNd8uxzX9-cM5xTX93DrHNeYtxzXCPzXLKNI1xijSNcYo0jXIP8M1yj811hvFNd8uxTX9
-cM5xzX93DrFNectxzXCPzXLKNI1xijSNcYo0jXIPzXBPzXKPzXVG8c13y7DNf39xDnHNf3dOsM1
6C3HNcI-Ncso0jXGKNI1xijSNdk-NdUbxzX9-eo5xzX9-c4txzXCPzXLKNE1xyjRNcco0TXNPzXK
PzXVG8c1-f3qOcc1-f3OLcc1wj81yyjQNcgo0DXIKNA1zj81yj811RvHNf396jnHNf39zy3FNcM-
NcsozzXJKM81ySjPNcs-wzXKPzXBA8M1zRvHNf396znFNf390S3DNcQ-NcsozjXKKM41yijONd0-
NcADxTXNG8U1-f3tOcM1-f3dPzXLKM01yyjNNcsozTXePzUDxzXNG8M1-f39-f3UPzXLKMw1zCjM
NcwozDXfPzUDxzX9-f39xijDNf3bPzX99D81A8c1-f39-cUoxTX92j81-fQ-NQPHNf39-f3EKMc1
-dk-Nf30PzUDxzX9-f39xCjHNf3ZPzX99D81wAPFNf39-f3FKMc1-dk-Nf30PzXBA8M1-f39-cYo
xzX92T81-fQ-Nf39-f3OKMc1-dk-Nf30PzX9-f39zyjFNf3aPzX99D81-f39-dAowzX92z810SjM
NcwozDXMKMw12T81-f39-f3yPzXQKM01yyjNNcsozTXZPzX9-f39-fI-Nc8ozjXKKM41yijONdk-
Nf39-f398j81zijPNckozzXJKM812T81-f39-f3yPzXNKNA1yCjQNcgo0DXZPzX9-f39-fI-Ncwo
0TXHKNE1xyjRNdk-Nf39-f398j81yyjSNcYo0jXGKNI12T81-f39-f3yPzXLKNI1xijSNcYo0jXZ
PzX9-f39-fI-Ncso0jXGKNI1xijSNdk-Nf39-f398j81yyjSNcYo0jXGKNI12T81-f39-f3yPzXL
KNI1xijSNcYo0jXZPzX9-f39-fI-Ncso0jXGKNI1xijSNdk-Nf39-f398j81yyjSNcYo0jXGKNI1
2T81-f39-f3yPzXLKNI1xijSNcYo0jXZP-39-f399DXLKNE1xyjRNcco0TX9-f39-f3fKNA1yCjQ
Ncgo0DXdP8A1wD-ANT-BNcs-wTU-wTU-wDXHP8A1P8E1P8E1P8A1wT-ANT-BNeA-NT81P8E1PzXB
PzXCP8A1PzU-Nco-wDU-wTU-wTU-wTU-wDXkP8A1PzU-NT-BNT-ANfU-wTU-NcE-NT81P8E1yT81
PzU-wTXAP8A1PzXBP8E1P8E1yT-BNT81PzU-wTU-wTU-NcE-wTXQP8E1zSjPNckozzXJKM813T81
PzU-NcE-Nc0-NT81PzXBPzU-NcU-NT81PzU-NT81PzU-NT81PzXBPzXiPzU-NT81wT81wT81wT81
PzU-NT81yT81wT81PzU-NcE-NcE-NT814j81wT81PzU-NT81PzU-NfQ-NT81PzXBPzU-NT81yz81
PzXAPzXAPzU-NT81wT81wj81yj81PzU-NT81PzU-NT81PzU-NcE-NdI-NT81zSjONcoozjXKKM41
3j81PzU-wTU-wDXMP8A1wD-ANcA-NT81xT81PzU-wDXAP8E1PzU-NT81wT-ANcEhwzXZP8AfwzU-
NcE-NcE-NT81PzU-Nck-NcE-wDXAP8A1wD-ANcA-NT814j81wT-BNT-BNT81PzX0P8A1wD81wT81
PzU-wDXKPzU-NcA-NcA-NT81PzXBP8A1wT81yj-BNT81PzU-wDXAP8E1PzXBP8A10T-ANc4ozTXL
KM01yyjNNd8-NT81wT81PzXBEsMNwTXCPzU-NT81wT81PzXBLMM1PzU-NQDDFMM-NT81PzXBIcU1
2R-FPzXBPzXBPzU-NT-BNck-NT81PzU-NT8jwzUmwzXAD8M12j81FcM1PzU-NT81PzXk-imt-8M1
yT81PzU-NcE-NT81PzXLP8E1wD81wD81PzU-NcE-NcI-Nco-NcE-NT81PzU-NT81wT81wT810jHD
NcsozDXMKMw1zCjMNeA-wDXAP8A1wD-BEsUNwTXBPzU-NT-BNT-BNcAsxTXAPwDFFMM-wDU-wSHH
Ndcfxz-ANT-BNT-ANcA-wTXJP8E1PzU-NSPEJsUPxTXaFcU-NT81PzU-NeMKxTXIP8E1P8E1wD-A
NT-BNco-NcA-wTU-wDXAP8E1P8E1wD81yj81wj-ANT81PzU-NcE-wTU-wTXA-uQNq8M1yDHFNf39
wBLHDcE1zCzHNQDHFMM1wyHHNdcfxzXeI8Qmx-4Ah1HFNdgVxzXoCsc1-d3_5A2rxTXGMcc1-fI-
yRLHDcE-zCzHPwDHFMM-wyHHP9cfxz-eI8Qmx-4Ah1HFP9gVxz-oCsc--dz_5A2rxz-FMcc1-fI-
NcgSxw3BNcwsxzUAxxTDNcMhxzXXH8c13iPEJsf_AIdRxTXYFcc16ArHNf3c-uQNq8c1xTHHNf3y
PzXIEscNwTXMLMc1AMcUwzXDIcc11x-HNd4jxCbH-gCHUcU12BXHNegKxzX93P7kDavHNcUxxzX9
8j81yBLHDcE1zCzHNQDHFMM1xCHFNdkfxTXfI8Qmx-4Ah1HFNdgVxzXoCsc1-dz_5A2rxzXFMcc1
-fI-NckSxQ3BNc4sxTXBAMUUwzXGIcM12x-DNdcywzXDI8Qmxf4Ah1HFNdoVxTXqCsU1-d3_5A2r
xzXGMcU1-fM-NcoSww3BNdAswzXDAMMUwzX9yDLFNcMjwzUmwzXA-gCHUcM13BXDNewKwzX93-7k
DavFNcgxwzX99D81-f3DMsc1-f390A-DNc0-NdEozDXMKMw1zCjMNdk-Nf39wzLHNf39-eQ-NdAo
zTXLKM01yyjNNdk-Nf39wzLHNf3INsM1-f3VPzXPKM41yijONcoozjXZPzX9-cMyxzX9xzbFNf39
1D81zijPNckozzXJKM812T81-f3DMsc1-cY2xzX9-dM-Nc0o0DXIKNA1yCjQNdk-Nf39xDLFNf3H
Nsc1-f3TPzXMKNE1xyjRNcco0TXZPzX9-cUywzX9wjnDNTbHNf390z81yyjSNcYo0jXGKNI12T81
-f39zTnFNsc14yDDNf3nPzXLKNI1xijSNcYo0jXZPzX9-f3MOcY2xzXiIMU1-eY-Ncso0jXGKNI1
xijSNdk-Nf39-cw5xzbFNeIgxzX95T81yyjSNcYo0jXGKNI12T81-f39zDnHNTbDNeMgxzX95T81
yyjSNcYo0jXGKNI12T81-f39zDnHNekgxzX95T81yyjSNcYo0jXGKNI12T81-f39zDnHNekgxzX9
5T81yyjSNcYo0jXGKNI12T81-f39zTnFNeogxzX95T81yyjSNcYo0jXGKNI12T81-f39zjnDNewg
xTX95j81yyjRNcco0TXHKNE12j81-f39-cQgwzX93C3DNcQ-Ncso0DXIKNA1yCjQNds-Nf39-f39
5i3FNcM-NcsozzXJKM81ySjPNcw-wjXKPzXi-qtSNsM1-f39-fotxzXCPzXLKM41yijONcoozjXM
PzXOPzXhCsU1-f39-fktxzXCPzXLKM01yyjNNcsozTXNP8M1yj814ArHNf39-f34Lcc1wj81yyjM
NcwozDXMKMw13z811xvDNcIKxzX9-f39_C3HNcI-Nf3jP8I1yz811hvFNcEKxzX9-f39_C3HNcI-
Nf3jPzXBPzXKPzXVG8c1wArHNf39-f35LcU1wz81-eQ-wjXKPzXVG8c1wArHNf39-f36LcM1xD81
-fQ-NdUbxzXBCsU1-f39-f3IPzX94z81wT81yj811RvHNcIKwzX9-f39zz-DNfE-Nf3jP8M1wD-C
NcQ-NdUbxzX9-f3uKMM14D8Hwz818D81-eM-NcE-NT81wj81wz811hvFNf39-e4oxTXePwfFPzXv
PzX96T81wz81wj811xvDNf39-e4oxzXcPwfHPzXuPzXRKMw1zCjMNcwozDXIPzXDPzXEPzXBPzX9
-f39zijHNdw-B8c-Ne4-NdAozTXLKM01yyjNNcg-wzU-NcU-NcA-Nf39-f3OKMc12zo-B8c-Ne4-
Nc8ozjXKKM41yijONcg-NcM-NcQ-NcE-Nf39-f3OKMc12jrAPwfHPzXuPzXOKM81ySjPNckozzXO
PzXDPzXCPzX9-f39zijHNdk6wT8Hxz817j81zSjQNcgo0DXIKNA1yD-DNT81wj81wz81-f39-c8o
xTXaOsI-B8U-Ne8-Ncwo0TXHKNE1xyjRNcg-NT81wj-CNcQ-Nf39-f3QKMM12zrDPwfDPzXwPzXL
KNI1xijSNcYo0jXIP8M1yj81-f39-fI6xD-DNfE-Ncso0jXGKNI1xijSNdk-Nf39-f3yOsc18z81
yyjSNcYo0jXGKNI1yD-ANT-ANco-Nf39-f3zOsU19D81yyjSNcYo0jXGKNI1yD81PzXMPzX9-f39
9DrDNfU-Ncso0jXGKNI1xijSNcg-wzXKPzX9-f39-fI-Ncso0jXGKNI1xijSNdk-Nf39-f398j81
yyjSNcYo0jXGKNI1yD-DNco-Nf39-f398j81yyjSNcYo0jXGKNI1zD81yj81-f39-f3yPzXLKNE1
xyjRNcco0TXJP8I1yz81-f39-f3yPzXLKNA1yCjQNcgo0DXbPzX9-f39-fI-NcsozzXJKM81ySjP
Ncs-Nc4-Nf39-f398j81yyjONcoozjXKKM41zD-DNco-Nf39-f398j81yyjNNcsozTXLKM01zT81
zj81-f39-f3yPzXLKMw1zCjMNcwozDXfPzX9-f39-fI-Nf3jP8M1yj81-f39-f3yPzX94z81PzXM
PzX9-f39-fI-Nf3jP8M1yj81wQPDNf39-f3pEMM1_D81-fQ-NcADxTX9-f395xDFNfc-Nf3jPzU-
wDXLPzUDxzX9-f395RDHNfY-Nf3jPzU-NT81yj81A8c1-f39-eUQxzX2PzX95D-ANT81yj81A8c1
-f39-eUQxzX2PzX99D81A8c1-f39-eUQxzX2PzXRKMw1zCjMNcwozDXZPzUDxzXl-qKIecM1-f39
9xDHNfY-NdAozTXLKM01yyjNNdk-NcADxTXlEsU1-f399xDFNfc-Nc8ozjXKKM41yijONdk-NcED
wzXlEsc1-f399xDDNfg-Nc4ozzXJKM81ySjPNdk-Ne0SxzX9-f39_D81zSjQNcgo0DXIKNA12T81
7RLHNf39-f34PzXMKNE1xyjRNcco0TXZPzXtEsc1-f39-fg-Ncso0jXGKNI1xijSNdk-Ne0SxzX9
-f39_D81yyjSNcYo0jXGKNI12T817hLFNf39-f35PzXLKNI1xijSNcYo0jXZPzXvEsM1-f39-fo-
Ncso0jXGKNI1xijSNdk-Nf3BLsM1-f39-eo-Ncso0jXGKNI1xijSNdk-Nf3ALsU1-f39-ek-Ncso
0jXGKNI1xijSNdk-Nf0uxzX9-f396D81yyjSNcYo0jXGKNI12T81-S7HNf39-f3oPzXLKNI1xijS
NcYo0jXZPzX9Lsc1-f39-eg-Ncso0TXHKNE1xyjRNdo-Nf0uxzX9-f3NO8M1-dQ-Ncso0DXIKNA1
yCjQNds-Nf0uxzX9-f3MO8U1-dM-NcsozzXJKM81ySjPNdw-Nf3ALsU1-f39zDvHNf3SPzXLKM41
yijONcoozjXdPzX9wS7DNf39-c07xzX90j81yyjNNcsozTXLKM013j81-f39-dU7xzX90j81yyjM
NcwozDXMKMw13z81-f39-dU7xzX90j81-fQ-Nf39-f3VO8c1-dI-Nf30PzX9-f391jvFNf3TPzX9
9D81-f39-dc7wzX91D81-fQ--f39-f30Nf39-f39-f39-f39-f39-f3fP9M1-f39-f3bPzX99j81
0z81-f39-f3ZPzU-Nf30PzXVPzXb-v8fisT_-yl6xP7-MGrE-v81WsT_-zlHxP7-PTDE-v5CAMT_
8VcAxP7nZADE-t1tAMT_1XQAxP7OegDE-sd_AMT_wYMAxP66hwDE-rSKAMT_rY4AxP6mkQDE-p_U
AMT_lpgAxP6NmwDE-oGfAMT_c6MAxP5epwDE-jutAMT_AK8xxP4ArlTE-gCsaMT_AKt2xP4AqoLE
-gCpi8T_AKiUxP4Ap5vE-gCmosT_AKWpxJ_fxP4Ao7bE-gCivcT_AKHExP4An8zE-gCe1MT_AJvf
xP4AmOvE-gCU_8T_M5D-xP5NjP-E-l_I-8T_boP-xP57f--E-od6-8T_k3T-xD-_AAAAwT-_n23-
-qxk-8T_uVj-xP7IR--E-tkl-8T_5QDzxP7sAOHE-vIAz8T__AC_xP78AKzANf3APzXBP8A1PzXB
P8E1P8E1P8A1wT812-7-H4rE-v8pesQIxDHE-v85R8T_-z0wxDnEO8T_52QAxC3EOMQBxP7HfgDE
-sGDAMT_uocAxAPEAsQ8xP6flADEL8QjxP6BnwDEPcQSxP47rQDEN8QnxP4ArGjE-gCrdsT_AKqC
xP4AqYvE-gColMT_AKebxCHEDcSfn8T_AKO2xArE-gChxMQkxP4AntTE-gCb38T_AJjrxP4AlPvE
-jOQ-8T_TYz-xP5fiP-E-m6D-8T_e3--xCXEK8M--gAAAMM-JsT_uVj-xP7IR--E-tkl-8T_5QDz
xCDENMT__AC_xB3ANf3APzXAPzXBPzXBPzXBPzU-NT81PzXAPzXb-v8fisT_-yl6xAjEMcT_-zlH
xP7-PTDEOcQ7xP7nZADELcQ4xAHE-sd_AMT_wYMAxP66hwDEA8QCxDzE-p_UAMQvxCPE-oGfAMQ9
xBLE-jutAMQ3xCfE-gCsaMT_AKt2xP4AqoLE-gCpi8T_AKiUxP4Ap5vEIcQNxJ_fxP4Ao7bECsT_
AKHExCTE-gCe1MT_AJvfxP4AmOvE-gCU_8T_M5D-xP5NjP-E-l_I-8T_boP-xP57f--EJcQrwj-_
AAAAxT8mw-65WP-E-shH-8T_2SX-xP7lAPPEIMQ0xP74AL7EHcA1-cA-NcA-NcE-NcE-wDXAP8E1
P8A1wT812-7-H4rE-v8pesQIxDHE-v85R8T_-z0wxDnEO8T_52QAxC3EOMQBxP7HfgDE-sGDAMT_
uocAxAPEAsQ8xP6flADEL8QjxP6BnwDEPcQSxP47rQDEN8QnxP4ArGjE-gCrdsT_AKqCxP4AqYvE
-gColMT_AKebxCHEDcSfn8T_AKO2xArE-gChxMQkxP4AntTE-gCb38T_AJjrxP4AlPvE-jOQ-8T_
TYz-xP5fiP-E-m6D-8T_e3--xCXEK8I--gAAAMU-JsP_uVj-xP7IR--E-tkl-8T_5QDzxCDENMT_
_AC_xB3ANf3APzXAPzXBPzXBPzXBPzU-NT81PzXAPzXb-v8fisT_-yl6xAjEMcT_-zlHxP7-PTDE
OcQ7xP7nZADELcQ4xAHE-sd_AMT_wYMAxP66hwDEA8QCxDzE-p_UAMQvxCPE-oGfAMQ9xBLE-jut
AMQ3xCfE-gCsaMT_AKt2xP4AqoLE-gCpi8T_AKiUxP4Ap5vEIcQNxJ_fxP4Ao7bECsT_AKHExCTE
-gCe1MT_AJvfxP4AmOvE-gCU_8T_M5D-xP5NjP-E-l_I-8T_boP-xP57f--EJcQrwj-_AAAAxT8m
w-65WP-E-shH-8T_2SX-xP7lAPPEIMQ0xP74AL7EHcA1-cA-NcE-wDU-wTU-wTU-NT81PzU-NcA-
Ndv_-x_KxP7-KXrECMQxxP7-OUfE-v89MMQ5xDvE-udkAMQtxDjEAcT_x34AxP7BgwDE-rqHAMQD
xALEPMT_n5QAxC-EI8T_gZ8AxD3EEsT_O60AxDfEJ8T_AKxoxP4Aq3bE-gCqgsT_AKmLxP4AqJTE
-gCnm8QhxA3En5-E-gCjtsQKxP4AocTEJMT_AJ7UxP4Am9-E-gCY68T_AJT7xP4zkP-E-k2M-8T_
X4j-xP5ug--E-nt--8QlxCvCP-4AAADFPybD-rlY-8T_yEf-xP7ZJf-E-uUA88QgxDTE-vgAvsQd
wDX9wD811T81-f39-f3WP8U1-fM-NdM-Nf39-f39-f3WP9M1-f39-f39-f39-e8-wDXAP8A1wD-A
NcA-wDXAPzU-NT81PzU-wTXAP8A1wD-ANcA-wDXAP8A1-f39-f39-cA-wDXAP8A1wD-ANcA-wDXB
PzU-NT81PzU-NcM-wDXAP8A1wD-ANcA-wDX9-f39-f38P8A1wD-ANcA-wDXAP8A1wj-BNT81PzU-
wDXDP8A1wD-ANcA-wDXAP8A1-f39-f39-D-ANcA-wDXAP8A1wD-ANcE-NT81PzU-NT81wz-ANcA-
wDXAP8A1wD-ANf39-f39-f3AP8A1wD-ANcA-wDXAP8A1wD81PzXAP8A1P8E1wD-ANcA-wDXAP8A1
wD-ANf39-f3LAAAAAAAAAAE=
:: main.lua
--[[pod_format="raw",created="2024-03-31 05:33:06",modified="2025-03-22 08:23:33",revision=9593]]
include "src/globals.lua"
include "src/custom_wrangle.lua"
include "src/oklab.lua"
include "src/palette.lua"
include "src/settings.lua"
include "src/files.lua"
include "src/integration.lua"
include "src/soft_wrap.lua"
include "src/gui.lua"
include "src/gui_palette.lua"
include "src/gui_alt_sliders.lua"
include "src/gui_old_sliders.lua"
include "src/gui_settings.lua"
include "src/gui_help.lua"
include "src/gui_newfile.lua"
include "src/gui_hexdialog.lua"


function _init()
	load_settings()

	window {
		tabbed = true,
		icon = --[[pod_type="gfx"]]unpod("b64:bHo0ABYAAAAUAAAA8AVweHUAQyAICARwtyBHIBcgRyC3cA=="),
	}
	
	local default_folder = "/ram/cart/pal/"
	-- TODO: useful or not?
--	if env().sandbox then
--		default_folder = "/appdata/pal/"
--	end
	
	local working_file_path = env()[1]
	if type(working_file_path) ~= "string" then
		mkdir(default_folder)
		working_file_path = default_folder .. "0.pal"
	end

	custom_wrangle_working_file(
		save_working_file,
		load_working_file,
		working_file_path
	)

	menuitem{
		id = "export_hex",
		label = "\^:7f4141417f616500 Export File",
		action = function()
			local current_filename = pwf()
			local segs = split(current_filename,"/",false)
			local path = string.sub(current_filename, 1, -#segs[#segs] - 2) -- same folder as current file
			create_process("/system/apps/filenav.p64", 
				{path=path, intention="select_file", use_ext = "hex", window_attribs={workspace = "current", autoclose=true}})
		end
	}
	on_event(
		"select_file",
		function(event)
			local filename = event.filename
			local ext = event.filename:ext()
			if ext == nil then
				filename ..= ".hex"
				ext = "hex"
			end
			notify("Palette exported to " .. filename)
			if ext == "hex" or ext == "txt" then
				store(filename, save_hex_file(), { metadata_format="none" })
			else
				local data, metadata = save_pal_file()
				store(filename, data, metadata)
			end
		end
	)

	
	-- Force the 11 first rows of the screen to use a default palette,
	-- so that the menu bar stays readable even when the colors used by
	-- the gui are redefined.
	poke(0x5400, 0b01010101, 0b01010101, 0b00010101)
	init_color_band()
	
	rebuild_pal()
	
	on_event("lost_focus", function() send_palette() end)
		
	on_event("drop_items", handle_drop_items)
	
	undo_stack = create_undo_stack(undo_save_state, undo_load_state)

	menuitem { id = "okpal_div1", label = "", divider = true, action = function() end }
	menuitem {
		id = "okpal_clear_colors",
		label = "\^:0000000000000000 Clear Palette",
		action = function() undo_stack:checkpoint(); clear_colors() end
	}
	menuitem {
		id = "okpal_reset_colors",
		label = "\^:0000000000000000 Reset Pic. Colors",
		action = function() undo_stack:checkpoint(); reset_picotron_colors() end
	}
	menuitem { id = "okpal_div2", label = "", divider = true, action = function() end }
	menuitem {
		id = "okpal_manual",
		label = "\^:0000000000000000 Help",
		shortcut = "F1",
		action = open_help
	}
	
	test_cube_colors = test_cube_colors or copy(default_test_cube_colors)
	test_ramp_colors = test_ramp_colors or default_test_ramp_colors:convert("u8")
	generate_gui()
	
	if is_new_file then
		open_new_file_dialog()
	end
	
	if imported_hex_file then
		open_import_hex_file_dialog()
	end
end


function _draw()
	cls(bg_color)
	gui:draw_all()
	blinked()
end


function _update()
	if padlock_flashing then
		padlock_flashing_time += 1
	end
	if crying_a_timer > 0 then
		crying_a_timer -= 1
		if crying_a_timer <= 0 then
			crying_a_done = true
		end
	end
	if circling_anim_timer > 0 then
		circling_anim_timer -= 1 / 12.0
	end
	
	if gui_changed then
		generate_gui()
		refresh_modal()
		gui_changed = false
	end
	gui:update_all()
	
	if key("ctrl") then
		if keyp("c") then copy_color() end
		if keyp("x") then cut_color() end
		if keyp("v") then paste_color() end
		if keyp("z") then undo_stack:undo(); update_hidden_toggles() end
		if keyp("y") then undo_stack:redo(); update_hidden_toggles() end
	end
	
	if keyp("f1") then open_help() end
	
	if keyp("tab") then
		pickers_mode = (pickers_mode == "linear_hue") and "circular_hue" or "linear_hue"
		gui_changed = true
	end
	
	if keyp("n") then
		change_settings({ show_color_names = not user_settings.show_color_names })
		gui_changed = true
	end
	if keyp("b") then
		change_settings({ show_color_band = not user_settings.show_color_band })
		if user_settings.show_color_band then
			show_color_band()
		else
			hide_color_band()
		end
		gui_changed = true
	end
end




-- Undo ---------------------------------------------------------------------------


function undo_save_state(_item)
	return {
		pal_okhsl = copy(pal_okhsl),
		pal_code = copy(pal_code),
		test_cube_colors = copy(test_cube_colors),
		test_ramp_colors = test_ramp_colors and test_ramp_colors:convert("u8"),
	}
end


function undo_load_state(state, _item)
	pal_okhsl = state.pal_okhsl
	pal_code = state.pal_code
	test_cube_colors = state.test_cube_colors
	test_ramp_colors = state.test_ramp_colors
	for c = 0, 63 do
		set_color(c, pal_code[c])
	end
--	send_palette() -- TODO: remove permanently?
end


function copy(t)
	if type(t) == "table" then
		local new = {}
		for k, v in pairs(t) do
			new[k] = copy(v)
		end
		return new
	else
		return t
	end
end

:: manual.txt
--[[pod_format="raw",created="2024-04-04 06:47:16",icon=userdata("u8",16,16,"00000101010101010101010101000000000106060606060606060606060100000107010606060606060606060606010000010106060707070707070707060100000106060607070707060606070601000107010606070707070606060706010000010106060706060607070707060100000106060607060606070707070601000107010606070707070707070706010000010106060606060606060606060100000106060606060606060606060601000107010606060606060606060601010000010101010101010101010101070100000101070707070707070707070601000000010606060606060606060601000000000001010101010101010101000000"),modified="2025-03-20 14:23:57",revision=1154,stored="2024-04-04 06:56:33"]]
# OkPal

OkPal is a tool to create and edit color palettes.
You can easily use those palettes in your programs,
and even directly in Picotron's sprite and map editors.

To use a palette, add the following line to your 
initialisation code:

```
    fetch("pal/0.pal"):poke(0x5000)
```


## Features

- Colors are defined by their hue, saturation and
  lightness; the calculations use a perceptually
  uniform color space (OkLAB).
- Colors are displayed and edited on multiple
  2D graphs.
- Any change to the palette is propagated to
  Picotron's sprite and map editors.
- Ability to reorder colors by drag-and-drop.
- Undo/redo for all operations.
- Two file formats are supported: ".hex" and ".pal".
- Multiple options for importing external palettes
  (keep default palette, overwrite it, or try to 
  match it)


## Usage

The screen is separated in three different zones:
- At the top, the full palette is displayed, with
  colors ordered by number (sams as in the sprite
  editor first tab). The currently selected color
  is also displayed here.
- On the right, a "test zone" allows you to paint
  on cubes or square to test your modified palette.
- The rest of the screen display the colors as
  dots on interactive 2D graphs, called "pickers"
  in this manual. This is the main way to create
  and edit colors.


To modify a color, you must first select it. You can
do that either by clicking in the palette overview
at the top of the screen, or by clicking directly on
one of the color dots in the circle picker or in the
square picker.

Once selected, some information about the color are
displayed on the right of the palette overview:

- the color number;
- the hex code corresponding to the RGB values of
  the color;
- a padlock icon: if the padlock is closed, the color
  is "locked" and cannot be edited; click on the icon
  to lock/unlock it;
- an eye icon: if the eye is closed, the color is only
  shown in the palette overview; it is hidden in the
  circle and square pickers.
- a paint bucket icon: you can click on it to change
  the color background to the current selected color;
  click again to go back to a black background.

You can copy the current color by using Ctrl-C, and
paste a copied color onto the current one by using
Ctrl-V. This also works outside OkPal: the color is
stored in the clipboard as a hex code ("#ffacc5").

There is five different ways to adjust the selected
color:

- a small triangle *outside* the circle picker
  allows you to change the hue of the color;
- a small colored circle *inside* the circle picker
  allows you to change at the same time the hue and
  the saturation;
- a small colored triangle below the square picker
  allows you to change just the saturation;
- a small colored triangle at the right of the square
  picker allows you to change the lightness;
- finally, a small colored circle inside the square
  picker allows you to change at the same time the
  saturation and the lightness.

Any change you make can be reverted by hitting
Ctrl-Z for undo. Use Ctrl-Y for redo.

Once you have several colors in you palettes, you can
reorder them in the palette overview: just drag one
color onto another, they will swap their positions.
Note that both colors must be unlocked.


## Using the palette in cartridges

By default, the palette you edit is saved in the
cart you're working on, alongside your sprite sheets
and maps.

The default path is "/ram/cart/pal/0.pal"

In order to use a palette in your programs, you just
need to copy it in memory. The default palette is
stored at address 0x5000:

```
    fetch("pal/0.pal"):poke(0x5000)
```


## Loading and saving

If you only need one palette for your cart, you
don't need to do anything special to save it. It is
saved alongside the rest of your assets each time
you hit Ctrl-S.

In order to create a new palette, use the '+' button
at the right of the tabs and choose the name of your
new palette, for example "1.pal". If you need to
start from scratch for this new palette, use
"Empty Palette" or "Picotron Palette" from the menu.

You can load a previously created palette by using
"Open File" in the menu.


## Importing and exporting

You can import and export palettes for use with
external tools. Currently the only supported format
is ".hex" files, which are simple text files with one
line per color, represented by their RGB code in hex
format (without "#" or "0x", just the hexadecimal
numbers).

To import a palette, choose "Open File" from the
menu, and select the ".hex" file. If this is the first
time you open this external palette in OkPal, a
dialog will appear to let you choose how to arrange
the colors in the palette. You can either:

- Keep default Picotron palette in the first 32 colors,
  and put the imported colors in the last 32 slots.
- Or simply import the palette as is. Note that this
  will affect the interface and probably make it
  difficult to use the menu, the sprite editor and
  the map editor.

To export a palette, choose "Save File As" in the
menu. In the save dialog, enter a file name ending
in ".hex".


## Changelog

2025-??-??: versrion 1.2.2 (release ??)

- Added: when clicking on an empty slot (pure black) in the
  palette, the slot is initialised to pure white: this way
  it's faster to add new colors (no need to bring up saturation
  and luminance before chosing hue).

2025-03-18: version 1.2.1 (release #okpal-10)

- Added: "Export File" menu entry to save a copy of the current file without opening it.
- Changed: ".hex" files are saved without metadata.
- Changed: dragging color dots is much more precise.
- Changed: constrain color changes along an axis when dragging a color dot
  using the right or middle mouse buttons (instead of holding "shift" or "control").
- Changed: bigger color dots, easier to grab.
- Changed: propagate palette to sprite and map editors only when focus is lost.
- Changed: Don't automatically register as default app for ".pal" and ".hex".
- Fixed: bug in opening files (due to bug in picotron's `wrangle.lua` since 0.1.1e)
- Fixed: reset display palette rows when hiding the color band.

2025-03-13: version 1.2.0 (release #okpal-9)

- Added: new alternate view with hue/lum and hue/sat pickers.
- Added: hold "shift" or "ctrl" when dragging a color dot to constrain the change along one axis.
- Added: ability to scroll the hue axis of the alternate view, either with the scroll wheel or the dedicated control at the bottom of the screen.
- Added: color names in the alternate view.
- Added: color band in the alternate view.
- Added: settings to hide the color names and color band.
- Added: angel.
- Changed: simplified the old view (remove color lines on the 1D sliders)

2025-03-08: version 1.1.0 (release #okpal-8)

- removed remapping option when importing ".hex" palettes (was not working very well anyway);
- added text entries for the hex code, the hue, the saturation and the luminance;
- added a new tab for drawing color ramps in the test zone;
- added dialog when creating a new palette (to choose between empty palette or default colors);
- added settings dialog;
- added settings to register OkPal as default app for ".pal" and ".hex" files;
- added settings for disabling the propagation of the palette to the sprite and map editors;
- added blink;
- changed dialog when importing ".hex" files;
- changed dialog for displaying help;
- fixed menu bar colors when default colors are redefined;
- fixed undo/redo of test cube color changes;

2025-02-26: version 1.0.4 (release #okpal-7)

- added registering as default app for ".pal" and ".hex" (needed for the file dialog?)
- added undo/redo and help buttons;
- added "clear" button to the "test cubes";
- added legends for the two pickers;
- changed: moved the luminance slider to the left of the sat/lum picker for consistency;
- fixed: palette is now propagated to all gfx and map editors (thanks to Eiyeron for the implementation);
- fixed: the "test cubes" saved in metadata where not properly loaded;


2024-08-23: version 1.0.3 (release #okpal-6)

- added: add file icon to saved palettes;
- changed: can load and import palettes by
  double-clicking in the file dialog (no need
  to drag-and-drop anymore);
- fixed: bug in BBS;

2024-05-03: version 1.0.2 (release #okpal-5)

- fixed: bug while using "+" button in Picotron
  0.1.0g;
- changed: disabled tabs in BBS, as it prevents
  the cart from running;

2024-04-27: version 1.0.1 (release #okpal-4)

- fixed: picotron's palette was not locked in the
  default file on first opening;
- fixed: saving a ".pal" file from an imported
  ".hex" file was not working;
- explain how to export to .hex in the manual;

2024-04-06: version 1.0.0 (release #okpal-3)

- propagate palette to sprite and map editors;
- undo/redo;
- reorder colors by drag-and-drop;
- import dialog;
- reorder imported colors to match default colors;
- added a manual;
- menu entries to initialize the palette and open
  the manual;
- flash padlock icon when trying to edit a locked
  color;
- shift-click paint-bucket icon to change the "white"
  color used in the interface, and ctrl-click the
  icon to change the "black" (useful when importing
  external palettes);

2024-04-02: version 0.0.3 (release #okpal-2)

- Added the ability to change the background color (by clicking on the small paint bucket icon), and switched the default background to black.
- Added the ability to import ".hex" files (using drag and drop from the "Open File" dialog); to actually create the ".pal" file, you need to save.
- Improved the color pickers.
- Added the ability to copy/paste colors (using a hex string starting with #).
- Added the ability to show/hide individual colors (right click on a color in the palette).

2024-04-01: v0.0.1 (release #okpal-1)

- Added the ability to lock colors, to avoid accidentally modifying them. By default the first 33 colors are locked (click on the padlock to unlock)
- Added the ability to hide specific rows of color from the two color pickers.
- Added sliders to change the individual components (hue, saturation and luminance).
- Added the ability to select a color by clicking on their dot in the color pickers.
- Added a test zone, with 24 paintable cubes (click on a cube face to change its color).


:: todo.txt
--[[pod_format="raw",created="2024-03-31 20:08:43",modified="2025-03-18 13:50:44",revision=1316]]
- Change: default_folder when sandboxed?
- Add: hold shift for fine-tuning colors.
- Add: on import, show number of colors.
- Add: setting for dragging sensibility.
- Add: "Ctrl-D" for duplicating current color.

Maybe:
- Add: new tab in test zone to show all hex codes
  and copy a ".hex" export to the clipboard?
- in-app gui for manual?
- multi-selection (ability to move a group of
  colors in the sliders)
- editing tools for multi-selection;
- Add another tab in the test zone for statistics?
- remove locking mechanism?
- import the palette from an image saved by
  the #paint cartridge;

:: .info.pod
b64$LS1bW3BvZCxhdXRob3I9ImRyYWttYW5pc28iLGJic19pZD0iX2Rldjk3MiIsY3JlYXRlZD0i
MjAyNC0wNC0yNyAxMjozMDo1NCIsaWNvbj11c2VyZGF0YSgidTgiLDE2LDE2LCIwMDAwMDAwMTAx
MDEwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDAw
MTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwNzAxMDAwMTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwZDBk
MDcwMTAxMDcwZDBkMDEwMTA2MDYwNzA3MDYwNjBkMGQwNzAxMDEwNzBkMGQwMTAxMDYwNjA3MDcw
NjA2MGQwZDA3MDEwMTA3MGQwZDA2MDYwZDBkMDEwMTA3MDcwZDBkMDcwMTAxMDcwZDBkMDYwNjBk
MGQwMTAxMDcwNzBkMGQwNzAxMDEwNzBkMGQwNzA3MDYwNjA3MDcwMTAxMGQwZDA3MDEwMTA3MGQw
ZDA3MDcwNjA2MDcwNzAxMDEwZDBkMDcwMTAxMDcwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwNzAx
MDEwNjA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwNzA2MDEwMTA2MDYwNzA3MDcwNzA3MDcwNzA3MDcw
NzA2MDYwMTAwMDEwNjA2MDYwNjA2MDYwNjA2MDYwNjA2MDYwMTAwMDAwMDAxMDYwNjA2MDYwNjA2
MDYwNjA2MDYwMTAwMDAwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAwMDAwMCIpLG1vZGlmaWVk
PSIyMDI1LTAzLTIyIDA4OjIzOjM0Iixub3Rlcz0iUGFsZXR0ZSBFZGl0b3Jcbih1c2UgbWVudSB0
byBvcGVuIHRoZSBtYW51YWwpIixydW50aW1lPTE2LHNhbmRib3g9ZmFsc2Usc3RvcmVkPSIyMDI0
LTA0LTE0IDEwOjMwOjA0Iix0aXRsZT0iT2tQQUwiLHZlcnNpb249IjEuMi4yIix3b3Jrc3BhY2Vz
PXt7bG9jYXRpb249InNyYy9nbG9iYWxzLmx1YSMxIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0
aW9uPSJtYWluLmx1YSMxIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJzcmMvZ3VpLmx1
YSMxIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJzcmMvZ3VpX3BhbGV0dGUubHVhIzEi
LHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InNyYy9ndWlfYWx0X3NsaWRlcnMubHVhIzEi
LHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InNyYy9ndWlfb2xkX3NsaWRlcnMubHVhIzEi
LHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImdmeC8wLmdmeCIsd29ya3NwYWNlX2luZGV4
PTJ9LHtsb2NhdGlvbj0ibWFwLzAubWFwIix3b3Jrc3BhY2VfaW5kZXg9M30se2xvY2F0aW9uPSJz
ZngvMC5zZngiLHdvcmtzcGFjZV9pbmRleD00fX1dXQ==
:: [eoc]
