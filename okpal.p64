picotron cartridge // www.picotron.net
version 2

:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA3Iixtb2RpZmllZD0iMjAyNS0w
My0xMSAxMjo0Nzo0NiIscmV2aXNpb249Njc0M11dbHo0AG5BAAC3ngAA9iN7WzBdPXtibXA9cHh1
AEMgCAgEcLcgRyAXIEcgt3AsZmxhZ3M9MCxwYW5feD0tMS44MwEAETcXABB5FwAnNDICAKcsem9v
bT0xMX0sWQDxCAwMBDAncAcgB2AHoAegB5BnQGdAJwAnBAA7Z-ALagBGNi4xNgEAFDNpADcwLjMB
ACIyN2oAHDdpACPwDGoAPyAHUGgAS-8SN2BXQHcgFwAXAAcAFxAHEDcQByAHEBcQB0AHMAdgN-AM
cAA3nw0JBACnEAeNBwQABi_nAG4AN-EGCQkEMAdgBwAHQAcgByAHQAcAB2AXAgA-BwBnaAA7UQA3
MAcwZAAxEAdQaAARUHgAfxAHMAcwNzBsADqjEEcgB00HAAdtFwIAjwcAB00HIEcQZgA3-woYGATw
KNqA2g8ZcNoeYNouUNo_QNpOMNleAwAE_wJOQNk_UNkuYNkecNkOgNnwKIsAEzB9ABIwbQANVgP-
CPAbB7AHsAdQZzAHAEdABxAnUAcgB-AMRgALHzhGAAUBuQISAI4BD0oAIPMCCwsEIEdAB04HIAdu
BwAHjhcCAM8HAAduByAHTgdARyBQABxz0E5AbiCOEAIAXyBuQE7QQgAZVEBABPD-AQDRvwfwLifw
LEfwLQfwLwMAGjAJABUwAwDyBhdQB-ApJyAX8CtX8C0X8C4H8FsHAAIAUyfwJQcAAgAx8CcnCQBV
F-AmBwAUAFAHAAcQFygADKoARC4xMjWuAAEMAAGyAB8zsgABELN9ARIrUQBCK0fwaw8A8QIgB-As
J-BtN-ArB-AvR-BrRyMAVfAtR-BsFAABKgASRy0AACEAMRfwLioAcS8H8Cs38HDpAE0rR-DtDQGS
LwdAB1AXACcA1AASJwIAgBAXABfQB0AXpAN1AAcQBxAHAAIAAe8EAxAAMMCHIC4AAhAAOBcQJxwA
IfAD1QMPPwAJYvADB0AXEBUAJRcAIQAxECcAFgAfoEsBnwA1BQMxAhEZQAEDDwBUB-AbhyA3Ahgg
GAA0IQdAOwIfF-AAIfAOEBAEELcgB7AHAAfQF9AXUEcgF0AnEBcQFzAnMAcGAJFgFxBnQBcgR1AM
AP8AQAdwF9AX0AcAB7AHILcQcgATHzFyAADxBNcA9xdAlyAXEHcgNwB3IKdgl0AVAD8ZANdYACgl
BwACAJEwB7AH8AAX8AYOADEgF0CkBBFwLgYRQPAAAAIAMUAXIAgAE7AYAEDwCBfwDgAGYgEvAAfm
ACgFWAEAQAFAEBcQJ7ACsTAnMBdgJzAXQGcQcAEADAA-cAdAWAE2thRAlxAXIIcANyDHWAEfFlgB
PREDDgAxUBcQ5AMAugAAxgARsBYAAJECAr0DE7AYAC-wBVgBNFIFMwTwHe8DQFdAByC-AcAnYEcw
R0BXAAcQR1AKAP8EByBnIAdAZyBHQEcwR5AHMFfwE2oAEx00agAQClAAEDc5AiMAN1gAQQcwV4Bs
ABBA9wQhBxBmABZQFgAzBwAX4QA-FwAHegAjCTwCQVAXUBcvCvMBFyAXIHcgFzBXMBcQNxA3EAYA
ABAAABgABCQAADAAD0gCMzAHEKd8BXEQd3CHUHcwaQBhMHdQh3B3FgBPpxD3B1QCKS-w8FcDLgH7
ADAnECf9APMCMBcgF4AXIBdwFzAXYBdAF1ACAB-QEQE4MAVQh4QBYRA3ENcQxwIAT9cQ9w4IAWIA
nQIf7-AFITILBQSeAjUHADeJAwNaBiYAB0UHAlQGD5sAIaAZCwQQ9wUgB-AFoAYQB5kCEAfnBwCd
AhEQGwwUIGYAAhAALxcQHAACFiBXCAEQACDwB1AAXwUHIPcFbAEVHzCZAAGQ9wcA9w0QBwAnbQBH
EGcAJ2cAEle_CA0YACdnEJsAXwD3DAD3hwAn9AVUDARQ9wdA9wjwD-cJIAfwCAfwDgkAsg33CwAH
8AoH8AxHdAUBHwFjNwAHMCcAQwFVIAfwC0eZAABzCSJnQAoAFAcWAENQB-AKIwAAygcwIEdAYwED
ZAlAMAfwCecAEwcCADhHAFeVBREAhggz8AhnnQEgBxAmDAcCABAg5wqCB-cR8AwH8AYHADsF90QK
AWYtNy4zNzUEDS40NysCCgsBlAfwBwcg9wrwDgkAQA0H8AlrAULwDAcwmgIDmwEyAEcgmQB2JxA3
8AsHMJgBAL0PElcKABQAFgA0Z-AKIwABgQchMFdEAAEbAUEgR-AJrg4VAPsAFTBAAAQdASDwCOUG
AowCEBdmBgcCAMInEGfwBwfwDPcR8AYHAA8LASbxBiIPBPAU9w4g9wDgBwD3AfAA9wLwAI0JZiCn
EDdABwgAJPAADwAEHwAi9wIvACAHAD4AXyD3DvAUmgITHzWDAAJiB_D3AAAHUwDW9wIgJxBHICeg
NxBHAAgAJPcCDwAEHwADLwAgAQA_AA_DACZfVAwE8AodAwaQdyAnYFcAB1DHqgEg8AyjAxAXowEA
8gIRoL8BUfALZwBHuAEQZzUSAgsDDhMAIwl3EwASdzkAU2AH8AiHTgAGEwC0B6cgJ2CHQMcAB3Dr
AgP4ASv3Pt0A8wAxNy40NDY0Mjg1NzE0MjnnAMAtNC42NDg4MDk1MjMGAALyAB428gAPBAMHMGAn
IN8DkWfABwBX8AwHUP4MASgMMGcAp7EEIfALgg8A-QBDUHcAp-ICDRMAOgkHYBMAU3fwCAdwTgAF
EwAwBweQcABTh8AHAIfSAg-yAD8PBhMiD1sFEwBbAE8jVzCXUQA6kS0HcAcQJzAnIDIHD08AMwF7
AR9QTQArDjwIDzoAw2cJCQSXYBcCAB_XRwAUHzZHAAAAnwsUMHcCMBcAJ3cIHzBTACVfCgoE8FQ6
ABUPSAEnDzoA------------------------------------------------------------6pEo
4AEAAA4BAABqPg4BAPAilCfw-8U3IIfw-753AAGXAfD-u5cBJyFHEfD-t1cxJwEHAZcBB-D-s7cB
BwEHATchRw4AgLHXAQcBdxE3DACAr9cBBxGXEScMAEGtNxF3KAAhtwEQAGKrNwE3kdcMAPAHqTcB
JxHXIXcBJwHw-6g3AScB9wMhhxoA8AqnJwEXEYcBxxF3AfD-picBFwG3EXcBNwFnDwChFwEXAecB
ZwFHEXoAEKSSAPAVVxGHAWcBVwFHAfD-pBcBBwFHEbcBZzEnATcB8P_jJxFHAYcRVAAwpwE3EABQ
AVcBdwFIAFEHAdcBJxIAYOcBVwH3AA0A8AahJwE3EUcBJwFnAfcE8P_hFwE3AReyAFABFwFnAdAA
cVfw-6AHAUdCAEAnAYcBoQA5dwFHFgAwJ2FXdABR8P_gAXchADEnEQcJAVBXAVcBZxcAEVeSACIH
IRcAYQcBJyFXAdIAIaBXRgACFgAhRwEiABARLAFwJ-D-bqfwFmsBEucdAPILIRcBF-D-avcD8BIn
EVchBwH3AxGnAQfwFgcgAPEA8P839wfwEBcBdxEHAfcGugEREhsAQLfw-zTsMwCsAME3AfcKATcx
J-APAQf0AGEv9w3wDRe3AGD3DFFX8A4YAIAH8P8s9w-wDBsBIfcNRQAAFDQAGwDwAgrw-yn3EfAK
VwEXATch9wMh7QAxR-ALHQCRDPD-J-cT8AkXGgEwBxEHQABAAQEnIQsAMTfwCiUAkQ7w-yX3FPAJ
Jw8BYBcBVxHXAfMAUQcRF-AJIgCAEPD-I-cW8AiKASEhJyIBMacRVyMAAJ81ACMAUBHw-yL3qTkg
ATeaAiEBR54BUBcBRwE3fQEh8AcmAFAT8P8gAScAAY8AAB0AAVoCAXYAAecBQQcB8AYqAKEV8P8e
AfcZ8AY3gQECRwATJ1sAAGMAMAfwBigAghfw-x33GvAGPQAFHQASAbgBAaQABFMAsxbw-xwHAfca
8AU3fAATRxgCAA4AAWIAIPAFDQDD9xjw-xoHAfcb8AUnfgATRygAFQe2AFEHAfAFAU8AdP8ZAfcd
8AWdACFXIScAIhFHjAADUwDAGvD-FwH3BEH3BfAFigEARgEiVwEHAQCZAhI3LAARAXcAYP8XBwH3
AUgAUxH3BPAGhAACzQAiByFZAABYAID3BDH3BfD-FS4AIgEHAgBUEfcD8AYMAQGCAANfAQBiAAKz
ACMAMSgAKP8UOgAAFAATAm4AADsBEDcCAgHZA1A3ARfwAjkAFxFlACn-EzwAABUAFAF6AAE-AACK
AwEIAEA3ASfwKgAU1z8AAmoAJf8STQMGAgABRAAWIYEAB0IACUEAA0MAFRGPAwEGAACkACDwBgoD
A-8AESdMBAJBAFYAAQcBxy0AAK8AJP8QQAASZxMAEABKAgM9ACMRF8gAAT0ABDwAFWc8ABUPUAAV
h3sAFyd6AAc9AAD1AwAdBAJjACL-D8sAAREAKgHncwATR7cBIifgXgACNgAQ528AEudxACoR52gA
FEdoAFTgAdcRxy8AEg0tACwB52MAEydhAAZjABPHiAAl-w0zAApkAAbPAgFmAADNABHnNAAQ12gA
RtcR9wFlAAJYAwRlABF3YwAk9wEuAFAM1wH3BAQBFQUsAAVeAJFHAWfgAdcB9wItAJLH8P8MAbcB
9wRaAScF11gAEsdWAMEDAQcR1-D-C8cB9wVUACf3A08AEcdNAIAEAQcRx-D-CkkBEvf_AgIoAAFL
ADD3A_AfByL3BnEAEAolAAIMAQRMAACnADD3A_BvAAOWABMIMQAQESUAVQkRJxE3RwAQCGsAEAil
ByP3CEYAEQlEACH3CEIAEAr7BRAIHwAVCj4AIvcIPAAxCwGnPABEhwH3CacAAEUAAAIAAz8AEAs-
AAEiABIL7wAXCEAAEAxAABEGoQIt9wtBABEHhAIUpycAASYAFw1FABEH1gEAXAYQl0YAEHcpAAVE
ABEnQgAi4AdCADEOAYdCAE9XAfcOQgAAEA8fABEEHwA-EQHnQAAAAiEAAScEIPcSYwASBEEAMgbg
B0IAMRABd0IAE0cgADIF9wdDADEG4AH4ARARxQcQBCAAERRiABYHPwBhpwH3EwFXPwAQNx8AAT8A
IQURPwASBYgDBCIAQAE3AecTAgIjAAKQADMF4AFGABAUJAAQA3kAAiUAEAESAhUh-QQTAKwAEAL8
AkBH8P8CKgAm9wArAAWqBAEcAgKvAgAsAEE38P8CkQUg5xEsADMC8AXwAgMuACEC4BkJIfcDBwAR
BzAAAS8AAfwJEJcyACAG98gAAwIAQBH3AuAqABG3HwYQt_0IAmIAABUAAIMHEqdlAAW7BQAzACAB
0OUDEbcnAxOnMwACMgAxRwFn1wAh8AVyAAeZAFABwHGXAXgKUBcRZwGXYwVw8P8BAUcBlx4GMHG3
ARUBNDcB114FADMA0QCAtwF3AccBFxGXAXcJBRH-HwAADAAATACD9wPAZwHXEWcwAAFpAYFXAdcB
hwFHEQcKAGIAEWfnCqKXAccBt3Eg5wHXbQUgIdeEA5BHAdcBlwFXMXcrAPECAIcxZwGnAccBlxH3
CQHnEYdnATLXAffFARCnhgQAJwAAXAEwpwHX5AIzCwHnhQUQ17IDERdIAQEnABD_JgAwxwHXxwIw
DAHnvAUiEdeaAxDXzAFhAQEX8P7HrgAAmQQQ9wYFBUoAEAkKAhDXBQAwF-D9JwIQRwwAETeuCiH3
DFkBA1AAMAoB1-cAUgEBB-D9KAAwAhEXKgoAUgAy5xHHUAAxCgFnqQEAAAtQZwEX8PxAAACuAiAR
t48DB1AAUQsBZ0G39AcBZgtC8PwBt8IEIgIBKwAiEcdpAVEKAXcB5ykANEcBh1MAAH0GAioAIQ0B
ZAIFgAAQdxAAERdOBxOXVwADLQABEQRF9wARx4EAAisAALgLAA4LAVkAFXcqACXnEVYAEwvWAAIx
DFEX8PsBtxoCOMcBp4EAJBHnAQERt64AASsAAlUANCcB1ywAAZAGFucrAREXBgAxJ-D7HwwgdxEC
AhKHqwAGVwARCzsHEaceCTCHATdXAGEXAUcRhxHLAxF3WgARAVoAIPcAPgAVADAAEGdnAGHw_wE3
QadmAhD3qAIQ5xkCUgAR9wERPgARAdwKAC8AMHdhV10AIfcD7wkwhwF3VwIQALwAATkHAd8DATEA
UBcRdwGXJgIwBfD7LwAAKAMQh94EEAH7AxABCAABjQBhVwH3AiGXfAMwVwHHXAACBQgAKQMQp4sM
EAGwABMCzAcDMQAhAbcxAFE3Edfw__kDAjAAEOcbABN3ywQSB7cAYfcCAccBh6EKIOcBXwAaNy8A
EWcvACQDES0AEbd4BlNnIfcAAVwAALgJEpeBBxJXigACXgAQAt4AADEAkRdh9woBB-D7Vy0AMWcB
d5gBEffXBREDXAAQAlkBEAOPAhAC9AAQB3ABATwOApkAAPYHAE0AASEIIgMRZAARAxoDESeoADAX
8PuxADanUScsABERWQUKLAAADQQAfwIClQQQd3EAMQUBFy0AEQWJAAQpADK3AcdVACH3BgsJAAgI
EhFVCAFWABIEWQARly0AE8eAAgD3Axi3LwABAwAHKwAA8gIBfgIRRyoAESdjAiL3BpUIAlkAEgU9
ARGHMQlT1xFHEUcMAQBZABJX2ggh9wdZABIGfwMRdygJUOdBZ-D8BQYJKAASAbMACSoAYPcAAZfw
-FsBEcfsAReXUwACogIC4w8CKAARp2IBAIEAEYf2ABMIUwAxCAHXTQMALAAQ5ykAEZdVAQADAQGP
AiH3CSwAdAgBxwEnUXclAEJHQUcBKQAzVwEHJwBCJ-EDFykAEXfvARDXKQAR5wIBIadRcANB9wox
N_cDgxcBFyH3CQG3KgBhxwGn8Px30gMASgJTAfccAXeQBAFsDxynKAAABAAAxQAfGygAAQAOBwEo
ABFHUAABggcCKQASJ1kFMQsBlykAPXcBpykAExqgEAMpAAAFAQIpADIHAYcrABF3JgNBpwH3GcgL
BS0AMwwBdy8AAEQPAS0AAEUBAy0AERiLAwApAgUrABGXrAAUJysAACgGDisAMQ0BZysAWJcBNxE3
KwAA9gEh9xZEBAUrABFXKwCBpzFXAYfw-WcVAh93KQAIAX8BACkANacBhycAJBFHJwA4EwGXJQAR
l7EAEddnCQF6CRInXgITEicAMIcBdycANFcxpycAEWdICxQnoAELKQAmhwEpABMR8wYPIwAAMTcR
J34GIfcSbwQRp3UBQfcQAacCAAcpABInaQZgAfcSEWcReQMSNykAAkIFGFcrADEHEVe2AyH3EckI
EpdPAx8PKwAAIhF3KQAQEC0FKBGnKQARR-8CAykAJGcBswMh9w9YBREHFQAQN78GAB0IAi8AAIIB
AzEAAGIBAzEAACIAMWcRlwYHJ-cNLwAyZwEXLwARNw8AGUcxAANiAAczAAFeACIBBzMAEScPAADL
AAGjCBEMHAARl48BEFfZAhEnMwBDZyGXES8AOWchZy0AIRF3kwEILQAA2gMi8P08AxFHXAUQV3YD
EQeSBBGHgQEQVwkEGDcvABGHbQMGLwAUEVwAAHIGKvcILQAAbgERZ_0AEaceABQRXAABogQAKgUT
R_sAEtcvADPHAWeoBRBnqgUB9QYqEXcvAAAnAQMvAAAcCgUvABMFXRMidwEvARJnEAYAsQMyh3Hn
MQAR540AIPcBbQcCCggAtwANMAAQd6MFMXfw-kkJIQdBLwcQZ2oHEieTAAUyABEXGgADEwEzNxGn
NQAAlQsB5hMCNQAE9xQDNQACGgABJgERVzkBAIYABDkAElfFDBFnOAg1NxFnOAAABgEBGQAAmwoA
hwoRB2UAEjc6AABrCWBncccBVyH-CwpyABF3fQsAOQAxFzFH1QEA7QMBNwAAmQEh9wDLAUAHEbch
4RMZR3IAEQf-BQDIBBFHHwQdFzgAURcRpxFHJAMXR3AAEQdsAwQ4ACFXAU8BAFEAFbdwAEABBxGH
TwEQEawABjwAETcKAxEHsAAYtz4AAOwAA8oQEbeKACAHofoWCHgAEUcMFxEHHg0RN5IAAhYAEBc_
ABFXWAcRtz0AAKEABgIAI2cBgwABbBMCgwAiB2EaAAAbAwlJABEXkQYRRyEDAL8DAS0AAwIAAAoD
FDeOAAAOGAUCABMn5gYA0AECdAZjB-D_BwF3SwACtg0RZysAILcRZxcRV4wAEWfmARMHAgBRNwFH
IVd_AgCCAQdFABGnGgQTR3ANIfcIxAAiVxGHABF3FQAA_AIxF1F3QwYUJzwAATcGAOQAIGchLgAg
9wjKAwHOAQLQAwBvARRHsAIBBwdSAVcB8P7KBAHJA4GXUUcB9wghZ1IBANMGYEcBdxG3ER0KEVdc
ACWXITQAAmMKEIeqAzb3CQFqABLHLgIiEWcxAADKAgAsAlM3ATchdwAIQ-cKEadhACDXEQEDDS4A
RkcxFwEuACcBt1wAEIdqAhsBMAAVpzMIAPcRA1wAMbcBB14ABi4AADADCTAAEJdQBSCnES8BADYA
Al4AFJftAAFiBQwwABENswMC8wUAaAMRdzgAEZc8AxFXNgAAGgELNgAR50YPAGcAAIMAA2kAAC4C
MiF3Af0PEHeDESkAZzQALPcIagAhEbc1BRFnhgcAMQAAKwcIMQABgwMKZgARx8YFAFoAG5czABCH
CwICNAAjASdlADGXEcf9BhGHywUAqBYCMgAAMAAFMgABlwAEVQIVhxoRE4cdBxUHNAAAewEPZgAD
EdcYBwIyADFX8P_oCQIyAABoAAC0ChoHZgAREWkODzMACAEODRUGZwAxdxGXIAAKNAARB9QBF0dp
AACJBgdpAD8RdxE2AAMApQMIbAAAygsRBzIEAL0DEQdCBADeBAH3CAGDBBAnPAARAh8AESdNAADq
AwSADALZARE3PgEqZxE7AAAaAAA7AABPAgc6ABQEOgAFdQAjEWeLBBOXOgABKwIBOgAAngUIdAAA
rwACcgAipwE2ABEnfgAC-QMRBxIADjoADHQAI-cDOwAC9gQiJwGPBErH8P8DOQAAZgQGcwAANwAj
EUc3AACbAwg3AAACAROHQAcQN1AGAAEKEdd9BBI3PQ8EcQAhFxFlAACjFhAEwwECpQEDOAARAXQB
NecRJzgAIRFHdgAxZyF3ggEPNgACAm4AIucBbgARlxUAFVdLCBGHJwUR5zkAE5enABFXXQMAIgQG
cAA25wFXbwAPNgADMVBXAQ4AExG7EhFX7wgRJ1wFABUAAAgBALoDBDkAAGcBBjsAAPgAAhADAYII
AdcTAaQFAbEGAj4AAIkABD4AAM8ACHkAAFcGAT4AEQKOASERRz4AAQYAAbQUEZfiBQQ_AABAAAIm
AQV8ACURR5sQATgAIxFXegAB1QAiAWc8ACkFNzwAADMDAnoAJjcRegATFzcDIQcBEwEvEXc8AAQR
R3gAEjfpEBJH4QEBKQgDuAAAPgAA4gACPgARRxwAHRd6ABEnPAQSZ2oPCkEAFWdBAEnX8P8GQQAh
QHc1ASJXAdIIEWcrBxHXLQEAhQIgNxHlBwI8AGHHAfD-BzcrAAQ9AABmCAcxCBAhNwkRx7IAEQcp
Bx_XPQAIETBACAJ7ABJHQAAQERcVEcccAhEXygIAMQACQgAAqwRB8P8Ht3UREnc_AAG5ADARV1Fg
AiC3EVQMEReRAxVHNgASN-UgCDcAALcFAUYLEWeIBBMnVgwEMgAAKQEKMgARBxMBEFfYARN39gYA
wgAklxEzABFXWhUIMwAAvQAS10oTAKABEUczAACnBRN3MwAhZwGjFgJIDgQ0AAH7DhEB4AQRFzQB
U1cRlxGHoAAwd0E3ABoAMwECMAAAkgQDMAARl1EBE6fwAADuEwAPGkERRxFX4gsgVzDUBQMsABEn
cwsSdwgLBS0AIidBWgUgRzDXAxK3KwASN1MCAXEOMacQNyEAAC4AEQk6AFCHATdAxysAEQCiAxMn
LQAA0yFBFwGnMCMBCi8AEFDYEhHnQgMD8AEACAEAuQg-EadAMAABEdcIAAKyBQAMAgU0AADDCEcR
l3AHNAARAY0EUTdQ5xF3UgIRBzwCERcFAwCaAhVndAADAgBdEQdBN5BBAEEncPcA3QgRB6kCAkoA
IQfxgyAMAgA8FxHAPwBTF5BX8QI1AATXAhQh3wJRJwFXMQcKACIHQQgAOifQh0EAEOBFAQsCAAVf
A1EXATdBB6EEEgfECVhxNwGHsIMAAAgQAY4ZCwIAFyFXAAN7AAFxDDABlxG9DRCgZwEn9wJEACUB
h3QAIhfBCgACUQERBykDAucEBzcAEQKsEAFOCBMHCwIMAgARR3EAEUcCAAC5ASRnkD8AEgr8ADXw
AMfoBQc1AEEBZxFX1RkANQAxV5CHDAILNwATV2IBBB8CAJgHBGgAUQcBR5CHgwM1NxHHNgAQ4P4D
IlcBqwEBnw4ALgACZwAATQUSVzQAEEEkHgIVARDgFgICGgIBiA8AohIgVxEKDkFXgIcByx0QAi0A
AQsBIeBXKwASd10AAPYDAswAAl0AMWeAhyQFBzEAIdBXtQAfh1wAACIRdykAADYEDSoAClkAIHdw
xwMALgAhDJcqByKHwC4AEZfEBBSHggcBWwAWZy0AALcFDi0AAMYBAloBC1wAEbfGBD2HsGdcAAD3
AAtcABHHwQkMLQACXAAkVxFaABCHBRxA-wzXEQcFIHewigcxZxGHQAUdd1oAAy0AAecGQIcBd6Ak
AAJQDBFndgYTZ1kAJodgLAATAioAETdiDgAXBQNaACMBZ_MIHXcuAAD9AAL1AheHXABGZwGHEVoA
EQ1QAiJ3kOgFDFoAEWdJAzN3cFcOARoOLgAPWgAAAOIABi4AAHMGMXeQV80CAD8DJncBCg8CXAAz
h2BXigARDrYAFGcuAANcABF3EgcRd8oaAOQADy4ABANcAAYuAC2HEVoAEICEARNHNAMWZy4AEBGK
ACinUC4AQpcBR5AuACRnAVoAEXfUBxEHyAEzl2A35AAaDy4AAAABBi4AAloAASwAEEfBIDAQ9wGL
FRCAqAIPWwAFIKdgMQc4JxHHLwAiVxFcAABWAgOUAQGJDwAtADCHARf1IhEQiQACXAATVz8BAIsA
AS0AAXkMhKdwFwGHIfcBLAAgJ4BpAgBdAApZAAA0ADOngAcPAQIsADEXkFdIDALhABFXJAARlzMG
NaeQlygAIqew7wQC2gATV3oAAoIAQocBt4AqAACKCDGXoGcgAABWAAJSABCHegABXgADKgAAJiUB
KgAx5xFX-QEC1gABXgoCYQAMKQAZ11EAL-cCUAAEAuEJKYcBUgAAbAcMUgAzp5DXlQECXwUAagUD
sx8CVgACIgEBKwAngNdWACRHEVYAIhEHQgAyAcdwLQAQE4MAIYDH1QoEWABD9wIRB2EAADABCisA
E9duAAVYACICEesKAmoCIsdgVQEQEw4UDVkAFQMsAQcqAADSBFaXgLcBB-wABVkAEWd1AzHHYIeR
KYIT1yEHAadwx0sAAlQAAzQAEocuAQQpAFD3ARGnYH0AAigAAU8AAh0eBSUAHYAjYEU0Ljk0P24F
JXEYNRYALjY3N2AOSywPAQAPIFwRpCvwCcYXEVchgEfw-7FHIYcRYKfw-6lXIbcRQOAOcKRXIfcA
IRCzDvAAnwH3CpHX8P_bMfcEARfBbBDgN-D-mBFHMbcxJwFHUWfMCoCVIScxxyHnMXUYoDcQV-D-
iiEnQReCIfEBAWF3ESchZ-D-hjEnISchJ5wqsDGnIRcxV-D-g0GH1A0gIZeLAxADJgBggDGXEVdR
iRPA9wYhV-D-fiGnEVdBAwQwVyE37R7wAFfw-3wRNyFHEWdBlwE3IQwmIPcDTAAReRYA8wM3ARcR
tyFXMVcR9wUhVxHw-3YXAHAnAYdB10H3KRFw8P9zETchl9APgBH3CgH3BCFnJgxgcRE3IYchAQ1B
9wtRl9UVUAfw-28RZQCzJyFnIfcLMXcxZxEYAFBtIScxJ_kFERGiIQAYAGKH8P9rETcWAFEBtzE3
YVAUALgLcfD-aQFHMTdfEGBB9wpBRxGeGlE38P9nAdcAUAUB9xMhaBcQxxUAEGVFAXAB9yAhhxE3
VBAAFAAQZB0IkCHnEZcx9wQhtxYjIBHXjCzxAGJHEQcR1zFnIZcxhxH3DJApQGABNxGuDsCXIXcR
9wAxNyH3DhEZDkI38P9fCAwgEYddEEIRpyEXrxoQR9MBEV0MECB3IXwEcdcR9xQRVxEYABBb1BAB
ciIwhzG3ohwhZxFMAJBaETcRNxFnIWcEARMAiCIgEWcWADHw-1kJETD3A4HpH0AR9wFxnQoBgwAR
WNMjYDcRdzH3AnguEEEwGED3ARE3zwARWIQAAN8FgvcEIacBJ0G3niGRN-D-VgE3IRcxqhowxwE3
NSASlxkAEFWDLRAhjAAw9wQRnA5AR3H3CfAJAlMAEVU4ACAXIeYlABYBEFcMFgA-ABE30xFAJ-D-
VEAAAAQRAXkhALsXYYcBR1H3ALsuAbMCASYAMjcxF9UAYAIBFxFHEeUBUkdB9wYBJgAQF3UBYfD-
UzdBF1gAIGdR2woAOxVBZwFHMf0mYScBJyF3ASUAASUCAEsJANQkAugOANYGMucxhzYbIBEHJgAR
Ed0OEQBGFgBBCQDGEBBhIgAgVyHGAmJTJxH3EQEdAKJXAUcxp-EAdwFHGwAAayVAFxH3EvwCsBHH
ERdRBzEHEWcRuRUAHgBxAZcRFzH3EJ4EwLcRJ2EnEQchVxFHId0vcVN3EScRFzGUAwCPEkCHQTdx
2A5hVxF38P9U7QjwAhGHEWdB9wARJxF3IXeB5wFHuwMQVWcDAJ0GIGdB7hFQIXcRl3ErIwCzAxBV
sQIAzgAgZ1E3AOEhdxFnsfcGEWfw-1MBN7wBUGcRZ1HnJDAA3gZQgfcHEVccACFHEUUwkFEnQVch
RxGHIUwFQAdx9wgeABJSCQgA5BRAQVcxx2YFEQE0GTCHEdcUFBBRfAsgMSepAVFBZ4FnEb4LALMF
IAdRLhYBIgAA3y4ABgOSZ1F3QQdxNxHXIQBAAQdBp3wjIf9QYwp0pyEHEWdRhxwAAIMNMyGnIQwA
IFGnnC1A3IfwWtYCQIdRd3FHBwcCACRhhysAQAEHQbctAHBch-Blt-BY_QBAZ1F3YbcoAQUOMlF3
IXMN8AUHUWcRN2HX8Fq38GPX8Fc3QacxhwsacUHnAQdRN0HHBvAAQXcR9wjwWdfwYfcA8FY3bAtD
MZdhB-kUEMGVBvABBzGHIfcG8Fj3APBf9wLwVF8MMRH3BjUOAagWQQcBB4F6ANAh9xPwVvcC8F73
A-BTJwAyIfcEJwAAQyoGAgAgxzEcHoDwVfcD8Es30MkGEFLnDQIuABAXCwUSJygAAZ8u8AL3AREn
MTfwU-cEAdA38DdnsP0AEFHiAAIxAEM3AfckKQD3AEEXIRfwUvcEEbBn8DWHoCkAIQJRtgAAKQAA
ZyABJQBhoIfwM6eQJQASB18EEAf2FRIlEQ0AugEAJgBkkKfwMceAJgAAyBwwERdx1Akw9yUx0x3g
hyFn8FL3AyGAx-Av53AMBTAA8FCeF0InEUcxXQ_AtwH3JjEXIXcCL0BhR-BSnjLCEXDn8C73AGAR
JxHnMAA2FxE34wEA-gDwEBH3JyEnMWcBV0FH8FLnERchYPcA8C73AVAhJwHn8FD6AIAHEfcSEfcn
8fYaIPBSZh2BUPcB8C73AkCgHnCHMRfwUGcRuiogKcGpACBRFxwEkCFA9wLwLvcDIKAA8AYRRzEX
EQfwUGcB9xUB9yURhxEXIXcrAPMCBxEXMUcRNyEg9wPwLRH3AiCeAAAbDCHwT_AAsREXAfcJIfck
EecR7Qkh8FGZD8AnMSD3AhHwLBH3AxDYMgHmBDHwTxf1AyAXEQ8ZQRH3IhEjHlAXEWfwUQUYEBEO
MrIQ9wMR8Cwh9wMAIWsQAHoMMfBPB5IMUCchZxHXzQEQIHUbICcBOQAA_AwB7AJREQD3AyE7AAFX
KxEnviIQT9cJEDcqBIQBtyFHEfceETkAIYcBcQAUMTUAETFvABAhSyNBAWfwN0EGUCcxdxGXRAgQ
HYcbANEYUTpn8AGHbAIpByFvABFH2B1AAYfwNggPMEGHAW4IBjgAUzmH8AF31B-CBzH3AjHwLDEX
EdcxdzVQd_C38DQGBSFRhyAaUacB9xwROgBxR-A5t_B3IWAAxSHXESch8BlnsCEHATwAwhF3wBHX
8DIBJxGHUY4cEBy3GAGPLlDwN9cRwK8LAXYAAD8AoDGwZ-AFh6AxNwGFCgClCvAAd7Ah5-AwERcR
h1GXAfcx-AYC8QZAN_chsPYLUQcBRzHXQABwoIfwA6eQISoDIscx9AAwd6Ahly4RL70GcUdRhyH3
LTHNJnaH8Db3AhGgfQCwxxE3MZCn8AHHcEERABTHfwAAUABA9wDwL2AFIDdhMAAg9yykAQJDADQB
MZCEALDHESdRcMfwANdgURcCQ1dRFyGEABCQNQBDAvAuF0MAUhcR9yoRmQeCATfwNfcDIZCIAPAA
RxEXUVcBR0Fg1-AA9wBAiQAAcgMRgYkAEYAjAKH3AvAsFxEXIUdhPAkQKhsvk3cRJ-A09wUhgIsA
IHEHagZAUUD3AKZqETA7BDQnEVcTARJwSQBwA-AsB1FXcf8eIPdGABVg8DX3BiFwigAAVwpSJyFH
QTCdaxEgIgVgJxEXAXcx3gwwZ2AxrACyx-ArByGHgbcB90c-AHLHIWchYGcRLTZxdwEXIUdRICpr
IQMQ3AQgBwEpAgDNADBnYCEHAJDX8CoHMXeR91VDEDHwNdegAFEHEWBnAScAICF3AxWyQRD3A-AB
AfcCAEFaAABnBkFnAWdQBwDRx-AqAQdBV6H3ASH3QVIDgTXHEWcxUGcRSwgAqQCxUQD3AgHwAgH3
AmEWCRMRhABwUDFnETdBN0EAYFEnwfcCQZ0CECipAkDwNDdBpBIzZyFQiwAxEYchnAAUUUsAEFEX
ADJHEZeMACFAMR4A8AABFyEnIQfwKwEH8QX3BUGNJxAodw0g8DRKBwCVCTJnIUCaACGXAUEAEWFQ
ABERUAACFQAydxFH2gAAdy4DTAAA1hYgZ1GnHaAJofcEATcRl-AzMAABIwAzEVBH0gASl6QAEEHa
BEIDAfcCMAEBUBQRF3YTJUAhNgAGWQAgd1HHL5QHQWch9wIRNwFbAAJEDkERQAE3qgAwZwGXuAAB
AAFABAH3A5wHMCGHIaUJJEAhaAAABB_w8CwRB-EDlwHXYddaAkEAIbcR9Qowh-A08ghBEYcxQNkj
AD4BI4cROgCTMfcDAfAEEfcCpAIiByE_GTEwQQd9EHCH8C4RB-ECKxgwh3HHBy8QIUYuESFXABOH
oQAwBzEwygMDvQ8BFAAAgwFx8AURBxHnMSIAIBGHxwA0ESBBZwBgd-AvIQfxQxFAAadxl4UJAK8G
AJwAUHfwNXcxWwgTIDc5I0cBaQBxQecRFwHwBg0AIudBWABCdwGnIVYAADECMYfwMa4AQCcRp4GQ
EUCnEfcTTAtiIWfwNIcRsggxICEXqgAhdyE0ACAx55o6cQYRFxHnQYfPDyWnEVEAUBGH8DEXpgAw
J-EHhgxAdyH3E3ELIhFX-gASp6cAEgGnABFnrwAgZzH8HAGnAACSDwGuIhEHcRQCVwARhxAG8AMx
FwEH8QGHUaexJxGXEUch9xUSAlIRR-A1d6gAIVEgFRQCBBIA9AEBZxwQ8MgfwQcRt1GXAQcxRxGn
AA8DAqwA0HfwMAEH8QSXEfcA0bdYBzHB9wh_KTM1dwF5ADFhADcbBiNHITUAIVG3cQIAqwEB1AYS
J1wwAN0QIxBhNQAwAWfwHgIg8QQgDIGBdwF3QfcEUQ4DU3fwNmcRJgAxURAXBQECWwCQhyEnEXcx
NyHwMQ0xR0E35igCnhgUp1gAQBFX8DE_APAB8QNnEUeRJwEXQQcRF0H3FxkQAFwAMzdXASoAAJQK
AEoYFCEQAEBHATdRsQQi8AQABDEhFxEaGgACAGIRFwG3UQedAUEBV-AwoQBSB-ECVxGvAwEvACAx
B4UHIAYxiQ6TBxEnIVfwOFcRXgAhYSd4AREXGgEAJR0AmQgChAEi8ATqA0EBB0FnYAARB7oHAvUG
UscRR-AwtAIg8QKfCQNkAQJuAIFB10EHQUdxZygKU0fwOkcBpAAQQcgRAmsAMpcBZzUAETHZAAED
BSEhVzoBRCch1zHVANNH8C8RB0EH8QMHIRdRtQASMUIAUfcEAXdB2ANQBhEnMSdnABIXNgBBIdch
NwoAM1chF5gAAc4AU6cBBzE3PAETJ_EM0gHHAAE38DAhByEH8QOIDBVnGRpT9wUBR0FJAQC6BYE3
QQfwOzcBAJULAc4eAjYBBLIKEofNABSn-wEAQwCBCQHHEAEn8DHHADECt0FNACAxVzsJEgK3GgGd
AiH3AxkBchcR8DwnARBhAAIoAQRdAATJABRBYQACwQJy9xYQARfwMsEAQcdBZyHdAQAQBSJHQVsA
MWchp_cCVfA9FwEQWQAABgYCnTwDWwBFMfAEUVsAAK0LYRYgAQfwM7gAUQH3AFG3GQIB_TAA-gMQ
h8IPsSHnAWfwPgcBIPcXnAEJUQARQawAEcc1AAC4MmH3FkAB8DOpADUB9xEqACDnAfgGARcBQRE3
IdeaHGBn8D4BQPf6HASbAgFSAHVR8AQhFyGnjQJA9yLwOaAAUuH3EDEHFgAhIccwBxEnDAARV0Iz
AE8AMET3GDsCCE0AIBEXFgIA4ykDEAIxIvA5nQBzACcR9wkhB6IcYQcRtxHHUfkAEAa6DGMRV-BE
9yL7AQBFAQD6AzIhVwFHAGEXAfch8Do0ARAAMgAB4wcBAgAQIcA-EHf4JgFbCWPwRfchAUeaFRBX
QwAA5RBwBwH3JfA7ET0AEDGUADSnoWeFACABl2QQkScRJyE38EX3JjoAcydRdxHwBBGPFUL3JPA7
tQAQgbYDoBch9w5BByH3CjFKDgEjAyFF99YCEAFvAACJCDAk8DyrAHBxJ0EHESeRRw6QEfcAQXeh
hyGXEA0g8EYGDgCyIQJlAKA58DwhB0EHYTcxCAFA9wFBV2AA8AEEIfcAcTcRhxFHISfwRvcm9UAB
bwNC9zfwPpAAQHE3URenByGnQUYBMfcGEXY1khEn8Ef3OhHwAy0AoD8RB9EnQceB1yGbBxDHghMR
ZyUAUEj3ODHwtwfxAfc18EAhB8E3IXdh9wVBBxHRETG3IccqEVAH8Er3NiIDEAJPACA28DAJAQIA
EGEyDTD3DCGaB3H3ASFnMQdBJjMzSvc3VwAyNPBCzQSBcSchVxH3DiGjGEEHQVcRyAtVB-BL9zVa
ADI18EMtABBhREJA9w9Rdy0PkycRV-BL9zQBB1MA8QAbAfcH8EURB8EnEfcWAQe-ByD3JRMTIPBN
LjIVHFAAEBwqAIFGEQexJxH3GDEZIfcktAIBKAAUG1IAkVcx9xEBpxGH8DUCZbEXIfcZESsAIE6H
Lw00ETFnVgBAB1H3FfMZIPBILgBSoRch9xLSBIAsIRcBV-BPpwwBEBV_BEAx8AFBXyIBTDGAx-BJ
0Rch9xBaAEIDEfcXLQARxx47AsoDQDHwADHMAgEjMUHH8EoRXQAQDrQdkggR9xYhh-BQx_o6EMcC
BAJQCxKXJzEQ1y8AELHaEABdH0AJAfcXYQ8Q124QMw0Bx1wABi8AoufwS9EXEfcLIYdcAFJBR-BR
5y0AUacBB0HgEAZAZxH3DtMQcADwTNH3DTHpOwDJEwEfKyHwUfATgPcOEZdh0GGH_i8QN_E_sE1B
AGH3DTGXAfcH7AAELAAhAhEdMFB3AQdR0CsLAFUwAN80I-BTLgBACCH3D2MJAS4AEgR2MGBXAQdh
wHFpCCD3ESQEYQXwVGH3C7sqABQQEw06FRFSKigg9xF-FFBhsGEHUY0QgAcwN-BMYfcLyw4RIcEI
YQch9wsRJ0oVMEs3MAACMRTRsOgAEPcGLHEwZ-BJYfcLwQhA9wYxN8gCABAYMElnMAM0EhhcACEB
B8QQsAogd-BIYfcKMUdBOjtRITcx9wn-BzBJdyCqFwGWAhNRXgAQBA8HgfcKIAF38EhRMzAQB5EV
EAtfB5EHETdBF-BKdwE3ABABFgdAB2GgcSwGAcA3cPcMEAGH8EcHFgMPCwBOBgH5J5IgAfBLhwEQ
9wztN1O3AQdhkBQJAawqcQ0QEYfwRnFOKiGnIdQZEAeaBGBX8E_HERANGAGIIkUHcYCBNABxDxAB
l-BGYcUGAPg8AJsHpQQBV-BOlwEQ9w8yACJwcegF4JcB5xH3DyABl-BFcfcFwgEQp54AADIAcE2X
ASD3DxEyAGJ3AQeBYJEwAADTAIEREAGn8ESB9-gEEACMDwBKBYHwTacBEPcRAYgjAbMJMoFQgbwG
ATYkMPcSEGBGIEOBPQNBBHH3A7klQLfwTAGcABISnzgBEgYxkUChTg0BUAFQExABhxE2ABECiwER
QXIpADoHQLfwSxE-ASETAWohEScXAGEHkTCxBwEmHlEBEfcVAJclcUKR9wAh9wfJKmAhpxGn8Esw
ATAA9xVfEgMuClABB6EgsWQPQPcNAfcVOVAX8EGRZ8MTECHlCUARt-BKWh4AagIQDUMEYcEA8QL3
D6YDUAEn8EBR1A1BdwH3I_MMMMfwSV0XAC0AMQ-xD9sCMPcWEakcQDfwQEEcKBF3kRRgAWchx-BI
WiAQByEAQfcT8QvhAxIFgQIQF24YMfBAUTYpQBH3JSEUAYEn8Ek3IRchF4sAUQUBx-EKMwAQBrYA
gDcxd-A_USchTBMh9yglJWEn8Ed3MTcLCQAlABCnwAsD8QAAVAAAe0QAIAQwPVE3nRYwEfcusRdB
8Ef3AL4AIgcRMwxEB9EHAQIAQGcB9zFQAFEB8D1BV8cYEPfHAwBrADBG9wETAhIw-wEDkQEmBwEC
AABmGiD3DjAFIAchdgAiQZd7FVEEIVdBxyIPIJcRRwACPD4AUgMRDnwXFAcCAAG4AgYCABGXTgBQ
DQEHMddNAJAhJyHnIUdhJ0FOHxE3kkcSR8cSAGUDArg8D0cAAQKoOwH4RhMASABC9xUhV0UAYQE3
8Ef3ISIAA9YXIwEHDAoAtAHjIfA9UYchJyFnYfcJQRczAACXB0EhEfclVw4BTwJw9xjwPkGHIXMN
IPcRlQ0hEdcmABAYVQIQJh0FNighZyYAsTcRt0EncQcRdyFnWDowSfcYUQIBcggQKhsXYRnwPlGH
EQAagSEHISdBZzFnCh9g9wLwSfcZCRokEAH7CBAppBUAC0ciPlGJN1AHEQcxB_MTEGHEFGD3AfBK
9xOODABGBwB9AiArQUIdUPcQ8EBR0CQCiQsgByGgHACADQJgCwAOF0DwS-cQbB0yQfcP6hfR9yph
F0EHcfcJ8EFRV2kGESfTBAA3EgE9ABIRPQAASjSR8Ez3CXEHQRdhegGgBwH3QvEPZ-BLUWkcAGYY
IwdRdQAiERezDSExJ0oPVPBWZ-EPNABhQ-BxUUcRChsQYWIKIDcxNgMC_hMAihoA7Qsj8HzCSGH3
P-B3UTcuACEngYkAQDEXIQfcFgTjJgAuADGC9wUuAKAHAfc9EfB4UTchsgARN8wEERc_AxFRHQAx
AvCDqz0EAgCg9ysxh1HweUEnMQBKIyeBbgoRgQ4JAS8AMlGHMSsAEAefAwAgDlED8HlRB8kbIRdx
GQASwYozIAdRzxtFh-CE8ZknIfcqBwAiF_EzAACCAQGIAAUCABIhZRkRB8M1ACUeRIThBwECACD3
LAcAUfEA8HuhRxwC0wEMAgADrAEAagEAhjkYhkEAAn8AUAfR8HyxphcDFQIMAgAEFgAQQQcsSofw
h_GBAJXh8H2hFxEnATcJAQe-AAU8AAK-ACqH0TwAYAEHwfB_obYXATUZDPsACAIAAcAAO5fwiEIA
E9FAAACKFQFPECMBp3AAbEcRh-CJwXAAcbHwgKEXERcnETGnMbeWAVNHAZfwiioAIvculgASgJYA
UCHXIcdR4xBCh-CLsSIABkwAM6HwgSYAAHcNINdBQBhIh-CMsUoAQLHwgpEcA0FXIcchIgBYAZfw
jKEiAGABB5Hwg6EIAzBXIddGABARchUSjvcBByYAUYHwhJEn8hJA1xGncZUtTHfwj5EkABGFbgBR
R1GnAbeRTAD5OxOQHAUj9zArBTHwhoEDO2EhJwGnEZcpIADHGRGRdAAi9zJKACCHYWQAAMMeMLcB
hzBKEREkABaRSgBBgfCIYU8pAjk4AZs3RKfwk3FGAGGR8IlBVxHXAgCLGwD0BkaX8JSBQQBCcfCL
MTYRQBdR1zHCFABhAiaWgWEAMYtBV7AKYCcRFyGXQT02Qnfwl5EgAECB8I0x0xUATQQgN7FlAELn
8JlxHAAxkfCO0zUiRzHiNgCPDSPwmVkAUXHwjkFXsCYARQUhNwFMB0MB8JuBHQAhYUecIQLjFwDd
AFL3AvCcYWYBQHHwjnHzLQH4AQCpE1ABx-CdYTkA8AFh8I2RhwGnQXcxdyGn8J1xLgDiYfCOoXcB
55GnMZfwnlE6AkFh8I7BaBhFECGHARYAQUHwjuGEAzAR9w_kFwAaAAAYABBRGAACmwURD5QAALVM
QZxh9yobAAC8D0InUfcOBRECHAAwQfcsGgABnBkA3wZEIVcxRx4AEBEfABEqbgAg8QK-GEDnEQcx
VgETBwIAcBcB8JtB9ysgABAEyhxiRwEX4Tch_RMEIACQMfcqUfCN8QU3dQMi8QW4TgJ9FjDwmkEG
BTMx8I2ZAqMHUScRV1EX8QEn7RQBaxNzmTH3KUHwjJcCBB0Fgnchh0EXIZchEgBShyHwmDFNABSM
xAQFDAQQF_sZJJcx6wd-ByHwlzH3JywAAgDbEhIR-QsCHQQCLABBMfCMgYQRBiYAAEYMAg0AUMdB
8JchwwdVIfCLcbciACH3FVAREOdAARGWugdSIfCLgcceADNB9xThAELnYfCWAQhE8IqB5x4AIRIR
CQBhAfcAcfCVSAhEEfCKkYAIM1H3DPgAAIsCwoHwlQH3JiHwiJH3AxUAFGGiEQAgAEEDkfCT1R5i
EfCGsfcCFwBVgfcGIRciAADDBCCPEbwKQiHwg9FhCzWx9wFeBgAQB7Hh8IwR9yQh8HzxBRA2VwfB
R1EXPwEAJABw8QPwiBH3ImsAIW-xbgszAQfxygABJADSB-EK8IIR9yMh8G3xE2kTB2IGDAIA4fcJ
8RDwexH3IiHwa-EVCkcAbiAPLwAHkAEH8RXwdhH3IIIAMmbxFxQADzUAC-IDCwEH8RvwbxH3ISHw
W-EJF-EINAAESwcPOAAFcQ0BB-Ee8GttAIQB8FrxCSfxCHAABEYHDzwABfYBDwEH8R-wagH3IRHw
WPEJNzoABkAHDzoAA4ARAQfxI-BnAXYAcPBX8QpH8QnCAA4BBww5APgBEwEX8SXwZPcfAQfwVfEN
R3MADzoACwCgGNcp8GH3HwHwU-EQN-EHqyEDdA0MMwCQGQEH8S3wXvceMwAYEjMAAnUHBSkAGB1k
AUDxHPBd_hEw8FLxixch8Qg0ACX3NVAB8QCHAQfxGPBc9x3wUfECJ8HACTWxB4HJACP3M7UB9QOn
8RvwW-cbAfBP4QcBR_GHQQfSASb3CSkA8ADn8RzwWfcaAQfwTuEHAWfJIiRBJygABewMEyksADAf
8FdTABBNJwBE4bcxRycAQ4ch9yPiB4T3AfEg8FX3GiYAI_chJgAQD8sSEyGLAjLnAQcnADHwS9HV
ACHBBw4zEoEbUzEx9yEWA6H3AfEj8FP3GfBLIwhCp_H3CSIAgQxR9x0BB9EXuwOD8STwUvcY8Eok
AAK5AAIoADYLQQelBCQH4esDY-Ek8FH3FzIAGccyACMKUSEBA9gBEvFJUpIF8SbwUfcW8EkzAAKx
ABEJkD4APgAUQf8DBoYCEvEHAAQXBFYm8FD3FT8AGOE-ACEGUYIAEBfHDgICAACQALHxCQfxDPBQ
9xTwSDYAFec2ABLByAASYeMAMfEJJxYAAjAANk-3EzAABCsAEgsHABICaQgBhwIg8QUIAABsDwAN
AHEI8E-3EvBHOAAKOgAS4aEFAAYABSwEEgMIABLBJAABLACKgfBN9xLwRtE-AAIoAEXhBwHXugYD
fgABPQQB-gAlB6FsARNhbQlRS-cS8EVLACf3AUwAAv0ANgEH4U4ABRMAFwdRACoBB6kGEwFXAG9K
9xHwRuFXAAEBlAAh0bcCAiUHAfkAAFMAAxgCD1cACjUQ8EVbAg9XAAwVCawABE0AEqGNADBx8ElI
ACTxAEcAB0kAAUsANBfBpyMIA0kAEsFHBSWBh0UAUmHwSfcPRQAGRwAEFQECOAA6D7GXEQACIgAh
9xF-AQlLABznNi0fMjYtAlYxMS4wNXSekCx6b29tPTF9fQ==
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Iixtb2RpZmllZD0iMjAyNS0w
My0xMSAxMjo0Nzo0NiIsc3RvcmVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Il1d
:: map/
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Iixtb2RpZmllZD0iMjAyNS0w
My0xMSAxMjo0Nzo0NiIscmV2aXNpb249NjM0MF1dbHo0AGkAAABYEAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD--------------------78QgiKSxoaWRkZW49ZmFsc2UscGFuX3g9
MAgAwnk9MCx0aWxlX2g9OAkA4Hc9OCx6b29tPTAuNX19
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Iixtb2RpZmllZD0iMjAyNS0w
My0xMSAxMjo0Nzo0NiIsc3RvcmVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Il1d
:: pal/
:: pal/0.pal
b64$LS1bW3BvZCxiZ19jb2xvcj0wLGJsYWNrZXN0X2NvbG9yPTAsY3JlYXRlZD0iMjAyNS0wMy0x
MSAwOTozMDoyOCIsaGlkZGVuPXtbMF09ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2V9LGhpZGRlbl90b2dnbGVzPXtbMF09ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2V9LGh1
ZV9tb2RlPSJodWUrbHVtIixpY29uPXVzZXJkYXRhKCJ1OCIsMTYsMTYsIjAwMDEwMTAxMDEwMTAx
MDEwMTAxMDEwMDAwMDAwMDAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNjAxMDAwMDAwMDAwMDAxMDcw
NzA3MDcwNzA3MDcwNzA2MDYwMTAwMDAwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDYwNjA2MDEwMDAw
MDAwMTA3MDcwNzA3MDcwNzA3MDcwNjA2MDYwNjAxMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3MDcw
NzA3MDEwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwMTAwMDAwMTA3MDcwNjA2MDEwMTBk
MGQwMTAxMDcwNzAxMDAwMDAxMDcwNzA2MDYwMTAxMGQwZDAxMDEwNzA3MDEwMDAwMDEwNzA3MDEw
MTA3MDcwNjA2MGQwZDA3MDcwMTAwMDAwMTA3MDcwMTAxMDcwNzA2MDYwZDBkMDcwNzAxMDAwMDAx
MDcwNzBkMGQwMTAxMGQwZDA2MDYwNzA3MDEwMDAwMDEwNzA3MGQwZDAxMDEwZDBkMDYwNjA3MDcw
MTAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzAxMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3
MDcwNzA3MDEwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAwIiksbG9ja2VkPXtbMF09
dHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRy
dWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVl
LHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlfSxtb2RpZmllZD0iMjAyNS0wMy0xMSAxMjo0Nzo0NiIsb2twYWxfdmVyc2lvbj0i
MS4xLjEiLHJldmlzaW9uPTMwNCx0ZXN0X2N1YmVfY29sb3JzPXtbMF09ezE1LDMxLDR9LHszMSw0
LDIwfSx7NCwyMCwyMX0sezEwLDksMjV9LHs5LDI1LDI0fSx7OCwyNCwyfSx7MjYsMTEsMjd9LHsx
MSwyNywzfSx7MjcsMywxOX0sezI4LDE3LDE5fSx7MjgsMTIsMTZ9LHsxMiwxNiwxfSx7NiwyOSwx
M30sezI5LDEzLDE4fSx7MTMsMTgsMX0sezcsMjMsMTR9LHsyMywxNCwxM30sezE0LDMwLDE4fSx7
Nyw2LDIyfSx7NiwyMiw1fSx7MjIsNSwyMX0sezEsMSwxfSx7MSwxLDF9LHsxLDEsMX19LHRlc3Rf
bW9kZT0iY3ViZXMiLHRlc3RfcmFtcF9jb2xvcnM9dXNlcmRhdGEoInU4IiwxMCwyNywiMDAxODA4
MTkwOTBhMWEwYjFiMDAwNjAwMDAwMDAwMDAwMDAwMDMwMDE2MDAwMDAwMDAwMDAwMDAxMzAwMDUw
MDAwMDAwMDAwMDAwMDAxMDAwZDAwMDAwMDAwMDAwMDAwMTAwMDFkMDAwMDAwMDAwMDAwMDAxMTAw
MTcwMDAwMDAwMDAwMDAwMDBjMDAwZTAwMDAwMDAwMDAwMDAwMWMwMDFlMTIwMjE1MTQwNDFmMGYw
NzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDE0MDQxZjBmMDgxODAyMDAwMDE1MDUxNjA2MDcxNzBl
MWUwMDAwMDExMDExMGMxYzFkMGQxMjAwMDAxMzAzMWIwYjFhMGEwOTE5MDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwIiksd2hpdGVzdF9jb2xvcj03XV1sejQACgEAABUCAAD1BXVz
ZXJkYXRhKCJpMzIiLDY0LCIwAQDAMWQyYjUzMDA3ZTI1CADwFzAwODc1MTAwYWI1MjM2MDA1ZjU3
NGYwMGMyYzNjNzAwZmZmMWU4CABAMDA0ZAgAEWE2AGBmZmVjMjcKACBlNDgAQDI5YWQkAGA4Mzc2
OWMgADE3N2E4ALBjY2FhMDAyNDYzYi8A8B4wYTVhMTAwNjU0Njg4MDAxMjUzNTkwMDc0MmYyOTAw
NDUyZDMyMDBhMjg4NzlAAPANYWNjNTAwYjkwMDNlMDBlMjZiMDIwMDk1ZjA0MlAAIGIywACgNjRk
ZmY2MDBiZIkAAJYAQDBkYWJAAF84NTU3MAEA6VAwMDAiKQ==
:: pal/1.pal
b64$LS1bW3BvZCxiZ19jb2xvcj0wLGJsYWNrZXN0X2NvbG9yPTAsY3JlYXRlZD0iMjAyNS0wMy0x
MSAxMjowODoyNSIsaGlkZGVuPXtbMF09ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2V9LGhpZGRlbl90b2dnbGVzPXtbMF09ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2V9LGh1
ZV9tb2RlPSJodWUrbHVtIixpY29uPXVzZXJkYXRhKCJ1OCIsMTYsMTYsIjAwMDEwMTAxMDEwMTAx
MDEwMTAxMDEwMDAwMDAwMDAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNjAxMDAwMDAwMDAwMDAxMDcw
NzA3MDcwNzA3MDcwNzA2MDYwMTAwMDAwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDYwNjA2MDEwMDAw
MDAwMTA3MDcwNzA3MDcwNzA3MDcwNjA2MDYwNjAxMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3MDcw
NzA3MDEwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwMTAwMDAwMTA3MDcwNjA2MDEwMTBk
MGQwMTAxMDcwNzAxMDAwMDAxMDcwNzA2MDYwMTAxMGQwZDAxMDEwNzA3MDEwMDAwMDEwNzA3MDEw
MTA3MDcwNjA2MGQwZDA3MDcwMTAwMDAwMTA3MDcwMTAxMDcwNzA2MDYwZDBkMDcwNzAxMDAwMDAx
MDcwNzBkMGQwMTAxMGQwZDA2MDYwNzA3MDEwMDAwMDEwNzA3MGQwZDAxMDEwZDBkMDYwNjA3MDcw
MTAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzAxMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3
MDcwNzA3MDEwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAwIiksbG9ja2VkPXtbMF09
dHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRy
dWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVl
LHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlfSxtb2RpZmllZD0iMjAyNS0wMy0xMSAxMjo0Nzo0NiIsb2twYWxfdmVyc2lvbj0i
MS4xLjEiLHJldmlzaW9uPTEyLHRlc3RfY3ViZV9jb2xvcnM9e1swXT17MTUsMzEsNH0sezMxLDQs
MjB9LHs0LDIwLDIxfSx7MTAsOSwyNX0sezksMjUsMjR9LHs4LDI0LDJ9LHsyNiwxMSwyN30sezEx
LDI3LDN9LHsyNywzLDE5fSx7MjgsMTcsMTl9LHsyOCwxMiwxNn0sezEyLDE2LDF9LHs2LDI5LDEz
fSx7MjksMTMsMTh9LHsxMywxOCwxfSx7NywyMywxNH0sezIzLDE0LDEzfSx7MTQsMzAsMTh9LHs3
LDYsMjJ9LHs2LDIyLDV9LHsyMiw1LDIxfSx7MSwxLDF9LHsxLDEsMX0sezEsMSwxfX0sdGVzdF9t
b2RlPSJyYW1wcyIsdGVzdF9yYW1wX2NvbG9ycz11c2VyZGF0YSgidTgiLDEwLDI3LCIwMDE4MDgx
OTA5MGExYTBiMWIwMDA2MDAwMDAwMDAwMDAwMDAwMzAwMTYwMDAwMDAwMDAwMDAwMDEzMDAwNTAw
MDAwMDAwMDAwMDAwMDEwMDBkMDAwMDAwMDAwMDAwMDAxMDAwMWQwMDAwMDAwMDAwMDAwMDExMDAx
NzAwMDAwMDAwMDAwMDAwMGMwMDBlMDAwMDAwMDAwMDAwMDAxYzAwMWUxMjAyMTUxNDA0MWYwZjA3
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTQwNDFmMGYwODE4MDIwMDAwMTUwNTE2MDYwNzE3MGUx
ZTAwMDAwMTEwMTEwYzFjMWQwZDEyMDAwMDEzMDMxYjBiMWEwYTA5MTkwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAiKSx3aGl0ZXN0X2NvbG9yPTddXWx6NAAKAQAAFQIAAPUFdXNl
cmRhdGEoImkzMiIsNjQsIjABAMAxZDJiNTMwMDdlMjUIAPAXMDA4NzUxMDBhYjUyMzYwMDVmNTc0
ZjAwYzJjM2M3MDBmZmYxZTgIAEAwMDRkCAARYTYAYGZmZWMyNwoAIGU0OABAMjlhZCQAYDgzNzY5
YyAAMTc3YTgAsGNjYWEwMDI0NjNiLwDwHjBhNWExMDA2NTQ2ODgwMDEyNTM1OTAwNzQyZjI5MDA0
NTJkMzIwMGEyODg3OUAA8A1hY2M1MDBiOTAwM2UwMGUyNmIwMjAwOTVmMDQyUAAgYjLAAKA2NGRm
ZjYwMGJkiQAAlgBAMGRhYkAAXzg1NTcwAQDpUDAwMCIp
:: pal/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTExIDA5OjMwOjI4Iixtb2RpZmllZD0iMjAyNS0w
My0xMSAxMjo0Nzo0NiJdXQ==
:: sfx/
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA3Iixtb2RpZmllZD0iMjAyNS0w
My0xMSAxMjo0Nzo0NiIscmV2aXNpb249NjI3NV1dbHo0ABEBAABSCAAA8CdweHUAAygAAAQABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDBAUGBwAP-5AICQoLDwwPDQ8ODw8QAPAADQ8RDxIPEw8UDxUP
Fg8XEwDxAQ8YDxkPGg8bDxwPHQ8eDx8UAPEAIA8hDyIPIw8kDyUPJg8nFADxACgPKQ8qDysPLA8t
Dy4PLxQA8QAwDzEPMg8zDzQPNQ82DzcUAP8FOA85DzoPOw88Dz0PPg8-AA--8P8BAOv-J1oBEAYP
IBABIAEgAfAAAhACDBABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDDAA-zkf-wEA
3L-4D0AADUD--7DwcAoA--9kH-8BAP_ZUP----8g
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Iixtb2RpZmllZD0iMjAyNS0w
My0xMSAxMjo0Nzo0NiIsc3RvcmVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Il1d
:: src/
:: src/files.lua
--[[pod_format="raw",created="2025-03-08 09:21:19",modified="2025-03-11 12:47:46",revision=368]]
-- Loading and saving -------------------------------------------------------------


function save_working_file()
	local ext = pwf():ext()
	if ext == "hex" or ext == "txt" then
		return save_hex_file()
	else
		if ext != "pal" then
			notify("unknown file extension: saved using default file format")
		end
		return save_pal_file()
	end
end


function load_working_file(data, metadata)
	if fstat(pwf()) ~= "file" then
		-- This is a new file
		create_metadata()
		is_new_file = true
		return
	end

	metadata = metadata or {}
	local ext = pwf():ext()
	if ext == "pal" then
		load_pal_file(data, metadata or {})
		if undo_stack then undo_stack:reset() end
		send_palette()

	elseif ext == "hex" or ext == "txt" then
		if metadata.okpal_version then
			current_import_choice = "overwrite"
			load_hex_file(data, metadata or {})
			if undo_stack then undo_stack:reset() end
			send_palette()
		else
			imported_hex_file = { data = data, metadata = metadata }
		end

	else
		notify("unkown file extension: OkPal can only load \".pal\" and \".hex\" palettes")
	end
end


-- Metadata ----------------------------------------------------------------------


function create_metadata()
	local metadata = {}
	metadata.okpal_version = okpal_version
	metadata.icon = userdata("u8",16,16,"0001010101010101010101000000000000010707070707070707060100000000000107070707070707070606010000000001070707070707070706060601000000010707070707070707060606060100000107070707070707070707070701000001070707070707070707070707010000010707060601010d0d01010707010000010707060601010d0d010107070100000107070101070706060d0d07070100000107070101070706060d0d07070100000107070d0d01010d0d060607070100000107070d0d01010d0d060607070100000107070707070707070707070701000001070707070707070707070707010000010101010101010101010101010100")
	metadata.bg_color = bg_color
	metadata.blackest_color = blackest_color
	metadata.whitest_color = whitest_color
	metadata.hidden_toggles = hidden_toggles
	metadata.hidden = copy(hidden)
	metadata.locked = copy(locked)
	metadata.hue_mode = hue_mode
	metadata.test_mode = test_mode
	metadata.test_cube_colors = copy(test_cube_colors)
	metadata.test_ramp_colors = test_ramp_colors and test_ramp_colors:convert("u8")
	return metadata
end


function load_metadata(metadata)
	metadata = metadata or {}
	bg_color = metadata.bg_color or 0
	blackest_color = metadata.blackest_color or 0
	whitest_color = metadata.whitest_color or 7
	
	if type(metadata.hidden_toggles) == "table" then
		hidden_toggles = metadata.hidden_toggles
	else
		hidden_toggles = {}
		for row = 0, 3 do
			hidden_toggles[row] = false
		end
	end
	
	if type(metadata.hidden) == "table" then
		hidden = metadata.hidden
	else
		hidden = {}
		for c = 0, 63 do
			hidden[c] = false
		end
	end
	
	if type(metadata.locked) == "table" then
		locked = metadata.locked
	elseif pwf() == "/ram/cart/pal/0.pal" then
		-- This only occurs when a default starting file
		-- is created.
		for c = 0, 63 do
			locked[c] = c <= 31
		end
	else
		locked = {}
		for c = 0, 63 do
			locked[c] = false
		end
	end

	if type(metadata.hue_mode) == "string" then
		hue_mode = metadata.hue_mode
	else
		hue_mode = "hue+lum"
	end

	if type(metadata.test_mode) == "string" then
		test_mode = metadata.test_mode
	else
		test_mode = "cubes"
	end

	if type(metadata.test_cube_colors) == "table" then
		test_cube_colors = copy(metadata.test_cube_colors)
	else
		test_cube_colors = copy(default_test_cube_colors)
	end
	
	if type(metadata.test_ramp_colors) == "userdata" then
		test_ramp_colors = metadata.test_ramp_colors:convert("u8")
	else
		test_ramp_colors = default_test_ramp_colors:convert("u8")
	end
end


-- Load and save pal files -------------------------------------------------------


function load_pal_file(data, metadata)
	if data then
		if type(data) == "userdata" and data:width() == 64 then
			for c = 0, 63 do
				if data[c] then
					set_color(c, data[c])
				end
			end
		else
			notify("unable to load working file")
			return
		end
	else
		-- New file
	end
	rebuild_pal()
	load_metadata(metadata)
end


function save_pal_file()
	local output = userdata("i32", 64)
	for c = 0, 63 do
		output:set(c, get_color(c))
	end
	return output, create_metadata()
end


-- Load and save hex files ---------------------------------------------------------


function load_hex_file(data, metadata)
	if type(data) == "string" then
		local lines = split(data, "\n", false)
		local codes = {}
		for l in all(lines) do
			local code = tonum("0x" .. l:gsub("%s",""))
			if type(code) == "number" then
				codes[#codes + 1] = code
			elseif code then
				notify("error importing hex file")
			end
		end
		local start = 0
		if current_import_choice == "dont_clobber" then
			-- TODO: put in separate function and add menu item
			for c = 0, 32 do
				set_color(c, peek4(0x5000 + 4 * (64 + c)))
			end
			start = 32
		end
		if #codes > 64 - start then
			notify("*** not enough space to import all the colors ***")
		end
		for c = start, 63 do
			if codes[c - start + 1] then
				set_color(c, codes[c - start + 1])
			else
				set_color(c, 0x000000)
			end
		end
		rebuild_pal()
	elseif data then
		notify("import hex file: unkown type: " .. type(data))
	end

	load_metadata(metadata)
	if current_import_choice == "dont_clobber" then
		active_color = nil
		for c = 0, 31 do
			hidden[c] = true
			locked[c] = true
		end
		hidden_toggles[0] = true
		hidden_toggles[1] = true
		blackest_color = 0
		whitest_color = 7
		bg_color = 0
	else
		local best_black, best_white = find_blackest_and_whitest()
		blackest_color = metadata.blackest_color or best_black
		whitest_color = metadata.whitest_color or best_white
		bg_color = metadata.bg_color or blackest_color
	end
end


function save_hex_file(filename)
	-- Don't export trailing black colors
	local fin = 63
	while fin > 0 and get_color(fin) == 0 do
		fin -= 1
	end
	
	local output = ""
	for c = 0, fin do
		output ..= color_to_hex(get_color(c)) .. "\n"
	end
	return output, create_metadata()
end

:: src/globals.lua
--[[pod_format="raw",created="2024-04-03 09:15:53",modified="2025-03-11 12:47:45",revision=4457]]
current_import_choice = "dont_clobber"

undo_stack = nil

padlock_flashing = false
padlock_flashing_time = 0

gui = nil
gui_changed = false

is_new_file = false
imported_hex_file = nil

blink_timer = 180 + math.random(1, 6) * 90
blink_eye = math.random(0, 3)
crying_a_timer = 0

help_current_line = 1


-- Saved in settings ----------------------------------------------------------


user_settings = {
	send_palette = true,
	new_interface = true,
	dont_blink = false,
}


-- Saved in undo stack ----------------------------------------------------------


pal_okhsl = {}
pal_code = {}

-- and also `test_cube_colors`? or not?


-- Saved in metadata --------------------------------------------------------------


okpal_version = "1.1.1"

active_color = nil
bg_color = 0 -- TODO: what about fg?
blackest_color = 0 -- TODO: remove?
whitest_color = 7 -- TODO: remove?

hidden_toggles = { [0] = false, false, false, false }
hidden = {}
for i = 0, 63 do hidden[i] = false end
locked = {}
for i = 0, 63 do locked[i] = i <= 31 end

hue_mode = "hue+sat"

test_mode = "cubes"
test_cube_colors = nil
test_ramp_colors = nil


-- Constants ----------------------------------------------------------------------


default_test_cube_colors = {
	[0] = 
	{15, 31, 4},
	{31, 4, 20},
	{4, 20, 21},
	--
	{10, 9, 25},
	{9, 25, 24},
	{8, 24, 2},
	--
	{26, 11, 27},
	{11, 27, 3},
	{27, 3, 19},
	--
	{28, 17, 19},
	{28, 12, 16},
	{12, 16, 1},
	--
	{6, 29, 13},
	{29, 13, 18},
	{13, 18, 1},
	--
	{7, 23, 14},
	{23, 14, 13},
	{14, 30, 18},
	--
	{7, 6, 22},
	{6, 22, 5},
	{22, 5, 21},
	--
	{1, 1, 1},
	{1, 1, 1},
	{1, 1, 1},
	--
}

default_test_ramp_colors = userdata("u8", 10, 27, 0)
default_test_ramp_colors:set(
	0, 0,
	 0, 24,  8, 25,  9, 10, 26, 11, 27,  0,
	 6,  0,  0,  0,  0,  0,  0,  0,  3,  0, 
	22,  0,  0,  0,  0,  0,  0,  0, 19,  0, 
	 5,  0,  0,  0,  0,  0,  0,  0,  1,  0, 
	13,  0,  0,  0,  0,  0,  0,  0, 16,  0, 
	29,  0,  0,  0,  0,  0,  0,  0, 17,  0, 
	23,  0,  0,  0,  0,  0,  0,  0, 12,  0, 
	14,  0,  0,  0,  0,  0,  0,  0, 28,  0, 
	30, 18,  2, 21, 20,  4, 31, 15,  7,  0,
	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	 0, 20,  4, 31, 15,  8, 24,  2,  0,  0,
	21,  5, 22,  6,  7, 23, 14, 30,  0,  0,
	 1, 16, 17, 12, 28, 29, 13, 18,  0,  0,
	19,  3, 27, 11, 26, 10,  9, 25,  0,  0
)


:: src/gui.lua
--[[pod_format="raw",created="2024-03-31 05:58:06",modified="2025-03-11 12:47:46",revision=7894]]
function generate_gui()
	gui = create_gui()
	generate_palette_gui()
end


-----------------------------------------------------------------------------------


local modal = nil


function open_modal(width, height, autoclose)
	if modal ~= nil then
		--TODO: !!!
		return
	end
	
	modal = gui:attach {
		x = 0, y = 0,
		width = gui.width, height = gui.height,
		autoclose = autoclose or false,
		draw = function(self)
			poke(0x550b, 0x3f)
			---fillp(0b0101101001011010)
			---fillp(0b0001001001001000)
			---fillp(0b1110110110110111)
			fillp(0b0011011011001001)
			rectfill(0, 0, self.width - 1, self.height - 1, 61)
			fillp()
			poke(0x550b, 0x00)
		end,
		click = function(self, msg)
			if msg.has_pointer and self.autoclose then
				close_modal()
			end
		end
	}
	local el = modal:attach {
		x = (modal.width - width) // 2, y = (modal.height - height) // 2,
		width = width, height = height,
		draw = function(self)
			clip()
			rect(-3, -3, self.width+3, self.height+3, bg_color)
			rectfill(-2, -2, self.width+2, self.height+2, outline_color())
			rect(-1, -1, self.width+1, self.height+1, bg_color)
		end,
	}
	return el
end


function has_modal()
	return modal ~= nil
end


function close_modal()
	if modal then
		modal:detach()
	end
	modal = nil
end


-----------------------------------------------------------------------------------


function create_label(el)
	el.width = el.width or (5 * #el.label + 4)
	el.height = el.height or 9
	gui:new(el)
	function el:draw()
		print(self.label, 0, 0, self.fg or outline_color())
	end
	return el
end


-----------------------------------------------------------------------------------


function create_button(el)
	local label = el.label or "---"
	el.width = el.width or (#label * 5 + 8 + 8)
	el.height = el.height or 16
	el.cursor = "pointer"

	function el:draw(msg)
		local fg = self.fg or bg_color
		line(2, 0, self.width - 3, 0, fg)
		pset(1, 1, fg)
		line(2, self.height - 1, self.width - 3, self.height - 1, fg)
		pset(self.width - 2, 1, fg)
		line(0, 2, 0, self.height - 3, fg)
		pset(1, self.height - 2, fg)
		line(self.width - 1, 2, self.width - 1, self.height - 3, fg)
		pset(self.width - 2, self.height - 2, fg)
		local pressed = msg.has_pointer and self.clicked
		if pressed then
			rectfill(1, 1, self.width - 2, self.height - 2, fg)
		end
		print(self.label or "---", 9, 4, pressed and outline_color() or fg)
	end
	
	function el:click()
		self.clicked = true
	end
	
	function el:release(msg)
		self.clicked = false
		if (msg.has_pointer and self.act) self.act()
	end	

	return el
end


function create_action_button(el)
	local s = get_spr(el.sprite)
	el.width = s:width() or 16
	el.height = s:height() or 16
	el.cursor = "pointer"

	function el:draw(msg)
		pal(7, outline_color())
		local s = el.sprite
		if el.active and not el:active() then
			s += 2
		elseif el.clicked and msg.has_pointer then
			s += 1
		end
		spr(s, 0, 0)
		pal(7, 7)
	end
	
	function el:click()
		self.clicked = true
	end
	
	function el:release(msg)
		self.clicked = false
		if (msg.has_pointer and self.act) self.act()
	end	

	return el
end


-----------------------------------------------------------------------------------


function create_field(el)
	el.cursor = "pointer"

	function el:draw()
		local str = type(self.get == "function") and self:get() or "---"
		local fg = type(self.get_fg == "function") and self:get_fg() or outline_color()
		local prefix = self.small_font and "\014" or ""
		if self:has_keyboard_focus() then
			local suffix = (time() % 0.666 > 0.333) and "\016" or ""
			str =  self.str .. suffix
			print(prefix .. str, 1, 1, fg)
			clip()
			rect(-1, -1, self.width, self.height, fg)
		else
			local ww,hh = print(prefix .. str, 0, -1000)
			print(prefix .. str, self.width - ww - 1, 1, fg)
		end
	end

	function el:click()
		self:set_keyboard_focus(true)
		readtext(true)
		self.str = "" -- starting editing new string
	end

	el.custom_update = el.update
	function el:update()
		self:custom_update()
		if self:has_keyboard_focus() then
			while peektext() do
				self.str = self.str .. readtext()
			end
			if keyp("backspace") then
				self.str = sub(self.str, 1, -2)
			end
			if keyp("enter") then
				if type(self.set) == "function" then
					self:set(self.str)
				end
				self:set_keyboard_focus(false)
			end
		end
	end

--	gui:new(el)

	return el
end


-----------------------------------------------------------------------------------


function create_checkbox(el)
	el.width = el.width or (16 + 5 * #el.label + 4)
	el.height = el.height or 12
	el.cursor = "pointer"
	el.get = el.get or function(self) return self.checked end
	el.toggle = el.toggle or function(self) self.checked = not self.checked end
	gui:new(el)

	function el:draw()
		local fg = self.fg or outline_color()
		local checked = self:get()
		pal(7, fg)
		spr(checked and 49 or 48, 0, 0)
		pal(7)
		print(el.label, 16, 1, fg)
	end
	
	function el:release(msg)
		if msg.has_pointer then
			self:toggle()
		end
	end	

	return el
end


------------------------------------------------------------------------------


function create_radio_button(el)
	el.width = 188
	el.height = 12 -- TODO: count the lines?
	el.cursor = "pointer"
	
	function el:draw()
		local fg = self.fg or bg_color
		oval(0, 0, 8, 8, fg)
		local choices = self.parent.choices
		if choices and choices[self.group] == self.key then
			ovalfill(2, 2, 6, 6, fg)
		end
		print(el.label, 15, 1, fg)
	end
	
	function el:tap()
		if not self.parent.choices then
			self.parent.choices = {}
		end
		self.parent.choices[self.group] = self.key
	end
	
	return el
end


--------------------------------------------------------------------------------


function clear_cube_colors()
	for i = 0, #test_cube_colors - 1 do
		test_cube_colors[i] = { 1, 1, 1 }
	end
end


function clear_ramp_colors()
	for i = 0, test_ramp_colors:width()-1 do
		for j = 0, test_ramp_colors:height()-1 do
			test_ramp_colors:set(i, j, bg_color)
		end
	end
end


-- Utility functions ----------------------------------------------------------------


function outline_color()
	if pal_okhsl[bg_color].l < 0.5 then
		return whitest_color
	else
		return blackest_color
	end
end


function contrast_color(c)
	return (pal_okhsl[c].l < 0.5) and whitest_color or blackest_color
end

:: src/gui_alt_sliders.lua
--[[pod_format="raw",created="2025-03-11 11:29:57",modified="2025-03-11 12:47:46",revision=88]]


local rectangle_width = 375
local rectangle_height = 98
local rectangle_border = 7
local rectangle_inner_width = rectangle_width - 2 * rectangle_border
local rectangle_inner_height = rectangle_height - 2 * rectangle_border


-------------------------------------------------------------------------------


local function hv_coords(c, ordinate)
	local hue = pal_okhsl[c].h
	local v = pal_okhsl[c][ordinate]
	local x = rectangle_border + hue * rectangle_inner_width
	local y = rectangle_border + rectangle_inner_height - v * rectangle_inner_height
	return x, y
end


local function coords_hv(x, y)
	local hue = (x - rectangle_border) / rectangle_inner_width
	local v = 1.0 - ((y - rectangle_border) / rectangle_inner_height)
	return hue, v
end


---------------------------------------------------------------------------------


function create_rectangle_picker(el)
	el.ordinate = el.ordinate or "l"
	el.width = rectangle_width
	el.height = rectangle_height
	el.drag_delta = nil
		
	function el:draw()
--		rectfill(0, 0, self.width, self.height, 6)
		rect(
			rectangle_border - 1, rectangle_border - 1, 
			rectangle_border + rectangle_inner_width + 1, rectangle_border + rectangle_inner_height + 1, 
			outline_color()
		)
		for c = 0, 63 do
			if not hidden[c] and pal_okhsl[c].l != 0 then
				local x, y = hv_coords(c, self.ordinate)
				ovalfill(x - 3, y - 3, x + 3, y + 3, c)
			end
		end
		if active_color and not hidden[active_color] then
			local x, y = hv_coords(active_color, self.ordinate)
			pal(7, whitest_color)
			pal(14, active_color)
			spr(
				self.drag_delta and 12 or 11,
				x - 5, y - 5,
				x + 5, y + 5
			)
			pal(14, 14)
			pal(7, 7)
		end
		clip()
		pal(7, outline_color())
		spr(self.ordinate == "l" and 22 or 23, -11, self.height - 74)
		pal(7, 7)
	end	
	
	function el:hover(msg)
		if active_color and not hidden[active_color] then
			local ax, ay = hv_coords(active_color, self.ordinate)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx < 6 and dy < 6 then
				self.cursor = "grab"
			else
				self.cursor = 1
			end
		end
	end
	
	function el:click(msg)
		if active_color and not hidden[active_color] then
			local ax, ay = hv_coords(active_color, self.ordinate)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx < 6 and dy < 6 then
				undo_stack:checkpoint()
				self.drag_delta = { x = ax - msg.mx, y = ay - msg.my }
				return
			end
		end
		active_color = nil
		-- In reverse order to prioritize colors on top
		for c = 63, 0, -1 do
			local cx, cy = hv_coords(c, self.ordinate)
			local dx = abs(cx - msg.mx)
			local dy = abs(cy - msg.my)
			if dx < 3 and dy < 3 and not hidden[c] and pal_okhsl[c].l != 0 then
				undo_stack:checkpoint()
				active_color = c
				self.drag_delta = { x = cx - msg.mx, y = cy - msg.my }
				self.cursor = "grab"
				return
			end
		end
		self.drag_delta = nil
	end
	
	function el:drag(msg)
		if (not active_color) return
		if (not self.drag_delta) return
		if locked[active_color] then
			padlock_flashing = true
		else
			local ax = msg.mx + self.drag_delta.x
			local ay = msg.my + self.drag_delta.y
			local hue, v = coords_hv(ax, ay)
			hue = max(0.0, hue)
			local sat = self.ordinate == "s" and v or nil
			local lum = self.ordinate == "l" and v or nil
			change_color(active_color, hue, sat, lum)
		end
	end
	
	function el:release(msg)
		send_palette()
		self.drag_delta = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end

	return el
end


--------------------------------------------------------------------------------


function create_hue_knob(el)
	el.width = rectangle_width
	el.height = 9
	
	function el:draw()
		if active_color and not hidden[active_color] then
			local ax, _ = hv_coords(active_color, "l")
			pal(7, outline_color())
			pal(13, active_color)
			spr(5, ax - 4, 0)
			pal(13, 13)
			pal(7, 7)
		end
		clip()
		pal(7, outline_color())
		spr(31, rectangle_width // 2 - 6, self.height + 1)
		pal(7)
	end	
	
	function el:hover(msg)
		if active_color and not hidden[active_color] then
			local ax, _ = hv_coords(active_color, "l")
			if msg.mx and msg.mx >= ax - 4 and msg.mx <= ax + 4 then
				self.cursor = "grab"
			else
				self.cursor = 1
			end
		end
	end

	function el:click(msg)
		undo_stack:checkpoint()
		if active_color and not hidden[active_color] then
			local ax, _ = hv_coords(active_color, "l")
			if msg.mx and msg.mx >= ax - 4 and msg.mx <= ax + 4 then
				self.drag_delta_x = ax - msg.mx
			end
		end
	end
	
	function el:drag(msg)
		if (not active_color) return
		if (not self.drag_delta_x) return
		if locked[active_color] then
			padlock_flashing = true
		else
			local ax = msg.mx + self.drag_delta_x
			local hue, _ = coords_hv(ax, 0)
			hue = max(0.0, hue)
			change_color(active_color, hue, nil, nil)
		end
	end
	
	function el:release(msg)
		send_palette()
		self.drag_delta_x = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end
			
	return el
end


--------------------------------------------------------------------------------


function create_val_knob(el)
	el.ordinate = el.ordinate or "l"
	el.width = 9
	el.height = rectangle_height
	
	function el:draw()
		if active_color and not hidden[active_color] then
			local _, ay = hv_coords(active_color, self.ordinate)
			pal(7, outline_color())
			pal(13, active_color)
			spr(6, 0, ay - 4)
			pal(13, 13)
			pal(7, 7)
		end
	end	
	
	function el:hover(msg)
		if active_color and not hidden[active_color] then
			local _, ay = hv_coords(active_color, self.ordinate)
			if msg.my and msg.my >= ay - 4 and msg.my <= ay + 4 then
				self.cursor = "grab"
			else
				self.cursor = 1
			end
		end
	end

	function el:click(msg)
		undo_stack:checkpoint()
		if active_color and not hidden[active_color] then
			local _, ay = hv_coords(active_color, self.ordinate)
			if msg.my and msg.my >= ay - 4 and msg.my <= ay + 4 then
				self.drag_delta_y = ay - msg.my
			end
		end
	end
	
	function el:drag(msg)
		if (not active_color) return
		if (not self.drag_delta_y) return
		if locked[active_color] then
			padlock_flashing = true
		else
			local ay = msg.my + self.drag_delta_y
			local _, v = coords_hv(0, ay)
			local sat = self.ordinate == "s" and v or nil
			local lum = self.ordinate == "l" and v or nil
			change_color(active_color, nil, sat, lum)
		end
	end
	
	function el:release(msg)
		send_palette()
		self.drag_delta_y = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end
			
	return el
end

:: src/gui_help.lua
--[[pod_format="raw",created="2025-03-07 10:21:37",modified="2025-03-07 17:37:27",revision=440]]
local text_view

function open_help()
	local el = open_modal(270, 250, true)
	if not el then
		return
	end
	text_view = el:attach(create_text_view { x = 10, y = 0, width = 250, height = 250 })
	text_view:set_text(fetch("manual.txt"))
end


function create_text_view(el)
	el.lines = {}

	function el:set_text(text)
		el.lines = soft_wrap(text, self.width)
	end

	function el:draw(msg)
		cursor(0, 0)
		color(bg_color)
		local l = help_current_line
		local y = 0
		while y < self.height do
			print(self.lines[l])
			y += 11
			l += 1
		end
	end
	
	function el:mousewheel(msg)
		local nb_lines = self.height // 11
		help_current_line = mid(
			1,
			help_current_line - (msg.wheel_y * 3),	
			#self.lines - nb_lines
		)
	end	

	return el
end
:: src/gui_hexdialog.lua
--[[pod_format="raw",created="2025-03-05 12:06:52",modified="2025-03-11 12:47:46",revision=264]]
function open_import_hex_file_dialog()
	local el = open_modal(180, 100, false)
	el:attach(create_label { x = 50, y = 6, label = "Import \".hex\" file", fg = bg_color })
	el:attach(create_radio_button {
		x = 16, y = 36, 
		label = "Import after Picotron's colors",
		group = "import_hex",
		key = "dont_clobber",
	})
	el:attach(create_radio_button {
		x = 16, y = 56, 
		label = "Replace all colors",
		group = "import_hex",
		key = "overwrite",
	})
	el.choices = { import_hex = "dont_clobber" }
	el:attach(create_button {
		x = 110, y = 80,
		label = "Import",
		act = function() prepare_imported_hex(el) end
	})
end


function prepare_imported_hex(dialog)
	current_import_choice = dialog.choices.import_hex
	load_hex_file(imported_hex_file.data, imported_hex_file.metadata or {})
	clear_cube_colors()
	clear_ramp_colors()
	if (undo_stack) undo_stack:reset()
	send_palette()
	imported_hex_file = nil
	close_modal()
	gui_changed = true
end
:: src/gui_newfile.lua
--[[pod_format="raw",created="2025-03-05 08:57:06",modified="2025-03-05 12:06:43",revision=168]]
function open_new_file_dialog()
	local el = open_modal(180, 100, false)
	el:attach(create_label { x = 60, y = 6, label = "New Palette", fg = bg_color })
	el:attach(create_radio_button {
		x = 16, y = 36, 
		label = "Keep default colors",
		group = "new_palette",
		key = "keep_default",
	})
	el:attach(create_radio_button {
		x = 16, y = 56, 
		label = "Start with empty palette",
		group = "new_palette",
		key = "empty_palette",
	})
	el.choices = { new_palette = "keep_default" }
	el:attach(create_button {
		x = 110, y = 80,
		label = "Let's go!",
		act = function() prepare_new_file(el) end
	})
end


function prepare_new_file(dialog)
	if dialog.choices.new_palette == "empty_palette" then
		clear_colors()
	end
	close_modal()
end
:: src/gui_new_sliders.lua
--[[pod_format="raw",created="2025-03-11 04:23:57",modified="2025-03-11 12:47:46",revision=788]]
local circle_size = 190
local circle_border = 13
local circle_inner = circle_size - 2 * circle_border


local square_size = 190
local square_border = 7
local square_inner = square_size - 2 * square_border


------------------------------------------------------------------------------------


local function sl_coords(c)
	local sat = pal_okhsl[c].s
	local lum = pal_okhsl[c].l
	local x = square_border + sat * square_inner
	local y = square_border + square_inner - lum * square_inner
	return x, y
end


local function coords_sl(x, y)
	local sat = (x - square_border) / square_inner
	local lum = 1.0 - ((y - square_border) / square_inner)
	return sat, lum
end


-- Remove 0.25 to compensate for Picotron's angle origin,
-- and 29/360 to compensate for OkLab weird position of
-- the red color.
local angle_correction = 0.25 + 0.08


local function hs_coords(c)
	local hue = pal_okhsl[c].h
	local sat = mid(0.0, pal_okhsl[c].s, 1.0)
--	sat = ((sat * 3.0) / 4.0) + 0.25
	local a = angle_correction - hue
	local dx = sat * cos(a) * (circle_inner / 2)
	local dy = sat * sin(a) * (circle_inner / 2)
	local x = circle_border + (circle_inner / 2) + dx
	local y = circle_border + (circle_inner / 2) + dy
	return x, y
end


local function h_coords(c, radius_delta, hue_delta)
	local r = circle_inner + (radius_delta or 0)
	local hue = pal_okhsl[c].h + (hue_delta or 0)
	local a = angle_correction - hue
	local dx = cos(a) * (r / 2)
	local dy = sin(a) * (r / 2)
	local x = circle_border + (circle_inner / 2) + dx + 0.5
	local y = circle_border + (circle_inner / 2) + dy + 0.5
	return x, y
end


local function coords_hs(x, y)
	local dx = x - (circle_border + (circle_inner / 2))
	local dy = y - (circle_border + (circle_inner / 2))
	local hue = -atan2(dx, dy) + angle_correction
	dx = (2.0 * dx) / circle_inner
	dy = (2.0 * dy) / circle_inner
	local sat = sqrt(dx * dx + dy * dy) -- / (circle_inner / 2)
	return hue, sat
end


--local function coords_h(x, y)
--	local s = circle_size + 2 * circle_border
--	local r = s - 6
--	local dx = x - ((s / 2) + 0.5)
--	local dy = y - ((s / 2) + 0.5)
--	local hue = -atan2(dx, dy) + angle_correction
--	dx = (2.0 * dx) / r
--	dy = (2.0 * dy) / r
--	local sat = sqrt(dx * dx + dy * dy)
--	return hue, sat
--end


---------------------------------------------------------------------------------------


function create_hue_sat_picker(el)
	el.width = circle_size
	el.height = circle_size
	el.drag_delta = nil
	
	function el:draw()
--		rectfill(0, 0, self.width, self.height, 6)
--		clip()
		oval(
			circle_border - 1, circle_border - 1,
			circle_border + circle_inner + 1, circle_border + circle_inner + 1,
			outline_color()
		)
		line(circle_size \ 2 - 12, circle_size \ 2, circle_size \ 2 + 12, circle_size \ 2, outline_color())
		line(circle_size \ 2, circle_size \ 2 - 12, circle_size \ 2, circle_size \ 2 + 12, outline_color())
--		fillp(0b0101101001011010)
--		rectfill(circle_size \ 2 - 24, circle_size \ 2, circle_size \ 2 + 24, circle_size \ 2, 7)
--		rectfill(circle_size \ 2, circle_size \ 2 - 24, circle_size \ 2, circle_size \ 2 + 24, 7)
--		fillp()
--		local small = (circle_inner * 3.0) / 8.0 + 1
--		oval(
--			circle_border - 1 + small, circle_border - 1 + small,
--			circle_border + circle_inner + 1 - small, circle_border + circle_inner + 1 - small,
--			outline_color()
--		)
		for c = 0, 63 do
			if not hidden[c] and pal_okhsl[c].l != 0 then
				local x, y = hs_coords(c)
				ovalfill(x - 3, y - 3, x + 3, y + 3, c)
			end
		end
		if active_color and not hidden[active_color] then
			-- Triangular knob
			local ax, ay = h_coords(active_color, 6, 0.0)
			local bx, by = h_coords(active_color, 24, -0.008)
			local cx, cy = h_coords(active_color, 24, 0.008)
			pal(7, outline_color())
			line(ax, ay, bx, by, 7)
			line(bx, by, cx, cy, 7)
			line(cx, cy, ax, ay, 7)
			pal(7)
			-- Active dot
			local x, y = hs_coords(active_color)
			pal(7, whitest_color)
			pal(14, active_color)
			spr(
				self.drag_delta and 12 or 11,
				x - 5, y - 5
			)
			pal(14, 14)
			pal(7, 7)
		end
		clip()
		pal(7, outline_color())
		spr(13, 0, 138)
		pal(7, 7)
	end	
	
	function el:hover(msg)
		if (not active_color) or hidden[active_color] then return end
		self.cursor = 1
		local h, r = coords_hs(msg.mx, msg.my)
		local dh = h - pal_okhsl[active_color].h
		if dh < -0.5 then dh += 1.0 end
		if
			r >= 1.02 and r <= 1.18
			and abs(dh) <= 0.01
		then
			self.cursor = "grab"
			return false
		else
			local ax, ay = hs_coords(active_color)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx <= 5 and dy <= 5 then
				self.cursor = "grab"
			end
		end
		return true
	end
	
	function el:click(msg)
		local h, r = coords_hs(msg.mx, msg.my)
		local active_hue = active_color and pal_okhsl[active_color].h or 0
		local dh = h - active_hue
		if dh < -0.5 then dh += 1.0 end
		if
			(active_color and not hidden[active_color])
			and r >= 1.02 and r <= 1.18
			and abs(dh) <= 0.01
		then
			undo_stack:checkpoint()
			self.knob_drag_delta = h - active_hue
			return true
		elseif active_color and not hidden[active_color] then
			local ax, ay = hs_coords(active_color)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx <= 5 and dy <= 5 then
				undo_stack:checkpoint()
				self.drag_delta = { x = ax - msg.mx, y = ay - msg.my }
				return true
			end
		end
		active_color = nil
		-- In reverse order to prioritize colors on top
		for c = 63, 0, -1 do
			local cx, cy = hs_coords(c)
			local dx = abs(cx - msg.mx)
			local dy = abs(cy - msg.my)
			if dx <= 3 and dy <= 3 and not hidden[c] and pal_okhsl[c].l != 0 then
				undo_stack:checkpoint()
				active_color = c
				self.drag_delta = { x = cx - msg.mx, y = cy - msg.my }
				self.cursor = "grab"
				return true
			end
		end
		self.knob_drag_delta = nil
		self.drag_delta = nil
		return true
	end
	
	function el:drag(msg)
		if not active_color then return end
		if locked[active_color] then
			padlock_flashing = true
			return
		end
		if self.knob_drag_delta then
			local h, _ = coords_hs(msg.mx, msg.my)
			local hue = h - self.knob_drag_delta
			change_color(active_color, hue, nil, nil)
		elseif self.drag_delta then
			local ax = msg.mx + self.drag_delta.x
			local ay = msg.my + self.drag_delta.y
			local hue, sat = coords_hs(ax, ay)
			change_color(active_color, hue, sat, nil)
			return true
		end
	end
	
	function el:release(msg)
		send_palette()
		self.knob_drag_delta = nil
		self.drag_delta = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end

	return el
end


-------------------------------------------------------------------------------------


function create_sat_lum_picker(el)
	el.width = square_size
	el.height = square_size
	el.drag_delta = nil
		
	function el:draw()
--		rectfill(0, 0, self.width, self.height, 6)
		rect(
			square_border - 1, square_border - 1, 
			square_border + square_inner + 1, square_border + square_inner + 1, 
			outline_color()
		)
		for c = 0, 63 do
			local dh = pal_okhsl[c].h - pal_okhsl[active_color or 0].h
			if dh < -0.5 then dh += 1.0 end
			if not hidden[c] and pal_okhsl[c].l != 0 then -- and abs(dh) <= 0.1 then
				local x, y = sl_coords(c)
				ovalfill(x - 3, y - 3, x + 3, y + 3, c)
			end
		end
		if active_color and not hidden[active_color] then
			local x, y = sl_coords(active_color)
			pal(7, whitest_color)
			pal(14, active_color)
			spr(
				self.drag_delta and 12 or 11,
				x - 5, y - 5,
				x + 5, y + 5
			)
			pal(14, 14)
			pal(7, 7)
		end
		clip()
		pal(7, outline_color())
		spr(14, -11, self.height + 12 - 64)
		pal(7, 7)
	end	
	
	function el:hover(msg)
		if active_color and not hidden[active_color] then
			local ax, ay = sl_coords(active_color)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx < 6 and dy < 6 then
				self.cursor = "grab"
			else
				self.cursor = 1
			end
		end
	end
	
	function el:click(msg)
		if active_color and not hidden[active_color] then
			local ax, ay = sl_coords(active_color)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx < 6 and dy < 6 then
				undo_stack:checkpoint()
				self.drag_delta = { x = ax - msg.mx, y = ay - msg.my }
				return
			end
		end
		active_color = nil
		-- In reverse order to prioritize colors on top
		for c = 63, 0, -1 do
			local cx, cy = sl_coords(c)
			local dx = abs(cx - msg.mx)
			local dy = abs(cy - msg.my)
			if dx < 3 and dy < 3 and not hidden[c] and pal_okhsl[c].l != 0 then
				undo_stack:checkpoint()
				active_color = c
				self.drag_delta = { x = cx - msg.mx, y = cy - msg.my }
				self.cursor = "grab"
				return
			end
		end
		self.drag_delta = nil
	end
	
	function el:drag(msg)
		if (not active_color) return
		if (not self.drag_delta) return
		if locked[active_color] then
			padlock_flashing = true
		else
			local ax = msg.mx + self.drag_delta.x
			local ay = msg.my + self.drag_delta.y
			local sat, lum = coords_sl(ax, ay)
			change_color(active_color, nil, sat, lum)
		end
	end
	
	function el:release(msg)
		send_palette()
		self.drag_delta = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end

	return el
end


------------------------------------------------------------------------------------


function create_sat_knob(el)
	el.width = square_size
	el.height = 9
	
	function el:draw()
--		clip()
--		for c = 0, 63 do
--			if not hidden[c] and pal_okhsl[c].l != 0 then
--				local ax, _ = sl_coords(c)
--				line(ax, 0, ax, self.height - 9, c)
--			end
--		end
		if active_color and not hidden[active_color] then
			local ax, _ = sl_coords(active_color)
			pal(7, outline_color())
			pal(13, active_color)
			spr(5, ax - 4, 0)
			pal(13, 13)
			pal(7, 7)
		end
	end	
	
	function el:hover(msg)
		if active_color and not hidden[active_color] then
			local ax, _ = sl_coords(active_color)
			if msg.mx and msg.mx >= ax - 4 and msg.mx <= ax + 4 then
				self.cursor = "grab"
			else
				self.cursor = 1
			end
		end
	end

	function el:click(msg)
		undo_stack:checkpoint()
		if active_color and not hidden[active_color] then
			local ax, _ = sl_coords(active_color)
			if msg.mx and msg.mx >= ax - 4 and msg.mx <= ax + 4 then
				self.drag_delta_x = ax - msg.mx
			end
		end
	end
	
	function el:drag(msg)
		if (not active_color) return
		if (not self.drag_delta_x) return
		if locked[active_color] then
			padlock_flashing = true
		else
			local ax = msg.mx + self.drag_delta_x
			local sat, lum = coords_sl(ax, 0)
			change_color(active_color, nil, sat, nil)
		end
	end
	
	function el:release(msg)
		send_palette()
		self.drag_delta_x = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end
			
	return el
end


--------------------------------------------------------------------------------


function create_lum_knob(el)
	el.width = 9
	el.height = square_size
	
	function el:draw()
--		clip()
--		for c = 0, 63 do
--			if not hidden[c] and pal_okhsl[c].l != 0 then
--				local _, ay = sl_coords(c)
--				line(9, ay, self.width, ay, c)
--			end
--		end
		if active_color and not hidden[active_color] then
			local _, ay = sl_coords(active_color)
			pal(7, outline_color())
			pal(13, active_color)
			spr(6, 0, ay - 4)
			pal(13, 13)
			pal(7, 7)
		end
	end	
	
	function el:hover(msg)
		if active_color and not hidden[active_color] then
			local _, ay = sl_coords(active_color)
			if msg.my and msg.my >= ay - 4 and msg.my <= ay + 4 then
				self.cursor = "grab"
			else
				self.cursor = 1
			end
		end
	end

	function el:click(msg)
		undo_stack:checkpoint()
		if active_color and not hidden[active_color] then
			local _, ay = sl_coords(active_color)
			if msg.my and msg.my >= ay - 4 and msg.my <= ay + 4 then
				self.drag_delta_y = ay - msg.my
			end
		end
	end
	
	function el:drag(msg)
		if (not active_color) return
		if (not self.drag_delta_y) return
		if locked[active_color] then
			padlock_flashing = true
		else
			local ay = msg.my + self.drag_delta_y
			local sat, lum = coords_sl(0, ay)
			change_color(active_color, nil, nil, lum)
		end
	end
	
	function el:release(msg)
		send_palette()
		self.drag_delta_y = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end
			
	return el
end

:: src/gui_palette.lua
--[[pod_format="raw",created="2025-02-28 10:09:19",modified="2025-03-11 12:47:46",revision=2956]]
function generate_palette_gui()
	gui.tap = function(self, msg) if (msg.has_pointer) active_color = nil end
	local pal_el = create_palette{ x = 16, y = 6 }
	gui:attach(pal_el)
	gui:attach(create_visibility_buttons { x = pal_el.x - 14, y = pal_el.y + 1 })
	gui:attach(create_color_preview { x = pal_el.x + pal_el.width + 8, y = pal_el.y })
	gui:attach(create_test_zone { x = 390, y = 4 })
	
	if user_settings.new_interface then
		gui:attach(create_hue_mode_switch { x = 346, y = 42 })
		if hue_mode == "hue+sat" then
			gui:attach(create_hue_sat_picker { x = 0, y = 56 })
			local right = gui:attach(create_sat_lum_picker{ x = 196, y = 270 - 190 - 24, abscissa = "s" })
			gui:attach(create_sat_knob { x = right.x, y = right.y + right.height - 3 })
			gui:attach(create_lum_knob { x = right.x - 5, y = right.y })
		else
			gui:attach(create_rectangle_picker { x = 11, y = 56 })
			gui:attach(create_rectangle_picker { x = 11, y = 148, ordinate = "s" })
			gui:attach(create_val_knob { x = 6, y = 56, ordinate = "l" })
			gui:attach(create_val_knob { x = 6, y = 148, ordinate = "s" })
			gui:attach(create_hue_knob { x = 11, y = 243 })
		end
	else
		gui:attach(create_hue_mode_switch { x = 300, y = 54 })
		if hue_mode == "hue+sat" then
			local h_slider = create_hue_slider{ x = 6, y = 68 }
			gui:attach(h_slider)
			h_slider:attach(create_hue_sat_slider { x = slider_border, y = slider_border })
			local sl_slider = create_sat_lum_slider{ x = 200 + 16, y = 66 }
			local s_slider = create_sat_slider { x = sl_slider.x, y = sl_slider.y + sl_slider.height }
			local l_slider = create_lum_slider { x = sl_slider.x - 16, y = sl_slider.y }
			gui:attach(s_slider)
			gui:attach(l_slider)
			gui:attach(sl_slider)
		elseif hue_mode == "hue+lum" then
			local hl_slider = create_hue_lum_slider{ x = 6 + 16, y = 66 }
			local h_slider = create_sat_slider { x = hl_slider.x, y = hl_slider.y + hl_slider.height }
			local l_slider = create_lum_slider { x = hl_slider.x - 16, y = hl_slider.y }
			gui:attach(h_slider)
			gui:attach(l_slider)
			gui:attach(hl_slider)
			local s_slider = create_vertical_sat_slider { x = 356, y = hl_slider.y }
			gui:attach(s_slider)
		end
	end

	local x_buttons = 346
	gui:attach(create_action_button { x = x_buttons, y = 4, sprite = 16,
		act = function(self) undo_stack:undo() end,
		active = function(self) return #(undo_stack.undo_stack) >= 1 end })
	gui:attach(create_action_button { x = x_buttons + 16 + 2, y = 4, sprite = 19,
		act = function(self) undo_stack:redo() end,
		active = function(self) return #(undo_stack.redo_stack) >= 1 end })
	gui:attach(create_action_button { x = x_buttons, y = 4 + 16 + 2, sprite = 24,
		act = function(self) open_settings() end })
	gui:attach(create_action_button { x = x_buttons + 16 + 2, y = 4 + 16 + 2, sprite = 27,
		act = function(self) open_help() end })
end


-------------------------------------------------------------------------------

	
function toggle_hidden(c)
	local nb_columns <const> = 16
	local row = c // nb_columns
	hidden[c] = not hidden[c]
	if hidden[c] then
		local all_hidden = true
		for i = 0, nb_columns - 1 do
			if not hidden[(row * nb_columns) + i] then
				all_hidden = false
			end
		end
		if all_hidden then
			hidden_toggles[row] = true
		end
	else
		hidden_toggles[row] = false
	end
	dont_blink()
end


-----------------------------------------------------------------------------------


function create_palette(el)
	local size = 12
	local nb_columns = 16
	local nb_rows = 4
	el.width = (nb_columns * size) + 1
	el.height = (nb_rows * size) + 1

	function el:draw(msg)
		clip()
		rect(0, 0, self.width, self.height, outline_color())
		for c = 0, 63 do
			local x = 1 + ((c % nb_columns) * size)
			local y = 1 + ((c \ nb_columns) * size)
			rectfill(x, y, x + size - 1, y + size - 1, c)
			if hidden[c] then
				ovalfill(
					x + 2, y + 2,
					x + size - 3, y + size - 3,
					0
				)
			end
			if c == active_color then
				rect(
					x + 1, y + 1,
					x + size - 2, y + size - 2,
					contrast_color(active_color)
				)
			end
		end	
		if self.drag_pos then
			local col = (msg.mx - 1) \ size
			local row = (msg.my - 1) \ size
			local c = col + row * nb_columns
			if 0 <= c and c <= 63 then
				local x = 1 + col * size
				local y = 1 + row * size
				if c != active_color and not locked[c] then
					oval(
						x + 2, y + 2,
						x + size - 3, y + size - 3,
						contrast_color(c)
					)
				end
			end
			local mx, my = self.drag_pos.x, self.drag_pos.y
			rectfill(mx, my, mx + 8, my + 8, active_color)		
		end
	end

	function el:click(msg)
		local col = min(nb_columns - 1, (msg.mx - 1) \ size)
		local row = min(nb_rows - 1, (msg.my - 1) \ size)
		local c = col + row * nb_columns
		if msg.mb == 1 then
			active_color = c
			self.click_pos = { x = msg.mx, y = msg.my }
		elseif msg.mb == 2 then
			toggle_hidden(c)
		end
	end
	
	function el:drag(msg)
		if self.click_pos and not self.drag_pos then
			local dx = abs(self.click_pos.x - msg.mx)
			local dy = abs(self.click_pos.y - msg.my)
			if dx > 1 or dy > 1 then
				if locked[active_color] then
					padlock_flashing = true
				else
					self.drag_pos = {}
				end
			end
		end
		if self.drag_pos then
			self.drag_pos = { x = msg.mx, y = msg.my }
		end
	end
	
	function el:release(msg)
		if self.drag_pos then
			local col = (msg.mx - 1) \ size
			local row = (msg.my - 1) \ size
			local c = col + row * nb_columns
			if 0 <= c and c <= 63 and not locked[c] then
				undo_stack:checkpoint()
				swap_colors(active_color, c)
				active_color = c
				send_palette()
			end			
		end
		self.click_pos = nil
		self.drag_pos = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end

	return el
end


local blink_anim <const> = { [0] = 40, 41, 42, 43, 43, 43, 42, 41, 40 }


function create_visibility_buttons(el)
	local size = 12
	local nb_rows = 4
	el.width = size
	el.height = nb_rows * size
	el.cursor = "pointer"
	

	function el:draw(msg)
		pal(7, outline_color())
		for row = 0, 3 do
			if hidden_toggles[row] then
				spr(43, 0, row * size)
			else
				local sprite = 40
				if blink_timer <= 0 and blink_eye == row then
					sprite = blink_anim[- blink_timer] 
				end
				spr(sprite, 0, row * size)
			end
		end
		pal(7, 7)
	end
	
	function el:update(msg)
		if not user_settings.dont_blink then
			blink_timer -= 1
			if blink_timer <= -9 then
				blink_timer = 180 + math.random(1, 6) * 90
				local nb_eyes = active_color and 4 or 3
				blink_eye = math.random(0, nb_eyes)
				if hidden_toggles[blink_eye] then
					blink_eye = math.random(0, nb_eyes)
				end
			end
		end
	end
	
	function el:tap(msg)
		local row = mid(0, msg.my \ size, 3)
		hidden_toggles[row] = not hidden_toggles[row]
		for c = row * 16, row * 16 + 15 do
			hidden[c] = hidden_toggles[row]
		end
		dont_blink()
	end
	
	return el
end


function dont_blink()
	local all_eyes_closed = true
	for i = 0, 3 do
		if not hidden_toggles[i] then all_eyes_closed = false end
	end
	if all_eyes_closed then
		crying_a_timer = 40
	end
end


function blinked()
	if user_settings.dont_blink then
		return
	end
	pal(1, 0)
	if crying_a_timer > 20 then
		spr(254, 0, 0)
	elseif crying_a_timer > 0 then
		spr(255, 0, -16)
	end
	pal(1, 1)
end


------------------------------------------------------------------------------


function create_color_preview(el)
	local size = 12
	el.width = size * 4 + 2 + 120
	el.height = size * 4 + 2
	
	function el:draw(msg)
		if active_color then
			---rect(0, 0, self.height - 1, self.height - 1, 0)
			rectfill(1, 1, self.height - 2, self.height - 2, active_color)
			print(string.format("%d", active_color), 4, 4, contrast_color(active_color))
			local c = get_color(active_color)
--			print("#" .. color_to_hex(c), 7, self.height - 10, contrast_color(active_color))
			pal(7, outline_color())
			if locked[active_color] then
				if padlock_flashing_time % 18 < 10 then
					spr(2, self.height + 4, 1)
				end
			else
				spr(1, self.height + 4, 1)
			end
			if hidden[active_color] then
				spr(43, self.height + 4 + size, 1)
			else
				local sprite = 40
				if blink_timer <= 0 and blink_eye == 4 then
					sprite = blink_anim[- blink_timer] 
				end
				spr(sprite, self.height + 4 + size, 1)
			end
			if bg_color == active_color then
				spr(10, self.height + 4 + 2 * size, 1)
			else
				spr(9, self.height + 4 + 2 * size, 1)
			end
			pal(7, 7)
			local hue = pal_okhsl[active_color].h * 360.0
			while hue < 0.0 do
				hue += 360.0
			end
			print("\014       hue: ", self.height + 5, 18, outline_color()) -- .. string.format("%3.0f", hue) .. "\031", self.height + 5, 24, outline_color())
			print("\014saturation: ", self.height + 5, 27) -- .. string.format("%3.0f", pal_okhsl[active_color].s * 100.0) .. "%", self.height + 5, 33)
			print("\014 luminance: ", self.height + 5, 36) -- .. string.format("%3.0f", pal_okhsl[active_color].l * 100.0) .. "%", self.height + 5, 42)
		else
			print("\^pOkPal" .. "\^-p\014\|o " .. okpal_version, 24, 0, outline_color())
			print("\014\|b\-g(press f1 for help)")
		end
	end
	
	function el:tap(msg)
		if (not active_color) return
		if msg.mx < self.height or msg.my > size then
			return
		elseif msg.mx < self.height + 4 + size then
			locked[active_color] = not locked[active_color]
		elseif msg.mx < self.height + 4 + 2 * size then
			hidden[active_color] = not hidden[active_color]
		elseif msg.mx < self.height + 4 + 3 * size then
			if key("shift") and bg_color != active_color then
				whitest_color = active_color
			elseif key("ctrl") then
				blackest_color = active_color
			elseif bg_color == active_color then
				bg_color = blackest_color
			else
				bg_color = active_color
			end
		end
	end
	
	function el:hover(msg)
		if msg.has_pointer and msg.mx >= self.height + 4 and msg.mx <= self.height + 4 + 3 * size and msg.my <= size then
			self.cursor = "pointer"
		else
			self.cursor = 1
		end
	end

	gui:new(el)
	
	-- Input field for the color code
	el:attach(create_field {
		x = 5, y = el.height - 12,
		width = 40, height = 9,
		small_font = false,
		get_fg = function(self) return contrast_color(active_color or 0) end,
		get = function(self)
			if (not active_color) return ""
			return "#" .. color_to_hex(get_color(active_color))
		end,
		set = function(self, str)
			if (locked[active_color]) return
			str = str:gsub("%s", ""):gsub("#", "")
			if (#str ~= 6) return
			local code = tonum("0x" .. str)
			if (type(code) ~= "number") return
			undo_stack:checkpoint()
			change_color_code(active_color, code)
		end,
		update = function(self, msg)
			self.hidden = active_color == nil
		end
	})

	-- Input field for hue
	el:attach(create_field {
		x = 100, y = 17,
		width = 20, height = 7,
		small_font = true,
		get_fg = function(self) return outline_color() end,
		get = function(self)
			if (not active_color) return ""
			local hue = pal_okhsl[active_color].h * 360.0
			while hue < 0.0 do
				hue += 360.0
			end
			return string.format("%3.0f\031", hue)
		end,
		set = function(self, str)
			if (locked[active_color]) return
			str = str:gsub("%s", ""):gsub("\031", "")
			local hue = tonum(str)
			if (type(hue) ~= "number") return
			hue = (hue % 360.0) / 360.0
			undo_stack:checkpoint()
			change_color(active_color, hue, nil, nil)
		end,
		update = function(self, msg)
			self.hidden = active_color == nil
		end
	})

	-- Input field for saturation
	el:attach(create_field {
		x = 100, y = 26,
		width = 20, height = 7,
		small_font = true,
		get_fg = function(self) return outline_color() end,
		get = function(self)
			if (not active_color) return ""
			local sat = pal_okhsl[active_color].s * 100.0
			return string.format("%3.0f%%", sat)
		end,
		set = function(self, str)
			if (locked[active_color]) return
			str = str:gsub("%s", ""):gsub("%%", "")
			local sat = tonum(str)
			if (type(sat) ~= "number") return
			sat = sat / 100.0
			undo_stack:checkpoint()
			change_color(active_color, nil, sat, nil)
		end,
		update = function(self, msg)
			self.hidden = active_color == nil
		end
	})

	-- Input field for luminance
	el:attach(create_field {
		x = 100, y = 35,
		width = 20, height = 7,
		small_font = true,
		get_fg = function(self) return outline_color() end,
		get = function(self)
			if (not active_color) return ""
			local lum = pal_okhsl[active_color].l * 100.0
			return string.format("%3.0f%%", lum)
		end,
		set = function(self, str)
			if (locked[active_color]) return
			str = str:gsub("%s", ""):gsub("%%", "")
			local lum = tonum(str)
			if (type(lum) ~= "number") return
			lum = lum / 100.0
			undo_stack:checkpoint()
			change_color(active_color, nil, nil, lum)
		end,
		update = function(self, msg)
			self.hidden = active_color == nil
		end
	})
	
	return el
end


---------------------------------------------------------------------------------


function create_hue_mode_switch(el)
	el.width = get_spr(36):width()
	el.height = get_spr(36):height()
	el.cursor = "pointer"
	function el:draw(msg)
		pal(7, outline_color())
		spr(hue_mode == "hue+sat" and 36 or 37, 0, 0)
		pal(7)
	end
	function el:tap(msg)
		if hue_mode == "hue+sat" then
			hue_mode = "hue+lum"
		else
			hue_mode = "hue+sat"
		end
		gui_changed = true
	end
	return el
end


---------------------------------------------------------------------------------


function create_test_zone(el)
	el.width = (24 + 4) * 3
	el.height = 12 + (24 + 4) * 8 + 15
	el.cursor = "pointer"
	el.cubes = {}
	el.ramps = nil

	function el:draw()
		pal(7, outline_color())
		if test_mode == "cubes" then
			spr(34, 0, 0)
		elseif test_mode == "ramps" then
			spr(35, 0, 0)
		end
		pal(7, 7)
	end
	
	function el:click(msg)
		if msg.my > 12 then
			return
		end
		if test_mode == "cubes" and msg.mx > 33 then
			test_mode = "ramps"
			for c in all(self.cubes) do
				c.hidden = true
			end
			self.ramps.hidden = false
		elseif test_mode == "ramps" and msg.mx < 33 then
			test_mode = "cubes"
			for c in all(self.cubes) do
				c.hidden = false
			end
			self.ramps.hidden = true
		end
	end
	
	function el:mousewheel(msg)
		if active_color and msg.wheel_y < 0 then
			active_color = (active_color + 1) % 64
		elseif active_color and msg.wheel_y > 0 then
			active_color = (active_color - 1) % 64
		end
	end
	
	gui:new(el)
	
	for i = 0, 2 do
		for j = 0, 7 do
			el.cubes[#el.cubes + 1] =
				el:attach(create_test_cube { x = i * 28, y = 12 + j * 28, test_id = i + 3 * j })
		end
	end
	
	el.ramps = el:attach(create_test_ramps { x = 0, y = 12, hidden = test_mode ~= "ramps" })

	el:attach(create_action_button { x = 54, y = 238, sprite = 32,
		act =
			function(self)
				undo_stack:checkpoint()
				if test_mode == "cubes" then
					clear_cube_colors()
				elseif test_mode == "ramps" then
					clear_ramp_colors()
				end
			end })

	return el
end


function create_test_cube(el)
	el.width = 24 + 4
	el.height = 24 + 4
	el.hidden = test_mode ~= "cubes"

	function el:draw()
		local colors = test_cube_colors[self.test_id]
		pal(10, colors[1])
		pal(9, colors[2])
		pal(25, colors[3])
		spr(8, 2, 2)
		pal(10, 10)
		pal(9, 9)
		pal(25, 25)
	end
	
	function el:hover(msg)
		if msg.mx > 2 and msg.my > 2 and msg.mx < self.width - 2 and msg.my < self.height - 2 then
			el.cursor = "crosshair"
		else
			el.cursor = 1
		end
	end
	
	function el:click(msg)
		local face = 2
		if msg.mx > self.width - 10 or msg.my < 10 then
			if msg.mx > self.height - msg.my then
				face = 3
			else
				face = 1
			end
		end
		if msg.mb == 1 then
			undo_stack:checkpoint()
			test_cube_colors[self.test_id][face] = active_color or 1
		elseif msg.mb == 2 then
			active_color = test_cube_colors[self.test_id][face]
		end
	end
	
	return el
end


function create_test_ramps(el)
	el.width = (24 + 4) * 3
	el.height = (24 + 4) * 8
	
	function el:square_of(x, y)
		if x < 2 or x > self.width - 2 or y <= 4 or y >= self.height - 4 then
			return nil, nil
		end
		local i = mid(0, (x - 2) // 8, 9)
		local j = mid(0, (y - 4) // 8, 26)
		return i, j
	end

	function el:draw(msg)
--		rectfill(0, 0, self.width, self.height, 8)
		for i = 0, 9 do
			for j = 0, 26 do
				local x = 2 + i * 8
				local y = 4 + j * 8
				local c = test_ramp_colors:get(i, j)
				rectfill(x, y, x + 7, y + 7, c)
			end
		end
		local i, j = self:square_of(msg.mx, msg.my)
		if i then
			local x = 2 + i * 8
			local y = 4 + j * 8
			local c = test_ramp_colors:get(i, j)
			if c == 0 then
				rect(x, y, x + 7, y + 7, contrast_color(c))
			end
		end
	end
	
	function el:hover(msg)
		local i, j = self:square_of(msg.mx, msg.my)
		if i then
			el.cursor = "crosshair"
		else
			el.cursor = 1
		end
	end
	
	function el:click(msg)
		local  i, j = self:square_of(msg.mx, msg.my)
		if (not i) return
		if msg.mb == 1 then
			undo_stack:checkpoint()
			test_ramp_colors:set(i, j, active_color)
		elseif msg.mb == 2 then
			active_color = mid(0, test_ramp_colors:get(i, j), 63)
		elseif msg.mb == 4 then
			test_ramp_colors:set(i, j, 0)
		end
	end

	return el
end
:: src/gui_settings.lua
--[[pod_format="raw",created="2025-02-28 11:31:28",modified="2025-03-10 15:52:22",revision=1239]]
function open_settings()
	local el = open_modal(220, 170, true)
	el:attach(create_label { x = 90, y = 6, label = "Settings", fg = bg_color })
	
	local default_apps = get_default_apps()
	el:attach(create_label {
		x = 10, y = 30,
		label = "Default apps for \".pal\" and \".hex\" files:",
		fg = bg_color,
	})
	local pal_path = el:attach(create_label {
		x = 50, y = 50, width = 220 - 50,
		label = "pal: " .. default_apps.pal,
		fg = bg_color,
	})
	el:attach(create_button {
		x = 16, y = 46,
		label = "set",
		fg = bg_color,
		act =
			function(self)
				set_default_apps("pal")
				pal_path.label = "pal: set to " .. env().argv[0]
			end
	})
	local hex_path = el:attach(create_label {
		x = 50, y = 70, width = 220 - 50,
		label = "hex: " .. default_apps.hex,
		fg = bg_color,
	})
	el:attach(create_button {
		x = 16, y = 66,
		label = "set",
		fg = bg_color,
		act =
			function(self)
				set_default_apps("hex")
				hex_path.label = "hex: set to " .. env().argv[0]
			end
	})
	
	el:attach(create_checkbox {
		x = 10, y = 100,
		label = "Send palette to sprite and map editors",
		fg = bg_color,
		get = function(self) return user_settings.send_palette end,
		toggle = function(self) change_settings { send_palette = not user_settings.send_palette } end,
	})
	if key("shift") then
		el:attach(create_checkbox {
			x = 10, y = 120,
			label = "Don't blink!",
			fg = bg_color,
			get = function(self) return user_settings.dont_blink end,
			toggle = function(self) change_settings { dont_blink = not user_settings.dont_blink } end,
		})
	end
	
	el:attach(create_button {
		x = 170, y = 150,
		label = "Close",
		fg = bg_color,
		act = function() close_modal() end,
	})
end
:: src/gui_sliders.lua
--[[pod_format="raw",created="2024-04-05 07:49:07",modified="2025-03-11 11:59:03",revision=2182]]
local slider_size = 170
local slider_border = 6
local slider_inner = slider_size - 2 * slider_border


------------------------------------------------------------------------------------



local function sl_coords(c)
	local sat = pal_okhsl[c].s
	local lum = pal_okhsl[c].l
	local x = slider_border + sat * slider_inner
	local y = slider_border + slider_inner - lum * slider_inner
	return x, y
end


local function coords_sl(x, y)
	local sat = (x - slider_border) / slider_inner
	local lum = 1.0 - ((y - slider_border) / slider_inner)
	return sat, lum
end


local function hl_coords(c)
	local hue = pal_okhsl[c].h
	local lum = pal_okhsl[c].l
	local x = slider_border + hue * slider_inner * 2
	local y = slider_border + slider_inner - lum * slider_inner
	return x, y
end


local function coords_hl(x, y)
	local hue = (x - slider_border) / (2 * slider_inner)
	local lum = 1.0 - ((y - slider_border) / slider_inner)
	return hue, lum
end


local function s_coordsy(c)
	local sat = pal_okhsl[c].s
	local y = slider_border + slider_inner - sat * slider_inner
	return y
end


local function coordsy_s(y)
	local sat = 1.0 - ((y - slider_border) / slider_inner)
	return sat
end


-- Remove 0.25 to compensate for Picotron's angle origin,
-- and 29/360 to compensate for OkLab weird position of
-- the red color.
local angle_correction = 0.25 + 0.08


local function hs_coords(c)
	local hue = pal_okhsl[c].h
	local sat = mid(0.0, pal_okhsl[c].s, 1.0)
	local a = angle_correction - hue
	local dx = sat * cos(a) * (slider_inner / 2)
	local dy = sat * sin(a) * (slider_inner / 2)
	local x = slider_border + (slider_inner / 2) + dx
	local y = slider_border + (slider_inner / 2) + dy
	return x, y
end


local function coords_hs(x, y)
	local dx = x - (slider_border + (slider_inner / 2))
	local dy = y - (slider_border + (slider_inner / 2))
	local hue = -atan2(dx, dy) + angle_correction
	dx = (2.0 * dx) / slider_inner
	dy = (2.0 * dy) / slider_inner
	local sat = sqrt(dx * dx + dy * dy) -- / (slider_inner / 2)
	return hue, sat
end


local function h_coords(c, radius_delta)
	local s = slider_size + 2 * slider_border
	local r = s - slider_border + (radius_delta or 0)
	local hue = pal_okhsl[c].h
	local a = angle_correction - hue
	local dx = cos(a) * (r / 2)
	local dy = sin(a) * (r / 2)
	local x = (s / 2) + dx + 0.5
	local y = (s / 2) + dy + 0.5
	return x, y
end


local function coords_h(x, y)
	local s = slider_size + 2 * slider_border
	local r = s - 6
	local dx = x - ((s / 2) + 0.5)
	local dy = y - ((s / 2) + 0.5)
	local hue = -atan2(dx, dy) + angle_correction
	dx = (2.0 * dx) / r
	dy = (2.0 * dy) / r
	local sat = sqrt(dx * dx + dy * dy)
	return hue, sat
end


-- Hue / saturation slider ----------------------------------------------------------


function create_hue_sat_slider(el)
	el.width = slider_size
	el.height = slider_size
	el.drag_delta = nil
	
	function el:draw()
		clip()
		oval(
			slider_border - 1, slider_border - 1,
			slider_border + slider_inner + 1, slider_border + slider_inner + 1,
			outline_color()
		)
		fillp(0b0101101001011010)
		rectfill(slider_size \ 2 - 24, slider_size \ 2, slider_size \ 2 + 24, slider_size \ 2, 7)
		rectfill(slider_size \ 2, slider_size \ 2 - 24, slider_size \ 2, slider_size \ 2 + 24, 7)
		fillp()
		for c = 0, 63 do
			if not hidden[c] and pal_okhsl[c].l != 0 then
				local x, y = hs_coords(c)
				ovalfill(x - 3, y - 3, x + 3, y + 3, c)
			end
		end
		if active_color and not hidden[active_color] then
			local x, y = hs_coords(active_color)
			pal(7, whitest_color)
			pal(14, active_color)
			spr(
				self.drag_delta and 12 or 11,
				x - 5, y - 5,
				x + 5, y + 5
			)
			pal(14, 14)
			pal(7, 7)
		end
		pal(7, outline_color())
		spr(13, -6, 120)
		pal(7, 7)
	end	
	
	function el:hover(msg)
		if (not msg.mx or not msg.my) return false
		local _, r = coords_hs(msg.mx, msg.my)
		if r > 1.02 then
			return false
		end
		if active_color and not hidden[active_color] then
			local ax, ay = hs_coords(active_color)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx <= 5 and dy <= 5 then
				self.cursor = "grab"
			else
				self.cursor = 1
			end
		end
		return true
	end
	
	function el:click(msg)
		local _, r = coords_hs(msg.mx, msg.my)
		if r > 1.02 then
			return false
		end
		if active_color and not hidden[active_color] then
			local ax, ay = hs_coords(active_color)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx <= 5 and dy <= 5 then
				undo_stack:checkpoint()
				self.drag_delta = { x = ax - msg.mx, y = ay - msg.my }
				return true
			end
		end
		active_color = nil
		-- In reverse order to prioritize colors on top
		for c = 63, 0, -1 do
			local cx, cy = hs_coords(c)
			local dx = abs(cx - msg.mx)
			local dy = abs(cy - msg.my)
			if dx <= 3 and dy <= 3 and not hidden[c] and pal_okhsl[c].l != 0 then
				undo_stack:checkpoint()
				active_color = c
				self.drag_delta = { x = cx - msg.mx, y = cy - msg.my }
				self.cursor = "grab"
				return true
			end
		end
		self.drag_delta = nil
		return true
	end
	
	function el:drag(msg)
		if (not active_color) return
		if (not self.drag_delta) return
		if locked[active_color] then
			padlock_flashing = true
		else
			local ax = msg.mx + self.drag_delta.x
			local ay = msg.my + self.drag_delta.y
			local hue, sat = coords_hs(ax, ay)
			change_color(active_color, hue, sat, nil)
			return true
		end
	end
	
	function el:release(msg)
		send_palette()
		self.drag_delta = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end

	return el
end


------------------------------------------------------------------------------------


function create_hue_lum_slider(el)
	el.width = slider_size * 2
	el.height = slider_size
	el.drag_delta = nil
		
	function el:draw()
		clip()
		rect(
			slider_border - 1, slider_border - 1, 
			slider_border + (slider_inner * 2) + 1, slider_border + slider_inner + 1, 
			outline_color()
		)
		for c = 0, 63 do
			if not hidden[c] and pal_okhsl[c].l != 0 then
				local x, y = hl_coords(c)
				ovalfill(x - 3, y - 3, x + 3, y + 3, c)
			end
		end
		if active_color and not hidden[active_color] then
			local x, y = hl_coords(active_color)
			pal(7, whitest_color)
			pal(14, active_color)
			spr(
				self.drag_delta and 12 or 11,
				x - 5, y - 5,
				x + 5, y + 5
			)
			pal(14, 14)
			pal(7, 7)
		end
		pal(7, outline_color())
		spr(15, -22, 128)
		pal(7, 7)
	end	
	
	function el:hover(msg)
		if active_color and not hidden[active_color] then
			local ax, ay = hl_coords(active_color)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx < 6 and dy < 6 then
				self.cursor = "grab"
			else
				self.cursor = 1
			end
		end
	end
	
	function el:click(msg)
		if active_color and not hidden[active_color] then
			local ax, ay = hl_coords(active_color)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx < 6 and dy < 6 then
				undo_stack:checkpoint()
				self.drag_delta = { x = ax - msg.mx, y = ay - msg.my }
				return
			end
		end
		active_color = nil
		-- In reverse order to prioritize colors on top
		for c = 63, 0, -1 do
			local cx, cy = hl_coords(c)
			local dx = abs(cx - msg.mx)
			local dy = abs(cy - msg.my)
			if dx < 3 and dy < 3 and not hidden[c] and pal_okhsl[c].l != 0 then
				undo_stack:checkpoint()
				active_color = c
				self.drag_delta = { x = cx - msg.mx, y = cy - msg.my }
				self.cursor = "grab"
				return
			end
		end
		self.drag_delta = nil
	end
	
	function el:drag(msg)
		if (not active_color) return
		if (not self.drag_delta) return
		if locked[active_color] then
			padlock_flashing = true
		else
			local ax = msg.mx + self.drag_delta.x
			local ay = msg.my + self.drag_delta.y
			local hue, lum = coords_hl(ax, ay)
			hue = max(0.0, hue)
			change_color(active_color, hue, nil, lum)
		end
	end
	
	function el:release(msg)
		send_palette()
		self.drag_delta = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end

	return el
end


-- Saturation / luminance slider ----------------------------------------------------


function create_sat_lum_slider(el)
	el.width = slider_size
	el.height = slider_size
	el.drag_delta = nil
		
	function el:draw()
		clip()
		rect(
			slider_border - 1, slider_border - 1, 
			slider_border + slider_inner + 1, slider_border + slider_inner + 1, 
			outline_color()
		)
		for c = 0, 63 do
			if not hidden[c] and pal_okhsl[c].l != 0 then
				local x, y = sl_coords(c)
				ovalfill(x - 3, y - 3, x + 3, y + 3, c)
			end
		end
		if active_color and not hidden[active_color] then
			local x, y = sl_coords(active_color)
			pal(7, whitest_color)
			pal(14, active_color)
			spr(
				self.drag_delta and 12 or 11,
				x - 5, y - 5,
				x + 5, y + 5
			)
			pal(14, 14)
			pal(7, 7)
		end
		pal(7, outline_color())
		spr(14, -22, 128)
		pal(7, 7)
	end	
	
	function el:hover(msg)
		if active_color and not hidden[active_color] then
			local ax, ay = sl_coords(active_color)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx < 6 and dy < 6 then
				self.cursor = "grab"
			else
				self.cursor = 1
			end
		end
	end
	
	function el:click(msg)
		if active_color and not hidden[active_color] then
			local ax, ay = sl_coords(active_color)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx < 6 and dy < 6 then
				undo_stack:checkpoint()
				self.drag_delta = { x = ax - msg.mx, y = ay - msg.my }
				return
			end
		end
		active_color = nil
		-- In reverse order to prioritize colors on top
		for c = 63, 0, -1 do
			local cx, cy = sl_coords(c)
			local dx = abs(cx - msg.mx)
			local dy = abs(cy - msg.my)
			if dx < 3 and dy < 3 and not hidden[c] and pal_okhsl[c].l != 0 then
				undo_stack:checkpoint()
				active_color = c
				self.drag_delta = { x = cx - msg.mx, y = cy - msg.my }
				self.cursor = "grab"
				return
			end
		end
		self.drag_delta = nil
	end
	
	function el:drag(msg)
		if (not active_color) return
		if (not self.drag_delta) return
		if locked[active_color] then
			padlock_flashing = true
		else
			local ax = msg.mx + self.drag_delta.x
			local ay = msg.my + self.drag_delta.y
			local sat, lum = coords_sl(ax, ay)
			change_color(active_color, nil, sat, lum)
		end
	end
	
	function el:release(msg)
		send_palette()
		self.drag_delta = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end

	return el
end


-- 1D Sliders ----------------------------------------------------------------------


function create_hue_slider(el)
	el.width = slider_size + 2 * slider_border
	el.height = slider_size + 2 * slider_border

	function el:draw()
		clip()
		for c = 0, 63 do
			if not hidden[c] and pal_okhsl[c].l != 0 then
				cx1, cy1 = h_coords(c, -2)
				cx2, cy2 = h_coords(c, 18)
				line(cx1, cy1, cx2, cy2, c)
			end
		end
		if active_color and not hidden[active_color] then
			local ax, ay = h_coords(active_color)
			pal(7, outline_color())
			pal(13, active_color)
			spr(7, ax - 4, ay - 4)
			pal(13, 13)
			pal(7, 7)
		end
	end	

	function el:hover(msg)
		-- I think there is a bug in Picotron's handling of mouse coords
		-- when one widget is on top of another.
		--[[
		if (not msg.mx or not msg.my) return
		if active_color then
			local ax, ay = h_coords(active_color)
			--printh(string.format("%.0f %.0f - %.0f %.0f", ax, ay, msg.mx, msg.my))
			if
				msg.mx >= ax - 6 and msg.mx <= ax + 6
				and msg.my >= ay - 6 and msg.my <= ay + 6
			then
				self.cursor = "grab"
			else
				self.cursor = 1
			end
		end
		--]]
	end

	function el:click(msg)
		undo_stack:checkpoint()
		if active_color and not hidden[active_color] then
			local ax, ay = h_coords(active_color)
			--[[
			if
				msg.mx >= ax - 6 and msg.mx <= ax + 6
				and msg.my >= ay - 6 and msg.my <= ay + 6
			then
			]]
				self.drag_delta = { x = ax - msg.mx, y = ay - msg.my }
			-- end
		end
	end
	
	function el:drag(msg)
		if (not active_color) return
		if (not self.drag_delta) return
		if locked[active_color] then
			padlock_flashing = true
		else
			local ax = msg.mx + self.drag_delta.x
			local ay = msg.my + self.drag_delta.y
			local hue = coords_h(ax, ay)
			change_color(active_color, hue, nil, nil)
		end
	end
	
	function el:release(msg)
		send_palette()
		self.drag_delta = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end

	return el
end


function create_sat_slider(el)
	el.width = slider_size
	el.height = 16
	
	function el:draw()
		clip()
		for c = 0, 63 do
			if not hidden[c] and pal_okhsl[c].l != 0 then
				local ax, _ = sl_coords(c)
				line(ax, 0, ax, self.height - 9, c)
			end
		end
		if active_color and not hidden[active_color] then
			local ax, _ = sl_coords(active_color)
			pal(7, outline_color())
			pal(13, active_color)
			spr(5, ax - 4, self.height - 9)
			pal(13, 13)
			pal(7, 7)
		end
	end	
	
	function el:hover(msg)
		if active_color and not hidden[active_color] then
			local ax, _ = sl_coords(active_color)
			if msg.mx and msg.mx >= ax - 4 and msg.mx <= ax + 4 and msg.my >= self.height - 9 then
				self.cursor = "grab"
			else
				self.cursor = 1
			end
		end
	end

	function el:click(msg)
		undo_stack:checkpoint()
		if active_color and not hidden[active_color] then
			local ax, _ = sl_coords(active_color)
			if msg.mx and msg.mx >= ax - 4 and msg.mx <= ax + 4 and msg.my >= self.height - 9 then
				self.drag_delta_x = ax - msg.mx
			end
		end
	end
	
	function el:drag(msg)
		if (not active_color) return
		if (not self.drag_delta_x) return
		if locked[active_color] then
			padlock_flashing = true
		else
			local ax = msg.mx + self.drag_delta_x
			local sat, lum = coords_sl(ax, 0)
			change_color(active_color, nil, sat, nil)
		end
	end
	
	function el:release(msg)
		send_palette()
		self.drag_delta_x = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end
			
	return el
end


function create_lum_slider(el)
	el.width = 16
	el.height = slider_size
	
	function el:draw()
		clip()
		for c = 0, 63 do
			if not hidden[c] and pal_okhsl[c].l != 0 then
				local _, ay = sl_coords(c)
				line(9, ay, self.width, ay, c)
			end
		end
		if active_color and not hidden[active_color] then
			local _, ay = sl_coords(active_color)
			pal(7, outline_color())
			pal(13, active_color)
			spr(6, 0, ay - 4)
			pal(13, 13)
			pal(7, 7)
		end
	end	
	
	function el:hover(msg)
		if active_color and not hidden[active_color] then
			local _, ay = sl_coords(active_color)
			if msg.my and msg.my >= ay - 4 and msg.my <= ay + 4 and msg.mx <= 9 then
				self.cursor = "grab"
			else
				self.cursor = 1
			end
		end
	end

	function el:click(msg)
		undo_stack:checkpoint()
		if active_color and not hidden[active_color] then
			local _, ay = sl_coords(active_color)
			if msg.my and msg.my >= ay - 4 and msg.my <= ay + 4 and msg.mx <= 9 then
				self.drag_delta_y = ay - msg.my
			end
		end
	end
	
	function el:drag(msg)
		if (not active_color) return
		if (not self.drag_delta_y) return
		if locked[active_color] then
			padlock_flashing = true
		else
			local ay = msg.my + self.drag_delta_y
			local sat, lum = coords_sl(0, ay)
			change_color(active_color, nil, nil, lum)
		end
	end
	
	function el:release(msg)
		send_palette()
		self.drag_delta_y = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end
			
	return el
end


-----------------------------------------------------------------------------------


function create_vertical_sat_slider(el)
	el.width = 23
	el.height = slider_size
	
	function el:draw()
--		rectfill(0, 0, self.width, self.height, 6)
--		clip()
		for c = 0, 63 do
--			if
--				not hidden[c] and pal_okhsl[c].l != 0
--				and c ~= active_color
--				and active_color
--				and abs(pal_okhsl[active_color].h - pal_okhsl[c].h) < 0.1
--			then
--				local ay = s_coordsy(c)
--				local dx = (pal_okhsl[c].h - pal_okhsl[active_color].h) * 100.0
--				rectfill(self.width//2 + dx - 2, ay - 2, self.width//2 + dx + 2, ay + 2, c)
--			end
			if
				not hidden[c] and pal_okhsl[c].l != 0
				and c ~= active_color
				and active_color
				and abs(pal_okhsl[active_color].h - pal_okhsl[c].h) < 0.1
			then
				local ay = s_coordsy(c)
				if pal_okhsl[c].h < pal_okhsl[active_color].h then
--					line(0, ay, self.width//2 - 3, ay, c)
					rectfill(0, ay-2, 4, ay+2, c)
				elseif pal_okhsl[c].h > pal_okhsl[active_color].h then
--					line(self.width//2 + 3, ay, self.width-1, ay, c)
					rectfill(self.width//2 + 7, ay-2, self.width//2 + 7 + 4, ay + 2, c)
				else
					line(2, ay, self.width - 3, ay, c)
				end
			end
		end
		line(
			self.width // 2, slider_border, 
			self.width // 2, slider_border + slider_inner, 
			outline_color()
		)
		if active_color and not hidden[active_color] then
			local ay = s_coordsy(active_color)
			pal(7, outline_color())
			pal(13, active_color)
			spr(4, 5, ay - 4)
			pal(13, 13)
			pal(7, 7)
		end
		clip()
		pal(7, outline_color())
		spr(23, -8, self.height + 4)
		pal(7)
	end	
	
	function el:hover(msg)
		if active_color and not hidden[active_color] then
			local ay = s_coordsy(active_color)
			if msg.my and msg.my >= ay - 4 and msg.my <= ay + 4
					and msg.mx >= 6 and msg.mx <= self.width - 6 then
				self.cursor = "grab"
			else
				self.cursor = 1
			end
		end
	end

	function el:click(msg)
		undo_stack:checkpoint()
		if active_color and not hidden[active_color] then
			local ay = s_coordsy(active_color)
			if msg.my and msg.my >= ay - 4 and msg.my <= ay + 4
					and msg.mx >= 6 and msg.mx <= self.width - 6 then
				self.drag_delta_y = ay - msg.my
			end
		end
	end
	
	function el:drag(msg)
		if (not active_color) return
		if (not self.drag_delta_y) return
		if locked[active_color] then
			padlock_flashing = true
		else
			local ay = msg.my + self.drag_delta_y
			local sat = coordsy_s(ay)
			change_color(active_color, nil, sat, nil)
		end
	end
	
	function el:release(msg)
		send_palette()
		self.drag_delta_y = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end
			
	return el
end

:: src/integration.lua
--[[pod_format="raw",created="2025-03-08 09:24:27",modified="2025-03-10 15:52:22",revision=269]]
function register_as_default_app()
	local okpal_path = env().argv[0]

	-- Prevent registering the wrong path when
	-- developing OkPal.
	if okpal_path == "/system/apps/terminal.lua" then
		return
	end
	
	if fstat("/system/util/default_app.lua") ~= "file" then
		return
	end

	local default_apps = fetch("/appdata/system/default_apps.pod") or {}
	if default_apps["pal"] == nil then
		create_process(
			"/system/util/default_app.lua",
			{ argv = { "pal", okpal_path } }
		)
	end
	if default_apps["hex"] == nil then
		create_process(
			"/system/util/default_app.lua",
			{ argv = { "hex", okpal_path } }
		)
	end
end


function get_default_apps()
	local result = { pal = "(unknown)", hex = "(unknown)" }

	if fstat("/system/util/default_app.lua") ~= "file" then
		return result
	end

	local default_apps = fetch("/appdata/system/default_apps.pod") or {}
	result.pal = default_apps.pal or "(none)"
	result.hex = default_apps.hex or "(none)"

	return result
end


function set_default_apps(extension)
	local okpal_path = env().argv[0]

	-- Prevent registering the wrong path when
	-- developing OkPal.
	if okpal_path == "/system/apps/terminal.lua" then
		return
	end
	
	if fstat("/system/util/default_app.lua") ~= "file" then
		return
	end

	create_process(
		"/system/util/default_app.lua",
		{ argv = { extension, okpal_path } }
	)
end


-----------------------------------------------------------------------------


function send_palette()
	if not user_settings.send_palette then
		return
	end
	
	local palette = userdata("i32", 64)
	for c = 0, 63 do
		palette:set(c, get_color(c))
	end
	
	-- Updating the PID lists as we're sending the event
	-- to not miss new processes.
	for pid in all(find_gfx_map_pids()) do
		send_message(pid, { event = "set_palette", palette = palette })
	end
end


-- From Eiyeron's fork #eyn_okpal_fork-0
function find_gfx_map_pids()
	local matching_pids = {}
	for process in all(fetch "/ram/system/processes.pod") do
		local name <const> = process.name
		if name == "gfx" or name == "map" then
			matching_pids[#matching_pids + 1] = process.id
		end
	end
	return matching_pids
end


-- Drag-and-drop ------------------------------------------------------------------


function handle_drop_items(msg)
	for i = 1, #msg.items do
		local item = msg.items[i]
		if item.pod_type == "file_reference" and item.attrib == "file" then
--			undo_stack:checkpoint()
--			send_message(pid(), { event = "open_file", filename = item.fullpath })
		local okpal_path = env().argv[0]
		-- Prevent registering the wrong path when
		-- developing OkPal.
		if okpal_path == "/system/apps/terminal.lua" then
			return
		end
		create_process(
			okpal_path,
			{
				argv = { item.fullpath },
			}
		)
		end
	end
end

:: src/oklab.lua
--[[pod_format="raw",created="2024-03-31 09:08:26",modified="2025-03-10 19:14:59",revision=981]]
-- Copyright(c) 2021 Bjorn Ottosson
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of
-- this software and associated documentation files(the "Software"), to deal in
-- the Software without restriction, including without limitation the rights to
-- use, copy, modify, merge, publish, distribute, sublicense, and /or sell copies
-- of the Software, and to permit persons to whom the Software is furnished to do
-- so, subject to the following conditions:
--
-- The above copyright noticeand this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

oklab = {}
oklab.__index = oklab

function oklab.color_to_okhsl(code)
	local srgb = {
		r = ((code & 0xff0000) >> 16) / 255,
		g = ((code & 0x00ff00) >> 8) / 255,
		b = ((code & 0x0000ff)) / 255,
	}
	return oklab.srgb_to_okhsl(srgb)
end

function oklab.okhsl_to_color(okhsl)
	local srgb = oklab.okhsl_to_srgb(okhsl)
	local r = mid(0x00, math.floor(srgb.r * 255 + 0.5), 0xff)
	local g = mid(math.floor(srgb.g * 255 + 0.5), 0xff)
	local b = mid(math.floor(srgb.b * 255 + 0.5), 0xff)
	return (r << 16) | (g << 8) | b
end

function oklab.new()
    local inst = setmetatable({}, oklab)
    return inst
end

-- Finds the maximum saturation possible for a given hue that fits in sRGB
-- Saturation here is defined as S = C/L
-- a and b must be normalized so a^2 + b^2 == 1
function oklab.compute_max_saturation(a, b)
    if a ~= 0.0 or b ~= 0.0 then
    	-- Max saturation will be when one of r, g or b goes below zero.
        -- Select different coefficients depending on which component goes below zero first

        -- Blue component (default)
        local k0 = 1.35733652
        local k1 = -0.00915799
        local k2 = -1.1513021
        local k3 = -0.50559606
        local k4 = 0.00692167
        local wl = -0.0041960863
        local wm = -0.7034186147
        local ws = 1.707614701

        if -1.88170328 * a - 0.80936493 * b > 1 then
            -- Red component
            k0 = 1.19086277
            k1 = 1.76576728
            k2 = 0.59662641
            k3 = 0.75515197
            k4 = 0.56771245
            wl = 4.0767416621
            wm = -3.3077115913
            ws = 0.2309699292
        elseif 1.81444104 * a - 1.19445276 * b > 1 then
            -- Green component
            k0 = 0.73956515
            k1 = -0.45954404
            k2 = 0.08285427
            k3 = 0.1254107
            k4 = 0.14503204
            wl = -1.2684380046
            wm = 2.6097574011
            ws = -0.3413193965
        end

        -- Approximate max saturation using a polynomial:
        local S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b

        -- Do one step Halley's method to get closer
        -- this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite
        -- this should be sufficient for most applications, otherwise do two/three steps

        local k_l = 0.3963377774 * a + 0.2158037573 * b
        local k_m = -0.1055613458 * a - 0.0638541728 * b
        local k_s = -0.0894841775 * a - 1.291485548 * b

        do
            local l_ = 1.0 + S * k_l
            local m_ = 1.0 + S * k_m
            local s_ = 1.0 + S * k_s

            local l = l_ * l_ * l_
            local m = m_ * m_ * m_
            local s = s_ * s_ * s_

            local l_dS = 3.0 * k_l * l_ * l_
            local m_dS = 3.0 * k_m * m_ * m_
            local s_dS = 3.0 * k_s * s_ * s_

            local l_dS2 = 6.0 * k_l * k_l * l_
            local m_dS2 = 6.0 * k_m * k_m * m_
            local s_dS2 = 6.0 * k_s * k_s * s_

            local f = wl * l + wm * m + ws * s
            local f1 = wl * l_dS + wm * m_dS + ws * s_dS
            local f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2

            local s_denom = f1 * f1 - 0.5 * f * f2
            if s_denom ~= 0.0 then  S = S - f * f1 / s_denom end
        end

        return S
    else
        return 0.0
    end
end

-- finds L_cusp and C_cusp for a given hue
-- a and b must be normalized so a^2 + b^2 == 1
function oklab.find_cusp(a, b)
	-- First, find the maximum saturation (saturation S = C/L)
    local S_cusp = oklab.compute_max_saturation(a, b)

    -- Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:
    local rgb_at_max = oklab.oklab_to_linear_srgb({L = 1, a = S_cusp * a, b = S_cusp * b })
    local max_comp = math.max(rgb_at_max.r, rgb_at_max.g, rgb_at_max.b)
    if max_comp ~= 0.0 then
        local L_cusp = (1.0 / max_comp) ^ 0.3333333333333333
        return { L = L_cusp, C = L_cusp * S_cusp }
    else
        return { L = 0.0, C = 0.0 }
    end
end

-- Finds intersection of the line defined by
-- L = L0 * (1 - t) + t * L1
-- C = t * C1
-- a and b must be normalized so a^2 + b^2 == 1
function oklab.find_gamut_intersection(a, b, L1, C1, L0, x)
    -- Find the cusp of the gamut triangle
    local cusp = x or oklab.find_cusp(a, b)

    -- Find the intersection for upper and lower half separately
    local t = 0.0
    if ((L1 - L0) * cusp.C - (cusp.L - L0) * C1) <= 0.0 then
        -- Lower half
        local t_denom = C1 * cusp.L + cusp.C * (L0 - L1)
        if t_denom ~= 0.0 then t = cusp.C * L0 / t_denom end
    else
        -- Upper half
        -- First intersect with triangle
        local t_denom = C1 * (cusp.L - 1.0) + cusp.C * (L0 - L1)
        if t_denom ~= 0.0 then t = cusp.C * (L0 - 1.0) / t_denom end

        -- Then one step Halley's method
        do
            local dL = L1 - L0
            local dC = C1

            local k_l = 0.3963377774 * a + 0.2158037573 * b
            local k_m = -0.1055613458 * a - 0.0638541728 * b
            local k_s = -0.0894841775 * a - 1.291485548 * b

            local l_dt = dL + dC * k_l
            local m_dt = dL + dC * k_m
            local s_dt = dL + dC * k_s

            -- If higher accuracy is required, 2 or 3 iterations of the following block can be used:
            do
                local L = L0 * (1.0 - t) + t * L1
				local C = t * C1

				local l_ = L + C * k_l
				local m_ = L + C * k_m
				local s_ = L + C * k_s

				local l = l_ * l_ * l_
				local m = m_ * m_ * m_
				local s = s_ * s_ * s_

				local ldt = 3.0 * l_dt * l_ * l_
				local mdt = 3.0 * m_dt * m_ * m_
				local sdt = 3.0 * s_dt * s_ * s_

				local ldt2 = 6.0 * l_dt * l_dt * l_
				local mdt2 = 6.0 * m_dt * m_dt * m_
				local sdt2 = 6.0 * s_dt * s_dt * s_

                local r0 = 4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s - 1
				local r1 = 4.0767416621 * ldt - 3.3077115913 * mdt + 0.2309699292 * sdt
				local r2 = 4.0767416621 * ldt2 - 3.3077115913 * mdt2 + 0.2309699292 * sdt2

                local r_denom = r1 * r1 - 0.5 * r0 * r2
                local u_r = 0.0
                if r_denom ~= 0.0 then u_r = r1 / r_denom end
				local t_r = -r0 * u_r

                local g0 = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s - 1
				local g1 = -1.2684380046 * ldt + 2.6097574011 * mdt - 0.3413193965 * sdt
				local g2 = -1.2684380046 * ldt2 + 2.6097574011 * mdt2 - 0.3413193965 * sdt2

                local g_denom = g1 * g1 - 0.5 * g0 * g2
                local u_g = 0.0
                if g_denom ~= 0.0 then u_g = g1 / g_denom end
				local t_g = -g0 * u_g

                local b0 = -0.0041960863 * l - 0.7034186147 * m + 1.707614701 * s - 1
				local b1 = -0.0041960863 * ldt - 0.7034186147 * mdt + 1.707614701 * sdt
				local b2 = -0.0041960863 * ldt2 - 0.7034186147 * mdt2 + 1.707614701 * sdt2

                local b_denom = (b1 * b1 - 0.5 * b0 * b2)
                local u_b = 0.0
                if b_denom ~= 0.0 then u_b = b1 / b_denom end
				local t_b = -b0 * u_b

                if u_r < 0.0 then t_r = 3.40282347e+38 end
                if u_g < 0.0 then t_g = 3.40282347e+38 end
                if u_b < 0.0 then t_b = 3.40282347e+38 end

                t = t + math.min(t_r, t_g, t_b)
            end
        end
    end

    return t
end

function oklab.get_Cs(L, a_, b_)
    local cusp = oklab.find_cusp(a_, b_)
    local C_max = oklab.find_gamut_intersection(a_, b_, L, 1.0, L, cusp)
    local ST_max = oklab.to_ST(cusp)

    -- Scale factor to compensate for the curved part of gamut shape:
    local k = 0.0
    local k_denom = math.min(L * ST_max.S, (1.0 - L) * ST_max.T)
    if k_denom ~= 0.0 then k = C_max / k_denom end

    local C_mid = 0.0
    do
        local ST_mid = oklab.get_ST_mid(a_, b_)

        -- Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.
        local C_a = L * ST_mid.S
        local C_b = (1.0 - L) * ST_mid.T

        local cae4 = C_a * C_a * C_a * C_a
        local cbe4 = C_b * C_b * C_b * C_b
        C_mid = 0.9 * k * ((1.0 / (1.0 / cae4 + 1.0 / cbe4)) ^ 0.25)
    end

    local C_0 = 0.0
    do
        -- for C_0, the shape is independent of hue, so ST are constant. Values picked to roughly be the average values of ST.
        local C_a = L * 0.4
        local C_b = (1.0 - L) * 0.8

        -- Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.
        local cae2 = C_a * C_a
        local cbe2 = C_b * C_b
        C_0 = math.sqrt(1.0 / (1.0 / cae2 + 1.0 / cbe2))
    end

    return { C_0 = C_0, C_mid = C_mid, C_max = C_max }
end

-- Returns a smooth approximation of the location of the cusp
-- This polynomial was created by an optimization process
-- It has been designed so that S_mid < S_max and T_mid < T_max
function oklab.get_ST_mid(a_, b_)
    local S = 0.11516993
    local s_denom = 7.4477897 + 4.1590124 * b_
        + a_ * (-2.19557347 + 1.75198401 * b_
        + a_ * (-2.13704948 - 10.02301043 * b_
        + a_ * (-4.24894561 + 5.38770819 * b_ + 4.69891013 * a_)))
    if s_denom ~= 0.0 then
        S = 0.11516993 + 1.0 / s_denom
    end

    local T = 0.11239642
    local t_denom = 1.6132032 - 0.68124379 * b_
        + a_ * (0.40370612 + 0.90148123 * b_
        + a_ * (-0.27087943 + 0.6122399 * b_
        + a_ * (0.00299215 - 0.45399568 * b_ - 0.14661872 * a_)))
	if t_denom ~= 0.0 then
        T = 0.11239642 + 1.0 / t_denom
    end

	return { S = S, T = T }
end

function oklab.linear_srgb_to_oklab(c)
    local l = 0.4122214708 * c.r
            + 0.5363325363 * c.g
            + 0.0514459929 * c.b
	local m = 0.2119034982 * c.r
            + 0.6806995451 * c.g
            + 0.1073969566 * c.b
	local s = 0.0883024619 * c.r
            + 0.2817188376 * c.g
            + 0.6299787005 * c.b

    local l_ = l ^ 0.3333333333333333
    local m_ = m ^ 0.3333333333333333
    local s_ = s ^ 0.3333333333333333

    return {
        L = 0.2104542553 * l_
          + 0.793617785 * m_
          - 0.0040720468 * s_,
        a = 1.9779984951 * l_
          - 2.428592205 * m_
          + 0.4505937099 * s_,
        b = 0.0259040371 * l_
          + 0.7827717662 * m_
          - 0.808675766 * s_ }
end

function oklab.okhsl_to_oklab(hsl)
	local l = hsl.l
    if l >= 1.0 then return { L = 1.0, a = 0.0, b = 0.0 } end
    if l <= 0.0 then return { L = 0.0, a = 0.0, b = 0.0 } end

    local s = hsl.s
    if s < 0.0 then s = 0.0 end
    if s > 1.0 then s = 1.0 end

    local h = hsl.h
    local h_rad = h * 6.283185307179586
    local a_ = math.cos(h_rad)
    local b_ = math.sin(h_rad)
    local L = oklab.toe_inv(l)

    local cs = oklab.get_Cs(L, a_, b_)
    local C_0 = cs.C_0
	local C_mid = cs.C_mid
	local C_max = cs.C_max

    local mid = 0.8
	local mid_inv = 1.25

    local C = 0.0
    local t = 0.0
    local k_0 = 0.0
    local k_1 = 0.0
    local k_2 = 0.0
    if s < mid then
        t = mid_inv * s

		k_1 = mid * C_0
        if C_mid ~= 0.0 then
		    k_2 = 1.0 - k_1 / C_mid
        end

        local k_denom = 1.0 - k_2 * t
		if k_denom ~= 0.0 then
            C = t * k_1 / k_denom
        end
    else
        local t_denom = 1.0 - mid
        if t_denom ~= 0.0 then
            t = (s - mid) / t_denom
        end

		k_0 = C_mid
        if C_0 ~= 0.0 then
		    k_1 = (1.0 - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0
        end

        local C_denom = C_max - C_mid
		k_2 = 1.0
        if C_denom ~= 0.0 then
            k_2 = 1.0 - k_1 / C_denom
        end

        local k_denom = 1.0 - k_2 * t
        if k_denom ~= 0.0 then
		    C = k_0 + t * k_1 / k_denom
        end
    end

    return {
        L = L,
        a = C * a_,
        b = C * b_ }
end

function oklab.okhsl_to_srgb(hsl)
    return oklab.oklab_to_srgb(oklab.okhsl_to_oklab(hsl))
end

function oklab.okhsv_to_oklab(hsv)
	local v = hsv.v
    if v <= 0.0 then return { L = 0.0, a = 0.0, b = 0.0 } end
    if v > 1.0 then v = 1.0 end

    local s = hsv.s
    if s < 0.0 then s = 0.0 end
    if s > 1.0 then s = 1.0 end

    local h = hsv.h
    local h_rad = h * 6.283185307179586
    local a_ = math.cos(h_rad)
    local b_ = math.sin(h_rad)

    local cusp = oklab.find_cusp(a_, b_)
	local ST_max = oklab.to_ST(cusp)
	local S_max = ST_max.S
	local T_max = ST_max.T
	local S_0 = 0.5
    local k = 1.0
    if S_max ~= 0.0 then
	    k = 1.0 - S_0 / S_max
    end

    -- first we compute L and V as if the gamut is a perfect triangle:

	-- L, C when v==1:
    local v_denom = S_0 + T_max - T_max * k * s
    local L_v = 1.0
    local C_v = 0.0
    if v_denom ~= 0.0 then
        L_v = 1.0 - s * S_0 / v_denom
	    C_v = s * T_max * S_0 / v_denom
    end

    local L = v * L_v
	local C = v * C_v

    --then we compensate for both toe and the curved top part of the triangle:
    local L_vt = oklab.toe_inv(L_v)
    local C_vt = 0.0
    if L_v ~= 0.0 then
        C_vt = C_v * L_vt / L_v
    end

    local L_new = oklab.toe_inv(L)
    if L ~= 0.0 then
        C = C * L_new / L
    end
    L = L_new

    local rgb_scale = oklab.oklab_to_linear_srgb({
        L = L_vt,
        a = a_ * C_vt,
        b = b_ * C_vt })
    local max_comp = math.max(
        rgb_scale.r,
        rgb_scale.g,
        rgb_scale.b, 0.0)
    local scale_L = 0.0
    if max_comp ~= 0.0 then
        scale_L = (1.0 / max_comp) ^ 0.3333333333333333
    end

	C = C * scale_L
    return {
        L = L * scale_L,
        a = C * a_,
        b = C * b_ }
end

function oklab.okhsv_to_srgb(hsv)
    return oklab.oklab_to_srgb(oklab.okhsv_to_oklab(hsv))
end

function oklab.oklab_to_linear_srgb(lab)
    local l_ = lab.L
        + 0.3963377774 * lab.a
        + 0.2158037573 * lab.b
	local m_ = lab.L
        - 0.1055613458 * lab.a
        - 0.0638541728 * lab.b
	local s_ = lab.L
        - 0.0894841775 * lab.a
        - 1.291485548 * lab.b

    local l = l_ * l_ * l_
    local m = m_ * m_ * m_
    local s = s_ * s_ * s_

    return {
        r = 4.0767416621 * l
          - 3.3077115913 * m
          + 0.2309699292 * s,
        g = -1.2684380046 * l
           + 2.6097574011 * m
           - 0.3413193965 * s,
        b = -0.0041960863 * l
           - 0.7034186147 * m
           + 1.707614701 * s }
end

function oklab.oklab_to_okhsl(lab)
    local L = lab.L
    if L >= 1.0 then return { h = 0.0, s = 0.0, l = 1.0 } end
    if L <= 0.0 then return { h = 0.0, s = 0.0, l = 0.0 } end

    local Csq = lab.a * lab.a + lab.b * lab.b
    if Csq > 0.0 then
        local C = math.sqrt(Csq)
        local a_ = lab.a / C
        local b_ = lab.b / C

        -- 1.0 / math.pi = 0.3183098861837907
        local h = 0.5 + 0.5 * math.atan(-lab.b, -lab.a) * 0.3183098861837907

        local cs = oklab.get_Cs(L, a_, b_)
        local C_0 = cs.C_0
        local C_mid = cs.C_mid
        local C_max = cs.C_max

        -- Inverse of the interpolation in okhsl_to_srgb:
        local mid = 0.8
        local mid_inv = 1.25

        local s = 0.0
        if C < C_mid then
            local k_1 = mid * C_0
            local k_2 = 1.0
            if C_mid ~= 0.0 then
                k_2 = (1.0 - k_1 / C_mid)
            end

            local t_denom = k_1 + k_2 * C
            local t = 0.0
            if t_denom ~= 0.0 then
                t = C / t_denom
            end

            s = t * mid
        else
            local k_0 = C_mid
            local k_1 = 0.0
            if C_0 ~= 0.0 then
                k_1 = (1.0 - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0
            end

            local C_denom = C_max - C_mid
            local k_2 = 1.0
            if C_denom ~= 0.0 then
                k_2 = 1.0 - k_1 / C_denom
            end

            local t_denom = k_1 + k_2 * (C - k_0)
            local t = 0.0
            if t_denom ~= 0.0 then
                t = (C - k_0) / t_denom
            end

            s = mid + (1.0 - mid) * t
        end

        return { h = h, s = s, l = oklab.toe(L) }
    else
        return { h = 0.0, s = 0.0, l = L }
    end
end

function oklab.oklab_to_okhsv(lab)
    local L = lab.L
    if L >= 1.0 then return { h = 0.0, s = 0.0, v = 1.0 } end
    if L <= 0.0 then return { h = 0.0, s = 0.0, v = 0.0 } end

    local Csq = lab.a * lab.a + lab.b * lab.b
    if Csq > 0.0 then
        local C = math.sqrt(Csq)
        local a_ = lab.a / C
        local b_ = lab.b / C

        -- 1.0 / math.pi = 0.3183098861837907
        local h = 0.5 + 0.5 * math.atan(-lab.b, -lab.a) * 0.3183098861837907

        local cusp = oklab.find_cusp(a_, b_)
        local ST_max = oklab.to_ST(cusp)
        local S_max = ST_max.S
        local T_max = ST_max.T
        local S_0 = 0.5
        local k = 1.0
        if S_max ~= 0.0 then
            k = 1.0 - S_0 / S_max
        end

        -- first we find L_v, C_v, L_vt and C_vt
        local t_denom = C + L * T_max
        local t = 0.0
        if t_denom ~= 0.0 then
            t = T_max / t_denom
        end
        local L_v = t * L
        local C_v = t * C

        local L_vt = oklab.toe_inv(L_v)
        local C_vt = 0.0
        if L_v ~= 0.0 then
            C_vt = C_v * L_vt / L_v
        end

        -- we can then use these to invert the step that compensates for the toe and the curved top part of the triangle:
        local rgb_scale = oklab.oklab_to_linear_srgb({
            L = L_vt,
            a = a_ * C_vt,
            b = b_ * C_vt })
        local scale_denom = math.max(
            rgb_scale.r,
            rgb_scale.g,
            rgb_scale.b, 0.0)
        local scale_L = 0.0
        if scale_denom ~= 0.0 then
            scale_L = (1.0 / scale_denom) ^ 0.3333333333333333
            L = L / scale_L
            C = C / scale_L
        end

        local toel = oklab.toe(L)
        C = C * toel / L
        L = toel

        -- we can now compute v and s:
        local v = 0.0
        if L_v ~= 0.0 then v = L / L_v end

        local s = 0.0
        local s_denom = ((T_max * S_0) + T_max * k * C_v)
        if s_denom ~= 0.0 then
            s = (S_0 + T_max) * C_v / s_denom
        end

        return { h = h, s = s, v = v }
    else
        return { h = 0.0, s = 0.0, v = L }
    end
end

function oklab.oklab_to_srgb(lab)
    local lrgb = oklab.oklab_to_linear_srgb(lab)
	return {
		r = oklab.srgb_transfer_function(lrgb.r),
		g = oklab.srgb_transfer_function(lrgb.g),
		b = oklab.srgb_transfer_function(lrgb.b) }
end

function oklab.srgb_to_okhsl(rgb)
    return oklab.oklab_to_okhsl(oklab.srgb_to_oklab(rgb))
end

function oklab.srgb_to_okhsv(rgb)
    return oklab.oklab_to_okhsv(oklab.srgb_to_oklab(rgb))
end

function oklab.srgb_to_oklab(srgb)
    return oklab.linear_srgb_to_oklab({
		r = oklab.srgb_transfer_function_inv(srgb.r),
		g = oklab.srgb_transfer_function_inv(srgb.g),
		b = oklab.srgb_transfer_function_inv(srgb.b) })
end

function oklab.srgb_transfer_function(a)
    if 0.0031308 >= a then
        return 12.92 * a
    else
        return 1.055 * (a ^ 0.4166666666666667) - 0.055
    end
end

function oklab.srgb_transfer_function_inv(a)
    if 0.04045 < a then
        return ((a + 0.055) * 0.9478672985781991) ^ 2.4
    else
        return a * 0.07739938080495357
    end
end

function oklab.to_ST(cusp)
	local L = cusp.L
    local C = cusp.C
    if L ~= 0.0 and L ~= 1.0 then
        return { S = C / L, T = C / (1.0 - L) }
    elseif L ~= 0.0 then
        return { S = C / L, T = 0.0 }
    elseif L ~= 1.0 then
        return { S = 0.0, T = C / (1.0 - L) }
    else
        return { S = 0.0, T = 0.0 }
    end
end

function oklab.toe(x)
    local y = 1.170873786407767 * x - 0.206
	return 0.5 * (y + math.sqrt(y * y + 0.14050485436893204 * x))
end

function oklab.toe_inv(x)
    local denom = 1.170873786407767 * (x + 0.03)
    if denom ~= 0.0 then
    	return (x * x + 0.206 * x) / denom
    else
        return 0.0
    end
end

return oklab
:: src/palette.lua
--[[pod_format="raw",created="2024-03-31 08:27:10",modified="2025-03-05 16:21:40",revision=3587]]
function set_color(c, code)
	poke4(0x5000 + 4 * c, code)
end


function get_color(c)
	return peek4(0x5000 + 4 * c)
end


function color_to_hex(c)
	return string.format("%06x", c)
end


function rebuild_pal(c)
	for c = 0, 63 do
		pal_code[c] = get_color(c)
		pal_okhsl[c] = oklab.color_to_okhsl(pal_code[c])
	end
end


function change_color_code(c, code)
	pal_code[c] = code
	pal_okhsl[c] = oklab.color_to_okhsl(pal_code[c])
	set_color(c, code)
end


function change_color(c, hue, sat, lum)
	local hsl = {
		h = hue or pal_okhsl[c].h,
		s = sat or pal_okhsl[c].s,
		l = lum or pal_okhsl[c].l,
	}
	hsl.h = mid(-1.0, hsl.h, 1.0)
	hsl.s = mid(0.0, hsl.s, 1.0)
	hsl.l = mid(0.0, hsl.l, 1.0)
	local code = oklab.okhsl_to_color(hsl)
	pal_code[c] = code
	pal_okhsl[c] = hsl
	set_color(c, code)
	return
end


function swap_colors(c1, c2)
	pal_code[c1], pal_code[c2] = pal_code[c2], pal_code[c1]
	pal_okhsl[c1], pal_okhsl[c2] = pal_okhsl[c2], pal_okhsl[c1]
	set_color(c1, pal_code[c1])
	set_color(c2, pal_code[c2])
end


function clear_colors()
	for c = 0, 63 do
		local code, lum
		if c == 7 then
			code = 0xffffff
			lum = 1.0
		else
			code = 0x000000
			lum = 0.0
		end
		pal_code[c] = code
		pal_okhsl[c] = { h = 0.0, s = 0.0, l = lum }
		set_color(c, code)
		locked[c] = (c == 0) or (c == 7)
		hidden[c] = false
		for row = 0, 3 do hidden_toggles[row] = false end
		for i = 0, #test_cube_colors - 1 do
			test_cube_colors[i] = { 1, 1, 1 }
		end
	end
	bg_color = 0
	blackest_color = 0
	whitest_color = 7
end


function restore_default_palette()
	for c = 0, 63 do
		code = peek4(0x5000 + 4 * (64 + c))
		set_color(c, code)
		pal_code[c] = code
		pal_okhsl[c] = oklab.color_to_okhsl(code)
		locked[c] = c <= 31
		hidden[c] = false
		for row = 0, 3 do hidden_toggles[row] = false end
		test_cube_colors = copy(default_test_cube_colors)
	end
	bg_color = 0
	blackest_color = 0
	whitest_color = 7
end


function find_blackest_and_whitest()
	local min_lum = 1.0
	local best_black = 0
	local max_lum = 0.0
	local best_white = 1
	for c = 0, 63 do
		if pal_okhsl[c].l < min_lum then
			best_black = c
			min_lum = pal_okhsl[c].l
		end
		if pal_okhsl[c].l > max_lum then
			best_white = c
			max_lum = pal_okhsl[c].l
		end
	end
	return best_black, best_white
end
:: src/settings.lua
--[[pod_format="raw",created="2025-03-07 18:22:46",modified="2025-03-11 04:23:31",revision=376]]
local settings_folder = "/appdata/okpal/"
local settings_filepath = "/appdata/okpal/settings.pod"


function load_settings()
	mkdir(settings_folder)
	local s = fetch(settings_filepath)
	if s then
		for k, v in pairs(user_settings) do
			if type(s[k]) ~= "nil" then
				user_settings[k] = s[k]
			end
		end
	end
end


function change_settings(t)
	for k, v in pairs(t) do
		user_settings[k] = v
	end
	store(settings_filepath, user_settings)
end

:: src/soft_wrap.lua
--[[pod_format="raw",created="2025-03-07 11:09:14",modified="2025-03-07 17:37:27",revision=426]]
function soft_wrap(text, width)
	local space_width <const> = print(" ", -1000, -1000) + 1000
	local lines = {}
	local line = ""
	local x = 0
	local indentation = 0 -- indentation of the current paragraph

	local function add_word(word)
		local dx = print(word, -1000, -1000) + 1000
		if x + space_width + dx >= width then
			add(lines, line)
			line = ""
			x = 0
			for i = 1, indentation do
				line ..= " "
				x += space_width
			end
			line ..= word
			x += dx
		else
			if line:find("^%s*$") then
				line ..= word
				x += dx
			else
				line ..= " " .. word
				x += space_width + dx
			end
		end
	end
	
	local function add_line()
		add(lines, line)
		line = ""
		x = 0
	end
	
	local in_paragraph = false
	local in_code = false
	local ignore_word = false
	local ignore_line = false
	add_line()
	for hard_line in text:gmatch("([^\n]*)\n?") do
		ignore_line = false
		ignore_word = false
		if hard_line:find("^%s*$") then
			if in_paragraph then
				add_line()
				add_line()
				in_paragraph = false
				indentation = 0
			end
		elseif hard_line:find("^%s*- ") then
			if in_paragraph then
				add_line()
			end
			add_word("-")
			indentation = 2
			in_paragraph = true
			ignore_word = true
		elseif hard_line:find("^```%s*$") then
			if line ~= "" then
				add_line()
			end
			in_code = not in_code
			ignore_line = true
		else
			in_paragraph = true
 		end
 		
 		if not ignore_line then
	 		if in_code then
	 			line = hard_line
	 			add_line()
	 		else
				for word in hard_line:gmatch("([^%s]*)%s?") do
					if ignore_word then
						ignore_word = false
					else
						add_word(word)
					end
				end
			end
		end
	end
	add_line()
	
	return lines
end
:: src/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTAzIDE4OjA3OjM0Iixtb2RpZmllZD0iMjAyNS0w
My0xMSAxMjo0Nzo0NiIsc3RvcmVkPSIyMDI0LTA0LTAzIDE4OjA3OjM0Il1d
:: label.qoi
b64$cW9pZgAAAeAAAAEOBAH_--Ho-f39-f39-f3T-rkAPvI-wf6iiHnMP-39-f39-cUSxD-X-rkA
Ps8-wBLOP8ASzz-_ooh5zj-9-f39zBLAP8ASwD-HEsE-wBLBP8sSwT-IEsQ-xhLGP8kSPxI-3RLF
P8YSxT-H-rkAPs4-EsA-Es4-Es8--qKIec4--f39-csSwD-CEsA-xhLBP8ASwT-GEsI-EsE-yBI-
whI-xhLGP8oSP8n_uQA_xj-P-qKIeT8SP9b_uQA_zj8SP8ASwz-BEsE-wBLBPxLPP-6iiHnOP-39
-f3LEsA-whLAP8YSwT-AEsE-xhLCPxLBP8gSP8ISP8YSxj-GEsc-xf65AD7CP8ESP8v_ooh5wT8S
wT-GEsU-x-65AD7OP8ASPxLDPxLAPxLCPxLAPxLPP-6iiHnGPxLFP-39-f3LEsA-whLAP8YSxj-G
EsI-zBI-whI-xhLGP8YSwD-DEsA-xf65AD7CP8ESP8v_ooh5PxI-2v65AD7OPxLAPxLDPxLAPxLA
P8ESwD8Szz-_ooh5xT-BEsQ--f39-csSwD-CEsA-xhI-EsI-Ej-GEsU-yRI-wBLBP9YSwD-DEsA-
xf65AD4-wRLCP8v_ooh5xT-GEsU-x-65AD7OPxLAPxLDP8ESwD8SwD8SwD8Szz-_ooh5xj8SxT-9
-f39yxLAP8ISwD-GEj8Swj8SP8YSxT-HEsE-wBLBP8YSxj-GEsA-wxLAP8X_uQA_P8ESwj-M-qKI
ecQ-1v65AD7PP8ASwT8SwD8Swz-BEsA-wBLOP-6iiHnOP-39-f3MEsA-wBLAP8cSxj-GEsU-xxLB
P8sSwD-CEsA-xhLHP8X_uQA_xj-qEtc-Eto--qKIec4--f39-f394-65AD70P-6iiHnOP-39-f39
-f4AAAD9-f39-f39-f39-f39-f39-f39-f39-f39-f39-f39-f39-f3iPzU-NT81PzU-NT81xT81
PzU-NT81PzU-NdE-1TXDP9Y1-f39-f39xT81yj81wj81yj81zj-XNcE-NdY-Ne0--f39xjXfPzU-
NcM-Ncc-NT81PzXNPzU-Nf3NPzXPPzXNP9c1wT811j817T81yv4dK1PK-n4lU8r_AIdRyv6rUjbK
-l9XT8r_wsPHyj-K-v8ATcr_-6MAyv7-7CfK-gDkNsr_Ka3-yv6DdpzK-v93qMr_-8yqyj81-f3K
PzXPPzXbP9k1PzXYPzXsPzXKKMotyg-K-qtSNsouyjvKP8oNyiHKH8ojyv4prf-KEModyhTKPzXd
PzXDPzXBPzXHPzXDPzXNPzX9xT81PzU-NcE-NcQ-NT81PzXEPzXMP8M1wD81PzU-NcE-NcE-wDXA
P8I1PzXCP8E1P8E1P8E1P8A1wT-ANcE-NeI-wjXEPzXKKMotyg-K-qtSNsouyjvKP8oNyiHKH8oj
yv4prf-KEModyhTKPzX9-co-NcM-NT81wT81wz81wD81wT81PzXRP8M1P8E1PzU-NT81PzU-wTU-
xTXDPzU-NT81PzU-wTU-NT81PzXEPzXgP8Q1wz81yijKLcoPyv6rUjbKLso7yj-KDcohyh-KI8r_
Ka3-yhDKHcoUyj813T81wz81wT81wz81wT81wz81wz81PzXFPzX9wz81PzXFPzXIPzU-NcI-Ncs-
wzU-wTU-NT81wD-ANcA-wDXBP8M1wz-ANcA-wTU-NT81P8A1wD-BNcI-Nd8-xjXCPzXKKMotyg-K
-qtSNsouyjvKP8oNyiHKH8ojyv4prf-KEModyhTKPzX9-co-NcM-Nck-NcY-NdA-xDU-wTU-NT81
PzU-NT-DNT-ENcI-NT81PzU-NT81PzU-NcM-NcM-Nd0-wDU-wDU-NT-ANcE-Ncooyi3KD8r_q1I2
yi7KO8o-yg3KIcofyiPK-imt-8oQyh3KFMo-Nd0-NcM-NcE-NcE-NcM-NT81PzXJPzXDPzX9wT81
PzU-NT81wz81xj81PzU-NT81wD81yj-FNcA-wDXAPzXBPzXBPzXAP8U1wj81PzU-NT81PzU-NT81
wT-ANcQ-Nd0-NcA-wjXAPzXBPzXKKMotyg-K-qtSNsouyjvKP8oNyiHKH8ojyv4prf-KEModyhTK
PzX9-co-NcE-NT81PzXHPzXEPzU-NT81zT-fNdo-Nd0-NcA-wDXAPzXCPzXKKMotyg-K-qtSNsou
yjvKP8oNyiHKH8ojyv4prf-KEModyhTKPzXdPzXDPzXBPzU-NcU-Nck-NT81PzXDPzXHP8A1xD-A
NcQ-wTXlPzU-NcU-Ncg-NT81wj81yT-fNdo-Nd4-NcI-NcM-Ncooyi3KD8r_q1I2yi7KO8o-yg3K
IcofyiPK-imt-8oQyh3KFMo-Nf3UPzXFPzXEPzU-NeA-NcM-Nck-NcY-Nc4--dQ1yj-CNcQ-Ncoo
yi3KD8r_q1I2yi7KO8o-yg3KIcofyiPK-imt-8oQyh3KFMo-Nd0-NcM-NcE-NcE-NcM-Ncc-NcM-
NcM-Ncg-NcU-NcQ-NT817z81zz81-fQ-Ncooyi3KD8r_q1I2yi7KO8o-yg3KIcofyiPK-imt-8oQ
yh3KFMo-Nf3UPzXFPzXEPzU-NeA-Nc8-Nf39xT81yijKLcoPyv6rUjbKLso7yj-KDcohyh-KI8r_
Ka3-yhDKHcoUyj813z81PzXDPzXDPzXBPzXJPzU-NT81wz81PzXFP8E1wD81wD-BNcA-NcA-wTXh
PzXKPzXCPzXKPzX99T-_JGOwyv4ApaHK-mVGiMr_ElNZyv50LynK-kUtMsoSyv7-rMXK-rkAPsr_
4msCyv6V8ELK-gCyUcr_ZN-2yv69mt-K-uQNq8r_-4VXyj81-f3NPzU-NT81PzU-NT81xT81PzU-
NT81PzU-Nf32PyDKFco6yjnKG8oDyv6iiHnKMcr_uQA_ygDKMsomyjbKB8oPyizKPzX9-f3CFMw1
zCzMNcz_q1I2zDXOP8I1xD8gyhXKOso5yhvKA8r_ooh5yjHK-rkAPsoAyjLKJso2ygfKD8osyj81
-f39wRTMCjXLLMwbNcsKzAM1zT-ENcM-IMoVyjrKOcobygPK-qKIecoxyv65AD7KAMoyyibKNsoH
yg-KLMo-Nf39zD-KNcQ-yjXSFMwKwDXKLMwbwDXKCswDwDXMP8Y1wj8gyhXKOso5yhvKA8r_ooh5
yjHK-rkAPsoAyjLKJso2ygfKD8osyj81-f3LPzXKPzXCPzXKPzXQFMwKwTXJLMwbwTXJCswDwTXL
P8A1P8A1PzU-wDXBPyDKFco6yjnKG8oDyv6iiHnKMcr_uQA_ygDKMsomyjbKB8oPyizKPzX9-co-
Ncw-NcA-Ncw-Nc4UzArCNcgszBvCNcgKzAPCNcs-NcA-wjXAPzXBPyDKFco6yjnKG8oDyv6iiHnK
Mcr_uQA_ygDKMsomyjbKB8oPyizKPzX9-co-NcQ-wDXEPzXAPzXCP8Q1wj81zRTMCsM1xyzMG8M1
xwrMA8M1zD81wD-ANcA-NcI-IMoVyjrKOcobygPK-qKIecoxyv65AD7KAMoyyibKNsoHyg-KLMo-
Nf39yj81wT-ANT-ANT-ANcE-NcA-NcE-wTXAP8E1wT81zCzMCsQ1xgrMG8Q1xhvMA8Q1zT81wj81
wz8gyhXKOso5yhvKA8r_ooh5yjHK-rkAPsoAyjLKJso2ygfKD8osyj81-f3KPzXBP8Y1wT81wD81
wT-ANcI-wDXBPzXMLMwKxDXGCswbxDXGG8wDxDXOP8I1xD8gyhXKOso5yhvKA8r_ooh5yjHK-rkA
PsoAyjLKJso2ygfKD8osyj81-f3KPzXCP8Q1wj81wD81xz-ANcE-NcwszArENcYKzBvENcYbzAPE
Ndg-IMoVyjrKOcobygPK-qKIecoxyv65AD7KAMoyyibKNsoHyg-KLMo-Nf39yj81wD-CNcA-wjXA
PzXAPzXGP8A1wj81zCzMCsQ1xgrMG8Q1xhvMA8Q12D8gyhXKOso5yhvKA8r_ooh5yjHK-rkAPsoA
yjLKJso2ygfKD8osyj81-f3KPzXAP8I1wD-CNcA-NcA-NcU-wDXDPzXMLMwKxDXGCswbxDXGG8wD
xDXYPzX9-f3EPzXePzXAP8E1P8E1P8E1wD-ANcA-wDXDP8E1P8A1xD-BNcA-wDU-wTXDPzU-NT-B
NT81wT-BNcA-Nd0-NcI-xDXCPzXAPzXEP8A1xD81zCzMCsQ1xgrMG8Q1xhvMA8Q12D81-f39xD81
3T81wT81PzU-NT81PzXBPzXBPzXFPzXCPzXEPzXBPzU-NT81PzXDPzU-NT81wT81wT81PzXBPzXc
PzXBP8Y1wT81wD81xD-ANcQ-NcwszArENcYKzBvENcYbzAPENc4-wjXEPzX9-f3EPzXdPzXBP8E1
P8A1wD-ANcA-wTU-wTXDP8A1wT81xD-ANcA-NT81P8A1xD-BNT-ANcA-NcE-wTXBPzXcPzXBP8A1
P8A1P8A1wT81wD81zD81zCzMCsQ1xgrMG8Q1xhvMA8Q1zT-ENcM-Nf39-cQ-Nd0-NcE-NcE-NT81
PzXDPzXBPzXDPzXCPzXEPzXBPzU-NT81PzXDPzU-NT81wT81wT81wz813D81xD-ANcQ-NcA-NcQ-
wDXEPzXMLMwKwzXHCswbwzXHG8wDwzXNP8Y1wj81-f39xD813j81wD81wT81PzU-wTU-wDXAP8A1
xD81wT-BNcM-NcE-wDXAPzU-NcM-NT81P8E1P8E1PzXCPzXdPzXMPzXAPzXMPzXMLMwKwjXICswb
wjXIG8wDwjXNP8A1P8A1PzU-wDXBPzX9-f3EPzX9-cs-Nco-NcI-Nco-Nc0szArBNckKzBvBNckb
zAPBNc4-NcA-wjXAPzXBPzX9-f3EPzX9-cw-yjXEP8o1zizMCsA1ygrMG8A1yhvMA8A10D81wD-A
NcA-NcI-Nf39-cQ-Nf39_izMCjXLCswbNcsbzAM10j81wj81wz81-f39xD81-f36LMw1zArMNcwb
zDXUP8I1xD81-f39xD81-f39-eQ-Nf39-cQ-Nf39-f3kPzX9-f3EPzX9-f395D81-f39xD81-f39
-eQ-Nf39-cQ-Nf39-f3aP8I1xD81-f39xD81-f39-dk-xDXDPzX9-f3EPzX9-f392D-GNcI-Nf39
-cQ-Nf39-f3XP8A1P8A1PzU-wDXBPzX9-f3EPzX9-f3CH8w1zCHMNcwNzDXLPzXAP8I1wD81wT81
-f39xD81-f39wR-MADXLIcwSNcsNzC01zD81wD-ANcA-NcI-Nf39-cQ-Nf39-cAfzADANcohzBLA
NcoNzC3ANc0-NcI-NcM-Nf39-cQ-Nf39-R-MAME1ySHMEsE1yQ3MLcE1zj-CNcQ-Nf39-cQ-Nf39
-B-MAMI1yCHMEsI1yA3MLcI12D81-f39xD81-f37H8wAwzXHIcwSwzXHDcwtwzXYPzX9-f3EPzX9
-fohzADENcYAzBLENcYSzC3ENdg--f39xjX9-fohzADENcYAzBLENcYSzC3ENf39-f39-d4hzADE
NcYAzBLENcYSzC3ENf39-f39-d4hzADENcYAzBLENcYSzC3ENf39-f39-d4hzADENcYAzBLENcYS
zC3ENf39-f39-d4hzADENcYAzBLENcYSzC3ENf39-f39-d4hzADENcYAzBLENcYSzC3ENf39-f39
-d4hzADENcYAzBLENcYSzC3ENf3pGzX9-f398CHMAMM1xwDMEsM1xxLMLcM1-eobNc8KNf39-f3e
IcwAwjXIAMwSwjXIEswtwjX92g01zhs1zwo1wSw1-f39-dohzADBNckAzBLBNckSzC3BNf3WEjXC
DTXOGzXPCjXBLDX9-f392iHMAMA1ygDMEsA1yhLMLcA1-dcSNcINNc4bNc4KNcIsNf39-f3aIcwA
NcsAzBI1yxLMLTX92BI1ww01zRs1zgo1wSw1-f39-dshzDXMAMw1zBLMNf3aEjXCDTXNGzXOCjXB
LDX9-f39-f39wRI1wg01zRs1zgo1wSw1zgA1-f39-f393wM1zBI1wg01zRs1zgo1wSw1zgA1-qKI
eTX9-f39-f3dAzXM-rkAPjXCDTXNGzXNCjXCLDXNADXA-qKIeTX91T-9-eM1-f3gAzXL-rkAPjXD
DTXMGzXNCjXBLDXOADX_ooh5NcMUNf3QPzX9-eE-Nf394AM1zP65AD41wg013Ao1wSw1zQA1wP6i
iHk1wxQ1-dA-Nf394T81-f3VHTE1yAM1y-65AD41wg014Cw1zQA1-qKIeTXDFDX90T81-f3hPzX9
-dYdMTXHAzXL-rkAPjX0ADXA-qKIeTXDFDX90T81-f3eP8I1-f3WHTE1yAM1-cMANRI1wxQ1-dI-
Nf393T-DNdAyzDXMI8w1zCbMNfsdMTXHAzX9wgA1wBI1wxQ1-dI-Nf393D-FNc4yzCY1yyPM-gCH
UTXLJsw5NfsdMTXIAzXODcE12yzBNcwANRI1wxQ1-cc-xjXCPzX9-dw-xTXNMswmwDXKI8wPwDXK
Jsw5wDX8HTE1xwM1yv65AD7BDcM1wz-PNcMswzXN-qKIeTXDFDX90z81-f3cP8U1zDLMJsE1ySPM
D8E1ySbMOcE1-B0xNdP_uQA_ww3DP8I1zz-CLMU10RQ1-dQ-Nf393T-DNcwyzCbCNcgjzA-CNcgm
zDnCNfAtNcodMTXREsUNwjXXLMU10RQ1-dQ-Nf393j8fwTXLMswmwzXHI8wPwzXHJsw5wzXxLTXJ
HTE10RLFDcI11yzFP8I1wQDBNf3ePzX9-d4fwzXJI8wmxDXGJswPxDXGD8w5xDXxLTXKHTE1zT-B
EsUNwTXZLMM1wz-AAMM13C41-D81-f3dH8U1yCPMJsQ1xibMD8Q1xg-MOcQ18i011z-BNcISww3B
NdsswTXFAMU12i418R-GNcI-Nf393R-FNcgjzCbENcYmzA-ENcYPzDnENfMtNdQ-wDXGEsE16QDF
NcAUwTXULjX9wD81-f3dH8U1yCPMJsQ1xibMD8Q1xg-MOcQ18y01yzHBNcI-wDX2AMU-FMM10i41
wiE1_j81-f3eH8M1ySPMJsQ1xibMD8Q1xg-MOcQ19C01yTHDNT-ANfkAwzUUxTXRLjXBITX7PzX9
-d8fwTXKI8wmxDXGJswPxDXGD8w5xDX0LTXIMcU1-ADBNcAUxTXQLjXBITX8PzX9-eE-NcojzCbE
NcYmzA-ENcYPzDnENfUtNccxxTX9wxTFPzXOLjXBITX9PzX9-eE-NcojzCbENcYmzA-ENcYPzDnE
NeT_5A2rNdgxxTX9xBTDNcA-wDXLLjXCITX9PzX9-d4UwT81yiPMJsM1xybM-gCHUcM1xw-MOcM1
5v7kDas11x0xwx01-cUUwTXDPzXJLjXCITX9wD81-f3dFMM1yiPMJsI1yCbM-gCHUcI1yA-MOcI1
6P7kDas11D-ANR0xwR01-c8-wDXLITX9wT81-f3cFMU1ySPMJsE1ySbM-gCHUcE1yQ-MOcE16v7k
Das10j81wh3BNf3SPzXJITX0FMY1wj81-f3RMsE1xhTFNckjzCbANcomzP4Ah1HANcoPzDnANez_
5A2rNc8-wDX92z-ANf3MPzX9-dAywzXFFMU1ySPMJjXLJsz_AIdRNcsPzDk17f7kDas1zj81-d8-
Nf3LPzX9-c8yxTXFFMM1yiPMNcwmzDXM-gCHUcw17-7kDas1zD81-eE-IcE1_TLGNcI-Nf39zzLF
NcYUwT81-f3GDzXJP8A1-eIhwzX9xj81-f3INsE1wjLFNck-Nf39xw81xz81-eMhxTX9xT81-f3H
NsM1wjLDNco-Nf390D81-eQhxTX9xT81-f3GNsU1wjLBNcs-Nf39zz81-eUhxTX3NsY1wj81-f3G
NsU1zzHBPzX9-c0PwTX95iHDNT81-cQ-Nf39xjbFNc4xwzX9-cwPwzX5CsE15iHBNcE-Nf3DPzXD
O8E1-f02wzXOMcU1-f3KD8U19wrDNew-NfQxxjXCPzXCO8M1-f02wTXPMcU1-f3KD8U17hvBNcMK
xTXsPzX9wT81wTvFNf390jHFNc82zDXMNsw1zP4prf-MNe4-D8U17RvDNcL_q1I2xTXtPzXyO8Y1
wj81wTvFNf390zHDNc82zDk1yzbMIDXL-imt-8woNe0-NcAPwzXtG8U1wf6rUjbFNe4-Nf0-NcE7
xTX9-dQxwT81zjbMOcA1yjbMIMA1yv4prf-MKMA17D81wg-BNe4bxTXC-qtSNsM18D81-D81wjvD
Nf391CPDNc02zDnBNck2zCDBNcn_Ka3-zCjBNes-NfYbxTXD-qtSNsE18j81_z81wzvBNf391CPF
Ncs2zDnCNcg2zCDCNcj_Ka3-zCjCNes-NfcbwzX7PzXvI8Y1wj81-f3cI8UhNck2zDnDNcc2zCDD
NccKzCjDNeo-NfkbwTX9PzXuIcY1wj81-f3cI8UhNcgVzDnENcYKzCDENcYgzCjENek-NdstwTX9
3z81_T81-f3dI8MhwDXIFcw5xDXGCswgxDXGIMwoxDXoPzXbLcM1-d8-Nfg-Nf393iPBIcA1yRXM
OcQ1xgrMIMQ1xiDMKMQ16D812i3FNf3ePzX4PzX9-d8hwTXKFcw5xDXGCswgxDXGIMwoxDXnPzXb
LcU1-d8-Nfc-Nf394T81yhXMOcQ1xgrMIMQ1xiDMKMQ15j813C3FNf3gPzX2PzX9-d4swT81yhXM
OcQ1xgrMIMQ1xiDMKMQ15j813S3DNf3hPzX2PzX92wfBNfsswzXKFcw5xDXGCswgxDXGIMwoxDXl
PzXfLcE1-eM-NfU-Nf3aB8M1_SzFNckVzDnENcYKzCDENcYgzCjENeQ-Nf39yz816CzGNcI-Nf3Z
B8U1_CzFNckVzDnDNccKzCDDNccgzCjDNeU-Nf39yz816AfGNcI-Nf3ZB8U1_CzFNckVzDnCNcgK
zCDCNcggzCjCNeU-Nf39zT818z81-dkHxTX4HSzDHTXJFcw5wTXJCswgwTXJIMwowTXmPzX9-c0-
NfM-Nf3aB8M1_h0swR01yhXMOcA1ygrMIMA1yiDMKMA15j81-f3PPzXyPzX92wfBNfoKwB3BCsA1
yRXMOTXLCswgNcsgzCg15z81-f3PPzXmCsY1wj81-f3cCsU1yRXMNcwKzDXMIMw15z81-f3RPzXx
PzX9-dwKxTX9_j81-f3RPzXxPzX9-d0KwzX9_j81-f3TPzXwPzX9-d4KwT81-fo-Nf390z818D81
-f3hPzX9_T81-f3VPzXvPzX9-eE-Nf35PzX9-dU-Ne8-Nf394T81-fg-Nf391z817j81-f3eJsE-
Nf34PzX9-dc-Ne4-Nf393SbDNf34PzX9-dc-Ne4-Nf393CbFNc87zDXMB8w1zBDMNd0-Nf392T81
zR-ANdAmxjXCPzXd-qKIecE1-fgmxTXOO8wQNcsHzDo1yxDMKDXdPzX9-dgfwTXJH8E10gDGNcI-
NdwSwzX99ybFNc07zBDANcoHzDrANcoQzCjANd0-Nf3LPzX9yR-DNcUfwTXVFcY1wj812xLFNf32
ACbDADXMO8wQwTXJB8w6wTXJEMwowTXcPzX9wgPBNf3QH8U1wh-ANdgSxjXCPzXbEsU1-fYVACbB
ABU1yzvMEMI1yAfMOsI1yBDMKMI13D81-cEDwzXEPzX9yB-FNeo-NdsSxTX99xUAwRU1yzvMEMM1
xwfMOsM1xxDMKMM13D81-cADxTX9zh-FNeo-NdwSwzX99w3AFcENwDXJB8wQxDXGEMw6xDXGOswo
xDXcPzX9wAPFNcM-Nf3JH8M13w3GNcI-Nd0SwTX99w-BDcM1yQfMEMQ1xhDMOsQ1xjrMKMQ12z81
-cEDxTX90B-BPzXrPzX9-doPww3CNckHzBDENcYQzDrENcY6zCjENds-Nf3CA8M1xD81whLBNf3G
PzXrPzX9-dkPxQ3ANcoHzBDENcYQzDrENcY6zCjENds-Nf3DA8E1yRLDNf3FPzXfD8Y1wj81-f3Z
D8UNPzXKB8wQxDXGEMw6xDXGOswoxDXbPzX9zT81wBLFNf3EPzXrPzXpEME1-ekPxTU-NcoHzBDE
NcYQzDrENcY6zCjENdo-Nf3REsU1-cU-Neo-NegQwzX96Q-DNcA-NcoHzBDENcYQzDrENcY6zCjE
NckHxDXJPzX9zj81wBLFNf3FPzXqPzXnEMU1-ekPwTXBPzXKB8wQxDXGEMw6xDXGOswoxDXPB8M1
xD81-dISwzX9xj813hDGNcI-NecQxTX97z81ygfMEMM1xxDMOsM1xzrMKMM12z81-c4-NcISwTX9
xz816j815xDFNf3vPzXKB8wQwjXIEMw6wjXIOswowjXcPzX9-d8-Neo-NegQwzX98D81ygfMEME1
yRDMOsE1yTrMKME13T813QfBNeo-NcEuwTX9yD816j816RDBNf3xPzXKB8wQwDXKEMw6wDXKOswo
wDXMOsQ1yj813AfDNewuwzX9xz816j81-f3hPzXKB8wQNcsQzDo1yzrMKDXTOsM1xD813AfFNeg-
NS7FNf3HPzXpPzX9-d7_AIdRwT81ygfMNcwQzDXMOsw13z813AfFOsA16C7FNf3HPzXpPzX96v6r
UjbBNewPwzX98z813AfFOsE15T81LsU1-cc-Nek-Nf3pCsM16g-FNf3yPzXdB8M6wzXnLsM1-cg-
Nd0PxjXCPzX96ArFNekPxTX98j813gfBOsQ1zBDBNdM-NcEuwTX9yT813QrGNcI-Nf3oCsU16Q-F
Nf3yPzXgOsU1yxDDNf3kPzXpPzX96ArFNeoPwzX94hDJNcQ-NeE6wzXLEMU1zDvBNcA-Nf3PPzXp
PzX96QrDNewPwT81-fM-NeI6wTXMEMU1yzvDNf3RPzXpPzX96grBNfA-Nf3zPzXzEMU1PzU-NT81
PzU-NT87xT81PzU-NT81PzU-NT81PzU-NT81PzU-NT819T816T81-f3hPzX98z819BDDNcs7xTX9
0D816T81-f0gwTXa-rkAPsE-NdA-zDXMMcw1zB3MNdk-NfUQwTXMO8U-Nf3PPzXpPzX9-CDDNdgS
wzXPP8wdNcsxzBA1yx3MOjXZPzX9yTvDNf3RPzXpPzX9_yDFNdYSxTXNP8wdwDXKMcwQwDXKHcw6
wDXZPzX9yjvBNcA-Nf3PPzXdEsY1wj81-fsgxTXWEsU1zD-MHcE1yTHMEME1yR3MOsE12T81-f3h
PzXpPzX9_yDFNdYSxTXLP8wdwjXIMcwQwjXIHcw6wjXZPzX9zz81-c8-Nek-Nf38IMM12BLDNcs-
zB3DNccxzBDDNccdzDrDNdk-Nf394T816T81-f0gwTXaEsE-NcoxzB3ENcYdzBDENcb_5A2rzDrE
Ndk-Nf3PPzX9zz816T81zS7BNf06wTX9yz81yjHMHcQ1xh3MEMQ1xg-MOsQ12j81-f3fPzXqPzXM
LsM1_zrDNf3KPzXKMcwdxDXGHcwQxDXGD8w6xDXaPzX9zj81-c4-Neo-NcsuxTX5OsU1-ck-Ncox
zB3ENcYdzBDENcYPzDrENdo-Nf393z813jrGNcI-NcsuxTX5OsU1-ck-NcoxzB3ENcYdzBDENcYP
zDrENdo-Nf3OPzX9zj816j81yy7FNfk6xTX9yT81yjHMHcQ1xh3MEMQ1xg-MOsQ12j81-f3fPzXq
PzXMLsM1_zrDNf3KPzXKMcwdxDXGHcwQxDXGD8w6xDXaPzX9zj81-c4-Neo-Nc0uwTX9OsE1-cs-
NcoxzB3ENcYdzBDENcYPzDrENdo-Nf391DLBNcY-Neo-Nf394T81yjHMHcM1xx3MEMM1xw-MOsM1
3D81-c0-Nf3CMsM1xD816z81-e4twTXsPzXKMcwdwjXIHcwQwjXID8w6wjXdPzX9-dEyxTXDPzXr
PzX97S3DNes-NcoxzB3BNckdzBDBNckPzDrBNd4-Nf3NPzX9wTLFNcM-Nes-Nf3sLcU1yTnBNdw-
NcoxzB3ANcodzBDANcoPzDrANd8-Nf390TLFNcM-Nd8txjXCPzX95RvBNcItxTXIOcM12z81yjHM
HTXLHcwQNcsPzDo14T814ijBNeM-Nf3CMsM1wz817D81-eQbwzXBLcU1xznFNdo-NcoxzDXMHcw1
zA-MNeI-NeEowzX96DLBNcQ-NeA5xjXCPzX94xvFNcEtwzXIOcU12j81-fY-NeAoxTXhPzX9zD81
xDLANdgbxjXCPzX94xvFNcItwTXJOcU12j81-fY-NeAoxTX98D81xjLCNeA-Nf3jG8U10TnDNds-
Nf33PzXfKMU14T81-cs-NcsywTXdPzX95BvDNdM5wTXcPzX99z814CjDNf3wPzXOMsA12z81-eUb
wTX1PzX99z814SjBNf3xPzXtPzX9-eE-Nf34PzX9-dc-Ne4-Nf394T81-fg-Nf391z817j81-f3h
PzX9_D81-f3XPzXuPzX9-eE-NdA-zDXMO8w1zP6iiHnMNd8-Nf390SPBNT817z81-f3hPzXPP8wS
Ncs7zC41yxLMAzXfPzX9-dAjwz817z816APBNf3yPzXOP8wSwDXKO8wuwDXKEswDwDXgPzX9-c4j
xTXvPzXnA8M1-fE-Nc0-zBLBNck7zC7BNckSzAPBNeA-Nf39ziPFNe8-NeYDxTX98D81zD-MEsI1
yDvMLsI1yBLMA8I14T81-f3NI8U14wPGNcI-NeYDxTX98D81yz-MEsM1xzvMLsM1xxLMA8M12DvA
NcU-Nf39ziPDNfA-NeYDxTX98D81yjvMEsQ1xhLMLsQ1xi7MA8Q11jvANcg-Nf39ziPBNfE-NecD
wzXqKME1-cI-Nco7zBLENcYSzC7ENcYuzAPENdQ7wDXKPzX9-comwTXAPzXFIzXqPzXoA8E16ijD
Nf3BPzXKO8wSxDXGEswuxDXGLswDxDXSO8A1zT81-f3IJsM-NccjwDXoPzX92CjFNf3APzXKO8wS
xDXGEswuxDXGLswDxDXQO8A1zz81-f3HJsU1ySPANdooxjXCPzX92CjFNf3APzXKO8wSxDXGEswu
xDXGLswDxDXkPzXSIME1-e0mxTXLI8A15D81-dgoxTX9wD81yjvMEsQ1xhLMLsQ1xi7MA8Q15D81
0SDDNf3sJsU1zSPANeI-Nf3ZKMM1-cE-Nco7zBLENcYSzC7ENcYuzAPENeU-Nc8gxTX97CbDNdAj
NeE-Nf3aKME1-cI-Nco7zBLENcYSzC7ENcYuzAPENeY-Nc4gxTX97SbBNfU-Nf394T81yjvMEsM1
xxLMLsM1xy7MA8M15z81ziDFNf3uPzX2PzX9-eE-Nco7zBLCNcgSzC7CNcguzAPCNeEoNcU-Nc4g
wzX96f4Ah1HBNcA-NcYmNe4-Nf394T81yjvMEsE1yRLMLsE1yS7MA8E14CjANcc-Nc4gwTX96Q-D
PzXIJsA17D81-f3hPzXKO8wSwDXKEswuwDXKLswDwDXgKDXJPzX9_w-FNcomNes-Nf394T81yjvM
EjXLEswuNcsuzAM13yjANcs-Nf36D8U1yybANek-Nf394T81yjvMNcwSzDXMLsw13yg1zj81-fkP
xTXNJsA15z81-f3hPzX98SjANdA-Nf35D8M10CY1yz81wT811D81-f3hPzX98Cg10j81-foPwTXf
PzU-NT811D81-f3hPzX9-cg-Nf35PzXhP8M11D81-f3hPzX9-ck-Nf33PzX9PzX9-eE-Nf39yj81
-fU-NcYPNdo-NcE-NdQ-Nf394T81-f3LPzX98z81yA812T81wT811D81-f3hPzX9-cw-Nf3xPzXK
D8A12D-BNdU-Nf394T81-f3NPzX97z81zQ818T81-f3hPzXQKMw1zCjMNcwozDXyPzX97T81zw81
1j-CNdQ-Nf394T81zyjNNcsozTXLKM018z81-es-NdEPwDXTPzXYPzX9-eE-Nc4ozjXKKM41yijO
NeogNcc-NfY5wTXsPzXUDzXSP8M11D81-f3hPzXNKM81ySjPNckozzXpIDXJPzX0OcM16j81-cc-
Nf394T81zCjQNcgo0DXIKNA15yDANcs-wDXB-imt-8E16znFNec-wDXrP8M11D81-f3hPzXLKNE1
xyjRNcco0TXmIDXPPzUKwzXqOcU15j817T81PzXWPzX9-eE-Ncoo0jXGKNI1xijSNeUgNdEKxTXi
NsE1wjnFNeU-Ne4-wzXUPzX9-eE-Ncoo0jXGKNI1xijSNeMgwDXSCsU14TbDNcI5wzXkP8A1-cw-
Nf394T81yijSNcYo0jXGKNI14iA11ArFNeA2xTXCOcE15D818j-CNdQ-Nf394T81yijSNcYo0jXG
KNI1_grDNeE2xTXpP8A18j812D81-f3hPzXKKNI1xijSNcYo0jX7CsE1PzXgNsU16D819D-DNdQ-
Nf394T81yijSNcYo0jXGKNI1-cI-wDXfNsM15z-ANf3SPzX9-eE-Ncoo0jXGKNI1xijSNf3EP8A1
3jbBNeY-wDX3PzXBPzXUPzX9-eE-Ncoo0jXGKNI1xijSNf3GP8A1-cc-wDX5P8M11D81-f3hPzXK
KNE1xyjRNcco0TX6CjXKP8A19RXBNcc-wDX7PzXBPzXUP-394zXKKNA1yCjQNcgo0DX6CjXNP8A1
8hXDNcQ-wDX9-f39zSjPNckozzXJKM811z814Qo1zz-ANe8VxTXBP8A1-cE-wzX9-f3HKM41yijO
NcoozjXXP8E13wo10j-BNewVxT-BNf3DP8A1-f39yijNNcsozTXLKM011z-DNd0KNdY-wTXpFcU1
-cY-wzX9-f3HKMw1zCjMNcwozDXaPzXfCjXZP8I15T8VwzX96Ts1xy41zRI1yAMQNeM6NcYoBzXH
GzXC-qtSNjXBLTXMIDk1xTY1xjI1x-7kDas1wCwfNf3vPzXe-imt-zXeP8I13T-CNcAVwTX9yD-D
Nds7NccuNc0SNcgDEDXjOjXGKAc1xxs1wv6rUjY1wS01zCA5NcU2NcYyNccPNcAsHzX97z813f4p
rf814z-FNc8-xTX91T812zs1xy41zRI1yAMQNeM6NcYoBzXHGzXC-qtSNjXBLTXMIDk1xTY1xjI1
xw81wCwfNf3wPzXc-imt-zXqP881-dg-wjXcOzXHLjXNEjXIAxA14zo1xigHNccbNcL_q1I2NcEt
NcwgOTXFNjXGMjXHDzXALB81-fA-Ndv_Ka3-Nf39_js1xy41zRI1yAMQNeM6NcYoBzXHGzXC-qtS
NjXBLTXMIDk1xTY1xjI1xw81wCwfNf3wPzX9-fo-Nds7NccuNc0SNcgDEDXjOjXGKAc1xxs1wgo1
wS01zCA5NcU2NcYyNccPNcAsHzX98T81-ewVNf3KPzXbOzXHLjXNEjXIAxA14zo1xigHNccbNcIK
NcEtNcwgOTXFNjXGMjXHDzXALB81-cE-0zXZPzX97BU1-cY-wzXbOzXHLjXNEjXIAxA14zo1xigH
NccbNcIKNcEtNcwgOTXFNjXGMjXHDzXALB81-cA-NdM-Ndk-Nf3rFTX9-f39-cg-NdU-Ndk-Nf3r
FTX9-f39-cc-NcE-wDU-NcE-wTU-wTU-wDXBPzXaPzX9yjY1yTk10RU1-f39-f3HPzXAPzXBPzXB
PzXBPzU-NT81PzXAPzXbP8A1xD81-cE2Nck5NdEVNf3HPzX9-f37PzXAPzXBPzXBP8A1wD-BNT-A
NcE-Nd0-wTXBP8A1-cA2Nck5NdEVNf3GP8E1-f39_j81wD81wT81wT81wT81PzU-NT81wD814D-E
Nf02Nck5NdEVNf3FP8M1-f39_T81wT-ANT-BNT-BNT81PzU-NT81wD814z-ANf3ANjXJOTXSFTX9
xj81-f39_z811T814z81-cE2Nck5NdIVNf3GPzX9-f38PzXTPzX96DY1yjk10RU1-cY-Nf39-f0-
0zXRPzU-NT81PzU-wTX9yzY1yjk1-do-NcM-NcQ-wDU-wTU-wTU-NT81P8E1P8E1P8E1P8E1wD-A
NT-ANf39-fQ-NT81PzU-NT81-c02Nco5Nf3aPzXDP8A1wj81wT81PzXAPzXAPzU-NT81PzU-NT81
wD81wT81wD81PzU-NT81-f398z-BNT81PzU-wDX9zDY1yjk1-do-xzXBP8E1P8E1wD81wD81PzU-
wDXAP8E1wD81wT81wD81PzU-NT81-f398z81PzU-NT81PzX9zTY1yjk1-eA-wDXEPzU-NT81wD81
wD81PzU-NT81PzU-NcA-NcE-NcA-NT81PzU-Nf39-fM-NT81wD-ANT-BNf39_z81wz-ANcA-NT81
wD81wT-ANT81PzU-NT81wD81wD-BNT-ANcA-NT81-f39-f39-f39-f3dAAAAAAAAAAE=
:: main.lua
--[[pod_format="raw",created="2024-03-31 05:33:06",modified="2025-03-11 12:47:46",revision=7635]]
include "src/globals.lua"
include "src/oklab.lua"
include "src/palette.lua"
include "src/settings.lua"
include "src/files.lua"
include "src/integration.lua"
include "src/soft_wrap.lua"
include "src/gui.lua"
include "src/gui_palette.lua"
include "src/gui_sliders.lua"
include "src/gui_new_sliders.lua"
include "src/gui_alt_sliders.lua"
include "src/gui_settings.lua"
include "src/gui_help.lua"
include "src/gui_newfile.lua"
include "src/gui_hexdialog.lua"


function _init()
	load_settings()
	
	register_as_default_app()

	window {
		tabbed = true,
		icon = --[[pod_type="gfx"]]unpod("b64:bHo0ABYAAAAUAAAA8AVweHUAQyAICARwtyBHIBcgRyC3cA=="),
	}
	
	local working_file_path = env()[1]
	if type(working_file_path) ~= "string" then
		mkdir("/ram/cart/pal")
		working_file_path = "/ram/cart/pal/0.pal"
	end

	wrangle_working_file(
		save_working_file,
		load_working_file,
		working_file_path
	)
	
	-- Force the 11 first rows of the screen to use a default palette,
	-- so that the menu bar stays readable even when the colors used by
	-- the gui are redefined.
	poke(0x5400, 0b01010101, 0b01010101, 0b00010101)
	
	rebuild_pal()
	
	on_event("gained_visibility", function() send_palette() end)
		
	on_event("drop_items", handle_drop_items)
	
	undo_stack = create_undo_stack(undo_save_state, undo_load_state)

	menuitem { id = "okpal_div1", label = "", divider = true, action = function() end }
	menuitem {
		id = "okpal_reset_colors",
		label = "\^:0000000000000000 Picotron Palette",
		action = function() undo_stack:checkpoint(); restore_default_palette() end
	}
	menuitem {
		id = "okpal_clear_colors",
		label = "\^:0000000000000000 Empty Palette",
		action = function() undo_stack:checkpoint(); clear_colors() end
	}
	menuitem { id = "okpal_div2", label = "", divider = true, action = function() end }
	menuitem {
		id = "okpal_manual",
		label = "\^:0000000000000000 Help",
		shortcut = "F1",
		action = open_help
	}
	
	test_cube_colors = test_cube_colors or copy(default_test_cube_colors)
	test_ramp_colors = test_ramp_colors or default_test_ramp_colors:convert("u8")
	generate_gui()
	
	if is_new_file then
		open_new_file_dialog()
	end
	
	if imported_hex_file then
		open_import_hex_file_dialog()
	end
end


function _draw()
	cls(bg_color)
	gui:draw_all()
	blinked()
end


function _update()
	if padlock_flashing then
		padlock_flashing_time += 1
	end
	if crying_a_timer > 0 then
		crying_a_timer -= 1
	end
	
	if gui_changed then
		generate_gui()
		gui_changed = false
	end
	gui:update_all()
	
	if key("ctrl") then
		if keyp("c") then copy_color() end
		if keyp("x") then cut_color() end
		if keyp("v") then paste_color() end
		if keyp("z") then undo_stack:undo() end
		if keyp("y") then undo_stack:redo() end
	end
	
	if keyp("f1") then open_help() end
	
	if keyp("tab") then
		hue_mode = (hue_mode == "hue+sat") and "hue+lum" or "hue+sat"
		gui_changed = true
	end
end




-- Undo ---------------------------------------------------------------------------


function undo_save_state(_item)
	return {
		pal_okhsl = copy(pal_okhsl),
		pal_code = copy(pal_code),
		test_cube_colors = copy(test_cube_colors),
		test_ramp_colors = test_ramp_colors and test_ramp_colors:convert("u8"),
	}
end


function undo_load_state(state, _item)
	pal_okhsl = state.pal_okhsl
	pal_code = state.pal_code
	test_cube_colors = state.test_cube_colors
	test_ramp_colors = state.test_ramp_colors
	for c = 0, 63 do
		set_color(c, pal_code[c])
	end
	send_palette()
end


function copy(t)
	if type(t) == "table" then
		local new = {}
		for k, v in pairs(t) do
			new[k] = copy(v)
		end
		return new
	else
		return t
	end
end


-- Copy and paste ----------------------------------------------------------------


function copy_color()
	if active_color then
		set_clipboard("#" .. color_to_hex(get_color(active_color)))
	end
end


function cut_color()
	if active_color then
		set_clipboard("#" .. color_to_hex(get_color(active_color)))
		if not locked[active_color] then
			 undo_stack:checkpoint()
			change_color_code(active_color, 0x000000)
		end
	end
end


function paste_color()
	if not active_color then
		notify("unable to paste: no selected color")
		return
	end
	if locked[active_color] then
		notify("unable to paste: selected color is locked")
		return
	end
	local cb = get_clipboard()
	if type(cb) == "string" then
		local hex = string.gsub(cb, "%s", "")
		if sub(hex, 1, 1) == "#" then
			hex = sub(hex, 2, -1)
		end
		local code = tonumber("0x" .. hex)
		if type(code) == "number" then
			undo_stack:checkpoint()
			change_color_code(active_color, code)
		else
			notify("unable to paste: unrecognized string: \"" .. cb .."\"")
		end
	else
		notify("unable to paste: type not supported (" .. type(cb) .. ")")
	end
end

:: manual.txt
--[[pod_format="raw",created="2024-04-04 06:47:16",icon=userdata("u8",16,16,"00000101010101010101010101000000000106060606060606060606060100000107010606060606060606060606010000010106060707070707070707060100000106060607070707060606070601000107010606070707070606060706010000010106060706060607070707060100000106060607060606070707070601000107010606070707070707070706010000010106060606060606060606060100000106060606060606060606060601000107010606060606060606060601010000010101010101010101010101070100000101070707070707070707070601000000010606060606060606060601000000000001010101010101010101000000"),modified="2025-03-08 10:15:57",revision=440,stored="2024-04-04 06:56:33"]]
# OkPal

OkPal is a tool to create and edit color palettes. You can easily use those palettes in your programs, and even directly in Picotron's sprite and map editors.

To use a palette in your programs:

```
    fetch("pal/0.pal"):poke(0x5000)
```


## Features

- Any change to the palette is propagated to
  Picotron's sprite and map editors.
- Use a perceptually uniform color space (oklab).
- Choose colors by hue, saturation and lightness.
- Reorder colors by drag-and-drop.
- Undo/redo.
- Supports two file formats: ".hex" and ".pal"
- Multiple options for importing external palettes
  (keep default palette, overwrite it, or try to 
  match it)


## Usage

The tool shows you four different views of the 64
colors in the current palette:

- at the top-left of the screen, the colors are
  shown in palette order (same as in sprite editor
  first tab);
- below, on the left, the colors are shown inside
  a circle picker: the angle correspond to the hue,
  and the distance from the center correspond to the
  saturation;
- in the middle the colors are shown as inside a
  square picker: the X axis correspond to the
  saturation, and the Y axis correspond to the
  lightness;
- finally, on the right is a "test zone", where
  you can use 24 paintable cubes to test color
  combinations.

To modify a color, you must first select it. You can
do that either by clicking in the palette overview
at the top of the screen, or by clicking directly on
one of the color dots in the circle picker or in the
square picker.

Once selected, some information about the color are
displayed on the right of the palette overview:

- the color number;
- the hex code corresponding to the RGB values of
  the color;
- a padlock icon: if the padlock is closed, the color
  is "locked" and cannot be edited; click on the icon
  to lock/unlock it;
- an eye icon: if the eye is closed, the color is only
  shown in the palette overview; it is hidden in the
  circle and square pickers.
- a paint bucket icon: you can click on it to change
  the color background to the current selected color;
  click again to go back to a black background.

You can copy the current color by using Ctrl-C, and
paste a copied color onto the current one by using
Ctrl-V. This also works outside OkPal: the color is
stored in the clipboard as a hex code ("#ffacc5").

There is five different ways to adjust the selected
color:

- a small colored circle *outside* the circle picker
  allows you to change the hue of the color;
- a small colored circle *inside* the circle picker
  allows you to change at the same time the hue and
  the saturation;
- a small colored triangle below the square picker
  allows you to change just the saturation;
- a small colored triangle at the right of the square
  picker allows you to change the lightness;
- finally, a small colored circle inside the square
  picker allows you to change at the same time the
  saturation and the lightness.

Any change you make can be reverted by hitting
Ctrl-Z for undo. Use Ctrl-Y for redo.

Once you have several colors in you palettes, you can
reorder them in the palette overview: just drag one
color onto another, they will swap their positions.
Note that both colors must be unlocked.


## Using the palette in cartridges

By default, the palette you edit is saved in the
cart you're working on, alongside your sprite sheets
and maps.

The default path is "/ram/cart/pal/0.pal"

In order to use a palette in your programs, you just
need to copy it in memory. The default palette is
stored at address 0x5000:

```
    fetch("pal/0.pal"):poke(0x5000)
```


## Loading and saving

If you only need one palette for your cart, you
don't need to do anything special to save it. It is
saved alongside the rest of your assets each time
you hit Ctrl-S.

In order to create a new palette, use the '+' button
at the right of the tabs and choose the name of your
new palette, for example "1.pal". If you need to
start from scratch for this new palette, use
"Empty Palette" or "Picotron Palette" from the menu.

You can load a previously created palette by using
"Open File" in the menu.


## Importing and exporting

You can import and export palettes for use with
external tools. Currently the only supported format
is ".hex" files, which are simple text files with one
line per color, represented by their RGB code in hex
format (without "#" or "0x", just the hexadecimal
numbers).

To import a palette, choose "Open File" from the
menu, and select the ".hex" file. If this is the first
time you open this external palette in OkPal, a
dialog will appear to let you choose how to arrange
the colors in the palette. You can either:

- Keep default Picotron palette in the first 32 colors,
  and put the imported colors in the last 32 slots.
- Completely remove the Picotron palette and import
  the whole palette, but reorder the colors to try
  to match the default colors.
- Or simply import the palette as is. Note that this
  will affect the interface and probably make it
  difficult to use the menu, the sprite editor and
  the map editor.

To export a palette, choose "Save File As" in the
menu. In the save dialog, enter a file name ending
in ".hex".


## Changelog

2025-03-08: version 1.1.0 (release #okpal-8)

- removed remapping option when importing ".hex" palettes (was not working very well anyway);
- added text entries for the hex code, the hue, the saturation and the luminance;
- added a new tab for drawing color ramps in the test zone;
- added dialog when creating a new palette (to choose between empty palette or default colors);
- added settings dialog;
- added settings to register OkPal as default app for ".pal" and ".hex" files;
- added settings for disabling the propagation of the palette to the sprite and map editors;
- added blink;
- changed dialog when importing ".hex" files;
- changed dialog for displaying help;
- fixed menu bar colors when default colors are redefined;
- fixed undo/redo of test cube color changes;

2025-02-26: version 1.0.4 (release #okpal-7)

- added registering as default app for ".pal" and ".hex" (needed for the file dialog?)
- added undo/redo and help buttons;
- added "clear" button to the "test cubes";
- added legends for the two pickers;
- changed: moved the luminance slider to the left of the sat/lum picker for consistency;
- fixed: palette is now propagated to all gfx and map editors (thanks to Eiyeron for the implementation);
- fixed: the "test cubes" saved in metadata where not properly loaded;


2024-08-23: version 1.0.3 (release #okpal-6)

- added: add file icon to saved palettes;
- changed: can load and import palettes by
  double-clicking in the file dialog (no need
  to drag-and-drop anymore);
- fixed: bug in BBS;

2024-05-03: version 1.0.2 (release #okpal-5)

- fixed: bug while using "+" button in Picotron
  0.1.0g;
- changed: disabled tabs in BBS, as it prevents
  the cart from running;

2024-04-27: version 1.0.1 (release #okpal-4)

- fixed: picotron's palette was not locked in the
  default file on first opening;
- fixed: saving a ".pal" file from an imported
  ".hex" file was not working;
- explain how to export to .hex in the manual;

2024-04-06: version 1.0.0 (release #okpal-3)

- propagate palette to sprite and map editors;
- undo/redo;
- reorder colors by drag-and-drop;
- import dialog;
- reorder imported colors to match default colors;
- added a manual;
- menu entries to initialize the palette and open
  the manual;
- flash padlock icon when trying to edit a locked
  color;
- shift-click paint-bucket icon to change the "white"
  color used in the interface, and ctrl-click the
  icon to change the "black" (useful when importing
  external palettes);

2024-04-02: version 0.0.3 (release #okpal-2)

- Added the ability to change the background color (by clicking on the small paint bucket icon), and switched the default background to black.
- Added the ability to import ".hex" files (using drag and drop from the "Open File" dialog); to actually create the ".pal" file, you need to save.
- Improved the color pickers.
- Added the ability to copy/paste colors (using a hex string starting with #).
- Added the ability to show/hide individual colors (right click on a color in the palette).

2024-04-01: v0.0.1 (release #okpal-1)

- Added the ability to lock colors, to avoid accidentally modifying them. By default the first 33 colors are locked (click on the padlock to unlock)
- Added the ability to hide specific rows of color from the two color pickers.
- Added sliders to change the individual components (hue, saturation and luminance).
- Added the ability to select a color by clicking on their dot in the color pickers.
- Added a test zone, with 24 paintable cubes (click on a cube face to change its color).


:: todo.txt
--[[pod_format="raw",created="2024-03-31 20:08:43",modified="2025-03-07 09:36:51",revision=884]]
- right click for fine-tuning colors;

Maybe:
- in-app gui for manual?
- multi-selection (ability to move a group of
  colors in the sliders)
- editing tools for multi-selection;
- Add another tab in the test zone, with the 
  hue/sat circle and sat/lum square, but filles
  with color zones instead of dots.
- remove locking mechanism?
- import the palette from an image saved by
  the #paint cartridge;

:: .info.pod
b64$LS1bW3BvZCxhdXRob3I9ImRyYWttYW5pc28iLGJic19pZD0iX2Rldjk3MiIsY3JlYXRlZD0i
MjAyNC0wNC0yNyAxMjozMDo1NCIsaWNvbj11c2VyZGF0YSgidTgiLDE2LDE2LCIwMDAwMDAwMTAx
MDEwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDAw
MTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwNzAxMDAwMTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwZDBk
MDcwMTAxMDcwZDBkMDEwMTA2MDYwNzA3MDYwNjBkMGQwNzAxMDEwNzBkMGQwMTAxMDYwNjA3MDcw
NjA2MGQwZDA3MDEwMTA3MGQwZDA2MDYwZDBkMDEwMTA3MDcwZDBkMDcwMTAxMDcwZDBkMDYwNjBk
MGQwMTAxMDcwNzBkMGQwNzAxMDEwNzBkMGQwNzA3MDYwNjA3MDcwMTAxMGQwZDA3MDEwMTA3MGQw
ZDA3MDcwNjA2MDcwNzAxMDEwZDBkMDcwMTAxMDcwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwNzAx
MDEwNjA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwNzA2MDEwMTA2MDYwNzA3MDcwNzA3MDcwNzA3MDcw
NzA2MDYwMTAwMDEwNjA2MDYwNjA2MDYwNjA2MDYwNjA2MDYwMTAwMDAwMDAxMDYwNjA2MDYwNjA2
MDYwNjA2MDYwMTAwMDAwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAwMDAwMCIpLG1vZGlmaWVk
PSIyMDI1LTAzLTExIDEyOjQ3OjQ2Iixub3Rlcz0iUGFsZXR0ZSBFZGl0b3Jcbih1c2UgbWVudSB0
byBvcGVuIHRoZSBtYW51YWwpIixydW50aW1lPTE0LHNhbmRib3g9ZmFsc2Usc3RvcmVkPSIyMDI0
LTA0LTE0IDEwOjMwOjA0Iix0aXRsZT0iT2tQQUwiLHZlcnNpb249IjEuMC4zIix3b3Jrc3BhY2Vz
PXt7bG9jYXRpb249InNyYy9nbG9iYWxzLmx1YSMyNiIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2Nh
dGlvbj0ibWFpbi5sdWEjMTIiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InNyYy9ndWku
bHVhIzI5NiIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ic3JjL2d1aV9wYWxldHRlLmx1
YSM4Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJzcmMvZ3VpX25ld19zbGlkZXJzLmx1
YSM0NzQiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InNyYy9ndWlfYWx0X3NsaWRlcnMu
bHVhIzE1NSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ic3JjL2ZpbGVzLmx1YSMxNyIs
d29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ic3JjL2d1aV9oZXhkaWFsb2cubHVhIzM0Iix3
b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJnZngvMC5nZngiLHdvcmtzcGFjZV9pbmRleD0y
fSx7bG9jYXRpb249Im1hcC8wLm1hcCIsd29ya3NwYWNlX2luZGV4PTN9LHtsb2NhdGlvbj0ic2Z4
LzAuc2Z4Iix3b3Jrc3BhY2VfaW5kZXg9NH0se2xvY2F0aW9uPSJwYWwvMS5wYWwiLHdvcmtzcGFj
ZV9pbmRleD03fSx7bG9jYXRpb249InBhbC8wLnBhbCIsd29ya3NwYWNlX2luZGV4PTd9fV1d
:: [eoc]
