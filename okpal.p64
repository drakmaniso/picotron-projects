picotron cartridge // www.picotron.net
version 2

:: gfx/
:: map/
:: sfx/
:: exports/
:: pal/
:: exports/lib/
:: exports/lib/oklab.lua
--[[pod_format="raw",created="2024-03-31 09:08:26",modified="2024-04-02 08:30:12",revision=966]]
-- Copyright(c) 2021 Bjorn Ottosson
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of
-- this software and associated documentation files(the "Software"), to deal in
-- the Software without restriction, including without limitation the rights to
-- use, copy, modify, merge, publish, distribute, sublicense, and /or sell copies
-- of the Software, and to permit persons to whom the Software is furnished to do
-- so, subject to the following conditions:
--
-- The above copyright noticeand this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

oklab = {}
oklab.__index = oklab

function oklab.color_to_okhsl(code)
	local srgb = {
		r = ((code & 0xff0000) >> 16) / 255,
		g = ((code & 0x00ff00) >> 8) / 255,
		b = ((code & 0x0000ff)) / 255,
	}
	return oklab.srgb_to_okhsl(srgb)
end

function oklab.okhsl_to_color(okhsl)
	local srgb = oklab.okhsl_to_srgb(okhsl)
	local r = mid(0x00, math.floor(srgb.r * 255 + 0.5), 0xff)
	local g = mid(math.floor(srgb.g * 255 + 0.5), 0xff)
	local b = mid(math.floor(srgb.b * 255 + 0.5), 0xff)
	return (r << 16) | (g << 8) | b
end

function oklab.new()
    local inst = setmetatable({}, oklab)
    return inst
end

-- Finds the maximum saturation possible for a given hue that fits in sRGB
-- Saturation here is defined as S = C/L
-- a and b must be normalized so a^2 + b^2 == 1
function oklab.compute_max_saturation(a, b)
    if a ~= 0.0 or b ~= 0.0 then
    	-- Max saturation will be when one of r, g or b goes below zero.
        -- Select different coefficients depending on which component goes below zero first

        -- Blue component (default)
        local k0 = 1.35733652
        local k1 = -0.00915799
        local k2 = -1.1513021
        local k3 = -0.50559606
        local k4 = 0.00692167
        local wl = -0.0041960863
        local wm = -0.7034186147
        local ws = 1.707614701

        if -1.88170328 * a - 0.80936493 * b > 1 then
            -- Red component
            k0 = 1.19086277
            k1 = 1.76576728
            k2 = 0.59662641
            k3 = 0.75515197
            k4 = 0.56771245
            wl = 4.0767416621
            wm = -3.3077115913
            ws = 0.2309699292
        elseif 1.81444104 * a - 1.19445276 * b > 1 then
            -- Green component
            k0 = 0.73956515
            k1 = -0.45954404
            k2 = 0.08285427
            k3 = 0.1254107
            k4 = 0.14503204
            wl = -1.2684380046
            wm = 2.6097574011
            ws = -0.3413193965
        end

        -- Approximate max saturation using a polynomial:
        local S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b

        -- Do one step Halley's method to get closer
        -- this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite
        -- this should be sufficient for most applications, otherwise do two/three steps

        local k_l = 0.3963377774 * a + 0.2158037573 * b
        local k_m = -0.1055613458 * a - 0.0638541728 * b
        local k_s = -0.0894841775 * a - 1.291485548 * b

        do
            local l_ = 1.0 + S * k_l
            local m_ = 1.0 + S * k_m
            local s_ = 1.0 + S * k_s

            local l = l_ * l_ * l_
            local m = m_ * m_ * m_
            local s = s_ * s_ * s_

            local l_dS = 3.0 * k_l * l_ * l_
            local m_dS = 3.0 * k_m * m_ * m_
            local s_dS = 3.0 * k_s * s_ * s_

            local l_dS2 = 6.0 * k_l * k_l * l_
            local m_dS2 = 6.0 * k_m * k_m * m_
            local s_dS2 = 6.0 * k_s * k_s * s_

            local f = wl * l + wm * m + ws * s
            local f1 = wl * l_dS + wm * m_dS + ws * s_dS
            local f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2

            local s_denom = f1 * f1 - 0.5 * f * f2
            if s_denom ~= 0.0 then  S = S - f * f1 / s_denom end
        end

        return S
    else
        return 0.0
    end
end

-- finds L_cusp and C_cusp for a given hue
-- a and b must be normalized so a^2 + b^2 == 1
function oklab.find_cusp(a, b)
	-- First, find the maximum saturation (saturation S = C/L)
    local S_cusp = oklab.compute_max_saturation(a, b)

    -- Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:
    local rgb_at_max = oklab.oklab_to_linear_srgb({L = 1, a = S_cusp * a, b = S_cusp * b })
    local max_comp = math.max(rgb_at_max.r, rgb_at_max.g, rgb_at_max.b)
    if max_comp ~= 0.0 then
        local L_cusp = (1.0 / max_comp) ^ 0.3333333333333333
        return { L = L_cusp, C = L_cusp * S_cusp }
    else
        return { L = 0.0, C = 0.0 }
    end
end

-- Finds intersection of the line defined by
-- L = L0 * (1 - t) + t * L1
-- C = t * C1
-- a and b must be normalized so a^2 + b^2 == 1
function oklab.find_gamut_intersection(a, b, L1, C1, L0, x)
    -- Find the cusp of the gamut triangle
    local cusp = x or oklab.find_cusp(a, b)

    -- Find the intersection for upper and lower half separately
    local t = 0.0
    if ((L1 - L0) * cusp.C - (cusp.L - L0) * C1) <= 0.0 then
        -- Lower half
        local t_denom = C1 * cusp.L + cusp.C * (L0 - L1)
        if t_denom ~= 0.0 then t = cusp.C * L0 / t_denom end
    else
        -- Upper half
        -- First intersect with triangle
        local t_denom = C1 * (cusp.L - 1.0) + cusp.C * (L0 - L1)
        if t_denom ~= 0.0 then t = cusp.C * (L0 - 1.0) / t_denom end

        -- Then one step Halley's method
        do
            local dL = L1 - L0
            local dC = C1

            local k_l = 0.3963377774 * a + 0.2158037573 * b
            local k_m = -0.1055613458 * a - 0.0638541728 * b
            local k_s = -0.0894841775 * a - 1.291485548 * b

            local l_dt = dL + dC * k_l
            local m_dt = dL + dC * k_m
            local s_dt = dL + dC * k_s

            -- If higher accuracy is required, 2 or 3 iterations of the following block can be used:
            do
                local L = L0 * (1.0 - t) + t * L1
				local C = t * C1

				local l_ = L + C * k_l
				local m_ = L + C * k_m
				local s_ = L + C * k_s

				local l = l_ * l_ * l_
				local m = m_ * m_ * m_
				local s = s_ * s_ * s_

				local ldt = 3.0 * l_dt * l_ * l_
				local mdt = 3.0 * m_dt * m_ * m_
				local sdt = 3.0 * s_dt * s_ * s_

				local ldt2 = 6.0 * l_dt * l_dt * l_
				local mdt2 = 6.0 * m_dt * m_dt * m_
				local sdt2 = 6.0 * s_dt * s_dt * s_

                local r0 = 4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s - 1
				local r1 = 4.0767416621 * ldt - 3.3077115913 * mdt + 0.2309699292 * sdt
				local r2 = 4.0767416621 * ldt2 - 3.3077115913 * mdt2 + 0.2309699292 * sdt2

                local r_denom = r1 * r1 - 0.5 * r0 * r2
                local u_r = 0.0
                if r_denom ~= 0.0 then u_r = r1 / r_denom end
				local t_r = -r0 * u_r

                local g0 = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s - 1
				local g1 = -1.2684380046 * ldt + 2.6097574011 * mdt - 0.3413193965 * sdt
				local g2 = -1.2684380046 * ldt2 + 2.6097574011 * mdt2 - 0.3413193965 * sdt2

                local g_denom = g1 * g1 - 0.5 * g0 * g2
                local u_g = 0.0
                if g_denom ~= 0.0 then u_g = g1 / g_denom end
				local t_g = -g0 * u_g

                local b0 = -0.0041960863 * l - 0.7034186147 * m + 1.707614701 * s - 1
				local b1 = -0.0041960863 * ldt - 0.7034186147 * mdt + 1.707614701 * sdt
				local b2 = -0.0041960863 * ldt2 - 0.7034186147 * mdt2 + 1.707614701 * sdt2

                local b_denom = (b1 * b1 - 0.5 * b0 * b2)
                local u_b = 0.0
                if b_denom ~= 0.0 then u_b = b1 / b_denom end
				local t_b = -b0 * u_b

                if u_r < 0.0 then t_r = 3.40282347e+38 end
                if u_g < 0.0 then t_g = 3.40282347e+38 end
                if u_b < 0.0 then t_b = 3.40282347e+38 end

                t = t + math.min(t_r, t_g, t_b)
            end
        end
    end

    return t
end

function oklab.get_Cs(L, a_, b_)
    local cusp = oklab.find_cusp(a_, b_)
    local C_max = oklab.find_gamut_intersection(a_, b_, L, 1.0, L, cusp)
    local ST_max = oklab.to_ST(cusp)

    -- Scale factor to compensate for the curved part of gamut shape:
    local k = 0.0
    local k_denom = math.min(L * ST_max.S, (1.0 - L) * ST_max.T)
    if k_denom ~= 0.0 then k = C_max / k_denom end

    local C_mid = 0.0
    do
        local ST_mid = oklab.get_ST_mid(a_, b_)

        -- Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.
        local C_a = L * ST_mid.S
        local C_b = (1.0 - L) * ST_mid.T

        local cae4 = C_a * C_a * C_a * C_a
        local cbe4 = C_b * C_b * C_b * C_b
        C_mid = 0.9 * k * ((1.0 / (1.0 / cae4 + 1.0 / cbe4)) ^ 0.25)
    end

    local C_0 = 0.0
    do
        -- for C_0, the shape is independent of hue, so ST are constant. Values picked to roughly be the average values of ST.
        local C_a = L * 0.4
        local C_b = (1.0 - L) * 0.8

        -- Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.
        local cae2 = C_a * C_a
        local cbe2 = C_b * C_b
        C_0 = math.sqrt(1.0 / (1.0 / cae2 + 1.0 / cbe2))
    end

    return { C_0 = C_0, C_mid = C_mid, C_max = C_max }
end

-- Returns a smooth approximation of the location of the cusp
-- This polynomial was created by an optimization process
-- It has been designed so that S_mid < S_max and T_mid < T_max
function oklab.get_ST_mid(a_, b_)
    local S = 0.11516993
    local s_denom = 7.4477897 + 4.1590124 * b_
        + a_ * (-2.19557347 + 1.75198401 * b_
        + a_ * (-2.13704948 - 10.02301043 * b_
        + a_ * (-4.24894561 + 5.38770819 * b_ + 4.69891013 * a_)))
    if s_denom ~= 0.0 then
        S = 0.11516993 + 1.0 / s_denom
    end

    local T = 0.11239642
    local t_denom = 1.6132032 - 0.68124379 * b_
        + a_ * (0.40370612 + 0.90148123 * b_
        + a_ * (-0.27087943 + 0.6122399 * b_
        + a_ * (0.00299215 - 0.45399568 * b_ - 0.14661872 * a_)))
	if t_denom ~= 0.0 then
        T = 0.11239642 + 1.0 / t_denom
    end

	return { S = S, T = T }
end

function oklab.linear_srgb_to_oklab(c)
    local l = 0.4122214708 * c.r
            + 0.5363325363 * c.g
            + 0.0514459929 * c.b
	local m = 0.2119034982 * c.r
            + 0.6806995451 * c.g
            + 0.1073969566 * c.b
	local s = 0.0883024619 * c.r
            + 0.2817188376 * c.g
            + 0.6299787005 * c.b

    local l_ = l ^ 0.3333333333333333
    local m_ = m ^ 0.3333333333333333
    local s_ = s ^ 0.3333333333333333

    return {
        L = 0.2104542553 * l_
          + 0.793617785 * m_
          - 0.0040720468 * s_,
        a = 1.9779984951 * l_
          - 2.428592205 * m_
          + 0.4505937099 * s_,
        b = 0.0259040371 * l_
          + 0.7827717662 * m_
          - 0.808675766 * s_ }
end

function oklab.okhsl_to_oklab(hsl)
	local l = hsl.l
    if l >= 1.0 then return { L = 1.0, a = 0.0, b = 0.0 } end
    if l <= 0.0 then return { L = 0.0, a = 0.0, b = 0.0 } end

    local s = hsl.s
    if s < 0.0 then s = 0.0 end
    if s > 1.0 then s = 1.0 end

    local h = hsl.h
    local h_rad = h * 6.283185307179586
    local a_ = math.cos(h_rad)
    local b_ = math.sin(h_rad)
    local L = oklab.toe_inv(l)

    local cs = oklab.get_Cs(L, a_, b_)
    local C_0 = cs.C_0
	local C_mid = cs.C_mid
	local C_max = cs.C_max

    local mid = 0.8
	local mid_inv = 1.25

    local C = 0.0
    local t = 0.0
    local k_0 = 0.0
    local k_1 = 0.0
    local k_2 = 0.0
    if s < mid then
        t = mid_inv * s

		k_1 = mid * C_0
        if C_mid ~= 0.0 then
		    k_2 = 1.0 - k_1 / C_mid
        end

        local k_denom = 1.0 - k_2 * t
		if k_denom ~= 0.0 then
            C = t * k_1 / k_denom
        end
    else
        local t_denom = 1.0 - mid
        if t_denom ~= 0.0 then
            t = (s - mid) / t_denom
        end

		k_0 = C_mid
        if C_0 ~= 0.0 then
		    k_1 = (1.0 - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0
        end

        local C_denom = C_max - C_mid
		k_2 = 1.0
        if C_denom ~= 0.0 then
            k_2 = 1.0 - k_1 / C_denom
        end

        local k_denom = 1.0 - k_2 * t
        if k_denom ~= 0.0 then
		    C = k_0 + t * k_1 / k_denom
        end
    end

    return {
        L = L,
        a = C * a_,
        b = C * b_ }
end

function oklab.okhsl_to_srgb(hsl)
    return oklab.oklab_to_srgb(oklab.okhsl_to_oklab(hsl))
end

function oklab.okhsv_to_oklab(hsv)
	local v = hsv.v
    if v <= 0.0 then return { L = 0.0, a = 0.0, b = 0.0 } end
    if v > 1.0 then v = 1.0 end

    local s = hsv.s
    if s < 0.0 then s = 0.0 end
    if s > 1.0 then s = 1.0 end

    local h = hsv.h
    local h_rad = h * 6.283185307179586
    local a_ = math.cos(h_rad)
    local b_ = math.sin(h_rad)

    local cusp = oklab.find_cusp(a_, b_)
	local ST_max = oklab.to_ST(cusp)
	local S_max = ST_max.S
	local T_max = ST_max.T
	local S_0 = 0.5
    local k = 1.0
    if S_max ~= 0.0 then
	    k = 1.0 - S_0 / S_max
    end

    -- first we compute L and V as if the gamut is a perfect triangle:

	-- L, C when v==1:
    local v_denom = S_0 + T_max - T_max * k * s
    local L_v = 1.0
    local C_v = 0.0
    if v_denom ~= 0.0 then
        L_v = 1.0 - s * S_0 / v_denom
	    C_v = s * T_max * S_0 / v_denom
    end

    local L = v * L_v
	local C = v * C_v

    --then we compensate for both toe and the curved top part of the triangle:
    local L_vt = oklab.toe_inv(L_v)
    local C_vt = 0.0
    if L_v ~= 0.0 then
        C_vt = C_v * L_vt / L_v
    end

    local L_new = oklab.toe_inv(L)
    if L ~= 0.0 then
        C = C * L_new / L
    end
    L = L_new

    local rgb_scale = oklab.oklab_to_linear_srgb({
        L = L_vt,
        a = a_ * C_vt,
        b = b_ * C_vt })
    local max_comp = math.max(
        rgb_scale.r,
        rgb_scale.g,
        rgb_scale.b, 0.0)
    local scale_L = 0.0
    if max_comp ~= 0.0 then
        scale_L = (1.0 / max_comp) ^ 0.3333333333333333
    end

	C = C * scale_L
    return {
        L = L * scale_L,
        a = C * a_,
        b = C * b_ }
end

function oklab.okhsv_to_srgb(hsv)
    return oklab.oklab_to_srgb(oklab.okhsv_to_oklab(hsv))
end

function oklab.oklab_to_linear_srgb(lab)
    local l_ = lab.L
        + 0.3963377774 * lab.a
        + 0.2158037573 * lab.b
	local m_ = lab.L
        - 0.1055613458 * lab.a
        - 0.0638541728 * lab.b
	local s_ = lab.L
        - 0.0894841775 * lab.a
        - 1.291485548 * lab.b

    local l = l_ * l_ * l_
    local m = m_ * m_ * m_
    local s = s_ * s_ * s_

    return {
        r = 4.0767416621 * l
          - 3.3077115913 * m
          + 0.2309699292 * s,
        g = -1.2684380046 * l
           + 2.6097574011 * m
           - 0.3413193965 * s,
        b = -0.0041960863 * l
           - 0.7034186147 * m
           + 1.707614701 * s }
end

function oklab.oklab_to_okhsl(lab)
    local L = lab.L
    if L >= 1.0 then return { h = 0.0, s = 0.0, l = 1.0 } end
    if L <= 0.0 then return { h = 0.0, s = 0.0, l = 0.0 } end

    local Csq = lab.a * lab.a + lab.b * lab.b
    if Csq > 0.0 then
        local C = math.sqrt(Csq)
        local a_ = lab.a / C
        local b_ = lab.b / C

        -- 1.0 / math.pi = 0.3183098861837907
        local h = 0.5 + 0.5 * math.atan(-lab.b, -lab.a) * 0.3183098861837907

        local cs = oklab.get_Cs(L, a_, b_)
        local C_0 = cs.C_0
        local C_mid = cs.C_mid
        local C_max = cs.C_max

        -- Inverse of the interpolation in okhsl_to_srgb:
        local mid = 0.8
        local mid_inv = 1.25

        local s = 0.0
        if C < C_mid then
            local k_1 = mid * C_0
            local k_2 = 1.0
            if C_mid ~= 0.0 then
                k_2 = (1.0 - k_1 / C_mid)
            end

            local t_denom = k_1 + k_2 * C
            local t = 0.0
            if t_denom ~= 0.0 then
                t = C / t_denom
            end

            s = t * mid
        else
            local k_0 = C_mid
            local k_1 = 0.0
            if C_0 ~= 0.0 then
                k_1 = (1.0 - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0
            end

            local C_denom = C_max - C_mid
            local k_2 = 1.0
            if C_denom ~= 0.0 then
                k_2 = 1.0 - k_1 / C_denom
            end

            local t_denom = k_1 + k_2 * (C - k_0)
            local t = 0.0
            if t_denom ~= 0.0 then
                t = (C - k_0) / t_denom
            end

            s = mid + (1.0 - mid) * t
        end

        return { h = h, s = s, l = oklab.toe(L) }
    else
        return { h = 0.0, s = 0.0, l = L }
    end
end

function oklab.oklab_to_okhsv(lab)
    local L = lab.L
    if L >= 1.0 then return { h = 0.0, s = 0.0, v = 1.0 } end
    if L <= 0.0 then return { h = 0.0, s = 0.0, v = 0.0 } end

    local Csq = lab.a * lab.a + lab.b * lab.b
    if Csq > 0.0 then
        local C = math.sqrt(Csq)
        local a_ = lab.a / C
        local b_ = lab.b / C

        -- 1.0 / math.pi = 0.3183098861837907
        local h = 0.5 + 0.5 * math.atan(-lab.b, -lab.a) * 0.3183098861837907

        local cusp = oklab.find_cusp(a_, b_)
        local ST_max = oklab.to_ST(cusp)
        local S_max = ST_max.S
        local T_max = ST_max.T
        local S_0 = 0.5
        local k = 1.0
        if S_max ~= 0.0 then
            k = 1.0 - S_0 / S_max
        end

        -- first we find L_v, C_v, L_vt and C_vt
        local t_denom = C + L * T_max
        local t = 0.0
        if t_denom ~= 0.0 then
            t = T_max / t_denom
        end
        local L_v = t * L
        local C_v = t * C

        local L_vt = oklab.toe_inv(L_v)
        local C_vt = 0.0
        if L_v ~= 0.0 then
            C_vt = C_v * L_vt / L_v
        end

        -- we can then use these to invert the step that compensates for the toe and the curved top part of the triangle:
        local rgb_scale = oklab.oklab_to_linear_srgb({
            L = L_vt,
            a = a_ * C_vt,
            b = b_ * C_vt })
        local scale_denom = math.max(
            rgb_scale.r,
            rgb_scale.g,
            rgb_scale.b, 0.0)
        local scale_L = 0.0
        if scale_denom ~= 0.0 then
            scale_L = (1.0 / scale_denom) ^ 0.3333333333333333
            L = L / scale_L
            C = C / scale_L
        end

        local toel = oklab.toe(L)
        C = C * toel / L
        L = toel

        -- we can now compute v and s:
        local v = 0.0
        if L_v ~= 0.0 then v = L / L_v end

        local s = 0.0
        local s_denom = ((T_max * S_0) + T_max * k * C_v)
        if s_denom ~= 0.0 then
            s = (S_0 + T_max) * C_v / s_denom
        end

        return { h = h, s = s, v = v }
    else
        return { h = 0.0, s = 0.0, v = L }
    end
end

function oklab.oklab_to_srgb(lab)
    local lrgb = oklab.oklab_to_linear_srgb(lab)
	return {
		r = oklab.srgb_transfer_function(lrgb.r),
		g = oklab.srgb_transfer_function(lrgb.g),
		b = oklab.srgb_transfer_function(lrgb.b) }
end

function oklab.srgb_to_okhsl(rgb)
    return oklab.oklab_to_okhsl(oklab.srgb_to_oklab(rgb))
end

function oklab.srgb_to_okhsv(rgb)
    return oklab.oklab_to_okhsv(oklab.srgb_to_oklab(rgb))
end

function oklab.srgb_to_oklab(srgb)
    return oklab.linear_srgb_to_oklab({
		r = oklab.srgb_transfer_function_inv(srgb.r),
		g = oklab.srgb_transfer_function_inv(srgb.g),
		b = oklab.srgb_transfer_function_inv(srgb.b) })
end

function oklab.srgb_transfer_function(a)
    if 0.0031308 >= a then
        return 12.92 * a
    else
        return 1.055 * (a ^ 0.4166666666666667) - 0.055
    end
end

function oklab.srgb_transfer_function_inv(a)
    if 0.04045 < a then
        return ((a + 0.055) * 0.9478672985781991) ^ 2.4
    else
        return a * 0.07739938080495357
    end
end

function oklab.to_ST(cusp)
	local L = cusp.L
    local C = cusp.C
    if L ~= 0.0 and L ~= 1.0 then
        return { S = C / L, T = C / (1.0 - L) }
    elseif L ~= 0.0 then
        return { S = C / L, T = 0.0 }
    elseif L ~= 1.0 then
        return { S = 0.0, T = C / (1.0 - L) }
    else
        return { S = 0.0, T = 0.0 }
    end
end

function oklab.toe(x)
    local y = 1.170873786407767 * x - 0.206
	return 0.5 * (y + math.sqrt(y * y + 0.14050485436893204 * x))
end

function oklab.toe_inv(x)
    local denom = 1.170873786407767 * (x + 0.03)
    if denom ~= 0.0 then
    	return (x * x + 0.206 * x) / denom
    else
        return 0.0
    end
end

return oklab
:: exports/lib/palette.lua
--[[pod_format="raw",created="2024-03-31 08:27:10",modified="2024-04-02 08:30:12",revision=1467]]
function load_palette(filename)
	poke4(0x5000, get(fetch(filename)))
end


--[[
function fetch_palette(filename)
	local colors = split(fetch(filename):gsub("\r",""),"\n",true)
	local palette = {}
	for i = 1, #colors do
		palette[i - 1] = tonum("0x00" .. colors[i])
	end
	return palette
end
]]--


function set_color(c, code)
	poke4(0x5000 + 4 * c, code)
end


function get_color(c)
	return peek4(0x5000 + 4 * c)
end

function color_to_hex(c)
	return string.format("%06x", c)
end
:: exports/lib/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA4OjQyOjE5IixzdG9yZWQ9IjIwMjQtMDMt
MzEgMDg6NDI6MTkiXV1sejQABAAAAAMAAAAwbmls
:: exports/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA4OjQyOjE1IixzdG9yZWQ9IjIwMjQtMDMt
MzEgMDg6NDI6MTUiXV1sejQABAAAAAMAAAAwbmls
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA3Iixtb2RpZmllZD0iMjAyNC0w
NC0wMiAwODozMDoxMiIscmV2aXNpb249MTY0Nl1dbHo0AJ4BAAC5MgAA9hl7WzBdPXtibXA9cHh1
AEMgEBAE8PAsZmxhZ3M9MCxwYW5feD02LjE2AQARMxYAZ3k9LTAuMwEAtzI3LHpvb209N30sTwDx
CAwMBDAncAcgB2AHoAegB5BnQGdAJwAnBAA-Z-ALaQA6I-AMagA-IAdQaABL-xI3YFdAdyAXABcA
BwAXEAcQNxAHIAcQFxAHQAcwB2A38AxwADtgLQdwBxAH3AAfUGIAQPEGCQkEMAdgBw0HQActByAH
TQcAB20XAgBLBwBnAGgAEzBaABIwSgAdOEoAYTcwBz0HEEYAEF1CACEHXQ4AbyAHPQcwN04AHSkQ
R5AAAVAAX00HIEcQSAAZ-woYGATwKNqA2g8ZcNoeYNouUNo_QNpOMNleAwAE-wJOQNk_UNkuYNke
cNkOgNnwKG0ACx0xrwH-BxsHsAewB1BnMAcAR0AHECdQByAH8AyzABkHRgAB8QFPAAcgB0oAIw7P
Aw8xAP-------------------------------------------------------------eUG09OH19
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2IixzdG9yZWQ9IjIwMjQtMDMt
MzEgMDU6MzM6MDYiXV1sejQABAAAAAMAAAAwbmls
:: gui.lua
--[[pod_format="raw",created="2024-03-31 05:58:06",modified="2024-04-02 08:30:12",revision=2557]]
local slider_size = 170
local slider_border = 6
local slider_inner = slider_size - 2 * slider_border


test_cube_colors = {
	[0] = 
	{15, 31, 4},
	{31, 4, 20},
	{4, 20, 21},
	--
	{10, 9, 25},
	{9, 25, 24},
	{8, 24, 2},
	--
	{26, 11, 27},
	{11, 27, 3},
	{27, 3, 19},
	--
	{28, 17, 3},
	{28, 12, 16},
	{12, 16, 1},
	--
	{23, 29, 13},
	{29, 13, 18},
	{13, 18, 1},
	--
	{15, 23, 14},
	{23, 14, 13},
	{14, 30, 18},
	--
	{7, 6, 22},
	{6, 22, 5},
	{22, 5, 21},
	--
	{1, 1, 1},
	{1, 1, 1},
	{1, 1, 1},
	--
}


function generate_gui()
	gui = create_gui()
	local pal_el = create_palette{ x = 16, y = 6 }
	gui:attach(pal_el)
	gui:attach(create_visibility_buttons { x = pal_el.x - 14, y = pal_el.y + 1 })
	gui:attach(create_color_preview { x = pal_el.x + pal_el.width + 8, y = pal_el.y })
	for i = 0, 2 do
		for j = 0, 7 do
			gui:attach(create_test_cube { x = 390 + i * 28, y = 16 + j * 28, test_id = i + 3 * j })
		end
	end
	local h_slider = create_hue_slider{ x = 6, y = 68 }
	gui:attach(h_slider)
	h_slider:attach(create_hue_sat_slider {})
	local sl_slider = create_sat_lum_slider{ x = 192, y = 68 }
	gui:attach(create_sat_slider { x = sl_slider.x, y = sl_slider.y + sl_slider.height })
	gui:attach(create_lum_slider { x = sl_slider.x + sl_slider.width, y = sl_slider.y })
	gui:attach(sl_slider)
end


function create_palette(el)
	local size = 12
	local nb_columns = 16
	local nb_rows = 4
	el.width = (nb_columns * size) + 1
	el.height = (nb_rows * size) + 1
		
	function el:draw()
		clip()
		rect(0, 0, self.width, self.height, outline_color())
		for c = 0, 63 do
			local x = 1 + ((c % nb_columns) * size)
			local y = 1 + ((c \ nb_columns) * size)
			rectfill(x, y, x + size - 1, y + size - 1, c)
			if hidden[c] then
				ovalfill(x + 2, y + 2, x + size - 3, y + size - 3, 0)
			end
			if c == active_color then
				local contrast_color = 0
				if pal_okhsl[active_color].l < 0.5 then
					contrast_color = 7
				end
				rect(x + 1, y + 1, x + size - 2, y + size - 2, contrast_color)
			end
		end	
	end

	function el:click(msg)
		local x = min(nb_columns - 1, (msg.mx - 1) \ size)
		local y = min(nb_rows - 1, (msg.my - 1) \ size)
		local c = x + y * nb_columns
		if msg.mb == 1 then
			active_color = c
		elseif msg.mb == 2 then
			hidden[c] = not hidden[c]
		end
	end	

	return el
end


function create_visibility_buttons(el)
	local size = 12
	local nb_rows = 4
	el.width = size
	el.height = nb_rows * size
	el.cursor = "pointer"
	
	function el:draw(msg)
		pal(7, outline_color())
		for row = 0, 3 do
			if hidden_toggles[row] then
				spr(4, 0, row * size)
			else
				spr(3, 0, row * size)
			end
		end
		pal(7, 7)
	end
	
	function el:tap(msg)
		local row = mid(0, msg.my \ size, 3)
		hidden_toggles[row] = not hidden_toggles[row]
		for c = row * 16, row * 16 + 15 do
			hidden[c] = hidden_toggles[row]
		end
	end
	
	return el
end


function create_color_preview(el)
	local size = 12
	el.width = size * 4 + 2 + 120
	el.height = size * 4 + 2
	
	function el:draw(msg)
		if active_color then
			---rect(0, 0, self.height - 1, self.height - 1, 0)
			rectfill(1, 1, self.height - 2, self.height - 2, active_color)
			local contrast_color = 0
			if pal_okhsl[active_color].l < 0.5 then
				contrast_color = 7
			end
			print(string.format("%d", active_color), 4, 4, contrast_color)
			local c = get_color(active_color)
			print("#" .. color_to_hex(c), 7, self.height - 10, contrast_color)
			pal(7, outline_color())
			if locked[active_color] then
				spr(2, self.height + 4, 1)
			else
				spr(1, self.height + 4, 1)
			end
			if hidden[active_color] then
				spr(4, self.height + 4 + size, 1)
			else
				spr(3, self.height + 4 + size, 1)
			end
			if bg_color == active_color then
				spr(10, self.height + 4 + 2 * size, 1)
			else
				spr(9, self.height + 4 + 2 * size, 1)
			end
			pal(7, 7)
			local hue = pal_okhsl[active_color].h * 360.0
			while hue < 0.0 do
				hue += 360.0
			end
			print("\|k\014       hue: " .. string.format("%3.0f", hue) .. "", self.height + 5, 26, outline_color())
			print("\014saturation:" .. string.format("%3.0f", pal_okhsl[active_color].s * 100.0) .. "%")
			print("\014 luminance:" .. string.format("%3.0f", pal_okhsl[active_color].l * 100.0) .. "%")
		else
			print("\^pOkPal\^-p\014\|o 0.0.3", 8, 16, 7)
			print("\014\|4- 'save as' to create a new palette")
			print("\014- 'open' to drag-n-drop a file")
		end
	end
	
	function el:tap(msg)
		if (not active_color) return
		if msg.mx < self.height or msg.my > size then
			return
		elseif msg.mx < self.height + 4 + size then
			locked[active_color] = not locked[active_color]
		elseif msg.mx < self.height + 4 + 2 * size then
			hidden[active_color] = not hidden[active_color]
		elseif msg.mx < self.height + 4 + 3 * size then
			if bg_color == active_color then
				bg_color = 0
			else
				bg_color = active_color
			end
		end
	end
	
	function el:hover(msg)
		if msg.mx >= self.height + 4 and msg.mx <= self.height + 4 + 3 * size and msg.my <= size then
			self.cursor = "pointer"
		else
			self.cursor = false
		end
	end
	
	return el
end


function create_test_cube(el)
	el.width = 24 + 4
	el.height = 24 + 4

	function el:draw()
		rectfill(0, 0, self.width, self.width, 0)
		local colors = test_cube_colors[self.test_id]
		pal(10, colors[1])
		pal(9, colors[2])
		pal(25, colors[3])
		spr(8, 2, 2)
		pal(10, 10)
		pal(9, 9)
		pal(25, 25)
	end
	
	function el:hover(msg)
		if msg.mx > 2 and msg.my > 2 and msg.mx < self.width - 2 and msg.my < self.height - 2 then
			el.cursor = "crosshair"
		else
			el.cursor = false
		end
	end
	
	function el:click(msg)
		local face = 2
		if msg.mx > self.width - 10 or msg.my < 10 then
			if msg.mx > self.height - msg.my then
				face = 3
			else
				face = 1
			end
		end
		if msg.mb == 1 then
			test_cube_colors[self.test_id][face] = active_color or 1
		elseif msg.mb == 2 then
			active_color = test_cube_colors[self.test_id][face]
		end
	end
	
	return el
end


-- 2D Sliders -----------------------------------------------------------------------


function create_hue_sat_slider(el)
	el.x = slider_border -- 240 - slider_size - 8
	el.y = slider_border -- 74
	el.width = slider_size
	el.height = slider_size
	el.drag_delta = nil
	
	function el:draw()
		clip()
		ovalfill(
			slider_border - 1, slider_border - 1,
			slider_border + slider_inner + 1, slider_border + slider_inner + 1,
			outline_color()
		)
		ovalfill(
			slider_border, slider_border,
			slider_border + slider_inner,
			slider_border + slider_inner,
			0
		)
		fillp(0b0101101001011010)
		rectfill(slider_size \ 2 - 24, slider_size \ 2, slider_size \ 2 + 24, slider_size \ 2, 7)
		rectfill(slider_size \ 2, slider_size \ 2 - 24, slider_size \ 2, slider_size \ 2 + 24, 7)
		fillp()
		for c = 0, 63 do
			-- TODO: put nb_columns in global constant
			if not hidden[c] and pal_okhsl[c].l ~= 0 then
				local x, y = hs_coords(c)
				ovalfill(x - 3, y - 3, x + 3, y + 3, c)
			end
		end
		if active_color and not hidden[active_color] then
			local x, y = hs_coords(active_color)
			if self.drag_delta then
				-- ovalfill(x - 6, y - 6, x + 6, y + 6, 7)
				ovalfill(x - 5, y - 5, x + 5, y + 5, active_color)
			else
				oval(x - 6, y - 6, x + 6, y + 6, 7)
				ovalfill(x - 5, y - 5, x + 5, y + 5, active_color)
			end
		end
	end	
	
	function el:hover(msg)
		if (not msg.mx or not msg.my) return false
		local _, r = coords_hs(msg.mx, msg.my)
		if r > 1.02 then
			return false
		end
		if active_color and not hidden[active_color] then
			local ax, ay = hs_coords(active_color)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx <= 5 and dy <= 5 then
				self.cursor = "grab"
			else
				self.cursor = false
			end
		end
		return true
	end
	
	function el:click(msg)
		local _, r = coords_hs(msg.mx, msg.my)
		if r > 1.02 then
			return false
		end
		if active_color and not hidden[active_color] then
			local ax, ay = hs_coords(active_color)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx <= 5 and dy <= 5 then
				self.drag_delta = { x = ax - msg.mx, y = ay - msg.my }
				return true
			end
		end
		active_color = nil
		-- In reverse order to prioritize colors on top
		for c = 63, 0, -1 do
			local cx, cy = hs_coords(c)
			local dx = abs(cx - msg.mx)
			local dy = abs(cy - msg.my)
			if dx <= 3 and dy <= 3 and not hidden[c] and pal_okhsl[c].l ~= 0 then
				active_color = c
				self.drag_delta = { x = cx - msg.mx, y = cy - msg.my }
				self.cursor = "grab"
				return true
			end
		end
		self.drag_delta = nil
		return true
	end
	
	function el:release(msg)
		self.drag_delta = nil
	end
	
	function el:drag(msg)
		if active_color and self.drag_delta and not locked[active_color] then
			local ax = msg.mx + self.drag_delta.x
			local ay = msg.my + self.drag_delta.y
			local hue, sat = coords_hs(ax, ay)
			update_pal(active_color, hue, sat, nil)
			return true
		end
	end
		
	return el
end


function create_sat_lum_slider(el)
	--el.x = 240 + 8
	--el.y = 74
	el.width = slider_size
	el.height = slider_size
	el.drag_delta = nil
		
	function el:draw()
		clip()
		rect(
			slider_border - 1, slider_border - 1, 
			slider_border + slider_inner + 1, slider_border + slider_inner + 1, 
			outline_color()
		)
		rectfill(
			slider_border, slider_border, 
			slider_border + slider_inner, slider_border + slider_inner,
			0
		)
		for c = 0, 63 do
			if not hidden[c] and pal_okhsl[c].l ~= 0 then
				local x, y = sl_coords(c)
				ovalfill(x - 3, y - 3, x + 3, y + 3, c)
			end
		end
		if active_color and not hidden[active_color] then
			local x, y = sl_coords(active_color)
			if self.drag_delta then
				-- ovalfill(x - 6, y - 6, x + 6, y + 6, 7)
				ovalfill(x - 5, y - 5, x + 5, y + 5, active_color)
			else
				ovalfill(x - 6, y - 6, x + 6, y + 6, 7)
				ovalfill(x - 5, y - 5, x + 5, y + 5, active_color)
			end
		end
	end	

	
	function el:hover(msg)
		if active_color and not hidden[active_color] then
			local ax, ay = sl_coords(active_color)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx < 6 and dy < 6 then
				self.cursor = "grab"
			else
				self.cursor = false
			end
		end
	end
	
	function el:click(msg)
		if active_color and not hidden[active_color] then
			local ax, ay = sl_coords(active_color)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx < 6 and dy < 6 then
				self.drag_delta = { x = ax - msg.mx, y = ay - msg.my }
				return
			end
		end
		active_color = nil
		-- In reverse order to prioritize colors on top
		for c = 63, 0, -1 do
			local cx, cy = sl_coords(c)
			local dx = abs(cx - msg.mx)
			local dy = abs(cy - msg.my)
			if dx < 3 and dy < 3 and not hidden[c] and pal_okhsl[c].l ~= 0 then
				active_color = c
				self.drag_delta = { x = cx - msg.mx, y = cy - msg.my }
				self.cursor = "grab"
				return
			end
		end
		self.drag_delta = nil
	end
	
	function el:release(msg)
		self.drag_delta = nil
	end
	
	function el:drag(msg)
		if active_color and self.drag_delta and not locked[active_color] then
			local ax = msg.mx + self.drag_delta.x
			local ay = msg.my + self.drag_delta.y
			local sat, lum = coords_sl(ax, ay)
			update_pal(active_color, nil, sat, lum)
		end
	end
	
	return el
end


-- 1D Sliders ----------------------------------------------------------------------


function create_hue_slider(el)
	el.width = slider_size + 2 * slider_border
	el.height = slider_size + 2 * slider_border

	function el:draw()
		clip()
		for c = 0, 63 do
			if not hidden[c] and pal_okhsl[c].l ~= 0 then
				cx1, cy1 = h_coords(c, -2)
				cx2, cy2 = h_coords(c, 18)
				line(cx1, cy1, cx2, cy2, c)
			end
		end
		if active_color and not hidden[active_color] then
			local ax, ay = h_coords(active_color)
			pal(7, outline_color())
			pal(13, active_color)
			spr(7, ax - 4, ay - 4)
			pal(13, 13)
			pal(7, 7)
		end
	end	

	function el:hover(msg)
		-- I think there is a bug in Picotron's handling of mouse coords
		-- when one widget is on top of another.
		--[[
		if (not msg.mx or not msg.my) return
		if active_color then
			local ax, ay = h_coords(active_color)
			--printh(string.format("%.0f %.0f - %.0f %.0f", ax, ay, msg.mx, msg.my))
			if
				msg.mx >= ax - 6 and msg.mx <= ax + 6
				and msg.my >= ay - 6 and msg.my <= ay + 6
			then
				self.cursor = "grab"
			else
				self.cursor = false
			end
		end
		--]]
	end

	function el:click(msg)
		if active_color and not hidden[active_color] then
			local ax, ay = h_coords(active_color)
			--[[
			if
				msg.mx >= ax - 6 and msg.mx <= ax + 6
				and msg.my >= ay - 6 and msg.my <= ay + 6
			then
			]]
				self.drag_delta = { x = ax - msg.mx, y = ay - msg.my }
			-- end
		end
	end
	
	function el:release(msg)
		self.drag_delta = nil
	end
	
	function el:drag(msg)
		if active_color and self.drag_delta and not locked[active_color] then
			local ax = msg.mx + self.drag_delta.x
			local ay = msg.my + self.drag_delta.y
			local hue = coords_h(ax, ay)
			update_pal(active_color, hue, nil, nil)
		end
	end
	
	return el
end


function create_sat_slider(el)
	el.width = slider_size
	el.height = 16
	
	function el:draw()
		clip()
		for c = 0, 63 do
			if not hidden[c] and pal_okhsl[c].l ~= 0 then
				local ax, _ = sl_coords(c)
				line(ax, 0, ax, self.height - 9, c)
			end
		end
		if active_color and not hidden[active_color] then
			local ax, _ = sl_coords(active_color)
			pal(7, outline_color())
			pal(13, active_color)
			spr(5, ax - 4, self.height - 9)
			pal(13, 13)
			pal(7, 7)
		end
	end	
	
	function el:hover(msg)
		if active_color and not hidden[active_color] then
			local ax, _ = sl_coords(active_color)
			if msg.mx and msg.mx >= ax - 4 and msg.mx <= ax + 4 and msg.my >= self.height - 9 then
				self.cursor = "grab"
			else
				self.cursor = false
			end
		end
	end

	function el:click(msg)
		if active_color and not hidden[active_color] then
			local ax, _ = sl_coords(active_color)
			if msg.mx and msg.mx >= ax - 4 and msg.mx <= ax + 4 and msg.my >= self.height - 9 then
				self.drag_delta_x = ax - msg.mx
			end
		end
	end
	
	function el:release(msg)
		self.drag_delta_x = nil
	end
	
	function el:drag(msg)
		if active_color and self.drag_delta_x and not locked[active_color] then
			local ax = msg.mx + self.drag_delta_x
			local sat, lum = coords_sl(ax, 0)
			update_pal(active_color, nil, sat, nil)
		end
	end
		
	return el
end


function create_lum_slider(el)
	el.width = 16
	el.height = slider_size
	
	function el:draw()
		clip()
		for c = 0, 63 do
			if not hidden[c] and pal_okhsl[c].l ~= 0 then
				local _, ay = sl_coords(c)
				line(0, ay, self.width - 9, ay, c)
			end
		end
		if active_color and not hidden[active_color] then
			local _, ay = sl_coords(active_color)
			pal(7, outline_color())
			pal(13, active_color)
			spr(6, self.width - 9, ay - 4)
			pal(13, 13)
			pal(7, 7)
		end
	end	
	
	function el:hover(msg)
		if active_color and not hidden[active_color] then
			local _, ay = sl_coords(active_color)
			if msg.my and msg.my >= ay - 4 and msg.my <= ay + 4 and msg.mx >= self.width - 9 then
				self.cursor = "grab"
			else
				self.cursor = false
			end
		end
	end

	function el:click(msg)
		if active_color and not hidden[active_color] then
			local _, ay = sl_coords(active_color)
			if msg.my and msg.my >= ay - 4 and msg.my <= ay + 4 and msg.mx >= self.width - 9 then
				self.drag_delta_y = ay - msg.my
			end
		end
	end
	
	function el:release(msg)
		self.drag_delta_y = nil
	end
	
	function el:drag(msg)
		if active_color and self.drag_delta_y and not locked[active_color] then
			local ay = msg.my + self.drag_delta_y
			local sat, lum = coords_sl(0, ay)
			update_pal(active_color, nil, nil, lum)
		end
	end
		
	return el
end


-- Utility functions ----------------------------------------------------------------


function outline_color()
	if pal_okhsl[bg_color].l < 0.5 then
		return 7
	else
		return 0
	end
end


function sl_coords(c)
	local sat = pal_okhsl[c].s
	local lum = pal_okhsl[c].l
	local x = slider_border + sat * slider_inner
	local y = slider_border + slider_inner - lum * slider_inner
	return x, y
end


function coords_sl(x, y)
	local sat = (x - slider_border) / slider_inner
	local lum = 1.0 - ((y - slider_border) / slider_inner)
	return sat, lum
end


-- Remove 0.25 to compensate for Picotron's angle origin,
-- and 29/360 to compensate for OkLab weird position of
-- the red color.
local angle_correction = 0.25 + 0.08


function hs_coords(c)
	local hue = pal_okhsl[c].h
	local sat = mid(0.0, pal_okhsl[c].s, 1.0)
	local a = angle_correction - hue
	local dx = sat * cos(a) * (slider_inner / 2)
	local dy = sat * sin(a) * (slider_inner / 2)
	local x = slider_border + (slider_inner / 2) + dx
	local y = slider_border + (slider_inner / 2) + dy
	return x, y
end


function coords_hs(x, y)
	local dx = x - (slider_border + (slider_inner / 2))
	local dy = y - (slider_border + (slider_inner / 2))
	local hue = -atan2(dx, dy) + angle_correction
	dx = (2.0 * dx) / slider_inner
	dy = (2.0 * dy) / slider_inner
	local sat = sqrt(dx * dx + dy * dy) -- / (slider_inner / 2)
	return hue, sat
end


function h_coords(c, radius_delta)
	local s = slider_size + 2 * slider_border
	local r = s - slider_border + (radius_delta or 0)
	local hue = pal_okhsl[c].h
	local a = angle_correction - hue
	local dx = cos(a) * (r / 2)
	local dy = sin(a) * (r / 2)
	local x = (s / 2) + dx + 0.5
	local y = (s / 2) + dy + 0.5
	return x, y
end


function coords_h(x, y)
	local s = slider_size + 2 * slider_border
	local r = s - 6
	local dx = x - ((s / 2) + 0.5)
	local dy = y - ((s / 2) + 0.5)
	local hue = -atan2(dx, dy) + angle_correction
	dx = (2.0 * dx) / r
	dy = (2.0 * dy) / r
	local sat = sqrt(dx * dx + dy * dy)
	return hue, sat
end
:: label.png
b64$iVBORw0KGgoAAAANSUhEUgAAAeAAAAEOCAIAAADe_FMwAAAeT0lEQVR4Ae2df8wc5Z3Yn9ns
tRUqXQkZdaOYSlZlAUW5SNUrKxTMteEqDsnxnPPaDFeKZ9v6dkXeiw7pgOKjYNmEGoz-CEres3bv
vWrHFiKD-ULHuAenC0SHIYDzXlqSOiZyI0exkTZ3PqqJU_7UqExbPb7xeHZ25tnd2dn58flotPrO
zHefeeb7PN-P-Kt57kAAAED_qGf8vLcau3Jbi9vdFRkcOfSc4l-uf_B32UMAMCM0zx0Ez4fdlKKD
JrCzlOa4f5zsX-KP6nbG0QDDyA6SfRGMY5JD_eptpZivrrVR7Z84nyOHnrv-gd_Vv_MqUfoqkrpK
CcZ6mRSFdbu74r-AWLZ9q7Er5p0BIAM7y_DIoefG1ZaiascaM5g8ysLTMJmdpaZifBUWdOg15FNV
3nl2RE7dv_iL239VmgQAsvwgjfX9CCkrnrCg-QfI0eM-NZF307X27e7KqM_LfE_ZMHw6oy8kOxIg
A9Opd2UeJh_aRsy7hGw2Sm4jBR00UeLLZ1AddduqfI6mXAAcDTCL5gq2lXqX_WnqIkocOWPjJ1or
QtDyHUIlU3-bzN5Qvps0_O3uih-M6POOnQEKx7g9Oyo-Y3GPFPRYGpr1pN9q7ApaOCji4MVgZsjg
wZyMVxqggkiBHDn0nJSD7Jp4UYQ6a6aNpqisYJrKfNTnLKUUlFWku3w0zx1ktngp6jJd_QaHHXd-
zOvTCgAFJeiuGDsLIeoleEMAgAIRL_Ugmmno1AsAIIfUKAEAAIIGAAAEDQCAoAEAAEEDACBoAABA
0AAAMIr6uH_wbIeqwZSYhl6UrRU5VYCcClqRG25ZTMz5N-87eZx9--aTxJyj3-0wMefEr3w6Meff
-c6jiTmbf3VD8qQbv52cc_SV5Jy7b0xM0f6mkZhz83vvJeb8q-f_KDHnP2h-P3nOO2rJc164Z9St
JzYmb5ss2Xd2FUfAHEluJwAAmAv14Uv9XtePW_3OrGewd2058vqehSWWBwAQdLSd5WkGjh528Shr
AwBUVNAhO2fpaICCEuyayE6RCfJWKHn4v8FkgFrkNvKD4V0FAEFa7Y48Rulb3vWbKJQfPB1OBgR9
1VYL_ZqPOcCwc4MNEpkwWfvQaxCiHtwcoQ948KtOpQBCdg62hh8PB8Nx0MXxpxXEsp3Kvrtp6CMF
HXL08MYCAL9HRvnXl2zw1L8b_svwCMNyhypzlaD9-Rc8zWASe9eWWQkoBLI7-N-IBgnJWr2J8DIk
CDozKfvsWVhiGaAotNodqdEYO0t9_60UPI25FUxA0zBS0AAQ7_iQQ0M_VbwVKWLUHI_39qJiprZw
j_qYT31FdczHvq6YefRLmxQzd7x0KmVBr995LDHn-F3-KzHnr_2PE3OuW3szMee9H19KzPmLT2qJ
OT95_3hizuafbUnMeUt4iTk3vZtc5_fv-kxy0vcaiSm3-dO-Tsz5Z391Z2LOh7_3lpjzmX_QvF4A
s7bzsf94MHU7P-zit1K38386m_ClZG0BAGDn7O0shKgPX_r3un7canfYGQCAnbO3c4Sgg3aWpzga
YEYdIdtNDhhsveCV4ccNZ2LnUto5LOiQnXE0QAau94Ngow3fDVKdlqyyna8StP_5DgbyF0cDDHdK
pEaDd_OJz6HjLpv0T04q2fnP31M3qWLyez__pDjmQ5_7WTH59CeNsSpwRdDDH3D-oh8DQMjIIXeP
Enei6yPlPurv6p8BKDRXBC1F3Gp3fCOr7DAAGFZnyOYqrg9qOr71hjOhrNRCC__rGTsDTIDsnaBD
FVU_fJfWg-rw9gruG7YIQLyOQ-3in8reiekgP1nmhP44fMVX9nAmVEXQrDpAvJFHBRO0TzA5cZxR
T4QSU6MEAAD5pD7Bfy4c3p6cdDg55dmU3uFgSuO8_ui7iTk7xf50HraskvNGKo9aEdco5KTEY-QU
QGrUKAEAlIwdL51KfcyD759JfcxXf-BufEJ9_FK-1-XjVrvDYgOMot-rZtkjsjeHnzjcs8OZGU8V
O09vZyFELWalh08BYL4fg1a7M9yV8rrv3_HM6jRymewshKgn6rg6H14ARVH6WvRP-djXYuRdGQd7
Kpgw1tPVM4Ozws4FsrMQohZaTn_jyCC4sQBAyk4efqcE9ecnBOOg00O6HP574tNV7sZnYudC2Pkq
QYc_48ENRFsCKDJuv-R73aCU4-_uaOfhTPmIePtj57zZWQhRD65o6IMv17iCn2KAbAzuN5evzlm0
W3EbWXvs65VVeVjQIUfPbrsAFFqvvkwTW8NPHpUZHC1xzOHRRrVn4nOhMJ8o09BDl4I7ZniBLduh
ajAlw7tObq0nNi7map77zq5GThVmR5UNM7zZ6pGfX3YJAMDcqVECAAAEDQAAY1CnBJBD9q4ty2DP
wlKuJtbvdYUQrXZHPV89eUaTHDVneV2S-SRhQkGzbDB3O-teDsZ5oNXuBBtEJT97O8uHyiB0Gjm3
sd4I5ino0FLN5fsPkBn7zq4KIZ7YuJiKCn2D_9d9D-qdFdJi-N1QgkozjrLwuK_Tz-XyLt6omKmt
_5HqmEdUn67drzxP8UXVMcUrMXdrMXbm6wqlt-MTGxef2LgoNT09vp0jfdpqd-xb8adyEHkET-3k
_K7s97ohycY4179VJjtf3JO_nd_6f0vqdt6z8e-EJ1wRdGhLhdaMZoZs2Lu2LH-l4V_ZBU9sXJzj
m0qNTpYc79BhmyfaOTETO2dv56sEHVr14Icda0DG7FlYkkcGz9p3djVFUyv2i1ShenPJZD8-xuyh
W_rO9TPVPxvYeaZ2FkLUgzvA3zRyhfzVwtFQViazc6hT4l0Z2UHx-w3eDT1IDhXTkqH_DQo3vqP9
i3nr98raWQihmYYe870dXkvLduhqmJLQrvO31hMbF-euLV-exAtLwXgudt53djVyqjA7QoaZ2M7X
X947adp5sziRup33nV2N6Yt6-Ic9b99SgNQdLYN4U8Nc8I4I8epV2h1p53dVx-zLJdXkD5avsnMM
J8WWt4SnkvmnG--uWBUICxopQ07Yu7Y860cgZcg5EYIGmCN7FpYoAgCChtyx7_wqRQCYXNCmoVM1
mAVsLYAQNUoAAICgAQAAQQMAIGgAgLxx-XL6Y24WJ1Ifc9-ZVQQNANi5eHZG0ACAnXNqZwQNANg5
p3ZG0ACAnXNqZwQNANg5p3YWQtRZWgDIJ9r91VW5pMYmAADIJwgaAABBAwAAggYAQNAAAICgAQAQ
NAAA5IE6JQCAovC1i19QzHxw3Ruqg17YpJq5-pRq5vFtqplbX0bQcVi2M9kfTUOnegB5tPN3Gunb
_chnUrfzddbf_yg2oVqCjnTxxJ5NdzQAqJqdE3PKL_igRtO1Z_Ros3tcIej3uqik3LTaHeycjZ1L
K_g5WjL4uGrKWms0sVhZ8dxBfN-NYp9X1s5lE7QvxJzYMFLW1TE1AHaexs4lEXQh3OfPDVMDqJv0
wb-5hVLm98Yx6ffUMk8rz3P-NsXk69bGsHOxBV1Q02FqACizoKXasvRa-1f-kQxa3--pjEyNpiG3
eO6AIiDo2aq5b39yWbJGLXyr14375zeeusrUv-OYEKLV7qRrajQN2BmKKugp-eXb_XLs-mHwrtZo
xm3Qp74ynBy5a6exNpoGgOIJeixn7bL-jwxWjE9dMXKvK_zfVjeyCpEjBK09mazRNAAUQ9Djesq3
s4xvd1d8mXrii5O7_LGve099xY8VrR2S9cF1jowfupj8Omga8oPWaAY3M2RJLbdqtmzHNPRp9KQ1
mvIQQmjilSvXA7G6o_UxwdO1RtO3sxAiGCdq2jR0WQp2KszX0X4rQZbU5-jsfq8bPG21O76dx-Wy
HOote1fcJhvfy7N7cf9lVTQ9WU0AUsS7eKMQQvzy14S4qQDT3fpy_mPuTn-Mj1ZfyKmgQ3aWV_Qn
eiwT_ePI-54UW_TpZnEiz-tHTnssTVu2M25xANK0s9y6yx_0lvLt6LLYWQhRm6OepFKDv547UBdQ
v9eVTpeH72V55GrDXL98VezPWb5C-_H75JHoaF-TAFB6Owsh6vP8LLuD0O9IF_94RAatowdCfi8K
QUf7aI2mt-bildd8_L7Ws88nalo6Wv1LBoCdi2hnIURtjsWUhg3_xttZxv1eV2s0i2XndDEN3dc0
QBatuu5Hftxaugk7Z2PnOQvacwehX3Wtl5V_r9vvdRU1jaMhS0dr634kfuXPsHNmdp6zoKVqg79V
3PcL9wRjrdHUGk1FTUtHo2koLetPqR5jqVzxGEvliseYzEfQUseeOwj9ttqdUGa-1xXfPX-lPBiX
yNHyCNZHalrF0VLT9DJA_ZiDoC3bMQ192MWhK-1et9-rao2m9sy94rvn5aE9c2911kY6WlHTOBqg
fNTnYudII4fsrDWaV1RVJS_HHC2E8NxBTK2CjvZrC5Ai3tqLFKH8glYxSL-X9cUEvqY9dxD-ScPR
kIWdz75JQbKkhp2L4mi-PomOplwACDp9O2uNJnaOcbTWaOJoAASdqZ37va60M_uhoun_FkceOBqy
2HIL91w52XgHBcmSeh7sLL3DYqjgHQmUbovTOhFdW_no_MpDxfnaxS-I4MF1byg62nMH853zrnMf
K2aubLhmjmPevOopZp5Z1GLu1rBzWZGOpg4Qb_dQnGfGMOk370t9zNf2-HHqdv7FE9vjE2YoaBU7
a40mdp4G_YXD0RDvIHkU-S2qZucZClrRzjTPuGj3XxVrjSaOBkUHFdfR1bTzrASdaOen-vhff7j_
5IVrj9I-kzlaHpdPcTSMz4Pr3oiMsXN_7CyEqM-Fzn584dqj6y-tKNbOPvqlTTLY8dKpvCi70fTc
QavdiXd0-LpAlR0dj3fsbeycvZ3TF3SiBfq97ofrTxZ3T-t2ljGOhpyzsuEa30crG66ZYISr7Pyn
P8509s9bK985qpT50-_sbtK3v6eUeclZVRxz-c5jisnan78wVgFSFnQ8-V5XazQvXKtW8fnx0Odu
lsHB988UqBUTHT0X3jz5jgzu2HwrupyXoylCQamlOJZlO6ahx9tZCLH_0o4rX55AnDc7h_KiOLrf
6466axq6ZTtzsXMoBoBMBZ1o5_Dp_ks75FG4eu146VRknCty5WgoOtr2266c-Mt-TEGypJ6ZnbVG
M61Je_7gqg2U3sjjOjqP7dRoeu6g3_u22p0YR8esF8AoR4daD2ZNLTNrpGjnPQtLwSPdTXPw-TOR
cZHaKdsvVgx3bL41MoaCcWHT5QOypT79EJbtmIY_6m6-103dzqGL0tEpPqWgXg452nMHrXYn8q5p
6PGrNiNHQ1Ht7O_rS1tN8WlKkhm1ots56GiWM_Tofq876q50NFWCcelvYdsUR9BxCznaDunaGUdn
tgoAxWD3y6kPeeHw9tTHPH96dYaCtmzHNPSYBK3RZKvMkfj6m4Zu2Q5VggTWn-JD79tXYuw8aztP
Jeh4O-d7XeycE0f3e10cDVM62vv2KWnn1omRXY_d07XzVIKOATsXyNEASrvofqHdL8TWAXbOzM6T
C9qyHdPI94cU1DAN3bId6gCFp3R2nlzQMfR7Xa3RTP8D3mjuXVuOSdi7tjyL55YDrdHs97rUAbBz
gewshKhP8AzLdkxDz9LOvmU8d7BnYQk7T1y9VrszfMs09Jg1BfCe_sp8HnyfmfqQZxa1Qqh8ckHP
3TIhR2NnyDOv987J4M72hsLb_RtPsaBZMragLdsxDT3yVr-XzUCU0tGhKyykeula7c7wLdPQY1YW
prezjAvqaCiMoHMiGlYOAEpPbaxsy3ZMQ4_81e918WYhvm39Xjfylmnolu1QIgjz89uiY8iboAFg
LO5sb4iMi-RRf_Ze8fPbLh_--89Z05wK2rId09Ajb-V7Xa3RpJrF6LdGs9-rRt4yDd2yHUqUuqPl
UdD537zq-ZNNxuXjW-_QBc2poAEAIEvqinmW7ZiGHnmr3_tqjSalLBBao_m5g1a7M3zLNPSYtQaY
L96xt1U3_fbbFDNf751TzLyzvUEx88lHVhQzHz_wK_ZujSUHgBjOLGp_-MNf-1kh7PzVU2dSt-Nr
J15L3c69--JqfEJ9ypL1e12t0WQTFw6t0fTcQavdoRQwhqPdAXbOzM5CiJrKQJbtmIbONq0IpqFb
tkMdID9U086qgh5Fv9dl6xQaVhCwc27tPK2ghRBao8kGKiisHWDnPNtZCFFPzLBsxzR0NkqlMA2d
dYcgf7n0-31x8febQmS3K17vnXvjI6XM7-yP19VNqpj88w9_qTjmw1sPKSZ-88ffGqsCtYlr1_91
tUaTjVtotEaz3_tSB0jg_Lbr79p2-V3bhBAH1znUIzMmFzQAVMTOfigdDXkRtGU7pqFXtjqeOyj5
C168Ufzy1-rLHwzfMg3dsh06BGCO1Cf7W7-X1RrNwr3t3Z-9vAxe-cG7rL138cYrC7r8QWvppvzP
_fDTu2Ww89H9rOBceOiiThEyo1adV-XtHIqhKPh2DsUwWy79ZnQMCBoAcuFoeUB_BG3Zjmno1Kis
aOt_5MetpZuGE0xDt2yHQlWd_0w-9LbcRT2ypD7Bf-q9rtZoFu5VX-3Bu3d-9vN_zNoHHe25f9Zq
d3I_252P7j-89G4-ZvmywRNfFPcd_9uzY8Ko5X-Ojx-YlfqYzx5-IPUxz59eTV-QxQUvFx28DNWx
c_UEPSWHn96NJqA6XLj2qBDiQyE_c_kwds7ezkKI2qgblu2Yhs4eHbZzKC43pqFbtsPqV9bOkg_v
3Xk5cv8QO2dm5zhBj6Lf62qNJtu3ZGiNZr-XpQ4wcoeIVzTxCnbO0s6TCBoAADtnYOf-92Gss7SK
7Hx0-_Gnd-sxBcktTz6yMrumrQ7rL_24cO1RP57LHO5sb6isyhH0JI6mCEWxs4xx9JSOpgjzpUYJ
AAAQNAAAjEE98qplO6ahz2VCr-fOyeC1E6-J4NnjD_ShUn5BLNup1BYxDX2O_2FcHj_w68lHVvyY
DodCUxsru9-rao1mBnYWQvzGlt_QwcNbD_XHzqG4TGiNZr-XLcGLPH5glzxob6iWoAEAAEEDAFSd
eq5mc2d7w_u9czJ_7cRrMnj2_ANzn5hlO6ah_zH7BqrF-m05mYi39qJiprZwj_qYx95WHXP7bapj
-vtvqo75zL2FEbR0dD63KF6GDDj6pU0y2PHSqRzaWfuDB8wi2Fkc-SR1O3-11JnU7fzImf8Zn5A7
QafCk4_syODxA7voeSicnWWcI0fngAraWQhRK7GdQ-EEaI0mjQGAnediZyFEnbUP8ubJd2Rwx_Zb
qQaAEELsflns33ZZQF8_1Gp3sHM2dq6EoD13oJh58vvnph9kFFqjSadDPDteOnX0S5v8OD8TO7n7
l5ejL2fevxW2czkF-fiBXU8_suLHjx9Q-eObJ99BrzB3R_dtSifFFj9_q7FLGJ-Kzs7H3hY-UUv9
7vkxTKqW-FXvF4pjXrj26Id-oJT53L_4OFYFSiho6eUpR3jz5Dt3bL4VXwDAHKlRAp_gkWXsuQPK
AgAIOi_OlgelgAl4eOsheZTppTaLE358u7vCKiNogELaOTIuh6PlwSojaAAAQNAApWb9zmPyoBQI
GqDSPHv8gch4jnaOjKFA1MfKbrU7njvQGk0KVz48d9Bqd6hDWo6GOaI9c2-qYz5_YFf2G6YWedU0
dMt2WGYQQli2Yxo6dQDsnP3nvM5ywhzx1W-ZDtVIlwuHt6-fecyPsXPh7IygIRd2ljGOnoWjK-W_
JbOzEKLGJgYA7JxDOyNoAMDOObWzEKLO0sK8sGzHNHQ-piBBPHdwlYAazSpqd-tthVD5_ks7ZlSB
sQXdanc8d1DN7VJovnbxCzJ4cN0bkTpotTtzcTRLE7kcexaWQldy3nT9Xrff60pFsIJpURt1wzR0
mqd8dg7FKgI1DZ0CztfOQog9C0ueO8iznSNjmJWgASAnds65o4eNjKMRNECF7JxzRwshtEZTHqxj
itQn_E_r3fHcAStRIB5c98bXLn7Bj4e90Gp3qBJM_XWhCKlTi7lnGrplO3mY5Q23LMqDBZvG0fJQ
-4tlO6ahU7qicN3ib8ljLk-XGk15sBApUs--FINevuGWxfOnV1k2KA0Pfe5mGRx8-8yUdg7GH62_
kPGLeO6A1ayioAFKb_dQXES0RjMDU6sP7s8nkTdPvqOYecfmWxUzDz_9WzFz56P70xd0q93x3IF6
CSC3eO6g1e5Qh5w4znMHexaWRiXsXVvObdPN1MvjPuLIoedSt-MffePp1O38wvPfjk_oxd82Dd2y
nfku-PnTq5FxNg1TWVlYtmMaOtLM3tF715YnsPNHqy9Exhkw-IGfxSe-gnYWQtQLsWsz9jJANhx8
-8xDn7vZj31He_5gz8KSup3n4uWQkfu9LnZO185TCbrV7njuIHHTQJ7x3MEs2gnGcvTwReno0JWc
v0ir3bFsxzR07JyWnYUQtcQM09At26GRKsWMOg3U0RrN4FHZOlTZzkKI_vTlq-LuqcjWB5gLb558
5_T3z6lk-uTt4_omVUx_-b-_UHFM09AVk--ihz8bqwK1acrXanfYQ4WGFQTIM0qCNg3dsh2KVQYu
bLp8jMayHdPQKRVAMQQdQ6vd8dwBdSyMnQNxq92hJABlFjRA-rn7s5_XB6WAcgraNHTLdiJvtdod
zx1QynJg2Y5p6CWzc2QMUB5BQxlYf_rKF-f3Pk09AMojaNPQLduJvNVqdzx3QDUL4Wjv2uOj7GzZ
jmnoFAmgeIIGKCKv-uDdyBhKzM5H96c_pmU7M92ckdTHGs40dMt2TEMfvtVqdzx3oDWabI7ccXzb
5WDry547aLU7o-Zf5MqWzNGAnYtiZyFEjeWsip1DMWTCDbcsyoNSYOdx7TyJoE1DHzXdVrvjuQO2
SJ5ptTujtqBp6NQndTtHxoCdFTPHFjQAAHbOwM4TCto09FHzbrU7njtgr_SIrS9fWbjnPxm1C01D
p1SAnXNlZyFEPfUZSEdrjeZY-1q-85gMLhzezm5L3dGeO2i1O1QiY86fXr3hlkU-piDjcsfmWyur
8qkEbRq6ZTumoacyCd-OMsbRWZLiOkKkoykCTExtFoO22h3PHVDcnOC5g1a7Qx0AKiRo09At28HR
eWT-tstHkp0t2zENnYIBlE3QiY6WdlAZ58Lh7ZExTGjnyBg7AxSN_uyGbrU7-V5XMRkvz24VKAJA
QalN_X-T0C3bibGD5w6ocg6xbMc0dOoAUGZB4_jcsfvlK0vz3z7BzgDFpZ7NYzx3oDWalDujan-5
kPw0UgooGTfcsqiYef70agnGrKVSNdPQLdsZdVeawnMHbK9svoXxdrZsxzR0CgUltnNpxkxH0IqO
hmzAzoCdyzFmaoJWcbTnDthnM8VzB9gZsHNpxkxT0Ing6DnaGQA7F27MlAVtGrplOzg6h3a2bMc0
dAoF2LkoY6YvaByNnQGwc34FjaOxMwDkV9A4GjsDwPTUZze0dHSMHXxHa40mKzGBmmUNsTNAWanN
dHTp6JgE6Rfpmpxz3eJvyQM7A0AZBF0aRwe9PHdHY2cABJ2po1vtju-om1c9ebA8kXaW5cLOAAg6
I0dLTXvuIOhlHB1Ss7RzfBp2BkDQs3L0fMux69zH8ghd-2j1hcg4Szur1Ac7Awghzp9eLceY9Syr
Jh2dW4MEvbzr3McrG64Z5ejs7azy6cLOAGWysxCilnHtpKNjEja9_Jt_-MNf-1nFt5rnDrAzQDXt
LISoZ19B6egYm-iObr0oPHegNZqVtbOKmrEzQCntPB9B_46WQXxmq93x3IEQIgNNr2y4Zte5j-14
vmqW766iZpUyAmDnIo45H0H7TrFsR8XRvrNmren5enksNStWDwA7F3fMuQna17SiZbLUdP7VnFs7
l3JpAO1mP2YuBO07WgbV1PQEalYsV8bIiQFAeQTtu8ayHUXpFEnTz1uXg-vM6dU8VpUAAEGnqWnL
dnxfj6XpnJrat7OM-9bR-pzHVbN6cfKA-5pQEQq0OYuClsOaWrYz7qz6vW4eNR0UtBDiPnMyNU9W
k3mtHb0KUGZB_30_wdzyZeqrBe1tuWtcL09TCgBA0HnUdNDU85K15w6EENqJP5Gn5vGXUDMAlEfQ
aXkqM1lLKUta7c4cXxkAEHSRND0s62msHXRxKlJGzQBQVEHP1F_R1o5nehejZgAolaBL6TLUDCH6
ve7wxVa7Q2UQdMG8Vly1FX3_kKWdcTSCLirFMh1eBhU7a42m5w6Cvzi6gtRL8A6_6fLsvup42X9T
mEbQ_Sxv6Xcvgs7U1PPdUjmZBj1MeaGgaKVf74wtWU0pQ4r0e91Rt1rtDvVB0JWQ9fQaTXc0gHhH
Y2cEXUUiPasCpQMABA0AUEVqlAAAAEEDAACCBgAoOG-89zqCBgDIo51-_p3l-wsPNthNOJ0xEgAA
ABB0RVh0TG9kZVBORwAyMDExMDIyMeNZtsEAAAAASUVORK5CYII=
:: main.lua
--[[pod_format="raw",created="2024-03-31 05:33:06",modified="2024-04-02 08:30:12",revision=1811]]
include "exports/lib/oklab.lua"
include "exports/lib/palette.lua"
include "gui.lua"


active_color = 2
bg_color = 0
pal_okhsl = {}
pal_code = {}


function _init()	
	window {
		tabbed = true,
		icon = --[[pod,pod_type="image"]]unpod("b64:bHo0ACQAAAAiAAAA8BNweHUAQyAICARAF0AHEAcAJyAXMAcAF1AXUAcABzAHIDcQ")
	}

	mkdir("/ram/cart/pal")
	wrangle_working_file(
		save_working_file,
		load_working_file,
		"/ram/cart/pal/0.pal" -- default
	)

	hidden_toggles = {
		[0] = false,
		[1] = false,
		[2] = false,
		[3] = false,
	}
	hidden = {}
	for c = 0, 63 do
		hidden[c] = false
	end
	locked = {}
	for c = 0, 63 do
		locked[c] = c < 33
	end
		
	rebuild_pal()
	generate_gui()
end


function _draw()
	cls(bg_color)
	if not active_color then
		print("\014poke4(0x5000,get(fetch\"/ram/cart/pal/0.pal\"))", 292, 4, 7)
	end
	gui:draw_all()
end


function _update()
	gui:update_all()
end


on_event("drop_items",function(msg)
	for i = 1, #msg.items do
		local item = msg.items[i]
		if item.pod_type == "file_reference" and item.attrib== "file" then
			send_message(pid(), {event = "open_file", filename = item.fullpath})
		end
	end
end)


function rebuild_pal()
	for c = 0, 63 do
		pal_code[c] = get_color(c)
		pal_okhsl[c] = oklab.color_to_okhsl(pal_code[c])
	end
end


function update_pal(c, hue, sat, lum)
	local hsl = {
		h = hue or pal_okhsl[c].h,
		s = sat or pal_okhsl[c].s,
		l = lum or pal_okhsl[c].l,
	}
	hsl.h = mid(-1.0, hsl.h, 1.0)
	hsl.s = mid(0.0, hsl.s, 1.0)
	hsl.l = mid(0.0, hsl.l, 1.0)
	local code = oklab.okhsl_to_color(hsl)
	pal_code[c] = code
	pal_okhsl[c] = hsl
	set_color(c, code)
end


function save_working_file()
	local output = userdata("i32", 64)
	for c = 0, 63 do
		output:set(c, get_color(c))
	end
--	local output = ""
--	for c = 0, 63 do
--		output ..= color_to_hex(get_color(c)) .. "\n"
--	end
	return output
end


function load_working_file(item)
	if type(item) == "userdata" then
		for c = 0, 63 do
			if item[c] then
				set_color(c, item:get(c))
			end
		end
	elseif type(item) == "string" then
		-- TODO: remove support for ".hex" files?
		local colors = split(item:gsub("\r",""),"\n",true)
		for c = 0, 63 do
			if colors[c + 1] then
				set_color(c, colors[c + 1])
			else
				set_color(c, 0xff00ee)
			end
		end	
	elseif item then
		notify("load_working_file: unkown type: " .. type(item))
	end
	rebuild_pal()
end
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Iixtb2RpZmllZD0iMjAyNC0w
NC0wMiAwODozMDoxMiIscmV2aXNpb249MTU0M11dbHo0AGgAAABYEAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD--------------------78QgiKSxoaWRkZW49ZmFsc2UscGFuX3g9
MAgA0nk9MCx0aWxlX2g9MTYKABB3CgCAem9vbT0xfX0=
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2IixzdG9yZWQ9IjIwMjQtMDMt
MzEgMDU6MzM6MDYiXV1sejQABAAAAAMAAAAwbmls
:: pal/0.pal
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTAyIDA4OjI5OjE1Iixtb2RpZmllZD0iMjAyNC0w
NC0wMiAwODozMDoxMiIscmV2aXNpb249NF1dbHo0AAkBAAAVAgAA9QV1c2VyZGF0YSgiaTMyIiw2
NCwiMAEAwDFkMmI1MzAwN2UyNQgA8BcwMDg3NTEwMGFiNTIzNjAwNWY1NzRmMDBjMmMzYzcwMGZm
ZjFlOAgAQDAwNGQIABFhNgBgZmZlYzI3CgAgZTQ4AEAyOWFkJABgODM3NjljIAAxNzdhOADAY2Nh
YTAwMWM1ZWFjMADwHWE1YTEwMDc1NGU5NzAwMTI1MzU5MDA3NDJmMjkwMDQ5MmQzODAwYTI4ODc5
QADwA2FjYzUwMGMzMDA0YzAwZWI2YkYAYDkwZWM0MgoAIGIywACgNjRkZmY2MDBiZIkAAJYAQDBk
YWJAAF84NTZkMAEA6VAwMDAiKQ==
:: pal/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDE5OjQ3OjQ2IixzdG9yZWQ9IjIwMjQtMDMt
MzEgMTk6NDc6NDYiXV1sejQABAAAAAMAAAAwbmls
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA3Iixtb2RpZmllZD0iMjAyNC0w
NC0wMiAwODozMDoxMyIscmV2aXNpb249MTUyNV1dbHo0ABABAABRBwAA8CdweHUAAygAAAMABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDBAUGBwAP-5AICQoLDwwPDQ8ODw8QAPAADQ8RDxIPEw8UDxUP
Fg8XEwDxAQ8YDxkPGg8bDxwPHQ8eDx8UAPEAIA8hDyIPIw8kDyUPJg8nFADxACgPKQ8qDysPLA8t
Dy4PLxQA8QAwDzEPMg8zDzQPNQ82DzcUAP8FOA85DzoPOw88Dz0PPg8-AA--8P8BAOv-J1oBEAYP
IBABIAEgAfAAAhACDBABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDDAA-zkf-wEA
3L-4D0AADUD--7DwcAoA--9kH-8BAJdQ-----x8=
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2IixzdG9yZWQ9IjIwMjQtMDMt
MzEgMDU6MzM6MDYiXV1sejQABAAAAAMAAAAwbmls
:: todo.txt
--[[pod_format="raw",created="2024-03-31 20:08:43",modified="2024-04-02 08:30:12",revision=449]]
- copy/paste colors
- text entry for hex code
- "New Empty Palette" in menu;
- right click for fine-tuning colors;
- import ".hex" files;
- accept drag-and-drop (or copy/pasting) of gfx;
- import the palette from an image saved by
  the #paint cartridge;

Maybe:
- reorder colors by drag-and-drop (i.e. swap two
  colors)
- multi-selection (ability to move a group of
  colors in the sliders)

:: .info.pod
b64$LS1bW3BvZCxhdXRob3I9ImRyYWttYW5pc28iLGljb249dXNlcmRhdGEoInU4IiwxNiwxNiwi
MDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDcw
NzAxMDAwMDAwMDEwNzBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwMTAwMDEwNzBkMGQwZDBkMGQwZDBk
MGQwZDBkMGQwZDA3MDEwMTA3MGQwZDAxMDEwNjA2MDcwNzA2MDYwZDBkMDcwMTAxMDcwZDBkMDEw
MTA2MDYwNzA3MDYwNjBkMGQwNzAxMDEwNzBkMGQwNjA2MGQwZDAxMDEwNzA3MGQwZDA3MDEwMTA3
MGQwZDA2MDYwZDBkMDEwMTA3MDcwZDBkMDcwMTAxMDcwZDBkMDcwNzA2MDYwNzA3MDEwMTBkMGQw
NzAxMDEwNzBkMGQwNzA3MDYwNjA3MDcwMTAxMGQwZDA3MDEwMTA3MGQwZDBkMGQwZDBkMGQwZDBk
MGQwZDBkMDcwMTAxMDYwNzBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwNjAxMDEwNjA2MDcwNzA3MDcw
NzA3MDcwNzA3MDcwNjA2MDEwMDAxMDYwNjA2MDYwNjA2MDYwNjA2MDYwNjA2MDEwMDAwMDAwMTA2
MDYwNjA2MDYwNjA2MDYwNjA2MDEwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAi
KSxub3Rlcz0iIixydW50aW1lPTUsc3RvcmVkPSIyMDI0LTA0LTAyIDA4OjMwOjEzIix0aXRsZT0i
T2tQQUwiLHZlcnNpb249IjAuMC4zIix3b3Jrc3BhY2VzPXt7bG9jYXRpb249Im1haW4ubHVhIzYi
LHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249Imd1aS5sdWEjODIiLHdvcmtzcGFjZV9pbmRl
eD0xfSx7bG9jYXRpb249ImV4cG9ydHMvbGliL3BhbGV0dGUubHVhIzIiLHdvcmtzcGFjZV9pbmRl
eD0xfSx7bG9jYXRpb249ImV4cG9ydHMvbGliL29rbGFiLmx1YSMzNyIsd29ya3NwYWNlX2luZGV4
PTF9LHtsb2NhdGlvbj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn0se2xvY2F0aW9uPSJt
YXAvMC5tYXAiLHdvcmtzcGFjZV9pbmRleD0zfSx7bG9jYXRpb249InNmeC8wLnNmeCIsd29ya3Nw
YWNlX2luZGV4PTR9LHtsb2NhdGlvbj0icGFsLzAucGFsIix3b3Jrc3BhY2VfaW5kZXg9N319XV1s
ejQABAAAAAMAAAAwbmls
:: [eoc]
