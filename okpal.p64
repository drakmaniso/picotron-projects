picotron cartridge // www.picotron.net
version 2

:: .info.pod
b64$LS1bW3BvZCxhdXRob3I9ImRyYWttYW5pc28iLGJic19pZD0iX2Rldjk3MiIsY3JlYXRlZD0i
MjAyNC0wNC0yNyAxMjozMDo1NCIsaWNvbj11c2VyZGF0YSgidTgiLDE2LDE2LCIwMDAwMDAwMTAx
MDEwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDAw
MTA3MTYxNjE2MTYxNjE2MTYxNjE2MTYwNzAxMDAwMTA3MTYxNjE2MTYxNjE2MTYxNjE2MTYxNjE2
MDcwMTAxMDcxNjE2MDIwMjBiMGIwNzA3MGUwZTE2MTYwNzAxMDEwNzE2MTYwMjAyMGIwYjA3MDcw
ZTBlMTYxNjA3MDEwMTA3MTYxNjA5MDkxZTFlMDMwMzA3MDcxNjE2MDcwMTAxMDcxNjE2MDkwOTFl
MWUwMzAzMDcwNzE2MTYwNzAxMDEwNzE2MTYwNzA3MGMwYzA3MDcwMTAxMTYxNjA3MDEwMTA3MTYx
NjA3MDcwYzBjMDcwNzAxMDExNjE2MDcwMTAxMDcxNjE2MTYxNjE2MTYxNjE2MTYxNjE2MTYwNzAx
MDEwNjA3MTYxNjE2MTYxNjE2MTYxNjE2MTYwNzA2MDEwMTA2MDYwNzA3MDcwNzA3MDcwNzA3MDcw
NzA2MDYwMTAwMDEwNjA2MDYwNjA2MDYwNjA2MDYwNjA2MDYwMTAwMDAwMDAxMDYwNjA2MDYwNjA2
MDYwNjA2MDYwMTAwMDAwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAwMDAwMCIpLG1vZGlmaWVk
PSIyMDI1LTEwLTIwIDA5OjM0OjQ3Iixub3Rlcz0iUGFsZXR0ZSBFZGl0b3Jcbih1c2UgbWVudSB0
byBvcGVuIHRoZSBtYW51YWwpIixydW50aW1lPTIxLHNhbmRib3g9ZmFsc2Usc3RvcmVkPSIyMDI0
LTA0LTE0IDEwOjMwOjA0Iix0aXRsZT0iT2tQQUwiLHZlcnNpb249IjEuMi4yIix3b3Jrc3BhY2Vz
PXt7bG9jYXRpb249Im1haW4ubHVhIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJnZngv
MC5nZngiLHdvcmtzcGFjZV9pbmRleD0yfX1dXQ==
:: gfx/
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Iixtb2RpZmllZD0iMjAyNS0x
MC0yMCAwOTozNDo0NiIsc3RvcmVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Il1d
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA3Iixtb2RpZmllZD0iMjAyNS0w
NS0zMSAwNzozNjozOCIscmV2aXNpb249OTI2Ml1dbHo0ABZEAABKogAA9iN7WzBdPXtibXA9cHh1
AEMgCAgEcLcgRyAXIEcgt3AsZmxhZ3M9MCxwYW5feD0tMS44MwEAETcXABB5FwAnNDICAKcsem9v
bT0xMX0sWQDxCAwMBDAncAcgB2AHoAegB5BnQGdAJwAnBAA7Z-ALagBGNi4xNgEAFDNpADcwLjMB
ACIyN2oAHDdpACPwDGoAPyAHUGgAS-8SN2BXQHcgFwAXAAcAFxAHEDcQByAHEBcQB0AHMAdgN-AM
cAA3nw0JBACnEAeNBwQABi_nAG4AN-EGCQkEMAdgBw0HQActByAHTQcAB20XAgA-BwBnaAA78AMA
NzAHMAcgB0AHEAdQBwAHYBcGAAAOAF8wBzA3MGwAOikQR8wAAM4AbwdNByBHEGYAN-8KGBgE8Cja
gNoPGXDaHmDaLlDaPkDaTjDZXgMABPsCTkDZPlDZLmDZHnDZDoDZ8CiLABMwfQASMG0ADVYD-wjw
GwewB7AHUGcwBwBHQAcQJ1AHIAfwDEYACx84RgAFAbkCEgCOAQ9KACCjCwsE0E5AbiCOEAIAXCBu
QE7QQgBELjEyNUYAAQwAAUoALDEwSwDjIEdAB04HIAduBwAHjhcCAM8HAAduByAHTgdARyBZAHtU
QEAE8P8BANG-B-AuJ-AsR-AtB-AvAwAaMAkAFTADAPIGF1AH8CknIBfwK1fwLRfwLgfwWwcAAgBT
J-AlBwACADHwJycJAFUX8CYHABQAUAcABxAXKAAPswATHzOyAAEQs1UAEixRAG4sFwAH8GsRAEIg
B-ArEQDRK0fwbDfwKwfwL0fwawYAQSsH8G-pABAtEgBAEBfwKy8AIyw3NwASRxAAEW-3AE0rR-Dt
GwGSLwdAB1AXACcA4gASJwIAgBAXABfQB0AXHQR1AAcQBxAHAAIAAWgFAxAAMMCHIC4AAhAAOBcQ
JxwAIfADTgQPPwAJYvADB0AXEBUAJRcAIQAxECcAFgAfoFkBIfAOEBAEELcgB7AHAAfQF9AXUEcg
F0AnEBcQFzAnMAcGAJFgFxBnQBcgR1AMAP8AQAdwF9AX0AcAB7AHILcQcgATHzFyAADxBNcA9xdA
lyAXEHcgNwB3IKdgl0AVAD8ZANdYACglBwACAJEwB7AH8AAX8AYOADEgF0AtBBFwtwURQPAAAAIA
MUAXIAgAE7AYAEDwCBfwDgAAWwQFYgEP5gAnBVgBAEABQBAXECfAAbEwJzAXYCcwF0BnEHABAAwA
P3AHQFgBNrYUQJcQFyCHADcgx1gBHxZYAT0RAw4AMVAXEPQCALoAAMYAEbAWAADqAwLNAhOwGAAv
8AVYATSDBTME8B0HABdFABAXgAcKDgABGwPhV1BHMEdABzBXgEcQBxBuBv8BIAcAN0AHIGcgB4AH
MFfwEy4DIQB_ABAKWgA2NwAHUAABaAAgVwBoAAAbBAAIAEZHMEdQFgAJogAPegAjCVACQVAXUBfM
CfMBFyAXIHcgFzBXMBcQNxA3EAYAABAAABgABCQAADAAD1wCHR8zXQIDMAcQp6EEcRB3cIdQdzBq
AGEwd1CHcHcWAG_nEPcHANdlACgv8PCfACgDHgEB-gAwJxAnAAHzAjAXIBeAFyAXcBcwF2AXQBdQ
AgAf0BQBOTAFUIeIAWEQNxDXEMcCAE-XEPcOCwFkAKMCH_9iAiEyCwUEpAI1BwA3owMDyQcmAAdv
BgLHBw9iABMZNmIAoBkLBBD3BSAH8AXNBhAHnwIQBxEHAKMCAEcEAAIABD8EARAALxcQHAACFiCB
BwEQACDwB1AAbwUHIPcFEBAJIgOZAJD3BwD3DRAHACdtAEcQZwAnZwASV_gHDRgAJ2cQmwBfAPcM
APeHACf0BVQMBFD3B0D3CPAP9wkgB-AIB-AOCQCyDfcLAAfwCgfwDEeOBQEfAWM3AAcwJwBDAVUg
B-ALR5kAAJ0IImdACgAUBxYAQ1AH8AojAADkBzAgR0BjAQOOCEAwB-AJ5wATBwIAOEcAV68FAFwF
ACEHE2edASAHEMkLBwIAECAfCoIH9xHwDAfwBgcAOwX3RAoBVDMzLjg3CwFWLTcuMTTADAOmDB8y
FQEFlAfwBwcg9wrwDgkAQA0H8Al1AULwDAcwpAIDpQEyAEcgowB2JxA38AsHMKIBAGoPElcKABQA
FgA0Z-AKIwABpQchMFdEAAElAWQgR-AJB0AqAAEFARUwQAAEJwEg8AgJBwKWAioXQB8AwicQZ-AH
B-AM9xHwBgcADxUBMPADIg8E8BT3DiAH4PcAAAfwAPcCBADxAxCnIDcgF0A3EKcgJ0AHQDfwAAcA
BA8ABB8AAy8AIAEAPgBfIPcO8BSuAhMfOIMAAnL3AOAHAPcBVQDxAzegJzAnEEcQN6AnIEcARxD3
AgcABA8ABB8AIvcCLwAgBwA_AA_DACZfVAwE8AoxAwaQdyAnYFcAB1DHtAEg8Ay3AxAXrQEABgMR
oMkBUfALZwBHwgEQZ_wRAh8DDhMAIwl3EwASdzkAU2AH8AiHTgAGEwC0B6cgJ2CHQMcAB3D-AgMC
Aiv3Pt0A8wAxNy40NDY0Mjg1NzE0MjnnAMAtNC42NDg4MDk1MjMGAA5CBQryAA8OAwAwYCcg8wOR
Z8AHAFfwDAdQPAwAtgNAAGcAp8UEIfALOQ8A-QBDUHcAp-wCDRMAOgkHYBMAU3fwCAdwTgAFEwAw
BweQcABTh8AHAIfcAg-yAD8PvRIiD28FEwBbAE8jVzCXUQA6cS0HcAcQJzBuCh8ATwA0AXsBH1BN
ACqXKGoBAAAJAAAA_Q9P----tpkAIgGTBZEA8DMH8AAH8DIGAEAxB-ACJBAVMG0GEiAtDwILAAA3
DEDwLgdAqAYAeQM1LQdQGgBlQAfwLAdQOAAQQL8PAMEDESoGAD8p90SkABMdMu8AEAXvABEAmAUR
wJoFJIAXKwdDACfwEnIAEyA7BhKwHQByJwAX8BYXAB0AERfKEBEgDQARoAYAExCzCBGgrAABMABz
ByAn8AInANAAFeDYADtgBwACAEMgB-AUCQASIFYAALYPJQcgFAAQACEAAg8AAgIAA0ERAhMAEMCR
BgMNEBEgiA0bAAIANSAH8MQJQCcAF9DOBgSKAATpB1EHIBfwEzIQCYQAIxcQLQAi8BSUCQF_ACIX
ECQAKBewfABlFyAHsCcAVQBBIBfwAzsAACsADwABCQACACPwFuwAAXwAAlYBIwcAFAABfgACNAIO
-gAEOBED-AACFgAEOgAC_AAAwwAiJ8D_AAC5ECYHAAIAECf0ASInAAIAKRcQwgFSAAfwFRcJAAJ4
AAFHCDIAJ7BcEQAOACQHsGMIAR8BIPACCwALmgI3MTMxnAJHMi4yMIUYAqYCGTRJA1MvBQQQFwIA
BagAAxAAJBcgCAAlBwCtEAISABMACAASMLIAHBcYAA4yABcgZgAmEBdkAA_DDyJnCQkEl2AXAgAf
l0YAFB80RwAAPQBHAAQAD1EAJwDpCAAPAhFAzxEgYBeEAgMSAC8nIFUALQMhAgapAAJAAg9fACof
EOgNFx85OQCp-w1oAdABBwHAARcBsAEnAaABNwGQARcRsBEHAfAUVAAlEUhUAP8HsAEgAZABByAH
AZABIAGwAQcB0AHwN1QAJTE2AQBEAFEHEZABBwIAE4AIAP8HcBFHAWABBwFHAXABVwGAATcBoDHw
JmgAJTdWQZBYAABSAA9WADETWGYBXwcRAAGQuAAJHwTIASgPXgBIURURABGgWAASsMgADwQABgGk
AX8BoBEAEfAWBgMmDzkA--------------------------------------------------------
mHwo4AEAAA4BljMFAQDxGpQn8P-FNyCH8P__dwABlwHw-7uXASchRxHw-7dXMScBBwGXAQfw-7O3
DiswNyFHDgCAsdcBBwF3ETcMAICv1wEHEZcRJwwAQa03EXcoACG3ARAAYqs3ATeR1wwA8AepNwEn
EdchdwEnAfD-qDcBJwH3AyGHGgDwCqcnARcRhwHHEXcB8P_mJwEXAbcRdwE3AWcPAKEXARcB5wFn
AUcRegAQpJIA4FcRhwFnAVcBRwHw-6QXGyzwAxG3AWcxJwE3AfD-oycRRwGHEVQAMKcBNxAAUAFX
AXcBSABRBwHXAScSAGDnAVcB9wANAPAGoScBNxFHAScBZwH3BPD-oRcBNwEXsgBQARcBZwHQAEBX
8P_gfiwRFxgAIIcBoQA5dwFHFgAwJ2FXdABR8P_gAXchADEnEQcJAVBXAVcBZxcAEVeSACIHIRcA
YQcBJyFXAdIAIaBXRgACFgAhRwEiABARLAFwJ-D-bqfwFmsBEucdAPAHIRcBF-D-avcD8BInEVch
BwH3AxGnAfAyAiAA8QDw-zf3B-AQFwF3EQcB9wa6ARESGwBAt-D-NMg3AKwAwTcB9woBNzEn8A8B
B-QAYS-3DfANF7cAYPcMUVfwDhgAgAfw-yz3D-AMGwEh9w1FAADwNwAbAPACCvD-KfcR8ApXARcB
NyH3AyHtADFH8AsdAJEM8P8n9xPwCRcaATAHEQdAAEABASchCwAxN-AKJQCRDvD-JfcU8AknDwFg
FwFXEdcB8wBRBxEX8AkiAIAQ8P8j9xbwCIoBISEnIgExpxFXIwAAtDUAIwBQEfD-IveZPSABN5oC
IQFHngFQFwFHATd9ASHwByYAUBPw-yABJwABjwAAHQABWgIBdgAB5wFBBwHwBioAoRXw-x4B9xnw
BjeBAQJHABMnWwAAYwAwB-AGKACCF-D-Hfca8AY9AAUdABIBuAEBpAAEUwCzFvD-HAcB9xrwBTd8
ABNHGAIADgABYgAg8AUNAMP3GPD-GgcB9xvwBSd_ABNHKAAVB7YAUQcB8AUBTwB0-xkB9x3wBZ0A
IVchJwAiEUeMAANTAMAa8P8XAfcEQfcF8AWKAQBGASJXAQcBAJkCEjcsABEBdwBg-xcHAfcBSABT
EfcE8AaEAALNACIHIVkAAFgAgPcEMfcF8P8VLgAiAQcCAFQR9wPwBgwBAYIAA18BAGIAArMAIwAx
KAAo-xQ6AAAUABMCbgAAOwEQNwICAdkDUDcBF-ACOQAXEWUAKf8TPAAAFQAUAXoAAT8AAIoDAQgA
QDcBJ-AqABTXPwACagAl-xJNAwYCAAFEABYhgQAHQgAJQQADQwAVEY8DAQYAAKQAIPAGCgMD-wAR
J0wEAkEAVgABBwHHLQAArwAk-xBAABJnEwAQAEoCAz0AIxEXyAABPQAEPAAVZzwAFQ9QABWHewAX
J3oABz0AAPUDAB0EAmMAIv8PywABEQAqAedzABNHtwEiJ_BeAAI2ABDnbwAS53EAKhHnaAAUR2gA
VOAB1xHHLwASDS0ALAHnYwATJ2EABmMAE8eIACX-DTMACmQABs8CAWYAAM0AEec0ABDXaABG1xH3
AWUAAlgDBGUAEXdjACT3AS4AUAzXAfcEBAEVBSwABV4AkUcBZ_AB1wH3Ai0Aksfw-wwBtwH3BFoB
JwXXWAASx1YAwQMBBxHX8P8LxwH3BVQAJ-cDTwARx00AgAQBBxHH8P8KSQES9-4CAigAAUsAMPcD
4B8HIvcGcQAQCiUAAgwBBEwAAKcAMPcD4G8AA5YAEwgxABARJQBVCREnETdHABAIawAQCKUHI-cI
RgARCUQAIfcIQgAQCvsFEAgfABUKPgAi9wg8ADELAac8AESHAfcJpwAARQAAAgADPwAQCz8AASIA
EgvvABcIQAAQDEAAEQahAi33C0EAEQeEAhSnJwABJgAXDUUAEQfWAQBcBhCXRgAQdykABUQAESdC
ACLgB0IAMQ4Bh0IAT1cB9w5CAAAQDx8AEQQfAD8RAedAAAACIQABJwQg9xJjABIEQQAyBuAHQgAx
EAF3QgATRyAAMgX3B0MAMQbgAfgBEBHFBxAEIAARFGIAFgc-AGGnAfcTAVc-ABA3HwABPwAhBRE-
ABIFiAMEIgBAATcB5xMCAiMAApAAMwXgAUYAEBQkABADeQACJQAQARICFSH9BBMArAAQAvwCQEfw
-wIqACb3ACsABaoEARwCAq8CACwAQTfw-wKRBSDnESwAMwLwBfACAy4AIQLgGQkh9wMHABEHMAAB
LwAB-AkQlzIAIAb3yAADAgBAEfcC4CoAEbcfBhC37QgCYgAAFQAAgwcSp2UABbsFADMAIAHQ5QMR
tycDE6czAAIyADFHAWfXACHwBXIAB5kAUAHAcZcBeApQFxFnAZdjBXDw-wEBRwGXHgYwcbcBFQE0
NwHXXgUAMwDRAIC3AXcBxwEXEZcBdwkFEf8fAAAMAABMAIP3A8BnAdcRZzAAAWkBgVcB1wGHAUcR
BwoAYgARZ_cKopcBxwG3cSDnAddtBSAh14QDkEcB1wGXAVcxdysA8QIAhzFnAacBxwGXEfcJAecR
h2cBMtcB98UBEKeGBAAnAABcATCnAdfkAjMLAeeFBRDXsgMRF0gBAScAEP4mADDHAdfHAjAMAee8
BSIR15oDENfMAWEBARfw-seuAACZBBD3BgUFSgAQCQoCENcFADAX8P0nAhBHDAARN64KIfcMWQED
UAAwCgHX9wBSAQEH8P0oADACERcqCgBSADLnEcdQADEKAWepAQAAC1BnARfw-EAAAK4CIBG3jwMH
UABRCwFnQbf0BwFmC0Lw-AG3wgQiAgErACIRx2kBUQoBdwHnKQA0RwGHUwAAfQYCKgAhDQFkAgWA
ABB3EAARF04HE5dXAAMtAAERBEX3ABHHgQACKwAAuAsADgsBWQAVdyoAJecRVgATC9YAAjEMURfw
_wG3GgI4xwGngQAkEecBARG3rgABKwACVQA0JwHXLAABkAYW5ysBERcGADEn8PsfDCB3EQICEoer
AAZXABELOwcRpx4JMIcBN1cAYRcBRxGHEcsDEXdaABEBWgAg9wA_ABUAMAAQZ2cAYfD7ATdBp2YC
EPeoAhDnGQJSABH3ARE_ABEB3AoALwAwd2FXXQAh9wPvCTCHAXdXAhAAvAABOQcB3wMBMQBQFxF3
AZcmAjAF8PsvAAAoAxCH3gQQAfsDEAEIAAGNAGFXAfcCIZd8AzBXAcdcAAIFCAApAxCniwwQAbAA
EwLMBwMxACEBtzEAUTcR1-D76QMCMAAQ5xsAE3fLBBIHtwBh9wIBxwGHoQog5wFfABo3LwARZy8A
JAMRLQARt3gGU2ch9wABXAAAuAkSl4EHEleKAAJeABAC3gAAMQCRF2H3CgEH8PtXLQAxZwF3mAER
99cFEQNcABACWQEQA48CEAL0ABAHcAEBPA4CmQAA9gcATQABIQgiAxFkABEDGgMRJ6gAMBfw_7EA
NqdRJywAERFZBQosAAANBAB-AgKVBBB3cQAxBQEXLQARBYkABCkAMrcBx1UAIfcGCwkACAgSEVUI
AVYAEgRZABGXLQATx4ACAPcDGLcvAAEDAAcrAADyAgF_AhFHKgARJ2MCIvcGlQgCWQASBT0BEYcx
CVPXEUcRRwwBAFkAElfaCCH3B1kAEgZ-AxF3KAlQ50Fn8PwFBgkoABIBswAJKgBg9wABl-D8WwER
x_wBF5dTAAKiAgLjDwIoABGnYgEAgQARh-YAEwhTADEIAddNAwAsABDnKQARl1UBAAMBAY8CIfcJ
LAB0CAHHASdRdyUAQkdBRwEpADNXAQcnAEIn8QMXKQARd_8BENcpABHnAgEhp1FwA0H3CjE35wOD
FwEXIfcJAbcqAGHHAafw-HfSAwBKAlMB9xwBd5AEAWwPHKcoAAAEAADFAB8bKAABAA4HASgAEUdQ
AAGCBwIpABInWQUxCwGXKQA9dwGnKQATGqAQAykAAAUBAikAMgcBhysAEXcmA0GnAfcZyAsFLQAz
DAF3LwAARA8BLQAARQEDLQARGIsDACkCBSsAEZesABQnKwAAKAYOKwAxDQFnKwBYlwE3ETcrAAD2
ASH3FkQEBSsAEVcrAIGnMVcBh-D9ZxUCH3cpAAgBfwEAKQA1pwGHJwAkEUcnADgTAZclABGXsQAR
12cJAXoJEideAhMSJwAwhwF3JwA0VzGnJwARZ0gLFCegAQspACaHASkAExHzBg8jAAAxNxEnfgYh
9xJvBBGndQFB9xABpwIABykAEidpBmAB9xIRZxF5AxI3KQACQgUYVysAMQcRV7YDIfcRyQgSl08D
Hw8rAAAiEXcpABAQLQUoEacpABFH-wIDKQAkZwGzAyH3D1gFEQcVABA3vwYAHQgCLwAAggEDMQAA
YgEDMQAAIgAxZxGXBgcn9w0vADJnARcvABE3DwAZRzEAA2IABzMAAV4AIgEHMwARJw8AAMsAAaMI
EQwcABGXjwEQV9kCESczAENnIZcRLwA5ZyFnLQAhEXeTAQgtAADaAyLw-TwDEUdcBRBXdgMRB5IE
EYeBARBXCQQYNy8AEYdtAwYvABQRXAAAcgYq9wgtAABuARFn7QARpx4AFBFcAAGiBAAqBRNH6wAS
1y8AM8cBZ6gFEGeqBQH1BioRdy8AACcBAy8AABwKBS8AEwVdEyJ3AS8BEmcQBgCxAzKHcecxABHn
jQAg9wFtBwIKCAC3AA0wABB3owUxd-D_SQkhB0EvBxBnagcSJ5MABTIAERcaAAMTATM3Eac1AACV
CwHmEwI1AAT3FAM1AAIaAAEmARFXOQEAhgAEOQASV8UMEWc4CDU3EWc4AAAGAQEZAACbCgCHChEH
ZQASNzoAAGsJYGdxxwFXIf8LCnIAEXd9CwA5ADEXMUfVAQDtAwE3AACZASH3AMsBQAcRtyHhExlH
cgARB-8FAMgEEUcfBB0XOABRFxGnEUckAxdHcAARB2wDBDgAIVcBTwEAUQAVt3AAQAEHEYdPARAR
rAAGPAARNwoDEQewABi3PgAA7AADyhARt4oAIAeh_hYIeAARRwwXEQceDRE3kgACFgAQFz4AEVdY
BxG3PQAAoQAGAgAjZwGDAAFsEwKDACIHYRoAABsDCUkAEReRBhFHIQMAvwMBLQADAgAACgMUN44A
AA4YBQIAEyfmBgDQAQJ0BmMH8P4HAXdLAAK2DRFnKwAgtxFnFxFXjAARZ_YBEwcCAFE3AUchV34C
AIIBB0UAEacaBBNHcA0h9wjEACJXEYcAEXcVAAD4AjEXUXdDBhQnPAABNwYA5AAgZyEuACD3CMoD
Ac4BAtADAG8BFEewAgEHB1IBVwHw-soEAckDgZdRRwH3CCFnUgEA0wZgRwF3EbcRHQoRV1wAJZch
NAACYwoQh6oDNvcJAWoAEscuAiIRZzEAAMoCACwCUzcBNyF3AAhD9woRp2EAINcRAQMNLgBGRzEX
AS4AJwG3XAAQh2oCGwEwABWnMwgA9xEDXAAxtwEHXgAGLgAAMAMJMAAQl1AFIKcRLwEANgACXgAU
l_0AAWIFDDAAEQ2zAwLzBQBoAxF3OAARlzwDEVc2AAAaAQs2ABHnRg8AZwAAgwADaQAALgIyIXcB
-Q8Qd4MRKQBnNAAs9whqACERtzUFEWeGBwAxAAArBwgxAAGDAwpmABHHxgUAWgAblzMAEIcLAgI0
ACMBJ2UAMZcRx-0GEYfLBQCoFgIyAAAwAAUyAAGXAARVAhWHGhEThx0HFQc0AAB7AQ9mAAMR1xgH
AjIAMVfw-6gJAjIAAGgAALQKGgdmABERaQ4PMwAIAQ4NFQZnADF3EZcgAAo0ABEH1AEXR2kAAIkG
B2kAPxF3ETYAAwClAwhsAADKCxEHMgQAvQMRB0IEAN4EAfcIAYMEECc8ABECHwARJ00AAOoDBIAM
AtkBETc_ASpnETsAABoAADsAAE8CBzoAFAQ6AAV1ACMRZ4sEE5c6AAErAgE6AACeBQh0AACvAAJy
ACKnATYAESd_AAL9AxEHEgAOOgAMdAAj9wM7AAL2BCInAY8ESsfw-wM5AABmBAZzAAA3ACMRRzcA
AJsDCDcAAAIBE4dABxA3UAYAAQoR130EEjc9DwRxACEXEWUAAKMWEATDAQKlAQM4ABEBdAE15xEn
OAAhEUd2ADFnIXeCAQ82AAICbgAi5wFuABGXFQAVV0sIEYcnBRHnOQATl6cAEVddAwAiBAZwADbn
AVdvAA82AAMxUFcBDgATEbsSEVfvCBEnXAUAFQAACAEAugMEOQAAZwEGOwAA_AACEAMBgggB1xMB
pAUBsQYCPgAAiQAEPgAAzwAIeQAAVwYBPgARAo4BIRFHPgABBgABtBQRl_IFBD4AAEAAAiYBBXwA
JRFHmxABOAAjEVd6AAHVACIBZzwAKQU3PAAAMwMCegAmNxF6ABMXNwMhBwETAS8RdzwABBFHeAAS
N_kQEkfhAQEpCAO4AAA_AADiAAI_ABFHHAAdF3oAESc8BBJnag8KQQAVZ0EASdfw-wZBACFAdzUB
IlcB0ggRZysHEdctAQCFAiA3EeUHAjwAYccB8P8HNysABD0AAGYIBzEIECE3CRHHsgARBykHH5c9
AAgRMEAIAnsAEkdAABARFxURxxwCERfKAgAxAAJCAACrBEHw-we3dRESdz4AAbkAMBFXUWACILcR
VAwRF5EDFUc2ABI39SAINwAAtwUBRgsRZ4gEEydWDAQyAAApAQoyABEHEwEQV9gBE3f2BgDCACSX
ETMAEVdaFQgzAAC9ABLXShMAoAERRzMAAKcFE3czACFnAaMWAkgOBDQAAfsOEQHgBBEXNAFTVxGX
EYegADB3QTcAGgAzAQIwAACSBAMwABGXUQETp-AAAO4TAA8aQRFHEVfiCyBXMNQFAywAESdzCxJ3
CAsFLQAiJ0FaBSBHMNcDErcrABI3UwIBcQ4xpxA3IQAALgARCToAUIcBN0DHKwARAKIDEyctAADT
IUEXAacwIwEKLwAQUNgSEedCAwPwAQAIAQC5CD8Rp0AwAAER1wgAArIFAAwCBTQAAMMIRxGXcAc0
ABEBjQRRN1DnEXdSAhEHPAIRFwUDAJoCFWd0AAMCAF0RB0E3kEEAQSdw9wDdCBEHqQICSgAhB-GD
IAwCADwXEcA-AFMXkFfxAjUABNcCFCHfAlEnAVcxBwoAIgdBCAA6J9CHQQAQ4EUBCwIABV8DURcB
N0EHoQQSB8QJWHE3AYewgwAACBABjhkLAgAXIVcAA3sAAXEMMAGXEb0NEKBnASf3AkQAJQGHdAAi
F8EKAAJRAREHKQMC5wQHNwARAqwQAU4IEwcLAgwCABFHcQARRwIAALkBJGeQPwASCvwANfAAx_gF
BzUAQQFnEVfVGQA1ADFXkIcMAgs3ABNXYgEEHwIAmAcEaABRBwFHkIeDAzU3Ecc2ABDg-gMiVwGr
AQGfDgAuAAJnAABNBRJXNAAQQSQeAhUBEOAWAgIaAgGIDwCiEiBXEQoOQVeAhwHLHRACLQABCwEh
4FcrABJ3XQAA9gMCzAACXQAxZ4CHJAUHMQAh0Fe1AB_HXAAAIhF3KQAANgQNKgAKWQAgd3DHAwAu
ACEMlyoHIofALgARl8QEFIeCBwFbABZnLQAAtwUOLQAAxgECWgELXAARt8YEPYewZ1wAAPcAC1wA
EcfBCQwtAAJcACRXEVoAEIcFHED-DNcRBwUgd7CKBzFnEYdABR13WgADLQAB5wZAhwF3oCQAAlAM
EWd2BhNnWQAmh2AsABMCKgARN2IOABcFA1oAIwFn4wgddy4AAP0AAvUCF4dcAEZnAYcRWgARDVAC
IneQ6AUMWgARZ0kDM3dwVw4BGg4uAA9aAAAA4gAGLgAAcwYxd5BXzQIAPwMmdwEKDwJcADOHYFeK
ABEOtgAUZy4AA1wAEXcSBxF3yhoA5AAPLgAEA1wABi4ALYcRWgAQgIQBE0c0AxZnLgAQEYoAKKdQ
LgBClwFHkC4AJGcBWgARd9QHEQfIATOXYDfkABoPLgAAAAEGLgACWgABLAAQR8EgMBD3AYsVEICo
Ag9bAAUgp2AxBzgnEccvACJXEVwAAFYCA5QBAYkPAC0AMIcBF-UiERCJAAJcABNXPwEAiwABLQAB
eQyEp3AXAYch9wEsACAngGkCAF0AClkAADQAM6eABw8BAiwAMReQV0gMAuEAEVckABGXMwY1p5CX
KAAip7DvBALaABNXegACggBChwG3gCoAAIoIMZegZyAAAFYAAlIAEId6AAFeAAMqAAAmJQEqADHn
EVf9AQLWAAFeCgJhAAwpABnXUQAv9wJQAAQC4QkphwFSAABsBwxSADOnkNeVAQJfBQBqBQOzHwJW
AAIiAQErACeA11YAJEcRVgAiEQdCADIBx3AtABATgwAhgMfVCgRYAEP3AhEHYQAAMAEKKwAT124A
BVgAIgIR6woCagIix2BVARATDhQNWQAVAywBByoAANIEVpeAtwEH-AAFWQARZ3UDMcdgh5EpghPX
IQcBp3DHSwACVAADNAAShy4BBCkAUPcBEadgfQACKAABTwACHR4FJQAbgDUsVi03NC45-WMFuHQ_
NS45E2QfMUssGQ8BAAAgXBGkK-AJxhcRVyGAR-D-sUchhxFgp-D-qVchtxFA4A5wpFch9wAhELMO
8ACfAfcKkdfw-5sx9wQBF8FsEOA38P_YEUcxtzEnAUdRZ8wKgJUhJzHHIecxdRigNxBX8P_KISdB
F4Ih8QEBYXcRJyFn8P_GMSchJyEnnCqwMachFzFX8P_DQYfUDSAhl4sDEAMmAGCAMZcRV1GJE8D3
BiFX8P9_IacRV0EDBDBXITftHvAAV-D-fBE3IUcRZ0GXATchDCYg9wNMABF5FgDzAzcBFxG3IVcx
VxH3BSFXEfD-dhcAcCcBh0HXQfcpEXDw-3MRNyGX0A_AEfcKAfcEIWcmDGBxETchhyEBDUH3C1GX
1RVQB-D-bxFlALMnIWch9wsxdzFnERgAUG0hJzEn6QUREaIhABgAYofw-2sRNxYAUQG3MTdhUBQA
uAtx8P9pAUcxN18QYEH3CkFHEZ4aUTfw-2cB1wBQBQH3EyFoFxDHFQAQZUUBcAH3ICGHETdUEAAU
ABBkHQiQIecRlzH3BCG3FiMgEdeMLPEAYkcRBxHXMWchlzGHEfcMkClAYAE3Ea4OwJchdxH3ADE3
IfcOERkOQjfw-18IDCARh10QQhGnIRevGhBH0wERXQwQIHchfARx1xH3FBFXERgAEFvUEAFyIjCH
MbeiHCFnEUwAkFoRNxE3EWchZwQBEwCIIiARZxYAMfD-WQkRMPcDgekfQBH3AXGdCgGDABFY0yNg
NxF3MfcCeC4QQTAYQPcBETfPABFYhAAA3wWC9wQhpwEnQbeeIZE38P9WATchFzGqGjDHATc1IBKX
GQAQVYMtECGMADD3BBGcDkBHcfcJ8AkCUwARVTgAIBch5iUAFgEQVwwWAD8AETfTEUAn8P9UQAAA
BBEBeSEAuxdhhwFHUfcAuy4BswIBJgAyNzEX1QBgAgEXEUcR5QFSR0H3BgEmABAXdQFh8P9TN0EX
WAAgZ1HbCgA7FUFnAUcx-SZhJwEnIXcBJQABJQIASwkA1CQC6A4A1gYy5zGHNhsgEQcmABER3Q4R
AEYWAEEJAMYQEGEiACBXIcYCYlMnEfcRAR0AolcBRzGn8QB3AUcbAABrJUAXEfcS-AKwEccRF1EH
MQcRZxG5FQAeAHEBlxEXMfcQngTAtxEnYScRByFXEUch3S9xU3cRJxEXMZQDAI8SQIdBN3HYDmFX
EXfw-1TtCPACEYcRZ0H3ABEnEXchd4HnAUe7AxBVZwMAnQYgZ0HuEVAhdxGXcSsjALMDEFWxAgDO
ACBnUTcA4SF3EWex9wYRZ-D-UwE3vAFQZxFnUeckMADeBlCB9wcRVxwAIUcRRTCQUSdBVyFHEYch
TAVAB3H3CB4AElIJCADkFEBBVzHHZgURATQZMIcR1xQUEFF8CyAxJ6kBUUFngWcRvgsAswUgB1Eu
FgEiAADfLgAGA5JnUXdBB3E3EdchAEABB0GnfCMh-1BjCnSnIQcRZ1GHHAAAgw0zIachDAAgUaec
LUDch-Ba1gJAh1F3cUcHBwIAJGGHKwBAAQdBty0AcFyH8GW38Fj5AEBnUXdhtygBBQ4yUXchcw3w
BQdRZxE3YdfwWrfwY9fwVzdBpzGHCxpxQecBB1E3QccG8ABBdxH3CPBZ1-Bh9wDwVjdsC0Mxl2EH
_RQQwZUG8AEHMYch9wbwWPcA8F-3AvBUXwwxEfcGNQ4BqBZBBwEHgXoA0CH3E-BW9wLwXvcD8FMn
ADIh9wQnAABDKgYCACDHMRwegPBV9wPwSzfQyQYQUucNAi4AEBcLBRInKAABny7wAvcBEScxN-BT
9wQB0DfwN2ew-QAQUeIAAjEAQzcB9yQpAPcAQRchF-BS9wQRsGfwNYegKQAhAlG2AAApAABnIAEl
AGGgh-Azp5AlABIHXwQQB-YVEiURDQC6AQAmAGSQp-Axx4AmAADIHDARF3HUCTD3JTHTHeCHIWfw
UvcDIYDH8C-ncAwFMADwUJ4XQicRRzFdD4C3AfcmMRchdwIvQGFH8FKeMsIRcOfwLvcAYBEnEecw
ADYXETfjAQD_APAQEfcnIScxZwFXQUfwUucRFyFg9wDwLvcBUCEnAefwUPoAgAcR9xIR9yfx9hog
8FJmHYFQ9wHwLvcCQKAecIcxF-BQZxG6KiApwakAIFEXHASQIUD3AvAu9wMgoADwBhFHMRcRB-BQ
ZwH3FQH3JRGHERchdysA8wIHERcxRxE3ISD3A-AtEfcCIJ4AABsMIfBP4ACxERcB9wkh9yQR5xHt
CSHwUZkPwCcxIPcCEfAsEfcDENgyAeYEMfBPF-UDIBcRDxlBEfciESMeUBcRZ-BRBRgQEQ4yshD3
AxHwLCH3AwAhaxAAegwx8E8HkgxQJyFnEdfNARAgdRsgJwE5AAD4DAHsAlERAPcDITsAAVcrESe_
IhBP1wkQNyoEhAG3IUcR9x4ROQAhhwFxABQxNQARMW8AECFLI0EBZ-A3QQZQJzF3EZdECBAdhxsA
0RhROmfwAYdsAikHIW8AEUfYHUABh-A2CA8wQYcBbggGOABTOYfwAXfUH8IHMfcCMfAsMRcR1zF3
NVB34LfwNAYFIVGHIBpRpwH3HBE6AHFH8Dm34HchYADFIdcRJyHwGWewIQcBPADCEXfAEdfwMgEn
EYdRjhwQHLcYAY8uUPA31xHArwsBdgAAPwCgMbBn8AWHoDE3AYUKAKUK8AB3sCHn8DARFxGHUZcB
9zH8BgLxBkA35yGw9gtRBwFHMddAAHCgh-ADp5AhKgMixzH0ADB3oCGXLhEvvQZxR1GHIfctMc0m
dofwNvcCEaB9ALDHETcxkKfwAcdwQREAFMd-AABQAED3APAvYAUgN2EwACD3LKQBAkMANAExkIQA
sMcRJ1Fwx-AA12BRFwJDV1EXIYQAEJA1AEMC8C4XQwBSFxH3KhGZB4IBN-A19wMhkIgA8ABHERdR
VwFHQWDX8AD3AECJAAByAxGBiQARgCMAofcC8CwXERchR2E8CRAqGy_TdxEn8DT3BSGAiwAgcQdq
BkBRQPcABW8RMDsENCcRVxMBEnBJAHAD8CwHUVdx-x4g90YAFWDwNfcGIXCKAABXClInIUdBMPZu
ESAiBWAnERcBdzHeDDBnYDGsALLH8CsHIYeBtwH3Rz8AcschZyFgZxEtNnF3ARchR1EgCW8hAxDc
BCAHASkCAM0AMGdgIQcAkNfwKgcxd5H3VUMQMfA116AAUQcRYGcBJwAgIXcDFbJBEPcD8AEB9wIA
QVoAAGcGQWcBZ1AHANHH8CoBB0FXofcBIfdBUgOBNccRZzFQZxFLCACpALFRAPcCAfACAfcCYRYJ
ExGEAHBQMWcRN0E3QQBgUSfB9wJBnQIQKKkCQPA0N0GkEjNnIVCLADERhyGcABRRSwAQURcAMkcR
l4wAIUAxHgDwAAEXISchB-ArAQfxBfcFQY0nECh3DSDwNEoHAJUJMmchQJoAIZcBQQARYVAAERFQ
AAIVADJ3EUfaAAB3LgNMAADWFiBnUacdoAmh9wQBNxGX8DMwAAEjADMRUEfSABKXpAAQQdoEQgMB
9wIwAQFQFBEXdhMlQCE2AAZZACB3UccvlAdBZyH3AhE3AVsAAkQOQRFAATeqADBnAZe4AAEAAUAE
AfcDnAcwIYchpQkkQCFoAAAEH7DwLBEH8QOXAddh11oCQQAhtxH1CjCH8DTyCEERhzFA2SMAPgEj
hxE6AJMx9wMB8AQR9wKkAiIHIT4ZMTBBB30QcIfwLhEH8QIrGDCHcccHLxAhRi4RIVcAE4ehADAH
MTDKAwO9DwEUAACDAXHwBREHEecxIgAgEYfHADQRIEFnAGB38C8hB-FDEUABp3GXhQkArwYAnABQ
d-A1dzFbCBMgNzkjRwFpAHFB5xEXAfAGDQAi50FYAEJ3AachVgAAMQIxh-AxrgBAJxGngZARQKcR
9xNMC2IhZ-A0hxGyCDEgIReqACF3ITQAIDHnmjpxBhEXEedBh88PJacRUQBQEYfwMRemADAn8QeG
DEB3IfcTcQsiEVf_ABKnpwASAacAEWevACBnMfwcAacAAJIPAa4iEQdxFAJXABGHEAbwAzEXAQfx
AYdRp7EnEZcRRyH3FRICUhFH8DV3qAAhUSAVFAIEEgD0AQFnHBDwyB-BBxG3UZcBBzFHEacADwMC
rADQd-AwAQfxBJcR9wDRt1gHMcH3CH4pMzV3AXkAMWEANxsGI0chNQAhUbdxAgCrAQHUBhInXDAA
3RAjEGE1ADABZ-AeAiDxBCAMgYF3AXdB9wRRDgNTd-A2ZxEmADFREBcFAQJbAJCHIScRdzE3IfAx
DTFHQTfmKAKeGBSnWABAEVfwMT4A8AHxA2cRR5EnARdBBxEXQfcXGRAAXAAzN1cBKgAAlAoAShgU
IRAAQEcBN1GxBCLwBAAEMSEXERoaAAIAYhEXAbdRB50BQQFX8DChAFIH8QJXEa8DAS8AIDEHhQcg
BjGJDpMHESchV-A4VxFeACFhJ3gBERcaAQAlHQCZCAKEASLwBOoDQQEHQWdgABEHugcC9QZSxxFH
8DC0AiDxAp8JA2QBAm4AgUHXQQdBR3FnKApTR-A6RwGkABBByBECawAylwFnNQARMdkAAQMFISFX
OgFEJyHXMdUA00fwLxEHQQfxAwchF1G1ABIxQgBR9wQBd0HYA1AGEScxJ2cAEhc2AEEh1yE3CgAz
VyEXmAABzgBTpwEHMTc8ARMn4QzSAccAATfwMCEHIQfxA4gMFWcZGlP3BQFHQUkBALoFgTdBB-A7
NwEAlQsBzh4CNgEEsgoSh80AFKf-AQBDAIEJAccQASfwMccAMQK3QU0AIDFXOwkSArcaAZ0CIfcD
GQFyFxHwPCcBEGEAAigBBF0ABMkAFEFhAALBAnL3FhABF-AywQBBx0FnId0BABAFIkdBWwAxZyGn
5wJV8D0XARBZAAAGBgKdPANbAEUx8ARRWwAArQthFiABB-AzuABRAfcAUbcZAgH5MAD_AxCHwg_x
IecBZ-A_BwEg9xecAQlRABFBrAARxzUAALgyYfcWQAHwM6kANQH3ESoAIOcB_AYBFwFBETch15oc
YGfwPgFA9-ocBJsCAVIAdVHwBCEXIaeNAkD3IvA5oABS4fcQMQcWACEhxzAHEScMABFXQjMATwAw
RPcYOwIITQAgERcWAgDjKQMQAjEi8DmdAHMAJxH3CSEHohxhBxG3EcdR_QAQBroMYxFX8ET3IvsB
AEUBAPoDMiFXAUcAYRcB9yHwOjQBEAAyAAHjBwECABAhwD8Qd-gmAVsJY-BF9yEBR5oVEFdDAADl
EHAHAfcl8DsRPQAQMZQANKehZ4UAIAGXZBCRJxEnITfwRfcmOgBzJ1F3EfAEEY8VQvck8Du1ABCB
tgOgFyH3DkEHIfcKMUoOASMDIUX31gIQAW8AAIkIMCTwPKsAcHEnQQcRJ5FHDpAR9wBBd6GHIZcQ
DSDwRgYOALIhAmUAoDnwPCEHQQdhNzEIAUD3AUFXYADwAQQh9wBxNxGHEUchJ-BG9yb1QAFvA0L3
N-A_kABAcTdRF6cHIadBRgEx9wYRdjWSESfwR-c6EfADLQCgPxEH0SdBx4HXIZsHEMeCExFnJQBQ
SPc4MfC3B-EB9zXwQCEHwTchd2H3BUEHEdERMbchxyoRUAfwSvc2IgMQAk8AIDbwMAkBAgAQYTIN
MPcMIZoHcfcBIWcxB0EmMzNK9zdXADI08ELNBIFxJyFXEfcOIaMYQQdBVxHIC1UH8Ev3NVoAMjXw
Qy0AEGFEQkD3D1F3LQ_TJxFX8Ev3NAEHUwDxABsB9wfwRREHwScR9xYBB78HIPclExMg8E0uMhUc
UAAQHCoAgUYRB7EnEfcYMRkh9yS0AgEoABQbUgCRVzH3EQGnEYfwNQJlsRch9xkRKwAgTocvDTQR
MWdWAEAHUfcV8xkg8EguAFKhFyH3EtIEgCwhFwFX8E_nDAEQFX4EQDHwAUFfIgFMMYDH8EnRFyH3
EFoAQgMR9xctABHHHjsCygNAMfAAMcwCASMxQcfwShFdABAOtB2SCBH3FiGH8FDH6joQxwIEAlAL
EpcnMRDXLwAQsdoQAF0fQAkB9xdhDxDXbhAzDQHHXAAGLwCi5-BL0RcR9wshh1wAUkFH8FHnLQBR
pwEHQeAQBkBnEfcO0xBwAPBM0fcNMek7AMkTAR8rIfBR8BOA9w4Rl2HQYYf6LxA34T6wTUEAYfcN
MZcB9wfsAAQsACECER0wUHcBB1HQKwsAVTAA3zQj8FMuAEAIIfcPYwkBLgASBHYwYFcBB2HAcWkI
IPcRJARhBfBUYfcLuyoAFBATDToVEVIqKCD3EX8UUGGwYQdRjRCABzA38Exh9wvLDhEhwQhhByH3
CxEnShUwSzcwAAIxFNGw6AAQ9wYscTBn8Elh9wvBCED3BjE3yAIAEBgwSWcwAzQSGFwAIQEHxBCw
CiB38Ehh9woxR0E6O1EhNzH3Cf8HMEl3IKoXAZYCE1FeABAEDweB9wogAXfwSFEzMBAHkRUQC18H
kQcRN0EX8Ep3ATcAEAEWB0AHYaBxLAYBwDdw9wwQAYfwRwcWAw8LAE4GAfknkiAB8EuHARD3DO03
U7cBB2GQFAkBrCpxDRARh-BGcU4qIach1BkQB5oEYFfwT4cREA0YAYgiRQdxgIE0AHEPEAGX8EZh
xQYA_DwAmwelBAFX8E6XARD3DzIAInBx6AXglwHnEfcPIAGX8EVx9wXCARCnngAAMgBwTZcBIPcP
ETIAYncBB4FgkTAAANMAgREQAafwRIH3_AQQAIwPAEoFgfBNpwEQ9xEBiCMBswkygVCBvAYBNiQw
9xIQYEYgQ4E9A0EEcfcDuSVAt-BMAZwAEhKfOAESBjGRQKFODQFQAVATEAGHETYAEQKLARFBcikA
OgdAt-BLET8BIRMBaiERJxcAYQeRMLEHASYeUQER9xUAlyVxQpH3ACH3B8kqYCGnEafwSzABMAD3
FV8SAy4KUAEHoSCxZA9A9w0B9xU5UBfwQZFnwxMQIeUJQBG38EpaHgBqAhANQwRhwQDxAvcPpgNQ
ASfwQFHUDUF3Afcj4wwwx-BJXRcALQAxD-EP2wIw9xYRqRxAN-BAQRwoEXeRFGABZyHH8EhaIBAH
IQBB9xPxC_EDEgWBAhAXbhgx8EBRNilAEfclIRQBgSfwSTchFyEXiwBRBQHH8QozABAGtgCANzF3
8D5RJyFMEyH3KCUlYSfwR3cxNwsJACUAEKfACwPxAABUAAB7RAAgBDA9UTedFjAR9y6xF0HwR-cA
vgAiBxEzDEQH0QcBAgBAZwH3MVAAUQHwPUFXxxgQ98cDAGsAMEb3ARMCEjD-AQORASYHAQIAAGYa
IPcOMAUgByF2ACJBl3sVUQQhV0HHIg8glxFHAAI8PgBSAxEOfBcUBwIAAbgCBgIAEZdOAFANAQcx
100AkCEnIechR2EnQU4fETeSRxJHxxIAZQMCuDwPRwABAqg7AfhGEwBIAEL3FSFXRQBhATfwR-ch
IgAD1hcjAQcMCgC0AeMh8D1RhyEnIWdh9wlBFzMAAJcHQSER9yVXDgFPAnD3GPA_QYchcw0g9xGV
DSER1yYAEBhVAhAmHQU2KCFnJgCxNxG3QSdxBxF3IWdYOjBJ9xhRAgFyCBAqGxdhGfA_UYcRABqB
IQchJ0FnMWcKH2D3AvBJ9xkJGiQQAfsIECmkFQALRyI_UYk3UAcRBzEH4xMQYcQUYPcB8Er3E44M
AEYHAH0CICtBQh1Q9xDwQFHQJAKJCyAHIaAcAIANAmALAA4XQPBL9xBsHTJB9w-qF9H3KmEXQQdx
9wnwQVFXaQYRJ9MEADcSAT0AEhE9AABKNJHwTPcJcQdBF2F6AaAHAfdC8Q9n8EtRaRwAZhgjB1F1
ACIRF7MNITEnSg9U8FZn8Q80AGFD8HFRRxEKGxBhYgogNzE2AwL6EwCKGgDtCyPwfMJIYfc-8HdR
Ny4AISeBiQBAMRchB9wWBOMmAC4AMYL3BS4AoAcB9z0R8HhRNyGyABE3zAQRFz4DEVEdADEC8IOr
PQQCAKD3KzGHUfB5QScxAEojJ4FuChGBDgkBLwAyUYcxKwAQB58DACAOUQPweVEHyRshF3EZABLB
ijMgB1HPG0WH8ITxmSch9yoHACIX4TMAAIIBAYgABQIAEiFlGREHwzUAJR5EhOEHAQIAIPcsBwBR
8QDwe6FHHALTAQwCAAOsAQBqAQCGORiGQQACfwBQB9HwfLGmFwMVAgwCAAQWABBBByxKh-CH4YEA
leHwfaEXEScBNwkBB78ABTwAAr8AKofRPABgAQfB8H6hthcBNRkM_wAIAgABwAA7l-CIQgAT0UAA
AIoVAU8QIwGncABsRxGH8InBcABxsfCAoRcRFycRMacxt5YBU0cBl-CKKgAi9y6WABKAlgBQIdch
x1HjEEKH8IuxIgAGTAAzofCBJgAAdw0g10FAGEiH8IyxSgBAsfCCkRwDQVchxyEiAFgBl-CMoSIA
YAEHkfCDoQgDMFch10YAEBFyFRKO9wEHJgBRgfCEkSfyEkDXEadxlS1Md-CPkSQAEYVuAFFHUacB
t5FMAPk7E5AcBSP3MCsFMfCGgQM7YSEnAacRlykgAMcZEZF0ACL3MkoAIIdhZAAAwx4wtwGHMEoR
ESQAFpFKAEGB8IhhTykCOTgBmzdEp-CTcUYAYZHwiUFXEdcCAIsbAPQGRpfwlIFBAEJx8IsxNhFA
F1HXMcIUAGECJpaBYQAxi0FXsApgJxEXIZdBPTZCd-CXkSAAQIHwjTHTFQBNBCA3sWUAQufwmXEc
ADGR8I7TNSJHMeI2AI8NI-CZWQBRcfCOQVewJgBFBSE3AUwHQwHwm4EdACFhR5whAuMXAN0AUvcC
8JxhZgFAcfCOcfMtAfgBAKkTUAHH8J1hOQDwAWHwjZGHAadBdzF3IafwnXEuAOJh8I6hdwHnkacx
l-CeUToCQWHwjsFoGEUQIYcBFgBBQfCO4YQDMBH3D6QXABoAABgAEFEYAAKbBREPlAAAtUxBnGH3
KhsAALwPQidR9w4FEQIcADBB9ywaAAGcGQDfBkQhVzFHHgAQER8AESpuACDxAr8YQOcRBzFWARMH
AgBwFwHwm0H3KyAAEATKHGJHARfhNyH5EwQgAJAx9ypR8I3xBTd1AyLxBbhOAn0WMPCaQQYFMzHw
jZkCowdRJxFXURfxASftFAFrE3OZMfcpQfCMlwIEHQWCdyGHQRchlyESAFKHIfCYMU0AFIzEBAUM
BBAX6xkklzHrB38HIfCXMfcnLAACANsSEhH9CwIdBAIsAEEx8IyBhBEGJgAARgwCDQBQx0HwlyHD
B1Uh8ItxtyIAIfcVUBEQ50ABEZa6B1Ih8IuBxx4AM0H3FOEAQudh8JYBCETwioHnHgAhEhEJAGEB
9wBx8JVICEQR8IqRgAgzUfcM_AAAiwLCgfCVAfcmIfCIkfcDFQAUYaIRACAAQQOR8JPVHmIR8Iax
9wIXAFWB9wYhFyIAAMMEII8RvApCIfCD0WELNbH3AV4GABAHseHwjBH3JCHwfPEFEDZXB8FHURc-
AQAkAHDxA-CIEfciawAhb-FuCzMBB-HKAAEkANIH8QrwghH3IyHwbfETaRMHYgYMAgDh9wnxEPB7
EfciIfBr8RUKRwBuIA8vAAeQAQfxFfB2EfcgggAyZvEXFAAPNQAL8gMLAQfxG-BvEfchIfBb8QkX
8Qg0AARLBw84AAVxDQEH8R7wa20AhAHwWvEJJ-EIcAAERgcPPAAF9gEPAQfxH-BqAfchEfBY8Qk3
OgAGQAcPOgADgBEBB-Ej8GcBdgBw8FfxCkfxCcIADgEHDDkA_AETARfxJfBk9x8BB-BV8Q1HcwAP
OgALAKAY1ynwYfcfAfBT8RA38QerIQN0DQwzAJAZAQfxLfBe9x4zABgSMwACdQcFKQAYHWQBQPEc
8F36ETDwUvGLFyHxCDQAJfc1UAHxAIcBB-EY8Fz3HfBR8QInwcAJNbEHgckAI-cztQH1A6fxG-Bb
9xsB8E-hBwFH4YdBB9IBJvcJKQDwAOfxHPBZ9xoBB-BO4QcBZ8kiJEEnKAAF7AwTKSwAMB-wV1MA
EE0nAEThtzFHJwBDhyH3I_IHhPcB8SDwVfcaJgAj5yEmABAPyxITIYsCMucBBycAMfBL0dUAIcEH
DjMSgRtTMTH3IRYDofcB8SPwU-cZ8EsjCEKn4fcJIgCBDFH3HQEH0Re7A4PxJPBS9xjwSiQAArkA
AigANgtBB6UEJAfh6wNj8STwUfcXMgAZxzIAIwpRIQED2AES8UlSkgXxJvBR9xbwSTMAArEAEQmQ
PgA_ABRB-wMGhgIS8QcABBcEVibwUPcVPwAY4T8AIQZRggAQF8cOAgIAAJAAsfEJB-EM8FD3FPBI
NgAV5zYAEsHIABJh4wAx8QknFgACMAA2T-cTMAAEKwASCwcAEgJpCAGHAiDxBQgAAGwPAA0AcQjw
T-cS8Ec4AAo6ABLhoQUABgAFLAQSAwgAEsEkAAEsAIqB8E33EvBG0T8AAigAReEHAde6BgN_AAE9
BAH_ACUHoWwBE2FtCVFL9xLwRUsAJ-cBTAAC-QA2AQfhTgAFEwAXB1EAKgEHqQYTAVcAb0r3EfBG
4VcAAQGUACHRtwICJQcB_QAAUwADGAIPVwAKNRDwRVsCD1cADBUJrAAETQASoY0AMHHwSUgAJPEA
RwAHSQABSwA0F8GnIwgDSQASwUcFJYGHRQBSYfBJ9w9FAAZHAAQVAQI4ADoPsZcRAAIiACH3EX8B
CUsAHOc2LR8yNi0CVjExLjA1gomQLHpvb209MX19
:: label.qoi
b64$cW9pZgAAAeAAAAEOBAH_--Ho-f39-f39-f3T-rkAPvI-wf6iiHnMP-39-f39-cUSxD-X-rkA
Ps8-wBLOP8ASzz-_ooh5zj-9-f396xLBP8ASwT-GEsY-yRI-Ej-tEsU-xhLFP8f_uQA_zj8SwD8S
zj8Szz-_ooh5zj-9-f396xLBP8ASwT-GEsY-yhI-yRLBP8ASwT-G-rkAPsY-z-6iiHk-Ej-W-rkA
Ps4-Ej-AEsM-wRLBP8ASwT8Szz-_ooh5zj-9-f396xLBP8ASwT-GEsY-xhLHP8USwD-CEsA-xv65
AD7CP8ESP8v_ooh5wT8SwT-GEsU-x-65AD7OP8ASPxLDPxLAPxLCPxLAPxLPP-6iiHnGPxLFP-39
-f3rEsY-xhLGP8YSwD-DEsA-xRLAP8ISwD-G-rkAPsI-wRI-y-6iiHk-Ej-a-rkAPs4-EsA-EsM-
EsA-EsA-wRLAPxLPP-6iiHnFP8ESxD-9-f396xI-EsI-Ej-WEsA-wxLAP8USwD-CEsA-xv65AD4-
wRLCP8v_ooh5xT-GEsU-x-65AD7OPxLAPxLDP8ESwD8SwD8SwD8Szz-_ooh5xj8SxT-9-f396xI-
EsI-Ej-GEsY-xhLAP8MSwD-FEsA-whLAP8b_uQA_P8ESwj-M-qKIecQ-1v65AD7PP8ASwT8SwD8S
wz-BEsA-wBLOP-6iiHnOP-39-f3rEsY-xhLAP8ISwD-GEsc-xRLBP8ASwT-G-rkAPsY-6hLXPxLa
P-6iiHnOP-39-f39-eP_uQA_9D-_ooh5zj-9-f39-f3_AAAA-f39-f39-f39-f39-f39-f39-f39
-f39-f39-f39-f39-f394z81PzU-NT81PzU-NcU-NT81PzU-NT81PzXQP9U1wz-WNf39-f39-cY-
Nco-NcI-Nco-Nc0-1zXBPzXWPzXuP-39-cY1-f3ZPzXPPzXMP9c1wT811j817j81yv4dK1PK-n4l
U8r_AIdRyv6rUjbK-l9XT8r_wsPHyj-K-v8ATcr_-6MAyv7-7CfK-gDkNsr_Ka3-yv6DdpzK-v93
qMr_-8yqyj81-f3KPzXPPzXaP9k1PzXYPzXtPzXKKMotyg-K-qtSNsouyjvKP8oNyiHKH8ojyv4p
rf-KEModyhTKPzX9-dE-NT81PzXBPzXEPzU-NT81xD81yz-DNcA-NT81PzXBPzXBP8A1wD-CNT81
wj-BNT-BNT-BNT-ANcE-wDXBPzXjP8I1xD81yijKLcoPyv6rUjbKLso7yj-KDcohyh-KI8r_Ka3-
yhDKHcoUyj81-f3KPzXDPzU-NcE-NcM-NcA-NcE-NT810D-DNT-BNT81PzU-NT81P8E1P8U1wz81
PzU-NT81P8E1PzU-NT81xD814T-ENcM-Ncooyi3KD8r_q1I2yi7KO8o-yg3KIcofyiPK-imt-8oQ
yh3KFMo-Nf39zz81PzXFPzXIPzU-NcI-Nco-wzU-wTU-NT81wD-ANcA-wDXBP8M1wz-ANcA-wTU-
NT81P8A1wD-BNcI-NeA-xjXCPzXKKMotyg-K-qtSNsouyjvKP8oNyiHKH8ojyv4prf-KEModyhTK
PzX9-co-NcM-Nck-NcY-Nc8-xDU-wTU-NT81PzU-NT-DNT-ENcI-NT81PzU-NT81PzU-NcM-NcM-
Nd4-wDU-wDU-NT-ANcE-Ncooyi3KD8r_q1I2yi7KO8o-yg3KIcofyiPK-imt-8oQyh3KFMo-Nf39
zT81PzU-NT81wz81xj81PzU-NT81wD81yT-FNcA-wDXAPzXBPzXBPzXAP8U1wj81PzU-NT81PzU-
NT81wT-ANcQ-Nd4-NcA-wjXAPzXBPzXKKMotyg-K-qtSNsouyjvKP8oNyiHKH8ojyv4prf-KEMod
yhTKPzX9-co-NcE-NT81PzXHPzXEPzU-NT81zD-fNdo-Nd4-NcA-wDXAPzXCPzXKKMotyg-K-qtS
NsouyjvKP8oNyiHKH8ojyv4prf-KEModyhTKPzX9-c8-NT81xT81yD81PzXCPzXIP9812j813z81
wj81wz81yijKLcoPyv6rUjbKLso7yj-KDcohyh-KI8r_Ka3-yhDKHcoUyj81-f3KPzXDPzXJPzXG
PzXNP-3UNcs-wjXEPzXKKMotyg-K-qtSNsouyjvKP8oNyiHKH8ojyv4prf-KEModyhTKPzX9-dk-
Nc8-Nf30PzXKKMotyg-K-qtSNsouyjvKP8oNyiHKH8ojyv4prf-KEModyhTKPzX9-co-Nc8-Nf39
xT81yijKLcoPyv6rUjbKLso7yj-KDcohyh-KI8r_Ka3-yhDKHcoUyj81-f3LPzXKPzXCPzXKPzX9
9T-_JGOwyv4ApaHK-mVGiMr_ElNZyv50LynK-kUtMsoSyv7-rMXK-rkAPsr_4msCyv6V8ELK-gCy
Ucr_ZN-2yv69mt-K-uQNq8r_-4VXyj81-f3NPzU-NT81PzU-NT81xT81PzU-NT81PzU-Nf32PyDK
Fco6yjnKG8oDyv6iiHnKMcr_uQA_ygDKMsomyjbKB8oPyizKPzX9-f3BFMw1zCzMNcz_q1I2zDXP
P8I1xD8gyhXKOso5yhvKA8r_ooh5yjHK-rkAPsoAyjLKJso2ygfKD8osyj81-f39wBTMCjXLLMwb
NcsKzAM1zj-ENcM-IMoVyjrKOcobygPK-qKIecoxyv65AD7KAMoyyibKNsoHyg-KLMo-Nd8-NT81
wz81xz81PzU-Nc0-NT81-cA-yjXEP8o10RTMCsA1yizMG8A1ygrMA8A1zT-GNcI-IMoVyjrKOcob
ygPK-qKIecoxyv65AD7KAMoyyibKNsoHyg-KLMo-Nf39yz81yj81wj81yj81zxTMCsE1ySzMG8E1
yQrMA8E1zD-ANT-ANT81P8A1wT8gyhXKOso5yhvKA8r_ooh5yjHK-rkAPsoAyjLKJso2ygfKD8os
yj813T81wz81wT81xz81wz81zT81-D81zD81wD81zD81zRTMCsI1yCzMG8I1yArMA8I1zD81wD-C
NcA-NcE-IMoVyjrKOcobygPK-qKIecoxyv65AD7KAMoyyibKNsoHyg-KLMo-Nf39yj81xD-ANcQ-
NcA-NcI-xDXCPzXMFMwKwzXHLMwbwzXHCswDwzXNPzXAP8A1wD81wj8gyhXKOso5yhvKA8r_ooh5
yjHK-rkAPsoAyjLKJso2ygfKD8osyj813T81wz81wT81wz81wT81wz81wz81PzXFPzX8PzXBP8A1
P8A1P8A1wT81wD81wT-BNcA-wTXBPzXLLMwKxDXGCswbxDXGG8wDxDXOPzXCPzXDPyDKFco6yjnK
G8oDyv6iiHnKMcr_uQA_ygDKMsomyjbKB8oPyizKPzX9-co-NcE-xjXBPzXAPzXBP8A1wj-ANcE-
NcsszArENcYKzBvENcYbzAPENc8-wjXEPyDKFco6yjnKG8oDyv6iiHnKMcr_uQA_ygDKMsomyjbK
B8oPyizKPzXdPzXDPzXBPzXBPzXDPzU-NT81yT81wz81-D81wj-ENcI-NcA-Ncc-wDXBPzXLLMwK
xDXGCswbxDXGG8wDxDXZPyDKFco6yjnKG8oDyv6iiHnKMcr_uQA_ygDKMsomyjbKB8oPyizKPzX9
-co-NcA-wjXAP8I1wD81wD81xj-ANcI-NcsszArENcYKzBvENcYbzAPENdk-IMoVyjrKOcobygPK
-qKIecoxyv65AD7KAMoyyibKNsoHyg-KLMo-Nd0-NcM-NcE-NT81xT81yT81PzU-NcM-Ncc-wDXE
P8E1wz-BNeA-NcA-wjXAP8I1wD81wD81xT-ANcM-NcsszArENcYKzBvENcYbzAPENdk-Nf39-cQ-
Nf3UPzXGPzXFPzXgPzXCP8Q1wj81wD81xD-ANcQ-NcsszArENcYKzBvENcYbzAPENdk-Nf39-cQ-
Nd0-NcM-NcE-NcE-NcM-Ncc-NcM-NcM-Ncg-NcQ-wTXDP8E14D81wT-GNcE-NcA-NcQ-wDXEPzXL
LMwKxDXGCswbxDXGG8wDxDXPP8I1xD81-f39xD81-dQ-NcQ-NcU-NeI-NcE-wDU-wDU-wDXBPzXA
PzXMPzXLLMwKxDXGCswbxDXGG8wDxDXOP8Q1wz81-f39xD813z81PzXDPzXDPzXBPzXJPzU-NT81
wz81PzXFP8E1wD81wD-BNcA-NcA-wTXgPzXEP8A1xD81wD81xD-ANcQ-NcsszArDNccKzBvDNccb
zAPDNc4-xjXCPzX9-f3EPzX9-co-Ncw-NcA-Ncw-NcsszArCNcgKzBvCNcgbzAPCNc4-wDU-wDU-
NT-ANcE-Nf39-cQ-Nf39yz81yj81wj81yj81zCzMCsE1yQrMG8E1yRvMA8E1zz81wD-CNcA-NcE-
Nf39-cQ-Nf39zD-KNcQ-yjXNLMwKwDXKCswbwDXKG8wDwDXRPzXAP8A1wD81wj81-f39xD81-f35
LMwKNcsKzBs1yxvMAzXTPzXCPzXDPzX9-f3EPzX9-fkszDXMCsw1zBvMNdU-wjXEPzX9-f3EPzX9
-f395D81-f39xD81-f39-eQ-Nf39-cQ-Nf39zD-cNf32PzX9-f3EPzX9-cs-zjXNPzX99T81-f39
xD81-f3KP881zj81-eo-wjXEPzX9-f3EPzX9-co-zzXOPzX96T-ENcM-Nf39-cQ-Nf39yj-BNck-
wTXCP8E1wD-DNcA-Nf3oP8Y1wj81-f39xD81-f3KP8E1yT-BNcE-wzU-wzXAPzX95z-ANT-ANT81
P8A1wT81-f39xD81-f3KP881wT-DNT-DNcA-NdEfzDXMIcw1zA3MNcw-NcA-wjXAPzXBPzX9-f3E
PzX9-co-wTXJP8E1wT-DNT-DNcA-NdAfzAA1yyHMEjXLDcwtNc0-NcA-wDXAPzXCPzX9-f3EPzX9
-co-wTXJP8E1wj-BNcA-wzXAPzXPH8wAwDXKIcwSwDXKDcwtwDXOPzXCPzXDPzX9-f3EPzX9-co-
zzXOPzXOH8wAwTXJIcwSwTXJDcwtwTXPP8I1xD81-f39xD81-f3KP881zj81zR-MAMI1yCHMEsI1
yA3MLcI12T81-f39xD81-f3LP841zT81zR-MAMM1xyHMEsM1xw3MLcM12T81-f39xD81-f3MP9w1
zSHMAMQ1xgDMEsQ1xhLMLcQ12T-9-f3GNf39_SHMAMQ1xgDMEsQ1xhLMLcQ1-f39-f393iHMAMQ1
xgDMEsQ1xhLMLcQ1-f39-f393iHMAMQ1xgDMEsQ1xhLMLcQ1-f39-f393iHMAMQ1xgDMEsQ1xhLM
LcQ1-f39-f393iHMAMQ1xgDMEsQ1xhLMLcQ12T-9-f39-fQ1yyHMAMQ1xgDMEsQ1xhLMLcQ12T81
8j-FNf39-f31PzXLIcwAxDXGAMwSxDXGEswtxDXZPzXxP8c1-f39-fQ-NcshzADDNccAzBLDNccS
zC3DNdo-NfE-xzXnH8M1-f39-cY-NcshzADCNcgAzBLCNcgSzC3CNds-NfE-xzXmH8U1-f39-cU-
NcshzADBNckAzBLBNckSzC3BNdw-NfE-xzXlH8c1-f39-cQ-NcshzADANcoAzBLANcoSzC3ANd0-
NfE-xzXlH8c1-f39-cQ-NcshzAA1ywDMEjXLEswtNd4-NfI-xTXmH8c1-f39-cQ-NcshzDXMAMw1
zBLMNd8-NfMUwzXnH8c1-f39-cQ-Nf30PzXyFMU15h-HNf39-f3EPzX99D818RTHNeYfxTXWMsM1
-f395j81-fQ-NfEUxzXnH8M11jLFNf39-eU-Nf30PzXxFMc1-cUyxzX9yDbDNf391T81-fQ-NfEU
xzX9xTLHNf3HNsU1-f3QMcM1-fQ-NfEUxzX9xTLHNf3GNsc19jvDNf3PMcU1-fM-NfIUxTX9xjLH
Nf3GNsc19TvFNf3NMcc1-fI-NfMUwzX9xzLHNcIjwzX7Nsc19DvHNf3MMcc1zzLMNcwjzDXMJsw1
2T81-cMhwzX4MsU1wiPFNfo2xzX0O8c1-cwxxzXOMswmNcsjzP4Ah1E1yybMOTXZPzX9wiHFNfgy
wzXCI8c1_TbHNfQ7xzX9zDHHNc0yzCbANcojzA-ANcomzDnANdk-Nf3BIcc1-cIjxzX6NsU19TvH
Nf3MMcc1zDLMJsE1ySPMD8E1ySbMOcE12T81-cEhxzX9wiPHNfs2wzX2O8c1-c0xxTXMMswmwjXI
I8wPwjXIJsw5wjXZPzXkLMM11CHHNf3CI8c1-fs7xTX9zzHDNcwyzCbDNccjzA-DNccmzDnDNdk-
NeMsxTXTIcc1-cIjxzX9-DvDNdoHwzXtHcM1yyPMJsQ1xibMD8Q1xg-MOcQ12T814izHNdIhxzX9
wyPFNf393wfFNesdxTXKI8wmxDXGJswPxDXGD8w5xDXZPzXiLMc10yHFNf3FI8M1-d7_Ka3-wzX4
B8c16R3HNckjzCbENcYmzA-ENcYPzDnENdk-NeIsxzXUIcM1-f3qCsU19wfHNekdxzXJI8wmxDXG
JswPxDXGD8w5xDXZPzXiLMc1-f39xgrHNfYHxzXpHcc1ySPMJsQ1xibMD8Q1xg-MOcQ1yD81P8A1
yz814izHNf39-cYKxzX2B8c16R3HNckjzCbENcYmzA-ENcYPzDnENcg-NT81PzXKPzXjLMU1-f39
xwrHNfYHxzXpHcc1ySPMJsQ1xibMD8Q1xg-MOcQ1yT-ANT81yj815CzDNf3pJsM1-dYKxzX3B8U1
6x3FNcojzCbENcYmzA-ENcYPzDnENdk-Ne4AwzX93ibFNeIVwzXqCsc1_AfDNe0dwzXLI8wmwzXH
JswPwzXHD8w5wzXJPzU-wDXLPzXtAMU1-dwmxzXgFcU16grFNf3zPzXLI8wmwjXIJswPwjXID8w5
wjXKPzU-NT81yj81zQ3DNdgAxzX92ybHNd8VxzXqCsM1-fQ-NcsjzCbBNckmzA-BNckPzDnBNcw-
wDU-Nco-NcwNxTXXAMf_ooh5Nf3aJsc13xXHNf395z81yyPMJsA1yibMD8A1yg-MOcA13T81yw3H
NdYAxxI1-domxzXfFcc1-f3T-uQNq8M1zT81yyPMJjXLJsz_AIdRNcsPzDk1zT81wT81yj81yw3H
NdYAxxI1-domxzXfFcc1-f3S-uQNq8U1zD81yyPMNcwmzDXM-gCHUcw1zj81PzU-Nco-NcsNxzXW
AMcSNf3bJsU14BXHNf3mEMM14v7kDavHNcs-Nf3jP8M1yj81yw3HNdcAxRLANf3cJsM14hXFNf3m
EMU14Q-HNcs-Nf30PzXLDcc12ADDEsA1-f3JFcM1-eYQxzXgD8c1yz81-eQ-wjXKPzXMDcU12hLD
Nf39-fcQxzXgD8c1yz81-eM-Nc4-Nc0NwzX9-cn_AIdRwzX9-csQxzXg-uQNq8c1yz81-eM-wzXK
PzXi-qtSNsM1-fH_AIdRxTX9-coQxzXh-uQNq8U1zD81-fQ-NeEKxTX97-4Ah1HHNf39yRDHNeL_
5A2rwzXNPzX94z81zj814ArHNf3u-gCHUcc1-f3KEMU19z81-eM-wzXKPzXgCsc1-e4PxzX9-csQ
wzX4PzXRNsw1zDbMNcz_Ka3-zDXIPzXOPzXK-rkAPsM1z-6rUjbHNf3uD8c1-dwgwzX95z810DbM
OTXLNswgNcv_Ka3-zCg12T81yRLFNc7_q1I2xzX97g-HNf3bIMU1-eY-Nc82zDnANco2zCDANcr_
Ka3-zCjANcg-wzXKPzXIEsc1zf6rUjbHNf3vD8U1-dsgxzX95T81zjbMOcE1yTbMIME1yf4prf-M
KME1yj81zD81yBLHNc7_q1I2xTX98Q-DNf3cIMc1-eU-Nc02zDnCNcg2zCDCNcj_Ka3-zCjCNcg-
wzXKPzXIEsc1z-6rUjbDNdYuwzX9-fggxzXnOsM19T81zDbMOcM1xzbMIMM1x-4prf-MKMM12T81
yBLHNesuxTX9-fcgxzXmOsU19D81yxXMOcQ1xgrMIMQ1xiDMKMQ1yD81wD-ANco-NcgSxzXqLsc1
-f32IMc15TrHNfM-NcsVzDnENcYKzCDENcYgzCjENcg-NcE-Nco-NckSxTXrLsc1-f33IMU15jrH
NfM-NcsVzDnENcYKzCDENcYgzCjENck-wjXKPzXKEsM17C7HNf39_CDDNec6xzXoLcM1xD81yxXM
OcQ1xgrMIMQ1xiDMKMQ12T81-S7HNf39xDnDNf3dOsc15y3FNcM-NcsVzDnENcYKzCDENcYgzCjE
Ncg-NcE-Nco-NdcbwzXfLsc1-f3DOcU1-dw6xzXmLcc1wj81yxXMOcQ1xgrMIMQ1xiDMKMQ1yD-D
Nco-NdYbxTXfLsU1-f3DOcc1-dw6xTXnLcc1wj81yxXMOcQ1xgrMIMQ1xiDMKMQ1yD81wT81yj81
1RvHNd8uwzX9-cQ5xzX93TrDNegtxzXCPzXLFcw5xDXGCswgxDXGIMwoxDXZPzXVG8c1-f3qOcc1
-f3OLcc1wj81yxXMOcM1xwrMIMM1xyDMKMM1zT81yj811RvHNf396jnHNf39zi3HNcI-NcsVzDnC
NcgKzCDCNcggzCjCNc4-Nco-NdUbxzX9-eo5xzX9-c8txTXDPzXLFcw5wTXJCswgwTXJIMwowTXL
P8M1yj81wQPDNc0bxzX9-es5xTX9-dEtwzXEPzXLFcw5wDXKCswgwDXKIMwowDXdPzXAA8U1zRvF
Nf397TnDNf393T81yxXMOTXLCswgNcsgzCg13j81A8c1zRvDNf39-f391D81yxXMNcwKzDXMIMw1
3z81A8c1-f39-cYowzX92z81-fQ-NQPHNf39-f3FKMU1-do-Nf30PzUDxzX9-f39xCjHNf3ZPzX9
9D81A8c1-f39-cQoxzX92T81-fQ-NcADxTX9-f39xSjHNf3ZPzX99D81wQPDNf39-f3GKMc1-dk-
Nf30PzX9-f39zijHNf3ZPzX99D81-f39-c8oxTX92j81-fQ-Nf39-f3QKMM1-ds-NdE7zDXMB8w1
zBDMNdk-Nf39-f398j810DvMEDXLB8w6NcsQzCg12T81-f39-f3yPzXPO8wQwDXKB8w6wDXKEMwo
wDXZPzX9-f39-fI-Nc47zBDBNckHzDrBNckQzCjBNdk-Nf39-f398j81zTvMEMI1yAfMOsI1yBDM
KMI12T81-f39-f3yPzXMO8wQwzXHB8w6wzXHEMwowzXZPzX9-f39-fI-NcsHzBDENcYQzDrENcY6
zCjENdk-Nf39-f398j81ywfMEMQ1xhDMOsQ1xjrMKMQ12T81-f39-f3yPzXLB8wQxDXGEMw6xDXG
OswoxDXZPzX9-f39-fI-NcsHzBDENcYQzDrENcY6zCjENdk-Nf39-f398j81ywfMEMQ1xhDMOsQ1
xjrMKMQ12T81-f39-f3yPzXLB8wQxDXGEMw6xDXGOswoxDXZPzX9-f39-fI-NcsHzBDENcYQzDrE
NcY6zCjENdk-Nf39-f398j81ywfMEMQ1xhDMOsQ1xjrMKMQ12T-9-f39-fQ1ywfMEMM1xxDMOsM1
xzrMKMM1-f39-f393wfMEMI1yBDMOsI1yDrMKMI13T-ANcA-wDU-wTXLP8E1P8E1P8A1xz-ANT-B
NT-BNT-ANcE-wDU-wTXgPzU-NT-BNT81wT81wj-ANT81PzXKP8A1P8E1P8E1P8E1P8A15D-ANT81
PzU-wTU-wDX1P8E1PzXBPzU-NT-BNck-NT81P8E1wD-ANT81wT-BNT-BNck-wTU-NT81P8E1P8E1
PzXBP8E10D-BNc0HzBDBNckQzDrBNck6zCjBNd0-NT81PzXBPzXNPzU-NT81wT81PzXFPzU-NT81
PzU-NT81PzU-NT81wT814j81PzU-NcE-NcE-NcE-NT81PzU-Nck-NcE-NT81PzXBPzXBPzU-NeI-
NcE-NT81PzU-NT81PzX0PzU-NT81wT81PzU-Ncs-NT81wD81wD81PzU-NcE-NcI-Nco-NT81PzU-
NT81PzU-NT81PzXBPzXSPzU-Nc0HzBDANcoQzDrANco6zCjANd4-NT81P8E1P8A1zD-ANcA-wDXA
PzU-NcU-NT81P8A1wD-BNT81PzU-NcE-wDXBIcM12T-AH8M1PzXBPzXBPzU-NT81PzXJPzXBP8A1
wD-ANcA-wDXAPzU-NeI-NcE-wTU-wTU-NT819D-ANcA-NcE-NT81P8A1yj81PzXAPzXAPzU-NT81
wT-ANcE-Nco-wTU-NT81P8A1wD-BNT81wT-ANdE-wDXOB8wQNcsQzDo1yzrMKDXfPzU-NcE-NT81
wRLDDcE1wj81PzU-NcE-NT81wSzDNT81PzUAwxTDPzU-NT81wSHFNdkfxT81wT81wT81PzU-wTXJ
PzU-NT81PzU-I8M1JsM1wA-DNdo-NRXDNT81PzU-NT815ArDNck-NT81PzXBPzU-NT81yz-BNcA-
NcA-NT81PzXBPzXCPzXKPzXBPzU-NT81PzU-NcE-NcE-NdIxwzXLB8w1zBDMNcw6zDXgP8A1wD-A
NcA-wRLFDcE1wT81PzU-wTU-wTXALMU1wD8AxRTDP8A1P8EhxzXXH8c-wDU-wTU-wDXAP8E1yT-B
NT81PzUjxCbFD8U12hXFPzU-NT81PzXjCsU1yD-BNT-BNcA-wDU-wTXKPzXAP8E1P8A1wD-BNT-B
NcA-Nco-NcI-wDU-NT81PzXBP8E1P8E1wP7kDavDNcgxxTX9-cASxw3BNcwsxzUAxxTDNcMhxzXX
H8c13iPEJsf_AIdRxTXYFcc16ArHNf3d-uQNq8U1xjHHNf3yP8kSxw3BP8wsxz8AxxTDP8Mhxz-X
H8c-3iPEJsf_AIdRxT-YFcc-6ArHP-3c-uQNq8c-xTHHNf3yPzXIEscNwTXMLMc1AMcUwzXDIcc1
1x-HNd4jxCbH-gCHUcU12BXHNegKxzX93P7kDavHNcUxxzX98j81yBLHDcE1zCzHNQDHFMM1wyHH
NdcfxzXeI8Qmx-4Ah1HFNdgVxzXoCsc1-dz_5A2rxzXFMcc1-fI-NcgSxw3BNcwsxzUAxxTDNcQh
xTXZH8U13yPEJsf_AIdRxTXYFcc16ArHNf3c-uQNq8c1xTHHNf3yPzXJEsUNwTXOLMU1wQDFFMM1
xiHDNdsfwzXXMsM1wyPEJsX_AIdRxTXaFcU16grFNf3d-uQNq8c1xjHFNf3zPzXKEsMNwTXQLMM1
wwDDFMM1-cgyxTXDI8M1JsM1wP4Ah1HDNdwVwzXsCsM1-d-_5A2rxTXIMcM1-fQ-Nf39wzLHNf39
-dAPwzXNPzXRP8w1zDHMNcwdzDXZPzX9-cMyxzX9-f3kPzXQP8wdNcsxzBA1yx3MOjXZPzX9-cMy
xzX9yDbDNf391T81zz-MHcA1yjHMEMA1yh3MOsA12T81-f3DMsc1-cc2xTX9-dQ-Nc4-zB3BNckx
zBDBNckdzDrBNdk-Nf39wzLHNf3GNsc1-f3TPzXNP8wdwjXIMcwQwjXIHcw6wjXZPzX9-cQyxTX9
xzbHNf390z81zD-MHcM1xzHMEMM1xx3MOsM12T81-f3FMsM1-cI5wzU2xzX9-dM-NcsxzB3ENcYd
zBDENcYPzDrENdk-Nf39-c05xTbHNeMgwzX95z81yzHMHcQ1xh3MEMQ1xg-MOsQ12T81-f39zDnG
Nsc14iDFNf3mPzXLMcwdxDXGHcwQxDXGD8w6xDXZPzX9-f3MOcc2xTXiIMc1-eU-NcsxzB3ENcYd
zBDENcYPzDrENdk-Nf39-cw5xzU2wzXjIMc1-eU-NcsxzB3ENcYdzBDENcYPzDrENdk-Nf39-cw5
xzXpIMc1-eU-NcsxzB3ENcYdzBDENcYPzDrENdk-Nf39-cw5xzXpIMc1-eU-NcsxzB3ENcYdzBDE
NcYPzDrENdk-Nf39-c05xTXqIMc1-eU-NcsxzB3ENcYdzBDENcYPzDrENdk-Nf39-c45wzXsIMU1
-eY-NcsxzB3DNccdzBDDNccPzDrDNdo-Nf39-f3EIMM1-dwtwzXEPzXLMcwdwjXIHcwQwjXID8w6
wjXbPzX9-f39-eYtxTXDPzXLMcwdwTXJHcwQwTXJD8w6wTXMP8I1yj814v6rUjbDNf39-f36Lcc1
wj81yzHMHcA1yh3MEMA1yg-MOsA1zD81zj814QrFNf39-f35Lcc1wj81yzHMHTXLHcwQNcsPzDo1
zT-DNco-NeAKxzX9-f39_C3HNcI-NcsxzDXMHcw1zA-MNd8-NdcbwzXCCsc1-f39-fgtxzXCPzX9
4z-CNcs-NdYbxTXBCsc1-f39-fgtxzXCPzX94z81wT81yj811RvHNcAKxzX9-f39_S3FNcM-Nf3k
P8I1yj811RvHNcAKxzX9-f39_i3DNcQ-Nf30PzXVG8c1wQrFNf39-f39yD81-eM-NcE-Nco-NdUb
xzXCCsM1-f39-f3JPzX94z-DNco-NdUbxzX9-f3uKMM14QfDNfE-Nf3jPzXBPzXKPzXWG8U1-f39
7ijFNd8HxTXwPzX99D811xvDNf39-e4oxzXdB8c17z810T-MNcw7zDXM-qKIecw1yD81zj81-f39
-c4oxzXdB8c17z810D-MEjXLO8wuNcsSzAM1yD-DNco-Nf39-f3OKMc12zrAB8c17z81zz-MEsA1
yjvMLsA1yhLMA8A1yD81zj81-f39-c4oxzXaOsEHxzXvPzXOP8wSwTXJO8wuwTXJEswDwTXZPzX9
-f39zijHNdk6wgfHNe8-Nc0-zBLCNcg7zC7CNcgSzAPCNcg-wzXKPzX9-f39zyjFNdo6wwfFNfA-
Ncw-zBLDNcc7zC7DNccSzAPDNcg-NT81zD81-f39-dAowzXbOsQHwzXxPzXLO8wSxDXGEswuxDXG
LswDxDXIP8M1yj81-f39-fI6xzXzPzXLO8wSxDXGEswuxDXGLswDxDXZPzX9-f398jrHNfM-Ncs7
zBLENcYSzC7ENcYuzAPENcg-wDU-wDXKPzX9-f398zrFNfQ-Ncs7zBLENcYSzC7ENcYuzAPENcg-
NT81zD81-f39-fQ6wzX1PzXLO8wSxDXGEswuxDXGLswDxDXIP8M1yj81-f39-f3yPzXLO8wSxDXG
EswuxDXGLswDxDXZPzX9-f39-fI-Ncs7zBLENcYSzC7ENcYuzAPENcg-wzXKPzX9-f39-fI-Ncs7
zBLENcYSzC7ENcYuzAPENcw-Nco-Nf39-f398j81yzvMEsM1xxLMLsM1xy7MA8M1yT-CNcs-Nf39
-f398j81yzvMEsI1yBLMLsI1yC7MA8I12z81-f39-f3yPzXLO8wSwTXJEswuwTXJLswDwTXLPzXO
PzX9-f39-fI-Ncs7zBLANcoSzC7ANcouzAPANcw-wzXKPzX9-f39-fI-Ncs7zBI1yxLMLjXLLswD
Nc0-Nc4-Nf39-f398j81yzvMNcwSzDXMLsw13z81-f39-f3yPzX94z-DNco-Nf39-f398j81-eM-
NT81zD81-f39-f3yPzX94z-DNco-NcEDwzX9-f396RDDNfg-Nf30PzXAA8U1-f39-ecQxTX3PzX9
4z81P8A1yz81A8c1-f39-eUQxzX2PzX94z81PzU-Nco-NQPHNf39-f3lEMc19j81-eQ-wDU-Nco-
NQPHNf39-f3lEMc19j81-fQ-NQPHNf39-f3lEMc19j810SjMNcwozDXMKMw12T81A8c15RLDNf39
-fcQxzX2PzXQKM01yyjNNcsozTXZPzXAA8U15RLFNf39-fcQxTX3PzXPKM41yijONcoozjXZPzXB
A8M15RLHNf39-fcQwzX4PzXOKM81ySjPNckozzXZPzXtEsc1-f39-fg-Nc0o0DXIKNA1yCjQNdk-
Ne0SxzX9-f39_D81zCjRNcco0TXHKNE12T817RLHNf39-f34PzXLKNI1xijSNcYo0jXZPzXtEsc1
-f39-fg-Ncso0jXGKNI1xijSNdk-Ne4SxTX9-f39_T81yyjSNcYo0jXGKNI12T817xLDNf39-f36
PzXLKNI1xijSNcYo0jXZPzX9wS7DNf39-f3qPzXLKNI1xijSNcYo0jXZPzX9wC7FNf39-f3pPzXL
KNI1xijSNcYo0jXZPzX9Lsc1-f39-eg-Ncso0jXGKNI1xijSNdk-Nf0uxzX9-f396D81yyjSNcYo
0jXGKNI12T81-S7HNf39-f3oPzXLKNE1xyjRNcco0TXaPzX9Lsc1-f39zTvDNf3UPzXLKNA1yCjQ
Ncgo0DXbPzX9Lsc1-f39zDvFNf3TPzXLKM81ySjPNckozzXcPzX9wC7FNf39-cw7xzX90j81yyjO
NcoozjXKKM413T81-cEuwzX9-f3NO8c1-dI-NcsozTXLKM01yyjNNd4-Nf39-f3VO8c1-dI-Ncso
zDXMKMw1zCjMNd8-Nf39-f3VO8c1-dI-Nf30PzX9-f391TvHNf3SPzX99D81-f39-dY7xTX90z81
-fQ-Nf39-f3XO8M1-dQ-Nf30P-39-f399DX9-f39-f39-f39-f39-f393z-TNf39-f39-f3WPzXT
PzX9-f39-f391D811T812-7-H4rE-v8pesT_-zBqxP7-NVrE-v85R8T_-z0wxP7_QgDE-vFXAMT_
52QAxP7dbQDE-tV0AMT_znoAxP7HfgDE-sGDAMT_uocAxP60igDE-q2OAMT_ppEAxP6flADE-paY
AMT_jZsAxP6BnwDE-nOjAMT_XqcAxP47rQDE-gCvMcT_AK5UxP4ArGjE-gCrdsT_AKqCxP4AqYvE
-gColMT_AKebxP4ApqLE-gClqcSfn8T_AKO2xP4Aor3E-gChxMT_AJ-MxP4AntTE-gCb38T_AJjr
xP4AlPvE-jOQ-8T_TYz-xP5fiP-E-m6D-8T_e3--xP6Hev-E-pN0-8T_n23-xP6sZP-E-rlY-8T_
yEf-xP7ZJf-E-uUA88T_7ADhxP7yAM-E-vgAvsT_-ACswP4AAAD9wD81wT-ANT81wT-BNT-BNT-A
NcE-Ndv_-x_KxP7-KXrECMQxxP7-OUfE-v89MMQ5xDvE-udkAMQtxDjEAcT_x34AxP7BgwDE-rqH
AMQDxALEPMT_n5QAxC-EI8T_gZ8AxD3EEsT_O60AxDfEJ8T_AKxoxP4Aq3bE-gCqgsT_AKmLxP4A
qJTE-gCnm8QhxA3En5-E-gCjtsQKxP4AocTEJMT_AJ7UxP4Am9-E-gCY68T_AJT7xP4zkP-E-k2M
-8T_X4j-xP5ug--E-nt--8QlxCvELMQmxP65WP-E-shH-8T_2SX-xP7lAPPEIMQ0xP74AL7EHcD_
AAAA-cA-NcA-NcE-NcE-NcE-NT81PzU-NcA-Ndv_-x_KxP7-KXrECMQxxP7-OUfE-v89MMQ5xDvE
-udkAMQtxDjEAcT_x34AxP7BgwDE-rqHAMQDxALEPMT_n5QAxC-EI8T_gZ8AxD3EEsT_O60AxDfE
J8T_AKxoxP4Aq3bE-gCqgsT_AKmLxP4AqJTE-gCnm8QhxA3En5-E-gCjtsQKxP4AocTEJMT_AJ7U
xP4Am9-E-gCY68T_AJT7xP4zkP-E-k2M-8T_X4j-xP5ug--E-nt--8QlxCvELMQmxP65WP-E-shH
-8T_2SX-xP7lAPPEIMQ0xP74AL7EHcD_AAAA-cA-NcA-NcE-NcE-wDXAP8E1P8A1wT812-7-H4rE
-v8pesQIxDHE-v85R8T_-z0wxDnEO8T_52QAxC3EOMQBxP7HfgDE-sGDAMT_uocAxAPEAsQ8xP6f
lADEL8QjxP6BnwDEPcQSxP47rQDEN8QnxP4ArGjE-gCrdsT_AKqCxP4AqYvE-gColMT_AKebxCHE
DcSfn8T_AKO2xArE-gChxMQkxP4AntTE-gCb38T_AJjrxP4AlPvE-jOQ-8T_TYz-xP5fiP-E-m6D
-8T_e3--xCXEK8QsxCbE-rlY-8T_yEf-xP7ZJf-E-uUA88QgxDTE-vgAvsQdwP4AAAD9wD81wD81
wT81wT81wT81PzU-NT81wD812-7-H4rE-v8pesQIxDHE-v85R8T_-z0wxDnEO8T_52QAxC3EOMQB
xP7HfgDE-sGDAMT_uocAxAPEAsQ8xP6flADEL8QjxP6BnwDEPcQSxP47rQDEN8QnxP4ArGjE-gCr
dsT_AKqCxP4AqYvE-gColMT_AKebxCHEDcSfn8T_AKO2xArE-gChxMQkxP4AntTE-gCb38T_AJjr
xP4AlPvE-jOQ-8T_TYz-xP5fiP-E-m6D-8T_e3--xCXEK8QsxCbE-rlY-8T_yEf-xP7ZJf-E-uUA
88QgxDTE-vgAvsQdwP4AAAD9wD81wT-ANT-BNT-BNT81PzU-NT81wD812-7-H4rE-v8pesQIxDHE
-v85R8T_-z0wxDnEO8T_52QAxC3EOMQBxP7HfgDE-sGDAMT_uocAxAPEAsQ8xP6flADEL8QjxP6B
nwDEPcQSxP47rQDEN8QnxP4ArGjE-gCrdsT_AKqCxP4AqYvE-gColMT_AKebxCHEDcSfn8T_AKO2
xArE-gChxMQkxP4AntTE-gCb38T_AJjrxP4AlPvE-jOQ-8T_TYz-xP5fiP-E-m6D-8T_e3--xCXE
K8QsxCbE-rlY-8T_yEf-xP7ZJf-E-uUA88QgxDTE-vgAvsQdwP4AAAD9wD811T81-f39-f39-dQ-
NdM-Nf39-f39-f3WP9M1-f39-f39-f39-e8-wDXAP8A1wD-ANcA-wDXAPzU-NT81PzU-wTXAP8A1
wD-ANcA-wDXAP8A1-f39-f39-cA-wDXAP8A1wD-ANcA-wDXBPzU-NT81PzU-NcM-wDXAP8A1wD-A
NcA-wDX9-f39-f38P8A1wD-ANcA-wDXAP8A1wj-BNT81PzU-wDXDP8A1wD-ANcA-wDXAP8A1-f39
-f39-D-ANcA-wDXAP8A1wD-ANcE-NT81PzU-NT81wz-ANcA-wDXAP8A1wD-ANf39-f39-f3AP8A1
wD-ANcA-wDXAP8A1wD81PzXAP8A1P8E1wD-ANcA-wDXAP8A1wD-ANf39-f3LAAAAAAAAAAE=
:: main.lua
--[[pod_format="raw",created="2024-03-31 05:33:06",modified="2025-10-20 09:34:46",revision=10319]]
include "src/globals.lua"
--include "src/custom_wrangle.lua"
include "src/oklab.lua"
include "src/palette.lua"
include "src/settings.lua"
include "src/files.lua"
include "src/integration.lua"
include "src/remap.lua"
include "src/soft_wrap.lua"
include "src/gui.lua"
include "src/gui_palette.lua"
include "src/gui_alt_sliders.lua"
include "src/gui_old_sliders.lua"
include "src/gui_settings.lua"
include "src/gui_help.lua"
include "src/gui_newfile.lua"
include "src/gui_hexdialog.lua"


function _init()
	load_settings()

	window {
		tabbed = true,
		-- TODO: as of Picotron 0.2.0c, this doesn't seem to work anymore?
--		workspace = user_settings.open_in_gfx_workspace and 1 or nil,
		icon = --[[pod_type="gfx"]]unpod("b64:bHo0ABYAAAAUAAAA8AVweHUAQyAICARwtyBHIBcgRyC3cA=="),
	}
	
	local default_folder = "/ram/cart/pal/"
	-- TODO: useful or not?
--	if env().sandbox then
--		default_folder = "/appdata/pal/"
--	end
	
	local working_file_path = env()[1]
	if type(working_file_path) ~= "string" then
		mkdir(default_folder)
		working_file_path = default_folder .. "0.pal"
	end

	menuitem{
		id = "new_file",
		label = "\^:7f4141417f616500 New File",
		action = function()
			local segs = split(working_file_path,"/",false)
			local path = string.sub(working_file_path, 1, -#segs[#segs] - 2) -- same folder as current file
			local open_with = env().argv[0]
			if (open_with == "/system/apps/terminal.lua") then
				open_with = "/ram/cart/main.lua"
			end
			create_process("/system/apps/filenav.p64", { path = path, use_ext = "pal", intention="new_file", open_with = open_with, window_attribs= {workspace = "current", autoclose=true}})
		end
	}

	--custom_wrangle_working_file(
	wrangle_working_file(
		save_working_file,
		load_working_file,
		working_file_path
	)

	menuitem{
		id = "export_hex",
		label = "\^:7f4141417f616500 Export File",
		action = function()
			local current_filename = pwf()
			local segs = split(current_filename,"/",false)
			local path = string.sub(current_filename, 1, -#segs[#segs] - 2) -- same folder as current file
			create_process("/system/apps/filenav.p64", 
				{path=path, intention="select_file", use_ext = "hex", window_attribs={workspace = "current", autoclose=true}})
		end
	}
	on_event(
		"select_file",
		function(event)
			local filename = event.filename
			local ext = event.filename:ext()
			if ext == nil then
				filename ..= ".hex"
				ext = "hex"
			end
			notify("Palette exported to " .. filename)
			if ext == "hex" or ext == "txt" then
				store(filename, save_hex_file(), { metadata_format="none" })
			else
				local data, metadata = save_pal_file()
				store(filename, data, metadata)
			end
		end
	)

	
	-- Force the 11 first rows of the screen to use a default palette,
	-- so that the menu bar stays readable even when the colors used by
	-- the gui are redefined.
	poke(0x5400, 0b01010101, 0b01010101, 0b00010101)
	init_color_band()
	
	rebuild_palette()
	
	on_event("lost_focus", function() send_palette() end)
		
	on_event("drop_items", handle_drop_items)
	
	init_undo()

	menuitem { id = "okpal_div1", label = "", divider = true, action = function() end }
	menuitem {
		id = "okpal_clear_colors",
		label = "\^:0000000000000000 Clear Palette",
		action = function() undo_stack:checkpoint(); clear_colors() end
	}
	menuitem {
		id = "okpal_reset_colors",
		label = "\^:0000000000000000 Reset Pic. Colors",
		action = function() undo_stack:checkpoint(); reset_picotron_colors() end
	}
	menuitem {
		id = "okpal_remap_colors",
		label = "\^:0000000000000000 Remap Colors",
		action = function() undo_stack:checkpoint(); remap_colors() end
	}
	menuitem { id = "okpal_div2", label = "", divider = true, action = function() end }
	menuitem {
		id = "okpal_manual",
		label = "\^:0000000000000000 Help",
		shortcut = "F1",
		action = open_help
	}
	
	test_cube_colors = test_cube_colors or default_test_cube_colors()
	test_ramp_colors = test_ramp_colors or default_test_ramp_colors()
	generate_gui()
	
	if is_new_file then
		open_new_file_dialog()
	end
	
	if imported_hex_file then
		open_import_hex_file_dialog()
	end
end


function _draw()
	cls(bg_color)
	gui:draw_all()
	blinked()
end


function _update()
	if padlock_flashing then
		padlock_flashing_time += 1
	end
	if crying_a_timer > 0 then
		crying_a_timer -= 1
		if crying_a_timer <= 0 then
			crying_a_done = true
		end
	end
	if circling_anim_timer > 0 then
		circling_anim_timer -= 1 / 12.0
	end
	
	if gui_changed then
		generate_gui()
		refresh_modal()
		gui_changed = false
	end
	gui:update_all()
	
	if key("ctrl") then
		if keyp("c") then copy_color() end
		if keyp("x") then cut_color() end
		if keyp("v") then paste_color() end
		if keyp("z") then undo_stack:undo(); update_hidden_toggles() end
		if keyp("y") then undo_stack:redo(); update_hidden_toggles() end
	end
	
	if keyp("f1") then open_help() end
	
	if keyp("tab") then
		pickers_mode = (pickers_mode == "linear_hue") and "circular_hue" or "linear_hue"
		gui_changed = true
	end
	
	if key("ctrl") and keyp("n") then
		change_settings({ show_color_names = not user_settings.show_color_names })
		gui_changed = true
	end
	if key("ctrl") and keyp("b") then
		change_settings({ show_color_band = not user_settings.show_color_band })
		if user_settings.show_color_band then
			show_color_band()
		else
			hide_color_band()
		end
		gui_changed = true
	end
end




-- Undo ---------------------------------------------------------------------------


function init_undo()
	undo_stack = create_undo_stack(
		-- Save current state
		function()
			return {
				mem = copy_palette(),
				hsl = copy_palette_hsl(),
				test_cube_colors = copy(test_cube_colors),
				test_ramp_colors = test_ramp_colors and test_ramp_colors:convert("u8"),
			}
		end,
		-- Restore previous state
		function(state)
			poke_palette(state.mem)
			restore_palette_hsl(state.hsl)
			test_cube_colors = state.test_cube_colors
			test_ramp_colors = state.test_ramp_colors
		end
		-- 0x11 -- appropriate?
	)	
end


function copy(t)
	if type(t) ~= "table" then
		return t
	end
	local new = {}
	for k, v in pairs(t) do
		new[k] = copy(v)
	end
	return new
end

:: manual.txt
--[[pod_format="raw",created="2024-04-04 06:47:16",icon=userdata("u8",16,16,"00000101010101010101010101000000000106060606060606060606060100000107010606060606060606060606010000010106060707070707070707060100000106060607070707060606070601000107010606070707070606060706010000010106060706060607070707060100000106060607060606070707070601000107010606070707070707070706010000010106060606060606060606060100000106060606060606060606060601000107010606060606060606060601010000010101010101010101010101070100000101070707070707070707070601000000010606060606060606060601000000000001010101010101010101000000"),lowcol_icon=true,modified="2025-10-20 09:34:46",revision=1386,stored="2024-04-04 06:56:33"]]
# OkPal

OkPal is a tool to create and edit color palettes.
You can easily use those palettes in your programs,
and even directly in Picotron's sprite and map editors.

To use a palette, add the following line to your 
initialisation code:

```
    fetch("pal/0.pal"):poke(0x5000)
```


## Features

- Colors are defined by their hue, saturation and
  lightness; the calculations use a perceptually
  uniform color space (OkLAB).
- Colors are displayed and edited on multiple
  2D graphs.
- Any change to the palette is propagated to
  Picotron's sprite and map editors.
- Ability to reorder colors by drag-and-drop.
- Undo/redo for all operations.
- Two file formats are supported: ".hex" and ".pal".
- Multiple options for importing external palettes
  (keep default palette, overwrite it, or try to 
  match it)


## Usage

The screen is separated in three different zones:
- At the top, the full palette is displayed, with
  colors ordered by number (sams as in the sprite
  editor first tab). The currently selected color
  is also displayed here.
- On the right, a "test zone" allows you to paint
  on cubes or square to test your modified palette.
- The rest of the screen display the colors as
  dots on interactive 2D graphs, called "pickers"
  in this manual. This is the main way to create
  and edit colors.


To modify a color, you must first select it. You can
do that either by clicking in the palette overview
at the top of the screen, or by clicking directly on
one of the color dots in the circle picker or in the
square picker.

Once selected, some information about the color are
displayed on the right of the palette overview:

- the color number;
- the hex code corresponding to the RGB values of
  the color;
- a padlock icon: if the padlock is closed, the color
  is "locked" and cannot be edited; click on the icon
  to lock/unlock it;
- an eye icon: if the eye is closed, the color is only
  shown in the palette overview; it is hidden in the
  circle and square pickers.
- a paint bucket icon: you can click on it to change
  the color background to the current selected color;
  click again to go back to a black background.

You can copy the current color by using Ctrl-C, and
paste a copied color onto the current one by using
Ctrl-V. This also works outside OkPal: the color is
stored in the clipboard as a hex code ("#ffacc5").

There is five different ways to adjust the selected
color:

- a small triangle *outside* the circle picker
  allows you to change the hue of the color;
- a small colored circle *inside* the circle picker
  allows you to change at the same time the hue and
  the saturation;
- a small colored triangle below the square picker
  allows you to change just the saturation;
- a small colored triangle at the right of the square
  picker allows you to change the lightness;
- finally, a small colored circle inside the square
  picker allows you to change at the same time the
  saturation and the lightness.

Any change you make can be reverted by hitting
Ctrl-Z for undo. Use Ctrl-Y for redo.

Once you have several colors in you palettes, you can
reorder them in the palette overview: just drag one
color onto another, they will swap their positions.
Note that both colors must be unlocked.


## Using the palette in cartridges

By default, the palette you edit is saved in the
cart you're working on, alongside your sprite sheets
and maps.

The default path is "/ram/cart/pal/0.pal"

In order to use a palette in your programs, you just
need to copy it in memory. The default palette is
stored at address 0x5000:

```
    fetch("pal/0.pal"):poke(0x5000)
```


## Loading and saving

If you only need one palette for your cart, you
don't need to do anything special to save it. It is
saved alongside the rest of your assets each time
you hit Ctrl-S.

In order to create a new palette, use the '+' button
at the right of the tabs and choose the name of your
new palette, for example "1.pal". If you need to
start from scratch for this new palette, use
"Empty Palette" or "Picotron Palette" from the menu.

You can load a previously created palette by using
"Open File" in the menu.


## Importing and exporting

You can import and export palettes for use with
external tools. Currently the only supported format
is ".hex" files, which are simple text files with one
line per color, represented by their RGB code in hex
format (without "#" or "0x", just the hexadecimal
numbers).

To import a palette, choose "Open File" from the
menu, and select the ".hex" file. If this is the first
time you open this external palette in OkPal, a
dialog will appear to let you choose how to arrange
the colors in the palette. You can either:

- Keep default Picotron palette in the first 32 colors,
  and put the imported colors in the last 32 slots.
- Or simply import the palette as is. Note that this
  will affect the interface and probably make it
  difficult to use the menu, the sprite editor and
  the map editor.

To export a palette, choose "Save File As" in the
menu. In the save dialog, enter a file name ending
in ".hex".


## Changelog

2023-10-20: version 1.2.3 (release #okpal-12)

- Changed: mouse wheel is now always used to select previous or next color.
- Fixed: unable to enter color codes containing the letter "b".

2025-03-29: versrion 1.2.2 (release #okpal-11)

- Added: colorful icon!
- Added: A "Remap colors" menu entry, that bring back
  the feature removed in 1.1.0; reoder all the colors
  to match as well as possible the colors of the default
  palette.
- Added: Menu entry for creating a new file (was necessary
  when sharing workspace with the gfx editor... not possible
  anymore, so maybe remove the menu entry?).
- Changed: when a ".hex" file is opened, the
  "test zone" (i.e. the cubes and ramps) is replaced
  with a simple overview of all the color codes; this
  is because ".hex" files do not contain any
  metadata, so they cannot save the test zone state.

2025-03-18: version 1.2.1 (release #okpal-10)

- Added: "Export File" menu entry to save a copy of the current file without opening it.
- Changed: ".hex" files are saved without metadata.
- Changed: dragging color dots is much more precise.
- Changed: constrain color changes along an axis when dragging a color dot
  using the right or middle mouse buttons (instead of holding "shift" or "control").
- Changed: bigger color dots, easier to grab.
- Changed: propagate palette to sprite and map editors only when focus is lost.
- Changed: Don't automatically register as default app for ".pal" and ".hex".
- Fixed: bug in opening files (due to bug in picotron's `wrangle.lua` since 0.1.1e)
- Fixed: reset display palette rows when hiding the color band.

2025-03-13: version 1.2.0 (release #okpal-9)

- Added: new alternate view with hue/lum and hue/sat pickers.
- Added: hold "shift" or "ctrl" when dragging a color dot to constrain the change along one axis.
- Added: ability to scroll the hue axis of the alternate view, either with the scroll wheel or the dedicated control at the bottom of the screen.
- Added: color names in the alternate view.
- Added: color band in the alternate view.
- Added: settings to hide the color names and color band.
- Added: angel.
- Changed: simplified the old view (remove color lines on the 1D sliders)

2025-03-08: version 1.1.0 (release #okpal-8)

- removed remapping option when importing ".hex" palettes (was not working very well anyway);
- added text entries for the hex code, the hue, the saturation and the luminance;
- added a new tab for drawing color ramps in the test zone;
- added dialog when creating a new palette (to choose between empty palette or default colors);
- added settings dialog;
- added settings to register OkPal as default app for ".pal" and ".hex" files;
- added settings for disabling the propagation of the palette to the sprite and map editors;
- added blink;
- changed dialog when importing ".hex" files;
- changed dialog for displaying help;
- fixed menu bar colors when default colors are redefined;
- fixed undo/redo of test cube color changes;

2025-02-26: version 1.0.4 (release #okpal-7)

- added registering as default app for ".pal" and ".hex" (needed for the file dialog?)
- added undo/redo and help buttons;
- added "clear" button to the "test cubes";
- added legends for the two pickers;
- changed: moved the luminance slider to the left of the sat/lum picker for consistency;
- fixed: palette is now propagated to all gfx and map editors (thanks to Eiyeron for the implementation);
- fixed: the "test cubes" saved in metadata where not properly loaded;


2024-08-23: version 1.0.3 (release #okpal-6)

- added: add file icon to saved palettes;
- changed: can load and import palettes by
  double-clicking in the file dialog (no need
  to drag-and-drop anymore);
- fixed: bug in BBS;

2024-05-03: version 1.0.2 (release #okpal-5)

- fixed: bug while using "+" button in Picotron
  0.1.0g;
- changed: disabled tabs in BBS, as it prevents
  the cart from running;

2024-04-27: version 1.0.1 (release #okpal-4)

- fixed: picotron's palette was not locked in the
  default file on first opening;
- fixed: saving a ".pal" file from an imported
  ".hex" file was not working;
- explain how to export to .hex in the manual;

2024-04-06: version 1.0.0 (release #okpal-3)

- propagate palette to sprite and map editors;
- undo/redo;
- reorder colors by drag-and-drop;
- import dialog;
- reorder imported colors to match default colors;
- added a manual;
- menu entries to initialize the palette and open
  the manual;
- flash padlock icon when trying to edit a locked
  color;
- shift-click paint-bucket icon to change the "white"
  color used in the interface, and ctrl-click the
  icon to change the "black" (useful when importing
  external palettes);

2024-04-02: version 0.0.3 (release #okpal-2)

- Added the ability to change the background color (by clicking on the small paint bucket icon), and switched the default background to black.
- Added the ability to import ".hex" files (using drag and drop from the "Open File" dialog); to actually create the ".pal" file, you need to save.
- Improved the color pickers.
- Added the ability to copy/paste colors (using a hex string starting with #).
- Added the ability to show/hide individual colors (right click on a color in the palette).

2024-04-01: v0.0.1 (release #okpal-1)

- Added the ability to lock colors, to avoid accidentally modifying them. By default the first 33 colors are locked (click on the padlock to unlock)
- Added the ability to hide specific rows of color from the two color pickers.
- Added sliders to change the individual components (hue, saturation and luminance).
- Added the ability to select a color by clicking on their dot in the color pickers.
- Added a test zone, with 24 paintable cubes (click on a cube face to change its color).


:: src/
:: src/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTAzIDE4OjA3OjM0Iixtb2RpZmllZD0iMjAyNS0x
MC0yMCAwOTozNDo0NiIsc3RvcmVkPSIyMDI0LTA0LTAzIDE4OjA3OjM0Il1d
:: src/files.lua
--[[pod_format="raw",created="2025-03-08 09:21:19",modified="2025-10-20 09:34:46",revision=1128]]
-- Loading and saving -------------------------------------------------------------


function save_working_file()
	local ext = pwf():ext()
	if ext == "hex" or ext == "txt" then
		return save_hex_file()
	else
		if ext != "pal" then
			notify("unknown file extension: saved using default file format")
		end
		return save_pal_file()
	end
end


function load_working_file(data, metadata)
	if fstat(pwf()) ~= "file" then
		-- This is a new file
		create_metadata()
		is_new_file = true
		return
	end

	metadata = metadata or {}
	local ext = pwf():ext()
	if ext == "pal" then
		load_pal_file(data, metadata or {})
		if undo_stack then undo_stack:reset() end
		send_palette()

	elseif ext == "hex" or ext == "txt" then
		if metadata.okpal_version then
			current_import_choice = "overwrite"
			load_hex_file(data, metadata or {})
			if undo_stack then undo_stack:reset() end
			send_palette()
		else
			imported_hex_file = { data = data, metadata = metadata }
		end

	else
		notify("unkown file extension: OkPal can only load \".pal\" and \".hex\" palettes")
	end
end


-- Metadata ----------------------------------------------------------------------


function create_metadata()
	local metadata = {}
	metadata.okpal_version = okpal_version
	metadata.icon = userdata("u8",16,16,"0001010101010101010101000000000000010707070707070707060100000000000107070707070707070606010000000001070707070707070706060601000000010707070707070707060606060100000107070707070707070707070701000001070707070707070707070707010000010707060601010d0d01010707010000010707060601010d0d010107070100000107070101070706060d0d07070100000107070101070706060d0d07070100000107070d0d01010d0d060607070100000107070d0d01010d0d060607070100000107070707070707070707070701000001070707070707070707070707010000010101010101010101010101010100")
	metadata.bg_color = bg_color
	metadata.blackest_color = blackest_color
	metadata.whitest_color = whitest_color
	metadata.hidden_toggles = hidden_toggles
	metadata.hidden = copy(hidden)
	metadata.locked = copy(locked)
	metadata.pickers_mode = pickers_mode
	metadata.hue_offset = hue_offset
	metadata.test_mode = test_mode
	metadata.test_cube_colors = copy(test_cube_colors)
	metadata.test_ramp_colors = test_ramp_colors and test_ramp_colors:convert("u8")
	return metadata
end


function load_metadata(metadata)
	metadata = metadata or {}
	bg_color = metadata.bg_color or 0
	blackest_color = metadata.blackest_color or 0
	whitest_color = metadata.whitest_color or 7
	
	if type(metadata.hidden_toggles) == "table" then
		hidden_toggles = metadata.hidden_toggles
	else
		hidden_toggles = {}
		for row = 0, 3 do
			hidden_toggles[row] = false
		end
	end
	
	if type(metadata.hidden) == "table" then
		hidden = metadata.hidden
	else
		hidden = {}
		for c = 0, 63 do
			hidden[c] = false
		end
	end
	
	if type(metadata.locked) == "table" then
		locked = metadata.locked
	elseif pwf() == "/ram/cart/pal/0.pal" then
		-- This only occurs when a default starting file
		-- is created.
		for c = 0, 63 do
			locked[c] = c <= 31
		end
	else
		locked = {}
		for c = 0, 63 do
			locked[c] = false
		end
	end

	if type(metadata.pickers_mode) == "string" then
		pickers_mode = metadata.pickers_mode
	else
		pickers_mode = "linear_hue"
	end
	
	if type(metadata.hue_offset) == "number" then
		hue_offset = metadata.hue_offset
	else
		hue_offset = 0.0
	end

	if type(metadata.test_mode) == "string" then
		test_mode = metadata.test_mode
	else
		test_mode = "cubes"
	end

	if type(metadata.test_cube_colors) == "table" then
		test_cube_colors = copy(metadata.test_cube_colors)
	else
		test_cube_colors = default_test_cube_colors()
	end
	
	if type(metadata.test_ramp_colors) == "userdata" then
		test_ramp_colors = metadata.test_ramp_colors:convert("u8")
	else
		test_ramp_colors = default_test_ramp_colors()
	end
end


-- Load and save pal files -------------------------------------------------------


function load_pal_file(data, metadata)
	if data then
		if type(data) == "userdata" and data:width() == 64 then
			for c = 0, 63 do
				if data[c] then
					poke_color_code(c, data[c])
				end
			end
		else
			notify("unable to load working file")
			return
		end
	else
		-- New file
	end
	rebuild_palette()
	load_metadata(metadata)
	update_hidden_toggles()
end


function save_pal_file()
	local output = userdata("i32", 64)
	for c = 0, 63 do
		output:set(c, color_code(c))
	end
	return output, create_metadata()
end


-- Load and save hex files ---------------------------------------------------------


function load_hex_file(data, metadata)
	if type(data) == "string" then
		local lines = split(data, "\n", false)
		local codes = {}
		for l in all(lines) do
			local code = tonum("0x" .. l:gsub("%s",""))
			if type(code) == "number" then
				codes[#codes + 1] = code
			elseif code then
				notify("error importing hex file")
			end
		end
		local start = 0
		if current_import_choice == "dont_clobber" then
			-- TODO: put in separate function and add menu item
			for c = 0, 32 do
				poke_color_code(c, peek4(0x5000 + 4 * (64 + c)))
			end
			start = 32
		end
		if #codes > 64 - start then
			notify("*** not enough space to import all the colors ***")
		end
		for c = start, 63 do
			if codes[c - start + 1] then
				poke_color_code(c, codes[c - start + 1])
			else
				poke_color_code(c, 0x000000)
			end
		end
		rebuild_palette()
	elseif data then
		notify("import hex file: unkown type: " .. type(data))
	end

	load_metadata(metadata)
	if current_import_choice == "dont_clobber" then
		active_color = nil
		for c = 0, 31 do
			hidden[c] = true
			locked[c] = true
		end
		hidden_toggles[0] = true
		hidden_toggles[1] = true
		blackest_color = 0
		whitest_color = 7
		bg_color = 0
	else
		local best_black, best_white = find_blackest_and_whitest()
		blackest_color = metadata.blackest_color or best_black
		whitest_color = metadata.whitest_color or best_white
		bg_color = metadata.bg_color or blackest_color
	end
	update_hidden_toggles()
end


function save_hex_file()
	-- Don't export trailing black colors
	local fin = 63
	while fin > 0 and color_code(fin) == 0 do
		fin -= 1
	end
	
	local output = ""
	for c = 0, fin do
		output ..= color_hex(c) .. "\n"
	end
	return output, { metadata_format="none" }
end

:: src/globals.lua
--[[pod_format="raw",created="2024-04-03 09:15:53",modified="2025-10-20 09:34:46",revision=6942]]
current_import_choice = "dont_clobber"

undo_stack = nil

padlock_flashing = false
padlock_flashing_time = 0

circling_anim_timer = 0

gui = nil
gui_changed = false

is_new_file = false
select_file_for_export = false
imported_hex_file = nil

blink_timer = 180 + math.random(1, 6) * 90
blink_eye = math.random(0, 3)
crying_a_timer = 0
crying_a_done = false

help_current_line = 1


-- Saved in settings ----------------------------------------------------------


user_settings = {
	send_palette = true,
	show_color_names = true,
	show_color_band = true,
	open_in_gfx_workspace = false,
	dont_blink = false,
	no_jump_scares = false,
}


-- Saved in metadata --------------------------------------------------------------


okpal_version = "1.2.3"

active_color = nil
bg_color = 0 -- TODO: what about fg?
blackest_color = 0 -- TODO: remove?
whitest_color = 7 -- TODO: remove?

hidden_toggles = { [0] = false, false, false, false }
hidden = {}
for i = 0, 63 do hidden[i] = false end
locked = {}
for i = 0, 63 do locked[i] = i <= 31 end

pickers_mode = "linear_hue"
hue_offset = 0.0

test_mode = "cubes"
test_cube_colors = nil
test_ramp_colors = nil


-- Constants ----------------------------------------------------------------------


function default_test_cube_colors()
	return {
		[0] = 
		{15, 31, 4},
		{31, 4, 20},
		{4, 20, 21},
		--
		{10, 9, 25},
		{9, 25, 24},
		{8, 24, 2},
		--
		{26, 11, 27},
		{11, 27, 3},
		{27, 3, 19},
		--
		{28, 17, 19},
		{28, 12, 16},
		{12, 16, 1},
		--
		{6, 29, 13},
		{29, 13, 18},
		{13, 18, 1},
		--
		{7, 23, 14},
		{23, 14, 13},
		{14, 30, 18},
		--
		{7, 6, 22},
		{6, 22, 5},
		{22, 5, 21},
		--
		{1, 1, 1},
		{1, 1, 1},
		{1, 1, 1},
		--
	}
end


function default_test_ramp_colors()
	local ud = userdata("u8", 10, 27, 0)
	ud:set(
		0, 0,
		 0, 24,  8, 25,  9, 10, 26, 11, 27,  0,
		 6,  0,  0,  0,  0,  0,  0,  0,  3,  0, 
		22,  0,  0,  0,  0,  0,  0,  0, 19,  0, 
		 5,  0,  0,  0,  0,  0,  0,  0,  1,  0, 
		13,  0,  0,  0,  0,  0,  0,  0, 16,  0, 
		29,  0,  0,  0,  0,  0,  0,  0, 17,  0, 
		23,  0,  0,  0,  0,  0,  0,  0, 12,  0, 
		14,  0,  0,  0,  0,  0,  0,  0, 28,  0, 
		30, 18,  2, 21, 20,  4, 31, 15,  7,  0,
		 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
		 0, 20,  4, 31, 15,  8, 24,  2,  0,  0,
		21,  5, 22,  6,  7, 23, 14, 30,  0,  0,
		 1, 16, 17, 12, 28, 29, 13, 18,  0,  0,
		19,  3, 27, 11, 26, 10,  9, 25,  0,  0
	)
	return ud
end	

:: src/gui.lua
--[[pod_format="raw",created="2024-03-31 05:58:06",modified="2025-10-20 09:34:46",revision=10038]]
function generate_gui()
	gui = create_gui()
	generate_palette_gui()
end


-----------------------------------------------------------------------------------


local modal = nil


function open_modal(width, height, autoclose)
	if modal ~= nil then
		--TODO: !!!
		return
	end

	modal = gui:attach {
		x = 0, y = 0,
		width = gui.width, height = gui.height,
		autoclose = autoclose or false,
		click = function(self, msg)
			if msg.has_pointer and self.autoclose then
				close_modal()
			end
		end
	}
	local el = modal:attach {
		x = (modal.width - width) // 2, y = (modal.height - height) // 2,
		width = width, height = height,
		draw = function(self)
			clip()
			rect(-3, -3, self.width+3, self.height+3, bg_color)
			rectfill(-2, -2, self.width+2, self.height+2, outline_color())
			rect(-1, -1, self.width+1, self.height+1, bg_color)
		end,
	}
	return el
end


function has_modal()
	return modal ~= nil
end


function refresh_modal()
	if has_modal() then
		gui:attach(modal)
	end
end


function close_modal()
	if modal then
		modal:detach()
	end
	modal = nil
	gui_changed = true -- necessary after closing settings dialog
end


-----------------------------------------------------------------------------------


function create_label(el)
	el.width = el.width or (5 * #el.label + 4)
	el.height = el.height or 9
	gui:new(el)
	function el:draw()
		print(self.label, 0, 0, self.fg or outline_color())
	end
	return el
end


-----------------------------------------------------------------------------------


function create_button(el)
	local label = el.label or "---"
	el.width = el.width or (#label * 5 + 8 + 8)
	el.height = el.height or 16
	el.cursor = "pointer"

	function el:draw(msg)
		local fg = self.fg or bg_color
		line(2, 0, self.width - 3, 0, fg)
		pset(1, 1, fg)
		line(2, self.height - 1, self.width - 3, self.height - 1, fg)
		pset(self.width - 2, 1, fg)
		line(0, 2, 0, self.height - 3, fg)
		pset(1, self.height - 2, fg)
		line(self.width - 1, 2, self.width - 1, self.height - 3, fg)
		pset(self.width - 2, self.height - 2, fg)
		local pressed = msg.has_pointer and self.clicked
		if pressed then
			rectfill(1, 1, self.width - 2, self.height - 2, fg)
		end
		print(self.label or "---", 9, 4, pressed and outline_color() or fg)
	end
	
	function el:click()
		self.clicked = true
	end
	
	function el:release(msg)
		self.clicked = false
		if (msg.has_pointer and self.act) self.act()
	end	

	return el
end


function create_action_button(el)
	local s = get_spr(el.sprite)
	el.width = s:width() or 16
	el.height = s:height() or 16
	el.cursor = "pointer"

	function el:draw(msg)
		pal(7, outline_color())
		local s = el.sprite
		if el.active and not el:active() then
			s += 2
		elseif el.clicked and msg.has_pointer then
			s += 1
		end
		spr(s, 0, 0)
		pal(7, 7)
	end
	
	function el:click()
		self.clicked = true
	end
	
	function el:release(msg)
		self.clicked = false
		if (msg.has_pointer and self.act) self.act()
	end	

	return el
end


-----------------------------------------------------------------------------------


function create_field(el)
	el.cursor = get_spr(62)

	function el:draw()
		local str = type(self.get == "function") and self:get() or "---"
		local fg = type(self.get_fg == "function") and self:get_fg() or outline_color()
		local prefix = self.small_font and "\014" or ""
		if self:has_keyboard_focus() then
			local suffix = (time() % 0.666 > 0.333) and "\016" or ""
			str =  self.str .. suffix
			print(prefix .. str, 1, 1, fg)
			clip()
			rect(-1, -1, self.width, self.height, fg)
		else
			local ww,hh = print(prefix .. str, 0, -1000)
			print(prefix .. str, self.width - ww - 1, 1, fg)
			if self.with_border then
				clip()
				rect(-1, -1, self.width, self.height, fg)
			end
		end
	end

	function el:click()
		self:set_keyboard_focus(true)
		readtext(true)
		self.str = "" -- starting editing new string
	end

	el.custom_update = el.update
	function el:update(msg)
		self.with_border = msg.has_pointer
		self:custom_update()
		if self:has_keyboard_focus() then
			while peektext() do
				self.str = self.str .. readtext()
			end
			if keyp("backspace") then
				self.str = sub(self.str, 1, -2)
			end
			if keyp("enter") then
				if type(self.set) == "function" then
					self:set(self.str)
				end
				self:set_keyboard_focus(false)
			end
		end
	end

--	gui:new(el)

	return el
end


-----------------------------------------------------------------------------------


function create_checkbox(el)
	el.width = el.width or (16 + 5 * #el.label + 4)
	el.height = el.height or 12
	el.cursor = "pointer"
	el.get = el.get or function(self) return self.checked end
	el.toggle = el.toggle or function(self) self.checked = not self.checked end
	gui:new(el)

	function el:draw()
		local fg = self.fg or outline_color()
		local checked = self:get()
		pal(7, fg)
		spr(checked and 49 or 48, 0, 0)
		pal(7, 7)
		print(el.label, 16, 1, fg)
	end
	
	function el:release(msg)
		if msg.has_pointer then
			self:toggle()
		end
	end	

	return el
end


------------------------------------------------------------------------------


function create_radio_button(el)
	el.width = 188
	el.height = 12 -- TODO: count the lines?
	el.cursor = "pointer"
	
	function el:draw()
		local fg = self.fg or bg_color
		local choices = self.parent.choices
		local checked = choices and choices[self.group] == self.key
		pal(7, fg)
		spr(checked and 51 or 50, 0, 0)
		pal(7, 7)
		print(el.label, 15, 1, fg)
	end
	
	function el:tap()
		if not self.parent.choices then
			self.parent.choices = {}
		end
		self.parent.choices[self.group] = self.key
	end
	
	return el
end


-- Utility functions ----------------------------------------------------------------


function outline_color()
	if lum(bg_color) < 0.5 then
		return whitest_color
	else
		return blackest_color
	end
end


function contrast_color(c)
	return (lum(c) < 0.5) and whitest_color or blackest_color
end


function contrast_color_darker(c)
	return (lum(c) < 0.15) and whitest_color or blackest_color
end


function distance(ax, ay, bx, by)
	return math.sqrt((ax - bx)^2 + (ay - by)^2)
end
:: src/gui_alt_sliders.lua
--[[pod_format="raw",created="2025-03-11 11:29:57",modified="2025-10-20 09:34:46",revision=2288]]
local rectangle_width = 375
local rectangle_height = 98
local rectangle_border = 7
local rectangle_inner_width = rectangle_width - 2 * rectangle_border
local rectangle_inner_height = rectangle_height - 2 * rectangle_border


-------------------------------------------------------------------------------


local function hv_coords(c, ordinate)
	local hue = (hue(c) + hue_offset) % 1.0
	local v = color_component(c, ordinate)
	local x = rectangle_border + hue * rectangle_inner_width
	local y = rectangle_border + rectangle_inner_height - v * rectangle_inner_height
	return x, y
end


local function coords_hv(x, y)
	local hue = (x - rectangle_border) / rectangle_inner_width
	hue = (hue - hue_offset) % 1.0
	local v = 1.0 - ((y - rectangle_border) / rectangle_inner_height)
	return hue, v
end


local function h_coords(hue)
	hue = (hue % 1.0)
	local x = rectangle_border + hue * rectangle_inner_width
	return x
end


---------------------------------------------------------------------------------


function create_rectangle_picker(el)
	el.ordinate = el.ordinate or "l"
	el.width = rectangle_width
	el.height = rectangle_height
	el.drag_delta = nil
		
	function el.draw(self, _msg)
		rect(
			rectangle_border - 1, rectangle_border - 1, 
			rectangle_border + rectangle_inner_width + 1, rectangle_border + rectangle_inner_height + 1, 
			outline_color()
		)
		for c = 0, 63 do
			if not hidden[c] and lum(c) != 0 then
				local x, y = hv_coords(c, self.ordinate)
				pal(14, c)
				spr(11, x - 5, y - 5)
				pal(14, 14)
			end
		end
		if active_color and not hidden[active_color] then
			local x, y = hv_coords(active_color, self.ordinate)
			pal(7, outline_color())
			pal(14, active_color)
			spr(
				self.drag_delta and 13 or 12,
				x - 5, y - 5,
				x + 5, y + 5
			)
			pal(14, 14)
			pal(7, 7)
			if circling_anim_timer > 0 then
				local delta = math.floor(0.5 + 5 + 10 * circling_anim_timer * circling_anim_timer)
				oval(
					x - delta, y - delta,
					x + delta, y + delta,
					outline_color()
				)
			end
		end
		clip()
		pal(7, outline_color())
		spr(self.ordinate == "l" and 22 or 23, -11, self.height - 74)
		pal(7, 7)
	end
	
	function el.hover(self, msg)
		self.cursor = 1
		if active_color and not hidden[active_color] then
			local ax, ay = hv_coords(active_color, self.ordinate)
			if distance(ax, ay, msg.mx, msg.my) < 6 then
				self.cursor = "pointer"
			end
		end
		-- In reverse order to prioritize colors on top
		for c = 63, 0, -1 do
			local cx, cy = hv_coords(c, self.ordinate)
			if distance(cx, cy, msg.mx, msg.my) < 5 and not hidden[c] and lum(c) != 0 then
				self.cursor = "pointer"
			end
		end
	end
	
	function el.click(self, msg)
		if active_color and not hidden[active_color] then
			local ax, ay = hv_coords(active_color, self.ordinate)
			if distance(ax, ay, msg.mx, msg.my) < 6 then
				undo_stack:checkpoint()
				mouselock(0x4|0x8, 1.0, 0.25)
				self.cursor = 0
				self.drag_delta = { ox = ax, oy = ay, x = 0, y = 0 }
				return
			end
		end
		
		active_color = nil
		-- In reverse order to prioritize colors on top
		for c = 63, 0, -1 do
			local cx, cy = hv_coords(c, self.ordinate)
			if distance(cx, cy, msg.mx, msg.my) < 5 and not hidden[c] and lum(c) != 0 then
				undo_stack:checkpoint()
				active_color = c
				local ax, ay = hv_coords(active_color, self.ordinate)
				mouselock(0x4|0x8, 1.0, 0.25)
				self.cursor = 0
				self.drag_delta = { ox = ax, oy = ay, x = 0, y = 0 }
				return
			end
		end
		self.drag_delta = nil
	end
	
	function el.drag(self, msg)
		if (not active_color) return
		if (not self.drag_delta) return
		if locked[active_color] then
			padlock_flashing = true
		elseif msg.mb & 0x07 then
			self.drag_delta.x += msg.dx
			self.drag_delta.y += msg.dy
			local ax = self.drag_delta.ox + self.drag_delta.x * 0.25
			local ay = self.drag_delta.oy + self.drag_delta.y * 0.25
			local hue, v = coords_hv(ax, ay)
			hue = max(0.0, hue)
			if msg.mb & 2 ~= 0 then hue = nil end
			if msg.mb & 4 ~= 0 then v = nil end
			local sat = self.ordinate == "s" and v or nil
			local lum = self.ordinate == "l" and v or nil
			change_color(active_color, hue, sat, lum)
		end
	end
	
	function el.release(self, msg)
		send_palette()
		self.drag_delta = nil
		padlock_flashing = false
		padlock_flashing_time = 0
		mouselock(false)
		self.cursor = nil
	end

	return el
end


--------------------------------------------------------------------------------


function create_hue_knob(el)
	el.width = rectangle_width
	el.height = 9
	
	function el.draw(self, _msg)
		if active_color and not hidden[active_color] then
			local ax, _ = hv_coords(active_color, "l")
			pal(7, outline_color())
			pal(13, 0)
			spr(5, ax - 4, 0)
			pal(13, 13)
			pal(7, 7)
		end
	end	
	
	function el.hover(self, msg)
		self.cursor = 1
		if active_color and not hidden[active_color] then
			local ax, _ = hv_coords(active_color, "l")
			if msg.mx and msg.mx >= ax - 4 and msg.mx <= ax + 4 then
				self.cursor = "grab"
			end
		end
	end

	function el.click(self, msg)
		undo_stack:checkpoint()
		if active_color and not hidden[active_color] then
			local ax, _ = hv_coords(active_color, "l")
			if msg.mx and msg.mx >= ax - 4 and msg.mx <= ax + 4 then
				mouselock(0x4|0x8, 1.0, 0.25)
				self.cursor = 0
				self.drag_delta = { ox = ax, x = 0 }
			end
		end
	end
	
	function el.drag(self, msg)
		if (not active_color) return
		if (not self.drag_delta) return
		if locked[active_color] then
			padlock_flashing = true
		else
			self.drag_delta.x += msg.dx
			local ax = self.drag_delta.ox + self.drag_delta.x * 0.25
			local hue, _ = coords_hv(ax, 0)
			hue = max(0.0, hue)
			change_color(active_color, hue, nil, nil)
		end
	end
	
	function el.release(self, msg)
		send_palette()
		self.drag_delta = nil
		padlock_flashing = false
		padlock_flashing_time = 0
		mouselock(false)
		self.cursor = 1
	end
			
	return el
end


--------------------------------------------------------------------------------


function create_val_knob(el)
	el.ordinate = el.ordinate or "l"
	el.width = 9
	el.height = rectangle_height
	
	function el.draw(self, _msg)
		if active_color and not hidden[active_color] then
			local _, ay = hv_coords(active_color, self.ordinate)
			pal(7, outline_color())
			pal(13, active_color)
			spr(6, 0, ay - 4)
			pal(13, 13)
			pal(7, 7)
		end
	end	
	
	function el.hover(self, msg)
		self.cursor = 1
		if active_color and not hidden[active_color] then
			local _, ay = hv_coords(active_color, self.ordinate)
			if msg.my and msg.my >= ay - 4 and msg.my <= ay + 4 then
				self.cursor = "grab"
			end
		end
	end

	function el.click(self, msg)
		undo_stack:checkpoint()
		if active_color and not hidden[active_color] then
			local _, ay = hv_coords(active_color, self.ordinate)
			if msg.my and msg.my >= ay - 4 and msg.my <= ay + 4 then
				mouselock(0x4|0x8, 1.0, 0.25)
				self.cursor = 0
				self.drag_delta = { oy = ay, y = 0 }
			end
		end
	end
	
	function el.drag(self, msg)
		if (not active_color) return
		if (not self.drag_delta) return
		if locked[active_color] then
			padlock_flashing = true
		else
			self.drag_delta.y += msg.dy
			local ay = self.drag_delta.oy + self.drag_delta.y * 0.25
			local _, v = coords_hv(0, ay)
			local sat = self.ordinate == "s" and v or nil
			local lum = self.ordinate == "l" and v or nil
			change_color(active_color, nil, sat, lum)
		end
	end
	
	function el.release(self, msg)
		send_palette()
		self.drag_delta_y = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end
			
	return el
end


--------------------------------------------------------------------------------


function create_color_names(el)
	el.width = rectangle_inner_width + 1
	el.height = 8
	function el.draw(self, msg)
		local x = math.floor(0.5 + h_coords(hue_offset))
		spr(46, x - rectangle_border - rectangle_inner_width - 1, 0)
		spr(46, x - rectangle_border, 0)
	end
	return el
end


--local colors = {
--	{ name = "rose", hue = 2.0 / 360.0 },
--	{ name = "red", hue = 29.0 / 360.0 },
--	{ name = "orange", hue = 53.0 / 360.0 },
--	{ name = "yellow", hue = 110.0 / 360.0 },
--	{ name = "green", hue = 142.0 / 360.0 },
--	{ name = "cyan", hue = 195.0 / 360.0 },
--	{ name = "blue", hue = 264.0 / 360.0 },
--	{ name = "violet", hue = 294.0 / 360.0 },
--	{ name = "purple", hue = 328.0 / 360.0 },
----	{ name = "magenta", hue = 328.0 / 360.0 },
--}
--
--
--function create_hue_ruler(el)
--	el.width = rectangle_inner_width
--	el.height = 8
--	function el.draw(self, msg)
--		for col in all(colors) do
--			local x = h_coords(hue_offset + col.hue)
--			print("\014" .. col.name, x - (#col.name * 2) - rectangle_border, 0)
--		end
--	end
--	return el
--end


--------------------------------------------------------------------------------


function init_color_band()
	-- Create the hue gradient palette
	local hue_step = 1.0 / 62.0
	local hue = 0
	for c = 1, 63 do
		if c ~= 1 and c ~= 7 then
			local color_code = oklab.okhsl_to_color({ h = hue, s = 1.0, l = 0.6 })
			poke4(0x5300 + 4 * c, color_code)
			hue += hue_step
		end
	end
	-- Create the sprite for the band
	local band = get_spr(44)
	set_draw_target(band)
	local width = band:width()
	local flat = (width // 61) + 1
	for x = 0, band:width() - 1 do
		local c = 1 + (x // flat )
		if c >= 1 then c += 1 end
		if c >= 7 then c += 1 end
		line(x, 2, x, 9, c)
	end
	set_draw_target()
end


function show_color_band()
	poke(0x5440, 0b11111111, 0b00001111)
end


function hide_color_band()
	poke(0x5440, 0b00000000, 0b00000000)
end


function create_color_band(el)
	el.width = rectangle_inner_width + 1
	el.height = 8
	function el.draw(self, _msg)
		local x = math.floor(0.5 + h_coords(hue_offset))
		spr(44, x - rectangle_border - rectangle_inner_width - 1, 0)
		spr(44, x - rectangle_border, 0)
	end
	return el
end

--------------------------------------------------------------------------------


function create_hue_scrubber(el)
	el.width = get_spr(47):width()
	el.height = get_spr(47):height()
	el.cursor = "grab"
	gui:new(el)
	function el.draw(self, _msg)
		pal(7, outline_color())
		spr(47, 0, 0)
		pal(7, 7)
	end
	function el.click(self, msg)
		self.drag_delta = msg.mx
		self.drag_origin = hue_offset
	end
	function el.drag(self, msg)
		if self.drag_delta then
			local dh, _ = coords_hv(msg.mx, 0) - coords_hv(self.drag_delta, 0)
			hue_offset = self.drag_origin + dh
		end
	end
	function el.release(self, msg)
		self.drag_delta = nil
	end
	function el.tap(self, msg)
		hue_offset = 0.0
	end
	return el
end
:: src/gui_help.lua
--[[pod_format="raw",created="2025-03-07 10:21:37",modified="2025-10-20 09:34:46",revision=653]]
local text_view

function open_help()
	local el = open_modal(270, 250, true)
	if not el then
		return
	end
	text_view = el:attach(create_text_view { x = 10, y = 0, width = 250, height = 250 })
	text_view:set_text(fetch("manual.txt"))
end


function create_text_view(el)
	el.lines = {}

	function el:set_text(text)
		el.lines = soft_wrap(text, self.width)
	end

	function el:draw(msg)
		cursor(0, 0)
		color(bg_color)
		local l = help_current_line
		local y = 0
		while y < self.height do
			print(self.lines[l])
			y += 11
			l += 1
		end
	end
	
	function el:mousewheel(msg)
		local nb_lines = self.height // 11
		help_current_line = mid(
			1,
			help_current_line - (msg.wheel_y * 3),	
			#self.lines - nb_lines
		)
	end	

	return el
end
:: src/gui_hexdialog.lua
--[[pod_format="raw",created="2025-03-05 12:06:52",modified="2025-10-20 09:34:46",revision=531]]
function open_import_hex_file_dialog()
	local el = open_modal(180, 100, false)
	el:attach(create_label { x = 50, y = 6, label = "Import \".hex\" file", fg = bg_color })
	el:attach(create_radio_button {
		x = 16, y = 36, 
		label = "Import after Picotron's colors",
		group = "import_hex",
		key = "dont_clobber",
	})
	el:attach(create_radio_button {
		x = 16, y = 56, 
		label = "Replace all colors",
		group = "import_hex",
		key = "overwrite",
	})
	el.choices = { import_hex = "dont_clobber" }
	el:attach(create_button {
		x = 110, y = 80,
		label = "Import",
		act = function() prepare_imported_hex(el) end
	})
end


function prepare_imported_hex(dialog)
	current_import_choice = dialog.choices.import_hex
	load_hex_file(imported_hex_file.data, imported_hex_file.metadata or {})
	clear_cube_colors()
	clear_ramp_colors()
	if (undo_stack) undo_stack:reset()
	send_palette()
	imported_hex_file = nil
	close_modal()
	gui_changed = true
end
:: src/gui_newfile.lua
--[[pod_format="raw",created="2025-03-05 08:57:06",modified="2025-10-20 09:34:46",revision=401]]
function open_new_file_dialog()
	local el = open_modal(180, 100, false)
	el:attach(create_label { x = 60, y = 6, label = "New Palette", fg = bg_color })
	el:attach(create_radio_button {
		x = 16, y = 36, 
		label = "Keep default colors",
		group = "new_palette",
		key = "keep_default",
	})
	el:attach(create_radio_button {
		x = 16, y = 56, 
		label = "Start with empty palette",
		group = "new_palette",
		key = "empty_palette",
	})
	el.choices = { new_palette = "keep_default" }
	el:attach(create_button {
		x = 110, y = 80,
		label = "Let's go!",
		act = function() prepare_new_file(el) end
	})
end


function prepare_new_file(dialog)
	if dialog.choices.new_palette == "empty_palette" then
		clear_colors()
	end
	close_modal()
end
:: src/gui_old_sliders.lua
--[[pod_format="raw",created="2025-03-17 19:49:11",modified="2025-10-20 09:34:46",revision=971]]
local circle_size = 190
local circle_border = 13
local circle_inner = circle_size - 2 * circle_border


local square_size = 190
local square_border = 7
local square_inner = square_size - 2 * square_border


------------------------------------------------------------------------------------


local function sl_coords(c)
	local sat = sat(c)
	local lum = lum(c)
	local x = square_border + sat * square_inner
	local y = square_border + square_inner - lum * square_inner
	return x, y
end


local function coords_sl(x, y)
	local sat = (x - square_border) / square_inner
	local lum = 1.0 - ((y - square_border) / square_inner)
	return sat, lum
end


-- Remove 0.25 to compensate for Picotron's angle origin,
-- and 29/360 to compensate for OkLab weird position of
-- the red color.
local angle_correction = 0.25 + 0.08


local function hs_coords(c)
	local hue = hue(c)
	local sat = mid(0.0, sat(c), 1.0)
--	sat = ((sat * 3.0) / 4.0) + 0.25
	local a = angle_correction - hue
	local dx = sat * cos(a) * (circle_inner / 2)
	local dy = sat * sin(a) * (circle_inner / 2)
	local x = circle_border + (circle_inner / 2) + dx
	local y = circle_border + (circle_inner / 2) + dy
	return x, y
end


local function h_coords(c, radius_delta, hue_delta)
	local r = circle_inner + (radius_delta or 0)
	local hue = hue(c) + (hue_delta or 0)
	local a = angle_correction - hue
	local dx = cos(a) * (r / 2)
	local dy = sin(a) * (r / 2)
	local x = circle_border + (circle_inner / 2) + dx + 0.5
	local y = circle_border + (circle_inner / 2) + dy + 0.5
	return x, y
end


local function coords_hs(x, y)
	local dx = x - (circle_border + (circle_inner / 2))
	local dy = y - (circle_border + (circle_inner / 2))
	local hue = -atan2(dx, dy) + angle_correction
	dx = (2.0 * dx) / circle_inner
	dy = (2.0 * dy) / circle_inner
	local sat = sqrt(dx * dx + dy * dy) -- / (circle_inner / 2)
	return hue, sat
end


--local function coords_h(x, y)
--	local s = circle_size + 2 * circle_border
--	local r = s - 6
--	local dx = x - ((s / 2) + 0.5)
--	local dy = y - ((s / 2) + 0.5)
--	local hue = -atan2(dx, dy) + angle_correction
--	dx = (2.0 * dx) / r
--	dy = (2.0 * dy) / r
--	local sat = sqrt(dx * dx + dy * dy)
--	return hue, sat
--end


---------------------------------------------------------------------------------------


function create_hue_sat_picker(el)
	el.width = circle_size
	el.height = circle_size
	el.drag_delta = nil
	
	function el.draw(self, _msg)
		oval(
			circle_border - 1, circle_border - 1,
			circle_border + circle_inner + 1, circle_border + circle_inner + 1,
			outline_color()
		)
		line(circle_size \ 2 - 12, circle_size \ 2, circle_size \ 2 + 12, circle_size \ 2, outline_color())
		line(circle_size \ 2, circle_size \ 2 - 12, circle_size \ 2, circle_size \ 2 + 12, outline_color())
--		fillp(0b0101101001011010)
--		rectfill(circle_size \ 2 - 24, circle_size \ 2, circle_size \ 2 + 24, circle_size \ 2, 7)
--		rectfill(circle_size \ 2, circle_size \ 2 - 24, circle_size \ 2, circle_size \ 2 + 24, 7)
--		fillp()
		for c = 0, 63 do
			if not hidden[c] and lum(c) != 0 then
				local x, y = hs_coords(c)
				pal(14, c)
				spr(11, x - 5, y - 5)
				pal(14, 14)
			end
		end
		if active_color and not hidden[active_color] then
			-- Triangular knob
			local ax, ay = h_coords(active_color, 6, 0.0)
			local bx, by = h_coords(active_color, 24, -0.008)
			local cx, cy = h_coords(active_color, 24, 0.008)
			pal(7, outline_color())
			line(ax, ay, bx, by, 7)
			line(bx, by, cx, cy, 7)
			line(cx, cy, ax, ay, 7)
			pal(7)
			-- Active dot
			local x, y = hs_coords(active_color)
			pal(7, outline_color())
			pal(14, active_color)
			spr(
				self.drag_delta and 13 or 12,
				x - 5, y - 5
			)
			pal(14, 14)
			pal(7, 7)
			if circling_anim_timer > 0 then
				local delta = math.floor(0.5 + 5 + 10 * circling_anim_timer * circling_anim_timer)
				oval(
					x - delta, y - delta,
					x + delta, y + delta,
					outline_color()
				)
			end
		end
		clip()
		pal(7, outline_color())
		spr(14, 0, 138)
		pal(7, 7)
	end	
	
	function el.hover(self, msg)
		self.cursor = 1
		if active_color and not hidden[active_color] then
			local h, r = coords_hs(msg.mx, msg.my)
			local dh = h - hue(active_color)
			if dh < -0.5 then dh += 1.0 end
			if
				r >= 1.02 and r <= 1.18
				and abs(dh) <= 0.01
			then
				self.cursor = "grab"
			else
				local ax, ay = hs_coords(active_color)
				if distance(ax, ay, msg.mx, msg.my) < 6 then
					self.cursor = "pointer"
				end
			end
		end
		-- In reverse order to prioritize colors on top
		for c = 63, 0, -1 do
			local cx, cy = hs_coords(c, self.ordinate)
			if distance(cx, cy, msg.mx, msg.my) < 5 and not hidden[c] and lum(c) != 0 then
				self.cursor = "pointer"
			end
		end
	end
	
	function el.click(self, msg)
		local h, r = coords_hs(msg.mx, msg.my)
		local active_hue = active_color and hue(active_color) or 0
		local dh = h - active_hue
		if dh < -0.5 then dh += 1.0 end
		if
			(active_color and not hidden[active_color])
			and r >= 1.02 and r <= 1.18
			and abs(dh) <= 0.01
		then
			undo_stack:checkpoint()
			mouselock(0x4|0x8, 1.0, 0.25)
			self.cursor = 0
			local ax, ay = h_coords(active_color, 10)
			self.knob_drag_delta = { ox = ax, oy = ay, x = 0, y = 0 }
			return true
		elseif active_color and not hidden[active_color] then
			local ax, ay = hs_coords(active_color)
			if distance(ax, ay, msg.mx, msg.my) < 6 then
				undo_stack:checkpoint()
				local ax, ay = hs_coords(active_color)
				mouselock(0x4|0x8, 1.0, 0.25)
				self.cursor = 0
				self.drag_delta = { ox = ax, oy = ay, x = 0, y = 0 }
				return true
			end
		end
		active_color = nil
		-- In reverse order to prioritize colors on top
		for c = 63, 0, -1 do
			local cx, cy = hs_coords(c)
			if distance(cx, cy, msg.mx, msg.my) < 5 and not hidden[c] and lum(c) != 0 then
				undo_stack:checkpoint()
				active_color = c
				local ax, ay = hs_coords(active_color)
				mouselock(0x4|0x8, 1.0, 0.25)
				self.cursor = 0
				self.drag_delta = { ox = ax, oy = ay, x = 0, y = 0 }
				return true
			end
		end
		self.knob_drag_delta = nil
		self.drag_delta = nil
		return true
	end
	
	function el.drag(self, msg)
		if not active_color then return end
		if locked[active_color] then
			padlock_flashing = true
			return
		end
		if self.knob_drag_delta then
			self.knob_drag_delta.x += msg.dx
			self.knob_drag_delta.y += msg.dy
			local ax = self.knob_drag_delta.ox + self.knob_drag_delta.x * 0.25
			local ay = self.knob_drag_delta.oy + self.knob_drag_delta.y * 0.25
			local hue, sat = coords_hs(ax, ay)
			change_color(active_color, hue, nil, nil)
		elseif self.drag_delta then
			self.drag_delta.x += msg.dx
			self.drag_delta.y += msg.dy
			local ax = self.drag_delta.ox + self.drag_delta.x * 0.25
			local ay = self.drag_delta.oy + self.drag_delta.y * 0.25
			local hue, sat = coords_hs(ax, ay)
			if msg.mb == 4 then hue = nil end
			if msg.mb == 2 then sat = nil end
			change_color(active_color, hue, sat, nil)
			return true
		end
	end
	
	function el.release(self, msg)
		send_palette()
		self.knob_drag_delta = nil
		self.drag_delta = nil
		padlock_flashing = false
		padlock_flashing_time = 0
		mouselock(false)
		self.cursor = 1
	end

	return el
end


-------------------------------------------------------------------------------------


function create_sat_lum_picker(el)
	el.width = square_size
	el.height = square_size
	el.drag_delta = nil
		
	function el.draw(self, _msg)
		rect(
			square_border - 1, square_border - 1, 
			square_border + square_inner + 1, square_border + square_inner + 1, 
			outline_color()
		)
		for c = 0, 63 do
			local dh = hue(c) - hue(active_color or 0)
			if dh < -0.5 then dh += 1.0 end
			if not hidden[c] and lum(c) != 0 then -- and abs(dh) <= 0.1 then
				local x, y = sl_coords(c)
				pal(14, c)
				spr(11, x - 5, y - 5)
				pal(14, 14)
			end
		end
		if active_color and not hidden[active_color] then
			local x, y = sl_coords(active_color)
			pal(7, outline_color())
			pal(14, active_color)
			spr(
				self.drag_delta and 13 or 12,
				x - 5, y - 5,
				x + 5, y + 5
			)
			pal(14, 14)
			pal(7, 7)
			if circling_anim_timer > 0 then
				local delta = math.floor(0.5 + 5 + 10 * circling_anim_timer * circling_anim_timer)
				oval(
					x - delta, y - delta,
					x + delta, y + delta,
					outline_color()
				)
			end
		end
		clip()
		pal(7, outline_color())
		spr(15, -11, self.height + 12 - 64)
		pal(7, 7)
	end	
	
	function el.hover(self, msg)
		self.cursor = 1
		if active_color and not hidden[active_color] then
			local ax, ay = sl_coords(active_color)
			if distance(ax, ay, msg.mx, msg.my) < 6 then
				self.cursor = "grab"
			end
		end
		-- In reverse order to prioritize colors on top
		for c = 63, 0, -1 do
			local cx, cy = sl_coords(c, self.ordinate)
			if distance(cx, cy, msg.mx, msg.my) < 5 and not hidden[c] and lum(c) != 0 then
				self.cursor = "pointer"
			end
		end
	end
	
	function el.click(self, msg)
		if active_color and not hidden[active_color] then
			local ax, ay = sl_coords(active_color)
			if distance(ax, ay, msg.mx, msg.my) < 6 then
				undo_stack:checkpoint()
				mouselock(0x4|0x8, 1.0, 0.25)
				self.cursor = 0
				self.drag_delta = { ox = ax, oy = ay, x = 0, y = 0 }
				return
			end
		end
		active_color = nil
		-- In reverse order to prioritize colors on top
		for c = 63, 0, -1 do
			local cx, cy = sl_coords(c)
			if distance(cx, cy, msg.mx, msg.my) < 5 and not hidden[c] and lum(c) != 0 then
				undo_stack:checkpoint()
				active_color = c
				local ax, ay = sl_coords(active_color)
				mouselock(0x4|0x8, 1.0, 0.25)
				self.cursor = 0
				self.drag_delta = { ox = ax, oy = ay, x = 0, y = 0 }
				return
			end
		end
		self.drag_delta = nil
	end
	
	function el.drag(self, msg)
		if (not active_color) return
		if (not self.drag_delta) return
		if locked[active_color] then
			padlock_flashing = true
		else
			self.drag_delta.x += msg.dx
			self.drag_delta.y += msg.dy
			local ax = self.drag_delta.ox + self.drag_delta.x * 0.25
			local ay = self.drag_delta.oy + self.drag_delta.y * 0.25
			local sat, lum = coords_sl(ax, ay)
			if msg.mb == 2 then sat = nil end
			if msg.mb == 4 then lum = nil end
			change_color(active_color, nil, sat, lum)
		end
	end
	
	function el.release(self, msg)
		send_palette()
		self.drag_delta = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end

	return el
end


------------------------------------------------------------------------------------


function create_sat_knob(el)
	el.width = square_size
	el.height = 9
	
	function el.draw(self, _msg)
		if active_color and not hidden[active_color] then
			local ax, _ = sl_coords(active_color)
			pal(7, outline_color())
			pal(13, 0)
			spr(5, ax - 4, 0)
			pal(13, 13)
			pal(7, 7)
		end
	end	
	
	function el.hover(self, msg)
		self.cursor = 1
		if active_color and not hidden[active_color] then
			local ax, _ = sl_coords(active_color)
			if msg.mx and msg.mx >= ax - 4 and msg.mx <= ax + 4 then
				self.cursor = "grab"
			end
		end
	end

	function el.click(self, msg)
		undo_stack:checkpoint()
		if active_color and not hidden[active_color] then
			local ax, _ = sl_coords(active_color)
			if msg.mx and msg.mx >= ax - 4 and msg.mx <= ax + 4 then
				mouselock(0x4|0x8, 1.0, 0.25)
				self.cursor = 0
				self.drag_delta = { ox = ax, x = 0 }
			end
		end
	end
	
	function el.drag(self, msg)
		if (not active_color) return
		if (not self.drag_delta) return
		if locked[active_color] then
			padlock_flashing = true
		else
			self.drag_delta.x += msg.dx
			local ax = self.drag_delta.ox + self.drag_delta.x * 0.25
			local sat, lum = coords_sl(ax, 0)
			change_color(active_color, nil, sat, nil)
		end
	end
	
	function el.release(self, msg)
		send_palette()
		self.drag_delta_x = nil
		padlock_flashing = false
		padlock_flashing_time = 0
		self.cursor = 1
		mouselock(false)
	end
			
	return el
end


--------------------------------------------------------------------------------


function create_lum_knob(el)
	el.width = 9
	el.height = square_size
	
	function el.draw(self, _msg)
		if active_color and not hidden[active_color] then
			local _, ay = sl_coords(active_color)
			pal(7, outline_color())
			pal(13, active_color)
			spr(6, 0, ay - 4)
			pal(13, 13)
			pal(7, 7)
		end
	end	
	
	function el.hover(self, msg)
		self.cursor = 1
		if active_color and not hidden[active_color] then
			local _, ay = sl_coords(active_color)
			if msg.my and msg.my >= ay - 4 and msg.my <= ay + 4 then
				self.cursor = "grab"
			end
		end
	end

	function el.click(self, msg)
		undo_stack:checkpoint()
		if active_color and not hidden[active_color] then
			local _, ay = sl_coords(active_color)
			if msg.my and msg.my >= ay - 4 and msg.my <= ay + 4 then
				mouselock(0x4|0x8, 1.0, 0.25)
				self.cursor = 0
				self.drag_delta = { ox = ax, oy = ay, x = 0, y = 0 }
			end
		end
	end
	
	function el.drag(self, msg)
		if (not active_color) return
		if (not self.drag_delta) return
		if locked[active_color] then
			padlock_flashing = true
		else
			self.drag_delta.y += msg.dy
			local ay = self.drag_delta.oy + self.drag_delta.y * 0.25
			local sat, lum = coords_sl(0, ay)
			change_color(active_color, nil, nil, lum)
		end
	end
	
	function el.release(self, msg)
		send_palette()
		self.drag_delta_y = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end
			
	return el
end

:: src/gui_palette.lua
--[[pod_format="raw",created="2025-02-28 10:09:19",modified="2025-10-20 09:34:46",revision=5256]]
function generate_palette_gui()
	gui.tap = function(self, msg) if (msg.has_pointer) active_color = nil end
	gui.mousewheel =
		function(self, msg)
			if not active_color then
				active_color = 0
			elseif msg.wheel_y < 0 then
				active_color = (active_color + 1) % 64
			elseif msg.wheel_y > 0 then
				active_color = (active_color - 1) % 64
			end
		end
		
	local pal_el = create_palette{ x = 17, y = 6 }
	gui:attach(pal_el)
	gui:attach(create_visibility_buttons { x = pal_el.x - 14, y = pal_el.y + 1 })
	gui:attach(create_color_preview { x = pal_el.x + pal_el.width + 8, y = pal_el.y })
	
	local x_buttons = 347
	gui:attach(create_action_button { x = x_buttons, y = 4, sprite = 16,
		act = function(self) undo_stack:undo(); update_hidden_toggles() end,
		active = function(self) return #(undo_stack.undo_stack) >= 1 end })
	gui:attach(create_action_button { x = x_buttons + 16 + 2, y = 4, sprite = 19,
		act = function(self) undo_stack:redo(); update_hidden_toggles() end,
		active = function(self) return #(undo_stack.redo_stack) >= 1 end })
	gui:attach(create_action_button { x = x_buttons, y = 4 + 16 + 2, sprite = 24,
		act = function(self) open_settings() end })
	gui:attach(create_action_button { x = x_buttons + 16 + 2, y = 4 + 16 + 2, sprite = 27,
		act = function(self) open_help() end })
	gui:attach(create_pickers_mode_switch { x = x_buttons, y = 41 })

	if pickers_mode == "circular_hue" then
		hide_color_band()
		gui:attach(create_hue_sat_picker { x = 0, y = 56 })
		local right = gui:attach(create_sat_lum_picker{ x = 196, y = 270 - 190 - 24, abscissa = "s" })
		gui:attach(create_sat_knob { x = right.x, y = right.y + right.height - 3 })
		gui:attach(create_lum_knob { x = right.x - 5, y = right.y })
	else
		if user_settings.show_color_band then
			show_color_band()
		else
			hide_color_band()
		end
		if user_settings.show_color_names then
			gui:attach(create_color_names { x = 11 + 7, y = 148 })
		end
		if user_settings.show_color_band then
			gui:attach(create_color_band { x = 11 + 7, y = 243 })
		end
		gui:attach(create_rectangle_picker { x = 11, y = 148, ordinate = "s" })
		-- Attach the bottom one last so it has priority for clicks. The two
		-- pickers have a slight overlap due to their borders, and black colors
		-- are difficult to grab otherwise.
		gui:attach(create_rectangle_picker { x = 11, y = 54 })
		gui:attach(create_val_knob { x = 6, y = 56, ordinate = "l" })
		gui:attach(create_val_knob { x = 6, y = 148, ordinate = "s" })
		gui:attach(create_hue_knob { x = 11, y = 243 })
		gui:attach(create_hue_scrubber { x = 174, y = 254 })
	end
	
	local is_hex = (pwf():ext() == "hex")
	gui:attach(create_test_zone { x = 390, y = 4, only_hex_tab = is_hex })	
end


-------------------------------------------------------------------------------


function change_hidden(c, hide)
	hidden[c] = hide
	update_hidden_toggles()
end


function update_hidden_toggles()
	local nb_columns <const> = 16
	for row = 0, 3 do
		local some_non_black = false
		local some_visible = false
		for column = 0, nb_columns - 1 do
			local c = (row * nb_columns) + column
			local is_black = color_code(c) == 0x000000
			if is_black then
				hidden[c] = false
			else
				some_non_black = true
			end
			if (c > 0) and (not is_black) and (not hidden[c]) then
				some_visible = true
			end
		end
		hidden_toggles[row] = some_non_black and (not some_visible)
	end
	dont_blink()
end


-----------------------------------------------------------------------------------


function create_palette(el)
	local size = 12
	local nb_columns = 16
	local nb_rows = 4
	el.width = (nb_columns * size) + 1
	el.height = (nb_rows * size) + 1
	el.cursor = "pointer"

	function el.draw(self, msg)
		clip()
		rect(0, 0, self.width, self.height, outline_color())
		for c = 0, 63 do
			local x = 1 + ((c % nb_columns) * size)
			local y = 1 + ((c \ nb_columns) * size)
			rectfill(x, y, x + size - 1, y + size - 1, c)
			if hidden[c] then
				ovalfill(x + 2, y + 2, x + size - 3, y + size - 3, bg_color)
			end
			if c == active_color then
				rect(
					x + 1, y + 1,
					x + size - 2, y + size - 2,
					contrast_color(active_color)
				)
			end
		end	
		if self.drag_pos then
			local col = (msg.mx - 1) \ size
			local row = (msg.my - 1) \ size
			local c = col + row * nb_columns
			if 0 <= c and c <= 63 then
				local x = 1 + col * size
				local y = 1 + row * size
				if c != active_color and not locked[c] then
					rect(x + 3, y + 3, x + size - 4, y + size - 4, contrast_color(c))
				end
			end
			local mx, my = self.drag_pos.x, self.drag_pos.y
			rectfill(mx, my, mx + 8, my + 8, active_color)		
		end
	end

	function el.click(self, msg)
		local col = min(nb_columns - 1, (msg.mx - 1) \ size)
		local row = min(nb_rows - 1, (msg.my - 1) \ size)
		local c = col + row * nb_columns
		if msg.mb == 1 then
			self.previous_active = active_color
			active_color = c
			self.click_pos = { x = msg.mx, y = msg.my }
		elseif msg.mb == 2 then
			change_hidden(c, not hidden[c])
		end
	end
	
	function el.drag(self, msg)
		if self.click_pos and not self.drag_pos then
			local dx = abs(self.click_pos.x - msg.mx)
			local dy = abs(self.click_pos.y - msg.my)
			if dx > 1 or dy > 1 then
				if locked[active_color] then
					padlock_flashing = true
				else
					self.drag_pos = {}
				end
			end
		end
		if self.drag_pos then
			self.drag_pos = { x = msg.mx, y = msg.my }
		end
	end
	
	function el.release(self, msg)
		if self.drag_pos then
			local col = (msg.mx - 1) \ size
			local row = (msg.my - 1) \ size
			local c = col + row * nb_columns
			if 0 <= c and c <= 63 and not locked[c] then
				undo_stack:checkpoint()
--				swap_colors(active_color, c)
				reorder_palette({ [active_color] = c, [c] = active_color })
				active_color = c
				send_palette()
			end			
		end
		self.click_pos = nil
		self.drag_pos = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end

	function el.tap(self, msg)
		if active_color and color_code(active_color) == 0x000000
			or active_color == self.previous_active
		then
			circling_anim_timer = 1.0
			self.previous_active = nil
		end
	end

	return el
end


local blink_anim <const> = { [0] = 40, 41, 42, 43, 43, 43, 42, 41, 40 }


function create_visibility_buttons(el)
	local size = 12
	local nb_rows = 4
	el.width = size
	el.height = nb_rows * size
	el.cursor = "pointer"

	function el.draw(self, msg)
		pal(7, outline_color())
		for row = 0, 3 do
			if hidden_toggles[row] then
				spr(43, 0, row * size)
			else
				local sprite = 40
				if blink_timer <= 0 and blink_eye == row then
					sprite = blink_anim[- blink_timer] 
				end
				spr(sprite, 0, row * size)
			end
		end
		pal(7, 7)
	end
	
	function el.update(self, msg)
		if not user_settings.dont_blink then
			blink_timer -= 1
			if blink_timer <= -9 then
				blink_timer = 180 + math.random(1, 6) * 90
				local nb_eyes = active_color and 4 or 3
				blink_eye = math.random(0, nb_eyes)
				if hidden_toggles[blink_eye] then
					blink_eye = math.random(0, nb_eyes)
				end
			end
		end
	end
	
	function el.tap(self, msg)
		local row = mid(0, msg.my \ size, 3)
		local action = not hidden_toggles[row]
		for c = row * 16, row * 16 + 15 do
			change_hidden(c, action)
		end
		dont_blink()
	end
	
	return el
end


function dont_blink()
	local all_eyes_closed = true
	for i = 0, 3 do
		if not hidden_toggles[i] then all_eyes_closed = false end
	end
	if all_eyes_closed then
		crying_a_timer = 46
	end
end


function blinked()
	if user_settings.no_jump_scares or crying_a_done then
		return
	end
	pal(1, 0)
	if crying_a_timer > 20 then
		spr(254, 0, 0)
	elseif crying_a_timer > 0 then
		spr(255, 0, -16)
	end
	pal(1, 1)
end


------------------------------------------------------------------------------


function create_color_preview(el)
	local size = 12
	el.width = size * 4 + 2 + 120
	el.height = size * 4 + 2

	gui:new(el)

	-- Input field for the color code
	el:attach(create_field {
		x = 5, y = el.height - 12,
		width = 40, height = 9,
		small_font = false,
		get_fg = function(self) return contrast_color(active_color or 0) end,
		get = function(self)
			if (not active_color) return ""
			return "#" .. color_hex(active_color)
		end,
		set = function(self, str)
			if (locked[active_color]) return
			str = str:gsub("%s", ""):gsub("#", "")
			if (#str ~= 6) return
			local code = tonum("0x" .. str)
			if (type(code) ~= "number") return
			undo_stack:checkpoint()
			change_color_code(active_color, code)
		end,
		update = function(self, msg)
			self.hidden = active_color == nil
		end
	})

	-- Input field for hue
	el:attach(create_field {
		x = 98, y = 20,
		width = 21, height = 7,
		small_font = true,
		get_fg = function(self) return outline_color() end,
		get = function(self)
			if (not active_color) return ""
			local h = hue(active_color) * 360.0
			while h < 0.0 do
				h += 360.0
			end
			return string.format("%3.0f\031", h)
		end,
		set = function(self, str)
			if (locked[active_color]) return
			str = str:gsub("%s", ""):gsub("\031", "")
			local h = tonum(str)
			if (type(h) ~= "number") return
			h = (h % 360.0) / 360.0
			undo_stack:checkpoint()
			change_color(active_color, h, nil, nil)
		end,
		update = function(self, msg)
			self.hidden = active_color == nil
		end
	})

	-- Input field for saturation
	el:attach(create_field {
		x = 98, y = 30,
		width = 21, height = 7,
		small_font = true,
		get_fg = function(self) return outline_color() end,
		get = function(self)
			if (not active_color) return ""
			local s = sat(active_color) * 100.0
			return string.format("%3.0f%%", s)
		end,
		set = function(self, str)
			if (locked[active_color]) return
			str = str:gsub("%s", ""):gsub("%%", "")
			local s = tonum(str)
			if (type(s) ~= "number") return
			s = s / 100.0
			undo_stack:checkpoint()
			change_color(active_color, nil, s, nil)
		end,
		update = function(self, msg)
			self.hidden = active_color == nil
		end
	})

	-- Input field for luminance
	el:attach(create_field {
		x = 98, y = 40,
		width = 21, height = 7,
		small_font = true,
		get_fg = function(self) return outline_color() end,
		get = function(self)
			if (not active_color) return ""
			local l = lum(active_color) * 100.0
			return string.format("%3.0f%%", l)
		end,
		set = function(self, str)
			if (locked[active_color]) return
			str = str:gsub("%s", ""):gsub("%%", "")
			local l = tonum(str)
			if (type(l) ~= "number") return
			l = l / 100.0
			undo_stack:checkpoint()
			change_color(active_color, nil, nil, l)
		end,
		update = function(self, msg)
			self.hidden = active_color == nil
		end
	})

	-- Container callbacks

	function el.draw(self, msg)
		if active_color then
			rectfill(1, 1, self.height - 2, self.height - 2, active_color)
			print(string.format("%d", active_color), 4, 4, contrast_color(active_color))
			pal(7, outline_color())
			if locked[active_color] then
				if padlock_flashing_time % 18 < 10 then
					spr(2, self.height + 4, 1)
				end
			else
				spr(1, self.height + 4, 1)
			end
			if hidden[active_color] then
				spr(43, self.height + 4 + size, 1)
			else
				local sprite = 40
				if blink_timer <= 0 and blink_eye == 4 then
					sprite = blink_anim[- blink_timer] 
				end
				spr(sprite, self.height + 4 + size, 1)
			end
			if bg_color == active_color then
				spr(10, self.height + 4 + 2 * size, 1)
			else
				spr(9, self.height + 4 + 2 * size, 1)
			end
			pal(7, 7)
			local hue = hue(active_color) * 360.0
			while hue < 0.0 do
				hue += 360.0
			end
			print("\014hue:        ", self.height + 3, 21, outline_color())
			print("\014saturation: ", self.height + 3, 31)
			print("\014lightness:  ", self.height + 3, 41)
		else
			print("\^pOkPal" .. "\^-p\014\|o " .. okpal_version, 24, 16, outline_color())
			if env().sandbox then
				print("\014    " .. env().sandbox .. " sandbox", 24, 34)
			end
		end
	end
	
	function el.tap(self, msg)
		if (not active_color) return
		if msg.mx < self.height or msg.my > size then
			return
		elseif msg.mx < self.height + 4 + size then
			locked[active_color] = not locked[active_color]
		elseif msg.mx < self.height + 4 + 2 * size then
			change_hidden(active_color, not hidden[active_color])
		elseif msg.mx < self.height + 4 + 3 * size then
			if key("shift") and bg_color != active_color then
				whitest_color = active_color
			elseif key("ctrl") then
				blackest_color = active_color
			elseif bg_color == active_color then
				bg_color = blackest_color
			else
				bg_color = active_color
			end
		end
	end
	
	function el.hover(self, msg)
		if msg.has_pointer and msg.mx >= self.height + 4 and msg.mx <= self.height + 4 + 3 * size and msg.my <= size then
			self.cursor = "pointer"
		else
			self.cursor = 1
		end
	end
	
	return el
end


---------------------------------------------------------------------------------


function create_pickers_mode_switch(el)
	el.width = get_spr(36):width()
	el.height = get_spr(36):height()
	el.cursor = "pointer"
	function el.draw(self, msg)
		pal(7, outline_color())
		spr(pickers_mode == "circular_hue" and 36 or 37, 0, 0)
		pal(7)
	end
	function el.tap(self, msg)
		if pickers_mode == "circular_hue" then
			pickers_mode = "linear_hue"
		else
			pickers_mode = "circular_hue"
		end
		gui_changed = true
	end
	return el
end


---------------------------------------------------------------------------------


function create_test_zone(el)
	el.width = (24 + 4) * 3
	el.height = 12 + (24 + 4) * 8 + 15
	el.cursor = "pointer"
	el.cubes = {}
	el.ramps = nil
	
	gui:new(el)
	
	if el.only_hex_tab then
		el.ramps = el:attach(create_test_hex { x = 0, y = 0 })
	else
		for i = 0, 2 do
			for j = 0, 7 do
				el.cubes[#el.cubes + 1] =
					el:attach(create_test_cube { x = i * 28, y = 12 + j * 28, test_id = i + 3 * j })
			end
		end
		
		el.ramps = el:attach(create_test_ramps { x = 0, y = 12, hidden = test_mode ~= "ramps" })
	
		el:attach(
			create_action_button {
				x = 54, y = 238, sprite = 32,
				act =
					function(self)
						undo_stack:checkpoint()
						if test_mode == "cubes" then
							clear_cube_colors()
						elseif test_mode == "ramps" then
							clear_ramp_colors()
						end
					end 
			}
		)
	end

	function el.draw(self, msg)
		if self.only_hex_tab then return end
		pal(7, outline_color())
		if test_mode == "cubes" then
			spr(34, 0, 0)
		elseif test_mode == "ramps" then
			spr(35, 0, 0)
		end
		pal(7, 7)
	end
	
	function el.click(self, msg)
		if self.only_hex_tab then return end
		if msg.my > 12 then
			return
		end
		if test_mode == "cubes" and msg.mx > 33 then
			test_mode = "ramps"
			for c in all(self.cubes) do
				c.hidden = true
			end
			self.ramps.hidden = false
		elseif test_mode == "ramps" and msg.mx < 33 then
			test_mode = "cubes"
			for c in all(self.cubes) do
				c.hidden = false
			end
			self.ramps.hidden = true
		end
	end
	
	return el
end


function create_test_cube(el)
	el.width = 24 + 4
	el.height = 24 + 4
	el.hidden = test_mode ~= "cubes"

	function el.draw(self, msg)
		local colors = test_cube_colors[self.test_id]
		pal(10, colors[1])
		pal(9, colors[2])
		pal(25, colors[3])
		spr(8, 2, 2)
		pal(10, 10)
		pal(9, 9)
		pal(25, 25)
	end
	
	function el.hover(self, msg)
		if msg.mx > 2 and msg.my > 2 and msg.mx < self.width - 2 and msg.my < self.height - 2 then
			el.cursor = "crosshair"
		else
			el.cursor = 1
		end
	end
	
	function el.click(self, msg)
		local face = 2
		if msg.mx > self.width - 10 or msg.my < 10 then
			if msg.mx > self.height - msg.my then
				face = 3
			else
				face = 1
			end
		end
		if msg.mb == 1 then
			undo_stack:checkpoint()
			test_cube_colors[self.test_id][face] = active_color or 1
		elseif msg.mb == 2 then
			active_color = test_cube_colors[self.test_id][face]
		end
	end
	
	return el
end


function create_test_ramps(el)
	el.width = (24 + 4) * 3
	el.height = (24 + 4) * 8
	
	function el:square_of(x, y)
		if x < 2 or x > self.width - 2 or y <= 4 or y >= self.height - 4 then
			return nil, nil
		end
		local i = mid(0, (x - 2) // 8, 9)
		local j = mid(0, (y - 4) // 8, 26)
		return i, j
	end

	function el.draw(self, msg)
		for i = 0, 9 do
			for j = 0, 26 do
				local x = 2 + i * 8
				local y = 4 + j * 8
				local c = test_ramp_colors:get(i, j)
				rectfill(x, y, x + 7, y + 7, c)
			end
		end
		local i, j = self:square_of(msg.mx, msg.my)
		if i then
			local x = 2 + i * 8
			local y = 4 + j * 8
			local c = test_ramp_colors:get(i, j)
			if c == 0 then
				rect(x, y, x + 7, y + 7, contrast_color(c))
			end
		end
	end
	
	function el.hover(self, msg)
		local i, j = self:square_of(msg.mx, msg.my)
		if i then
			el.cursor = "crosshair"
		else
			el.cursor = 1
		end
	end
	
	function el.click(self, msg)
		local  i, j = self:square_of(msg.mx, msg.my)
		if (not i) return
		if msg.mb == 1 then
			undo_stack:checkpoint()
			test_ramp_colors:set(i, j, active_color)
		elseif msg.mb == 2 then
			active_color = mid(0, test_ramp_colors:get(i, j), 63)
		elseif msg.mb == 4 then
			test_ramp_colors:set(i, j, 0)
		end
	end

	return el
end


function create_test_hex(el)
	el.width = (24 + 4) * 3
	el.height = (24 + 4) * 8 + 30
	el.cursor = 1
	function el:draw(msg)
		print("\014hex file", 26, 4, outline_color())
		local last_color = 63
		while last_color > 1 and color_code(last_color) == 0 do
			last_color -= 1
		end
		for c = 0, 63 do
			local x = (c < 32) and 6 or 46
			local y = 16 + (c % 32) * 7
			rectfill(x + 1, y + 1, x + 5, y + 5, c)
			if c <= last_color then
				print("\014" .. color_hex(c), x + 9, y + 1, outline_color())
			else
				print("\014......", x + 9, y + 1, outline_color())
			end
		end
	end
	return el
end
:: src/gui_settings.lua
--[[pod_format="raw",created="2025-02-28 11:31:28",modified="2025-10-20 09:34:46",revision=1871]]
function open_settings()
	local el = open_modal(220, 170, true)
	el:attach(create_label { x = 90, y = 6, label = "Settings", fg = bg_color })
	
	if key("shift") then
		el:attach(create_checkbox {
			x = 10, y = 30,
			label = "Don't blink!",
			fg = bg_color,
			get = function(self) return user_settings.dont_blink end,
			toggle = function(self) change_settings { dont_blink = not user_settings.dont_blink } end,
		})
		el:attach(create_checkbox {
			x = 10, y = 50,
			label = "No jump scares",
			fg = bg_color,
			get = function(self) return user_settings.no_jump_scares end,
			toggle = function(self) change_settings { no_jump_scares = not user_settings.no_jump_scares } end,
		})
	
	else
		el:attach(create_checkbox {
			x = 10, y = 30,
			label = "Send palette to sprite and map editors",
			fg = bg_color,
			get = function(self) return user_settings.send_palette end,
			toggle = function(self) change_settings { send_palette = not user_settings.send_palette } end,
		})
		el:attach(create_checkbox {
			x = 10, y = 50,
			label = "Show color names",
			fg = bg_color,
			get = function(self) return user_settings.show_color_names end,
			toggle = function(self) change_settings { show_color_names = not user_settings.show_color_names } end,
		})
		el:attach(create_checkbox {
			x = 120, y = 50,
			label = "Show color band",
			fg = bg_color,
			get = function(self) return user_settings.show_color_band end,
			toggle =
				function(self)
					change_settings { show_color_band = not user_settings.show_color_band }
				end,
		})
		-- TODO: As of Picotron 0.2.0c, this doesn't seem to work anymore?
		--[[
		el:attach(create_checkbox {
			x = 10, y = 70,
			label = "EXPERIMENTAL: Open in GFX workspace",
			fg = bg_color,
			is_default_app = get_default_app("hex") == env().argv[0],
			get = function(self) return user_settings.open_in_gfx_workspace end,
			toggle =
				function(self)
					change_settings { open_in_gfx_workspace = not user_settings.open_in_gfx_workspace }
				end,
		})
		]]
		el:attach(create_checkbox {
			x = 10, y = 70,
			label = "Default app for \".pal\" files",
			fg = bg_color,
			is_default_app = get_default_app("pal") == env().argv[0],
			get = function(self) return self.is_default_app end,
			toggle =
				function(self)
					self.is_default_app = not self.is_default_app
					set_default_app("pal", self.is_default_app)
				end,
		})
		el:attach(create_checkbox {
			x = 10, y = 90,
			label = "Default app for \".hex\" files",
			fg = bg_color,
			is_default_app = get_default_app("hex") == env().argv[0],
			get = function(self) return self.is_default_app end,
			toggle =
				function(self)
					self.is_default_app = not self.is_default_app
					set_default_app("hex", self.is_default_app)
				end,
		})
	end
	
	el:attach(create_button {
		x = 170, y = 150,
		label = "Close",
		fg = bg_color,
		act = function() close_modal() end,
	})
end
:: src/integration.lua
--[[pod_format="raw",created="2025-03-08 09:24:27",modified="2025-10-20 09:34:46",revision=838]]
-- Copy and paste ----------------------------------------------------------------


function copy_color()
	if active_color then
		set_clipboard("#" .. color_hex(active_color))
	end
end


function cut_color()
	if active_color then
		set_clipboard("#" .. color_hex(active_color))
		if not locked[active_color] then
			 undo_stack:checkpoint()
			change_color_code(active_color, 0x000000)
			change_hidden(active_color, true)
		end
	end
end


function paste_color()
	if not active_color then
		notify("unable to paste: no selected color")
		return
	end
	if locked[active_color] then
		notify("unable to paste: selected color is locked")
		return
	end
	local cb = get_clipboard()
	if type(cb) == "string" then
		local hex = string.gsub(cb, "%s", "")
		if sub(hex, 1, 1) == "#" then
			hex = sub(hex, 2, -1)
		end
		local code = tonumber("0x" .. hex)
		if type(code) == "number" then
			undo_stack:checkpoint()
			change_color_code(active_color, code)
			change_hidden(active_color, false)
		else
			notify("unable to paste: unrecognized string: \"" .. cb .."\"")
		end
	else
		notify("unable to paste: type not supported (" .. type(cb) .. ")")
	end
end


---------------------------------------------------------------------------------------------


function get_default_app(extension)
	if fstat("/system/util/default_app.lua") ~= "file" then
		return "(unknown)"
	end

	local default_apps = fetch("/appdata/system/default_apps.pod") or {}
	return default_apps[extension] or "(none)"
end


function set_default_app(extension, value)
	local okpal_path = env().argv[0]

	-- Prevent registering the wrong path when
	-- developing OkPal.
	if okpal_path == "/system/apps/terminal.lua" then
		return
	end
	
	local defaults = fetch("/appdata/system/default_apps.pod")
	if type(defaults) ~= "table" then return end
	if value then
		defaults[extension] = okpal_path
		notify("OkPal registered as default app for \"."..extension.."\" files")
	else
		defaults[extension] = nil
		notify("Cleared default app for \"."..extension.."\" files")
	end
	store("/appdata/system/default_apps.pod", defaults)
end


-----------------------------------------------------------------------------


function send_palette()
	if not user_settings.send_palette then
		return
	end
	
	local palette = userdata("i32", 64)
	for c = 0, 63 do
		palette:set(c, color_code(c))
	end
	
	-- Updating the PID lists as we're sending the event
	-- to not miss new processes.
	for pid in all(find_gfx_map_pids()) do
		send_message(pid, { event = "set_palette", palette = palette })
	end
end


-- From Eiyeron's fork #eyn_okpal_fork-0
function find_gfx_map_pids()
	local matching_pids = {}
	for process in all(fetch "/ram/system/processes.pod") do
		local name <const> = process.name
		if name == "gfx" or name == "map" then
			matching_pids[#matching_pids + 1] = process.id
		end
	end
	return matching_pids
end


-- Drag-and-drop ------------------------------------------------------------------


function handle_drop_items(msg)
	for i = 1, #msg.items do
		local item = msg.items[i]
		if item.pod_type == "file_reference" and item.attrib == "file" then
--			undo_stack:checkpoint()
--			send_message(pid(), { event = "open_file", filename = item.fullpath })
		local okpal_path = env().argv[0]
		-- Prevent registering the wrong path when
		-- developing OkPal.
		if okpal_path == "/system/apps/terminal.lua" then
			return
		end
		create_process(
			okpal_path,
			{
				argv = { item.fullpath },
			}
		)
		end
	end
end

:: src/oklab.lua
--[[pod_format="raw",created="2024-03-31 09:08:26",modified="2025-10-20 09:34:46",revision=1194]]
-- Copyright(c) 2021 Bjorn Ottosson
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of
-- this software and associated documentation files(the "Software"), to deal in
-- the Software without restriction, including without limitation the rights to
-- use, copy, modify, merge, publish, distribute, sublicense, and /or sell copies
-- of the Software, and to permit persons to whom the Software is furnished to do
-- so, subject to the following conditions:
--
-- The above copyright noticeand this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

oklab = {}
oklab.__index = oklab

function oklab.color_to_okhsl(code)
	local srgb = {
		r = ((code & 0xff0000) >> 16) / 255,
		g = ((code & 0x00ff00) >> 8) / 255,
		b = ((code & 0x0000ff)) / 255,
	}
	return oklab.srgb_to_okhsl(srgb)
end

function oklab.okhsl_to_color(okhsl)
	local srgb = oklab.okhsl_to_srgb(okhsl)
	local r = mid(0x00, math.floor(srgb.r * 255 + 0.5), 0xff)
	local g = mid(math.floor(srgb.g * 255 + 0.5), 0xff)
	local b = mid(math.floor(srgb.b * 255 + 0.5), 0xff)
	return (r << 16) | (g << 8) | b
end

function oklab.new()
    local inst = setmetatable({}, oklab)
    return inst
end

-- Finds the maximum saturation possible for a given hue that fits in sRGB
-- Saturation here is defined as S = C/L
-- a and b must be normalized so a^2 + b^2 == 1
function oklab.compute_max_saturation(a, b)
    if a ~= 0.0 or b ~= 0.0 then
    	-- Max saturation will be when one of r, g or b goes below zero.
        -- Select different coefficients depending on which component goes below zero first

        -- Blue component (default)
        local k0 = 1.35733652
        local k1 = -0.00915799
        local k2 = -1.1513021
        local k3 = -0.50559606
        local k4 = 0.00692167
        local wl = -0.0041960863
        local wm = -0.7034186147
        local ws = 1.707614701

        if -1.88170328 * a - 0.80936493 * b > 1 then
            -- Red component
            k0 = 1.19086277
            k1 = 1.76576728
            k2 = 0.59662641
            k3 = 0.75515197
            k4 = 0.56771245
            wl = 4.0767416621
            wm = -3.3077115913
            ws = 0.2309699292
        elseif 1.81444104 * a - 1.19445276 * b > 1 then
            -- Green component
            k0 = 0.73956515
            k1 = -0.45954404
            k2 = 0.08285427
            k3 = 0.1254107
            k4 = 0.14503204
            wl = -1.2684380046
            wm = 2.6097574011
            ws = -0.3413193965
        end

        -- Approximate max saturation using a polynomial:
        local S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b

        -- Do one step Halley's method to get closer
        -- this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite
        -- this should be sufficient for most applications, otherwise do two/three steps

        local k_l = 0.3963377774 * a + 0.2158037573 * b
        local k_m = -0.1055613458 * a - 0.0638541728 * b
        local k_s = -0.0894841775 * a - 1.291485548 * b

        do
            local l_ = 1.0 + S * k_l
            local m_ = 1.0 + S * k_m
            local s_ = 1.0 + S * k_s

            local l = l_ * l_ * l_
            local m = m_ * m_ * m_
            local s = s_ * s_ * s_

            local l_dS = 3.0 * k_l * l_ * l_
            local m_dS = 3.0 * k_m * m_ * m_
            local s_dS = 3.0 * k_s * s_ * s_

            local l_dS2 = 6.0 * k_l * k_l * l_
            local m_dS2 = 6.0 * k_m * k_m * m_
            local s_dS2 = 6.0 * k_s * k_s * s_

            local f = wl * l + wm * m + ws * s
            local f1 = wl * l_dS + wm * m_dS + ws * s_dS
            local f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2

            local s_denom = f1 * f1 - 0.5 * f * f2
            if s_denom ~= 0.0 then  S = S - f * f1 / s_denom end
        end

        return S
    else
        return 0.0
    end
end

-- finds L_cusp and C_cusp for a given hue
-- a and b must be normalized so a^2 + b^2 == 1
function oklab.find_cusp(a, b)
	-- First, find the maximum saturation (saturation S = C/L)
    local S_cusp = oklab.compute_max_saturation(a, b)

    -- Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:
    local rgb_at_max = oklab.oklab_to_linear_srgb({L = 1, a = S_cusp * a, b = S_cusp * b })
    local max_comp = math.max(rgb_at_max.r, rgb_at_max.g, rgb_at_max.b)
    if max_comp ~= 0.0 then
        local L_cusp = (1.0 / max_comp) ^ 0.3333333333333333
        return { L = L_cusp, C = L_cusp * S_cusp }
    else
        return { L = 0.0, C = 0.0 }
    end
end

-- Finds intersection of the line defined by
-- L = L0 * (1 - t) + t * L1
-- C = t * C1
-- a and b must be normalized so a^2 + b^2 == 1
function oklab.find_gamut_intersection(a, b, L1, C1, L0, x)
    -- Find the cusp of the gamut triangle
    local cusp = x or oklab.find_cusp(a, b)

    -- Find the intersection for upper and lower half separately
    local t = 0.0
    if ((L1 - L0) * cusp.C - (cusp.L - L0) * C1) <= 0.0 then
        -- Lower half
        local t_denom = C1 * cusp.L + cusp.C * (L0 - L1)
        if t_denom ~= 0.0 then t = cusp.C * L0 / t_denom end
    else
        -- Upper half
        -- First intersect with triangle
        local t_denom = C1 * (cusp.L - 1.0) + cusp.C * (L0 - L1)
        if t_denom ~= 0.0 then t = cusp.C * (L0 - 1.0) / t_denom end

        -- Then one step Halley's method
        do
            local dL = L1 - L0
            local dC = C1

            local k_l = 0.3963377774 * a + 0.2158037573 * b
            local k_m = -0.1055613458 * a - 0.0638541728 * b
            local k_s = -0.0894841775 * a - 1.291485548 * b

            local l_dt = dL + dC * k_l
            local m_dt = dL + dC * k_m
            local s_dt = dL + dC * k_s

            -- If higher accuracy is required, 2 or 3 iterations of the following block can be used:
            do
                local L = L0 * (1.0 - t) + t * L1
				local C = t * C1

				local l_ = L + C * k_l
				local m_ = L + C * k_m
				local s_ = L + C * k_s

				local l = l_ * l_ * l_
				local m = m_ * m_ * m_
				local s = s_ * s_ * s_

				local ldt = 3.0 * l_dt * l_ * l_
				local mdt = 3.0 * m_dt * m_ * m_
				local sdt = 3.0 * s_dt * s_ * s_

				local ldt2 = 6.0 * l_dt * l_dt * l_
				local mdt2 = 6.0 * m_dt * m_dt * m_
				local sdt2 = 6.0 * s_dt * s_dt * s_

                local r0 = 4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s - 1
				local r1 = 4.0767416621 * ldt - 3.3077115913 * mdt + 0.2309699292 * sdt
				local r2 = 4.0767416621 * ldt2 - 3.3077115913 * mdt2 + 0.2309699292 * sdt2

                local r_denom = r1 * r1 - 0.5 * r0 * r2
                local u_r = 0.0
                if r_denom ~= 0.0 then u_r = r1 / r_denom end
				local t_r = -r0 * u_r

                local g0 = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s - 1
				local g1 = -1.2684380046 * ldt + 2.6097574011 * mdt - 0.3413193965 * sdt
				local g2 = -1.2684380046 * ldt2 + 2.6097574011 * mdt2 - 0.3413193965 * sdt2

                local g_denom = g1 * g1 - 0.5 * g0 * g2
                local u_g = 0.0
                if g_denom ~= 0.0 then u_g = g1 / g_denom end
				local t_g = -g0 * u_g

                local b0 = -0.0041960863 * l - 0.7034186147 * m + 1.707614701 * s - 1
				local b1 = -0.0041960863 * ldt - 0.7034186147 * mdt + 1.707614701 * sdt
				local b2 = -0.0041960863 * ldt2 - 0.7034186147 * mdt2 + 1.707614701 * sdt2

                local b_denom = (b1 * b1 - 0.5 * b0 * b2)
                local u_b = 0.0
                if b_denom ~= 0.0 then u_b = b1 / b_denom end
				local t_b = -b0 * u_b

                if u_r < 0.0 then t_r = 3.40282347e+38 end
                if u_g < 0.0 then t_g = 3.40282347e+38 end
                if u_b < 0.0 then t_b = 3.40282347e+38 end

                t = t + math.min(t_r, t_g, t_b)
            end
        end
    end

    return t
end

function oklab.get_Cs(L, a_, b_)
    local cusp = oklab.find_cusp(a_, b_)
    local C_max = oklab.find_gamut_intersection(a_, b_, L, 1.0, L, cusp)
    local ST_max = oklab.to_ST(cusp)

    -- Scale factor to compensate for the curved part of gamut shape:
    local k = 0.0
    local k_denom = math.min(L * ST_max.S, (1.0 - L) * ST_max.T)
    if k_denom ~= 0.0 then k = C_max / k_denom end

    local C_mid = 0.0
    do
        local ST_mid = oklab.get_ST_mid(a_, b_)

        -- Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.
        local C_a = L * ST_mid.S
        local C_b = (1.0 - L) * ST_mid.T

        local cae4 = C_a * C_a * C_a * C_a
        local cbe4 = C_b * C_b * C_b * C_b
        C_mid = 0.9 * k * ((1.0 / (1.0 / cae4 + 1.0 / cbe4)) ^ 0.25)
    end

    local C_0 = 0.0
    do
        -- for C_0, the shape is independent of hue, so ST are constant. Values picked to roughly be the average values of ST.
        local C_a = L * 0.4
        local C_b = (1.0 - L) * 0.8

        -- Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.
        local cae2 = C_a * C_a
        local cbe2 = C_b * C_b
        C_0 = math.sqrt(1.0 / (1.0 / cae2 + 1.0 / cbe2))
    end

    return { C_0 = C_0, C_mid = C_mid, C_max = C_max }
end

-- Returns a smooth approximation of the location of the cusp
-- This polynomial was created by an optimization process
-- It has been designed so that S_mid < S_max and T_mid < T_max
function oklab.get_ST_mid(a_, b_)
    local S = 0.11516993
    local s_denom = 7.4477897 + 4.1590124 * b_
        + a_ * (-2.19557347 + 1.75198401 * b_
        + a_ * (-2.13704948 - 10.02301043 * b_
        + a_ * (-4.24894561 + 5.38770819 * b_ + 4.69891013 * a_)))
    if s_denom ~= 0.0 then
        S = 0.11516993 + 1.0 / s_denom
    end

    local T = 0.11239642
    local t_denom = 1.6132032 - 0.68124379 * b_
        + a_ * (0.40370612 + 0.90148123 * b_
        + a_ * (-0.27087943 + 0.6122399 * b_
        + a_ * (0.00299215 - 0.45399568 * b_ - 0.14661872 * a_)))
	if t_denom ~= 0.0 then
        T = 0.11239642 + 1.0 / t_denom
    end

	return { S = S, T = T }
end

function oklab.linear_srgb_to_oklab(c)
    local l = 0.4122214708 * c.r
            + 0.5363325363 * c.g
            + 0.0514459929 * c.b
	local m = 0.2119034982 * c.r
            + 0.6806995451 * c.g
            + 0.1073969566 * c.b
	local s = 0.0883024619 * c.r
            + 0.2817188376 * c.g
            + 0.6299787005 * c.b

    local l_ = l ^ 0.3333333333333333
    local m_ = m ^ 0.3333333333333333
    local s_ = s ^ 0.3333333333333333

    return {
        L = 0.2104542553 * l_
          + 0.793617785 * m_
          - 0.0040720468 * s_,
        a = 1.9779984951 * l_
          - 2.428592205 * m_
          + 0.4505937099 * s_,
        b = 0.0259040371 * l_
          + 0.7827717662 * m_
          - 0.808675766 * s_ }
end

function oklab.okhsl_to_oklab(hsl)
	local l = hsl.l
    if l >= 1.0 then return { L = 1.0, a = 0.0, b = 0.0 } end
    if l <= 0.0 then return { L = 0.0, a = 0.0, b = 0.0 } end

    local s = hsl.s
    if s < 0.0 then s = 0.0 end
    if s > 1.0 then s = 1.0 end

    local h = hsl.h
    local h_rad = h * 6.283185307179586
    local a_ = math.cos(h_rad)
    local b_ = math.sin(h_rad)
    local L = oklab.toe_inv(l)

    local cs = oklab.get_Cs(L, a_, b_)
    local C_0 = cs.C_0
	local C_mid = cs.C_mid
	local C_max = cs.C_max

    local mid = 0.8
	local mid_inv = 1.25

    local C = 0.0
    local t = 0.0
    local k_0 = 0.0
    local k_1 = 0.0
    local k_2 = 0.0
    if s < mid then
        t = mid_inv * s

		k_1 = mid * C_0
        if C_mid ~= 0.0 then
		    k_2 = 1.0 - k_1 / C_mid
        end

        local k_denom = 1.0 - k_2 * t
		if k_denom ~= 0.0 then
            C = t * k_1 / k_denom
        end
    else
        local t_denom = 1.0 - mid
        if t_denom ~= 0.0 then
            t = (s - mid) / t_denom
        end

		k_0 = C_mid
        if C_0 ~= 0.0 then
		    k_1 = (1.0 - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0
        end

        local C_denom = C_max - C_mid
		k_2 = 1.0
        if C_denom ~= 0.0 then
            k_2 = 1.0 - k_1 / C_denom
        end

        local k_denom = 1.0 - k_2 * t
        if k_denom ~= 0.0 then
		    C = k_0 + t * k_1 / k_denom
        end
    end

    return {
        L = L,
        a = C * a_,
        b = C * b_ }
end

function oklab.okhsl_to_srgb(hsl)
    return oklab.oklab_to_srgb(oklab.okhsl_to_oklab(hsl))
end

function oklab.okhsv_to_oklab(hsv)
	local v = hsv.v
    if v <= 0.0 then return { L = 0.0, a = 0.0, b = 0.0 } end
    if v > 1.0 then v = 1.0 end

    local s = hsv.s
    if s < 0.0 then s = 0.0 end
    if s > 1.0 then s = 1.0 end

    local h = hsv.h
    local h_rad = h * 6.283185307179586
    local a_ = math.cos(h_rad)
    local b_ = math.sin(h_rad)

    local cusp = oklab.find_cusp(a_, b_)
	local ST_max = oklab.to_ST(cusp)
	local S_max = ST_max.S
	local T_max = ST_max.T
	local S_0 = 0.5
    local k = 1.0
    if S_max ~= 0.0 then
	    k = 1.0 - S_0 / S_max
    end

    -- first we compute L and V as if the gamut is a perfect triangle:

	-- L, C when v==1:
    local v_denom = S_0 + T_max - T_max * k * s
    local L_v = 1.0
    local C_v = 0.0
    if v_denom ~= 0.0 then
        L_v = 1.0 - s * S_0 / v_denom
	    C_v = s * T_max * S_0 / v_denom
    end

    local L = v * L_v
	local C = v * C_v

    --then we compensate for both toe and the curved top part of the triangle:
    local L_vt = oklab.toe_inv(L_v)
    local C_vt = 0.0
    if L_v ~= 0.0 then
        C_vt = C_v * L_vt / L_v
    end

    local L_new = oklab.toe_inv(L)
    if L ~= 0.0 then
        C = C * L_new / L
    end
    L = L_new

    local rgb_scale = oklab.oklab_to_linear_srgb({
        L = L_vt,
        a = a_ * C_vt,
        b = b_ * C_vt })
    local max_comp = math.max(
        rgb_scale.r,
        rgb_scale.g,
        rgb_scale.b, 0.0)
    local scale_L = 0.0
    if max_comp ~= 0.0 then
        scale_L = (1.0 / max_comp) ^ 0.3333333333333333
    end

	C = C * scale_L
    return {
        L = L * scale_L,
        a = C * a_,
        b = C * b_ }
end

function oklab.okhsv_to_srgb(hsv)
    return oklab.oklab_to_srgb(oklab.okhsv_to_oklab(hsv))
end

function oklab.oklab_to_linear_srgb(lab)
    local l_ = lab.L
        + 0.3963377774 * lab.a
        + 0.2158037573 * lab.b
	local m_ = lab.L
        - 0.1055613458 * lab.a
        - 0.0638541728 * lab.b
	local s_ = lab.L
        - 0.0894841775 * lab.a
        - 1.291485548 * lab.b

    local l = l_ * l_ * l_
    local m = m_ * m_ * m_
    local s = s_ * s_ * s_

    return {
        r = 4.0767416621 * l
          - 3.3077115913 * m
          + 0.2309699292 * s,
        g = -1.2684380046 * l
           + 2.6097574011 * m
           - 0.3413193965 * s,
        b = -0.0041960863 * l
           - 0.7034186147 * m
           + 1.707614701 * s }
end

function oklab.oklab_to_okhsl(lab)
    local L = lab.L
    if L >= 1.0 then return { h = 0.0, s = 0.0, l = 1.0 } end
    if L <= 0.0 then return { h = 0.0, s = 0.0, l = 0.0 } end

    local Csq = lab.a * lab.a + lab.b * lab.b
    if Csq > 0.0 then
        local C = math.sqrt(Csq)
        local a_ = lab.a / C
        local b_ = lab.b / C

        -- 1.0 / math.pi = 0.3183098861837907
        local h = 0.5 + 0.5 * math.atan(-lab.b, -lab.a) * 0.3183098861837907

        local cs = oklab.get_Cs(L, a_, b_)
        local C_0 = cs.C_0
        local C_mid = cs.C_mid
        local C_max = cs.C_max

        -- Inverse of the interpolation in okhsl_to_srgb:
        local mid = 0.8
        local mid_inv = 1.25

        local s = 0.0
        if C < C_mid then
            local k_1 = mid * C_0
            local k_2 = 1.0
            if C_mid ~= 0.0 then
                k_2 = (1.0 - k_1 / C_mid)
            end

            local t_denom = k_1 + k_2 * C
            local t = 0.0
            if t_denom ~= 0.0 then
                t = C / t_denom
            end

            s = t * mid
        else
            local k_0 = C_mid
            local k_1 = 0.0
            if C_0 ~= 0.0 then
                k_1 = (1.0 - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0
            end

            local C_denom = C_max - C_mid
            local k_2 = 1.0
            if C_denom ~= 0.0 then
                k_2 = 1.0 - k_1 / C_denom
            end

            local t_denom = k_1 + k_2 * (C - k_0)
            local t = 0.0
            if t_denom ~= 0.0 then
                t = (C - k_0) / t_denom
            end

            s = mid + (1.0 - mid) * t
        end

        return { h = h, s = s, l = oklab.toe(L) }
    else
        return { h = 0.0, s = 0.0, l = L }
    end
end

function oklab.oklab_to_okhsv(lab)
    local L = lab.L
    if L >= 1.0 then return { h = 0.0, s = 0.0, v = 1.0 } end
    if L <= 0.0 then return { h = 0.0, s = 0.0, v = 0.0 } end

    local Csq = lab.a * lab.a + lab.b * lab.b
    if Csq > 0.0 then
        local C = math.sqrt(Csq)
        local a_ = lab.a / C
        local b_ = lab.b / C

        -- 1.0 / math.pi = 0.3183098861837907
        local h = 0.5 + 0.5 * math.atan(-lab.b, -lab.a) * 0.3183098861837907

        local cusp = oklab.find_cusp(a_, b_)
        local ST_max = oklab.to_ST(cusp)
        local S_max = ST_max.S
        local T_max = ST_max.T
        local S_0 = 0.5
        local k = 1.0
        if S_max ~= 0.0 then
            k = 1.0 - S_0 / S_max
        end

        -- first we find L_v, C_v, L_vt and C_vt
        local t_denom = C + L * T_max
        local t = 0.0
        if t_denom ~= 0.0 then
            t = T_max / t_denom
        end
        local L_v = t * L
        local C_v = t * C

        local L_vt = oklab.toe_inv(L_v)
        local C_vt = 0.0
        if L_v ~= 0.0 then
            C_vt = C_v * L_vt / L_v
        end

        -- we can then use these to invert the step that compensates for the toe and the curved top part of the triangle:
        local rgb_scale = oklab.oklab_to_linear_srgb({
            L = L_vt,
            a = a_ * C_vt,
            b = b_ * C_vt })
        local scale_denom = math.max(
            rgb_scale.r,
            rgb_scale.g,
            rgb_scale.b, 0.0)
        local scale_L = 0.0
        if scale_denom ~= 0.0 then
            scale_L = (1.0 / scale_denom) ^ 0.3333333333333333
            L = L / scale_L
            C = C / scale_L
        end

        local toel = oklab.toe(L)
        C = C * toel / L
        L = toel

        -- we can now compute v and s:
        local v = 0.0
        if L_v ~= 0.0 then v = L / L_v end

        local s = 0.0
        local s_denom = ((T_max * S_0) + T_max * k * C_v)
        if s_denom ~= 0.0 then
            s = (S_0 + T_max) * C_v / s_denom
        end

        return { h = h, s = s, v = v }
    else
        return { h = 0.0, s = 0.0, v = L }
    end
end

function oklab.oklab_to_srgb(lab)
    local lrgb = oklab.oklab_to_linear_srgb(lab)
	return {
		r = oklab.srgb_transfer_function(lrgb.r),
		g = oklab.srgb_transfer_function(lrgb.g),
		b = oklab.srgb_transfer_function(lrgb.b) }
end

function oklab.srgb_to_okhsl(rgb)
    return oklab.oklab_to_okhsl(oklab.srgb_to_oklab(rgb))
end

function oklab.srgb_to_okhsv(rgb)
    return oklab.oklab_to_okhsv(oklab.srgb_to_oklab(rgb))
end

function oklab.srgb_to_oklab(srgb)
    return oklab.linear_srgb_to_oklab({
		r = oklab.srgb_transfer_function_inv(srgb.r),
		g = oklab.srgb_transfer_function_inv(srgb.g),
		b = oklab.srgb_transfer_function_inv(srgb.b) })
end

function oklab.srgb_transfer_function(a)
    if 0.0031308 >= a then
        return 12.92 * a
    else
        return 1.055 * (a ^ 0.4166666666666667) - 0.055
    end
end

function oklab.srgb_transfer_function_inv(a)
    if 0.04045 < a then
        return ((a + 0.055) * 0.9478672985781991) ^ 2.4
    else
        return a * 0.07739938080495357
    end
end

function oklab.to_ST(cusp)
	local L = cusp.L
    local C = cusp.C
    if L ~= 0.0 and L ~= 1.0 then
        return { S = C / L, T = C / (1.0 - L) }
    elseif L ~= 0.0 then
        return { S = C / L, T = 0.0 }
    elseif L ~= 1.0 then
        return { S = 0.0, T = C / (1.0 - L) }
    else
        return { S = 0.0, T = 0.0 }
    end
end

function oklab.toe(x)
    local y = 1.170873786407767 * x - 0.206
	return 0.5 * (y + math.sqrt(y * y + 0.14050485436893204 * x))
end

function oklab.toe_inv(x)
    local denom = 1.170873786407767 * (x + 0.03)
    if denom ~= 0.0 then
    	return (x * x + 0.206 * x) / denom
    else
        return 0.0
    end
end

return oklab
:: src/palette.lua
--[[pod_format="raw",created="2024-03-31 08:27:10",modified="2025-10-20 09:34:46",revision=4486]]
------------------------------------------------------------------------------------------


function color_code(c)
	return peek4(0x5000 + 4 * c)
end


function poke_color_code(c, code)
	poke4(0x5000 + 4 * c, code)
end


function copy_palette()
	return userdata("u32", 64):peek(0x5000)
end


function poke_palette(mem)
	mem:poke(0x5000)
end


---------------------------------------------------------------------------------------


function color_hex(c)
	return string.format("%06x", color_code(c))
end


----------------------------------------------------------------------------------------


local palette = {}


function hue(c)
	return palette[c].h
end


function sat(c)
	return palette[c].s
end


function lum(c)
	return palette[c].l
end


function color_component(c, name)
	return palette[c][name]
end


function copy_palette_hsl()
	return copy(palette)
end


function restore_palette_hsl(hsl)
	palette = hsl
end


local function code_to_hsl(code)
	local hsl = oklab.color_to_okhsl(code)
	if code == 0x000000 then
		hsl.s = 1.0
	end
	return hsl
end


function rebuild_palette(c)
	for c = 0, 63 do
		local code = color_code(c)
		-- TODO: something more subtle? only update the hsl values
		-- if they don't result in the same color code?
		palette[c] = code_to_hsl(color_code(c))
	end
end


function change_color_code(c, code)
	poke_color_code(c, code)
	palette[c] = code_to_hsl(color_code(c))
end


function change_color(c, hue, sat, lum)
	local hsl = {
		h = hue or palette[c].h,
		s = sat or palette[c].s,
		l = lum or palette[c].l,
	}
	hsl.h = hsl.h % 1.0
	hsl.s = mid(0.0, hsl.s, 1.0)
	hsl.l = mid(0.0, hsl.l, 1.0)
	palette[c] = hsl
	local code = oklab.okhsl_to_color(hsl)
	poke_color_code(c, code)
	return
end


-- TODO: remove
--[=[
function swap_colors(c1, c2)
	palette[c1], palette[c2] = palette[c2], palette[c1]
	local a, b = color_code(c1), color_code(c2)
	poke_color_code(c1, b)
	poke_color_code(c2, a)
end


function reorder___palette(new_order)
	local new_palette = {}
	local new_codes = {}
	local unassigned = {}
	for c = 0, 63 do table.insert(unassigned, c) end
	for c = 0, 63 do
		local old_c = new_order[c]
		if old_c then
			new_palette[c] = palette[old_c]
			new_codes[c] = color_code(old_c)
			del(unassigned, old_c)
		end
	end
	local next = table.remove(unassigned, 1)
	for c = 0, 63 do
		if not new_palette[c] then
			new_palette[c] = palette[next]
			new_codes[c] = color_code(next)
			next = table.remove(unassigned, 1)
		end
	end
	palette = new_palette
	for c = 0, 63 do
		poke_color_code(c, new_codes[c])
	end
end
]=]


function reorder_palette(mapping)
	local new_palette = {}
	local new_codes = {}
	for c = 0, 63 do
		local new_c = mapping[c]
		if new_c then
			new_palette[new_c] = palette[c]
			new_codes[new_c] = color_code(c)
		end
	end
	local unassigned = 0
	for c = 0, 63 do
		if not new_palette[c] then
			while mapping[unassigned] do
				unassigned += 1
			end
			mapping[unassigned] = c
			new_palette[c] = palette[unassigned]
			new_codes[c] = color_code(unassigned)
		end
	end
	for i = 0, #test_cube_colors do
		local cube = test_cube_colors[i]
		cube[1] = mapping[cube[1]]
		cube[2] = mapping[cube[2]]
		cube[3] = mapping[cube[3]]
	end
	local width, height = test_ramp_colors:width(), test_ramp_colors:height()
	for x = 0, width - 1 do
		for y = 0, height - 1 do
			local new_c = mapping[test_ramp_colors:get(x, y)]
			test_ramp_colors:set(x, y, new_c)
		end
	end
	palette = new_palette
	for c = 0, 63 do
		poke_color_code(c, new_codes[c])
	end
end


function clear_colors()
	for c = 0, 63 do
		local code, lum
		if c == 7 then
			code = 0xffffff
			lum = 1.0
		else
			code = 0x000000
			lum = 0.0
		end
		palette[c] = { h = 0.0, s = 0.0, l = lum }
		poke_color_code(c, code)
		locked[c] = (c == 0) or (c == 7)
		hidden[c] = false
		clear_cube_colors()
		clear_ramp_colors()
	end
	for row = 0, 3 do hidden_toggles[row] = false end
	bg_color = 0
	blackest_color = 0
	whitest_color = 7
end


function reset_picotron_colors()
	for c = 0, 31 do
		code = peek4(0x5000 + 4 * (64 + c))
		poke_color_code(c, code)
		palette[c] = code_to_hsl(code)
		if c <= 31 then
			locked[c] = true
		end
	end
	bg_color = 0
	blackest_color = 0
	whitest_color = 7
end


function restore_default_palette()
	for c = 0, 63 do
		code = peek4(0x5000 + 4 * (64 + c))
		poke_color_code(c, code)
		palette[c] = code_to_hsl(code)
		if c <= 31 then
			locked[c] = true
		end
	end
	bg_color = 0
	blackest_color = 0
	whitest_color = 7
end


--------------------------------------------------------------------------------


function clear_cube_colors()
	for i = 0, #test_cube_colors - 1 do
		test_cube_colors[i] = { 1, 1, 1 }
	end
end


function clear_ramp_colors()
	for i = 0, test_ramp_colors:width()-1 do
		for j = 0, test_ramp_colors:height()-1 do
			test_ramp_colors:set(i, j, bg_color)
		end
	end
end


----------------------------------------------------------------------------------


function find_blackest_and_whitest()
	local min_lum = 1.0
	local best_black = 0
	local max_lum = 0.0
	local best_white = 1
	for c = 0, 63 do
		if palette[c].l < min_lum then
			best_black = c
			min_lum = palette[c].l
		end
		if palette[c].l > max_lum then
			best_white = c
			max_lum = palette[c].l
		end
	end
	return best_black, best_white
end


----------------------------------------------------------------------------------------
:: src/remap.lua
--[[pod_format="raw",created="2024-04-04 07:28:50",modified="2025-10-20 09:34:46",revision=1300]]
-- Color remapping ---------------------------------------------------------------


-- assumes `palette` is up to date
function remap_colors()
	local new_pal_code = {}
	local picotron_okhsl = {}
	local remaining_pico_c = {}
	local remaining_new_c = { 0 }
	for pico_c = 0, 31 do
		local code = peek4(0x5000 + 4 * (64 + pico_c))
		picotron_okhsl[pico_c] = oklab.color_to_okhsl(code)
		add(remaining_pico_c, pico_c)
	end	
	for c = 1, 63 do
		if color_code(c) != 0x000000 then
			add(remaining_new_c, c)
		end
	end

		
	-- Choose colors 0 (black) and 7 (white) first
	local best_black, best_white = find_blackest_and_whitest()
	new_pal_code[0] = color_code(best_black)
	del(remaining_pico_c, 0)
	del(remaining_new_c, best_black)
	new_pal_code[7] = color_code(best_white)
	del(remaining_pico_c, 7)
	del(remaining_new_c, best_white)
		
	-- Find best match for the other colors
	local deltas = {}
	for c = 0, 63 do
		deltas[c] = {}
		for pico_c = 0, 31 do
			local delta_sat = sat(c) - picotron_okhsl[pico_c].s
			local delta_lum = lum(c) - picotron_okhsl[pico_c].l
			-- TODO: should ignore hue if sat or lum is low
			local delta_hue = hue(c) - picotron_okhsl[pico_c].h
			if delta_hue > 360.0 then
				delta_hue -= 360.0
			elseif delta_hue < -360.0 then
				delta_hue += 360.0
			end

			delta_hue *= 2.0 * picotron_okhsl[pico_c].s * sat(c)
			delta_sat *= 0.5

			deltas[c][pico_c] =
				math.sqrt(
					(delta_hue * delta_hue)
					+ (delta_sat * delta_sat)
					+ (delta_lum * delta_lum)
				)
		end
	end
	
	while #remaining_pico_c > 0 and #remaining_new_c > 0  do
		local min_delta = 1000.0
		local match_c = nil
		local match_pico_c = nil
		for i = 1, #remaining_new_c do
			local c = remaining_new_c[i]
			for j = 1, #remaining_pico_c do
				local pico_c = remaining_pico_c[j]
				local d = deltas[c][pico_c]
				if d and d < min_delta then
					min_delta = d
					match_c = c
					match_pico_c = pico_c
				end
			end
		end
		if match_c then
			new_pal_code[match_pico_c] = color_code(match_c)
			del(remaining_new_c, match_c)
			del(remaining_pico_c, match_pico_c)
		end
	end

	-- Add remaining colors
	for i = 1, #remaining_new_c do
		local c = remaining_new_c[i]
		local dest = 1
		while new_pal_code[dest] do
			dest += 1
		end
		new_pal_code[dest] = color_code(c)
		dest += 1
	end
	
	for c = 0, 63 do
		poke_color_code(c, new_pal_code[c] or 0x000000)
	end
	rebuild_palette()
	blackest_color = 0
	whitest_color = 7
	bg_color = 0
end

:: src/settings.lua
--[[pod_format="raw",created="2025-03-07 18:22:46",modified="2025-10-20 09:34:46",revision=747]]
local settings_folder = "/appdata/okpal/"
local settings_filepath = "/appdata/okpal/settings.pod"


function load_settings()
	mkdir(settings_folder)
	local s = fetch(settings_filepath)
	if s then
		for k, v in pairs(user_settings) do
			if type(s[k]) ~= "nil" then
				user_settings[k] = s[k]
			end
		end
	end
end


function change_settings(t)
	for k, v in pairs(t) do
		user_settings[k] = v
	end
	store(settings_filepath, user_settings)
end

:: src/soft_wrap.lua
--[[pod_format="raw",created="2025-03-07 11:09:14",modified="2025-10-20 09:34:46",revision=673]]
-- Soft-wraps a very tiny subset of markdown.
-- This code is absolutely horrible, but kind of work.
function soft_wrap(text, width)
	local space_width <const> = print(" ", -1000, -1000) + 1000
	local lines = {}
	local line = ""
	local x = 0
	local indentation = 0 -- indentation of the current paragraph

	local function add_word(word)
		if word == "" then return end
		local dx = print(word, -1000, -1000) + 1000
		if x + space_width + dx >= width then
			add(lines, line)
			line = ""
			x = 0
			for i = 1, indentation do
				line ..= " "
				x += space_width
			end
			line ..= word
			x += dx
		else
			if line:find("^%s*$") then
				line ..= word
				x += dx
			else
				line ..= " " .. word
				x += space_width + dx
			end
		end
	end
	
	local function add_line()
		add(lines, line)
		line = ""
		x = 0
	end
	
	local in_paragraph = false
	local in_code = false
	local ignore_word = false
	local ignore_line = false
	add_line()
	for hard_line in text:gmatch("([^\n]*)\n?") do
		ignore_line = false
		ignore_word = false
		if hard_line:find("^%s*$") then
			if in_paragraph then
				add_line()
				add_line()
				in_paragraph = false
				indentation = 0
			end
		elseif hard_line:find("^%s*- ") then
			if in_paragraph then
				add_line()
			end
			add_word("-")
			indentation = 2
			in_paragraph = true
			ignore_word = true
		elseif hard_line:find("^```%s*$") then
			if line ~= "" then
				add_line()
			end
			in_code = not in_code
			ignore_line = true
		else
			in_paragraph = true
 		end
 		
 		if not ignore_line then
	 		if in_code then
	 			line = hard_line
	 			add_line()
	 		else
				for word in hard_line:gmatch("([^%s]*)%s?") do
					if ignore_word then
						ignore_word = false
					else
						add_word(word)
					end
				end
			end
		end
	end
	add_line()
	
	return lines
end
:: todo.txt
--[[pod_format="raw",created="2024-03-31 20:08:43",modified="2025-10-20 09:34:46",revision=1531]]
- Fix: remap colors doesn't remap the test cubes and test ramps...
- Fix: undo after remapping doesn't reset blackest and whitest colors...
- Change: color icon for .pal files, maybe even
  a preview of the actual palette?
- Change: default_folder when sandboxed?
- Add: A 3D cube overview of the palette...
- Add: hold shift for fine-tuning colors.
- Add: on import, show number of colors.
- Add: setting for dragging sensibility.
- Add: "Ctrl-D" for duplicating current color.

Maybe:
- Add: new tab in test zone to show all hex codes
  and copy a ".hex" export to the clipboard?
- in-app gui for manual?
- multi-selection (ability to move a group of
  colors in the sliders)
- editing tools for multi-selection;
- Add another tab in the test zone for statistics?
- remove locking mechanism?
- import the palette from an image saved by
  the #paint cartridge;

:: [eoc]
