picotron cartridge // www.picotron.net
version 2

:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA3Iixtb2RpZmllZD0iMjAyNS0w
My0wNyAxNToxNTo0NyIscmV2aXNpb249NTQ2NV1dbHo0AHwGAADfQQAA9iN7WzBdPXtibXA9cHh1
AEMgCAgEcLcgRyAXIEcgt3AsZmxhZ3M9MCxwYW5feD0tMS44MwEAETcXABB5FwAnNDICAKcsem9v
bT0xMX0sWQDxCAwMBDAncAcgB2AHoAegB5BnQGdAJwAnBAA7Z-ALagBGNi4xNgEAFDNpADcwLjMB
ACIyN2oAHDdpACPwDGoAPyAHUGgAS-8SN2BXQHcgFwAXAAcAFxAHEDcQByAHEBcQB0AHMAdgN-AM
cAA7YC0HcAcQB9wAH1BiAEDxBgkJBDAHYAcNB0AHLQcgB00HAAdtFwIASwcAZwBoABMwWgASMEoA
HDhKAFEANzAHPUYAMRAHXUoAAAYAAA4AXz0HMDcwTgAcKRBHkAAhF21MAD8gRxBIABn-ChgYBPAo
2oDaDxlw2h5g2i5Q2j5A2k4w2V4DAAT-Ak5A2T5Q2S5g2R5w2Q6A2fAobQALDfAC-wjwGwewB7AH
UGcwBwBHQAcQJ1AHIAfwDLMAGQdGAAHxAU8AByAHSgAj8wILCwQgR0AHTgcgB24HAAeOFwIAzwcA
B24HIAdOB0BHIFAAHHPQTkBuII4QAgBfIG5ATtBCABlUQEAE8P8BANG-B-AuJ-AsR-AtB-AvAwAa
MAkAFTADAPIGF1AH8CknIBfwK1fwLRfwLgfwWwcAAgBTJ-AlBwACADHwJycJAFUX8CYHABQAUAcA
BxAXKAAN2wRTNS41NzWwAGIxMy4xNzW1AB81tQABELOAARIrVABCK0fwaw8A8QIgB-AsJ-BtN-Ar
B-AvR-BrRyMAVfAtR-BsFAABKgASRy0AACEAMRfwLioAcS8H8Cs38HDsAE0rR-DtEAGSLwdAB1AX
ACcA1wASJwIAsBAXABfQB0AXMAcg2wBFBxAHAAIAAYwEAxAAMMCHIC4AAhAAOBcQJxwAb-ADF1AH
AD8ACmLwAwdAFxAVACUXACEAMRAnABYAH6BOASRbEBAE8PA8AEQwLjEyOgACDAAPXgMA8A4QEAQQ
tyAHsAcAB9AX0BdQRyAXQCcQFxAXMCcwBwYAkWAXEGdAFyBHUAwA-wBAB3AX0BfQBwAHsAcgtxBy
ACfxBNcA9xdAlyAXEHcgNwB3IKdgl0AVAD8ZANdYACglBwACAJEwB7AH8AAX8AYOADEgF0DzA0Bw
BwAHxgARsBYAUQAHQBcgCAATsBgAQPAIF-AOAAAhBAWeAQ9YATAAQAFAEBcQJ-wBsTAnMBdgJzAX
QGcQcAEADAA-cAdAWAE2thRAlxAXIIcANyDHWAEfFlgBPREDDgAxUBcQMAMAugAAxgARsBYAABsE
AgkDE7AYAC-wBVgBNy-w8DkAXQTKASFQF8YBAgIAAGUB43cgFyAnECcgFwA3MDcABgACEgAAHAAA
JAAEAgARUBIBD94BLhNnVABAV5BncH4AMVcwNwIAEFdyAENwZ5BXnAAeZ-ABDykBWFTQFzBXMAkB
8wMXMBcgF4AXIBdwFzAXYBdAF1ACABLQBgAP9QIyMAVQhwIBYRA3ENcQxwIAf9cQ9w4Q9wcIASsP
OQCToBkLBBD3BSAH8AViBiAHF1oGAKYGMQAXIKADAAIABJgDARAALxcQHAACFiAWBwEQACDwB1AA
XwUHIPcFQwEVHzCZAAGQ9wcA9w0QBwAnbQBHEGcAJ2cAEld9Bw0YACdnEJsAXwD3DAD3hwAn9AVU
DARQ9wdA9wjwD-cJIAfwCAfwDgkAsg33CwAH8AoH8AxH5wQBHwFjNwAHMCcAQwFVIAfwC0eZAAAy
CCJnQAoAFAcWAENQB-AKIwAAgQMwIEdAYwEDIwhAMAfwCecAEwcCADhHAFcIBUAAB0AHegYTZ50B
IAcQ6AoHAgAQIKkJggf3EfAMB-AGBwA7BfdECgFmLTcuMzc1pgwuNDcrAgoLAZQH8AcHIPcK8A4J
AEANB-AJawFC8AwHMJwIA5sBMgBHIJkAYicQN-ALByMJEwAuASJQVwoAFAAWADRn8AojAACMBDEn
MFdEAAEbAWQgR-AJB0AqAAH7ABUwQAAEHQEg8AhYBgKMAioXQB8AwicQZ-AHB-AM9xHwBgcADwsB
EQ9vAy4fMDoAqA9gDxMPWwAmTyNXMJdRADoBnA_PJzAnIAcANwBPADQO6w8PvAEkDzoA--------
--------------------------------------------------------EFA9MTB9fQ==
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Iixtb2RpZmllZD0iMjAyNS0w
My0wNyAxNToxNTo0OCIsc3RvcmVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Il1d
:: map/
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Iixtb2RpZmllZD0iMjAyNS0w
My0wNyAxNToxNTo0NyIscmV2aXNpb249NTE3OV1dbHo0AGkAAABYEAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD--------------------78QgiKSxoaWRkZW49ZmFsc2UscGFuX3g9
MAgAwnk9MCx0aWxlX2g9OAkA4Hc9OCx6b29tPTAuNX19
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Iixtb2RpZmllZD0iMjAyNS0w
My0wNyAxNToxNTo0OCIsc3RvcmVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Il1d
:: sfx/
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA3Iixtb2RpZmllZD0iMjAyNS0w
My0wNyAxNToxNTo0NyIscmV2aXNpb249NTExNV1dbHo0ABEBAABSCAAA8CdweHUAAygAAAQABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDBAUGBwAP-5AICQoLDwwPDQ8ODw8QAPAADQ8RDxIPEw8UDxUP
Fg8XEwDxAQ8YDxkPGg8bDxwPHQ8eDx8UAPEAIA8hDyIPIw8kDyUPJg8nFADxACgPKQ8qDysPLA8t
Dy4PLxQA8QAwDzEPMg8zDzQPNQ82DzcUAP8FOA85DzoPOw88Dz0PPg8-AA--8P8BAOv-J1oBEAYP
IBABIAEgAfAAAhACDBABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDDAA-zkf-wEA
3L-4D0AADUD--7DwcAoA--9kH-8BAP_ZUP----8g
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Iixtb2RpZmllZD0iMjAyNS0w
My0wNyAxNToxNTo0OCIsc3RvcmVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Il1d
:: src/
:: src/globals.lua
--[[pod_format="raw",created="2024-04-03 09:15:53",modified="2025-03-07 15:15:47",revision=3247]]
current_import_choice = "dont_clobber"

undo_stack = nil

padlock_flashing = false
padlock_flashing_time = 0

gui = nil

is_new_file = false
imported_hex_file = nil


blink_timer = 180 + math.random(1, 6) * 90
blink_eye = math.random(0, 3)

-- Saved in undo stack ----------------------------------------------------------


pal_okhsl = {}
pal_code = {}

-- and also `test_cube_colors`? or not?


-- Saved in metadata --------------------------------------------------------------


okpal_version = "1.1.0"

active_color = nil
bg_color = 0 -- TODO: what about fg?
blackest_color = 0 -- TODO: remove?
whitest_color = 7 -- TODO: remove?

hidden_toggles = {}
hidden = {}
locked = {}
for i = 0, 63 do locked[i] = i <= 32 end

test_mode = "cubes"
test_cube_colors = nil
test_ramp_colors = nil


-- Constants ----------------------------------------------------------------------


default_test_cube_colors = {
	[0] = 
	{15, 31, 4},
	{31, 4, 20},
	{4, 20, 21},
	--
	{10, 9, 25},
	{9, 25, 24},
	{8, 24, 2},
	--
	{26, 11, 27},
	{11, 27, 3},
	{27, 3, 19},
	--
	{28, 17, 19},
	{28, 12, 16},
	{12, 16, 1},
	--
	{6, 29, 13},
	{29, 13, 18},
	{13, 18, 1},
	--
	{7, 23, 14},
	{23, 14, 13},
	{14, 30, 18},
	--
	{7, 6, 22},
	{6, 22, 5},
	{22, 5, 21},
	--
	{1, 1, 1},
	{1, 1, 1},
	{1, 1, 1},
	--
}

default_test_ramp_colors = userdata("u8", 10, 27, 0)
default_test_ramp_colors:set(
	0, 0,
	 0, 24,  8, 25,  9, 10, 26, 11, 27,  0,
	 6,  0,  0,  0,  0,  0,  0,  0,  3,  0, 
	22,  0,  0,  0,  0,  0,  0,  0, 19,  0, 
	 5,  0,  0,  0,  0,  0,  0,  0,  1,  0, 
	13,  0,  0,  0,  0,  0,  0,  0, 16,  0, 
	29,  0,  0,  0,  0,  0,  0,  0, 17,  0, 
	23,  0,  0,  0,  0,  0,  0,  0, 12,  0, 
	14,  0,  0,  0,  0,  0,  0,  0, 28,  0, 
	30, 18,  2, 21, 20,  4, 31, 15,  7,  0,
	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	 0, 20,  4, 31, 15,  8, 24,  2,  0,  0,
	21,  5, 22,  6,  7, 23, 14, 30,  0,  0,
	 1, 16, 17, 12, 28, 29, 13, 18,  0,  0,
	19,  3, 27, 11, 26, 10,  9, 25,  0,  0
)


:: src/gui.lua
--[[pod_format="raw",created="2024-03-31 05:58:06",modified="2025-03-07 15:15:47",revision=6667]]
function generate_gui()
	gui = create_gui()
	generate_palette_gui()
end


-----------------------------------------------------------------------------------


local modal = nil


function open_modal(width, height, autoclose)
	if modal ~= nil then
		--TODO: !!!
		return
	end
	
	modal = gui:attach {
		x = 0, y = 0,
		width = gui.width, height = gui.height,
		autoclose = autoclose or false,
		draw = function(self)
			poke(0x550b, 0x3f)
			---fillp(0b0101101001011010)
			---fillp(0b0001001001001000)
			---fillp(0b1110110110110111)
			fillp(0b0011011011001001)
			rectfill(0, 0, self.width - 1, self.height - 1, 61)
			fillp()
			poke(0x550b, 0x00)
		end,
		click = function(self, msg)
			if msg.has_pointer and self.autoclose then
				close_modal()
			end
		end
	}
	local el = modal:attach {
		x = (modal.width - width) // 2, y = (modal.height - height) // 2,
		width = width, height = height,
		draw = function(self)
			clip()
			rect(-3, -3, self.width+3, self.height+3, bg_color)
			rectfill(-2, -2, self.width+2, self.height+2, outline_color())
			rect(-1, -1, self.width+1, self.height+1, bg_color)
		end,
	}
	return el
end


function has_modal()
	return modal ~= nil
end


function close_modal()
	if modal then
		modal:detach()
	end
	modal = nil
end



-----------------------------------------------------------------------------------


function create_label(el)
	el.width = el.width or (5 * #el.label + 4)
	el.height = el.height or 9
	gui:new(el)
	function el:draw()
		print(el.label, 0, 0, el.fg or outline_color())
	end
	return el
end


-----------------------------------------------------------------------------------


function create_button(el)
	local label = el.label or "---"
	el.width = el.width or (#label * 5 + 8 + 8)
	el.height = el.height or 16
	el.cursor = "pointer"

	function el:draw(msg)
		local fg = self.fg or bg_color
		line(2, 0, self.width - 3, 0, fg)
		pset(1, 1, fg)
		line(2, self.height - 1, self.width - 3, self.height - 1, fg)
		pset(self.width - 2, 1, fg)
		line(0, 2, 0, self.height - 3, fg)
		pset(1, self.height - 2, fg)
		line(self.width - 1, 2, self.width - 1, self.height - 3, fg)
		pset(self.width - 2, self.height - 2, fg)
		local pressed = msg.has_pointer and self.clicked
		if pressed then
			rectfill(1, 1, self.width - 2, self.height - 2, fg)
		end
		print(self.label or "---", 9, 4, pressed and outline_color() or fg)
	end
	
	function el:click()
		self.clicked = true
	end
	
	function el:release(msg)
		self.clicked = false
		if (msg.has_pointer and self.act) self.act()
	end	

	return el
end


function create_action_button(el)
	local s = get_spr(el.sprite)
	el.width = s:width() or 16
	el.height = s:height() or 16
	el.cursor = "pointer"

	function el:draw(msg)
		pal(7, outline_color())
		local s = el.sprite
		if el.active and not el:active() then
			s += 2
		elseif el.clicked and msg.has_pointer then
			s += 1
		end
		spr(s, 0, 0)
		pal(7, 7)
	end
	
	function el:click()
		self.clicked = true
	end
	
	function el:release(msg)
		self.clicked = false
		if (msg.has_pointer and self.act) self.act()
	end	

	return el
end


-----------------------------------------------------------------------------------


function create_field(el)
	el.cursor = "pointer"

	function el:draw()
		local str = type(self.get == "function") and self:get() or "---"
		local fg = type(self.get_fg == "function") and self:get_fg() or outline_color()
		local prefix = self.small_font and "\014" or ""
--		rectfill(0, 0, self.width - 1, self.height - 1, self:has_keyboard_focus() and 8 or 6)
		if self:has_keyboard_focus() then
			local suffix = (time() % 0.666 > 0.333) and "\016" or ""
			str =  self.str .. suffix
			print(prefix .. str, 1, 1, fg)
			clip()
			rect(-1, -1, self.width, self.height, fg)
		else
			local ww,hh = print(prefix .. str, 0, -1000)
			print(prefix .. str, self.width - ww - 1, 1, fg)
		end
	end

	function el:click()
		self:set_keyboard_focus(true)
		readtext(true)
		self.str = "" -- starting editing new string
	end

	el.custom_update = el.update
	function el:update()
		self:custom_update()
		if self:has_keyboard_focus() then
			while peektext() do
				self.str = self.str .. readtext()
			end
			if keyp("backspace") then
				self.str = sub(self.str, 1, -2)
			end
			if keyp("enter") then
				if type(self.set) == "function" then
					self:set(self.str)
				end
				self:set_keyboard_focus(false)
			end
		end
	end

--	gui:new(el)

	return el
end


------------------------------------------------------------------------------


function create_radio_button(el)
	el.width = 188
	el.height = 12 -- TODO: count the lines?
	el.cursor = "pointer"
	
	function el:draw()
		local fg = self.fg or bg_color
		oval(0, 0, 8, 8, fg)
		local choices = self.parent.choices
		if choices and choices[self.group] == self.key then
			ovalfill(2, 2, 6, 6, fg)
		end
		print(el.label, 15, 1, fg)
	end
	
	function el:tap()
		if not self.parent.choices then
			self.parent.choices = {}
		end
		self.parent.choices[self.group] = self.key
	end
	
	return el
end


-- Utility functions ----------------------------------------------------------------


function outline_color()
	if pal_okhsl[bg_color].l < 0.5 then
		return whitest_color
	else
		return blackest_color
	end
end


function contrast_color(c)
	return (pal_okhsl[c].l < 0.5) and whitest_color or blackest_color
end


function sl_coords(c)
	local sat = pal_okhsl[c].s
	local lum = pal_okhsl[c].l
	local x = slider_border + sat * slider_inner
	local y = slider_border + slider_inner - lum * slider_inner
	return x, y
end


function coords_sl(x, y)
	local sat = (x - slider_border) / slider_inner
	local lum = 1.0 - ((y - slider_border) / slider_inner)
	return sat, lum
end


-- Remove 0.25 to compensate for Picotron's angle origin,
-- and 29/360 to compensate for OkLab weird position of
-- the red color.
local angle_correction = 0.25 + 0.08


function hs_coords(c)
	local hue = pal_okhsl[c].h
	local sat = mid(0.0, pal_okhsl[c].s, 1.0)
	local a = angle_correction - hue
	local dx = sat * cos(a) * (slider_inner / 2)
	local dy = sat * sin(a) * (slider_inner / 2)
	local x = slider_border + (slider_inner / 2) + dx
	local y = slider_border + (slider_inner / 2) + dy
	return x, y
end


function coords_hs(x, y)
	local dx = x - (slider_border + (slider_inner / 2))
	local dy = y - (slider_border + (slider_inner / 2))
	local hue = -atan2(dx, dy) + angle_correction
	dx = (2.0 * dx) / slider_inner
	dy = (2.0 * dy) / slider_inner
	local sat = sqrt(dx * dx + dy * dy) -- / (slider_inner / 2)
	return hue, sat
end


function h_coords(c, radius_delta)
	local s = slider_size + 2 * slider_border
	local r = s - slider_border + (radius_delta or 0)
	local hue = pal_okhsl[c].h
	local a = angle_correction - hue
	local dx = cos(a) * (r / 2)
	local dy = sin(a) * (r / 2)
	local x = (s / 2) + dx + 0.5
	local y = (s / 2) + dy + 0.5
	return x, y
end


function coords_h(x, y)
	local s = slider_size + 2 * slider_border
	local r = s - 6
	local dx = x - ((s / 2) + 0.5)
	local dy = y - ((s / 2) + 0.5)
	local hue = -atan2(dx, dy) + angle_correction
	dx = (2.0 * dx) / r
	dy = (2.0 * dy) / r
	local sat = sqrt(dx * dx + dy * dy)
	return hue, sat
end
:: src/gui_help.lua
--[[pod_format="raw",created="2025-03-07 10:21:37",modified="2025-03-07 15:15:47",revision=404]]
local text_view

function open_help()
	local el = open_modal(300, 250, true)
	if not el then
		return
	end
	text_view = el:attach(create_text_view { x = 50, y = 0, width = 250, height = 250 })
	text_view:set_text(fetch("manual.txt"))
end


function create_text_view(el)
	el.lines = {}
	el.current_line = 1

	function el:set_text(text)
		el.lines = soft_wrap(text, self.width)
	end

	function el:draw(msg)
		cursor(0, 0)
		color(bg_color)
		local l = self.current_line
		local y = 0
		while y < self.height do
			print(self.lines[l])
			y += 11
			l += 1
		end
	end
	
	function el:mousewheel(msg)
		local nb_lines = self.height // 11
		self.current_line = mid(
			1,
			self.current_line - (msg.wheel_y * 3),	
			#self.lines - nb_lines
		)
	end	

	return el
end
:: src/gui_hexdialog.lua
--[[pod_format="raw",created="2025-03-05 12:06:52",modified="2025-03-07 09:39:40",revision=249]]
function open_import_hex_file_dialog()
	local el = open_modal(180, 100, false)
	el:attach(create_label { x = 50, y = 6, label = "Import \".hex\" file", fg = bg_color })
	el:attach(create_radio_button {
		x = 16, y = 36, 
		label = "Import after Picotron's colors",
		group = "import_hex",
		key = "dont_clobber",
	})
	el:attach(create_radio_button {
		x = 16, y = 56, 
		label = "Replace all colors",
		group = "import_hex",
		key = "overwrite",
	})
	el.choices = { import_hex = "dont_clobber" }
	el:attach(create_button {
		x = 110, y = 80,
		label = "Import",
		act = function() prepare_imported_hex(el) end
	})
end


function prepare_imported_hex(dialog)
	current_import_choice = dialog.choices.import_hex
	load_hex_file(imported_hex_file.data, imported_hex_file.metadata or {})
	clear_cube_colors()
	clear_ramp_colors()
	if (undo_stack) undo_stack:reset()
	send_palette()
	imported_hex_file = nil
	close_modal()
end
:: src/gui_newfile.lua
--[[pod_format="raw",created="2025-03-05 08:57:06",modified="2025-03-05 12:06:43",revision=168]]
function open_new_file_dialog()
	local el = open_modal(180, 100, false)
	el:attach(create_label { x = 60, y = 6, label = "New Palette", fg = bg_color })
	el:attach(create_radio_button {
		x = 16, y = 36, 
		label = "Keep default colors",
		group = "new_palette",
		key = "keep_default",
	})
	el:attach(create_radio_button {
		x = 16, y = 56, 
		label = "Start with empty palette",
		group = "new_palette",
		key = "empty_palette",
	})
	el.choices = { new_palette = "keep_default" }
	el:attach(create_button {
		x = 110, y = 80,
		label = "Let's go!",
		act = function() prepare_new_file(el) end
	})
end


function prepare_new_file(dialog)
	if dialog.choices.new_palette == "empty_palette" then
		clear_colors()
	end
	close_modal()
end
:: src/gui_palette.lua
--[[pod_format="raw",created="2025-02-28 10:09:19",modified="2025-03-07 15:15:47",revision=1524]]
function generate_palette_gui()
	gui.tap = function(self, msg) if (msg.has_pointer) active_color = nil end
	local pal_el = create_palette{ x = 16, y = 6 }
	gui:attach(pal_el)
	gui:attach(create_visibility_buttons { x = pal_el.x - 14, y = pal_el.y + 1 })
	gui:attach(create_color_preview { x = pal_el.x + pal_el.width + 8, y = pal_el.y })
	gui:attach(create_test_zone { x = 390, y = 4 })
	local h_slider = create_hue_slider{ x = 6, y = 68 }
	gui:attach(h_slider)
	h_slider:attach(create_hue_sat_slider { x = slider_border, y = slider_border })
	local sl_slider = create_sat_lum_slider{ x = 200 + 16, y = 66 }
	local s_slider = create_sat_slider { x = sl_slider.x, y = sl_slider.y + sl_slider.height }
	local l_slider = create_lum_slider { x = sl_slider.x - 16, y = sl_slider.y }
	gui:attach(s_slider)
	gui:attach(l_slider)
	gui:attach(sl_slider)
	
	local x_buttons = 346
	gui:attach(create_action_button { x = x_buttons, y = 4, sprite = 16,
		act = function(self) undo_stack:undo() end,
		active = function(self) return #(undo_stack.undo_stack) >= 1 end })
	gui:attach(create_action_button { x = x_buttons + 16 + 2, y = 4, sprite = 19,
		act = function(self) undo_stack:redo() end,
		active = function(self) return #(undo_stack.redo_stack) >= 1 end })
--	gui:attach(create_action_button { x = x_buttons, y = 4 + 16 + 2, sprite = 24,
--		act = function(self) open_settings() end })
	gui:attach(create_action_button { x = x_buttons + 16 + 2, y = 4 + 16 + 2, sprite = 27,
		act = function(self) open_help() end })
end


-----------------------------------------------------------------------------------


function create_palette(el)
	local size = 12
	local nb_columns = 16
	local nb_rows = 4
	el.width = (nb_columns * size) + 1
	el.height = (nb_rows * size) + 1

	function el:draw(msg)
		clip()
		rect(0, 0, self.width, self.height, outline_color())
		for c = 0, 63 do
			local x = 1 + ((c % nb_columns) * size)
			local y = 1 + ((c \ nb_columns) * size)
			rectfill(x, y, x + size - 1, y + size - 1, c)
			if hidden[c] then
				ovalfill(
					x + 2, y + 2,
					x + size - 3, y + size - 3,
					0
				)
			end
			if c == active_color then
				rect(
					x + 1, y + 1,
					x + size - 2, y + size - 2,
					contrast_color(active_color)
				)
			end
		end	
		if self.drag_pos then
			local col = (msg.mx - 1) \ size
			local row = (msg.my - 1) \ size
			local c = col + row * nb_columns
			if 0 <= c and c <= 63 then
				local x = 1 + col * size
				local y = 1 + row * size
				if c != active_color and not locked[c] then
					oval(
						x + 2, y + 2,
						x + size - 3, y + size - 3,
						contrast_color(c)
					)
				end
			end
			local mx, my = self.drag_pos.x, self.drag_pos.y
			rectfill(mx, my, mx + 8, my + 8, active_color)		
		end
	end

	function el:click(msg)
		local col = min(nb_columns - 1, (msg.mx - 1) \ size)
		local row = min(nb_rows - 1, (msg.my - 1) \ size)
		local c = col + row * nb_columns
		if msg.mb == 1 then
			active_color = c
			self.click_pos = { x = msg.mx, y = msg.my }
		elseif msg.mb == 2 then
			hidden[c] = not hidden[c]
			if hidden[c] then
				local all_hidden = true
				for i = 0, nb_columns - 1 do
					if not hidden[(row * nb_columns) + i] then
						all_hidden = false
					end
				end
				if all_hidden then
					hidden_toggles[row] = true
				end
			else
				hidden_toggles[row] = false
			end
		end
	end	
	
	function el:drag(msg)
		if self.click_pos and not self.drag_pos then
			local dx = abs(self.click_pos.x - msg.mx)
			local dy = abs(self.click_pos.y - msg.my)
			if dx > 1 or dy > 1 then
				if locked[active_color] then
					padlock_flashing = true
				else
					self.drag_pos = {}
				end
			end
		end
		if self.drag_pos then
			self.drag_pos = { x = msg.mx, y = msg.my }
		end
	end
	
	function el:release(msg)
		if self.drag_pos then
			local col = (msg.mx - 1) \ size
			local row = (msg.my - 1) \ size
			local c = col + row * nb_columns
			if 0 <= c and c <= 63 and not locked[c] then
				undo_stack:checkpoint()
				swap_colors(active_color, c)
				active_color = c
				send_palette()
			end			
		end
		self.click_pos = nil
		self.drag_pos = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end

	return el
end


local blink_anim <const> = { [0] = 40, 41, 42, 43, 43, 43, 42, 41, 40 }


function create_visibility_buttons(el)
	local size = 12
	local nb_rows = 4
	el.width = size
	el.height = nb_rows * size
	el.cursor = "pointer"
	

	function el:draw(msg)
		pal(7, outline_color())
		for row = 0, 3 do
			if hidden_toggles[row] then
				spr(43, 0, row * size)
			else
				local sprite = 40
				if blink_timer <= 0 and blink_eye == row then
					sprite = blink_anim[- blink_timer] 
				end
				spr(sprite, 0, row * size)
			end
		end
		pal(7, 7)
	end
	
	function el:update(msg)
		blink_timer -= 1
		if blink_timer <= -9 then
			blink_timer = 180 + math.random(1, 6) * 90
			local nb_eyes = active_color and 4 or 3
			blink_eye = math.random(0, nb_eyes)
			if hidden_toggles[blink_eye] then
				blink_eye = math.random(0, nb_eyes)
			end
		end
	end
	
	function el:tap(msg)
		local row = mid(0, msg.my \ size, 3)
		hidden_toggles[row] = not hidden_toggles[row]
		for c = row * 16, row * 16 + 15 do
			hidden[c] = hidden_toggles[row]
		end
	end
	
	return el
end


------------------------------------------------------------------------------


function create_color_preview(el)
	local size = 12
	el.width = size * 4 + 2 + 120
	el.height = size * 4 + 2
	
	function el:draw(msg)
		if active_color then
			---rect(0, 0, self.height - 1, self.height - 1, 0)
			rectfill(1, 1, self.height - 2, self.height - 2, active_color)
			print(string.format("%d", active_color), 4, 4, contrast_color(active_color))
			local c = get_color(active_color)
--			print("#" .. color_to_hex(c), 7, self.height - 10, contrast_color(active_color))
			pal(7, outline_color())
			if locked[active_color] then
				if padlock_flashing_time % 18 < 10 then
					spr(2, self.height + 4, 1)
				end
			else
				spr(1, self.height + 4, 1)
			end
			if hidden[active_color] then
				spr(43, self.height + 4 + size, 1)
			else
				local sprite = 40
				if blink_timer <= 0 and blink_eye == 4 then
					sprite = blink_anim[- blink_timer] 
				end
				spr(sprite, self.height + 4 + size, 1)
			end
			if bg_color == active_color then
				spr(10, self.height + 4 + 2 * size, 1)
			else
				spr(9, self.height + 4 + 2 * size, 1)
			end
			pal(7, 7)
			local hue = pal_okhsl[active_color].h * 360.0
			while hue < 0.0 do
				hue += 360.0
			end
			print("\014       hue: ", self.height + 5, 24, outline_color()) -- .. string.format("%3.0f", hue) .. "\031", self.height + 5, 24, outline_color())
			print("\014saturation: ", self.height + 5, 33) -- .. string.format("%3.0f", pal_okhsl[active_color].s * 100.0) .. "%", self.height + 5, 33)
			print("\014 luminance: ", self.height + 5, 42) -- .. string.format("%3.0f", pal_okhsl[active_color].l * 100.0) .. "%", self.height + 5, 42)
		else
			print("\^pOkPal" .. "\^-p\014\|o " .. okpal_version, 24, 0, outline_color())
			print("\014\|b\-g(press f1 for help)")
		end
	end
	
	function el:tap(msg)
		if (not active_color) return
		if msg.mx < self.height or msg.my > size then
			return
		elseif msg.mx < self.height + 4 + size then
			locked[active_color] = not locked[active_color]
		elseif msg.mx < self.height + 4 + 2 * size then
			hidden[active_color] = not hidden[active_color]
		elseif msg.mx < self.height + 4 + 3 * size then
			if key("shift") and bg_color != active_color then
				whitest_color = active_color
			elseif key("ctrl") then
				blackest_color = active_color
			elseif bg_color == active_color then
				bg_color = blackest_color
			else
				bg_color = active_color
			end
		end
	end
	
	function el:hover(msg)
		if msg.has_pointer and msg.mx >= self.height + 4 and msg.mx <= self.height + 4 + 3 * size and msg.my <= size then
			self.cursor = "pointer"
		else
			self.cursor = 1
		end
	end

	gui:new(el)
	
	-- Input field for the color code
	el:attach(create_field {
		x = 5, y = el.height - 12,
		width = 40, height = 9,
		small_font = false,
		get_fg = function(self) return contrast_color(active_color or 0) end,
		get = function(self)
			if (not active_color) return ""
			return "#" .. color_to_hex(get_color(active_color))
		end,
		set = function(self, str)
			if (locked[active_color]) return
			str = str:gsub("%s", ""):gsub("#", "")
			if (#str ~= 6) return
			local code = tonum("0x" .. str)
			if (type(code) ~= "number") return
			undo_stack:checkpoint()
			change_color_code(active_color, code)
		end,
		update = function(self, msg)
			self.hidden = active_color == nil
		end
	})

	-- Input field for hue
	el:attach(create_field {
		x = 100, y = 23,
		width = 20, height = 7,
		small_font = true,
		get_fg = function(self) return outline_color() end,
		get = function(self)
			if (not active_color) return ""
			local hue = pal_okhsl[active_color].h * 360.0
			while hue < 0.0 do
				hue += 360.0
			end
			return string.format("%3.0f\031", hue)
		end,
		set = function(self, str)
			if (locked[active_color]) return
			str = str:gsub("%s", ""):gsub("\031", "")
			local hue = tonum(str)
			if (type(hue) ~= "number") return
			hue = (hue % 360.0) / 360.0
			undo_stack:checkpoint()
			change_color(active_color, hue, nil, nil)
		end,
		update = function(self, msg)
			self.hidden = active_color == nil
		end
	})

	-- Input field for saturation
	el:attach(create_field {
		x = 100, y = 32,
		width = 20, height = 7,
		small_font = true,
		get_fg = function(self) return outline_color() end,
		get = function(self)
			if (not active_color) return ""
			local sat = pal_okhsl[active_color].s * 100.0
			return string.format("%3.0f%%", sat)
		end,
		set = function(self, str)
			if (locked[active_color]) return
			str = str:gsub("%s", ""):gsub("%%", "")
			local sat = tonum(str)
			if (type(sat) ~= "number") return
			sat = sat / 100.0
			undo_stack:checkpoint()
			change_color(active_color, nil, sat, nil)
		end,
		update = function(self, msg)
			self.hidden = active_color == nil
		end
	})

	-- Input field for luminance
	el:attach(create_field {
		x = 100, y = 41,
		width = 20, height = 7,
		small_font = true,
		get_fg = function(self) return outline_color() end,
		get = function(self)
			if (not active_color) return ""
			local lum = pal_okhsl[active_color].l * 100.0
			return string.format("%3.0f%%", lum)
		end,
		set = function(self, str)
			if (locked[active_color]) return
			str = str:gsub("%s", ""):gsub("%%", "")
			local lum = tonum(str)
			if (type(lum) ~= "number") return
			lum = lum / 100.0
			undo_stack:checkpoint()
			change_color(active_color, nil, nil, lum)
		end,
		update = function(self, msg)
			self.hidden = active_color == nil
		end
	})
	
	return el
end


---------------------------------------------------------------------------------


function create_test_zone(el)
	el.width = (24 + 4) * 3
	el.height = 12 + (24 + 4) * 8 + 15
	el.cursor = "pointer"
	el.cubes = {}
	el.ramps = nil

	function el:draw()
		pal(7, outline_color())
		if test_mode == "cubes" then
			spr(34, 0, 0)
		elseif test_mode == "ramps" then
			spr(35, 0, 0)
		end
		pal(7, 7)
	end
	
	function el:click(msg)
		if msg.my > 12 then
			return
		end
		if test_mode == "cubes" and msg.mx > 33 then
			test_mode = "ramps"
			for c in all(self.cubes) do
				c.hidden = true
			end
			self.ramps.hidden = false
		elseif test_mode == "ramps" and msg.mx < 33 then
			test_mode = "cubes"
			for c in all(self.cubes) do
				c.hidden = false
			end
			self.ramps.hidden = true
		end
	end
	
	function el:mousewheel(msg)
		if active_color and msg.wheel_y < 0 then
			active_color = (active_color + 1) % 64
		elseif active_color and msg.wheel_y > 0 then
			active_color = (active_color - 1) % 64
		end
	end
	
	gui:new(el)
	
	for i = 0, 2 do
		for j = 0, 7 do
			el.cubes[#el.cubes + 1] =
				el:attach(create_test_cube { x = i * 28, y = 12 + j * 28, test_id = i + 3 * j })
		end
	end
	
	el.ramps = el:attach(create_test_ramps { x = 0, y = 12, hidden = test_mode ~= "ramps" })

	el:attach(create_action_button { x = 54, y = 238, sprite = 32,
		act =
			function(self)
				undo_stack:checkpoint()
				if test_mode == "cubes" then
					clear_cube_colors()
				elseif test_mode == "ramps" then
					clear_ramp_colors()
				end
			end })

	return el
end


function create_test_cube(el)
	el.width = 24 + 4
	el.height = 24 + 4
	el.hidden = test_mode ~= "cubes"

	function el:draw()
		local colors = test_cube_colors[self.test_id]
		pal(10, colors[1])
		pal(9, colors[2])
		pal(25, colors[3])
		spr(8, 2, 2)
		pal(10, 10)
		pal(9, 9)
		pal(25, 25)
	end
	
	function el:hover(msg)
		if msg.mx > 2 and msg.my > 2 and msg.mx < self.width - 2 and msg.my < self.height - 2 then
			el.cursor = "crosshair"
		else
			el.cursor = 1
		end
	end
	
	function el:click(msg)
		local face = 2
		if msg.mx > self.width - 10 or msg.my < 10 then
			if msg.mx > self.height - msg.my then
				face = 3
			else
				face = 1
			end
		end
		if msg.mb == 1 then
			undo_stack:checkpoint()
			test_cube_colors[self.test_id][face] = active_color or 1
		elseif msg.mb == 2 then
			active_color = test_cube_colors[self.test_id][face]
		end
	end
	
	return el
end


function create_test_ramps(el)
	el.width = (24 + 4) * 3
	el.height = (24 + 4) * 8
	
	function el:square_of(x, y)
		if x < 2 or x > self.width - 2 or y <= 4 or y >= self.height - 4 then
			return nil, nil
		end
		local i = mid(0, (x - 2) // 8, 9)
		local j = mid(0, (y - 4) // 8, 26)
		return i, j
	end

	function el:draw(msg)
--		rectfill(0, 0, self.width, self.height, 8)
		for i = 0, 9 do
			for j = 0, 26 do
				local x = 2 + i * 8
				local y = 4 + j * 8
				local c = test_ramp_colors:get(i, j)
				rectfill(x, y, x + 7, y + 7, c)
			end
		end
		local i, j = self:square_of(msg.mx, msg.my)
		if i then
			local x = 2 + i * 8
			local y = 4 + j * 8
			local c = test_ramp_colors:get(i, j)
			if c == 0 then
				rect(x, y, x + 7, y + 7, contrast_color(c))
			end
		end
	end
	
	function el:hover(msg)
		local i, j = self:square_of(msg.mx, msg.my)
		if i then
			el.cursor = "crosshair"
		else
			el.cursor = 1
		end
	end
	
	function el:click(msg)
		local  i, j = self:square_of(msg.mx, msg.my)
		if (not i) return
		if msg.mb == 1 then
			undo_stack:checkpoint()
			test_ramp_colors:set(i, j, active_color)
		elseif msg.mb == 2 then
			active_color = mid(0, test_ramp_colors:get(i, j), 63)
		elseif msg.mb == 4 then
			test_ramp_colors:set(i, j, 0)
		end
	end

	return el
end
:: src/gui_settings.lua
--[[pod_format="raw",created="2025-02-28 11:31:28",modified="2025-03-07 10:21:27",revision=788]]
function open_settings()
	local el = open_modal(200, 100)
	el:attach(create_label { x = 78, y = 6, label = "Settings", fg = bg_color })
end
:: src/gui_sliders.lua
--[[pod_format="raw",created="2024-04-05 07:49:07",modified="2025-03-07 09:39:40",revision=1760]]
slider_size = 170
slider_border = 6
slider_inner = slider_size - 2 * slider_border


-- Hue / saturation slider ----------------------------------------------------------


function create_hue_sat_slider(el)
	el.width = slider_size
	el.height = slider_size
	el.drag_delta = nil
	
	function el:draw()
		clip()
		oval(
			slider_border - 1, slider_border - 1,
			slider_border + slider_inner + 1, slider_border + slider_inner + 1,
			outline_color()
		)
		fillp(0b0101101001011010)
		rectfill(slider_size \ 2 - 24, slider_size \ 2, slider_size \ 2 + 24, slider_size \ 2, 7)
		rectfill(slider_size \ 2, slider_size \ 2 - 24, slider_size \ 2, slider_size \ 2 + 24, 7)
		fillp()
		for c = 0, 63 do
			if not hidden[c] and pal_okhsl[c].l != 0 then
				local x, y = hs_coords(c)
				ovalfill(x - 3, y - 3, x + 3, y + 3, c)
			end
		end
		if active_color and not hidden[active_color] then
			local x, y = hs_coords(active_color)
			pal(7, whitest_color)
			pal(14, active_color)
			spr(
				self.drag_delta and 12 or 11,
				x - 5, y - 5,
				x + 5, y + 5
			)
			pal(14, 14)
			pal(7, 7)
		end
		pal(7, outline_color())
		spr(13, -6, 120)
		pal(7, 7)
	end	
	
	function el:hover(msg)
		if (not msg.mx or not msg.my) return false
		local _, r = coords_hs(msg.mx, msg.my)
		if r > 1.02 then
			return false
		end
		if active_color and not hidden[active_color] then
			local ax, ay = hs_coords(active_color)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx <= 5 and dy <= 5 then
				self.cursor = "grab"
			else
				self.cursor = 1
			end
		end
		return true
	end
	
	function el:click(msg)
		local _, r = coords_hs(msg.mx, msg.my)
		if r > 1.02 then
			return false
		end
		if active_color and not hidden[active_color] then
			local ax, ay = hs_coords(active_color)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx <= 5 and dy <= 5 then
				undo_stack:checkpoint()
				self.drag_delta = { x = ax - msg.mx, y = ay - msg.my }
				return true
			end
		end
		active_color = nil
		-- In reverse order to prioritize colors on top
		for c = 63, 0, -1 do
			local cx, cy = hs_coords(c)
			local dx = abs(cx - msg.mx)
			local dy = abs(cy - msg.my)
			if dx <= 3 and dy <= 3 and not hidden[c] and pal_okhsl[c].l != 0 then
				undo_stack:checkpoint()
				active_color = c
				self.drag_delta = { x = cx - msg.mx, y = cy - msg.my }
				self.cursor = "grab"
				return true
			end
		end
		self.drag_delta = nil
		return true
	end
	
	function el:drag(msg)
		if (not active_color) return
		if (not self.drag_delta) return
		if locked[active_color] then
			padlock_flashing = true
		else
			local ax = msg.mx + self.drag_delta.x
			local ay = msg.my + self.drag_delta.y
			local hue, sat = coords_hs(ax, ay)
			change_color(active_color, hue, sat, nil)
			return true
		end
	end
	
	function el:release(msg)
		send_palette()
		self.drag_delta = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end

	return el
end


-- Saturation / luminance slider ----------------------------------------------------


function create_sat_lum_slider(el)
	el.width = slider_size
	el.height = slider_size
	el.drag_delta = nil
		
	function el:draw()
		clip()
		rect(
			slider_border - 1, slider_border - 1, 
			slider_border + slider_inner + 1, slider_border + slider_inner + 1, 
			outline_color()
		)
		for c = 0, 63 do
			if not hidden[c] and pal_okhsl[c].l != 0 then
				local x, y = sl_coords(c)
				ovalfill(x - 3, y - 3, x + 3, y + 3, c)
			end
		end
		if active_color and not hidden[active_color] then
			local x, y = sl_coords(active_color)
			pal(7, whitest_color)
			pal(14, active_color)
			spr(
				self.drag_delta and 12 or 11,
				x - 5, y - 5,
				x + 5, y + 5
			)
			pal(14, 14)
			pal(7, 7)
		end
		pal(7, outline_color())
		spr(14, -22, 128)
		pal(7, 7)
	end	
	
	function el:hover(msg)
		if active_color and not hidden[active_color] then
			local ax, ay = sl_coords(active_color)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx < 6 and dy < 6 then
				self.cursor = "grab"
			else
				self.cursor = 1
			end
		end
	end
	
	function el:click(msg)
		if active_color and not hidden[active_color] then
			local ax, ay = sl_coords(active_color)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx < 6 and dy < 6 then
				undo_stack:checkpoint()
				self.drag_delta = { x = ax - msg.mx, y = ay - msg.my }
				return
			end
		end
		active_color = nil
		-- In reverse order to prioritize colors on top
		for c = 63, 0, -1 do
			local cx, cy = sl_coords(c)
			local dx = abs(cx - msg.mx)
			local dy = abs(cy - msg.my)
			if dx < 3 and dy < 3 and not hidden[c] and pal_okhsl[c].l != 0 then
				undo_stack:checkpoint()
				active_color = c
				self.drag_delta = { x = cx - msg.mx, y = cy - msg.my }
				self.cursor = "grab"
				return
			end
		end
		self.drag_delta = nil
	end
	
	function el:drag(msg)
		if (not active_color) return
		if (not self.drag_delta) return
		if locked[active_color] then
			padlock_flashing = true
		else
			local ax = msg.mx + self.drag_delta.x
			local ay = msg.my + self.drag_delta.y
			local sat, lum = coords_sl(ax, ay)
			change_color(active_color, nil, sat, lum)
		end
	end
	
	function el:release(msg)
		send_palette()
		self.drag_delta = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end

	return el
end


-- 1D Sliders ----------------------------------------------------------------------


function create_hue_slider(el)
	el.width = slider_size + 2 * slider_border
	el.height = slider_size + 2 * slider_border

	function el:draw()
		clip()
		for c = 0, 63 do
			if not hidden[c] and pal_okhsl[c].l != 0 then
				cx1, cy1 = h_coords(c, -2)
				cx2, cy2 = h_coords(c, 18)
				line(cx1, cy1, cx2, cy2, c)
			end
		end
		if active_color and not hidden[active_color] then
			local ax, ay = h_coords(active_color)
			pal(7, outline_color())
			pal(13, active_color)
			spr(7, ax - 4, ay - 4)
			pal(13, 13)
			pal(7, 7)
		end
	end	

	function el:hover(msg)
		-- I think there is a bug in Picotron's handling of mouse coords
		-- when one widget is on top of another.
		--[[
		if (not msg.mx or not msg.my) return
		if active_color then
			local ax, ay = h_coords(active_color)
			--printh(string.format("%.0f %.0f - %.0f %.0f", ax, ay, msg.mx, msg.my))
			if
				msg.mx >= ax - 6 and msg.mx <= ax + 6
				and msg.my >= ay - 6 and msg.my <= ay + 6
			then
				self.cursor = "grab"
			else
				self.cursor = 1
			end
		end
		--]]
	end

	function el:click(msg)
		undo_stack:checkpoint()
		if active_color and not hidden[active_color] then
			local ax, ay = h_coords(active_color)
			--[[
			if
				msg.mx >= ax - 6 and msg.mx <= ax + 6
				and msg.my >= ay - 6 and msg.my <= ay + 6
			then
			]]
				self.drag_delta = { x = ax - msg.mx, y = ay - msg.my }
			-- end
		end
	end
	
	function el:drag(msg)
		if (not active_color) return
		if (not self.drag_delta) return
		if locked[active_color] then
			padlock_flashing = true
		else
			local ax = msg.mx + self.drag_delta.x
			local ay = msg.my + self.drag_delta.y
			local hue = coords_h(ax, ay)
			change_color(active_color, hue, nil, nil)
		end
	end
	
	function el:release(msg)
		send_palette()
		self.drag_delta = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end

	return el
end


function create_sat_slider(el)
	el.width = slider_size
	el.height = 16
	
	function el:draw()
		clip()
		for c = 0, 63 do
			if not hidden[c] and pal_okhsl[c].l != 0 then
				local ax, _ = sl_coords(c)
				line(ax, 0, ax, self.height - 9, c)
			end
		end
		if active_color and not hidden[active_color] then
			local ax, _ = sl_coords(active_color)
			pal(7, outline_color())
			pal(13, active_color)
			spr(5, ax - 4, self.height - 9)
			pal(13, 13)
			pal(7, 7)
		end
	end	
	
	function el:hover(msg)
		if active_color and not hidden[active_color] then
			local ax, _ = sl_coords(active_color)
			if msg.mx and msg.mx >= ax - 4 and msg.mx <= ax + 4 and msg.my >= self.height - 9 then
				self.cursor = "grab"
			else
				self.cursor = 1
			end
		end
	end

	function el:click(msg)
		undo_stack:checkpoint()
		if active_color and not hidden[active_color] then
			local ax, _ = sl_coords(active_color)
			if msg.mx and msg.mx >= ax - 4 and msg.mx <= ax + 4 and msg.my >= self.height - 9 then
				self.drag_delta_x = ax - msg.mx
			end
		end
	end
	
	function el:drag(msg)
		if (not active_color) return
		if (not self.drag_delta_x) return
		if locked[active_color] then
			padlock_flashing = true
		else
			local ax = msg.mx + self.drag_delta_x
			local sat, lum = coords_sl(ax, 0)
			change_color(active_color, nil, sat, nil)
		end
	end
	
	function el:release(msg)
		send_palette()
		self.drag_delta_x = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end
			
	return el
end


function create_lum_slider(el)
	el.width = 16
	el.height = slider_size
	
	function el:draw()
		clip()
		for c = 0, 63 do
			if not hidden[c] and pal_okhsl[c].l != 0 then
				local _, ay = sl_coords(c)
				line(9, ay, self.width, ay, c)
			end
		end
		if active_color and not hidden[active_color] then
			local _, ay = sl_coords(active_color)
			pal(7, outline_color())
			pal(13, active_color)
			spr(6, 0, ay - 4)
			pal(13, 13)
			pal(7, 7)
		end
	end	
	
	function el:hover(msg)
		if active_color and not hidden[active_color] then
			local _, ay = sl_coords(active_color)
			if msg.my and msg.my >= ay - 4 and msg.my <= ay + 4 and msg.mx <= 9 then
				self.cursor = "grab"
			else
				self.cursor = 1
			end
		end
	end

	function el:click(msg)
		undo_stack:checkpoint()
		if active_color and not hidden[active_color] then
			local _, ay = sl_coords(active_color)
			if msg.my and msg.my >= ay - 4 and msg.my <= ay + 4 and msg.mx <= 9 then
				self.drag_delta_y = ay - msg.my
			end
		end
	end
	
	function el:drag(msg)
		if (not active_color) return
		if (not self.drag_delta_y) return
		if locked[active_color] then
			padlock_flashing = true
		else
			local ay = msg.my + self.drag_delta_y
			local sat, lum = coords_sl(0, ay)
			change_color(active_color, nil, nil, lum)
		end
	end
	
	function el:release(msg)
		send_palette()
		self.drag_delta_y = nil
		padlock_flashing = false
		padlock_flashing_time = 0
	end
			
	return el
end

:: src/oklab.lua
--[[pod_format="raw",created="2024-03-31 09:08:26",modified="2024-04-02 08:53:32",revision=979]]
-- Copyright(c) 2021 Bjorn Ottosson
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of
-- this software and associated documentation files(the "Software"), to deal in
-- the Software without restriction, including without limitation the rights to
-- use, copy, modify, merge, publish, distribute, sublicense, and /or sell copies
-- of the Software, and to permit persons to whom the Software is furnished to do
-- so, subject to the following conditions:
--
-- The above copyright noticeand this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

oklab = {}
oklab.__index = oklab

function oklab.color_to_okhsl(code)
	local srgb = {
		r = ((code & 0xff0000) >> 16) / 255,
		g = ((code & 0x00ff00) >> 8) / 255,
		b = ((code & 0x0000ff)) / 255,
	}
	return oklab.srgb_to_okhsl(srgb)
end

function oklab.okhsl_to_color(okhsl)
	local srgb = oklab.okhsl_to_srgb(okhsl)
	local r = mid(0x00, math.floor(srgb.r * 255 + 0.5), 0xff)
	local g = mid(math.floor(srgb.g * 255 + 0.5), 0xff)
	local b = mid(math.floor(srgb.b * 255 + 0.5), 0xff)
	return (r << 16) | (g << 8) | b
end

function oklab.new()
    local inst = setmetatable({}, oklab)
    return inst
end

-- Finds the maximum saturation possible for a given hue that fits in sRGB
-- Saturation here is defined as S = C/L
-- a and b must be normalized so a^2 + b^2 == 1
function oklab.compute_max_saturation(a, b)
    if a ~= 0.0 or b ~= 0.0 then
    	-- Max saturation will be when one of r, g or b goes below zero.
        -- Select different coefficients depending on which component goes below zero first

        -- Blue component (default)
        local k0 = 1.35733652
        local k1 = -0.00915799
        local k2 = -1.1513021
        local k3 = -0.50559606
        local k4 = 0.00692167
        local wl = -0.0041960863
        local wm = -0.7034186147
        local ws = 1.707614701

        if -1.88170328 * a - 0.80936493 * b > 1 then
            -- Red component
            k0 = 1.19086277
            k1 = 1.76576728
            k2 = 0.59662641
            k3 = 0.75515197
            k4 = 0.56771245
            wl = 4.0767416621
            wm = -3.3077115913
            ws = 0.2309699292
        elseif 1.81444104 * a - 1.19445276 * b > 1 then
            -- Green component
            k0 = 0.73956515
            k1 = -0.45954404
            k2 = 0.08285427
            k3 = 0.1254107
            k4 = 0.14503204
            wl = -1.2684380046
            wm = 2.6097574011
            ws = -0.3413193965
        end

        -- Approximate max saturation using a polynomial:
        local S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b

        -- Do one step Halley's method to get closer
        -- this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite
        -- this should be sufficient for most applications, otherwise do two/three steps

        local k_l = 0.3963377774 * a + 0.2158037573 * b
        local k_m = -0.1055613458 * a - 0.0638541728 * b
        local k_s = -0.0894841775 * a - 1.291485548 * b

        do
            local l_ = 1.0 + S * k_l
            local m_ = 1.0 + S * k_m
            local s_ = 1.0 + S * k_s

            local l = l_ * l_ * l_
            local m = m_ * m_ * m_
            local s = s_ * s_ * s_

            local l_dS = 3.0 * k_l * l_ * l_
            local m_dS = 3.0 * k_m * m_ * m_
            local s_dS = 3.0 * k_s * s_ * s_

            local l_dS2 = 6.0 * k_l * k_l * l_
            local m_dS2 = 6.0 * k_m * k_m * m_
            local s_dS2 = 6.0 * k_s * k_s * s_

            local f = wl * l + wm * m + ws * s
            local f1 = wl * l_dS + wm * m_dS + ws * s_dS
            local f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2

            local s_denom = f1 * f1 - 0.5 * f * f2
            if s_denom ~= 0.0 then  S = S - f * f1 / s_denom end
        end

        return S
    else
        return 0.0
    end
end

-- finds L_cusp and C_cusp for a given hue
-- a and b must be normalized so a^2 + b^2 == 1
function oklab.find_cusp(a, b)
	-- First, find the maximum saturation (saturation S = C/L)
    local S_cusp = oklab.compute_max_saturation(a, b)

    -- Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:
    local rgb_at_max = oklab.oklab_to_linear_srgb({L = 1, a = S_cusp * a, b = S_cusp * b })
    local max_comp = math.max(rgb_at_max.r, rgb_at_max.g, rgb_at_max.b)
    if max_comp ~= 0.0 then
        local L_cusp = (1.0 / max_comp) ^ 0.3333333333333333
        return { L = L_cusp, C = L_cusp * S_cusp }
    else
        return { L = 0.0, C = 0.0 }
    end
end

-- Finds intersection of the line defined by
-- L = L0 * (1 - t) + t * L1
-- C = t * C1
-- a and b must be normalized so a^2 + b^2 == 1
function oklab.find_gamut_intersection(a, b, L1, C1, L0, x)
    -- Find the cusp of the gamut triangle
    local cusp = x or oklab.find_cusp(a, b)

    -- Find the intersection for upper and lower half separately
    local t = 0.0
    if ((L1 - L0) * cusp.C - (cusp.L - L0) * C1) <= 0.0 then
        -- Lower half
        local t_denom = C1 * cusp.L + cusp.C * (L0 - L1)
        if t_denom ~= 0.0 then t = cusp.C * L0 / t_denom end
    else
        -- Upper half
        -- First intersect with triangle
        local t_denom = C1 * (cusp.L - 1.0) + cusp.C * (L0 - L1)
        if t_denom ~= 0.0 then t = cusp.C * (L0 - 1.0) / t_denom end

        -- Then one step Halley's method
        do
            local dL = L1 - L0
            local dC = C1

            local k_l = 0.3963377774 * a + 0.2158037573 * b
            local k_m = -0.1055613458 * a - 0.0638541728 * b
            local k_s = -0.0894841775 * a - 1.291485548 * b

            local l_dt = dL + dC * k_l
            local m_dt = dL + dC * k_m
            local s_dt = dL + dC * k_s

            -- If higher accuracy is required, 2 or 3 iterations of the following block can be used:
            do
                local L = L0 * (1.0 - t) + t * L1
				local C = t * C1

				local l_ = L + C * k_l
				local m_ = L + C * k_m
				local s_ = L + C * k_s

				local l = l_ * l_ * l_
				local m = m_ * m_ * m_
				local s = s_ * s_ * s_

				local ldt = 3.0 * l_dt * l_ * l_
				local mdt = 3.0 * m_dt * m_ * m_
				local sdt = 3.0 * s_dt * s_ * s_

				local ldt2 = 6.0 * l_dt * l_dt * l_
				local mdt2 = 6.0 * m_dt * m_dt * m_
				local sdt2 = 6.0 * s_dt * s_dt * s_

                local r0 = 4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s - 1
				local r1 = 4.0767416621 * ldt - 3.3077115913 * mdt + 0.2309699292 * sdt
				local r2 = 4.0767416621 * ldt2 - 3.3077115913 * mdt2 + 0.2309699292 * sdt2

                local r_denom = r1 * r1 - 0.5 * r0 * r2
                local u_r = 0.0
                if r_denom ~= 0.0 then u_r = r1 / r_denom end
				local t_r = -r0 * u_r

                local g0 = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s - 1
				local g1 = -1.2684380046 * ldt + 2.6097574011 * mdt - 0.3413193965 * sdt
				local g2 = -1.2684380046 * ldt2 + 2.6097574011 * mdt2 - 0.3413193965 * sdt2

                local g_denom = g1 * g1 - 0.5 * g0 * g2
                local u_g = 0.0
                if g_denom ~= 0.0 then u_g = g1 / g_denom end
				local t_g = -g0 * u_g

                local b0 = -0.0041960863 * l - 0.7034186147 * m + 1.707614701 * s - 1
				local b1 = -0.0041960863 * ldt - 0.7034186147 * mdt + 1.707614701 * sdt
				local b2 = -0.0041960863 * ldt2 - 0.7034186147 * mdt2 + 1.707614701 * sdt2

                local b_denom = (b1 * b1 - 0.5 * b0 * b2)
                local u_b = 0.0
                if b_denom ~= 0.0 then u_b = b1 / b_denom end
				local t_b = -b0 * u_b

                if u_r < 0.0 then t_r = 3.40282347e+38 end
                if u_g < 0.0 then t_g = 3.40282347e+38 end
                if u_b < 0.0 then t_b = 3.40282347e+38 end

                t = t + math.min(t_r, t_g, t_b)
            end
        end
    end

    return t
end

function oklab.get_Cs(L, a_, b_)
    local cusp = oklab.find_cusp(a_, b_)
    local C_max = oklab.find_gamut_intersection(a_, b_, L, 1.0, L, cusp)
    local ST_max = oklab.to_ST(cusp)

    -- Scale factor to compensate for the curved part of gamut shape:
    local k = 0.0
    local k_denom = math.min(L * ST_max.S, (1.0 - L) * ST_max.T)
    if k_denom ~= 0.0 then k = C_max / k_denom end

    local C_mid = 0.0
    do
        local ST_mid = oklab.get_ST_mid(a_, b_)

        -- Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.
        local C_a = L * ST_mid.S
        local C_b = (1.0 - L) * ST_mid.T

        local cae4 = C_a * C_a * C_a * C_a
        local cbe4 = C_b * C_b * C_b * C_b
        C_mid = 0.9 * k * ((1.0 / (1.0 / cae4 + 1.0 / cbe4)) ^ 0.25)
    end

    local C_0 = 0.0
    do
        -- for C_0, the shape is independent of hue, so ST are constant. Values picked to roughly be the average values of ST.
        local C_a = L * 0.4
        local C_b = (1.0 - L) * 0.8

        -- Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.
        local cae2 = C_a * C_a
        local cbe2 = C_b * C_b
        C_0 = math.sqrt(1.0 / (1.0 / cae2 + 1.0 / cbe2))
    end

    return { C_0 = C_0, C_mid = C_mid, C_max = C_max }
end

-- Returns a smooth approximation of the location of the cusp
-- This polynomial was created by an optimization process
-- It has been designed so that S_mid < S_max and T_mid < T_max
function oklab.get_ST_mid(a_, b_)
    local S = 0.11516993
    local s_denom = 7.4477897 + 4.1590124 * b_
        + a_ * (-2.19557347 + 1.75198401 * b_
        + a_ * (-2.13704948 - 10.02301043 * b_
        + a_ * (-4.24894561 + 5.38770819 * b_ + 4.69891013 * a_)))
    if s_denom ~= 0.0 then
        S = 0.11516993 + 1.0 / s_denom
    end

    local T = 0.11239642
    local t_denom = 1.6132032 - 0.68124379 * b_
        + a_ * (0.40370612 + 0.90148123 * b_
        + a_ * (-0.27087943 + 0.6122399 * b_
        + a_ * (0.00299215 - 0.45399568 * b_ - 0.14661872 * a_)))
	if t_denom ~= 0.0 then
        T = 0.11239642 + 1.0 / t_denom
    end

	return { S = S, T = T }
end

function oklab.linear_srgb_to_oklab(c)
    local l = 0.4122214708 * c.r
            + 0.5363325363 * c.g
            + 0.0514459929 * c.b
	local m = 0.2119034982 * c.r
            + 0.6806995451 * c.g
            + 0.1073969566 * c.b
	local s = 0.0883024619 * c.r
            + 0.2817188376 * c.g
            + 0.6299787005 * c.b

    local l_ = l ^ 0.3333333333333333
    local m_ = m ^ 0.3333333333333333
    local s_ = s ^ 0.3333333333333333

    return {
        L = 0.2104542553 * l_
          + 0.793617785 * m_
          - 0.0040720468 * s_,
        a = 1.9779984951 * l_
          - 2.428592205 * m_
          + 0.4505937099 * s_,
        b = 0.0259040371 * l_
          + 0.7827717662 * m_
          - 0.808675766 * s_ }
end

function oklab.okhsl_to_oklab(hsl)
	local l = hsl.l
    if l >= 1.0 then return { L = 1.0, a = 0.0, b = 0.0 } end
    if l <= 0.0 then return { L = 0.0, a = 0.0, b = 0.0 } end

    local s = hsl.s
    if s < 0.0 then s = 0.0 end
    if s > 1.0 then s = 1.0 end

    local h = hsl.h
    local h_rad = h * 6.283185307179586
    local a_ = math.cos(h_rad)
    local b_ = math.sin(h_rad)
    local L = oklab.toe_inv(l)

    local cs = oklab.get_Cs(L, a_, b_)
    local C_0 = cs.C_0
	local C_mid = cs.C_mid
	local C_max = cs.C_max

    local mid = 0.8
	local mid_inv = 1.25

    local C = 0.0
    local t = 0.0
    local k_0 = 0.0
    local k_1 = 0.0
    local k_2 = 0.0
    if s < mid then
        t = mid_inv * s

		k_1 = mid * C_0
        if C_mid ~= 0.0 then
		    k_2 = 1.0 - k_1 / C_mid
        end

        local k_denom = 1.0 - k_2 * t
		if k_denom ~= 0.0 then
            C = t * k_1 / k_denom
        end
    else
        local t_denom = 1.0 - mid
        if t_denom ~= 0.0 then
            t = (s - mid) / t_denom
        end

		k_0 = C_mid
        if C_0 ~= 0.0 then
		    k_1 = (1.0 - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0
        end

        local C_denom = C_max - C_mid
		k_2 = 1.0
        if C_denom ~= 0.0 then
            k_2 = 1.0 - k_1 / C_denom
        end

        local k_denom = 1.0 - k_2 * t
        if k_denom ~= 0.0 then
		    C = k_0 + t * k_1 / k_denom
        end
    end

    return {
        L = L,
        a = C * a_,
        b = C * b_ }
end

function oklab.okhsl_to_srgb(hsl)
    return oklab.oklab_to_srgb(oklab.okhsl_to_oklab(hsl))
end

function oklab.okhsv_to_oklab(hsv)
	local v = hsv.v
    if v <= 0.0 then return { L = 0.0, a = 0.0, b = 0.0 } end
    if v > 1.0 then v = 1.0 end

    local s = hsv.s
    if s < 0.0 then s = 0.0 end
    if s > 1.0 then s = 1.0 end

    local h = hsv.h
    local h_rad = h * 6.283185307179586
    local a_ = math.cos(h_rad)
    local b_ = math.sin(h_rad)

    local cusp = oklab.find_cusp(a_, b_)
	local ST_max = oklab.to_ST(cusp)
	local S_max = ST_max.S
	local T_max = ST_max.T
	local S_0 = 0.5
    local k = 1.0
    if S_max ~= 0.0 then
	    k = 1.0 - S_0 / S_max
    end

    -- first we compute L and V as if the gamut is a perfect triangle:

	-- L, C when v==1:
    local v_denom = S_0 + T_max - T_max * k * s
    local L_v = 1.0
    local C_v = 0.0
    if v_denom ~= 0.0 then
        L_v = 1.0 - s * S_0 / v_denom
	    C_v = s * T_max * S_0 / v_denom
    end

    local L = v * L_v
	local C = v * C_v

    --then we compensate for both toe and the curved top part of the triangle:
    local L_vt = oklab.toe_inv(L_v)
    local C_vt = 0.0
    if L_v ~= 0.0 then
        C_vt = C_v * L_vt / L_v
    end

    local L_new = oklab.toe_inv(L)
    if L ~= 0.0 then
        C = C * L_new / L
    end
    L = L_new

    local rgb_scale = oklab.oklab_to_linear_srgb({
        L = L_vt,
        a = a_ * C_vt,
        b = b_ * C_vt })
    local max_comp = math.max(
        rgb_scale.r,
        rgb_scale.g,
        rgb_scale.b, 0.0)
    local scale_L = 0.0
    if max_comp ~= 0.0 then
        scale_L = (1.0 / max_comp) ^ 0.3333333333333333
    end

	C = C * scale_L
    return {
        L = L * scale_L,
        a = C * a_,
        b = C * b_ }
end

function oklab.okhsv_to_srgb(hsv)
    return oklab.oklab_to_srgb(oklab.okhsv_to_oklab(hsv))
end

function oklab.oklab_to_linear_srgb(lab)
    local l_ = lab.L
        + 0.3963377774 * lab.a
        + 0.2158037573 * lab.b
	local m_ = lab.L
        - 0.1055613458 * lab.a
        - 0.0638541728 * lab.b
	local s_ = lab.L
        - 0.0894841775 * lab.a
        - 1.291485548 * lab.b

    local l = l_ * l_ * l_
    local m = m_ * m_ * m_
    local s = s_ * s_ * s_

    return {
        r = 4.0767416621 * l
          - 3.3077115913 * m
          + 0.2309699292 * s,
        g = -1.2684380046 * l
           + 2.6097574011 * m
           - 0.3413193965 * s,
        b = -0.0041960863 * l
           - 0.7034186147 * m
           + 1.707614701 * s }
end

function oklab.oklab_to_okhsl(lab)
    local L = lab.L
    if L >= 1.0 then return { h = 0.0, s = 0.0, l = 1.0 } end
    if L <= 0.0 then return { h = 0.0, s = 0.0, l = 0.0 } end

    local Csq = lab.a * lab.a + lab.b * lab.b
    if Csq > 0.0 then
        local C = math.sqrt(Csq)
        local a_ = lab.a / C
        local b_ = lab.b / C

        -- 1.0 / math.pi = 0.3183098861837907
        local h = 0.5 + 0.5 * math.atan(-lab.b, -lab.a) * 0.3183098861837907

        local cs = oklab.get_Cs(L, a_, b_)
        local C_0 = cs.C_0
        local C_mid = cs.C_mid
        local C_max = cs.C_max

        -- Inverse of the interpolation in okhsl_to_srgb:
        local mid = 0.8
        local mid_inv = 1.25

        local s = 0.0
        if C < C_mid then
            local k_1 = mid * C_0
            local k_2 = 1.0
            if C_mid ~= 0.0 then
                k_2 = (1.0 - k_1 / C_mid)
            end

            local t_denom = k_1 + k_2 * C
            local t = 0.0
            if t_denom ~= 0.0 then
                t = C / t_denom
            end

            s = t * mid
        else
            local k_0 = C_mid
            local k_1 = 0.0
            if C_0 ~= 0.0 then
                k_1 = (1.0 - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0
            end

            local C_denom = C_max - C_mid
            local k_2 = 1.0
            if C_denom ~= 0.0 then
                k_2 = 1.0 - k_1 / C_denom
            end

            local t_denom = k_1 + k_2 * (C - k_0)
            local t = 0.0
            if t_denom ~= 0.0 then
                t = (C - k_0) / t_denom
            end

            s = mid + (1.0 - mid) * t
        end

        return { h = h, s = s, l = oklab.toe(L) }
    else
        return { h = 0.0, s = 0.0, l = L }
    end
end

function oklab.oklab_to_okhsv(lab)
    local L = lab.L
    if L >= 1.0 then return { h = 0.0, s = 0.0, v = 1.0 } end
    if L <= 0.0 then return { h = 0.0, s = 0.0, v = 0.0 } end

    local Csq = lab.a * lab.a + lab.b * lab.b
    if Csq > 0.0 then
        local C = math.sqrt(Csq)
        local a_ = lab.a / C
        local b_ = lab.b / C

        -- 1.0 / math.pi = 0.3183098861837907
        local h = 0.5 + 0.5 * math.atan(-lab.b, -lab.a) * 0.3183098861837907

        local cusp = oklab.find_cusp(a_, b_)
        local ST_max = oklab.to_ST(cusp)
        local S_max = ST_max.S
        local T_max = ST_max.T
        local S_0 = 0.5
        local k = 1.0
        if S_max ~= 0.0 then
            k = 1.0 - S_0 / S_max
        end

        -- first we find L_v, C_v, L_vt and C_vt
        local t_denom = C + L * T_max
        local t = 0.0
        if t_denom ~= 0.0 then
            t = T_max / t_denom
        end
        local L_v = t * L
        local C_v = t * C

        local L_vt = oklab.toe_inv(L_v)
        local C_vt = 0.0
        if L_v ~= 0.0 then
            C_vt = C_v * L_vt / L_v
        end

        -- we can then use these to invert the step that compensates for the toe and the curved top part of the triangle:
        local rgb_scale = oklab.oklab_to_linear_srgb({
            L = L_vt,
            a = a_ * C_vt,
            b = b_ * C_vt })
        local scale_denom = math.max(
            rgb_scale.r,
            rgb_scale.g,
            rgb_scale.b, 0.0)
        local scale_L = 0.0
        if scale_denom ~= 0.0 then
            scale_L = (1.0 / scale_denom) ^ 0.3333333333333333
            L = L / scale_L
            C = C / scale_L
        end

        local toel = oklab.toe(L)
        C = C * toel / L
        L = toel

        -- we can now compute v and s:
        local v = 0.0
        if L_v ~= 0.0 then v = L / L_v end

        local s = 0.0
        local s_denom = ((T_max * S_0) + T_max * k * C_v)
        if s_denom ~= 0.0 then
            s = (S_0 + T_max) * C_v / s_denom
        end

        return { h = h, s = s, v = v }
    else
        return { h = 0.0, s = 0.0, v = L }
    end
end

function oklab.oklab_to_srgb(lab)
    local lrgb = oklab.oklab_to_linear_srgb(lab)
	return {
		r = oklab.srgb_transfer_function(lrgb.r),
		g = oklab.srgb_transfer_function(lrgb.g),
		b = oklab.srgb_transfer_function(lrgb.b) }
end

function oklab.srgb_to_okhsl(rgb)
    return oklab.oklab_to_okhsl(oklab.srgb_to_oklab(rgb))
end

function oklab.srgb_to_okhsv(rgb)
    return oklab.oklab_to_okhsv(oklab.srgb_to_oklab(rgb))
end

function oklab.srgb_to_oklab(srgb)
    return oklab.linear_srgb_to_oklab({
		r = oklab.srgb_transfer_function_inv(srgb.r),
		g = oklab.srgb_transfer_function_inv(srgb.g),
		b = oklab.srgb_transfer_function_inv(srgb.b) })
end

function oklab.srgb_transfer_function(a)
    if 0.0031308 >= a then
        return 12.92 * a
    else
        return 1.055 * (a ^ 0.4166666666666667) - 0.055
    end
end

function oklab.srgb_transfer_function_inv(a)
    if 0.04045 < a then
        return ((a + 0.055) * 0.9478672985781991) ^ 2.4
    else
        return a * 0.07739938080495357
    end
end

function oklab.to_ST(cusp)
	local L = cusp.L
    local C = cusp.C
    if L ~= 0.0 and L ~= 1.0 then
        return { S = C / L, T = C / (1.0 - L) }
    elseif L ~= 0.0 then
        return { S = C / L, T = 0.0 }
    elseif L ~= 1.0 then
        return { S = 0.0, T = C / (1.0 - L) }
    else
        return { S = 0.0, T = 0.0 }
    end
end

function oklab.toe(x)
    local y = 1.170873786407767 * x - 0.206
	return 0.5 * (y + math.sqrt(y * y + 0.14050485436893204 * x))
end

function oklab.toe_inv(x)
    local denom = 1.170873786407767 * (x + 0.03)
    if denom ~= 0.0 then
    	return (x * x + 0.206 * x) / denom
    else
        return 0.0
    end
end

return oklab
:: src/palette.lua
--[[pod_format="raw",created="2024-03-31 08:27:10",modified="2025-03-05 16:21:40",revision=3587]]
function set_color(c, code)
	poke4(0x5000 + 4 * c, code)
end


function get_color(c)
	return peek4(0x5000 + 4 * c)
end


function color_to_hex(c)
	return string.format("%06x", c)
end


function rebuild_pal(c)
	for c = 0, 63 do
		pal_code[c] = get_color(c)
		pal_okhsl[c] = oklab.color_to_okhsl(pal_code[c])
	end
end


function change_color_code(c, code)
	pal_code[c] = code
	pal_okhsl[c] = oklab.color_to_okhsl(pal_code[c])
	set_color(c, code)
end


function change_color(c, hue, sat, lum)
	local hsl = {
		h = hue or pal_okhsl[c].h,
		s = sat or pal_okhsl[c].s,
		l = lum or pal_okhsl[c].l,
	}
	hsl.h = mid(-1.0, hsl.h, 1.0)
	hsl.s = mid(0.0, hsl.s, 1.0)
	hsl.l = mid(0.0, hsl.l, 1.0)
	local code = oklab.okhsl_to_color(hsl)
	pal_code[c] = code
	pal_okhsl[c] = hsl
	set_color(c, code)
	return
end


function swap_colors(c1, c2)
	pal_code[c1], pal_code[c2] = pal_code[c2], pal_code[c1]
	pal_okhsl[c1], pal_okhsl[c2] = pal_okhsl[c2], pal_okhsl[c1]
	set_color(c1, pal_code[c1])
	set_color(c2, pal_code[c2])
end


function clear_colors()
	for c = 0, 63 do
		local code, lum
		if c == 7 then
			code = 0xffffff
			lum = 1.0
		else
			code = 0x000000
			lum = 0.0
		end
		pal_code[c] = code
		pal_okhsl[c] = { h = 0.0, s = 0.0, l = lum }
		set_color(c, code)
		locked[c] = (c == 0) or (c == 7)
		hidden[c] = false
		for row = 0, 3 do hidden_toggles[row] = false end
		for i = 0, #test_cube_colors - 1 do
			test_cube_colors[i] = { 1, 1, 1 }
		end
	end
	bg_color = 0
	blackest_color = 0
	whitest_color = 7
end


function restore_default_palette()
	for c = 0, 63 do
		code = peek4(0x5000 + 4 * (64 + c))
		set_color(c, code)
		pal_code[c] = code
		pal_okhsl[c] = oklab.color_to_okhsl(code)
		locked[c] = c <= 31
		hidden[c] = false
		for row = 0, 3 do hidden_toggles[row] = false end
		test_cube_colors = copy(default_test_cube_colors)
	end
	bg_color = 0
	blackest_color = 0
	whitest_color = 7
end


function find_blackest_and_whitest()
	local min_lum = 1.0
	local best_black = 0
	local max_lum = 0.0
	local best_white = 1
	for c = 0, 63 do
		if pal_okhsl[c].l < min_lum then
			best_black = c
			min_lum = pal_okhsl[c].l
		end
		if pal_okhsl[c].l > max_lum then
			best_white = c
			max_lum = pal_okhsl[c].l
		end
	end
	return best_black, best_white
end
:: src/soft_wrap.lua
--[[pod_format="raw",created="2025-03-07 11:09:14",modified="2025-03-07 15:15:47",revision=398]]
function soft_wrap(text, width)
	local space_width <const> = print(" ", -1000, -1000) + 1000
	local lines = {}
	local line = ""
	local x = 0
	local indentation = 0 -- indentation of the current paragraph

	local function add_word(word)
		local dx = print(word, -1000, -1000) + 1000
		if x + space_width + dx >= width then
			add(lines, line)
			line = ""
			x = 0
			for i = 1, indentation do
				line ..= " "
				x += space_width
			end
			line ..= word
			x += dx
		else
			if line:find("^%s*$") then
				line ..= word
				x += dx
			else
				line ..= " " .. word
				x += space_width + dx
			end
		end
	end
	
	local function add_line()
		add(lines, line)
		line = ""
		x = 0
	end
	
	local in_paragraph = false
	local in_code = false
	local ignore_word = false
	local ignore_line = false
	add_line()
	for hard_line in text:gmatch("([^\n]*)\n?") do
		ignore_line = false
		ignore_word = false
		if hard_line:find("^%s*$") then
			if in_paragraph then
				add_line()
				add_line()
				in_paragraph = false
				indentation = 0
			end
		elseif hard_line:find("^%s*- ") then
			if in_paragraph then
				add_line()
			end
			add_word("-")
			indentation = 2
			in_paragraph = true
			ignore_word = true
		elseif hard_line:find("^```%s*$") then
			if line ~= "" then
				add_line()
			end
			in_code = not in_code
			ignore_line = true
		else
			in_paragraph = true
 		end
 		
 		if not ignore_line then
	 		if in_code then
	 			line = hard_line
	 			add_line()
	 		else
				for word in hard_line:gmatch("([^%s]*)%s?") do
					if ignore_word then
						ignore_word = false
					else
						add_word(word)
					end
				end
			end
		end
	end
	add_line()
	
	return lines
end
:: src/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTAzIDE4OjA3OjM0Iixtb2RpZmllZD0iMjAyNS0w
My0wNyAxNToxNTo0OCIsc3RvcmVkPSIyMDI0LTA0LTAzIDE4OjA3OjM0Il1d
:: label.qoi
b64$cW9pZgAAAeAAAAEOBAH_--Ho-f39-f39-f3T-rkAPvI-wf6iiHnMP-39-f39-cUSxD-X-rkA
Ps8-wBLOP8ASzz-_ooh5zj-9-f39zBLAP8ASwD-HEsE-wBLBP8sSwT-IEsQ-xhLGP8kSPxI-3RLF
P8YSxT-H-rkAPs4-EsA-Es4-Es8--qKIec4--f39-csSwD-CEsA-xhLBP8ASwT-GEsI-EsE-yBI-
whI-xhLGP8oSP8n_uQA_xj-P-qKIeT8SP9b_uQA_zj8SP8ASwz-BEsE-wBLBPxLPP-6iiHnOP-39
-f3LEsA-whLAP8YSwT-AEsE-xhLCPxLBP8gSP8ISP8YSxj-GEsc-xf65AD7CP8ESP8v_ooh5wT8S
wT-GEsU-x-65AD7OP8ASPxLDPxLAPxLCPxLAPxLPP-6iiHnGPxLFP-39-f3LEsA-whLAP8YSxj-G
EsI-zBI-whI-xhLGP8YSwD-DEsA-xf65AD7CP8ESP8v_ooh5PxI-2v65AD7OPxLAPxLDPxLAPxLA
P8ESwD8Szz-_ooh5xT-BEsQ--f39-csSwD-CEsA-xhI-EsI-Ej-GEsU-yRI-wBLBP9YSwD-DEsA-
xf65AD4-wRLCP8v_ooh5xT-GEsU-x-65AD7OPxLAPxLDP8ESwD8SwD8SwD8Szz-_ooh5xj8SxT-9
-f39yxLAP8ISwD-GEj8Swj8SP8YSxT-HEsE-wBLBP8YSxj-GEsA-wxLAP8X_uQA_P8ESwj-M-qKI
ecQ-1v65AD7PP8ASwT8SwD8Swz-BEsA-wBLOP-6iiHnOP-39-f3MEsA-wBLAP8cSxj-GEsU-xxLB
P8sSwD-CEsA-xhLHP8X_uQA_xj-qEtc-Eto--qKIec4--f39-f394-65AD70P-6iiHnOP-39-f39
-f4AAAD9-f39-f39-f39-f39-f39-f39-f39-f39-f39-f39-f39-f3iPzU-NT81PzU-NT81xT81
PzU-NT81PzU-NdE-1TXDP9Y1-f39-f39xT81yj81wj81yj81zj-XNcE-NdY-Ne0--f39xjXfPzU-
NcM-Ncc-NT81PzXNPzU-Nf3NPzXPPzXNP9c1wT811j817T81yv4dK1PK-n4lU8r_AIdRyv6rUjbK
-l9XT8r_wsPHyj-K-v8ATcr_-6MAyv7-7CfK-gDkNsr_Ka3-yv6DdpzK-v93qMr_-8yqyj81-f3K
PzXPPzXbP9k1PzXYPzXsPzXKKMotyg-K-qtSNsouyjvKP8oNyiHKH8ojyv4prf-KEModyhTKPzXd
PzXDPzXBPzXHPzXDPzXNPzX9xT81PzU-NcE-NcQ-NT81PzXEPzXMP8M1wD81PzU-NcE-NcE-wDXA
P8I1PzXCP8E1P8E1P8E1P8A1wT-ANcE-NeI-wjXEPzXKKMotyg-K-qtSNsouyjvKP8oNyiHKH8oj
yv4prf-KEModyhTKPzX9-co-NcM-NT81wT81wz81wD81wT81PzXRP8M1P8E1PzU-NT81PzU-wTU-
xTXDPzU-NT81PzU-wTU-NT81PzXEPzXgP8Q1wz81yijKLcoPyv6rUjbKLso7yj-KDcohyh-KI8r_
Ka3-yhDKHcoUyj813T81wz81wT81wz81wT81wz81wz81PzXFPzX9wz81PzXFPzXIPzU-NcI-Ncs-
wzU-wTU-NT81wD-ANcA-wDXBP8M1wz-ANcA-wTU-NT81P8A1wD-BNcI-Nd8-xjXCPzXKKMotyg-K
-qtSNsouyjvKP8oNyiHKH8ojyv4prf-KEModyhTKPzX9-co-NcM-Nck-NcY-NdA-xDU-wTU-NT81
PzU-NT-DNT-ENcI-NT81PzU-NT81PzU-NcM-NcM-Nd0-wDU-wDU-NT-ANcE-Ncooyi3KD8r_q1I2
yi7KO8o-yg3KIcofyiPK-imt-8oQyh3KFMo-Nd0-NcM-NcE-NcE-NcM-NT81PzXJPzXDPzX9wT81
PzU-NT81wz81xj81PzU-NT81wD81yj-FNcA-wDXAPzXBPzXBPzXAP8U1wj81PzU-NT81PzU-NT81
wT-ANcQ-Nd0-NcA-wjXAPzXBPzXKKMotyg-K-qtSNsouyjvKP8oNyiHKH8ojyv4prf-KEModyhTK
PzX9-co-NcE-NT81PzXHPzXEPzU-NT81zT-fNdo-Nd0-NcA-wDXAPzXCPzXKKMotyg-K-qtSNsou
yjvKP8oNyiHKH8ojyv4prf-KEModyhTKPzXdPzXDPzXBPzU-NcU-Nck-NT81PzXDPzXHP8A1xD-B
NcM-wTXlPzU-NcU-Ncg-NT81wj81yT-fNdo-Nd4-NcI-NcM-Ncooyi3KD8r_q1I2yi7KO8o-yg3K
IcofyiPK-imt-8oQyh3KFMo-Nf3UPzXEPzU-NcM-NeI-NcM-Nck-NcY-Nc4--dQ1yj-CNcQ-Ncoo
yi3KD8r_q1I2yi7KO8o-yg3KIcofyiPK-imt-8oQyh3KFMo-Nd0-NcM-NcE-NcE-NcM-Ncc-NcM-
NcM-Ncg-NcQ-NT81wz-BNe8-Nc8-Nf30PzXKKMotyg-K-qtSNsouyjvKP8oNyiHKH8ojyv4prf-K
EModyhTKPzX91D81xD81PzXFPzXgPzXPPzX9-cU-Ncooyi3KD8r_q1I2yi7KO8o-yg3KIcofyiPK
-imt-8oQyh3KFMo-Nd8-NT81wz81wz81wT81yT81PzU-NcM-NT81xT-BNcA-NcA-wTXAPzXAP8E1
4T81yj81wj81yj81-fU--iRjsMr_AKWhyv5lRojK-hJTWcr_dC8pyv5FLTLKEsr_-6zFyv65AD7K
-uJrAsr_lfBCyv4AslHK-mTf9sr_vZrfyv7kDavK-v_FV8o-Nf39zT81PzU-NT81PzU-NcU-NT81
PzU-NT81PzX99j8gyhXKOso5yhvKA8r_ooh5yjHK-rkAPsoAyjLKJso2ygfKD8osyj81-f39whTM
NcwszDXM-qtSNsw1zj-CNcQ-IMoVyjrKOcobygPK-qKIecoxyv65AD7KAMoyyibKNsoHyg-KLMo-
Nf39-cEUzAo1yyzMGzXLCswDNc0-xDXDPyDKFco6yjnKG8oDyv6iiHnKMcr_uQA_ygDKMsomyjbK
B8oPyizKPzX9-d4-yjXSFMwKwDXKLMwbwDXKCswDwDXMP8Y1wj8gyhXKOso5yhvKA8r_ooh5yjHK
-rkAPsoAyjLKJso2ygfKD8osyj81-f3dPzXKPzXQFMwKwTXJLMwbwTXJCswDwTXLP8A1P8A1PzU-
wDXBPyDKFco6yjnKG8oDyv6iiHnKMcr_uQA_ygDKMsomyjbKB8oPyizKPzX9-dw-Ncw-Nc4UzArC
NcgszBvCNcgKzAPCNcs-NcA-wjXAPzXBPyDKFco6yjnKG8oDyv6iiHnKMcr_uQA_ygDKMsomyjbK
B8oPyizKPzX9-dw-NcI-xDXCPzXNFMwKwzXHLMwbwzXHCswDwzXMPzXAP8A1wD81wj8gyhXKOso5
yhvKA8r_ooh5yjHK-rkAPsoAyjLKJso2ygfKD8osyj81-f3cPzXBP8E1wD-BNcE-NcwszArENcYK
zBvENcYbzAPENc0-NcI-NcM-IMoVyjrKOcobygPK-qKIecoxyv65AD7KAMoyyibKNsoHyg-KLMo-
Nf393D81wT-ANcI-wDXBPzXMLMwKxDXGCswbxDXGG8wDxDXOP8I1xD8gyhXKOso5yhvKA8r_ooh5
yjHK-rkAPsoAyjLKJso2ygfKD8osyj81-f3cPzXHP8A1wT81zCzMCsQ1xgrMG8Q1xhvMA8Q12D8g
yhXKOso5yhvKA8r_ooh5yjHK-rkAPsoAyjLKJso2ygfKD8osyj81-f3cPzXGP8A1wj81zCzMCsQ1
xgrMG8Q1xhvMA8Q12D8gyhXKOso5yhvKA8r_ooh5yjHK-rkAPsoAyjLKJso2ygfKD8osyj81-f3c
PzXFP8A1wz81zCzMCsQ1xgrMG8Q1xhvMA8Q12D81-f39xD813j81wD-BNT-BNT-BNcA-wDXAP8A1
wz-BNT-ANcQ-wTXAP8A1P8E1wz81PzU-wTU-NcE-wTXAPzXvPzXEP8A1xD81zCzMCsQ1xgrMG8Q1
xhvMA8Q12D81-f39xD813T81wT81PzU-NT81PzXBPzXBPzXFPzXCPzXEPzXBPzU-NT81PzXDPzU-
NT81wT81wT81PzXBPzXuPzXEP8A1xD81zCzMCsQ1xgrMG8Q1xhvMA8Q1zj-CNcQ-Nf39-cQ-Nd0-
NcE-wTU-wDXAP8A1wD-BNT-BNcM-wDXBPzXEP8A1wD81PzU-wDXEP8E1P8A1wD81wT-BNcE-Ne4-
Ncw-NcwszArENcYKzBvENcYbzAPENc0-xDXDPzX9-f3EPzXdPzXBPzXBPzU-NT81wz81wT81wz81
wj81xD81wT81PzU-NT81wz81PzU-NcE-NcE-NcM-Ne4-NcQ-wDXEPzXMLMwKwzXHCswbwzXHG8wD
wzXNP8Y1wj81-f39xD813j81wD81wT81PzU-wTU-wDXAP8A1xD81wT-BNcM-NcE-wDXAPzU-NcM-
NT81P8E1P8E1PzXCPzXvPzXMPzXMLMwKwjXICswbwjXIG8wDwjXNP8A1P8A1PzU-wDXBPzX9-f3E
PzX9-d0-Nco-Nc0szArBNckKzBvBNckbzAPBNc4-NcA-wjXAPzXBPzX9-f3EPzX9-d4-yjXOLMwK
wDXKCswbwDXKG8wDwDXQPzXAP8A1wD81wj81-f39xD81-f36LMwKNcsKzBs1yxvMAzXSPzXCPzXD
PzX9-f3EPzX9-foszDXMCsw1zBvMNdQ-wjXEPzX9-f3EPzX9-f395D81-f39xD81-f39-eQ-Nf39
-cQ-Nf39-f3kPzX9-f3EPzX9-f395D81-f39xD81-f39-do-wjXEPzX9-f3EPzX9-f392T-ENcM-
Nf39-cQ-Nf39-f3YP8Y1wj81-f39xD81-f39-dc-wDU-wDU-NT-ANcE-Nf39-cQ-Nf39-cIfzDXM
Icw1zA3MNcs-NcA-wjXAPzXBPzX9-f3EPzX9-f3BH8wANcshzBI1yw3MLTXMPzXAP8A1wD81wj81
-f39xD81-f39wB-MAMA1yiHMEsA1yg3MLcA1zT81wj81wz81-f39xD81-f39H8wAwTXJIcwSwTXJ
DcwtwTXOP8I1xD81-f39xD81-f38H8wAwjXIIcwSwjXIDcwtwjXYPzX9-f3EPzX9-fsfzADDNcch
zBLDNccNzC3DNdg-Nf39-cQ-Nf39_iHMAMQ1xgDMEsQ1xhLMLcQ12D-9-f3GNf39_iHMAMQ1xgDM
EsQ1xhLMLcQ1-f39-f393iHMAMQ1xgDMEsQ1xhLMLcQ1-f39-f393iHMAMQ1xgDMEsQ1xhLMLcQ1
-f39-f393iHMAMQ1xgDMEsQ1xhLMLcQ1-f39-f393iHMAMQ1xgDMEsQ1xhLMLcQ1-f39-f393iHM
AMQ1xgDMEsQ1xhLMLcQ1-f39-f393iHMAMQ1xgDMEsQ1xhLMLcQ1-ekbNf39-f3wIcwAwzXHAMwS
wzXHEswtwzX96hs1zwo1-f39-d4hzADCNcgAzBLCNcgSzC3CNf3aDTXOGzXPCjXBLDX9-f392iHM
AME1yQDMEsE1yRLMLcE1-dYSNcINNc4bNc8KNcEsNf39-f3aIcwAwDXKAMwSwDXKEswtwDX91xI1
wg01zhs1zgo1wiw1-f39-dohzAA1ywDMEjXLEswtNf3YEjXDDTXNGzXOCjXBLDX9-f392yHMNcwA
zDXMEsw1-doSNcINNc0bNc4KNcEsNf39-f39-f3BEjXCDTXNGzXOCjXBLDXOADX9-f39-f3fAzXM
EjXCDTXNGzXOCjXBLDXOADX_ooh5Nf39-f39-d0DNcz_uQA_NcINNc0bNc0KNcIsNc0ANcD_ooh5
Nf3VP-394zX9-eADNcv_uQA_NcMNNcwbNc0KNcEsNc4ANf6iiHk1wxQ1-dA-Nf394T81-f3gAzXM
-rkAPjXCDTXcCjXBLDXNADXA-qKIeTXDFDX90D81-f3hPzX9-dUdMTXIAzXL-rkAPjXCDTXgLDXN
ADX_ooh5NcMUNf3RPzX9-eE-Nf391h0xNccDNcv_uQA_NfQANcD_ooh5NcMUNf3RPzX9-d4-wjX9
-dYdMTXIAzX9wwA1EjXDFDX90j81-f3dP8M10DLMNcwjzDXMJsw1_x0xNccDNf3CADXAEjXDFDX9
0j81-f3cP8U1zjLMJjXLI8z_AIdRNcsmzDk1_x0xNcgDNc4NwTXbLME1zAA1EjXDFDX9xz-GNcI-
Nf393D-FNc0yzCbANcojzA-ANcomzDnANfwdMTXHAzXK-rkAPsENwzXDP881wyzDNc3_ooh5NcMU
Nf3TPzX9-dw-xTXMMswmwTXJI8wPwTXJJsw5wTX8HTE10-65AD7DDcM-wjXPP8IsxTXRFDX91D81
-f3dP8M1zDLMJsI1yCPMD8I1yCbMOcI18C01yh0xNdESxQ3CNdcsxTXRFDX91D81-f3ePx-BNcsy
zCbDNccjzA-DNccmzDnDNfEtNckdMTXREsUNwjXXLMU-wjXBAME1-d4-Nf393h-DNckjzCbENcYm
zA-ENcYPzDnENfEtNcodMTXNP8ESxQ3BNdkswzXDP8AAwzXcLjX8PzX9-d0fxTXII8wmxDXGJswP
xDXGD8w5xDXyLTXXP8E1whLDDcE12yzBNcUAxTXaLjXxH8Y1wj81-f3dH8U1yCPMJsQ1xibMD8Q1
xg-MOcQ18y011D-ANcYSwTXpAMU1wBTBNdQuNf3APzX9-d0fxTXII8wmxDXGJswPxDXGD8w5xDXz
LTXLMcE1wj-ANfYAxT8UwzXSLjXCITX6PzX9-d4fwzXJI8wmxDXGJswPxDXGD8w5xDX0LTXJMcM1
P8A1_QDDNRTFNdEuNcEhNfs-Nf393x-BNcojzCbENcYmzA-ENcYPzDnENfQtNcgxxTX8AME1wBTF
NdAuNcEhNfw-Nf394T81yiPMJsQ1xibMD8Q1xg-MOcQ19S01xzHFNf3DFMU-Nc4uNcEhNf0-Nf39
4T81yiPMJsQ1xibMD8Q1xg-MOcQ15P7kDas12DHFNf3EFMM1wD-ANcsuNcIhNf0-Nf393hTBPzXK
I8wmwzXHJsz_AIdRwzXHD8w5wzXm-uQNqzXXHTHDHTX9xRTBNcM-NckuNcIhNf3APzX9-d0UwzXK
I8wmwjXIJsz_AIdRwjXID8w5wjXo-uQNqzXUP8A1HTHBHTX9zz-ANcshNf3BPzX9-dwUxTXJI8wm
wTXJJsz_AIdRwTXJD8w5wTXq-uQNqzXSPzXCHcE1-dI-NckhNfQUxjXCPzX9-dEywTXGFMU1ySPM
JsA1yibM-gCHUcA1yg-MOcA17P7kDas1zz-ANf3bP8A1-cw-Nf390DLDNcUUxTXJI8wmNcsmzP4A
h1E1yw-MOTXt-uQNqzXOPzX93z81-cs-Nf39zzLFNcUUwzXKI8w1zCbMNcz_AIdRzDXv-uQNqzXM
PzX94T8hwTX5MsY1wj81-f3PMsU1xhTBPzX9-cYPNck-wDX94iHDNf3GPzX9-cg2wTXCMsU1yT81
-f3HDzXHPzX94yHFNf3FPzX9-cc2wzXCMsM1yj81-f3QPzX95CHFNf3FPzX9-cY2xTXCMsE1yz81
-f3PPzX95SHFNfc2xjXCPzX9-cY2xTXPMcE-Nf39zQ-BNf3mIcM1PzX9xD81-f3GNsU1zjHDNf39
zA-DNfkKwTXmIcE1wT81-cM-NcM7wTX9-TbDNc4xxTX9-coPxTX3CsM17D819DHGNcI-NcI7wzX9
-TbBNc8xxTX9-coPxTXuG8E1wwrFNew-Nf3BPzXBO8U1-f3SMcU1zzbMNcw2zDXM-imt-8w17j8P
xTXtG8M1wv6rUjbFNe0-NfI7xjXCPzXBO8U1-f3TMcM1zzbMOTXLNswgNcv_Ka3-zCg17T81wA-D
Ne0bxTXB-qtSNsU17j81-T81wTvFNf391DHBPzXONsw5wDXKNswgwDXK-imt-8wowDXsPzXCD8E1
7hvFNcL_q1I2wzXwPzX8PzXCO8M1-f3UI8M1zTbMOcE1yTbMIME1yf4prf-MKME16z819hvFNcP_
q1I2wTXyPzX7PzXDO8E1-f3UI8U1yzbMOcI1yDbMIMI1yP4prf-MKMI16z819xvDNfs-Ne8jxjXC
PzX9-dwjxSE1yTbMOcM1xzbMIMM1xwrMKMM16j81_RvBNf0-Ne4hxjXCPzX9-dwjxSE1yBXMOcQ1
xgrMIMQ1xiDMKMQ16T812y3BNf3fPzX5PzX9-d0jwyHANcgVzDnENcYKzCDENcYgzCjENeg-Ndst
wzX93z81_D81-f3eI8EhwDXJFcw5xDXGCswgxDXGIMwoxDXoPzXaLcU1-d4-Nfg-Nf393yHBNcoV
zDnENcYKzCDENcYgzCjENec-NdstxTX93z819z81-f3hPzXKFcw5xDXGCswgxDXGIMwoxDXmPzXc
LcU1-eA-NfY-Nf393izBPzXKFcw5xDXGCswgxDXGIMwoxDXmPzXdLcM1-eE-NfY-Nf3bB8E1_yzD
NcoVzDnENcYKzCDENcYgzCjENeU-Nd8twTX94z819T81-doHwzX5LMU1yRXMOcQ1xgrMIMQ1xiDM
KMQ15D81-f3LPzXoLMY1wj81-dkHxTX4LMU1yRXMOcM1xwrMIMM1xyDMKMM15T81-f3LPzXoB8Y1
wj81-dkHxTX4LMU1yRXMOcI1yArMIMI1yCDMKMI15T81-f3NPzXzPzX92QfFNfgdLMMdNckVzDnB
NckKzCDBNckgzCjBNeY-Nf39zT818z81-doHwzX6HSzBHTXKFcw5wDXKCswgwDXKIMwowDXmPzX9
-c8-NfI-Nf3bB8E1_grAHcEKwDXJFcw5NcsKzCA1yyDMKDXnPzX9-c8-NeYKxjXCPzX9-dwKxTXJ
Fcw1zArMNcwgzDXnPzX9-dE-NfE-Nf393ArFNf36PzX9-dE-NfE-Nf393QrDNf36PzX9-dM-NfA-
Nf393grBPzX9_j81-f3TPzXwPzX9-eE-Nf35PzX9-dU-Ne8-Nf394T81-fk-Nf391T817z81-f3h
PzX9_D81-f3XPzXuPzX9-d4mwT81-fg-Nf391z817j81-f3dJsM1-fg-Nf391z817j81-f3cJsU1
zzvMNcwHzDXMEMw13T81-f3ZPzXNH8A10CbGNcI-Nd3_ooh5wTX9_CbFNc47zBA1ywfMOjXLEMwo
Nd0-Nf392B-BNckfwTXSAMY1wj813BLDNf33JsU1zTvMEMA1ygfMOsA1yhDMKMA13T81-cs-Nf3J
H8M1xR-BNdUVxjXCPzXbEsU1-fYAJsMANcw7zBDBNckHzDrBNckQzCjBNdw-Nf3CA8E1-dAfxTXC
H8A12BLGNcI-NdsSxTX99hUAJsEAFTXLO8wQwjXIB8w6wjXIEMwowjXcPzX9wQPDNcQ-Nf3IH8U1
6j812xLFNf33FQDBFTXLO8wQwzXHB8w6wzXHEMwowzXcPzX9wAPFNf3OH8U16j813BLDNf33DcAV
wQ3ANckHzBDENcYQzDrENcY6zCjENdw-Nf3AA8U1wz81-ckfwzXfDcY1wj813RLBNf33D8ENwzXJ
B8wQxDXGEMw6xDXGOswoxDXbPzX9wQPFNf3QH8E-Nes-Nf392g-DDcI1yQfMEMQ1xhDMOsQ1xjrM
KMQ12z81-cIDwzXEPzXCEsE1-cY-Nes-Nf392Q-FDcA1ygfMEMQ1xhDMOsQ1xjrMKMQ12z81-cMD
wTXJEsM1-cU-Nd8PxjXCPzX9-dkPxQ0-NcoHzBDENcYQzDrENcY6zCjENds-Nf3NPzXAEsU1-cQ-
Nes-NekQwTX96Q-FNT81ygfMEMQ1xhDMOsQ1xjrMKMQ12j81-dESxTX9xT816j816BDDNf3pD8M1
wD81ygfMEMQ1xhDMOsQ1xjrMKMQ1yQfENck-Nf3OPzXAEsU1-cU-Neo-NecQxTX96Q-BNcE-NcoH
zBDENcYQzDrENcY6zCjENc8HwzXEPzX90hLDNf3GPzXeEMY1wj815xDFNf3vPzXKB8wQwzXHEMw6
wzXHOswowzXbPzX9zj81whLBNf3HPzXqPzXnEMU1-e8-NcoHzBDCNcgQzDrCNcg6zCjCNdw-Nf39
3z816j816BDDNf3wPzXKB8wQwTXJEMw6wTXJOswowTXdPzXdB8E16j81wS7BNf3IPzXqPzXpEME1
-fE-NcoHzBDANcoQzDrANco6zCjANcw6xDXKPzXcB8M17C7DNf3HPzXqPzX9-eE-NcoHzBA1yxDM
OjXLOswoNdM6wzXEPzXcB8U16D81LsU1-cc-Nek-Nf393v4Ah1HBPzXKB8w1zBDMNcw6zDXfPzXc
B8U6wDXoLsU1-cc-Nek-Nf3q-qtSNsE17A-DNf3zPzXcB8U6wTXlPzUuxTX9xz816T81-ekKwzXq
D8U1-fI-Nd0HwzrDNecuwzX9yD813Q-GNcI-Nf3oCsU16Q-FNf3yPzXeB8E6xDXMEME10z81wS7B
Nf3JPzXdCsY1wj81-egKxTXpD8U1-fI-NeA6xTXLEMM1-eQ-Nek-Nf3oCsU16g-DNf3iEMk1xD81
4TrDNcsQxTXMO8E1wD81-c8-Nek-Nf3pCsM17A-BPzX98z814jrBNcwQxTXLO8M1-dE-Nek-Nf3q
CsE18D81-fM-NfMQxTU-NT81PzU-NT81PzvFPzU-NT81PzU-NT81PzU-NT81PzU-NT81PzX1PzXp
PzX9-eE-Nf3zPzX0EMM1yzvFNf3QPzXpPzX9-SDBNdr_uQA_wT810D-MNcwxzDXMHcw12T819RDB
Ncw7xT81-c8-Nek-Nf38IMM12BLDNc8-zB01yzHMEDXLHcw6Ndk-Nf3JO8M1-dE-Nek-Nf37IMU1
1hLFNc0-zB3ANcoxzBDANcodzDrANdk-Nf3KO8E1wD81-c8-Nd0SxjXCPzX9_yDFNdYSxTXMP8wd
wTXJMcwQwTXJHcw6wTXZPzX9-eE-Nek-Nf37IMU11hLFNcs-zB3CNcgxzBDCNcgdzDrCNdk-Nf3P
PzX9zz816T81-fwgwzXYEsM1yz-MHcM1xzHMEMM1xx3MOsM12T81-f3hPzXpPzX9-SDBNdoSwT81
yjHMHcQ1xh3MEMQ1xv7kDavMOsQ12T81-c8-Nf3PPzXpPzXNLsE1-TrBNf3LPzXKMcwdxDXGHcwQ
xDXGD8w6xDXaPzX9-d8-Neo-NcwuwzX7OsM1-co-NcoxzB3ENcYdzBDENcYPzDrENdo-Nf3OPzX9
zj816j81yy7FNfk6xTX9yT81yjHMHcQ1xh3MEMQ1xg-MOsQ12j81-f3fPzXeOsY1wj81yy7FNfk6
xTX9yT81yjHMHcQ1xh3MEMQ1xg-MOsQ12j81-c4-Nf3OPzXqPzXLLsU1_TrFNf3JPzXKMcwdxDXG
HcwQxDXGD8w6xDXaPzX9-d8-Neo-NcwuwzX7OsM1-co-NcoxzB3ENcYdzBDENcYPzDrENdo-Nf3O
PzX9zj816j81zS7BNf06wTX9yz81yjHMHcQ1xh3MEMQ1xg-MOsQ12j81-f3UMsE1xj816j81-f3h
PzXKMcwdwzXHHcwQwzXHD8w6wzXcPzX9zT81-cIywzXEPzXrPzX97i3BNew-NcoxzB3CNcgdzBDC
NcgPzDrCNd0-Nf390TLFNcM-Nes-Nf3tLcM16z81yjHMHcE1yR3MEME1yQ-MOsE13j81-c0-Nf3B
MsU1wz816z81-ewtxTXJOcE13D81yjHMHcA1yh3MEMA1yg-MOsA13z81-f3RMsU1wz813y3GNcI-
Nf3lG8E1wi3FNcg5wzXbPzXKMcwdNcsdzBA1yw-MOjXhPzXiKME14z81-cIywzXDPzXsPzX95BvD
NcEtxTXHOcU12j81yjHMNcwdzDXMD8w14j814SjDNf3oMsE1xD814DnGNcI-Nf3jG8U1wS3DNcg5
xTXaPzX99j814CjFNeE-Nf3MPzXEMsA12BvGNcI-Nf3jG8U1wi3BNck5xTXaPzX99j814CjFNf3w
PzXGMsI14D81-eMbxTXROcM12z81-fc-Nd8oxTXhPzX9yz81yzLBNd0-Nf3kG8M10znBNdw-Nf33
PzXgKMM1-fA-Nc4ywDXbPzX95RvBNfU-Nf33PzXhKME1-fE-Ne0-Nf394T81-fg-Nf391z817j81
-f3hPzX9_D81-f3XPzXuPzX9-eE-Nf34PzX9-dc-Ne4-Nf394T810D-MNcw7zDXM-qKIecw13z81
-f3RI8E1PzXvPzX9-eE-Nc8-zBI1yzvMLjXLEswDNd8-Nf390CPDPzXvPzXoA8E1-fI-Nc4-zBLA
Nco7zC7ANcoSzAPANeA-Nf39ziPFNe8-NecDwzX98T81zT-MEsE1yTvMLsE1yRLMA8E14D81-f3O
I8U17z815gPFNf3wPzXMP8wSwjXIO8wuwjXIEswDwjXhPzX9-c0jxTXjA8Y1wj815gPFNf3wPzXL
P8wSwzXHO8wuwzXHEswDwzXYO8A1xT81-f3OI8M18D815gPFNf3wPzXKO8wSxDXGEswuxDXGLswD
xDXWO8A1yD81-f3OI8E18T815wPDNeoowTX9wj81yjvMEsQ1xhLMLsQ1xi7MA8Q11DvANco-Nf39
yibBNcA-NcUjNeo-NegDwTXqKMM1-cE-Nco7zBLENcYSzC7ENcYuzAPENdI7wDXNPzX9-cgmwz81
xyPANeg-Nf3YKMU1-cA-Nco7zBLENcYSzC7ENcYuzAPENdA7wDXPPzX9-ccmxTXJI8A12ijGNcI-
Nf3YKMU1-cA-Nco7zBLENcYSzC7ENcYuzAPENeQ-NdIgwTX97SbFNcsjwDXkPzX92CjFNf3APzXK
O8wSxDXGEswuxDXGLswDxDXkPzXRIMM1-ewmxTXNI8A14j81-dkowzX9wT81yjvMEsQ1xhLMLsQ1
xi7MA8Q15T81zyDFNf3sJsM10CM14T81-doowTX9wj81yjvMEsQ1xhLMLsQ1xi7MA8Q15j81ziDF
Nf3tJsE19T81-f3hPzXKO8wSwzXHEswuwzXHLswDwzXnPzXOIMU1-e4-NfY-Nf394T81yjvMEsI1
yBLMLsI1yC7MA8I14Sg1xT81ziDDNf3p-gCHUcE1wD81xiY17j81-f3hPzXKO8wSwTXJEswuwTXJ
LswDwTXgKMA1xz81ziDBNf3pD8M-NcgmwDXsPzX9-eE-Nco7zBLANcoSzC7ANcouzAPANeAoNck-
Nf37D8U1yiY16z81-f3hPzXKO8wSNcsSzC41yy7MAzXfKMA1yz81-foPxTXLJsA16T81-f3hPzXK
O8w1zBLMNcwuzDXfKDXOPzX9_Q-FNc0mwDXnPzX9-eE-Nf3xKMA10D81-fkPwzXQJjXLPzXBPzXU
PzX9-eE-Nf3wKDXSPzX9_g-BNd8-NT81PzXUPzX9-eE-Nf39yD81-fk-NeE-wzXUPzX9-eE-Nf39
yT81-fc-Nf0-Nf394T81-f3KPzX99T81xg812j81wT811D81-f3hPzX9-cs-Nf3zPzXIDzXZPzXB
PzXUPzX9-eE-Nf39zD81-fE-NcoPwDXYP8E11T81-f3hPzX9-c0-Nf3vPzXNDzXxPzX9-eE-NdAo
zDXMKMw1zCjMNfI-Nf3tPzXPDzXWP8I11D81-f3hPzXPKM01yyjNNcsozTXzPzX96z810Q-ANdM-
Ndg-Nf394T81zijONcoozjXKKM416iA1xz819jnBNew-NdQPNdI-wzXUPzX9-eE-Nc0ozzXJKM81
ySjPNekgNck-NfQ5wzXqPzX9xz81-f3hPzXMKNA1yCjQNcgo0DXnIMA1yz-ANcH_Ka3-wTXrOcU1
5z-ANes-wzXUPzX9-eE-Ncso0TXHKNE1xyjRNeYgNc8-NQrDNeo5xTXmPzXtPzU-NdY-Nf394T81
yijSNcYo0jXGKNI15SA10QrFNeI2wTXCOcU15T817j-DNdQ-Nf394T81yijSNcYo0jXGKNI14yDA
NdIKxTXhNsM1wjnDNeQ-wDX9zD81-f3hPzXKKNI1xijSNcYo0jXiIDXUCsU14DbFNcI5wTXkPzXy
P8I11D81-f3hPzXKKNI1xijSNcYo0jX6CsM14TbFNek-wDXyPzXYPzX9-eE-Ncoo0jXGKNI1xijS
NfsKwTU-NeA2xTXoPzX0P8M11D81-f3hPzXKKNI1xijSNcYo0jX9wj-ANd82wzXnP8A1-dI-Nf39
4T81yijSNcYo0jXGKNI1-cQ-wDXeNsE15j-ANfc-NcE-NdQ-Nf394T81yijSNcYo0jXGKNI1-cY-
wDX9xz-ANfk-wzXUPzX9-eE-Ncoo0TXHKNE1xyjRNfoKNco-wDX1FcE1xz-ANfs-NcE-NdQ--f3j
Ncoo0DXIKNA1yCjQNfoKNc0-wDXyFcM1xD-ANf39-f3NKM81ySjPNckozzXXPzXhCjXPP8A17xXF
NcE-wDX9wT-DNf39-ccozjXKKM41yijONdc-wTXfCjXSP8E17BXFP8E1-cM-wDX9-f3KKM01yyjN
NcsozTXXP8M13Qo11j-BNekVxTX9xj-DNf39-ccozDXMKMw1zCjMNdo-Nd8KNdk-wjXlPxXDNf3p
OzXHLjXNEjXIAxA14zo1xigHNccbNcL_q1I2NcEtNcwgOTXFNjXGMjXH-uQNqzXALB81-e8-Nd7_
Ka3-Nd4-wjXdP8I1wBXBNf3IP8M12zs1xy41zRI1yAMQNeM6NcYoBzXHGzXC-qtSNjXBLTXMIDk1
xTY1xjI1xw81wCwfNf3vPzXd-imt-zXjP8U1zz-FNf3VPzXbOzXHLjXNEjXIAxA14zo1xigHNccb
NcL_q1I2NcEtNcwgOTXFNjXGMjXHDzXALB81-fA-Ndz_Ka3-Neo-zzX92D-CNdw7NccuNc0SNcgD
EDXjOjXGKAc1xxs1wv6rUjY1wS01zCA5NcU2NcYyNccPNcAsHzX98D812-4prf81-f36OzXHLjXN
EjXIAxA14zo1xigHNccbNcL_q1I2NcEtNcwgOTXFNjXGMjXHDzXALB81-fA-Nf39_j812zs1xy41
zRI1yAMQNeM6NcYoBzXHGzXCCjXBLTXMIDk1xTY1xjI1xw81wCwfNf3xPzX97BU1-co-Nds7Nccu
Nc0SNcgDEDXjOjXGKAc1xxs1wgo1wS01zCA5NcU2NcYyNccPNcAsHzX9wT-TNdk-Nf3sFTX9xj-D
Nds7NccuNc0SNcgDEDXjOjXGKAc1xxs1wgo1wS01zCA5NcU2NcYyNccPNcAsHzX9wD810z812T81
-esVNf39-f39yD811T812T81-esVNf39-f39xz81wT-ANT81wT-BNT-BNT-ANcE-Ndo-Nf3KNjXJ
OTXRFTX9-f39-cc-NcA-NcE-NcE-NcE-NT81PzU-NcA-Nds-wDXEPzX9wTY1yTk10RU1-cc-Nf39
-fs-NcA-NcE-NcE-wDXAP8E1P8A1wT813T-BNcE-wDX9wDY1yTk10RU1-cY-wTX9-f36PzXAPzXB
PzXBPzXBPzU-NT81PzXAPzXgP8Q1-TY1yTk10RU1-cU-wzX9-f35PzXBP8A1P8E1P8E1PzU-NT81
PzXAPzXjP8A1-cA2Nck5NdIVNf3GPzX9-f37PzXVPzXjPzX9wTY1yTk10hU1-cY-Nf39-fw-NdM-
Nf3oNjXKOTXRFTX9xj81-f39-T-TNdE-NT81PzU-NT-BNf3LNjXKOTX92j81wz81xD-ANT-BNT-B
NT81PzU-wTU-wTU-wTU-wTXAP8A1P8A1-f399D81PzU-NT81PzX9zTY1yjk1-do-NcM-wDXCPzXB
PzU-NcA-NcA-NT81PzU-NT81PzXAPzXBPzXAPzU-NT81PzX9-f3zP8E1PzU-NT-ANf3MNjXKOTX9
2j-HNcE-wTU-wTXAPzXAPzU-NT-ANcA-wTXAPzXBPzXAPzU-NT81PzX9-f3zPzU-NT81PzU-Nf3N
NjXKOTX94D-ANcQ-NT81PzXAPzXAPzU-NT81PzU-NT81wD81wT81wD81PzU-NT81-f398z81PzXA
P8A1P8E1-f37PzXDP8A1wD81PzXAPzXBP8A1PzU-NT81PzXAPzXAP8E1P8A1wD81PzX9-f39-f39
-f39-d0AAAAAAAAAAQ==
:: main.lua
--[[pod_format="raw",created="2024-03-31 05:33:06",modified="2025-03-07 15:15:47",revision=6406]]
include "src/globals.lua"
include "src/oklab.lua"
include "src/palette.lua"
include "src/gui.lua"
include "src/gui_palette.lua"
include "src/gui_sliders.lua"
include "src/gui_settings.lua"
include "src/gui_help.lua"
include "src/gui_newfile.lua"
include "src/gui_hexdialog.lua"
include "src/soft_wrap.lua"


function _init()
	register_as_default_app()

	window {
		tabbed = true,
		icon = --[[pod_type="gfx"]]unpod("b64:bHo0ABYAAAAUAAAA8AVweHUAQyAICARwtyBHIBcgRyC3cA=="),
	}
	
	local working_file_path = env()[1]
	if type(working_file_path) ~= "string" then
		mkdir("/ram/cart/pal")
		working_file_path = "/ram/cart/pal/0.pal"
	end

	wrangle_working_file(
		save_working_file,
		load_working_file,
		working_file_path
	)
	
	-- Force the 11 first rows of the screen to use a default palette,
	-- so that the menu bar stays readable even when the colors used by
	-- the gui are redefined.
	poke(0x5400, 0b01010101, 0b01010101, 0b00010101)
	
	rebuild_pal()
	
	on_event("gained_visibility", function() send_palette() end)
		
	on_event("drop_items", handle_drop_items)
	
	undo_stack = create_undo_stack(undo_save_state, undo_load_state)

	menuitem { id = "okpal_div1", label = "", divider = true, action = function() end }
	menuitem {
		id = "okpal_reset_colors",
		label = "\^:0000000000000000 Picotron Palette",
		action = function() undo_stack:checkpoint(); restore_default_palette() end
	}
	menuitem {
		id = "okpal_clear_colors",
		label = "\^:0000000000000000 Empty Palette",
		action = function() undo_stack:checkpoint(); clear_colors() end
	}
	menuitem { id = "okpal_div2", label = "", divider = true, action = function() end }
	menuitem {
		id = "okpal_manual",
		label = "\^:0000000000000000 Help",
		shortcut = "F1",
		action = open_help
	}
	
	test_cube_colors = test_cube_colors or copy(default_test_cube_colors)
	test_ramp_colors = test_ramp_colors or default_test_ramp_colors:convert("u8")
	generate_gui()
	
	if is_new_file then
		open_new_file_dialog()
	end
	
	if imported_hex_file then
		open_import_hex_file_dialog()
	end
end


function _draw()
	cls(bg_color)
	gui:draw_all()
end


function _update()
	if padlock_flashing then
		padlock_flashing_time += 1
	end
	
	gui:update_all()
	
	if key("ctrl") then
		if (keyp("c")) copy_color()
		if (keyp("x")) cut_color()
		if (keyp("v")) paste_color()
		if (keyp("z")) undo_stack:undo()
		if (keyp("y")) undo_stack:redo()
	end
	
	if (key("f1")) open_help()
end


function register_as_default_app()
	local okpal_path = env().argv[0]

	-- Prevent registering the wrong path when
	-- developing OkPal.
	if okpal_path == "/system/apps/terminal.lua" then
		return
	end
	
	if fstat("/system/util/default_app.lua") ~= "file" then
		return
	end

	local default_apps = fetch("/appdata/system/default_apps.pod") or {}
	if default_apps["pal"] == nil then
		create_process(
			"/system/util/default_app.lua",
			{
				argv = { "pal", okpal_path },
			}
		)
	end
	if default_apps["hex"] == nil then
		create_process(
			"/system/util/default_app.lua",
			{
				argv = { "hex", okpal_path },
			}
		)
	end
end


-- From Eiyeron's fork #eyn_okpal_fork-0
function find_gfx_map_pids()
	local matching_pids = {}
	for process in all(fetch "/ram/system/processes.pod") do
		local name <const> = process.name
		if name == "gfx" or name == "map" then
			matching_pids[#matching_pids + 1] = process.id
		end
	end
	return matching_pids
end


function send_palette()
	local palette = userdata("i32", 64)
	for c = 0, 63 do
		palette:set(c, get_color(c))
	end
	
	-- Updating the PID lists as we're sending the event
	-- to not miss new processes.
	for pid in all(find_gfx_map_pids()) do
		send_message(pid, { event = "set_palette", palette = palette })
	end
end


-- Undo ---------------------------------------------------------------------------


function undo_save_state(_item)
	return {
		pal_okhsl = copy(pal_okhsl),
		pal_code = copy(pal_code),
		test_cube_colors = copy(test_cube_colors),
		test_ramp_colors = test_ramp_colors and test_ramp_colors:convert("u8"),
	}
end


function undo_load_state(state, _item)
	pal_okhsl = state.pal_okhsl
	pal_code = state.pal_code
	test_cube_colors = state.test_cube_colors
	test_ramp_colors = state.test_ramp_colors
	for c = 0, 63 do
		set_color(c, pal_code[c])
	end
	send_palette()
end


function copy(t)
	if type(t) == "table" then
		local new = {}
		for k, v in pairs(t) do
			new[k] = copy(v)
		end
		return new
	else
		return t
	end
end


-- Drag-and-drop ------------------------------------------------------------------


function handle_drop_items(msg)
	for i = 1, #msg.items do
		local item = msg.items[i]
		if item.pod_type == "file_reference" and item.attrib == "file" then
--			undo_stack:checkpoint()
--			send_message(pid(), { event = "open_file", filename = item.fullpath })
		local okpal_path = env().argv[0]
		-- Prevent registering the wrong path when
		-- developing OkPal.
		if okpal_path == "/system/apps/terminal.lua" then
			return
		end
		create_process(
			okpal_path,
			{
				argv = { item.fullpath },
			}
		)
		end
	end
end


-- Loading and saving -------------------------------------------------------------


function save_working_file()
	local ext = pwf():ext()
	if ext == "hex" or ext == "txt" then
		return save_hex_file()
	else
		if ext != "pal" then
			notify("unknown file extension: saved using default file format")
		end
		return save_pal_file()
	end
end


function load_working_file(data, metadata)
	
	if fstat(pwf()) ~= "file" then
		-- This is a new file
		create_metadata()
		is_new_file = true
		return
	end

	metadata = metadata or {}
	local ext = pwf():ext()
	if ext == "pal" then
		load_pal_file(data, metadata or {})
		if undo_stack then undo_stack:reset() end
		send_palette()

	elseif ext == "hex" or ext == "txt" then
		if metadata.okpal_version then
			current_import_choice = "overwrite"
			load_hex_file(data, metadata or {})
			if undo_stack then undo_stack:reset() end
			send_palette()
		else
			imported_hex_file = { data = data, metadata = metadata }
		end

	else
		notify("unkown file extension: OkPal can only load \".pal\" and \".hex\" palettes")
	end
end


-- Metadata ----------------------------------------------------------------------


function create_metadata()
	local metadata = {}
	metadata.okpal_version = okpal_version
	metadata.icon = userdata("u8",16,16,"0001010101010101010101000000000000010707070707070707060100000000000107070707070707070606010000000001070707070707070706060601000000010707070707070707060606060100000107070707070707070707070701000001070707070707070707070707010000010707060601010d0d01010707010000010707060601010d0d010107070100000107070101070706060d0d07070100000107070101070706060d0d07070100000107070d0d01010d0d060607070100000107070d0d01010d0d060607070100000107070707070707070707070701000001070707070707070707070707010000010101010101010101010101010100")
	metadata.bg_color = bg_color
	metadata.blackest_color = blackest_color
	metadata.whitest_color = whitest_color
	metadata.hidden_toggles = hidden_toggles
	metadata.hidden = copy(hidden)
	metadata.locked = copy(locked)
	metadata.test_mode = test_mode
	metadata.test_cube_colors = copy(test_cube_colors)
	metadata.test_ramp_colors = test_ramp_colors and test_ramp_colors:convert("u8")
	return metadata
end


function load_metadata(metadata)
	metadata = metadata or {}
	bg_color = metadata.bg_color or 0
	blackest_color = metadata.blackest_color or 0
	whitest_color = metadata.whitest_color or 7
	
	if type(metadata.hidden_toggles) == "table" then
		hidden_toggles = metadata.hidden_toggles
	else
		hidden_toggles = {}
		for row = 0, 3 do
			hidden_toggles[row] = false
		end
	end
	
	if type(metadata.hidden) == "table" then
		hidden = metadata.hidden
	else
		hidden = {}
		for c = 0, 63 do
			hidden[c] = false
		end
	end
	
	if type(metadata.locked) == "table" then
		locked = metadata.locked
	elseif pwf() == "/ram/cart/pal/0.pal" then
		-- This only occurs when a default starting file
		-- is created.
		for c = 0, 63 do
			locked[c] = c <= 31
		end
	else
		locked = {}
		for c = 0, 63 do
			locked[c] = false
		end
	end

	if type(metadata.test_mode) == "string" then
		test_mode = metadata.test_mode
	else
		test_mode = "cubes"
	end

	if type(metadata.test_cube_colors) == "table" then
		test_cube_colors = copy(metadata.test_cube_colors)
	else
		test_cube_colors = copy(default_test_cube_colors)
	end
	
	if type(metadata.test_ramp_colors) == "userdata" then
		test_ramp_colors = metadata.test_ramp_colors:convert("u8")
	else
		test_ramp_colors = default_test_ramp_colors:convert("u8")
	end
end


-- Load and save pal files -------------------------------------------------------


function load_pal_file(data, metadata)
	if data then
		if type(data) == "userdata" and data:width() == 64 then
			for c = 0, 63 do
				if data[c] then
					set_color(c, data[c])
				end
			end
		else
			notify("unable to load working file")
			return
		end
	else
		-- New file
	end
	rebuild_pal()
	load_metadata(metadata)
end


function save_pal_file()
	local output = userdata("i32", 64)
	for c = 0, 63 do
		output:set(c, get_color(c))
	end
	return output, create_metadata()
end


-- Load and save hex files ---------------------------------------------------------


function load_hex_file(data, metadata)
	if type(data) == "string" then
		local lines = split(data, "\n", false)
		local codes = {}
		for l in all(lines) do
			local code = tonum("0x" .. l:gsub("%s",""))
			if type(code) == "number" then
				codes[#codes + 1] = code
			elseif code then
				notify("error importing hex file")
			end
		end
		local start = 0
		if current_import_choice == "dont_clobber" then
			-- TODO: put in separate function and add menu item
			for c = 0, 32 do
				set_color(c, peek4(0x5000 + 4 * (64 + c)))
			end
			start = 32
		end
		if #codes > 64 - start then
			notify("*** not enough space to import all the colors ***")
		end
		for c = start, 63 do
			if codes[c - start + 1] then
				set_color(c, codes[c - start + 1])
			else
				set_color(c, 0x000000)
			end
		end
		rebuild_pal()
	elseif data then
		notify("import hex file: unkown type: " .. type(data))
	end

	load_metadata(metadata)
	if current_import_choice == "dont_clobber" then
		active_color = nil
		for c = 0, 31 do
			hidden[c] = true
			locked[c] = true
		end
		hidden_toggles[0] = true
		hidden_toggles[1] = true
		blackest_color = 0
		whitest_color = 7
		bg_color = 0
	else
		local best_black, best_white = find_blackest_and_whitest()
		blackest_color = metadata.blackest_color or best_black
		whitest_color = metadata.whitest_color or best_white
		bg_color = metadata.bg_color or blackest_color
	end
end


function save_hex_file(filename)
	-- Don't export trailing black colors
	local fin = 63
	while fin > 0 and get_color(fin) == 0 do
		fin -= 1
	end
	
	local output = ""
	for c = 0, fin do
		output ..= color_to_hex(get_color(c)) .. "\n"
	end
	return output, create_metadata()
end


-- Copy and paste ----------------------------------------------------------------


function copy_color()
	if active_color then
		set_clipboard("#" .. color_to_hex(get_color(active_color)))
	end
end


function cut_color()
	if active_color then
		set_clipboard("#" .. color_to_hex(get_color(active_color)))
		if not locked[active_color] then
			 undo_stack:checkpoint()
			change_color_code(active_color, 0x000000)
		end
	end
end


function paste_color()
	if not active_color then
		notify("unable to paste: no selected color")
		return
	end
	if locked[active_color] then
		notify("unable to paste: selected color is locked")
		return
	end
	local cb = get_clipboard()
	if type(cb) == "string" then
		local hex = string.gsub(cb, "%s", "")
		if sub(hex, 1, 1) == "#" then
			hex = sub(hex, 2, -1)
		end
		local code = tonumber("0x" .. hex)
		if type(code) == "number" then
			undo_stack:checkpoint()
			change_color_code(active_color, code)
		else
			notify("unable to paste: unrecognized string: \"" .. cb .."\"")
		end
	else
		notify("unable to paste: type not supported (" .. type(cb) .. ")")
	end
end


--------------------------------------------------------------------------------


function clear_cube_colors()
	for i = 0, #test_cube_colors - 1 do
		test_cube_colors[i] = { 1, 1, 1 }
	end
end


function clear_ramp_colors()
	for i = 0, test_ramp_colors:width()-1 do
		for j = 0, test_ramp_colors:height()-1 do
			test_ramp_colors:set(i, j, bg_color)
		end
	end
end
:: manual.txt
--[[pod_format="raw",created="2024-04-04 06:47:16",icon=userdata("u8",16,16,"00000101010101010101010101000000000106060606060606060606060100000107010606060606060606060606010000010106060707070707070707060100000106060607070707060606070601000107010606070707070606060706010000010106060706060607070707060100000106060607060606070707070601000107010606070707070707070706010000010106060606060606060606060100000106060606060606060606060601000107010606060606060606060601010000010101010101010101010101070100000101070707070707070707070601000000010606060606060606060601000000000001010101010101010101000000"),modified="2025-03-07 15:15:04",revision=421,stored="2024-04-04 06:56:33"]]
# OkPal

OkPal is a tool to create and edit color palettes. You can easily use those palettes in your programs, and even directly in Picotron's sprite and map editors.

To use a palette in your programs:

```
    fetch("pal/0.pal"):poke(0x5000)
```


## Features

- Any change to the palette is propagated to
  Picotron's sprite and map editors.
- Use a perceptually uniform color space (oklab).
- Choose colors by hue, saturation and lightness.
- Reorder colors by drag-and-drop.
- Undo/redo.
- Supports two file formats: ".hex" and ".pal"
- Multiple options for importing external palettes
  (keep default palette, overwrite it, or try to 
  match it)


## Usage

The tool shows you four different views of the 64
colors in the current palette:

- at the top-left of the screen, the colors are
  shown in palette order (same as in sprite editor
  first tab);
- below, on the left, the colors are shown inside
  a circle picker: the angle correspond to the hue,
  and the distance from the center correspond to the
  saturation;
- in the middle the colors are shown as inside a
  square picker: the X axis correspond to the
  saturation, and the Y axis correspond to the
  lightness;
- finally, on the right is a "test zone", where
  you can use 24 paintable cubes to test color
  combinations.

To modify a color, you must first select it. You can
do that either by clicking in the palette overview
at the top of the screen, or by clicking directly on
one of the color dots in the circle picker or in the
square picker.

Once selected, some information about the color are
displayed on the right of the palette overview:

- the color number;
- the hex code corresponding to the RGB values of
  the color;
- a padlock icon: if the padlock is closed, the color
  is "locked" and cannot be edited; click on the icon
  to lock/unlock it;
- an eye icon: if the eye is closed, the color is only
  shown in the palette overview; it is hidden in the
  circle and square pickers.
- a paint bucket icon: you can click on it to change
  the color background to the current selected color;
  click again to go back to a black background.

You can copy the current color by using Ctrl-C, and
paste a copied color onto the current one by using
Ctrl-V. This also works outside OkPal: the color is
stored in the clipboard as a hex code ("#ffacc5").

There is five different ways to adjust the selected
color:

- a small colored circle *outside* the circle picker
  allows you to change the hue of the color;
- a small colored circle *inside* the circle picker
  allows you to change at the same time the hue and
  the saturation;
- a small colored triangle below the square picker
  allows you to change just the saturation;
- a small colored triangle at the right of the square
  picker allows you to change the lightness;
- finally, a small colored circle inside the square
  picker allows you to change at the same time the
  saturation and the lightness.

Any change you make can be reverted by hitting
Ctrl-Z for undo. Use Ctrl-Y for redo.

Once you have several colors in you palettes, you can
reorder them in the palette overview: just drag one
color onto another, they will swap their positions.
Note that both colors must be unlocked.


## Using the palette in cartridges

By default, the palette you edit is saved in the
cart you're working on, alongside your sprite sheets
and maps.

The default path is "/ram/cart/pal/0.pal"

In order to use a palette in your programs, you just
need to copy it in memory. The default palette is
stored at address 0x5000:

```
    fetch("pal/0.pal"):poke(0x5000)
```


## Loading and saving

If you only need one palette for your cart, you
don't need to do anything special to save it. It is
saved alongside the rest of your assets each time
you hit Ctrl-S.

In order to create a new palette, use the '+' button
at the right of the tabs and choose the name of your
new palette, for example "1.pal". If you need to
start from scratch for this new palette, use
"Empty Palette" or "Picotron Palette" from the menu.

You can load a previously created palette by using
"Open File" in the menu.


## Importing and exporting

You can import and export palettes for use with
external tools. Currently the only supported format
is ".hex" files, which are simple text files with one
line per color, represented by their RGB code in hex
format (without "#" or "0x", just the hexadecimal
numbers).

To import a palette, choose "Open File" from the
menu, and select the ".hex" file. If this is the first
time you open this external palette in OkPal, a
dialog will appear to let you choose how to arrange
the colors in the palette. You can either:

- Keep default Picotron palette in the first 32 colors,
  and put the imported colors in the last 32 slots.
- Completely remove the Picotron palette and import
  the whole palette, but reorder the colors to try
  to match the default colors.
- Or simply import the palette as is. Note that this
  will affect the interface and probably make it
  difficult to use the menu, the sprite editor and
  the map editor.

To export a palette, choose "Save File As" in the
menu. In the save dialog, enter a file name ending
in ".hex".


## Changelog

2025-??-??: version 1.1.0 (release ?)

- removed remapping option when importing ".hex" palettes (was not working very well anyway);
- added text entries for the hex code, the hue, the saturation and the luminance;
- added a new tab for drawing color ramps in the test zone;
- added dialog when creating a new palette (to choose between empty palette or default colors);
- added blink;
- changed dialog when importing ".hex";
- fixed menu bar colors when default colors are redefined;

2025-02-26: version 1.0.4 (release #okpal-7)

- added registering as default app for ".pal" and ".hex" (needed for the file dialog?)
- added undo/redo and help buttons;
- added "clear" button to the "test cubes";
- added legends for the two pickers;
- changed: moved the luminance slider to the left of the sat/lum picker for consistency;
- fixed: palette is now propagated to all gfx and map editors (thanks to Eiyeron for the implementation);
- fixed: the "test cubes" saved in metadata where not properly loaded;


2024-08-23: version 1.0.3 (release #okpal-6)

- added: add file icon to saved palettes;
- changed: can load and import palettes by
  double-clicking in the file dialog (no need
  to drag-and-drop anymore);
- fixed: bug in BBS;

2024-05-03: version 1.0.2 (release #okpal-5)

- fixed: bug while using "+" button in Picotron
  0.1.0g;
- changed: disabled tabs in BBS, as it prevents
  the cart from running;

2024-04-27: version 1.0.1 (release #okpal-4)

- fixed: picotron's palette was not locked in the
  default file on first opening;
- fixed: saving a ".pal" file from an imported
  ".hex" file was not working;
- explain how to export to .hex in the manual;

2024-04-06: version 1.0.0 (release #okpal-3)

- propagate palette to sprite and map editors;
- undo/redo;
- reorder colors by drag-and-drop;
- import dialog;
- reorder imported colors to match default colors;
- added a manual;
- menu entries to initialize the palette and open
  the manual;
- flash padlock icon when trying to edit a locked
  color;
- shift-click paint-bucket icon to change the "white"
  color used in the interface, and ctrl-click the
  icon to change the "black" (useful when importing
  external palettes);

2024-04-02: version 0.0.3 (release #okpal-2)

- Added the ability to change the background color (by clicking on the small paint bucket icon), and switched the default background to black.
- Added the ability to import ".hex" files (using drag and drop from the "Open File" dialog); to actually create the ".pal" file, you need to save.
- Improved the color pickers.
- Added the ability to copy/paste colors (using a hex string starting with #).
- Added the ability to show/hide individual colors (right click on a color in the palette).

2024-04-01: v0.0.1 (release #okpal-1)

- Added the ability to lock colors, to avoid accidentally modifying them. By default the first 33 colors are locked (click on the padlock to unlock)
- Added the ability to hide specific rows of color from the two color pickers.
- Added sliders to change the individual components (hue, saturation and luminance).
- Added the ability to select a color by clicking on their dot in the color pickers.
- Added a test zone, with 24 paintable cubes (click on a cube face to change its color).


:: todo.txt
--[[pod_format="raw",created="2024-03-31 20:08:43",modified="2025-03-07 09:36:51",revision=884]]
- right click for fine-tuning colors;

Maybe:
- in-app gui for manual?
- multi-selection (ability to move a group of
  colors in the sliders)
- editing tools for multi-selection;
- Add another tab in the test zone, with the 
  hue/sat circle and sat/lum square, but filles
  with color zones instead of dots.
- remove locking mechanism?
- import the palette from an image saved by
  the #paint cartridge;

:: .info.pod
b64$LS1bW3BvZCxhdXRob3I9ImRyYWttYW5pc28iLGJic19pZD0iX2Rldjk3MiIsY3JlYXRlZD0i
MjAyNC0wNC0yNyAxMjozMDo1NCIsaWNvbj11c2VyZGF0YSgidTgiLDE2LDE2LCIwMDAwMDAwMTAx
MDEwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDAw
MTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwNzAxMDAwMTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwZDBk
MDcwMTAxMDcwZDBkMDEwMTA2MDYwNzA3MDYwNjBkMGQwNzAxMDEwNzBkMGQwMTAxMDYwNjA3MDcw
NjA2MGQwZDA3MDEwMTA3MGQwZDA2MDYwZDBkMDEwMTA3MDcwZDBkMDcwMTAxMDcwZDBkMDYwNjBk
MGQwMTAxMDcwNzBkMGQwNzAxMDEwNzBkMGQwNzA3MDYwNjA3MDcwMTAxMGQwZDA3MDEwMTA3MGQw
ZDA3MDcwNjA2MDcwNzAxMDEwZDBkMDcwMTAxMDcwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwNzAx
MDEwNjA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwNzA2MDEwMTA2MDYwNzA3MDcwNzA3MDcwNzA3MDcw
NzA2MDYwMTAwMDEwNjA2MDYwNjA2MDYwNjA2MDYwNjA2MDYwMTAwMDAwMDAxMDYwNjA2MDYwNjA2
MDYwNjA2MDYwMTAwMDAwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAwMDAwMCIpLG1vZGlmaWVk
PSIyMDI1LTAzLTA3IDE1OjE1OjQ4Iixub3Rlcz0iUGFsZXR0ZSBFZGl0b3Jcbih1c2UgbWVudSB0
byBvcGVuIHRoZSBtYW51YWwpIixydW50aW1lPTE0LHNhbmRib3g9ZmFsc2Usc3RvcmVkPSIyMDI0
LTA0LTE0IDEwOjMwOjA0Iix0aXRsZT0iT2tQQUwiLHZlcnNpb249IjEuMC4zIix3b3Jrc3BhY2Vz
PXt7bG9jYXRpb249InNyYy9nbG9iYWxzLmx1YSMxIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0
aW9uPSJtYWluLmx1YSM2MyIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ic3JjL2d1aS5s
dWEjMSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ic3JjL2d1aV9oZWxwLmx1YSM3Iix3
b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJzcmMvc29mdF93cmFwLmx1YSMzOSIsd29ya3Nw
YWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ic3JjL2d1aV9wYWxldHRlLmx1YSMxIix3b3Jrc3BhY2Vf
aW5kZXg9MX0se2xvY2F0aW9uPSJnZngvMC5nZngiLHdvcmtzcGFjZV9pbmRleD0yfSx7bG9jYXRp
b249Im1hcC8wLm1hcCIsd29ya3NwYWNlX2luZGV4PTN9LHtsb2NhdGlvbj0ic2Z4LzAuc2Z4Iix3
b3Jrc3BhY2VfaW5kZXg9NH19XV0=
:: [eoc]
