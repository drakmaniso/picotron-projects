picotron cartridge // www.picotron.net
version 2

:: gfx/
:: map/
:: pal/
:: sfx/
:: src/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA3Iixtb2RpZmllZD0iMjAyNC0w
NC0wNCAxNjoyNzowMyIscmV2aXNpb249Mjk3NF1dbHo0AMIBAADDMgAA9iN7WzBdPXtibXA9cHh1
AEMgCAgEcLcgRyAXIEcgt3AsZmxhZ3M9MCxwYW5feD0tMS44MwEAETcXABB5FwAnNDICAKcsem9v
bT0xMX0sWQDxCAwMBDAncAcgB2AHoAegB5BnQGdAJwAnBAA7Z-ALagBGNi4xNgEAFDNpADcwLjMB
ACIyN2oAHDdpACPwDGoAPyAHUGgAS-8SN2BXQHcgFwAXAAcAFxAHEDcQByAHEBcQB0AHMAdgN-AM
cAA7YC0HcAcQB9wAH1BiAEDxBgkJBDAHYAcNB0AHLQcgB00HAAdtFwIASwcAZwBoABMwWgASMEoA
HThKAGE3MAc9BxBGABBdQgAhB10OAG8gBz0HMDdOAB0pEEeQAAFQAF9NByBHEEgAGf8KGBgE8Cja
gNoPGXDaHmDaLlDaPkDaTjDZXgMABP8CTkDZPlDZLmDZHnDZDoDZ8ChtAAsN8AL-CPAbB7AHsAdQ
ZzAHAEdABxAnUAcgB-AMswAZB0YAAfEBTwAHIAdKACNfEBAE8PAxAP----------------------
---------------------------------------rUG09OH19
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2IixzdG9yZWQ9IjIwMjQtMDMt
MzEgMDU6MzM6MDYiXV1sejQABAAAAAMAAAAwbmls
:: label.png
b64$iVBORw0KGgoAAAANSUhEUgAAAeAAAAEOCAIAAADe_FMwAAAg5ElEQVR4Ae2de2wc13X-z12s
28CoMoAgAlOYDCAUgqoSroGCIazIlBHrVyQC9Ci1pB4VRKEpI0BhhOjX_iFGtQjJUSnZ_sOGshHg
MEVJQtCDXDGi1MpGIwURLVumGbeuIDOGEigIqWIcsSomTJWgBnyb4q5Gw5nZmTu7897vB4PF2btn
78yce8-n-su4rhEAAIDkkY-4fm8p3YmtxVP6gAiGT7wm_Zcdu7_BPQQACAnGdc383e6mAB1UhZ2F
NP3_sbp-iT-K2xmOBsCO6CDRF_bYJdmSL99WkvnyWqvU-p7PM3zitR27vyE_AyxmXqYEvl4mwOd7
Sh8QkjUC_ZNAOBoAEJedRTB84rUAtWV2jq85zcmVLFwLknau5LFKvrIK2vIa4q4y7xwejo9uDBov
LEZ8eRwAAII6MPyeH3aJeQvauIGY3f2ocfw1WGs-pQ_8pXQ7Olq8lUiwfw3phMSOBCAC08l3ZRIe
3vIYAYrCKmiziTxfPoLqyNvWUeLBLgAcDUAYzWVuK-kuM9LkReQ5cwROM0wlIzcHQYt3sJRM-m0j
O9PEe4qXfEofMIKQjnfYGYDU4bdnK_VHpjUPQfvSUNgP-ZbSbbawWcSW88fItBhc5owKaaUBqEOE
QIZPvCbkILrGXRSWzgq10SSVZU6TeR5fz_xLSozrWmSLF6Aug5WveVq-_yOuoxUAkHlyKX3uMOwM
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAABYYH7-wHUNVQO1bjtFRREA8CQfUnc1NRc8c-7qf7zvdegr
n3rmjLx3xzPn4iN-6Jnz11-f55nT9qdLvR9a_ap3zvAF75y1y73X4reKZ86Kd9-1zPnLd7-nmfN3
7A_8n7kz552zbHWlXw4s8942UXLoVgmOACkTdIAcnCq6-NrX0oMVAgBA0A-humbETFHDfoJKFnZ3
NwDxYrSJS49E3Eoge_RctpT9KwCRcXCqmNhDmusaU1RxVeoRv62EXgMegnbcItg3IBY797X09LX0
JNbRVdjWvZVcXA8g6PLuYYpqbBfjE-sGRExfS0-C5ct1TVz2Bqm6leBoYCFv2R-20x6bBsTFwali
kk3trlrJVnIcMf8d1DM5__ltOfmxXQDs7Glhy7hkKzk2F9oNOAjasrFgZwA71_Ju_VYyj6PdgJl8
pY2F7QJid7QIEmtqc6e4OFqmlUQy2g14CDp6KRt9CIBBYqXsq0E8M80JsDOQEjT6EAAA0iroxq5R
z5yZL-23Z85vztz3zFk8ddUz592fzXvm-PLTnGfOz6_Ne_a0fbzOM_ct4p45f3zdu84n1z7mnfS_
4pmy6s9_45nzhf9c45lz52_nPHMe_6z3etGy1Wg8AMISNAAAxAKfOiuZyVo2y855eI-snPuPS2aO
bGqVzOw8N_lP0FzXHj6QomJPAADSZefRvz8WuJ2fO-uDwO38D7dy7gnWn812tn8FAADYORo7WwXt
qGM4GgAAO0dv5wWCFiJmiiq_ikB8wtEAANg5YjsvELTZzmYpmwcBAAB2jsbORJQ325nrGlNUERhq
FoPYKACAqO18eA_9OSFl5x_-K29SyeR3fzYvOeezT6yQTL75qeKrAgtcblYz7AwAAPGSt3w3HG18
RY0AACARgoaUAQAgIeRQAgAASCb5Kv4zO9ThnTTknfJKQO9wLKB5Lu277pnTRf3B3Kwok3MlkFsN
0KMSOQGx3zuFf10iCQBAlEMJAAAgmeTtQ1zXjJgpKmoEAACxkHOxs-0rAAAkn85zk4HPeeyD6cDn
vHTjug9BO_oYjgYAwM7R25mI8hYRM0U1B_JTBFh4AMLAaDT7p0hw6T5zTqUYdk6pnYkoZ-5iXsu6
XWAAkgNTVKMBjZaslGD_ahmHndNoZyLKm5dWnNvG8SsWWAyiVQAID0f5WrqvUhua-2t0bqUJYecU
2ZmIcpbT2Fhg2BmAyKjUZebxSs41G9ycb-kKO6fOzkSUty_2eR-AzgBEbGpzA4pYtKFjM9qTHf_b
1mrsP163KncWNKQMQPRSNvedPfD8r3sM0ouDoAEALnBdEwYUgWNs-qyU4xjb55dXrczzYPnSRQ4l
AMCXnZmiGqazBI4GNA865ps-LRo1q9YIKmF_MPu9QBrJowQA_HW02aeSTpeUrLt-azxXsHapI_e4
lsaFAgFgsaTZdDLWY4pqtFKNkoWd6428_ybA0oKkcXCqaMR9LT2VEsRPlmT7f83J8pZ0bwqzkeXn
NHqtUtP57UT0ctYE7birsK4gURgyNdvWbGfDvCKwyNf81Z7sibkXRGyM2H_y5FTKd-yjPV8S_7_q
mwckS9DCzsbhLwLxCUeDGBH2dHGoMLWjjiVdXx3mvjCaxeggczdZOstoN-u4vRPl3epyX_Mz7ZuB
zy2XPaiWfCQ757D04bdD_jlpveycdMHl15z97LUvNhwBYrSz5dNsbSMQBrf-KmLLT-avNZrarf0U
1dxElbRrjAuNmvMt4na-l_MfM9PC8nae6wvezm-tWBe4nfuW-Z57wkNB209y46iHo0FcCHWaPy3_
dXSu8atwt6Fvy1djxPz3AL3s0cZewrXk_J3TEqe9i_vQzgsEbXE07AySgFCn_dNR4uKyu1tm8riQ
6SxzjozQzflGDDun1M5ElLcvsN9DG4Dw6GvpEc6tZF7xkxGbtev_kzlB3unWhtQ10SaWxrEkyCvS
mEfkm2PPGcwPYH_Y9Gq6bu1MRKyKHQlrg5r6rfIWOrCskKhHPXSrhPVKqZ0bymdxkHZuo4uB29l9
j_WxAwAACbXzMNGlBdqtaOfrsnPe7ZFN-klxgZ1dmKB1bxGXyfyXZb-vqwLVCJrrGrYOCINDt0oo
AgDVC5opKqoGAAARkEMJAAAAggYAAABBAwAABA0AAACCBgAACBo84NknVjiO88N7UBwAEktDMfg5
2_hi4HMeulWCoKNmZFMrigAA7FyjnetL0JzWY_8CADunxc71JWgAAOycIjtD0MEzsqm189wk6gAA
7FyjnTMl6Ala557A6AKn9djHAMDOqbDz77SVx9L6hR-ew-YfD3bOuz2h7DAAUg3bUb8qF_Qys5Zt
dHGC1mFPAwAyQ3YEnV7u9lhP9aEjvSgLAACCDpKRTa2d5yZRBwAABG2ljS5O0DqXBEYXOK1P1DPf
7aGG4oKRoSO9Xfv6zSN86ix2KgB1SB4lcOHYB9MOlt9-HJWpBNc1FCHbMEVFEepa0PyF0-T5Jtax
KnXV7Dw36Sv-bg81FBeMDB3p7drXv6AaU2dZy2Y0MMABXIfkktjhR7fSezN89FoV-22jixO0zm1y
uoBVBwCkgjxKEBd3e6ihuGBk6Ehv175_8wifOstaNqNWAAhenXtGMnPvkiuyk862ymY2TspmjrfL
Zm4YS5_g2dGt-IXTfPQa61jl979tdDGkp_KH95Qfb-9xtAqoH7iupczObyvB23n4scDtvHjwM-dc
ExIq6BC3Gq0vS5YuVGdnEdfu6Ibigq9DR3q79vUvuOPUWdayGXYAsHNW7eyZw_It_trHn7x043rF
nfHCafp8E_tYFbidHR3tthG-fdhh8Ov7maIG9WzZEDTXtQBrApJp5_iXuBo7bxgL3s69XnP6t-O9
0imXtHy8y3-pxnV3R1fHBK0TQRtdrGTn8oj_XZltxw-vcdymAW7fDNgZQN9hGLwaO3tShZ098W9n
T2IT9IFlhUO3Su6OZke38hdO89FrrGNVFXYWsdnRge8kx7_bd60l4W5POWgoortB6glWxLBzggR9
6FbJcHSAmO1sjDylDxARKV_tfiPuP84P77GMyOxas6znvvlw-G6Ph6NZy2b0P0iCgs17OBopm026
97e-lsp8349J35fLvCn9nP3tksmLp3zYmYhySdgEl25cX-v4k8774_hWem_Gj16rcZMxRWV0wTpu
G3F3tIydnW_tqGY7G44OlZ1bNsIvIBBHExF98nT5AhGSj-Heh26VDiwrHJwqup-P7OhWyQm5rr2l
dLttNbrAaX0Vdvbr5djZuWXj4Jnz2N8gGExe5nPL2ZKPUJLsC5qIDk4V_1p6LJK1O1pGzYbcJ2id
_ac2umhxdHKqb35sPnW2-IQtm2FnkKBdOrfcPgJHZ1-QXNcsdiaivpaeSo7mo9fKCutY5eg4w8iG
oy12jpGGIt1d_K4NRaKiWn6FW1cfvtHU2VocbbEzHya2A-scROTucodC3xkQtL_t8MDOImYdq_xq
Njs6ga9gdnRD0fSDyc6BOBp2BtEAEYdNLnV2fuhoRXW0c5JpKJavkNi5ZePgmfOwMwjVwvAyBF3v
cF2DnUECHQ07p17Qs4tGUFkfu79ls32EKSrXNXlNm_0MQBiOZks_okd_lI7H3TAW-Jy9wc95r3Qq
BkE3znfKOJop6sGpomXw4FSRKao19b0Z75GsONqImaIKTfu1Mx8mtgNKAfVKVuxMRPmQSiQc3Tjf
6eloi4Asdha-MkXlL5ymzzcZdmZHt2ZsU5kd7Vgih3PrAbAzCBU_dRZ2jt7ORJQLr1DC0d5iUlTz
ZbGzMciObqX3ZsSVPTvLlMhykjk3EuwMQrXzrauwc2R2JiIWdsVmF400znf63hO6JsSE9khXWcSZ
ipXKpp0Na7Rsjuj2s62yme8-Jmvn8XbZOW9K27lfds7FU5_Rt-PvDJ1Hk6cIURbUByRZ35Ea3EDS
zr6QtLMffNk5CkE3znfOLhppnO_EnQPUNNc1Gi9Xie1ASUBMWzFsETdO1q3KIxK0vKO5rgn7YN97
88DORMSH4WhQDa-OPSOCvUuuuCiYT52NVMrARC6a2whHu9uZKSrsLAMf9h4BQNLOltjR0Q_-LFuN
0mVQ0MLR7nbGYgAQBt2374vLxciejhYXihkx_difAHYGIFQ7m_OBpY8GOHklre9dcgWVT72gZxeN
ENGdxgksgy-YDuLDthGcc8DVzmE4GiLOrKCFnY24cb4zXYUb2dQqgs5zk-E6mu0gImKKCkcDebG_
OveMvGr56DXJA0AQ4BlQ57DY7WyQIkcbdo7R0c6NFLejcUgkCkeBGvY0HO3LzqxjFQoLQcfPs0_s
EMGxD6Zd7AxHu9-96sQ7IljdthL9FrujDTvLLuhCO8fuaMcjxxH5Nw1jzhUlLpk5XXCTcD6WHr7T
OJHwbW3YWcQWRyf6yFXUeB3taGcRw9HRM7D0UUNAfu1cnb7DM7gPk57eHvicb-T9c_B2-vWBDveE
XPR2ZoraON9pGbePJMTOlUaS7_hE2bnSCIjG0eIKfqd1rHK8YOdA7ExE_ejtbBh5dtFIAu3sSee5
yZFNrZaRZDraqDYAVSuYj16zjHieuKvbVsLOtds5UkHbfVGjl7muWZQUi6MTaGc4GoTl6D--o1BF
DDvHJujAdd-X0uN_AFTNsQ_mn31ihWXE7mi0rjur21ZenXgn_n4GATPbyuj-l_P5qG9ez3YmIhaZ
T4Oyp6OdBQenigHexXC03c7pOskCrEkVtzMcDTun1M4Og42TEd395KBs5i__bx3pHavRpPPnS9Zi
DDm7tbFrVFa4Pz5lGZm5ab2LmXxm7ExEfS09Ad4r1V5_uCEUNWJHW4CXswcfJrajsr6jNHjWCV3Q
kdk5DEdng9gdDTJr6h86i5ihNGkRNAAgxTRO0mxrJSmzHShQuOTCPWB1jSkqqhw7TFG5rqEOoEpH
L7QzvBwZedi5rhyNFQHVOZoPP9hIsHOE5FACAID3Ab_D2A6iDRpKESX5kOblusYUNfhdoqhc1-pa
eiolHJwqhnHfjPSYooa0LiDb8MN7UITsCDpUC7g4GnaGoxPI5ddvi2DNrqWpt-O3D6fjoXvHAp9y
dqgj8DlnbpbcE3IptczBqSLsDFJkZ0ucSjtXGIGdQ7IzEeWDX1Fdi0CUTFG5rllGoAP50qFcEdvZ
GFmza2lmXrCSrNn_47Bz7XYORdBRigYKACBGrjT8TYVfYhJ0tuwcvKC5rsGbqTjbsFJAil_tos9e
s4488O_aXUsT9KiZszMR5bADAQgJu7_SZTSZs-zoVvrVKrOd2dGtSXzQLNqZiFiA9_a6xhQVbZkW
wlgv7AE7l1_-nVI7E9GKEieiDyfPiK9-0rqFiKYLQXoDuJBHCQAIlTR62YLwciV924HBEydormtM
UVHQFMEUFasGagEiDpscSgAAkFcwpJw_QXNdY4qKaqYOpqhc11AHIOnoD--fxyhIlORRAgCArKNx
nEdLrvYpuK4xRUUpUwpTVI6uAyCR5FECAIAnd3v_zxdz31RRCggaAJAkxtsbhKbfHLvbQw3F2B6E
j16TzGQdqyQzL79_WzJzza6lkpkvPT8gmfniy90uv_ZqrZeuMQWHarphisp1zd_6zy3nc8tRujqx
sxE2fKmdiO72JN3O35qcDtzOb1x8I3A7v-5Pl9wT8th_gM8tp0_e5nPL2ZKPvDOF070yQfbsbDj6
7ptjIq5k6oYi7ByAnetU0Gsff1IEl25cl9oZusYUNct2NsWO5k2Ol4eO9Iqga18-5Bk7DV_y6rtM
sWxw2LkWOxNRrqaqpdBchp0tsQt1YmfHET63XFhbXAmxsyUGUXu5_CDaMOZ8wc5B2LlWQacOu5Fl
HM11rW5bMQlermRkODoK5v-CbeTkoPMFOwdhZyLKYwd6S0pRUQRQ145e9H1HXw-N-MTxH10B3fny
67ev3JPKfPunl_VNKpn8q598IjnncxtOSCaf-tkPfFUAgpY4w3Utq45mSz7ic8stI1hx8JDtO_nk
4AIvb9-5UMT7_lGhUKle0GnU1qUb19c_-qRlxNtiGbWzg6Mf_RFRQl_2a1--0JFeywgaOGw4raft
o_xkR-nr9lGi9YwuoDJJF3RKMTtaxs72o8jQRGYEwZZ89OBNE-2cZkfDzhEwu2jkTtnLQxX17bij
YHAIuhZH_-OXk51FDE1E72gUITI7G-GdRV2PzTs4GiIOmxxK4AnXNbudK40AkDE7G46GlKMnX7Wz
mKLWSY3q6k3ramWBb-Tvkml72D0uaJzvRKkCE-Tl129bRtfsWorS1OdplAFeen5ABC__3I1qBHl_
0wUOEUcvaLuOLcquc18bdu7a1z90pNf8U9e_fuyhZNpZxHB0dTTOd84uGkmvi8NY91fGdwc_58zN
kntCznF0za6l5qvONyvXNUcjw85JtnOlESDvaNg5XjsTUR4b0ROmqOav8DKoQ0dLnojhKbIO7Zxc
QV9_-bYI3rj4Rng1koTrmuHonVs2imDwzHk0MKhzYhRxPdiZiHJJtjMRfXndl0Xw3IYTcT2P3c6W
GCS2P5NmEAA7y9u5SkFzXTOcFaqdE_JormuORs6ko5miivfNQJfCzrBzqu1MRHksrYyzUIQ671UQ
C2t2La1blQty2ASecF1DEUBd099evkC0JE7Q9jPzjYtvhH1MucMUlYgGz5y3jNtHAKiRkU2t4kqW
nY1e_E48PQhBJ9TRtdj5pecHxFXj83BdsxsZdgZh2NkxToidK46A0Mgn87HMjq4Os5dfen7gxZe7
q56KKSq8DKK0szHSeW4y0Q9dSda9Y1jQYARtFpkjtagtLuwv5cvRVyfeEcHqtpVExHXN7GgAQPkI
ee_O43gnShOUoNPo31Ax7Czi1W0rYWdQv-SOUX-7RO8n4ltb-yPUO-ZQxOcmUaFQydXV23Jdc-80
29lwtOe-fH0C4IhddgnRn2FnSwwiIJ-Jt3rx5e6Xnh_wjBARU1T3T7ugZf7l6xMAF0ePbGpNlp1p
nX2kjS7G9Tx86qxkJmvZLDvn6DXZOTtWyc75wmnZOY9urTtBWxwt7Fz9ntA1uBVE5ugUPa1d34KQ
DC5vZxr5NHA7f2tyOnA7Pz-9X_4JmRV0dV5e3bby6sQ7lhFYA0jy3IYTInhlfHc9vG9IIoadDXJo
KrujLTHXNZQFyNvZEmdMwVFKuc7tDEFXdLS4xFemqKgJkLdzhh39lD4AO0dmZyLKo7W8665rcDRI
I41doyKYHeoIxNFc7hB6ZXw37Fy7nSFoKWBnkGo7i7hGR4ct4oom-blc6nszPkwql-wt-mvJOWcX
jdz5jlTma1_c81WBHPax94rqGooA-KoqbHnJ27nSCEg_1QiaKWpdOYspal2dRnX1viE5Ol47R3kM
OF7YDEGRRwngrBjZuWWjCAbPnM_Yo_uB2aEO7OFQyaEEnsDOYdvZEoMw1AmZQtDZhOsaihCqneHo
sB0NO6eUPErgCVNUFAGk3dHRnLKCwTPnUXwIOiK4rsHRAEDEEHQSyZKdX517RgR7l1yJvbd3btmI
bq8E17WsbsIoevbo1sDnfPHl7sDnfGV8dyiCZorKda1ONk1m3tSws4jtjo74Tc2Ohp0tC9HX0pPJ
TQg7y9u5ekHX13pnzs4ujo4YeFnGzkTU19KTRkdzXYu4j7JkZwhadpNlw9EgpXZOqaMt7xLBw2fM
zkSUQ0t4rzrsDOK2s9nR2XgX2DlcQTNFjXivNDUXxBX9VstA8_9dcsV9hOsajqJUs7iwTVywczbs
TET5tGw_s5ebmgszN0vRrX1WtLV3yZVX556p5GsQC88_sUIExz6YrtHO5vhe6VQED39g2cOuNDg4
VQzKzqxjVSpU3jjfGVKF0yFos52jdzTXtSw5Gk5MoJ0tcS12jtLRh2459OAhpcR1LShH1znpEHS8
ZMbOVfDq3DMwewR2Tin2g8FoGTg6fkGLZci8v_r5HQ0vG6aGr8PjudVffGXqhy5eOzhVTNRW-MpP
-81x-BgcnQRBR8bMzVJTc8EyEtndM29nGSxGNnwNUwe_2Sp5zcXO90qnFhe2WUYieNpjH0x7vgv6
qBZyaXlQs5GjtDOo5GtxoRQB2k2MMEU9OFWUt7PdyNHYWfK8MS6seDUFrH0KrmuofqoJcAWxGfzy
7BMrHH3Ndc1iuoxtFSBDHiUAIEYsXk6akQEEDQAAUnBdk8yUP_GuTrwjmbm6baVk5tCRXsnMrn39
Lr-mai8ZU1T5qoFEMNtavoi4rslvZQBSYefhE68FbufvfftI4HY_dfKH7gkBCBqkz86OMQCwc5Ls
HJigmaLKlw8kxc5i7eY3ZP6l1z7_pLiw-rBziuwcmKABSLKdHWMAOyfczkEKmimqfB0BiN7OcDTs
nC47E1Heb73Eu61uW4mtk0oaJ2m21ToCQEDnn_DSjeuBzH914p2Jf78tk-nza_PyJpVMvvyvH0rO
uXPLRsnkX374sa8K_BC0p5qZonJdY4qKjZsaR8POoAaCEjGoSdCeagYpYLy9HGwYo8bJikfpbGuW
rH3pxvW1jz8Jp4BsCtqvmpmiVux8kAQ7E9F4O3-6RMU1apyk2dZykDlHR2-npuaCCGZulrANQWCC
9qtmkA47i3P0R7vd8oWaM6Tp6L1ssbOI4Wjgl1ylH1a3razOzkxRua6hsqmncZIaJ2m2tWxqUIOd
K40AUKWgAYCmgech5HihMkGRD2NSpqhc15ii_rZB16gIZoc6sDaBsWGMxtutI341TUSzreUAACIi
mrlZQhFCJRfSvMLR1dnZEoNgHF21nS2aBtXKCzqLjK59-YHPOXjmfOBzXrpxPR5B__59m5Hh6MAd
zZ8_Ub2dQW2Ohp1hZ792JqJ8IHdqai7Y9x9TVK5rTFGxY_Khv70c9I4RkdtajLdD3BE4GsDOvuwc
gKCbmgsuuxCOjt-ORNTfzr92wm0VNozReHs5AAB2ToadaxV0U3Ohkpr9MjvU0dg1ahnBhgvAzuKk
-M5uj78INY_3w9EAdk6InYkoV7WaJe3MFJXrmqSjYeeY2TBG4_00bvU7ALBz9Haukqbmgt_-SDoa
BEN-u8Pli2o1jYXONljfiMlXoeaZmyW-t2GKynWNKSoqHgW9Y1Yj9475m2HDWFnTIgAAJFzQTc2F
KtQM4ne0XztbNA0AiImcfGqNdmaKynUNFY8M-rUT1DtWvZ0BACkSdO3A0dHZWdeYoqIOAEDQcHR6
7NzfjvoAAEHD0cmzMxH1jsHRAEDQcHTy7Gx2NDQNQOLJx3Vj4Whvm4Bg7Ww4moj628sBACmhqbkg
mTlzs5SBOXMx1lo4GnsuajubNd3fjtKB7Nk5M3PGKWg4Ok47mx0NTQPYOZFzRiToxq7RbDh6cWGb
uLJgZ8PRQtMAwM4JmzMKQTd2jc4OdbgkpMXRZi8nxNG12tmsaQBg54TNmY-dzhZHG7pZUeIimC6w
pNnZGLlXOhWjms3lAgB2zticRJRLgp0NRxuaNuxsiYFhZ1EulALAzlm1c4iCbuwa9WVns6btRo7Y
0d2374sryXZG9wKQefIh2bkKNScEs5e7b98fWPqoiO_VTi0ubDNn3iudil7N4gzDxgWgHsjBzpXs
bB8xGzkWOzNFhZ0BqB-yCbTzdIGtKHHLSELqFb2XhZqJCGoGoN7IBTtd7Xa2G3m6wISh6hOua0xR
YWcA6pB8Yp-M7GimqMLRYXtqYOmj3bfvW0ZiVHMErwwAgKBrRXgqAmeZHR2XnaFmAECaBB2lpuPy
MtQMQCDM3CxlY84kCnpFiU8XWOyaDpKTg_Vg_06oGQDYWXLOxAna087p07RhZxHbHA01AwA7p0PQ
fkm6ps12tjk6k2oWLwUA7Fz7nMkS9IoSny6wGjWdfOWl5TmrXggAYOdA5kyQoKu2s90OCTcgLAYA
7CzliiwJ2o5h6ri0yHWNXXxzwdD2nWgnAECaBB2GneOStcONTg7CzgCAVAo6Aju7OLQWawc1T7a5
OvHO6raVlX7duWXj4Jnz8rMNHent2tfvnvPS8wMvvtxtHln7_JOXblyP4GWf23DilfHd5pGm5sI-
fuPYml1LK-3l2SdWHPtg2vg6sqm189ykiA8sKxy6VZK-__LCtnulU_aRxq7R2aGO7tv3B5Y_as9-
de6ZvUuuuEw4u2ikcb6TiPjhPXP-cbyhiO0cKfk6PZecHOpo2yrmAQCAjAh6RYlPF1hirQ0AAHGR
i-0JEmJnAACAoOuek4OoAQAAggYAAAgaAAAABJ16tu_kk4MoA5Dh4FQRRQBgAd2373vmLC5sq-4G
EDSQgOvagWUFrmsoRd2SQwkASKad_1p6iKivpQeOhqABAImzswCOhqABAEm0MxwNQYNo2b6TTg6i
DAA0NRdQBAgaAJBEO--i7SIcDUEHz73SqcWFbagDADUCR7uQRwniYftO1AA4whSV65rjeIYd-bkv
0MzNElbfQg4lACCBjrZf2X7lX7xdbGouYOkt5FECAEC8fO4LPUQ0c7OEUgBvum-fl0lbXNiGWgFQ
C03NhabmAte1puYCqgEAAAAAAACojf8FAw-_VsLf1HEAAAAQdEVYdExvZGVQTkcAMjAxMTAyMjHj
WbbBAAAAAElFTkSuQmCC
:: main.lua
--[[pod_format="raw",created="2024-03-31 05:33:06",modified="2024-04-04 16:27:03",revision=3606]]
include "src/globals.lua"
include "src/oklab.lua"
include "src/palette.lua"
include "src/remap.lua"
include "src/gui.lua"


function _init()	
	window {
		tabbed = true,
		icon = --[[pod_type="gfx"]]unpod("b64:bHo0ABYAAAAUAAAA8AVweHUAQyAICARwtyBHIBcgRyC3cA=="),
	}

	mkdir("/ram/cart/pal")
	wrangle_working_file(
		save_working_file,
		load_working_file,
		"/ram/cart/pal/0.pal" -- default
	)
	
	on_event("open_file", update_filename)
	on_event("save_file", update_filename)
	on_event("save_file_as", update_filename)
	on_event("drop_items", handle_drop_items)
	on_event("okpal_hexdialog_confirm", handle_okpal_hexdialog_confirm)
	
	-- Initialize globals
	load_metadata({})
	rebuild_pal()
	
	undo_stack = create_undo_stack(undo_save_state, undo_load_state)
	
	generate_gui()
end


function _draw()
	cls(bg_color)
	gui:draw_all()
end


function _update()
	gui:update_all()
	
	if key("ctrl") then
		if (keyp("c")) copy_color()
		if (keyp("x")) cut_color()
		if (keyp("v")) paste_color()
		if (keyp("z")) undo_stack:undo()
		if (keyp("y")) undo_stack:redo()
	end
end


-- Undo ---------------------------------------------------------------------------


function undo_save_state(_item)
	return {
		pal_okhsl = copy(pal_okhsl),
		pal_code = copy(pal_code),
		test_cube_colors = copy(test_cube_colors),
	}
end


function undo_load_state(state, _item)
	pal_okhsl = state.pal_okhsl
	pal_code = state.pal_code
	test_cube_colors = state.test_cube_colors
	for c = 0, 63 do
		set_color(c, pal_code[c])
	end
end


function copy(t)
	if type(t) == "table" then
		local new = {}
		for k, v in pairs(t) do
			new[k] = copy(v)
		end
		return new
	else
		return t
	end
end


-- Drag-and-drop ------------------------------------------------------------------


function handle_drop_items(msg)
	for i = 1, #msg.items do
		local item = msg.items[i]
		if item.pod_type == "file_reference" and item.attrib == "file" then
			local ext = item.fullpath:ext()
			if ext == "hex" or ext == "txt" then
				local metadata = fetch_metadata(item.fullpath) or {}
				if metadata.okpal_version then
					current_filename = item.fullpath
					current_import_choice = "overwrite"
					send_message(pid(), {event = "open_file", filename = item.fullpath})
				else
					create_process(
						"src/hexdialog.lua",
						{
							okpal_filename = item.fullpath,
							okpal_parent_pid = pid(),
							path = path, 
							window_attribs = { 
								workspace = "current",
								autoclose = true, -- ???
								give_focus = nil, -- ???
								show_in_workspace = nil, -- ???
								corun_program = nil, -- ???
								unique_location = nil, -- ???
								has_frame = true,
								x = nil, y = nil, z = nil,
								moveable = true,
								resizeable = false,
								desktop_filenav = nil, -- ???
							}
						}
					)
				end
			else
				-- TODO: dialog for unknown file extensions?
				current_filename = item.fullpath
				send_message(pid(), {event = "open_file", filename = item.fullpath})
			end
		end
	end
end


function handle_okpal_hexdialog_confirm(msg)
	current_filename = msg.okpal_filename
	current_import_choice = msg.okpal_hexdialog_choice
	send_message(pid(), { event = "open_file", filename = msg.okpal_filename })
end


-- Loading and saving -------------------------------------------------------------


function update_filename(msg)
	-- TODO: maybe add `or "/ram/cart/pal/0.pal"`?
	if msg.filename then
		-- Clicking on the disabled 'Save File (auto)' menu entry
		-- sends a msg with no filename, so we need to ignore it.
		current_filename = msg.filename
	end
end


function save_working_file()
	local ext = current_filename:ext()
	if ext == "hex" or ext == "txt" then
		return save_hex_file()
	else
		if ext != "pal" then
			notify("unknown file extension: saved using default file format")
		end
		return save_pal_file()
	end
end


function load_working_file(data, metadata)
	local ext = current_filename:ext()
	if ext == "hex" or ext == "txt" then
		load_hex_file(data, metadata or {})
	else
		if ext != "pal" then
			notify("unkown file extension: loaded using default file format")
		end
		load_pal_file(data, metadata or {})
	end
	if (undo_stack) undo_stack:reset()
end


-- Metadata ----------------------------------------------------------------------


function create_metadata()
	local metadata = {}
	metadata.okpal_version = okpal_version
	metadata.bg_color = bg_color
	metadata.blackest_color = blackest_color
	metadata.whitest_color = whitest_color
	metadata.hidden_toggles = hidden_toggles
	metadata.hidden = copy(hidden)
	metadata.locked = copy(locked)
	metadata.test_cube_colors = copy(test_cube_colors)
	return metadata
end


function load_metadata(metadata)
	metadata = metadata or {}
	bg_color = metadata.bg_color or 0
	blackest_color = metadata.blackest_color or 0
	whitest_color = metadata.whitest_color or 7
	
	if type(metadata.hidden_toggles) == "table" then
		hidden_toggles = metadata.hidden_toggles
	else
		hidden_toggles = {}
		for row = 0, 3 do
			hidden_toggles[row] = false
		end
	end
	
	if type(metadata.hidden) == "table" then
		hidden = metadata.hidden
	else
		hidden = {}
		for c = 0, 63 do
			hidden[c] = false
		end
	end
	
	if type(metadata.locked) == "table" then
		locked = metadata.locked
	else
		locked = {}
		if current_filename == "/ram/cart/pal/0.pal" then
			-- This only occurs when a default starting file
			-- is created.
			for c = 0, 63 do
				locked[c] = c < 33
			end
		end
	end
	
	if type(metadata.test_cube_colors) == "table" then
		test_cube_colors = metadata.test_cube_colors
	else
		test_cube_colors = default_test_cube_colors
		if current_filename != "/ram/cart/pal/0.pal" then
			for k, _ in pairs(test_cube_colors) do
				test_cube_colors[k] = { 1, 1, 1 }
			end
		end
	end
end


-- Load and save pal files -------------------------------------------------------


function load_pal_file(data, metadata)
	if type(data) != "userdata" then
		if data then
			notify("unable to load working file")
		end
		return
	end
	for c = 0, 63 do
		if data[c] then
			set_color(c, data[c])
		end
	end
	rebuild_pal()
	load_metadata(metadata)
end


function save_pal_file()
	local output = userdata("i32", 64)
	for c = 0, 63 do
		output:set(c, get_color(c))
	end
	return output, create_metadata()
end


-- Load and save hex files ---------------------------------------------------------


function load_hex_file(data, metadata)
	if type(data) == "string" then
		local lines = split(data, "\n", false)
		local codes = {}
		for l in all(lines) do
			local code = tonum("0x" .. l:gsub("%s",""))
			if type(code) == "number" then
				codes[#codes + 1] = code
			elseif code then
				notify("error importing hex file")
			end
		end
		local start = 0
		if current_import_choice == "dont_clobber" then
			-- TODO: put in separate function and add menu item
			for c = 0, 32 do
				set_color(c, peek4(0x5000 + 4 * (64 + c)))
			end
			start = 32
		end
		if #codes > 64 - start then
			notify("*** not enough space to import all the colors ***")
		end
		for c = start, 63 do
			if codes[c - start + 1] then
				set_color(c, codes[c - start + 1])
			else
				set_color(c, 0x000000)
			end
		end
		rebuild_pal()
		if current_import_choice == "remap" then
			remap_colors()
		end	
	elseif data then
		notify("import hex file: unkown type: " .. type(data))
	end

	load_metadata(metadata)
	if current_import_choice == "dont_clobber" then
		active_color = nil
		for c = 0, 31 do
			hidden[c] = true
			locked[c] = true
		end
		hidden_toggles[0] = true
		hidden_toggles[1] = true
	end
	local best_black, best_white = find_blackest_and_whitest()
	blackest_color = metadata.blackest_color or best_black
	whitest_color = metadata.whitest_color or best_white
	bg_color = metadata.bg_color or best_black
end


function save_hex_file(filename)
	-- Don't export trailing black colors
	local fin = 63
	while fin > 0 and get_color(fin) == 0 do
		fin -= 1
	end
	
	local output = ""
	for c = 0, fin do
		output ..= color_to_hex(get_color(c)) .. "\n"
	end
	return output, create_metadata()
end


-- Copy and paste ----------------------------------------------------------------


function copy_color()
	if active_color then
		set_clipboard("#" .. color_to_hex(get_color(active_color)))
	end
end


function cut_color()
	if active_color then
		set_clipboard("#" .. color_to_hex(get_color(active_color)))
		if not locked[active_color] then
			set_color(active_color, 0x000000)
			change_color_code(active_color)
		end
	end
end


function paste_color()
	if not active_color then
		notify("unable to paste: no selected color")
		return
	end
	if locked[active_color] then
		notify("unable to paste: selected color is locked")
		return
	end
	local cb = get_clipboard()
	if type(cb) == "string" then
		local hex = string.gsub(cb, "%s", "")
		if sub(hex, 1, 1) == "#" then
			hex = sub(hex, 2, -1)
		end
		local code = tonumber("0x" .. hex)
		if type(code) == "number" then
			set_color(active_color, code)
			change_color_code(active_color)
		else
			notify("unable to paste: unrecognized string: \"" .. cb .."\"")
		end
	else
		notify("unable to paste: type not supported (" .. type(cb) .. ")")
	end
end
:: manual.txt
--[[pod_format="raw",created="2024-04-04 06:47:16",icon=userdata("u8",16,16,"00000101010101010101010101000000000106060606060606060606060100000107010606060606060606060606010000010106060707070707070707060100000106060607070707060606070601000107010606070707070606060706010000010106060706060607070707060100000106060607060606070707070601000107010606070707070707070706010000010106060606060606060606060100000106060606060606060606060601000107010606060606060606060601010000010101010101010101010101070100000101070707070707070707070601000000010606060606060606060601000000000001010101010101010101000000"),modified="2024-04-04 10:05:39",revision=150,stored="2024-04-04 06:56:33"]]
# OkPal
A palette editor.

## Features
- perceptually uniform color space (oklab);
- two file formats: ".hex" and ".pal"
- can reorder colors to match the default picotron
  palette

:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2Iixtb2RpZmllZD0iMjAyNC0w
NC0wNCAxNjoyNzowMyIscmV2aXNpb249Mjg1MV1dbHo0AGkAAABYEAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD--------------------78QgiKSxoaWRkZW49ZmFsc2UscGFuX3g9
MAgAwnk9MCx0aWxlX2g9OAkA4Hc9OCx6b29tPTAuNX19
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2IixzdG9yZWQ9IjIwMjQtMDMt
MzEgMDU6MzM6MDYiXV1sejQABAAAAAMAAAAwbmls
:: pal/0.pal
b64$LS1bW3BvZCxiZ19jb2xvcj0wLGJsYWNrZXN0X2NvbG9yPTAsY3JlYXRlZD0iMjAyNC0wNC0w
NCAxNTowNjoyOSIsaGlkZGVuPXtbMF09dHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1
ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUs
dHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRy
dWUsdHJ1ZSx0cnVlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlfSxoaWRkZW5fdG9nZ2xlcz17WzBdPXRy
dWUsdHJ1ZSxmYWxzZSxmYWxzZX0sbG9ja2VkPXtbMF09dHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVl
LHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0
cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1
ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2V9LG1vZGlmaWVkPSIyMDI0
LTA0LTA0IDE2OjI3OjAzIixva3BhbF92ZXJzaW9uPSIwLjAuNCIscmV2aXNpb249MTIxLHRlc3Rf
Y3ViZV9jb2xvcnM9e1swXT17MTUsMzEsNH0sezMxLDQsMjB9LHs0LDIwLDIxfSx7MTAsOSwyNX0s
ezksMjUsMjR9LHs4LDI0LDJ9LHsyNiwxMSwyN30sezExLDI3LDN9LHsyNywzLDE5fSx7MjgsMTcs
MTl9LHsyOCwxMiwxNn0sezEyLDE2LDF9LHs2LDI5LDEzfSx7MjksMTMsMTh9LHsxMywxOCwxfSx7
NywyMywxNH0sezIzLDE0LDEzfSx7MTQsMzAsMTh9LHs3LDYsMjJ9LHs2LDIyLDV9LHsyMiw1LDIx
fSx7MSwxLDF9LHsxLDEsMX0sezEsMSwxfX0sd2hpdGVzdF9jb2xvcj03XV1sejQAKQEAABUCAAD1
BXVzZXJkYXRhKCJpMzIiLDY0LCIwAQDAMWQyYjUzMDA3ZTI1CADwFzAwODc1MTAwYWI1MjM2MDA1
ZjU3NGYwMGMyYzNjNzAwZmZmMWU4CABAMDA0ZAgAEWE2AGBmZmVjMjcKACBlNDgAQDI5YWQkAGA4
Mzc2OWMgADE3N2E4AMBjY2FhMDAxYzVlYWMwAPAdYTVhMTAwNzU0ZTk3MDAxMjUzNTkwMDc0MmYy
OTAwNDkyZDM4MDBhMjg4NzlAAPADYWNjNTAwYzMwMDRjMDBlYjZiRgBgOTBlYzQyCgAgYjLAAKA2
NGRmZjYwMGJkiQAAlgBAMGRhYkAAXzg1NmQwAQC_EGI-AfEBMjAwNTFjYjhkMDAxOWExORABWDgx
OGUwAQBQMDAwIik=
:: pal/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDE5OjQ3OjQ2IixzdG9yZWQ9IjIwMjQtMDMt
MzEgMTk6NDc6NDYiXV1sejQABAAAAAMAAAAwbmls
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA3Iixtb2RpZmllZD0iMjAyNC0w
NC0wNCAxNjoyNzowMyIscmV2aXNpb249MjgwOV1dbHo0ABABAABRBwAA8CdweHUAAygAAAMABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDBAUGBwAP-5AICQoLDwwPDQ8ODw8QAPAADQ8RDxIPEw8UDxUP
Fg8XEwDxAQ8YDxkPGg8bDxwPHQ8eDx8UAPEAIA8hDyIPIw8kDyUPJg8nFADxACgPKQ8qDysPLA8t
Dy4PLxQA8QAwDzEPMg8zDzQPNQ82DzcUAP8FOA85DzoPOw88Dz0PPg8-AA--8P8BAOv-J1oBEAYP
IBABIAEgAfAAAhACDBABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDDAA-zkf-wEA
3L-4D0AADUD--7DwcAoA--9kH-8BAJdQ-----x8=
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTMxIDA1OjMzOjA2IixzdG9yZWQ9IjIwMjQtMDMt
MzEgMDU6MzM6MDYiXV1sejQABAAAAAMAAAAwbmls
:: src/globals.lua
--[[pod_format="raw",created="2024-04-03 09:15:53",modified="2024-04-04 16:27:03",revision=830]]
current_filename = "/ram/cart/pal/0.pal"
current_import_choice = "dont_clobber"

undo_stack = nil


-- Saved in undo stack ----------------------------------------------------------


pal_okhsl = {}
pal_code = {}

-- and also `test_cube_colors`


-- Saved in metadata --------------------------------------------------------------


okpal_version = "0.0.4"

active_color = nil
bg_color = 0
blackest_color = 0
whitest_color = 7

hidden_toggles = {}
hidden = {}
locked = {}

test_cube_colors = {}


-- Constants ----------------------------------------------------------------------


default_test_cube_colors = {
	[0] = 
	{15, 31, 4},
	{31, 4, 20},
	{4, 20, 21},
	--
	{10, 9, 25},
	{9, 25, 24},
	{8, 24, 2},
	--
	{26, 11, 27},
	{11, 27, 3},
	{27, 3, 19},
	--
	{28, 17, 19},
	{28, 12, 16},
	{12, 16, 1},
	--
	{6, 29, 13},
	{29, 13, 18},
	{13, 18, 1},
	--
	{7, 23, 14},
	{23, 14, 13},
	{14, 30, 18},
	--
	{7, 6, 22},
	{6, 22, 5},
	{22, 5, 21},
	--
	{1, 1, 1},
	{1, 1, 1},
	{1, 1, 1},
	--
}
:: src/gui.lua
--[[pod_format="raw",created="2024-03-31 05:58:06",modified="2024-04-04 16:27:03",revision=3913]]
local slider_size = 170
local slider_border = 6
local slider_inner = slider_size - 2 * slider_border


function generate_gui()
	gui = create_gui()
	local pal_el = create_palette{ x = 16, y = 6 }
	gui:attach(pal_el)
	gui:attach(create_visibility_buttons { x = pal_el.x - 14, y = pal_el.y + 1 })
	gui:attach(create_color_preview { x = pal_el.x + pal_el.width + 8, y = pal_el.y })
	for i = 0, 2 do
		for j = 0, 7 do
			gui:attach(create_test_cube { x = 390 + i * 28, y = 16 + j * 28, test_id = i + 3 * j })
		end
	end
	local h_slider = create_hue_slider{ x = 6, y = 68 }
	gui:attach(h_slider)
	h_slider:attach(create_hue_sat_slider { x = slider_border, y = slider_border })
	local sl_slider = create_sat_lum_slider{ x = 192, y = 68 }
	gui:attach(create_sat_slider { x = sl_slider.x, y = sl_slider.y + sl_slider.height })
	gui:attach(create_lum_slider { x = sl_slider.x + sl_slider.width, y = sl_slider.y })
	gui:attach(sl_slider)
end


function create_palette(el)
	local size = 12
	local nb_columns = 16
	local nb_rows = 4
	el.width = (nb_columns * size) + 1
	el.height = (nb_rows * size) + 1

	function el:draw()
		clip()
		rect(0, 0, self.width, self.height, outline_color())
		for c = 0, 63 do
			local x = 1 + ((c % nb_columns) * size)
			local y = 1 + ((c \ nb_columns) * size)
			rectfill(x, y, x + size - 1, y + size - 1, c)
			if hidden[c] then
				ovalfill(x + 2, y + 2, x + size - 3, y + size - 3, 0)
			end
			if c == active_color then
				local contrast_color = blackest_color
				if pal_okhsl[active_color].l < 0.5 then
					contrast_color = whitest_color
				end
				rect(x + 1, y + 1, x + size - 2, y + size - 2, contrast_color)
			end
		end	
	end

	function el:click(msg)
		local x = min(nb_columns - 1, (msg.mx - 1) \ size)
		local y = min(nb_rows - 1, (msg.my - 1) \ size)
		local c = x + y * nb_columns
		if msg.mb == 1 then
			active_color = c
		elseif msg.mb == 2 then
			hidden[c] = not hidden[c]
		end
	end	

	return el
end


function create_visibility_buttons(el)
	local size = 12
	local nb_rows = 4
	el.width = size
	el.height = nb_rows * size
	el.cursor = "pointer"
	
	function el:draw(msg)
		pal(7, outline_color())
		for row = 0, 3 do
			if hidden_toggles[row] then
				spr(4, 0, row * size)
			else
				spr(3, 0, row * size)
			end
		end
		pal(7, 7)
	end
	
	function el:tap(msg)
		local row = mid(0, msg.my \ size, 3)
		hidden_toggles[row] = not hidden_toggles[row]
		for c = row * 16, row * 16 + 15 do
			hidden[c] = hidden_toggles[row]
		end
	end
	
	return el
end


function create_color_preview(el)
	local size = 12
	el.width = size * 4 + 2 + 120
	el.height = size * 4 + 2
	
	function el:draw(msg)
		if active_color then
			---rect(0, 0, self.height - 1, self.height - 1, 0)
			rectfill(1, 1, self.height - 2, self.height - 2, active_color)
			local contrast_color = blackest_color
			if pal_okhsl[active_color].l < 0.5 then
				contrast_color = whitest_color
			end
			print(string.format("%d", active_color), 4, 4, contrast_color)
			local c = get_color(active_color)
			print("#" .. color_to_hex(c), 7, self.height - 10, contrast_color)
			pal(7, outline_color())
			if locked[active_color] then
				spr(2, self.height + 4, 1)
			else
				spr(1, self.height + 4, 1)
			end
			if hidden[active_color] then
				spr(4, self.height + 4 + size, 1)
			else
				spr(3, self.height + 4 + size, 1)
			end
			if bg_color == active_color then
				spr(10, self.height + 4 + 2 * size, 1)
			else
				spr(9, self.height + 4 + 2 * size, 1)
			end
			pal(7, 7)
			local hue = pal_okhsl[active_color].h * 360.0
			while hue < 0.0 do
				hue += 360.0
			end
			print("\|k\014       hue: " .. string.format("%3.0f", hue) .. "", self.height + 5, 26, outline_color())
			print("\014saturation: " .. string.format("%3.0f", pal_okhsl[active_color].s * 100.0) .. "%")
			print("\014 luminance: " .. string.format("%3.0f", pal_okhsl[active_color].l * 100.0) .. "%")
		else
			print("\^pOkPal\^-p\014\|o 0.0.4", 8, 16, outline_color())
			print("\014\|4- 'save as' to create a new palette")
			print("\014- 'open' to drag-n-drop a file")
		end
	end
	
	function el:tap(msg)
		if (not active_color) return
		if msg.mx < self.height or msg.my > size then
			return
		elseif msg.mx < self.height + 4 + size then
			locked[active_color] = not locked[active_color]
		elseif msg.mx < self.height + 4 + 2 * size then
			hidden[active_color] = not hidden[active_color]
		elseif msg.mx < self.height + 4 + 3 * size then
			if key("shift") and bg_color != active_color then
				whitest_color = active_color
			elseif key("ctrl") then
				blackest_color = active_color
			elseif bg_color == active_color then
				bg_color = blackest_color
			else
				bg_color = active_color
			end
		end
	end
	
	function el:hover(msg)
		if msg.mx >= self.height + 4 and msg.mx <= self.height + 4 + 3 * size and msg.my <= size then
			self.cursor = "pointer"
		else
			self.cursor = 1
		end
	end
	
	return el
end


function create_test_cube(el)
	el.width = 24 + 4
	el.height = 24 + 4

	function el:draw()
		if false then
			rectfill(0, 0, self.width, self.width, 0)
		end
		local colors = test_cube_colors[self.test_id]
		pal(10, colors[1])
		pal(9, colors[2])
		pal(25, colors[3])
		spr(8, 2, 2)
		pal(10, 10)
		pal(9, 9)
		pal(25, 25)
	end
	
	function el:hover(msg)
		if msg.mx > 2 and msg.my > 2 and msg.mx < self.width - 2 and msg.my < self.height - 2 then
			el.cursor = "crosshair"
		else
			el.cursor = 1
		end
	end
	
	function el:click(msg)
		local face = 2
		if msg.mx > self.width - 10 or msg.my < 10 then
			if msg.mx > self.height - msg.my then
				face = 3
			else
				face = 1
			end
		end
		if msg.mb == 1 then
			undo_stack:checkpoint()
			test_cube_colors[self.test_id][face] = active_color or 1
		elseif msg.mb == 2 then
			active_color = test_cube_colors[self.test_id][face]
		end
	end
	
	return el
end


-- 2D Sliders -----------------------------------------------------------------------


function create_hue_sat_slider(el)
	---el.x = slider_border -- 240 - slider_size - 8
	---el.y = slider_border -- 74
	el.width = slider_size
	el.height = slider_size
	el.drag_delta = nil
	
	function el:draw()
		clip()
		oval(
			slider_border - 1, slider_border - 1,
			slider_border + slider_inner + 1, slider_border + slider_inner + 1,
			outline_color()
		)
		if false then
			ovalfill(
				slider_border - 1, slider_border - 1,
				slider_border + slider_inner + 1, slider_border + slider_inner + 1,
				outline_color()
			)			ovalfill(
				slider_border, slider_border,
				slider_border + slider_inner,
				slider_border + slider_inner,
				0
			)
		end
		fillp(0b0101101001011010)
		rectfill(slider_size \ 2 - 24, slider_size \ 2, slider_size \ 2 + 24, slider_size \ 2, 7)
		rectfill(slider_size \ 2, slider_size \ 2 - 24, slider_size \ 2, slider_size \ 2 + 24, 7)
		fillp()
		for c = 0, 63 do
			-- TODO: put nb_columns in global constant
			if not hidden[c] and pal_okhsl[c].l != 0 then
				local x, y = hs_coords(c)
				ovalfill(x - 3, y - 3, x + 3, y + 3, c)
			end
		end
		if active_color and not hidden[active_color] then
			local x, y = hs_coords(active_color)
			if self.drag_delta then
				-- ovalfill(x - 6, y - 6, x + 6, y + 6, 7)
				ovalfill(x - 5, y - 5, x + 5, y + 5, active_color)
			else
				oval(x - 6, y - 6, x + 6, y + 6, 7)
				ovalfill(x - 5, y - 5, x + 5, y + 5, active_color)
			end
		end
	end	
	
	function el:hover(msg)
		if (not msg.mx or not msg.my) return false
		local _, r = coords_hs(msg.mx, msg.my)
		if r > 1.02 then
			return false
		end
		if active_color and not hidden[active_color] then
			local ax, ay = hs_coords(active_color)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx <= 5 and dy <= 5 then
				self.cursor = "grab"
			else
				self.cursor = 1
			end
		end
		return true
	end
	
	function el:click(msg)
		undo_stack:checkpoint()
		local _, r = coords_hs(msg.mx, msg.my)
		if r > 1.02 then
			return false
		end
		if active_color and not hidden[active_color] then
			local ax, ay = hs_coords(active_color)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx <= 5 and dy <= 5 then
				self.drag_delta = { x = ax - msg.mx, y = ay - msg.my }
				return true
			end
		end
		active_color = nil
		-- In reverse order to prioritize colors on top
		for c = 63, 0, -1 do
			local cx, cy = hs_coords(c)
			local dx = abs(cx - msg.mx)
			local dy = abs(cy - msg.my)
			if dx <= 3 and dy <= 3 and not hidden[c] and pal_okhsl[c].l != 0 then
				active_color = c
				self.drag_delta = { x = cx - msg.mx, y = cy - msg.my }
				self.cursor = "grab"
				return true
			end
		end
		self.drag_delta = nil
		return true
	end
	
	function el:release(msg)
		self.drag_delta = nil
	end
	
	function el:drag(msg)
		if active_color and self.drag_delta and not locked[active_color] then
			local ax = msg.mx + self.drag_delta.x
			local ay = msg.my + self.drag_delta.y
			local hue, sat = coords_hs(ax, ay)
			change_color(active_color, hue, sat, nil)
			return true
		end
	end
		
	return el
end


function create_sat_lum_slider(el)
	--el.x = 240 + 8
	--el.y = 74
	el.width = slider_size
	el.height = slider_size
	el.drag_delta = nil
		
	function el:draw()
		clip()
		rect(
			slider_border - 1, slider_border - 1, 
			slider_border + slider_inner + 1, slider_border + slider_inner + 1, 
			outline_color()
		)
		if false then
			rectfill(
				slider_border, slider_border, 
				slider_border + slider_inner, slider_border + slider_inner,
				0
			)
		end
		for c = 0, 63 do
			if not hidden[c] and pal_okhsl[c].l != 0 then
				local x, y = sl_coords(c)
				ovalfill(x - 3, y - 3, x + 3, y + 3, c)
			end
		end
		if active_color and not hidden[active_color] then
			local x, y = sl_coords(active_color)
			if self.drag_delta then
				-- ovalfill(x - 6, y - 6, x + 6, y + 6, 7)
				ovalfill(x - 5, y - 5, x + 5, y + 5, active_color)
			else
				ovalfill(x - 6, y - 6, x + 6, y + 6, 7)
				ovalfill(x - 5, y - 5, x + 5, y + 5, active_color)
			end
		end
	end	

	
	function el:hover(msg)
		if active_color and not hidden[active_color] then
			local ax, ay = sl_coords(active_color)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx < 6 and dy < 6 then
				self.cursor = "grab"
			else
				self.cursor = 1
			end
		end
	end
	
	function el:click(msg)
		undo_stack:checkpoint()
		if active_color and not hidden[active_color] then
			local ax, ay = sl_coords(active_color)
			local dx = abs(ax - msg.mx)
			local dy = abs(ay - msg.my)
			if dx < 6 and dy < 6 then
				self.drag_delta = { x = ax - msg.mx, y = ay - msg.my }
				return
			end
		end
		active_color = nil
		-- In reverse order to prioritize colors on top
		for c = 63, 0, -1 do
			local cx, cy = sl_coords(c)
			local dx = abs(cx - msg.mx)
			local dy = abs(cy - msg.my)
			if dx < 3 and dy < 3 and not hidden[c] and pal_okhsl[c].l != 0 then
				active_color = c
				self.drag_delta = { x = cx - msg.mx, y = cy - msg.my }
				self.cursor = "grab"
				return
			end
		end
		self.drag_delta = nil
	end
	
	function el:release(msg)
		self.drag_delta = nil
	end
	
	function el:drag(msg)
		if active_color and self.drag_delta and not locked[active_color] then
			local ax = msg.mx + self.drag_delta.x
			local ay = msg.my + self.drag_delta.y
			local sat, lum = coords_sl(ax, ay)
			change_color(active_color, nil, sat, lum)
		end
	end
	
	return el
end


-- 1D Sliders ----------------------------------------------------------------------


function create_hue_slider(el)
	el.width = slider_size + 2 * slider_border
	el.height = slider_size + 2 * slider_border

	function el:draw()
		clip()
		for c = 0, 63 do
			if not hidden[c] and pal_okhsl[c].l != 0 then
				cx1, cy1 = h_coords(c, -2)
				cx2, cy2 = h_coords(c, 18)
				line(cx1, cy1, cx2, cy2, c)
			end
		end
		if active_color and not hidden[active_color] then
			local ax, ay = h_coords(active_color)
			pal(7, outline_color())
			pal(13, active_color)
			spr(7, ax - 4, ay - 4)
			pal(13, 13)
			pal(7, 7)
		end
	end	

	function el:hover(msg)
		-- I think there is a bug in Picotron's handling of mouse coords
		-- when one widget is on top of another.
		--[[
		if (not msg.mx or not msg.my) return
		if active_color then
			local ax, ay = h_coords(active_color)
			--printh(string.format("%.0f %.0f - %.0f %.0f", ax, ay, msg.mx, msg.my))
			if
				msg.mx >= ax - 6 and msg.mx <= ax + 6
				and msg.my >= ay - 6 and msg.my <= ay + 6
			then
				self.cursor = "grab"
			else
				self.cursor = 1
			end
		end
		--]]
	end

	function el:click(msg)
		undo_stack:checkpoint()
		if active_color and not hidden[active_color] then
			local ax, ay = h_coords(active_color)
			--[[
			if
				msg.mx >= ax - 6 and msg.mx <= ax + 6
				and msg.my >= ay - 6 and msg.my <= ay + 6
			then
			]]
				self.drag_delta = { x = ax - msg.mx, y = ay - msg.my }
			-- end
		end
	end
	
	function el:release(msg)
		self.drag_delta = nil
	end
	
	function el:drag(msg)
		if active_color and self.drag_delta and not locked[active_color] then
			local ax = msg.mx + self.drag_delta.x
			local ay = msg.my + self.drag_delta.y
			local hue = coords_h(ax, ay)
			change_color(active_color, hue, nil, nil)
		end
	end
	
	return el
end


function create_sat_slider(el)
	el.width = slider_size
	el.height = 16
	
	function el:draw()
		clip()
		for c = 0, 63 do
			if not hidden[c] and pal_okhsl[c].l != 0 then
				local ax, _ = sl_coords(c)
				line(ax, 0, ax, self.height - 9, c)
			end
		end
		if active_color and not hidden[active_color] then
			local ax, _ = sl_coords(active_color)
			pal(7, outline_color())
			pal(13, active_color)
			spr(5, ax - 4, self.height - 9)
			pal(13, 13)
			pal(7, 7)
		end
	end	
	
	function el:hover(msg)
		if active_color and not hidden[active_color] then
			local ax, _ = sl_coords(active_color)
			if msg.mx and msg.mx >= ax - 4 and msg.mx <= ax + 4 and msg.my >= self.height - 9 then
				self.cursor = "grab"
			else
				self.cursor = 1
			end
		end
	end

	function el:click(msg)
		undo_stack:checkpoint()
		if active_color and not hidden[active_color] then
			local ax, _ = sl_coords(active_color)
			if msg.mx and msg.mx >= ax - 4 and msg.mx <= ax + 4 and msg.my >= self.height - 9 then
				self.drag_delta_x = ax - msg.mx
			end
		end
	end
	
	function el:release(msg)
		self.drag_delta_x = nil
	end
	
	function el:drag(msg)
		if active_color and self.drag_delta_x and not locked[active_color] then
			local ax = msg.mx + self.drag_delta_x
			local sat, lum = coords_sl(ax, 0)
			change_color(active_color, nil, sat, nil)
		end
	end
		
	return el
end


function create_lum_slider(el)
	el.width = 16
	el.height = slider_size
	
	function el:draw()
		clip()
		for c = 0, 63 do
			if not hidden[c] and pal_okhsl[c].l != 0 then
				local _, ay = sl_coords(c)
				line(0, ay, self.width - 9, ay, c)
			end
		end
		if active_color and not hidden[active_color] then
			local _, ay = sl_coords(active_color)
			pal(7, outline_color())
			pal(13, active_color)
			spr(6, self.width - 9, ay - 4)
			pal(13, 13)
			pal(7, 7)
		end
	end	
	
	function el:hover(msg)
		if active_color and not hidden[active_color] then
			local _, ay = sl_coords(active_color)
			if msg.my and msg.my >= ay - 4 and msg.my <= ay + 4 and msg.mx >= self.width - 9 then
				self.cursor = "grab"
			else
				self.cursor = 1
			end
		end
	end

	function el:click(msg)
		undo_stack:checkpoint()
		if active_color and not hidden[active_color] then
			local _, ay = sl_coords(active_color)
			if msg.my and msg.my >= ay - 4 and msg.my <= ay + 4 and msg.mx >= self.width - 9 then
				self.drag_delta_y = ay - msg.my
			end
		end
	end
	
	function el:release(msg)
		self.drag_delta_y = nil
	end
	
	function el:drag(msg)
		if active_color and self.drag_delta_y and not locked[active_color] then
			local ay = msg.my + self.drag_delta_y
			local sat, lum = coords_sl(0, ay)
			change_color(active_color, nil, nil, lum)
		end
	end
		
	return el
end


-- Utility functions ----------------------------------------------------------------


function outline_color()
	if pal_okhsl[bg_color].l < 0.5 then
		return whitest_color
	else
		return blackest_color
	end
end


function sl_coords(c)
	local sat = pal_okhsl[c].s
	local lum = pal_okhsl[c].l
	local x = slider_border + sat * slider_inner
	local y = slider_border + slider_inner - lum * slider_inner
	return x, y
end


function coords_sl(x, y)
	local sat = (x - slider_border) / slider_inner
	local lum = 1.0 - ((y - slider_border) / slider_inner)
	return sat, lum
end


-- Remove 0.25 to compensate for Picotron's angle origin,
-- and 29/360 to compensate for OkLab weird position of
-- the red color.
local angle_correction = 0.25 + 0.08


function hs_coords(c)
	local hue = pal_okhsl[c].h
	local sat = mid(0.0, pal_okhsl[c].s, 1.0)
	local a = angle_correction - hue
	local dx = sat * cos(a) * (slider_inner / 2)
	local dy = sat * sin(a) * (slider_inner / 2)
	local x = slider_border + (slider_inner / 2) + dx
	local y = slider_border + (slider_inner / 2) + dy
	return x, y
end


function coords_hs(x, y)
	local dx = x - (slider_border + (slider_inner / 2))
	local dy = y - (slider_border + (slider_inner / 2))
	local hue = -atan2(dx, dy) + angle_correction
	dx = (2.0 * dx) / slider_inner
	dy = (2.0 * dy) / slider_inner
	local sat = sqrt(dx * dx + dy * dy) -- / (slider_inner / 2)
	return hue, sat
end


function h_coords(c, radius_delta)
	local s = slider_size + 2 * slider_border
	local r = s - slider_border + (radius_delta or 0)
	local hue = pal_okhsl[c].h
	local a = angle_correction - hue
	local dx = cos(a) * (r / 2)
	local dy = sin(a) * (r / 2)
	local x = (s / 2) + dx + 0.5
	local y = (s / 2) + dy + 0.5
	return x, y
end


function coords_h(x, y)
	local s = slider_size + 2 * slider_border
	local r = s - 6
	local dx = x - ((s / 2) + 0.5)
	local dy = y - ((s / 2) + 0.5)
	local hue = -atan2(dx, dy) + angle_correction
	dx = (2.0 * dx) / r
	dy = (2.0 * dy) / r
	local sat = sqrt(dx * dx + dy * dy)
	return hue, sat
end
:: src/hexdialog.lua
--[[pod_format="raw",created="2024-04-03 19:36:00",modified="2024-04-04 16:27:03",revision=819]]
gui_state = {
	choice = "dont_clobber"
}


function _init()
	window {
	    width = 208,
	    height = 124,
	    title = "Import Hex File",
	    resizeable = false,
	}
	
	gui = create_gui()
	
	local x, y = 16, 16
	local line_height = 12
	local line_gap = 2
	gui:attach(create_radio_button {
		x = x, y = y, 
		label = "Don't overwrite Picotron palette\n(only use last 32 colors)",
		group = "choice",
		key = "dont_clobber",
	})
	y += 2 * line_height + line_gap
	gui:attach(create_radio_button {
		x = x, y = y, 
		label = "Overwrite but reorder colors\nto match Picotron palette",
		group = "choice",
		key = "remap",
	})
	y += 2 * line_height + line_gap
	gui:attach(create_radio_button {
		x = x, y = y, 
		label = "Overwrite *without* reordering\n(may render GUI hard to use!)",
		group = "choice",
		key = "overwrite",
	})
	
	y += 2 * line_height + 12
	x = 150
	
	gui:attach_button {
		x = x, y = y,
		label = "Import",
		bgcol = 0x060d,
		fgcol = 0x0101,
		tap = handle_confirm,
	}
end


function _draw()
	cls(7)
	gui:draw_all()
end


function _update()
	gui:update_all()
end


function handle_confirm()
	send_message(
		env().okpal_parent_pid,
		{
			event = "okpal_hexdialog_confirm",
			okpal_filename = env().okpal_filename,
			okpal_hexdialog_choice = gui_state.choice,
		}
	)
	exit(0)
end


-- Widgets ------------------------------------------------------------------------


function create_radio_button(el)
	el.width = 188
	el.height = 80 -- TODO: count the lines?
	el.cursor = "pointer"
	
	function el:draw()
		oval(0, 0, 8, 8, 1)
		if gui_state[el.group] == el.key then
			ovalfill(2, 2, 6, 6, 1)
		end
		print(el.label, 15, 1, 13)
	end
	
	function el:tap()
		gui_state[el.group] = el.key
	end
	
	return el
end
:: src/oklab.lua
--[[pod_format="raw",created="2024-03-31 09:08:26",modified="2024-04-02 08:53:32",revision=979]]
-- Copyright(c) 2021 Bjorn Ottosson
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of
-- this software and associated documentation files(the "Software"), to deal in
-- the Software without restriction, including without limitation the rights to
-- use, copy, modify, merge, publish, distribute, sublicense, and /or sell copies
-- of the Software, and to permit persons to whom the Software is furnished to do
-- so, subject to the following conditions:
--
-- The above copyright noticeand this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

oklab = {}
oklab.__index = oklab

function oklab.color_to_okhsl(code)
	local srgb = {
		r = ((code & 0xff0000) >> 16) / 255,
		g = ((code & 0x00ff00) >> 8) / 255,
		b = ((code & 0x0000ff)) / 255,
	}
	return oklab.srgb_to_okhsl(srgb)
end

function oklab.okhsl_to_color(okhsl)
	local srgb = oklab.okhsl_to_srgb(okhsl)
	local r = mid(0x00, math.floor(srgb.r * 255 + 0.5), 0xff)
	local g = mid(math.floor(srgb.g * 255 + 0.5), 0xff)
	local b = mid(math.floor(srgb.b * 255 + 0.5), 0xff)
	return (r << 16) | (g << 8) | b
end

function oklab.new()
    local inst = setmetatable({}, oklab)
    return inst
end

-- Finds the maximum saturation possible for a given hue that fits in sRGB
-- Saturation here is defined as S = C/L
-- a and b must be normalized so a^2 + b^2 == 1
function oklab.compute_max_saturation(a, b)
    if a ~= 0.0 or b ~= 0.0 then
    	-- Max saturation will be when one of r, g or b goes below zero.
        -- Select different coefficients depending on which component goes below zero first

        -- Blue component (default)
        local k0 = 1.35733652
        local k1 = -0.00915799
        local k2 = -1.1513021
        local k3 = -0.50559606
        local k4 = 0.00692167
        local wl = -0.0041960863
        local wm = -0.7034186147
        local ws = 1.707614701

        if -1.88170328 * a - 0.80936493 * b > 1 then
            -- Red component
            k0 = 1.19086277
            k1 = 1.76576728
            k2 = 0.59662641
            k3 = 0.75515197
            k4 = 0.56771245
            wl = 4.0767416621
            wm = -3.3077115913
            ws = 0.2309699292
        elseif 1.81444104 * a - 1.19445276 * b > 1 then
            -- Green component
            k0 = 0.73956515
            k1 = -0.45954404
            k2 = 0.08285427
            k3 = 0.1254107
            k4 = 0.14503204
            wl = -1.2684380046
            wm = 2.6097574011
            ws = -0.3413193965
        end

        -- Approximate max saturation using a polynomial:
        local S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b

        -- Do one step Halley's method to get closer
        -- this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite
        -- this should be sufficient for most applications, otherwise do two/three steps

        local k_l = 0.3963377774 * a + 0.2158037573 * b
        local k_m = -0.1055613458 * a - 0.0638541728 * b
        local k_s = -0.0894841775 * a - 1.291485548 * b

        do
            local l_ = 1.0 + S * k_l
            local m_ = 1.0 + S * k_m
            local s_ = 1.0 + S * k_s

            local l = l_ * l_ * l_
            local m = m_ * m_ * m_
            local s = s_ * s_ * s_

            local l_dS = 3.0 * k_l * l_ * l_
            local m_dS = 3.0 * k_m * m_ * m_
            local s_dS = 3.0 * k_s * s_ * s_

            local l_dS2 = 6.0 * k_l * k_l * l_
            local m_dS2 = 6.0 * k_m * k_m * m_
            local s_dS2 = 6.0 * k_s * k_s * s_

            local f = wl * l + wm * m + ws * s
            local f1 = wl * l_dS + wm * m_dS + ws * s_dS
            local f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2

            local s_denom = f1 * f1 - 0.5 * f * f2
            if s_denom ~= 0.0 then  S = S - f * f1 / s_denom end
        end

        return S
    else
        return 0.0
    end
end

-- finds L_cusp and C_cusp for a given hue
-- a and b must be normalized so a^2 + b^2 == 1
function oklab.find_cusp(a, b)
	-- First, find the maximum saturation (saturation S = C/L)
    local S_cusp = oklab.compute_max_saturation(a, b)

    -- Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:
    local rgb_at_max = oklab.oklab_to_linear_srgb({L = 1, a = S_cusp * a, b = S_cusp * b })
    local max_comp = math.max(rgb_at_max.r, rgb_at_max.g, rgb_at_max.b)
    if max_comp ~= 0.0 then
        local L_cusp = (1.0 / max_comp) ^ 0.3333333333333333
        return { L = L_cusp, C = L_cusp * S_cusp }
    else
        return { L = 0.0, C = 0.0 }
    end
end

-- Finds intersection of the line defined by
-- L = L0 * (1 - t) + t * L1
-- C = t * C1
-- a and b must be normalized so a^2 + b^2 == 1
function oklab.find_gamut_intersection(a, b, L1, C1, L0, x)
    -- Find the cusp of the gamut triangle
    local cusp = x or oklab.find_cusp(a, b)

    -- Find the intersection for upper and lower half separately
    local t = 0.0
    if ((L1 - L0) * cusp.C - (cusp.L - L0) * C1) <= 0.0 then
        -- Lower half
        local t_denom = C1 * cusp.L + cusp.C * (L0 - L1)
        if t_denom ~= 0.0 then t = cusp.C * L0 / t_denom end
    else
        -- Upper half
        -- First intersect with triangle
        local t_denom = C1 * (cusp.L - 1.0) + cusp.C * (L0 - L1)
        if t_denom ~= 0.0 then t = cusp.C * (L0 - 1.0) / t_denom end

        -- Then one step Halley's method
        do
            local dL = L1 - L0
            local dC = C1

            local k_l = 0.3963377774 * a + 0.2158037573 * b
            local k_m = -0.1055613458 * a - 0.0638541728 * b
            local k_s = -0.0894841775 * a - 1.291485548 * b

            local l_dt = dL + dC * k_l
            local m_dt = dL + dC * k_m
            local s_dt = dL + dC * k_s

            -- If higher accuracy is required, 2 or 3 iterations of the following block can be used:
            do
                local L = L0 * (1.0 - t) + t * L1
				local C = t * C1

				local l_ = L + C * k_l
				local m_ = L + C * k_m
				local s_ = L + C * k_s

				local l = l_ * l_ * l_
				local m = m_ * m_ * m_
				local s = s_ * s_ * s_

				local ldt = 3.0 * l_dt * l_ * l_
				local mdt = 3.0 * m_dt * m_ * m_
				local sdt = 3.0 * s_dt * s_ * s_

				local ldt2 = 6.0 * l_dt * l_dt * l_
				local mdt2 = 6.0 * m_dt * m_dt * m_
				local sdt2 = 6.0 * s_dt * s_dt * s_

                local r0 = 4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s - 1
				local r1 = 4.0767416621 * ldt - 3.3077115913 * mdt + 0.2309699292 * sdt
				local r2 = 4.0767416621 * ldt2 - 3.3077115913 * mdt2 + 0.2309699292 * sdt2

                local r_denom = r1 * r1 - 0.5 * r0 * r2
                local u_r = 0.0
                if r_denom ~= 0.0 then u_r = r1 / r_denom end
				local t_r = -r0 * u_r

                local g0 = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s - 1
				local g1 = -1.2684380046 * ldt + 2.6097574011 * mdt - 0.3413193965 * sdt
				local g2 = -1.2684380046 * ldt2 + 2.6097574011 * mdt2 - 0.3413193965 * sdt2

                local g_denom = g1 * g1 - 0.5 * g0 * g2
                local u_g = 0.0
                if g_denom ~= 0.0 then u_g = g1 / g_denom end
				local t_g = -g0 * u_g

                local b0 = -0.0041960863 * l - 0.7034186147 * m + 1.707614701 * s - 1
				local b1 = -0.0041960863 * ldt - 0.7034186147 * mdt + 1.707614701 * sdt
				local b2 = -0.0041960863 * ldt2 - 0.7034186147 * mdt2 + 1.707614701 * sdt2

                local b_denom = (b1 * b1 - 0.5 * b0 * b2)
                local u_b = 0.0
                if b_denom ~= 0.0 then u_b = b1 / b_denom end
				local t_b = -b0 * u_b

                if u_r < 0.0 then t_r = 3.40282347e+38 end
                if u_g < 0.0 then t_g = 3.40282347e+38 end
                if u_b < 0.0 then t_b = 3.40282347e+38 end

                t = t + math.min(t_r, t_g, t_b)
            end
        end
    end

    return t
end

function oklab.get_Cs(L, a_, b_)
    local cusp = oklab.find_cusp(a_, b_)
    local C_max = oklab.find_gamut_intersection(a_, b_, L, 1.0, L, cusp)
    local ST_max = oklab.to_ST(cusp)

    -- Scale factor to compensate for the curved part of gamut shape:
    local k = 0.0
    local k_denom = math.min(L * ST_max.S, (1.0 - L) * ST_max.T)
    if k_denom ~= 0.0 then k = C_max / k_denom end

    local C_mid = 0.0
    do
        local ST_mid = oklab.get_ST_mid(a_, b_)

        -- Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.
        local C_a = L * ST_mid.S
        local C_b = (1.0 - L) * ST_mid.T

        local cae4 = C_a * C_a * C_a * C_a
        local cbe4 = C_b * C_b * C_b * C_b
        C_mid = 0.9 * k * ((1.0 / (1.0 / cae4 + 1.0 / cbe4)) ^ 0.25)
    end

    local C_0 = 0.0
    do
        -- for C_0, the shape is independent of hue, so ST are constant. Values picked to roughly be the average values of ST.
        local C_a = L * 0.4
        local C_b = (1.0 - L) * 0.8

        -- Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.
        local cae2 = C_a * C_a
        local cbe2 = C_b * C_b
        C_0 = math.sqrt(1.0 / (1.0 / cae2 + 1.0 / cbe2))
    end

    return { C_0 = C_0, C_mid = C_mid, C_max = C_max }
end

-- Returns a smooth approximation of the location of the cusp
-- This polynomial was created by an optimization process
-- It has been designed so that S_mid < S_max and T_mid < T_max
function oklab.get_ST_mid(a_, b_)
    local S = 0.11516993
    local s_denom = 7.4477897 + 4.1590124 * b_
        + a_ * (-2.19557347 + 1.75198401 * b_
        + a_ * (-2.13704948 - 10.02301043 * b_
        + a_ * (-4.24894561 + 5.38770819 * b_ + 4.69891013 * a_)))
    if s_denom ~= 0.0 then
        S = 0.11516993 + 1.0 / s_denom
    end

    local T = 0.11239642
    local t_denom = 1.6132032 - 0.68124379 * b_
        + a_ * (0.40370612 + 0.90148123 * b_
        + a_ * (-0.27087943 + 0.6122399 * b_
        + a_ * (0.00299215 - 0.45399568 * b_ - 0.14661872 * a_)))
	if t_denom ~= 0.0 then
        T = 0.11239642 + 1.0 / t_denom
    end

	return { S = S, T = T }
end

function oklab.linear_srgb_to_oklab(c)
    local l = 0.4122214708 * c.r
            + 0.5363325363 * c.g
            + 0.0514459929 * c.b
	local m = 0.2119034982 * c.r
            + 0.6806995451 * c.g
            + 0.1073969566 * c.b
	local s = 0.0883024619 * c.r
            + 0.2817188376 * c.g
            + 0.6299787005 * c.b

    local l_ = l ^ 0.3333333333333333
    local m_ = m ^ 0.3333333333333333
    local s_ = s ^ 0.3333333333333333

    return {
        L = 0.2104542553 * l_
          + 0.793617785 * m_
          - 0.0040720468 * s_,
        a = 1.9779984951 * l_
          - 2.428592205 * m_
          + 0.4505937099 * s_,
        b = 0.0259040371 * l_
          + 0.7827717662 * m_
          - 0.808675766 * s_ }
end

function oklab.okhsl_to_oklab(hsl)
	local l = hsl.l
    if l >= 1.0 then return { L = 1.0, a = 0.0, b = 0.0 } end
    if l <= 0.0 then return { L = 0.0, a = 0.0, b = 0.0 } end

    local s = hsl.s
    if s < 0.0 then s = 0.0 end
    if s > 1.0 then s = 1.0 end

    local h = hsl.h
    local h_rad = h * 6.283185307179586
    local a_ = math.cos(h_rad)
    local b_ = math.sin(h_rad)
    local L = oklab.toe_inv(l)

    local cs = oklab.get_Cs(L, a_, b_)
    local C_0 = cs.C_0
	local C_mid = cs.C_mid
	local C_max = cs.C_max

    local mid = 0.8
	local mid_inv = 1.25

    local C = 0.0
    local t = 0.0
    local k_0 = 0.0
    local k_1 = 0.0
    local k_2 = 0.0
    if s < mid then
        t = mid_inv * s

		k_1 = mid * C_0
        if C_mid ~= 0.0 then
		    k_2 = 1.0 - k_1 / C_mid
        end

        local k_denom = 1.0 - k_2 * t
		if k_denom ~= 0.0 then
            C = t * k_1 / k_denom
        end
    else
        local t_denom = 1.0 - mid
        if t_denom ~= 0.0 then
            t = (s - mid) / t_denom
        end

		k_0 = C_mid
        if C_0 ~= 0.0 then
		    k_1 = (1.0 - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0
        end

        local C_denom = C_max - C_mid
		k_2 = 1.0
        if C_denom ~= 0.0 then
            k_2 = 1.0 - k_1 / C_denom
        end

        local k_denom = 1.0 - k_2 * t
        if k_denom ~= 0.0 then
		    C = k_0 + t * k_1 / k_denom
        end
    end

    return {
        L = L,
        a = C * a_,
        b = C * b_ }
end

function oklab.okhsl_to_srgb(hsl)
    return oklab.oklab_to_srgb(oklab.okhsl_to_oklab(hsl))
end

function oklab.okhsv_to_oklab(hsv)
	local v = hsv.v
    if v <= 0.0 then return { L = 0.0, a = 0.0, b = 0.0 } end
    if v > 1.0 then v = 1.0 end

    local s = hsv.s
    if s < 0.0 then s = 0.0 end
    if s > 1.0 then s = 1.0 end

    local h = hsv.h
    local h_rad = h * 6.283185307179586
    local a_ = math.cos(h_rad)
    local b_ = math.sin(h_rad)

    local cusp = oklab.find_cusp(a_, b_)
	local ST_max = oklab.to_ST(cusp)
	local S_max = ST_max.S
	local T_max = ST_max.T
	local S_0 = 0.5
    local k = 1.0
    if S_max ~= 0.0 then
	    k = 1.0 - S_0 / S_max
    end

    -- first we compute L and V as if the gamut is a perfect triangle:

	-- L, C when v==1:
    local v_denom = S_0 + T_max - T_max * k * s
    local L_v = 1.0
    local C_v = 0.0
    if v_denom ~= 0.0 then
        L_v = 1.0 - s * S_0 / v_denom
	    C_v = s * T_max * S_0 / v_denom
    end

    local L = v * L_v
	local C = v * C_v

    --then we compensate for both toe and the curved top part of the triangle:
    local L_vt = oklab.toe_inv(L_v)
    local C_vt = 0.0
    if L_v ~= 0.0 then
        C_vt = C_v * L_vt / L_v
    end

    local L_new = oklab.toe_inv(L)
    if L ~= 0.0 then
        C = C * L_new / L
    end
    L = L_new

    local rgb_scale = oklab.oklab_to_linear_srgb({
        L = L_vt,
        a = a_ * C_vt,
        b = b_ * C_vt })
    local max_comp = math.max(
        rgb_scale.r,
        rgb_scale.g,
        rgb_scale.b, 0.0)
    local scale_L = 0.0
    if max_comp ~= 0.0 then
        scale_L = (1.0 / max_comp) ^ 0.3333333333333333
    end

	C = C * scale_L
    return {
        L = L * scale_L,
        a = C * a_,
        b = C * b_ }
end

function oklab.okhsv_to_srgb(hsv)
    return oklab.oklab_to_srgb(oklab.okhsv_to_oklab(hsv))
end

function oklab.oklab_to_linear_srgb(lab)
    local l_ = lab.L
        + 0.3963377774 * lab.a
        + 0.2158037573 * lab.b
	local m_ = lab.L
        - 0.1055613458 * lab.a
        - 0.0638541728 * lab.b
	local s_ = lab.L
        - 0.0894841775 * lab.a
        - 1.291485548 * lab.b

    local l = l_ * l_ * l_
    local m = m_ * m_ * m_
    local s = s_ * s_ * s_

    return {
        r = 4.0767416621 * l
          - 3.3077115913 * m
          + 0.2309699292 * s,
        g = -1.2684380046 * l
           + 2.6097574011 * m
           - 0.3413193965 * s,
        b = -0.0041960863 * l
           - 0.7034186147 * m
           + 1.707614701 * s }
end

function oklab.oklab_to_okhsl(lab)
    local L = lab.L
    if L >= 1.0 then return { h = 0.0, s = 0.0, l = 1.0 } end
    if L <= 0.0 then return { h = 0.0, s = 0.0, l = 0.0 } end

    local Csq = lab.a * lab.a + lab.b * lab.b
    if Csq > 0.0 then
        local C = math.sqrt(Csq)
        local a_ = lab.a / C
        local b_ = lab.b / C

        -- 1.0 / math.pi = 0.3183098861837907
        local h = 0.5 + 0.5 * math.atan(-lab.b, -lab.a) * 0.3183098861837907

        local cs = oklab.get_Cs(L, a_, b_)
        local C_0 = cs.C_0
        local C_mid = cs.C_mid
        local C_max = cs.C_max

        -- Inverse of the interpolation in okhsl_to_srgb:
        local mid = 0.8
        local mid_inv = 1.25

        local s = 0.0
        if C < C_mid then
            local k_1 = mid * C_0
            local k_2 = 1.0
            if C_mid ~= 0.0 then
                k_2 = (1.0 - k_1 / C_mid)
            end

            local t_denom = k_1 + k_2 * C
            local t = 0.0
            if t_denom ~= 0.0 then
                t = C / t_denom
            end

            s = t * mid
        else
            local k_0 = C_mid
            local k_1 = 0.0
            if C_0 ~= 0.0 then
                k_1 = (1.0 - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0
            end

            local C_denom = C_max - C_mid
            local k_2 = 1.0
            if C_denom ~= 0.0 then
                k_2 = 1.0 - k_1 / C_denom
            end

            local t_denom = k_1 + k_2 * (C - k_0)
            local t = 0.0
            if t_denom ~= 0.0 then
                t = (C - k_0) / t_denom
            end

            s = mid + (1.0 - mid) * t
        end

        return { h = h, s = s, l = oklab.toe(L) }
    else
        return { h = 0.0, s = 0.0, l = L }
    end
end

function oklab.oklab_to_okhsv(lab)
    local L = lab.L
    if L >= 1.0 then return { h = 0.0, s = 0.0, v = 1.0 } end
    if L <= 0.0 then return { h = 0.0, s = 0.0, v = 0.0 } end

    local Csq = lab.a * lab.a + lab.b * lab.b
    if Csq > 0.0 then
        local C = math.sqrt(Csq)
        local a_ = lab.a / C
        local b_ = lab.b / C

        -- 1.0 / math.pi = 0.3183098861837907
        local h = 0.5 + 0.5 * math.atan(-lab.b, -lab.a) * 0.3183098861837907

        local cusp = oklab.find_cusp(a_, b_)
        local ST_max = oklab.to_ST(cusp)
        local S_max = ST_max.S
        local T_max = ST_max.T
        local S_0 = 0.5
        local k = 1.0
        if S_max ~= 0.0 then
            k = 1.0 - S_0 / S_max
        end

        -- first we find L_v, C_v, L_vt and C_vt
        local t_denom = C + L * T_max
        local t = 0.0
        if t_denom ~= 0.0 then
            t = T_max / t_denom
        end
        local L_v = t * L
        local C_v = t * C

        local L_vt = oklab.toe_inv(L_v)
        local C_vt = 0.0
        if L_v ~= 0.0 then
            C_vt = C_v * L_vt / L_v
        end

        -- we can then use these to invert the step that compensates for the toe and the curved top part of the triangle:
        local rgb_scale = oklab.oklab_to_linear_srgb({
            L = L_vt,
            a = a_ * C_vt,
            b = b_ * C_vt })
        local scale_denom = math.max(
            rgb_scale.r,
            rgb_scale.g,
            rgb_scale.b, 0.0)
        local scale_L = 0.0
        if scale_denom ~= 0.0 then
            scale_L = (1.0 / scale_denom) ^ 0.3333333333333333
            L = L / scale_L
            C = C / scale_L
        end

        local toel = oklab.toe(L)
        C = C * toel / L
        L = toel

        -- we can now compute v and s:
        local v = 0.0
        if L_v ~= 0.0 then v = L / L_v end

        local s = 0.0
        local s_denom = ((T_max * S_0) + T_max * k * C_v)
        if s_denom ~= 0.0 then
            s = (S_0 + T_max) * C_v / s_denom
        end

        return { h = h, s = s, v = v }
    else
        return { h = 0.0, s = 0.0, v = L }
    end
end

function oklab.oklab_to_srgb(lab)
    local lrgb = oklab.oklab_to_linear_srgb(lab)
	return {
		r = oklab.srgb_transfer_function(lrgb.r),
		g = oklab.srgb_transfer_function(lrgb.g),
		b = oklab.srgb_transfer_function(lrgb.b) }
end

function oklab.srgb_to_okhsl(rgb)
    return oklab.oklab_to_okhsl(oklab.srgb_to_oklab(rgb))
end

function oklab.srgb_to_okhsv(rgb)
    return oklab.oklab_to_okhsv(oklab.srgb_to_oklab(rgb))
end

function oklab.srgb_to_oklab(srgb)
    return oklab.linear_srgb_to_oklab({
		r = oklab.srgb_transfer_function_inv(srgb.r),
		g = oklab.srgb_transfer_function_inv(srgb.g),
		b = oklab.srgb_transfer_function_inv(srgb.b) })
end

function oklab.srgb_transfer_function(a)
    if 0.0031308 >= a then
        return 12.92 * a
    else
        return 1.055 * (a ^ 0.4166666666666667) - 0.055
    end
end

function oklab.srgb_transfer_function_inv(a)
    if 0.04045 < a then
        return ((a + 0.055) * 0.9478672985781991) ^ 2.4
    else
        return a * 0.07739938080495357
    end
end

function oklab.to_ST(cusp)
	local L = cusp.L
    local C = cusp.C
    if L ~= 0.0 and L ~= 1.0 then
        return { S = C / L, T = C / (1.0 - L) }
    elseif L ~= 0.0 then
        return { S = C / L, T = 0.0 }
    elseif L ~= 1.0 then
        return { S = 0.0, T = C / (1.0 - L) }
    else
        return { S = 0.0, T = 0.0 }
    end
end

function oklab.toe(x)
    local y = 1.170873786407767 * x - 0.206
	return 0.5 * (y + math.sqrt(y * y + 0.14050485436893204 * x))
end

function oklab.toe_inv(x)
    local denom = 1.170873786407767 * (x + 0.03)
    if denom ~= 0.0 then
    	return (x * x + 0.206 * x) / denom
    else
        return 0.0
    end
end

return oklab
:: src/palette.lua
--[[pod_format="raw",created="2024-03-31 08:27:10",modified="2024-04-04 16:27:03",revision=2457]]
function set_color(c, code)
	poke4(0x5000 + 4 * c, code)
end


function get_color(c)
	return peek4(0x5000 + 4 * c)
end


function color_to_hex(c)
	return string.format("%06x", c)
end


function rebuild_pal(c)
	for c = 0, 63 do
		change_color_code(c)
	end
end


function change_color_code(c)
	pal_code[c] = get_color(c)
	pal_okhsl[c] = oklab.color_to_okhsl(pal_code[c])
end


function change_color(c, hue, sat, lum)
	local hsl = {
		h = hue or pal_okhsl[c].h,
		s = sat or pal_okhsl[c].s,
		l = lum or pal_okhsl[c].l,
	}
	hsl.h = mid(-1.0, hsl.h, 1.0)
	hsl.s = mid(0.0, hsl.s, 1.0)
	hsl.l = mid(0.0, hsl.l, 1.0)
	local code = oklab.okhsl_to_color(hsl)
	pal_code[c] = code
	pal_okhsl[c] = hsl
	set_color(c, code)
	return
end
:: src/remap.lua
--[[pod_format="raw",created="2024-04-04 07:28:50",modified="2024-04-04 16:27:03",revision=471]]
-- Color remapping ---------------------------------------------------------------


-- assumes `pal_okhsl` is up to date
function remap_colors()
	local new_pal_code = {}
	local picotron_okhsl = {}
	local remaining_pico_c = {}
	local remaining_new_c = { 0 }
	for pico_c = 0, 31 do
		local code = peek4(0x5000 + 4 * (64 + pico_c))
		picotron_okhsl[pico_c] = oklab.color_to_okhsl(code)
		add(remaining_pico_c, pico_c)
	end	
	for c = 1, 63 do
		if pal_code[c] != 0x000000 then
			add(remaining_new_c, c)
		end
	end

		
	-- Choose colors 0 (black) and 7 (white) first
	local best_black, best_white = find_blackest_and_whitest()
	new_pal_code[0] = pal_code[best_black]
	del(remaining_pico_c, 0)
	del(remaining_new_c, best_black)
	new_pal_code[7] = pal_code[best_white]
	del(remaining_pico_c, 7)
	del(remaining_new_c, best_white)
		
	-- Find best match for the other colors
	local deltas = {}
	for c = 0, 63 do
		deltas[c] = {}
		for pico_c = 0, 31 do
			local delta_sat = pal_okhsl[c].s - picotron_okhsl[pico_c].s
			local delta_lum = pal_okhsl[c].l - picotron_okhsl[pico_c].l
			-- TODO: should ignore hue if sat or lum is low
			local delta_hue = pal_okhsl[c].h - picotron_okhsl[pico_c].h
			if delta_hue > 360.0 then
				delta_hue -= 360.0
			elseif delta_hue < -360.0 then
				delta_hue += 360.0
			end

			delta_hue *= 2.0 * picotron_okhsl[pico_c].s * pal_okhsl[c].s
			delta_sat *= 0.5

			deltas[c][pico_c] =
				math.sqrt(
					(delta_hue * delta_hue)
					+ (delta_sat * delta_sat)
					+ (delta_lum * delta_lum)
				)
		end
	end
	
	while #remaining_pico_c > 0 and #remaining_new_c > 0  do
		local min_delta = 1000.0
		local match_c = nil
		local match_pico_c = nil
		for i = 1, #remaining_new_c do
			local c = remaining_new_c[i]
			for j = 1, #remaining_pico_c do
				local pico_c = remaining_pico_c[j]
				local d = deltas[c][pico_c]
				if d and d < min_delta then
					min_delta = d
					match_c = c
					match_pico_c = pico_c
				end
			end
		end
		if match_c then
			new_pal_code[match_pico_c] = pal_code[match_c]
			del(remaining_new_c, match_c)
			del(remaining_pico_c, match_pico_c)
		end
	end

	-- Add remaining colors
	for i = 1, #remaining_new_c do
		local c = remaining_new_c[i]
		local dest = 1
		while new_pal_code[dest] do
			dest += 1
		end
		new_pal_code[dest] = pal_code[c]
		dest += 1
	end
	
	for c = 0, 63 do
		set_color(c, new_pal_code[c] or 0x000000)
	end
	rebuild_pal()
end


function find_blackest_and_whitest()
	local min_lum = 1.0
	local best_black = 0
	local max_lum = 0.0
	local best_white = 1
	for c = 0, 63 do
		if pal_okhsl[c].l < min_lum then
			best_black = c
			min_lum = pal_okhsl[c].l
		end
		if pal_okhsl[c].l > max_lum then
			best_white = c
			max_lum = pal_okhsl[c].l
		end
	end
	return best_black, best_white
end
:: src/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTAzIDE4OjA3OjM0IixzdG9yZWQ9IjIwMjQtMDQt
MDMgMTg6MDc6MzQiXV1sejQABAAAAAMAAAAwbmls
:: todo.txt
--[[pod_format="raw",created="2024-03-31 20:08:43",modified="2024-04-04 10:05:39",revision=862]]
- text entry for hex code
- "New Empty Palette" in menu;
- right click for fine-tuning colors;
- undo/redo;
- accept drag-and-drop (or copy/pasting) of gfx;
- import the palette from an image saved by
  the #paint cartridge;
- write manual, and add it to menu;

Maybe:
- reorder colors by drag-and-drop (i.e. swap two
  colors)
- multi-selection (ability to move a group of
  colors in the sliders)
- Add another tab in the test zone, with the 
  hue/sat circle and sat/lum square, but filles
  with color zones instead of dots.
:: .info.pod
b64$LS1bW3BvZCxhdXRob3I9ImRyYWttYW5pc28iLGljb249dXNlcmRhdGEoInU4IiwxNiwxNiwi
MDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDcw
NzAxMDAwMDAwMDEwNzBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwMTAwMDEwNzBkMGQwZDBkMGQwZDBk
MGQwZDBkMGQwZDA3MDEwMTA3MGQwZDAxMDEwNjA2MDcwNzA2MDYwZDBkMDcwMTAxMDcwZDBkMDEw
MTA2MDYwNzA3MDYwNjBkMGQwNzAxMDEwNzBkMGQwNjA2MGQwZDAxMDEwNzA3MGQwZDA3MDEwMTA3
MGQwZDA2MDYwZDBkMDEwMTA3MDcwZDBkMDcwMTAxMDcwZDBkMDcwNzA2MDYwNzA3MDEwMTBkMGQw
NzAxMDEwNzBkMGQwNzA3MDYwNjA3MDcwMTAxMGQwZDA3MDEwMTA3MGQwZDBkMGQwZDBkMGQwZDBk
MGQwZDBkMDcwMTAxMDYwNzBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwNjAxMDEwNjA2MDcwNzA3MDcw
NzA3MDcwNzA3MDcwNjA2MDEwMDAxMDYwNjA2MDYwNjA2MDYwNjA2MDYwNjA2MDEwMDAwMDAwMTA2
MDYwNjA2MDYwNjA2MDYwNjA2MDEwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAi
KSxub3Rlcz0iQSBwYWxldHRlIGVkaXRvci4iLHJ1bnRpbWU9NSxzdG9yZWQ9IjIwMjQtMDQtMDQg
MTY6Mjc6MDMiLHRpdGxlPSJPa1BBTCIsdmVyc2lvbj0iMC4wLjQiLHdvcmtzcGFjZXM9e3tsb2Nh
dGlvbj0ibWFpbi5sdWEjNjAiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InNyYy9ndWku
bHVhIzYyMCIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ic3JjL2hleGRpYWxvZy5sdWEj
MzAiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InNyYy9nbG9iYWxzLmx1YSMxMyIsd29y
a3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ic3JjL3BhbGV0dGUubHVhIzM5Iix3b3Jrc3BhY2Vf
aW5kZXg9MX0se2xvY2F0aW9uPSJzcmMvcmVtYXAubHVhIzk3Iix3b3Jrc3BhY2VfaW5kZXg9MX0s
e2xvY2F0aW9uPSJnZngvMC5nZngiLHdvcmtzcGFjZV9pbmRleD0yfSx7bG9jYXRpb249Im1hcC8w
Lm1hcCIsd29ya3NwYWNlX2luZGV4PTN9LHtsb2NhdGlvbj0ic2Z4LzAuc2Z4Iix3b3Jrc3BhY2Vf
aW5kZXg9NH0se2xvY2F0aW9uPSJwYWwvMC5wYWwiLHdvcmtzcGFjZV9pbmRleD03fX1dXWx6NAAE
AAAAAwAAADBuaWw=
:: [eoc]
